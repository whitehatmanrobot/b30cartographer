* pszReqArguments, [out] int* pnCount);
    [id(12)] HRESULT GetRequiredAttributes([in] int nAttribute, [out] char*** pszReqAttributes, [out] int* pnCount);
    [id(13)] HRESULT GetRequiredClassAttributes([in] int nAttribute, [out] char*** pszReqClassAttrs, [out] int* pnCount);
    [id(14)] HRESULT GetArgumentRequiredAttributes([in] int nAttribute, [out] char*** keys, [out] char*** reqargs, [out] int* maxdim, [out] int** pcount, [out] int* count);
    [id(15)] HRESULT GetInvalidAttributes([in] int nAttribute, [out] char*** pszReqAttributes, [out] int* pnCount);
    [id(16)] HRESULT GetInvalidClassAttributes([in] int nAttribute, [out] char*** pszReqClassAttrs, [out] int* pnCount);
    [id(17)] HRESULT GetArgumentInvalidAttributes([in] int nAttribute, [out] char*** keys, [out] char*** invargs, [out] int* maxdim, [out] int** pcount, [out] int* count);        
    [id(18)] HRESULT GetHelpString([in] int nAttribute, [in] int nArgument, [out] BSTR* pszHelpString);
    [id(19)] HRESULT GetAttributeHelpString([in] int nAttribute, [out] char** pszHelpString);
    [id(20)] HRESULT GetArgumentHelpString([in] int nAttribute, [in] int nArgument, [out] char** pszHelpString);
    [id(21)] HRESULT GetMeta([in] int nAttribute, [in]char* pszMetaType, [out] char** ppszArguments);
    [id(22)] HRESULT GetVariableArguments([in] int nAttribute, [out] BOOL* pbVarArgs);
    [id(23)] HRESULT AttributeToInt([in] const char* attr, [out, retval] int* idx);
    [id(24)] HRESULT GetShipping([in] int nAttribute, [out] BOOL* pbShipping);
    [id(25)] HRESULT GetVersion([out] DWORD* pmajor, [out] DWORD* pminor);
    [id(26)] HRESULT GetNames([out] char** provname, [out] char** provguid);
    [id(27)] HRESULT GetMultiValue([in] int nAttribute, [in] int nArgument, [out] BOOL* pbMultivalue);
    [id(28)] HRESULT GetArgumentRepeatable([in] int nAttribute, [in] int nArgument, [out] BOOL* pbRepeatable);
    [id(29)] HRESULT GetExplicitArguments([in] int nAttribute, [out] BOOL* pbExplicitArgs);
};

[
    object,
    uuid(64626786-83F5-11d2-B8DA-00C04F799BBB),
    helpstring("IAttributeHandler Interface"),
    pointer_default(unique)
]
__interface IAttributeHandler : IUnknown
{
    [id(1), helpstring("method ParseAttributes")] 
    HRESULT ParseAttributes(
        [in] ICompiler* pcxxfe, 
        [in, size_is(count)] struct Attribute* attr,
        [in] int count,
        [in] int usage);
    [id(2), helpstring("method OnEvent")] 
    HRESULT OnEvent([in] ICompiler* pcxxfe, [in] Event e);
    [id(3), helpstring("method CreateInstance")] 
    HRESULT CreateInstance(
        [in] int eFlags, 
        [out] IAttributeHandler** ppHandler, 
        [out] IAttributeGrammar** ppGrammar);
};


[
    module(name="CompilerLib",
           uuid="6462678F-83F5-11d2-B8DA-00C04F799BBB",
           version="1.0",
           helpstring="Compiler 1.0 Type Library")
];

CASSERT(CC_BLDWITH61_IDLATTR);

#define Compiler CCompiler
#define DefaultHandler CDefaultHandler
#define ProvProv CProvProv
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\group.h ===
#if !defined(__GROUP_H__)
#define __GROUP_H__

typedef enum tagGroupType {
    eCPlusPlusGroup         = 0x0,
    eModuleGroup            = 0x1,
    eInterfaceGroup         = 0x2,
    eComGroup               = 0x3,
    eComPlusMetaDataGroup   = 0x4,
    eControlGroup           = 0x5,
    eWindowGroup            = 0x6,
    eRegistryGroup          = 0x7,
    eDBConsumerGroup        = 0x8,
    eDBProviderGroup        = 0x9,
    eStockPMEGroup          = 0xA,
    eDebugGroup             = 0xB,
    eDHTMLGroup             = 0xC,
    eCompilerGroup          = 0xD,
    eIDLGroup               = 0xE,
    eUserDefinedGroup       = 0xF,
    eHPS                    = 0x10,
    eMaxGroup               = 0x11
} GroupType;

static GroupType GroupTypeVector[eMaxGroup] = {
    eCPlusPlusGroup,
    eModuleGroup,
    eInterfaceGroup,
    eComGroup,
    eComPlusMetaDataGroup,
    eControlGroup,
    eWindowGroup,
    eRegistryGroup,
    eDBConsumerGroup,
    eDBProviderGroup,
    eStockPMEGroup,
    eDebugGroup,
    eDHTMLGroup,
    eCompilerGroup,
    eIDLGroup,
    eUserDefinedGroup,
    eHPS
};

static const char* GroupTypeStrings[eMaxGroup] = {
    "C++",
    "Module",
    "Interface",
    "COM",
    "COM+",
    "Controls",
    "Windowing",
    "Registry",
    "OLE DB Consumer",
    "OLE DB Provider",
    "Stock PME",
    "Internal/Debug",
    "DHTML",
    "Compiler",
    "IDL",
    "User Defined",
    "ATL Server"
};

inline GroupType GetGroupType(char* val) {
    if (strcmp(val, "eCPlusPlusGroup") == 0) {
            return eCPlusPlusGroup;
    } else if (strcmp(val, "eModuleGroup") == 0) {
            return eModuleGroup;
    } else if (strcmp(val, "eInterfaceGroup") == 0) {
            return eInterfaceGroup;
    } else if (strcmp(val, "eComGroup") == 0) {
            return eComGroup;
    } else if (strcmp(val, "eComPlusMetaDataGroup") == 0) {
            return eComPlusMetaDataGroup;
    } else if (strcmp(val, "eControlGroup") == 0) {
            return eControlGroup;
    } else if (strcmp(val, "eWindowGroup") == 0) {
            return eWindowGroup;
    } else if (strcmp(val, "eRegistryGroup") == 0) {
            return eRegistryGroup;
    } else if (strcmp(val, "eDBConsumerGroup") == 0) {
            return eDBConsumerGroup;
    } else if (strcmp(val, "eDBProviderGroup") == 0) {
            return eDBProviderGroup;
    } else if (strcmp(val, "eStockPMEGroup") == 0) {
            return eStockPMEGroup;
    } else if (strcmp(val, "eDebugGroup") == 0) {
            return eDebugGroup;
    } else if (strcmp(val, "eDHTMLGroup ") == 0) {
            return eDHTMLGroup  ;
    } else if (strcmp(val, "eCompilerGroup") == 0) {
            return eCompilerGroup;
    } else if (strcmp(val, "eIDLGroup") == 0) {
            return eIDLGroup;
    } else if (strcmp(val, "eUserDefinedGroup") == 0) {
            return eUserDefinedGroup;
    } else if (strcmp(val, "eHPS") == 0) {
            return eHPS;
    } else {
        char buf[512];
        sprintf(buf, "'%s': incorrect format for attribute \'group\'", val);
#if VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG
        error(C2338, buf);
#else
        printf("%s\n", buf);
#endif
        DASSERT(UNREACHED);
        return eCPlusPlusGroup;
    }
}

#endif // __GROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\usage_dat.h ===
DAT(eAnyUsage,                0x000000, "anything")
DAT(eCoClassUsage,            0x000001, "coclasses")
DAT(eCOMInterfaceUsage,       0x000002, "COM interfaces")
DAT(eInterfaceUsage,          0x000004|eCOMInterfaceUsage, "interfaces")
DAT(eMemberUsage,             0x000008, "members")
DAT(eMethodUsage,             0x000010, "methods")
DAT(eInterfaceMethodUsage,    0x000020, "interface methods")
DAT(eCoClassMemberUsage,      0x000040, "coclass members")
DAT(eCoClassMethodUsage,      0x000080, "coclass methods")
DAT(eGlobalMethodUsage,       0x000100, "global methods")
DAT(eGlobalDataUsage,         0x000200, "global data")
DAT(eClassUsage,              0x000400, "classes") // any struct or class (non-coclass) but not typedef, union, enum, coclass or interface
DAT(eInterfaceParameterUsage, 0x000800, "interface method parameters") // interface function formals only
DAT(eMethodParameterUsage,    0x001000|eInterfaceParameterUsage, "method parameters") // function formals only
DAT(eIDLModuleUsage,          0x002000, "idl_module methods")
DAT(eAnonymousUsage,          0x004000, "anonymous attribute blocks")
DAT(eTypedefUsage,            0x008000, "typedefs")
DAT(eUnionUsage,              0x010000, "unions")
DAT(eEnumUsage,               0x020000, "enums")
DAT(eDefineTagUsage,          0x040000, "UDT definitions")
DAT(eStructUsage,             0x080000, "structs")
DAT(eLocalUsage,              0x100000, "local variables")
DAT(ePropertyUsage,           0x200000, "properties")
DAT(eEventUsage,              0x400000, "events")
DAT(eTemplateUsage,           0x800000, "templates")
DAT(eModuleUsage,             0x1000000, "modules") // Not real -- nothing should have module usage
DAT(eIllegalUsage,            0x2000000, "illegal usage")
DAT(eAsynchronousUsage,       0x4000000, "asynchronous usage")
DAT(eAnyIDLUsage,             0x1FBFFF, "anything but anonymous, property, event, asynchronous and template") // eAnyUsage - eAnonymousUsage - eTemplateUsage - ePropertyUsage - eEventUsage - eAsynchronousUsage
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\crefobj.h ===
/*
 * CRefCountedObj
 *
 */

#pragma once

#if !defined(_CRefCountedObj_h)
#define _CRefCountedObj_h

#if defined(_DEBUG)
#define	Debug(x)	x
#else
#define	Debug(x)
#endif

// handles ref counted garbage collection and dyncasting

class CRefCountedObj {
private:
    unsigned	_cUses;

public:

    CRefCountedObj() {
        _cUses = 0;
        }

	// copy ctor, does not copy usage count of object being copied from
	CRefCountedObj ( const CRefCountedObj & ) {
		_cUses = 0;
		}

    // virtual dtor should cause all descendents of CRefCountedObj have to have a virtual dtor
    virtual ~CRefCountedObj() { }

	CRefCountedObj & operator= ( const CRefCountedObj & ) {
		return *this;
		}

	unsigned CUses() {
		return _cUses;
		}

    void Use() {
        _cUses++;
        }

    bool FUnUse() {
        return !(--_cUses);
        }
};

template <class T>
class RefCount : public CRefCountedObj, public T {
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\bsc.h ===
//
// bsc.h
//
// interface to browser information in a .PDB file
//

#ifndef __BSC_INCLUDED__
#define __BSC_INCLUDED__

#include <pdb.h>

typedef ULONG  IINST;
typedef ULONG  IREF;
typedef ULONG  IDEF;
typedef USHORT IMOD;

#define irefNil  ((IREF)-1)
#define idefNil  ((IDEF)-1)
#define iinstNil ((IINST)-1)

#define HTARGET ULONG_PTR

// The constant IINST value for the "Globals" class
#define IINST_GLOBALS	0xFFFF0001
#define isTheGlobalIinst(iinst) ((iinst) == IINST_GLOBALS)

typedef USHORT LINE;
typedef BYTE   TYP;

typedef USHORT ATR;
typedef ULONG  ATR32;

typedef ULONG MBF;

enum OPERATION
{
	addOp,
	delOp,
	changeOp,
	changeIinstOp,
	refreshAllOp,
	noOp
};

struct IinstInfo
{
	IINST m_iinst;
	SZ_CONST m_szName; // REVIEW: must be deleted (use Ni instead)!
	NI	m_ni; 
};

struct NiQ
{
    IINST m_iinstOld;
	IinstInfo m_iInfoNew;
	OPERATION m_op;
	TYP		m_typ;
};

typedef BOOL (*pfnNotifyChange) (NiQ * rgQ, ULONG cQ, HTARGET hTarget);

#define OUT

PdbInterface Bsc
{
	// open by name or by .pdb 
	static  PDBAPI(BOOL) open(PDB* ppdb, OUT Bsc** ppbsc);
	static 	PDBAPI(BOOL) open(SZ szName, OUT Bsc** ppbsc);
	virtual BOOL close() pure;

	// primitives for getting the information that underlies a handle
	virtual BOOL iinstInfo(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr) pure;
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL idefInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule) pure;
	virtual SZ   szFrTyp(TYP typ) pure;
	virtual SZ   szFrAtr(ATR atr) pure;

	// primitives for managing object instances (iinst)
	virtual BOOL getIinstByvalue(SZ sz, TYP typ, ATR atr, OUT IINST *piinst) pure;
	virtual BOOL getOverloadArray(SZ sz, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;	
	virtual BOOL getUsedByArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getUsesArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getBaseArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getDervArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst)  pure;
	virtual BOOL getMembersArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;

	// primitives for getting definition and reference information	
	virtual BOOL getDefArray(IINST iinst, OUT IREF **ppidef, OUT ULONG *pciidef) pure;
	virtual BOOL getRefArray(IINST iinst, OUT IREF **ppiref, OUT ULONG *pciiref) pure;

	// primitives for managing source module contents
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod) pure;
	virtual BOOL getAllModulesArray(OUT IMOD **ppimod, OUT ULONG *pcimod) pure;
	
	// call this when a computed array is no longer required
	virtual void disposeArray(void *pAnyArray) pure;

	// call this to get a pretty form of a decorated name	
	virtual SZ  formatDname(SZ szDecor) pure;
	
	// call this to do category testing on instances
	virtual BOOL fInstFilter(IINST iinst, MBF mbf) pure;

	// primitives for converting index types
	virtual IINST iinstFrIref(IREF) pure;
	virtual IINST iinstFrIdef(IDEF) pure;
	virtual IINST iinstContextIref(IREF) pure;

	// general size information
	virtual	BOOL getStatistics(struct BSC_STAT *) pure;
	virtual	BOOL getModuleStatistics(IMOD, struct BSC_STAT *) pure;

	// case sensitivity functions
	virtual BOOL fCaseSensitive() pure;
	virtual BOOL setCaseSensitivity(BOOL) pure;

	// handy common queries which can be optimized
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IinstInfo **ppiinstinfo, OUT ULONG *pciinst) pure;

	// needed for no compile browser
	// get parameters (iinst must be a function type)
	virtual SZ  getParams (IINST iinst) pure;
	virtual USHORT getNumParam (IINST iinst) pure;
	virtual SZ getParam (IINST iinst, USHORT index) pure;
	// get return type/variable type
	virtual SZ  getType (IINST iinst) pure;
	// register call back for notification
	// THIS SHOULD BE DELETED SOON!
	virtual BOOL regNotify (pfnNotifyChange pNotify) pure;
	// register to make sure that NCB will create change queue
	virtual BOOL regNotify () pure;
	virtual BOOL getQ (OUT NiQ ** ppQ, OUT ULONG * pcQ) pure;
	virtual BOOL checkParams (IINST iinst, SZ * pszParam, ULONG cParam) pure;
	virtual BOOL fHasMembers (IINST iinst, MBF mbf) pure;
	
	// needed for class view for optimization
	virtual SZ szFrNi (NI ni) pure;
	virtual BOOL niFrIinst (IINST iinst, NI *ni) pure;
	virtual BOOL lock() pure;
	virtual BOOL unlock() pure;

    // Methods allowing usage of big ATR field
	virtual SZ   szFrAtr2(ATR32 atr) pure;
	virtual BOOL iinstInfo2(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr) pure;
	virtual BOOL getIinstByvalue2(SZ sz, TYP typ, ATR32 atr, OUT IINST *piinst) pure;
};

struct BSC_STAT
{
	ULONG	cDef;
	ULONG	cRef;
	ULONG	cInst;
	ULONG	cMod;
	ULONG	cUseLink;
	ULONG	cBaseLink;
};


// CBSCLock
//
// Note, Bsc::lock returns BOOL, however, from current usage, the result is never tested, so
// this class assumes it need not be tested.
//

class CBSCLock
{
private :

	Bsc * const m_pBsc;

public :

	CBSCLock(Bsc * const pBsc) : m_pBsc(pBsc)	{ if (m_pBsc) m_pBsc->lock();	}
	~CBSCLock(void)								{ if (m_pBsc) m_pBsc->unlock();	}
};


// these are the bit values for Bsc::instInfo()

// this is the type part of the result, it describes what sort of object
// we are talking about.  Note the values are sequential -- the item will
// be exactly one of these things
//

#define INST_TYP_FUNCTION       0x01
#define INST_TYP_LABEL          0x02
#define INST_TYP_PARAMETER      0x03
#define INST_TYP_VARIABLE       0x04
#define INST_TYP_CONSTANT       0x05
#define INST_TYP_MACRO          0x06
#define INST_TYP_TYPEDEF        0x07
#define INST_TYP_STRUCNAM       0x08
#define INST_TYP_ENUMNAM        0x09
#define INST_TYP_ENUMMEM        0x0A
#define INST_TYP_UNIONNAM       0x0B
#define INST_TYP_SEGMENT        0x0C
#define INST_TYP_GROUP          0x0D
#define INST_TYP_PROGRAM        0x0E
#define INST_TYP_CLASSNAM       0x0F
#define INST_TYP_MEMFUNC        0x10
#define INST_TYP_MEMVAR         0x11
#define INST_TYP_INCL           0x12
#define INST_TYP_MSGMAP         0x13
#define INST_TYP_MSGITEM        0x14
#define INST_TYP_DIALOGID       0x15 // dialog ID for MFC
// idl stuff
#define INST_TYP_IDL_ATTR       0x16 // idl attributes are stored as iinst
#define INST_TYP_IDL_COCLASS    0x17
#define INST_TYP_IDL_IFACE      0x18
#define INST_TYP_IDL_DISPIFACE  0x19
#define INST_TYP_IDL_LIBRARY    0x1A
#define	INST_TYP_IDL_MODULE     0x1B
#define INST_TYP_IDL_IMPORT     0x1C
#define INST_TYP_IDL_IMPORTLIB  0x1D
#define INST_TYP_IDL_MFCCOMMENT 0x1E // idl interface/dispinterface can have mfc comment
// java stuff
#define INST_TYP_JAVA_IFACE     0x1F // java (NOT COM) interfaces
// 0x20 to 0x30 left for Java
// some more C++ stuff
#define INST_TYP_TEMPLATE       0x31
#define INST_TYP_NAMESPACE      0x32
#define INST_TYP_IMPORT         0x33
#define INST_TYP_BASECLASS      0x34
#define INST_TYP_ATTRIBUTE      0x35
#define INST_TYP_INTERFACE      0x36
#define INST_TYP_PROPERTY       0x37 // MC++ __property
#define INST_TYP_NSALIAS        0x38 // Namespace alias
#define INST_TYP_ASSEMBLY       0x39 // #using of an assembly

// these are the attributes values, they describes the storage
// class and/or scope of the instance.  Any combination of the bits
// might be set by some language compiler, but there are some combinations
// that don't make sense.

#define INST_ATR_LOCAL       0x001
#define INST_ATR_STATIC      0x002
#define INST_ATR_SHARED      0x004
#define INST_ATR_NEAR        0x008
#define INST_ATR_COMMON      0x010
#define INST_ATR_DECL_ONLY   0x020
#define INST_ATR_PUBLIC      0x040
#define INST_ATR_NAMED       0x080
#define INST_ATR_MODULE      0x100
#define INST_ATR_VIRTUAL     0x200
#define INST_ATR_PRIVATE     0x400
#define INST_ATR_PROTECT     0x800

#define IMODE_VIRTUAL        0x001
#define IMODE_PRIVATE        0x002
#define IMODE_PUBLIC         0x004
#define IMODE_PROTECT        0x008

#define mbfNil       0x000
#define mbfVars      0x001
#define mbfFuncs     0x002
#define mbfMacros    0x004
#define mbfTypes     0x008
#define mbfClass     0x010
#define mbfIncl      0x020
#define mbfMsgMap    0x040
#define mbfDialogID  0x080
#define mbfLibrary   0x100
#define mbfImport    0x200
#define mbfTemplate  0x400
#define mbfNamespace 0x800
#define mbfAll       0xFFF

// BOB = browser object, general index holder 

typedef ULONG BOB;

#define bobNil 0L

typedef USHORT CLS;

#define clsMod  1
#define clsInst 2
#define clsRef  3
#define clsDef  4

#define BobFrClsIdx(cls, idx)  ((((ULONG)(cls)) << 28) | (idx))
#define ClsOfBob(bob)	(CLS)((bob) >> 28)

#define ImodFrBob(bob)	((IMOD) ((bob) & 0xfffffffL))
#define IinstFrBob(bob)	((IINST)((bob) & 0xfffffffL))
#define IrefFrBob(bob)	((IREF) ((bob) & 0xfffffffL))
#define IdefFrBob(bob)	((IDEF) ((bob) & 0xfffffffL))

#define BobFrMod(x)  (BobFrClsIdx(clsMod,  (x)))
#define BobFrInst(x) (BobFrClsIdx(clsInst, (x)))
#define BobFrRef(x)  (BobFrClsIdx(clsRef,  (x)))
#define BobFrDef(x)  (BobFrClsIdx(clsDef,  (x)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cpdbase.h ===
//------------------------------------------------------------------------------
// CPDBASE.H
//
// Definitions of classes and interfaces used for the "Class Path Database"
//------------------------------------------------------------------------------
#ifndef _CPDBASE_INCLUDED
#define _CPDBASE_INCLUDED

#include "clstypes.h"
#include "cpdguid.h"

interface   ICPDatabase;
interface   IPackage;
interface   IClass;
interface   IInputStream;

typedef ICPDatabase     *LPCPDATABASE;
typedef IPackage        *LPPACKAGE;
typedef IClass          *LPCLASS;
typedef IInputStream    *LPINPUTSTREAM;


//------------------------------------------------------------------------------
// ICPDatabase
//
// This interface is the "entry point" to the class database.  It is used to
// configure the classpath, and to find specific classes/packages (or get the
// entire list of them) in the "root" of the CLASSPATH.  It also holds central
// functionality such as releasing arrays/memory allocated by this and other
// interfaces dealing with the class path database.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE ICPDatabase

DECLARE_INTERFACE_(ICPDatabase, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICPDatabase methods
	
	// CLASSPATH management (note:  GetClassPath returns allocated data -- use FreeMemory to release)
	STDMETHOD(SetClassPath)(THIS_ PCSTR pszClassPath) PURE;
	STDMETHOD(AppendClassPath)(THIS_ PCSTR pszAppendPath) PURE;
	STDMETHOD(PrependClassPath)(THIS_ PCSTR pszPrependPath) PURE;
	STDMETHOD(RemoveClassPath)(THIS_ PCSTR pszRemovePath) PURE;
	STDMETHOD(GetClassPath)(THIS_ PSTR *ppszClassPath) PURE;
	
	// Archive locking means speed improvement.  It also means any .ZIP or other
	// single-file archives that are classpath roots will remain open throughout
	// use of the database, or until unlocked
	STDMETHOD_(VOID, LockArchives)(THIS) PURE;
	STDMETHOD_(VOID, UnlockArchives)(THIS) PURE;
	
	// Find specific packages or classes.  Note that the IPackage or IClass pointers returned
	// here should be Release()'d
	STDMETHOD(FindPackage)(THIS_ PCSTR pszPackageName, LPPACKAGE *ppPackage) PURE;
	STDMETHOD(FindClass)(THIS_ PCSTR pszClassName, LPCLASS *ppClass) PURE;
	
	// Given a file name, create a class interface
	STDMETHOD(GetClass)(THIS_ PCSTR pszClassFileName, LPCLASS *ppClass) PURE;
	
	// Package/class array access.  Release these arrays with appropriate Release*Array()
	// members below -- do NOT call Release() on each element!
	STDMETHOD(GetPackageArray)(THIS_ LPPACKAGE **pppPackages, LPINT piCount) PURE;
	STDMETHOD(GetClassArray)(THIS_ LPCLASS **pppClasses, LPINT piCount) PURE;
	
	// Find all occurances of a specific class name, searching all packages.  Note that
	// an array is returned, which must also be freed using ReleaseClassArray().
	STDMETHOD(GetClassArray)(THIS_ PCSTR pszClassName, LPCLASS **pppClasses, LPINT piCount) PURE;
	
	// Array release mechanism.  Note:  These release functions should be used to
	// release arrays obtained thru IPackage::GetPackageArray/GetClassArray as well.
	// Elements of these arrays should NOT be Release()'d individually unless they
	// are AddRef()'d first (for individual extension of their lifetimes)
	STDMETHOD(ReleasePackageArray)(THIS_ LPPACKAGE *ppPackages) PURE;
	STDMETHOD(ReleaseClassArray)(THIS_ LPCLASS *ppClasses) PURE;
	
    // Allocated memory release mechanism -- note that this should be used to
    // free memory returned by members of this interface as well as IPackage and
    // IClass that are noted as returning allocated memory
    STDMETHOD(FreeMemory)(THIS_ PVOID pData) PURE;
};


//------------------------------------------------------------------------------
// IPackage
//
// This interface is used to represent a package on the CLASSPATH, and its
// primary purpose is to provide subpackage and class finding/iteration.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IPackage

DECLARE_INTERFACE_(IPackage, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPackage methods

	// Find specific packages or classes.  Note that the IPackage or IClass pointers returned
	// here should be Release()'d
	STDMETHOD(FindPackage)(THIS_ PCSTR pszPackageName, LPPACKAGE *ppPackage) PURE;
	STDMETHOD(FindClass)(THIS_ PCSTR pszClassName, LPCLASS *ppClass) PURE;

	// Package/class array access.  Release these arrays with appropriate Release*Array()
	// members in ICPDatabase -- do NOT call Release() on each element!
	STDMETHOD(GetPackageArray)(THIS_ LPPACKAGE **pppPackages, LPINT piCount) PURE;
	STDMETHOD(GetClassArray)(THIS_ LPCLASS **pppClasses, LPINT piCount) PURE;
	
    // Package name
    STDMETHOD_(PCSTR, GetName)(THIS) PURE;

    // Full name (i.e. if this is package lang, full name is "java.lang")
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetFullName)(THIS_ PSTR *pszFullName) PURE;
};

//------------------------------------------------------------------------------
// IClass
//
// This interface represents a class found on the CLASSPATH.  Provides access to
// all information about the class.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IClass

DECLARE_INTERFACE_(IClass, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IClass methods

    // Class name
    STDMETHOD_(PCSTR, GetName)(THIS) PURE;

    // Qualified (dotted) name.  Includes package name.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetQualifiedName)(THIS_ PSTR *pszQualifiedName) PURE;

    // File name.  If this class is represented by a physical file on disk
    // (as opposed to one found in an archive or elsewhere) the full path name
    // of that file can be obtained here.  E_FAIL is returned if not.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetFileName)(THIS_ PSTR *pszFileName) PURE;

    // Source file name.  If this class is represented by a physical file on
    // disk, the full path name of its source file can be obtained here.  E_FAIL
    // is returned if the class doesn't have a source that is represented by
    // a single disk file (i.e. the source might be in an archive as well, in
    // which case a full path to it doesn't make sense).  Note:  The class
    // information itself is opened and the attributes are searched to determine
    // the source file name.  In the interesting case where only the .java file
    // is found along the class path (.class file doesn't exist), the full path
    // to that .java file is returned, even though it *might not* necessarily
    // generate an output with the same name.  Note also that the file does not
    // have to exist for this to succeed.
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetSourceFileName)(THIS_ PSTR *pszSourceName) PURE;

    // "Moniker" -- a somewhat-human-readable name that describes where this
    // class originates.  Disk files are just the absolute file name (same as
    // GetFileName), archive files might be something that looks like
    // "archive.zip(dir1\dir2\file.ext)", etc...
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetMoniker)(THIS_ PSTR *pszMoniker) PURE;

    // Ditto for source
    // (allocated -- use ICPDatabase::FreeMemory to release)
    STDMETHOD(GetSourceMoniker)(THIS_ PSTR *pszMoniker) PURE;

    // Dependency checking between source and output.  This method returns TRUE
    // only if the class's source file is available as a single disk file, and
    // either:
    //  1) The .class file doesn't exist, or
    //  2) The .class file is older than the .java file
    // Returns FALSE in all other cases.
    STDMETHOD_(BOOL, IsOutOfDate)(THIS) PURE;

    // Direct class data access.  If this class is represented by a stream of
    // bytes in the class file format, an input stream interface is returned
    // for direct access to that stream.  E_FAIL is returned if no such file
    // exists.
    STDMETHOD(GetClassInputStream)(THIS_ LPINPUTSTREAM *ppStream) PURE;

    // Source file stream access.  Note that this may succeed when
    // GetSourceFileName() may not, since the source may be found in an archive
    STDMETHOD(GetSourceInputStream)(THIS_ LPINPUTSTREAM *ppStream) PURE;

    // Class data access.  Availability of class data depends on "completeness"
    // of the Open() call.  If fFullOpen is TRUE, all data is available; if
    // FALSE, you can get the version info and access flags, and queries for
    // other data will return 0/NULL.
    //
    // NOTE:  Everything returned from these methods is maintained by the class,
    // and does NOT need to be released or freed.  Happens automatically on Close().
    STDMETHOD(Open)(THIS_ BOOL fFullOpen = TRUE) PURE;
    STDMETHOD_(VOID, Close)(THIS) PURE;
    STDMETHOD_(U2, GetMajorVersion)(THIS) PURE;
    STDMETHOD_(U2, GetMinorVersion)(THIS) PURE;
    STDMETHOD_(U2, GetCPCount)(THIS) PURE;
    STDMETHOD_(LPCPOOLINFO, GetCPArray)(THIS) PURE;
    STDMETHOD_(U2, GetAccessFlags)(THIS) PURE;
    STDMETHOD_(U2, GetThisClass)(THIS) PURE;
    STDMETHOD_(U2, GetSuperClass)(THIS) PURE;
    STDMETHOD_(U2, GetInterfaceCount)(THIS) PURE;
    STDMETHOD_(U2 *, GetInterfaceArray)(THIS) PURE;
    STDMETHOD_(U2, GetFieldCount)(THIS) PURE;
    STDMETHOD_(LPFIELDINFO, GetFieldArray)(THIS) PURE;
    STDMETHOD_(U2, GetMethodCount)(THIS) PURE;
    STDMETHOD_(LPMETHODINFO, GetMethodArray)(THIS) PURE;
    STDMETHOD_(U2, GetAttributeCount)(THIS) PURE;
    STDMETHOD_(LPATTRINFO, GetAttributeList)(THIS) PURE;
};

//------------------------------------------------------------------------------
// IInputStream
//
// Abstraction over a file, or a section of an archive file, or anything else
// that needs to "look like" a stream of bytes w/ random access capability.
//------------------------------------------------------------------------------
#undef INTERFACE
#define INTERFACE IInputStream

typedef enum { SCP_FROMSTART = FILE_BEGIN, SCP_FROMCURRENT = FILE_CURRENT, SCP_FROMEND = FILE_END } POSRELATION;

DECLARE_INTERFACE_(IInputStream, IUnknown)
{
	// IUnknown methods
	
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	
	// IInputStream methods
	
	// Size of stream
	STDMETHOD_(LONG, GetSize)(THIS) PURE;
	
	// Current position (offset of next byte to be read)
	STDMETHOD_(LONG, GetCurrentPosition)(THIS) PURE;
	STDMETHOD(SetCurrentPosition)(THIS_ LONG iPos, POSRELATION iRel = SCP_FROMSTART) PURE;
	STDMETHOD_(BOOL, EndOfStream)(THIS) PURE;
	
	// Read from current position (piRead:  in=size of pDest, out=bytes read)
	STDMETHOD(Read)(THIS_ PVOID pDest, LONG *piRead) PURE;
	
	// Big-Endian number readers
	STDMETHOD(ReadU2)(THIS_ U2 *piValue) PURE;
	STDMETHOD(ReadU4)(THIS_ U4 *piValue) PURE;
};	


#endif // #ifndef _CPDBASE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\compsym.h ===
#pragma once
#ifndef _COMPSYM_H_
#define _COMPSYM_H_

#if !defined(PdbInterface)
#define PdbInterface struct
#endif

#ifndef IMPORT_EXPORT
#ifndef OBJFILE_IMPL
#define IMPORT_EXPORT __declspec(dllimport)
PdbInterface   ObjectCode;
typedef PdbInterface ObjectCode        ObjectCode;
#else
#define IMPORT_EXPORT __declspec(dllexport)
#endif
#endif

PdbInterface   FunctionSymbols;
PdbInterface   EnumStackSyms;
PdbInterface   StackVariable;

typedef PdbInterface FunctionSymbols   FunctionSymbols;
typedef PdbInterface EnumStackSyms     EnumStackSyms;
typedef PdbInterface StackVariable     StackVariable;

#define COMPSYMAPI __cdecl

#ifdef __cplusplus

// C++ Binding

PdbInterface FunctionSymbols {
    IMPORT_EXPORT static bool COMPSYMAPI
    get( char* szName, ObjectCode* pobj, FunctionSymbols** ppfsyms );

    IMPORT_EXPORT static bool COMPSYMAPI
    get( RefSec& rsec, FunctionSymbols** ppfsyms );

    virtual bool  FGetEnumLocals ( EnumStackSyms ** ) const pure;
    virtual bool  FGetEnumParams ( EnumStackSyms ** ) const pure;
    virtual bool  FGetFrameInfo(  
        unsigned long*  cbFrame, 
        unsigned long*  cbPad,
        unsigned long*  offPad ) const pure;
    virtual void release() pure;
    virtual void Dump() const pure;
};

// stack variable enumerator
PdbInterface EnumStackSyms : public Enum {
    virtual void get( StackVariable ** const ) pure;
};

PdbInterface StackVariable
{
    virtual long offBP() const pure;
    virtual unsigned long typeIndex() const pure;
    virtual unsigned long name( char* szName ) const pure;// if szName ==0 return length, then call again with buffer
    virtual void release() pure;
    virtual void Dump() const pure;
};

#endif  // __cplusplus

// ANSI C Binding

#ifdef __cplusplus
extern "C" {
#endif

IMPORT_EXPORT
BOOL COMPSYMAPI ObjectCodeGet(ObjectCode** ppobj, 
                              DWORD dwMachineTypeExpected, 
                              char* szFileName );
IMPORT_EXPORT
void COMPSYMAPI OCRelease( ObjectCode* pobj );

IMPORT_EXPORT 
BOOL COMPSYMAPI FuncSymsGet(char* szName, ObjectCode* pobj, FunctionSymbols** ppfsyms );
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetFrameInfo(FunctionSymbols* pfuncs, 
                               unsigned long*  cbFrame, 
                               unsigned long*  cbPad,
                               unsigned long*  offPad);
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetEnumParams(FunctionSymbols* pfuncs, 
                                EnumStackSyms** ppesv);
IMPORT_EXPORT 
BOOL COMPSYMAPI FSGetEnumLocals(FunctionSymbols* pfuncs, 
                                EnumStackSyms** ppesv);
IMPORT_EXPORT 
void COMPSYMAPI FSRelease(FunctionSymbols* pfuncs);

IMPORT_EXPORT 
void COMPSYMAPI ESVRelease(EnumStackSyms* pesv);
IMPORT_EXPORT 
void COMPSYMAPI ESVReset(EnumStackSyms* pesv);
IMPORT_EXPORT 
BOOL COMPSYMAPI ESVNext(EnumStackSyms* pesv);
IMPORT_EXPORT 
void COMPSYMAPI ESVGet(EnumStackSyms* pesv, 
            StackVariable **ppsv);

IMPORT_EXPORT 
long COMPSYMAPI SVOffBP(StackVariable * psv);
IMPORT_EXPORT 
unsigned long COMPSYMAPI SVTypeIndex(StackVariable * psv);
IMPORT_EXPORT 
unsigned long COMPSYMAPI SVName(StackVariable * psv, 
                                char* szName ); // if szName ==0 return length, then call again with buffer
IMPORT_EXPORT 
void COMPSYMAPI SVRelease(StackVariable * psv);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cpdguid.h ===
//------------------------------------------------------------------------------
// CPDGUID.H
//------------------------------------------------------------------------------

// {DD669B20-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_ICPDatabase, 0xdd669b20, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B21-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IPackage, 0xdd669b21, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B22-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IClass, 0xdd669b22, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);

// {DD669B23-BF1D-11cf-A45D-00A0C905428A}
DEFINE_GUID(IID_IInputStream, 0xdd669b23, 0xbf1d, 0x11cf, 0xa4, 0x5d, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x8a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\clstypes.h ===
//------------------------------------------------------------------------------
// CLSTYPES.H
//
// Structures and typedefs to ease the life of a class file data reader...
//------------------------------------------------------------------------------
#ifndef _CLSTYPES_INCLUDED
#define _CLSTYPES_INCLUDED

//------------------------------------------------------------------------------
// Access flags
//------------------------------------------------------------------------------
#define ACC_PUBLIC          0x0001
#define ACC_PRIVATE         0x0002
#define ACC_PROTECTED       0x0004
#define ACC_STATIC          0x0008
#define ACC_FINAL           0x0010
#define ACC_SYNCHRONIZED    0x0020
#define ACC_VOLATILE        0x0040
#define ACC_TRANSIENT       0x0080
#define ACC_NATIVE          0x0100
#define ACC_INTERFACE       0x0200
#define ACC_ABSTRACT        0x0400

//------------------------------------------------------------------------------
// Constant tags, also taken from the VM spec
//------------------------------------------------------------------------------
#define CONSTANT_Class                  7
#define CONSTANT_Fieldref               9
#define CONSTANT_Methodref              10
#define CONSTANT_InterfaceMethodref     11
#define CONSTANT_String                 8
#define CONSTANT_Integer                3
#define CONSTANT_Float                  4
#define CONSTANT_Long                   5
#define CONSTANT_Double                 6
#define CONSTANT_NameAndType            12
#define CONSTANT_Utf8                   1
#define CONSTANT_Unicode                2

//------------------------------------------------------------------------------
// Basic types
//------------------------------------------------------------------------------
typedef unsigned char       U1;
typedef unsigned short      U2;
typedef unsigned long       U4;
typedef unsigned __int64    U8;

//------------------------------------------------------------------------------
// Helper structs
//------------------------------------------------------------------------------
struct longdbl
{
    union
    {
        U8      iValue;
        double  fValue;
        struct
        {
            U4  iLow;
            U4  iHigh;
        };
    };
};

//------------------------------------------------------------------------------
// CPINFO -- constant pool entry structure (union).  Note that all values are
// swapped into little-endian for you, but strings are still UTF8...
//------------------------------------------------------------------------------
struct cp_info
{
    U1      iTag;       // CONSTANT_* tag
    union
    {
        struct
        {
            U2      iName;
        } Class;                // CONSTANT_Class;
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } Fieldref;             // CONSTANT_Fieldref
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } Methodref;            // CONSTANT_Methodref
        struct
        {
            U2      iClass;
            U2      iNameAndType;
        } InterfaceMethodref;   // CONSTANT_InterfaceMethodref
        struct
        {
            U2      iIndex;
        } String;               // CONSTANT_String
        struct
        {
            U4      iValue;
        } Integer;              // CONSTANT_Integer
        struct
        {
            float   fValue;
        } Float;                // CONSTANT_Float
        struct
        {
            longdbl *pVal;
        } Long;                 // CONSTANT_Long
        struct _DoubleStruct
        {
            longdbl *pVal;
        } Double;               // CONSTANT_Double
        struct
        {
            U2      iName;
            U2      iSignature;
        } NameAndType;          // CONSTANT_NameAndType
        struct
        {
            U2      iLength;
            U1      *pBytes;
        } Utf8;                 // CONSTANT_Utf8
        struct
        {
            U2      iLength;
            U2      *pBytes;
        } Unicode;              // CONSTANT_Unicode
    };
};

typedef cp_info CPOOLINFO, *LPCPOOLINFO;

//------------------------------------------------------------------------------
// ATTRINFO -- attribute information
//------------------------------------------------------------------------------
struct attribute_info
{
    struct attribute_info   *pNext;
    U2                      iName;
    U4                      iLength;
    U1                      rgBytes[1];
};

typedef attribute_info ATTRINFO, *LPATTRINFO;

//------------------------------------------------------------------------------
// MEMBERINFO -- member information
//------------------------------------------------------------------------------
struct member_info
{
    U2          iAccessFlags;
    U2          iName;
    U2          iSignature;
    LPATTRINFO  pAttrList;
};

typedef member_info MEMBERINFO, *LPMEMBERINFO;


//------------------------------------------------------------------------------
// METHODINFO -- method information
//------------------------------------------------------------------------------
struct method_info : public member_info
{
};

typedef method_info METHODINFO, *LPMETHODINFO;

//------------------------------------------------------------------------------
// FIELDINFO -- field information
//------------------------------------------------------------------------------
struct field_info : public member_info
{
};

typedef field_info FIELDINFO, *LPFIELDINFO;


#endif // #ifndef _CLSTYPES_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\csymbuf.h ===
#ifndef _CSYMBUF_H_
#define _CSYMBUF_H_

#pragma warning( disable: 4786 )

class FuncBuffer;
typedef PROCSYM* PPROCSYM;
typedef PROCSYM32* PPROCSYM32;

//
// SymBuffer
//  understands the representation of cv symbolic information
//  as stored in an object file section. This object supplies
//  an interpretation of an existing buffer, it does not manage
//  the memory itself.
//

class SymBuffer 
{
public:
    typedef unsigned long ULONG;
    typedef ULONG SigType;
    SymBuffer( PB pbFirst = 0, CB cb = 0 ) : m_first( 0 ), m_last( 0 ), m_start( 0 )
    {
        Reset( pbFirst, cb );
    }
    void Reset( PB pbFirst, CB cb ) // set new buffer extent
    {
        m_sigSymsT = 0;
        assert( cb >= 0 );
        if ( pbFirst > 0 ) {
      	    m_sigSymsT = *reinterpret_cast<SigType*>(pbFirst);
            if (  CV_SIGNATURE_C6 < m_sigSymsT && m_sigSymsT < CV_SIGNATURE_RESERVED ) {
                m_first = reinterpret_cast<PSYM>(pbFirst+sizeof(SigType));
            } else {
                m_first = reinterpret_cast<PSYM>(pbFirst);
            }
        }
        m_last = reinterpret_cast<PSYM>(pbFirst+cb);
        m_start = pbFirst;
    }

    typedef PSYM _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    SYMTYPE& operator*() const
		    {return *_Ptr; }
	    SYMTYPE* operator->() const
		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = NextSym(_Ptr);
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator findNextProcSyms( iterator it, FuncBuffer& rfb );
    iterator findNextFileSym( iterator it );

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_last ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_last ); }

    bool empty() const { return begin() == end(); }
    
    CB offSym( PSYM psym ) 
    { 
        return CB(asPb(psym)-pbfirst());    // REVIEW:WIN64 cast
    }
    PSYM cvsymOff( CB off )
    {
        return asPsym( pbfirst()+off );
    }
    SigType signature() { return m_sigSymsT; }

    template <class T> 
    bool findSym( int s, T** t )
    {
        for ( iterator it = begin(); it != end(); ++it ) {
            if (it->rectyp == (unsigned)s) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }

    template <class T> 
    bool findNextSym( int s, T** t, iterator& it )
    {
        for ( ; it != end(); ++it ) {
            if ( it->rectyp == (unsigned)s ) {
                if ( t ) *t = reinterpret_cast<T*>(&*it);
                return true;
            }
        }
        return false;
    }
    CB Count() { return CB(PB( m_last ) - m_start); /* REVIEW:WIN64 cast */ }
    PB Base() { return m_start; }
    virtual PB pbStart() { return m_start; }
    void updateOffsets();
    void updateTypeServer( USHORT itsm );

protected:
     _Nodeptr first() const { return m_first; }
     _Nodeptr last() const { return m_last; }
     PB pbfirst() const { return asPb(m_first); }
    static inline PB asPb( PSYM psym ) { return reinterpret_cast<PB>( psym ); }
    static inline PSYM asPsym( PB pb ) { return reinterpret_cast<PSYM>( pb ); }
   
private:
    friend FuncBuffer;
    PB m_start;
    _Nodeptr m_first;
    _Nodeptr m_last;  // actually, one past the last byte of the buffer
    SigType m_sigSymsT;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\comenvi.h ===
#ifndef __COMENVI_H__
#define __COMENVI_H__

//
// Class to interpret a buffer containing a list of null
// strings. List is terminated with a 0.
//

template <class T>
inline const T* EndStr( const T* sz );

template <class T>
class StrList   // input must be formatted correctly
{
public:
    StrList( const T* pStart )
        : m_first( pStart )
    {
        for ( m_end = pStart; m_end != 0 && *m_end != 0; m_end = EndStr( m_end ) )
            ;
    }

    unsigned long Count() const {
        unsigned long i=0;
        for ( iterator it = begin(); it != end(); ++it )
            ++i;
        return i;
    }

    typedef const T* _Nodeptr;

    class iterator  // based on STL forward iterator
    {
    public:
	    iterator()
		    {}
	    iterator(_Nodeptr _P)
		    : _Ptr(_P) {}
	    const T& operator*() const
		    {return *_Ptr; }
//	    const T* operator->() const
//		    {return (&**this); }
	    iterator& operator++()
		    {_Ptr = EndStr( _Ptr );
		    return (*this); }
	    iterator operator++(int)
		    {iterator _Tmp = *this;
		    ++*this;
		    return (_Tmp); }
	    bool operator==(const iterator& _X) const
		    {return (_Ptr == _X._Ptr); }
	    bool operator!=(const iterator& _X) const
		    {return (!(*this == _X)); }
	    _Nodeptr _Mynode() const
		    {return (_Ptr); }
    private:
        _Nodeptr _Ptr;
    };

    iterator begin() { return iterator( m_first ); }
    iterator end() { return iterator( m_end ); }
    iterator begin() const { return iterator( m_first ); }
    iterator end() const { return iterator( m_end ); }

    bool empty() const { return begin() == end(); }

private:

    const T* m_first;
    const T* m_end;
};

typedef StrList<_TCHAR> tcStrList;
inline const _TCHAR* EndStr( const _TCHAR* sz ) { return sz+_tcslen(sz)+1; }

//
//	Class to interpret a buffer containing environment data
//
//  Format:
//			[<tag>'\0'<value>'\0']*
//			'\0'
//
//	The environ contains a list of 0 or more tag-value pairs,
//  each of which is a '\0' terminated string. A '\0' terminates
//  the entire list. Thus the trivial environ is a single '\0'.
//
class StrEnviron
{
public:
    StrEnviron( const _TCHAR* pStart, const _TCHAR* pEnd = 0 )
        : m_strlist( pStart )
    {
        assert( pEnd == 0 || &*m_strlist.end() <= pEnd );
        assert( m_strlist.Count() % 2 == 0 );
        // REVIEW: how about some way to test these in release?
    }
    
    const _TCHAR* szValueForTag( const _TCHAR* szTag ) const {
        if ( szTag != 0 ) {
            tcStrList::iterator itEnd = m_strlist.end();
            for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it )
            {
                assert( *it != 0 );
                if ( _tcscmp( &*it++, szTag ) == 0 ) {
                    return &*(it);
                }
            }
        }
        return 0;
    }

    bool empty() const { return m_strlist.empty(); }
    unsigned long Count() const { return m_strlist.Count()/2; }
#ifdef _OSTREAM_
    void Dump( ostream& o )
    {
        tcStrList::iterator itEnd = m_strlist.end();
        for ( tcStrList::iterator it = m_strlist.begin(); it != itEnd; ++it ) {
            o << &*it++ << " " << &*it << '\n';
        }
    }
#endif
private:
    tcStrList m_strlist;
};

//
// Class to interpret the environment data in a COMPILESYM record
//
// This field contains an ST followed by an environment
//

#define IS_STTYPE(x)        fNeedsSzConversion(x->rectype)

class CompEnviron: public StrEnviron
{
public:

#ifdef LNGNM
    CompEnviron(COMPILESYM *psym) 
        : StrEnviron((const _TCHAR *)
            (fNeedsSzConversion((PSYM)psym) 
            ? ((psym->verSt + *psym->verSt < pbEndSym((PSYM)psym))
                    ? psym->verSt + *psym->verSt + 1
                    : NULL)
            : ((psym->verSt + strlen((char *)psym->verSt) + 1 < pbEndSym((PSYM)psym))
                    ? psym->verSt + strlen((char *)psym->verSt) + 1
                    : NULL)))
    {}
#else
    CompEnviron( const unsigned char* st, const unsigned char* pEnd ) 
        : StrEnviron( st + *st + 1 < pEnd  
        ? reinterpret_cast< const char* >( st ) + *st + 1 
        : 0 )
    {}
#endif
};

#define ENC_CWD "cwd" /* <the current working directory>*/
#define ENC_CL  "cl"  /*<full pathname to cl.exe> */
#define ENC_SRC "src" /*<full pathname to the source file>*/
#define ENC_CMD "cmd" /*<command line to reinvoke cl.exe with for an edit-n-continue recompile> */
#define ENC_PDB "pdb" /*<full pathname to compiler pdb file> */



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvinfo16.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#if CC_CVTYPE32
#include "./cvinfo32.h"
#else

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ_t;
typedef CV_typ_t        CV_typ16_t;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_RESERVED   2L  // All signatures from 2 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7       // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))




// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types


#define T_NOTYPE        0x0000      // uncharacterized type (no type)
#define T_ABS           0x0001      // absolute symbol
#define T_SEGMENT       0x0002      // segment type
#define T_VOID          0x0003      // void
#define T_PVOID         0x0103      // near pointer to void
#define T_PFVOID        0x0203      // far pointer to void
#define T_PHVOID        0x0303      // huge pointer to void
#define T_32PVOID       0x0403      // 16:32 near pointer to void
#define T_32PFVOID      0x0503      // 16:32 far pointer to void
#define T_CURRENCY      0x0004      // BASIC 8 byte currency value
#define T_NBASICSTR     0x0005      // Near BASIC string
#define T_FBASICSTR     0x0006      // Far BASIC string
#define T_NOTTRANS      0x0007      // type not translated by cvpack
#define T_BIT           0x0060      // bit
#define T_PASCHAR       0x0061      // Pascal CHAR



//      Character types


#define T_CHAR          0x0010      // 8 bit signed
#define T_UCHAR         0x0020      // 8 bit unsigned
#define T_PCHAR         0x0110      // near pointer to 8 bit signed
#define T_PUCHAR        0x0120      // near pointer to 8 bit unsigned
#define T_PFCHAR        0x0210      // far pointer to 8 bit signed
#define T_PFUCHAR       0x0220      // far pointer to 8 bit unsigned
#define T_PHCHAR        0x0310      // huge pointer to 8 bit signed
#define T_PHUCHAR       0x0320      // huge pointer to 8 bit unsigned
#define T_32PCHAR       0x0410      // 16:32 near pointer to 8 bit signed
#define T_32PUCHAR      0x0420      // 16:32 near pointer to 8 bit unsigned
#define T_32PFCHAR      0x0510      // 16:32 far pointer to 8 bit signed
#define T_32PFUCHAR     0x0520      // 16:32 far pointer to 8 bit unsigned




//      really a character types

#define T_RCHAR         0x0070      // really a char
#define T_PRCHAR        0x0170      // 16:16 near pointer to a real char
#define T_PFRCHAR       0x0270      // 16:16 far pointer to a real char
#define T_PHRCHAR       0x0370      // 16:16 huge pointer to a real char
#define T_32PRCHAR      0x0470      // 16:32 near pointer to a real char
#define T_32PFRCHAR     0x0570      // 16:32 far pointer to a real char




//      really a wide character types

#define T_WCHAR         0x0071      // wide char
#define T_PWCHAR        0x0171      // 16:16 near pointer to a wide char
#define T_PFWCHAR       0x0271      // 16:16 far pointer to a wide char
#define T_PHWCHAR       0x0371      // 16:16 huge pointer to a wide char
#define T_32PWCHAR      0x0471      // 16:32 near pointer to a wide char
#define T_32PFWCHAR     0x0571      // 16:32 far pointer to a wide char


//      8 bit int types


#define T_INT1          0x0068      // 8 bit signed int
#define T_UINT1         0x0069      // 8 bit unsigned int
#define T_PINT1         0x0168      // near pointer to 8 bit signed int
#define T_PUINT1        0x0169      // near pointer to 8 bit unsigned int
#define T_PFINT1        0x0268      // far pointer to 8 bit signed int
#define T_PFUINT1       0x0269      // far pointer to 8 bit unsigned int
#define T_PHINT1        0x0368      // huge pointer to 8 bit signed int
#define T_PHUINT1       0x0369      // huge pointer to 8 bit unsigned int

#define T_32PINT1       0x0468      // 16:32 near pointer to 8 bit signed int
#define T_32PUINT1      0x0469      // 16:32 near pointer to 8 bit unsigned int
#define T_32PFINT1      0x0568      // 16:32 far pointer to 8 bit signed int
#define T_32PFUINT1     0x0569      // 16:32 far pointer to 8 bit unsigned int


//      16 bit short types


#define T_SHORT         0x0011      // 16 bit signed
#define T_USHORT        0x0021      // 16 bit unsigned
#define T_PSHORT        0x0111      // near pointer to 16 bit signed
#define T_PUSHORT       0x0121      // near pointer to 16 bit unsigned
#define T_PFSHORT       0x0211      // far pointer to 16 bit signed
#define T_PFUSHORT      0x0221      // far pointer to 16 bit unsigned
#define T_PHSHORT       0x0311      // huge pointer to 16 bit signed
#define T_PHUSHORT      0x0321      // huge pointer to 16 bit unsigned

#define T_32PSHORT      0x0411      // 16:32 near pointer to 16 bit signed
#define T_32PUSHORT     0x0421      // 16:32 near pointer to 16 bit unsigned
#define T_32PFSHORT     0x0511      // 16:32 far pointer to 16 bit signed
#define T_32PFUSHORT    0x0521      // 16:32 far pointer to 16 bit unsigned




//      16 bit int types


#define T_INT2          0x0072      // 16 bit signed int
#define T_UINT2         0x0073      // 16 bit unsigned int
#define T_PINT2         0x0172      // near pointer to 16 bit signed int
#define T_PUINT2        0x0173      // near pointer to 16 bit unsigned int
#define T_PFINT2        0x0272      // far pointer to 16 bit signed int
#define T_PFUINT2       0x0273      // far pointer to 16 bit unsigned int
#define T_PHINT2        0x0372      // huge pointer to 16 bit signed int
#define T_PHUINT2       0x0373      // huge pointer to 16 bit unsigned int

#define T_32PINT2       0x0472      // 16:32 near pointer to 16 bit signed int
#define T_32PUINT2      0x0473      // 16:32 near pointer to 16 bit unsigned int
#define T_32PFINT2      0x0572      // 16:32 far pointer to 16 bit signed int
#define T_32PFUINT2     0x0573      // 16:32 far pointer to 16 bit unsigned int




//      32 bit long types


#define T_LONG          0x0012      // 32 bit signed
#define T_ULONG         0x0022      // 32 bit unsigned
#define T_PLONG         0x0112      // near pointer to 32 bit signed
#define T_PULONG        0x0122      // near pointer to 32 bit unsigned
#define T_PFLONG        0x0212      // far pointer to 32 bit signed
#define T_PFULONG       0x0222      // far pointer to 32 bit unsigned
#define T_PHLONG        0x0312      // huge pointer to 32 bit signed
#define T_PHULONG       0x0322      // huge pointer to 32 bit unsigned

#define T_32PLONG       0x0412      // 16:32 near pointer to 32 bit signed
#define T_32PULONG      0x0422      // 16:32 near pointer to 32 bit unsigned
#define T_32PFLONG      0x0512      // 16:32 far pointer to 32 bit signed
#define T_32PFULONG     0x0522      // 16:32 far pointer to 32 bit unsigned




//      32 bit int types


#define T_INT4          0x0074      // 32 bit signed int
#define T_UINT4         0x0075      // 32 bit unsigned int
#define T_PINT4         0x0174      // near pointer to 32 bit signed int
#define T_PUINT4        0x0175      // near pointer to 32 bit unsigned int
#define T_PFINT4        0x0274      // far pointer to 32 bit signed int
#define T_PFUINT4       0x0275      // far pointer to 32 bit unsigned int
#define T_PHINT4        0x0374      // huge pointer to 32 bit signed int
#define T_PHUINT4       0x0375      // huge pointer to 32 bit unsigned int

#define T_32PINT4       0x0474      // 16:32 near pointer to 32 bit signed int
#define T_32PUINT4      0x0475      // 16:32 near pointer to 32 bit unsigned int
#define T_32PFINT4      0x0574      // 16:32 far pointer to 32 bit signed int
#define T_32PFUINT4     0x0575      // 16:32 far pointer to 32 bit unsigned int




//      64 bit quad types


#define T_QUAD          0x0013      // 64 bit signed
#define T_UQUAD         0x0023      // 64 bit unsigned
#define T_PQUAD         0x0113      // near pointer to 64 bit signed
#define T_PUQUAD        0x0123      // near pointer to 64 bit unsigned
#define T_PFQUAD        0x0213      // far pointer to 64 bit signed
#define T_PFUQUAD       0x0223      // far pointer to 64 bit unsigned
#define T_PHQUAD        0x0313      // huge pointer to 64 bit signed
#define T_PHUQUAD       0x0323      // huge pointer to 64 bit unsigned
#define T_32PQUAD       0x0413      // 16:32 near pointer to 64 bit signed
#define T_32PUQUAD      0x0423      // 16:32 near pointer to 64 bit unsigned
#define T_32PFQUAD      0x0513      // 16:32 far pointer to 64 bit signed
#define T_32PFUQUAD     0x0523      // 16:32 far pointer to 64 bit unsigned



//      64 bit int types


#define T_INT8          0x0076      // 64 bit signed int
#define T_UINT8         0x0077      // 64 bit unsigned int
#define T_PINT8         0x0176      // near pointer to 64 bit signed int
#define T_PUINT8        0x0177      // near pointer to 64 bit unsigned int
#define T_PFINT8        0x0276      // far pointer to 64 bit signed int
#define T_PFUINT8       0x0277      // far pointer to 64 bit unsigned int
#define T_PHINT8        0x0376      // huge pointer to 64 bit signed int
#define T_PHUINT8       0x0377      // huge pointer to 64 bit unsigned int

#define T_32PINT8       0x0476      // 16:32 near pointer to 64 bit signed int
#define T_32PUINT8      0x0477      // 16:32 near pointer to 64 bit unsigned int
#define T_32PFINT8      0x0576      // 16:32 far pointer to 64 bit signed int
#define T_32PFUINT8     0x0577      // 16:32 far pointer to 64 bit unsigned int


//      128 bit octet types


#define T_OCT           0x0014      // 128 bit signed
#define T_UOCT          0x0024      // 128 bit unsigned
#define T_POCT          0x0114      // near pointer to 128 bit signed
#define T_PUOCT         0x0124      // near pointer to 128 bit unsigned
#define T_PFOCT         0x0214      // far pointer to 128 bit signed
#define T_PFUOCT        0x0224      // far pointer to 128 bit unsigned
#define T_PHOCT         0x0314      // huge pointer to 128 bit signed
#define T_PHUOCT        0x0324      // huge pointer to 128 bit unsigned

#define T_32POCT        0x0414      // 16:32 near pointer to 128 bit signed
#define T_32PUOCT       0x0424      // 16:32 near pointer to 128 bit unsigned
#define T_32PFOCT       0x0514      // 16:32 far pointer to 128 bit signed
#define T_32PFUOCT      0x0524      // 16:32 far pointer to 128 bit unsigned

//      128 bit int types


#define T_INT16         0x0078      // 128 bit signed int
#define T_UINT16        0x0079      // 128 bit unsigned int
#define T_PINT16        0x0178      // near pointer to 128 bit signed int
#define T_PUINT16       0x0179      // near pointer to 128 bit unsigned int
#define T_PFINT16       0x0278      // far pointer to 128 bit signed int
#define T_PFUINT16      0x0279      // far pointer to 128 bit unsigned int
#define T_PHINT16       0x0378      // huge pointer to 128 bit signed int
#define T_PHUINT16      0x0379      // huge pointer to 128 bit unsigned int

#define T_32PINT16      0x0478      // 16:32 near pointer to 128 bit signed int
#define T_32PUINT16     0x0479      // 16:32 near pointer to 128 bit unsigned int
#define T_32PFINT16     0x0578      // 16:32 far pointer to 128 bit signed int
#define T_32PFUINT16    0x0579      // 16:32 far pointer to 128 bit unsigned int





//      32 bit real types


#define T_REAL32        0x0040      // 32 bit real
#define T_PREAL32       0x0140      // near pointer to 32 bit real
#define T_PFREAL32      0x0240      // far pointer to 32 bit real
#define T_PHREAL32      0x0340      // huge pointer to 32 bit real
#define T_32PREAL32     0x0440      // 16:32 near pointer to 32 bit real
#define T_32PFREAL32    0x0540      // 16:32 far pointer to 32 bit real



//      48 bit real types


#define T_REAL48        0x0044      // 48 bit real
#define T_PREAL48       0x0144      // near pointer to 48 bit real
#define T_PFREAL48      0x0244      // far pointer to 48 bit real
#define T_PHREAL48      0x0344      // huge pointer to 48 bit real
#define T_32PREAL48     0x0444      // 16:32 near pointer to 48 bit real
#define T_32PFREAL48    0x0544      // 16:32 far pointer to 48 bit real




//      64 bit real types


#define T_REAL64        0x0041      // 64 bit real
#define T_PREAL64       0x0141      // near pointer to 64 bit real
#define T_PFREAL64      0x0241      // far pointer to 64 bit real
#define T_PHREAL64      0x0341      // huge pointer to 64 bit real
#define T_32PREAL64     0x0441      // 16:32 near pointer to 64 bit real
#define T_32PFREAL64    0x0541      // 16:32 far pointer to 64 bit real




//      80 bit real types


#define T_REAL80        0x0042      // 80 bit real
#define T_PREAL80       0x0142      // near pointer to 80 bit real
#define T_PFREAL80      0x0242      // far pointer to 80 bit real
#define T_PHREAL80      0x0342      // huge pointer to 80 bit real
#define T_32PREAL80     0x0442      // 16:32 near pointer to 80 bit real
#define T_32PFREAL80    0x0542      // 16:32 far pointer to 80 bit real




//      128 bit real types


#define T_REAL128       0x0043      // 128 bit real
#define T_PREAL128      0x0143      // near pointer to 128 bit real
#define T_PFREAL128     0x0243      // far pointer to 128 bit real
#define T_PHREAL128     0x0343      // huge pointer to 128 bit real
#define T_32PREAL128    0x0443      // 16:32 near pointer to 128 bit real
#define T_32PFREAL128   0x0543      // 16:32 far pointer to 128 bit real




//      32 bit complex types


#define T_CPLX32        0x0050      // 32 bit complex
#define T_PCPLX32       0x0150      // near pointer to 32 bit complex
#define T_PFCPLX32      0x0250      // far pointer to 32 bit complex
#define T_PHCPLX32      0x0350      // huge pointer to 32 bit complex
#define T_32PCPLX32     0x0450      // 16:32 near pointer to 32 bit complex
#define T_32PFCPLX32    0x0550      // 16:32 far pointer to 32 bit complex




//      64 bit complex types


#define T_CPLX64        0x0051      // 64 bit complex
#define T_PCPLX64       0x0151      // near pointer to 64 bit complex
#define T_PFCPLX64      0x0251      // far pointer to 64 bit complex
#define T_PHCPLX64      0x0351      // huge pointer to 64 bit complex
#define T_32PCPLX64     0x0451      // 16:32 near pointer to 64 bit complex
#define T_32PFCPLX64    0x0551      // 16:32 far pointer to 64 bit complex




//      80 bit complex types


#define T_CPLX80        0x0052      // 80 bit complex
#define T_PCPLX80       0x0152      // near pointer to 80 bit complex
#define T_PFCPLX80      0x0252      // far pointer to 80 bit complex
#define T_PHCPLX80      0x0352      // huge pointer to 80 bit complex
#define T_32PCPLX80     0x0452      // 16:32 near pointer to 80 bit complex
#define T_32PFCPLX80    0x0552      // 16:32 far pointer to 80 bit complex




//      128 bit complex types


#define T_CPLX128       0x0053      // 128 bit complex
#define T_PCPLX128      0x0153      // near pointer to 128 bit complex
#define T_PFCPLX128     0x0253      // far pointer to 128 bit complex
#define T_PHCPLX128     0x0353      // huge pointer to 128 bit real
#define T_32PCPLX128    0x0453      // 16:32 near pointer to 128 bit complex
#define T_32PFCPLX128   0x0553      // 16:32 far pointer to 128 bit complex




//      boolean types


#define T_BOOL08        0x0030      // 8 bit boolean
#define T_BOOL16        0x0031      // 16 bit boolean
#define T_BOOL32        0x0032      // 32 bit boolean
#define T_BOOL64        0x0033      // 64 bit boolean
#define T_PBOOL08       0x0130      // near pointer to  8 bit boolean
#define T_PBOOL16       0x0131      // near pointer to 16 bit boolean
#define T_PBOOL32       0x0132      // near pointer to 32 bit boolean
#define T_PBOOL64       0x0133      // near pointer to 64 bit boolean
#define T_PFBOOL08      0x0230      // far pointer to  8 bit boolean
#define T_PFBOOL16      0x0231      // far pointer to 16 bit boolean
#define T_PFBOOL32      0x0232      // far pointer to 32 bit boolean
#define T_PFBOOL64      0x0233      // far pointer to 64 bit boolean
#define T_PHBOOL08      0x0330      // huge pointer to  8 bit boolean
#define T_PHBOOL16      0x0331      // huge pointer to 16 bit boolean
#define T_PHBOOL32      0x0332      // huge pointer to 32 bit boolean
#define T_PHBOOL64      0x0333      // huge pointer to 64 bit boolean

#define T_32PBOOL08     0x0430      // 16:32 near pointer to 8 bit boolean
#define T_32PFBOOL08    0x0530      // 16:32 far pointer to 8 bit boolean
#define T_32PBOOL16     0x0431      // 16:32 near pointer to 18 bit boolean
#define T_32PFBOOL16    0x0531      // 16:32 far pointer to 16 bit boolean
#define T_32PBOOL32     0x0432      // 16:32 near pointer to 32 bit boolean
#define T_32PFBOOL32    0x0532      // 16:32 far pointer to 32 bit boolean
#define T_32PBOOL64     0x0433      // 16:32 near pointer to 64 bit boolean
#define T_32PFBOOL64    0x0533      // 16:32 far pointer to 64 bit boolean


#define T_NCVPTR        0x01f0      // CV Internal type for created near pointers
#define T_FCVPTR        0x02f0      // CV Internal type for created far pointers
#define T_HCVPTR        0x03f0      // CV Internal type for created huge pointers
#define T_32NCVPTR      0x04f0      // CV Internal type for created near 32-bit pointers
#define T_32FCVPTR      0x05f0      // CV Internal type for created far 32-bit pointers
#define T_64NCVPTR      0x06f0      // CV Internal type for created near 64-bit pointers

#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))


/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */



    // leaf indices starting records but referenced from symbol records

#define LF_MODIFIER     0x0001
#define LF_POINTER      0x0002
#define LF_ARRAY        0x0003
#define LF_CLASS        0x0004
#define LF_STRUCTURE    0x0005
#define LF_UNION        0x0006
#define LF_ENUM         0x0007
#define LF_PROCEDURE    0x0008
#define LF_MFUNCTION    0x0009
#define LF_VTSHAPE      0x000a
#define LF_COBOL0       0x000b
#define LF_COBOL1       0x000c
#define LF_BARRAY       0x000d
#define LF_LABEL        0x000e
#define LF_NULL         0x000f
#define LF_NOTTRAN      0x0010
#define LF_DIMARRAY     0x0011
#define LF_VFTPATH      0x0012
#define LF_PRECOMP      0x0013      // not referenced from symbol
#define LF_ENDPRECOMP   0x0014      // not referenced from symbol
#define LF_OEM          0x0015      // oem definable type string
#define LF_TYPESERVER   0x0016      // not referenced from symbol

    // leaf indices starting records but referenced only from type records

#define LF_SKIP         0x0200
#define LF_ARGLIST      0x0201
#define LF_DEFARG       0x0202
#define LF_LIST         0x0203
#define LF_FIELDLIST    0x0204
#define LF_DERIVED      0x0205
#define LF_BITFIELD     0x0206
#define LF_METHODLIST   0x0207
#define LF_DIMCONU      0x0208
#define LF_DIMCONLU     0x0209
#define LF_DIMVARU      0x020a
#define LF_DIMVARLU     0x020b
#define LF_REFSYM       0x020c

#define LF_BCLASS       0x0400
#define LF_VBCLASS      0x0401
#define LF_IVBCLASS     0x0402
#define LF_ENUMERATE    0x0403
#define LF_FRIENDFCN    0x0404
#define LF_INDEX        0x0405
#define LF_MEMBER       0x0406
#define LF_STMEMBER     0x0407
#define LF_METHOD       0x0408
#define LF_NESTTYPE     0x0409
#define LF_VFUNCTAB     0x040a
#define LF_FRIENDCLS    0x040b
#define LF_ONEMETHOD    0x040c
#define LF_VFUNCOFF     0x040d
#define LF_NESTTYPEEX   0x040e
#define LF_MEMBERMODIFY 0x040f

#define LF_NUMERIC      0x8000
#define LF_CHAR         0x8000
#define LF_SHORT        0x8001
#define LF_USHORT       0x8002
#define LF_LONG         0x8003
#define LF_ULONG        0x8004
#define LF_REAL32       0x8005
#define LF_REAL64       0x8006
#define LF_REAL80       0x8007
#define LF_REAL128      0x8008
#define LF_QUADWORD     0x8009
#define LF_UQUADWORD    0x800a
#define LF_REAL48       0x800b
#define LF_COMPLEX32    0x800c
#define LF_COMPLEX64    0x800d
#define LF_COMPLEX80    0x800e
#define LF_COMPLEX128   0x800f
#define LF_VARSTRING    0x8010

#define LF_OCTWORD      0x8017
#define LF_UOCTWORD     0x8018

#define LF_PAD0         0xf0
#define LF_PAD1         0xf1
#define LF_PAD2         0xf2
#define LF_PAD3         0xf3
#define LF_PAD4         0xf4
#define LF_PAD5         0xf5
#define LF_PAD6         0xf6
#define LF_PAD7         0xf7
#define LF_PAD8         0xf8
#define LF_PAD9         0xf9
#define LF_PAD10        0xfa
#define LF_PAD11        0xfb
#define LF_PAD12        0xfc
#define LF_PAD13        0xfd
#define LF_PAD14        0xfe
#define LF_PAD15        0xff

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // near pointer
    CV_PTR_FAR          = 0x01, // far pointer
    CV_PTR_HUGE         = 0x02, // huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 16:32 near pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 far pointer
    CV_PTR_UNUSEDPTR    = 0x0c  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;




//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_RESERVED    = 0x10  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;



//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 16:32 near pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 16:32 near pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16:16 near pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16:16 near pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 16:32 near pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 16:32 near pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */


//      Type record for LF_MODIFIER


typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ_t        type;           // modified type
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        struct lfPointerAttr {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (ptrtype-t)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (ptrmode_t)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ_t    utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union  {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;




//      type record for LF_ENUM


typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned short  count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;


//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000


//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned short  count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned short  count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];             // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod {
    CV_fldattr_t   attr;           // method attribute
    CV_typ_t       index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    unsigned char   length;
    unsigned char   position;
    CV_typ_t        type;           // type of bitfield

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    unsigned short  rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned short  rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_typ_t        index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_typ_t        index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_typ_t        index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCTAB
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurances of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod {
    unsigned short  leaf;           // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_typ_t        index;      // index of nested type definition
    CV_fldattr_t    attr;       // member access
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_typ_t        index;      // index of base class type definition
    CV_fldattr_t    attr;       // the new attributes
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE    =  0x0001, // Compile flags symbol
    S_REGISTER   =  0x0002, // Register variable
    S_CONSTANT   =  0x0003, // constant symbol
    S_UDT        =  0x0004, // User defined type
    S_SSEARCH    =  0x0005, // Start Search
    S_END        =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP       =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE  =  0x0008, // Reserved symbol for CV internal use
    S_OBJNAME    =  0x0009, // path to object file name
    S_ENDARG     =  0x000a, // end of argument/return list
    S_COBOLUDT   =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG    =  0x000c, // multiple register variable
    S_RETURN     =  0x000d, // return description symbol
    S_ENTRYTHIS  =  0x000e, // description of this pointer on entry

    S_BPREL16    =  0x0100, // BP-relative
    S_LDATA16    =  0x0101, // Module-local symbol
    S_GDATA16    =  0x0102, // Global data symbol
    S_PUB16      =  0x0103, // a public symbol
    S_LPROC16    =  0x0104, // Local procedure start
    S_GPROC16    =  0x0105, // Global procedure start
    S_THUNK16    =  0x0106, // Thunk Start
    S_BLOCK16    =  0x0107, // block start
    S_WITH16     =  0x0108, // with start
    S_LABEL16    =  0x0109, // code label
    S_CEXMODEL16 =  0x010a, // change execution model
    S_VFTABLE16  =  0x010b, // address of virtual function table
    S_REGREL16   =  0x010c, // register relative address

    S_BPREL32    =  0x0200, // BP-relative
    S_LDATA32    =  0x0201, // Module-local symbol
    S_GDATA32    =  0x0202, // Global data symbol
    S_PUB32      =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32    =  0x0204, // Local procedure start
    S_GPROC32    =  0x0205, // Global procedure start
    S_THUNK32    =  0x0206, // Thunk Start
    S_BLOCK32    =  0x0207, // block start
    S_WITH32     =  0x0208, // with start
    S_LABEL32    =  0x0209, // code label
    S_CEXMODEL32 =  0x020a, // change execution model
    S_VFTABLE32  =  0x020b, // address of virtual function table
    S_REGREL32   =  0x020c, // register relative address
    S_LTHREAD32  =  0x020d, // local thread storage
    S_GTHREAD32  =  0x020e, // global thread storage
    S_SLINK32    =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS  =  0x0300, // Local procedure start
    S_GPROCMIPS  =  0x0301, // Global procedure start

    S_PROCREF    =  0x0400, // Reference to a procedure
    S_DATAREF    =  0x0401, // Reference to data
    S_ALIGN      =  0x0402, // Used for page alignment of symbols
    S_LPROCREF    =  0x0403 // Local Reference to a procedure
} SYM_ENUM_e;




//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
} CV_CFL_LANG;



//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SH5          = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
} CV_CPU_TYPE_e;


//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        struct {
            unsigned char CV_PFLAG_NOFPO:1; // frame pointer present
            unsigned char CV_PFLAG_INT  :1; // interrupt return
            unsigned char CV_PFLAG_FAR  :1; // far return
            unsigned char CV_PFLAG_NEVER:1; // function does not return
            unsigned char unused        :4; //
        };
    };
} CV_PROCFLAGS;


// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;



typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;



typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;

typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;

typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambiant data model
        unsigned char   ambcode     :3; // ambiant code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;





typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;




typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    CV_GENERIC_STYLE_e style;   // return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;



typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ_t        typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;




typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef enum {
    THUNK_ORDINAL_NOTYPE,
    THUNK_ORDINAL_ADJUSTOR,
    THUNK_ORDINAL_VCALL,
    THUNK_ORDINAL_PCODE
} THUNK_ORDINAL;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;

typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;

typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;




typedef enum CEXM_MODEL_e {
    CEXM_MDL_table      = 0x00,     // not executable
    CEXM_MDL_jumptable  = 0x01,     // Compiler generated jump table
    CEXM_MDL_datapad    = 0x02,     // Data padding for alignment
    CEXM_MDL_native     = 0x20,     // native (actually not-pcode)
    CEXM_MDL_cobol      = 0x21,     // cobol
    CEXM_MDL_codepad    = 0x22,     // Code padding for alignment
    CEXM_MDL_code       = 0x23,     // code
	CEXM_MDL_SQL		= 0x30,		// SQL
    CEXM_MDL_pcode      = 0x40,     // pcode
    CEXM_MDL_pcode32Mac = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42  // macintosh 32 bit pcode native entry point
} CEXM_MODEL_e;

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var16 {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;




typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
} VPATHSYM16;




typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;





typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;
typedef DATASYM32 PUBSYM32;



typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ_t        typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;




typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // ordinal specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;




typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union var32 {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH32
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
} VPATHSYM32;





typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;



typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ_t        typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ_t        typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;


typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF or S_DATAREF
} ALIGNSYM;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;


typedef enum CV_HREG_e {
    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )


	//
	// JAVA VM registers
	//

	CV_JAVA_PC		= 1,


} CV_HREG_e;

#pragma pack ( pop )

#endif	/* CC_CVTYPE32 */

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvinfo.h ===
/***    cvinfo.h - Generic CodeView information definitions
 *
 *      Structures, constants, etc. for accessing and interpreting
 *      CodeView information.
 *
 */


/***    The master copy of this file resides in the langapi project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 *      When this file is modified, the corresponding documentation file
 *      omfdeb.doc in the langapi project must be updated.
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#pragma once

#include "cvconst.h"

#ifndef _CV_INFO_INCLUDED
#define _CV_INFO_INCLUDED

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif

#ifndef __INLINE
#ifdef  __cplusplus
#define __INLINE inline
#else
#define __INLINE __inline
#endif
#endif

#pragma pack ( push, 1 )
typedef unsigned long   CV_uoff32_t;
typedef          long   CV_off32_t;
typedef unsigned short  CV_uoff16_t;
typedef          short  CV_off16_t;
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.
typedef unsigned short  _2BYTEPAD;
typedef unsigned long   CV_tkn_t;

#if !defined (CV_ZEROLEN)
#define CV_ZEROLEN
#endif

#if !defined (FLOAT10)
#if defined(_M_I86)                    // 16 bit x86 supporting long double
typedef long double FLOAT10;
#else                                  // 32 bit w/o long double support
typedef struct FLOAT10
{
    char b[10];
} FLOAT10;
#endif
#endif


#define CV_SIGNATURE_C6         0L  // Actual signature is >64K
#define CV_SIGNATURE_C7         1L  // First explicit signature
#define CV_SIGNATURE_C11        2L  // C11 (vc5.x) 32-bit types
#define CV_SIGNATURE_C13        4L  // C13 (vc7.x) zero terminated names
#define CV_SIGNATURE_RESERVED   5L  // All signatures from 5 to 64K are reserved

#define CV_MAXOFFSET   0xffffffff

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    unsigned long   Data1;
    unsigned short  Data2;
    unsigned short  Data3;
    unsigned char   Data4[8];
} GUID;

#endif // !GUID_DEFINED

typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;



/**     CodeView Symbol and Type OMF type information is broken up into two
 *      ranges.  Type indices less than 0x1000 describe type information
 *      that is frequently used.  Type indices above 0x1000 are used to
 *      describe more complex features such as functions, arrays and
 *      structures.
 */




/**     Primitive types have predefined meaning that is encoded in the
 *      values of the various bit fields in the value.
 *
 *      A CodeView primitive type is defined as:
 *
 *      1 1
 *      1 089  7654  3  210
 *      r mode type  r  sub
 *
 *      Where
 *          mode is the pointer mode
 *          type is a type indicator
 *          sub  is a subtype enumeration
 *          r    is a reserved field
 *
 *      See Microsoft Symbol and Type OMF (Version 4.0) for more
 *      information.
 */


#define CV_MMASK        0x700       // mode mask
#define CV_TMASK        0x0f0       // type mask

// can we use the reserved bit ??
#define CV_SMASK        0x00f       // subtype mask

#define CV_MSHIFT       8           // primitive mode right shift count
#define CV_TSHIFT       4           // primitive type right shift count
#define CV_SSHIFT       0           // primitive subtype right shift count

// macros to extract primitive mode, type and size

#define CV_MODE(typ)    (((typ) & CV_MMASK) >> CV_MSHIFT)
#define CV_TYPE(typ)    (((typ) & CV_TMASK) >> CV_TSHIFT)
#define CV_SUBT(typ)    (((typ) & CV_SMASK) >> CV_SSHIFT)

// macros to insert new primitive mode, type and size

#define CV_NEWMODE(typ, nm)     ((CV_typ_t)(((typ) & ~CV_MMASK) | ((nm) << CV_MSHIFT)))
#define CV_NEWTYPE(typ, nt)     (((typ) & ~CV_TMASK) | ((nt) << CV_TSHIFT))
#define CV_NEWSUBT(typ, ns)     (((typ) & ~CV_SMASK) | ((ns) << CV_SSHIFT))



//     pointer mode enumeration values

typedef enum CV_prmode_e {
    CV_TM_DIRECT = 0,       // mode is not a pointer
    CV_TM_NPTR   = 1,       // mode is a near pointer
    CV_TM_FPTR   = 2,       // mode is a far pointer
    CV_TM_HPTR   = 3,       // mode is a huge pointer
    CV_TM_NPTR32 = 4,       // mode is a 32 bit near pointer
    CV_TM_FPTR32 = 5,       // mode is a 32 bit far pointer
    CV_TM_NPTR64 = 6,       // mode is a 64 bit near pointer
    CV_TM_NPTR128 = 7,      // mode is a 128 bit near pointer
} CV_prmode_e;




//      type enumeration values


typedef enum CV_type_e {
    CV_SPECIAL      = 0x00,         // special type size values
    CV_SIGNED       = 0x01,         // signed integral size values
    CV_UNSIGNED     = 0x02,         // unsigned integral size values
    CV_BOOLEAN      = 0x03,         // Boolean size values
    CV_REAL         = 0x04,         // real number size values
    CV_COMPLEX      = 0x05,         // complex number size values
    CV_SPECIAL2     = 0x06,         // second set of special types
    CV_INT          = 0x07,         // integral (int) values
    CV_CVRESERVED   = 0x0f,
} CV_type_e;




//      subtype enumeration values for CV_SPECIAL


typedef enum CV_special_e {
    CV_SP_NOTYPE    = 0x00,
    CV_SP_ABS       = 0x01,
    CV_SP_SEGMENT   = 0x02,
    CV_SP_VOID      = 0x03,
    CV_SP_CURRENCY  = 0x04,
    CV_SP_NBASICSTR = 0x05,
    CV_SP_FBASICSTR = 0x06,
    CV_SP_NOTTRANS  = 0x07,
    CV_SP_HRESULT   = 0x08,
} CV_special_e;




//      subtype enumeration values for CV_SPECIAL2


typedef enum CV_special2_e {
    CV_S2_BIT       = 0x00,
    CV_S2_PASCHAR   = 0x01          // Pascal CHAR
} CV_special2_e;





//      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN


typedef enum CV_integral_e {
    CV_IN_1BYTE     = 0x00,
    CV_IN_2BYTE     = 0x01,
    CV_IN_4BYTE     = 0x02,
    CV_IN_8BYTE     = 0x03,
    CV_IN_16BYTE    = 0x04
} CV_integral_e;





//      subtype enumeration values for CV_REAL and CV_COMPLEX


typedef enum CV_real_e {
    CV_RC_REAL32    = 0x00,
    CV_RC_REAL64    = 0x01,
    CV_RC_REAL80    = 0x02,
    CV_RC_REAL128   = 0x03,
    CV_RC_REAL48    = 0x04
} CV_real_e;




//      subtype enumeration values for CV_INT (really int)


typedef enum CV_int_e {
    CV_RI_CHAR      = 0x00,
    CV_RI_INT1      = 0x00,
    CV_RI_WCHAR     = 0x01,
    CV_RI_UINT1     = 0x01,
    CV_RI_INT2      = 0x02,
    CV_RI_UINT2     = 0x03,
    CV_RI_INT4      = 0x04,
    CV_RI_UINT4     = 0x05,
    CV_RI_INT8      = 0x06,
    CV_RI_UINT8     = 0x07,
    CV_RI_INT16     = 0x08,
    CV_RI_UINT16    = 0x09
} CV_int_e;




// macros to check the type of a primitive

#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT)
#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT)
#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR)
#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR)
#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR)
#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32)
#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32)

#define CV_TYP_IS_SIGNED(typ)   (((CV_TYPE(typ) == CV_SIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_INT1)  || \
                                 (typ == T_INT2)  || \
                                 (typ == T_INT4)  || \
                                 (typ == T_INT8)  || \
                                 (typ == T_INT16) || \
                                 (typ == T_RCHAR))

#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) && CV_TYP_IS_DIRECT(typ)) || \
                                 (typ == T_UINT1) || \
                                 (typ == T_UINT2) || \
                                 (typ == T_UINT4) || \
                                 (typ == T_UINT8) || \
                                 (typ == T_UINT16))

#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  && CV_TYP_IS_DIRECT(typ))

#define CV_FIRST_NONPRIM 0x1000
#define CV_IS_PRIMITIVE(typ)    ((typ) < CV_FIRST_NONPRIM)
#define CV_TYP_IS_COMPLEX(typ)  ((CV_TYPE(typ) == CV_COMPLEX)   && CV_TYP_IS_DIRECT(typ))
#define CV_IS_INTERNAL_PTR(typ) (CV_IS_PRIMITIVE(typ) && \
                                 CV_TYPE(typ) == CV_CVRESERVED && \
                                 CV_TYP_IS_PTR(typ))






// selected values for type_index - for a more complete definition, see
// Microsoft Symbol and Type OMF document




//      Special Types

typedef enum TYPE_ENUM_e {
//      Special Types

    T_NOTYPE        = 0x0000,   // uncharacterized type (no type)
    T_ABS           = 0x0001,   // absolute symbol
    T_SEGMENT       = 0x0002,   // segment type
    T_VOID          = 0x0003,   // void
    T_HRESULT       = 0x0008,   // OLE/COM HRESULT
    T_32PHRESULT    = 0x0408,   // OLE/COM HRESULT __ptr32 *
    T_64PHRESULT    = 0x0608,   // OLE/COM HRESULT __ptr64 *
    T_PVOID         = 0x0103,   // near pointer to void
    T_PFVOID        = 0x0203,   // far pointer to void
    T_PHVOID        = 0x0303,   // huge pointer to void
    T_32PVOID       = 0x0403,   // 32 bit pointer to void
    T_32PFVOID      = 0x0503,   // 16:32 pointer to void
    T_64PVOID       = 0x0603,   // 64 bit pointer to void
    T_CURRENCY      = 0x0004,   // BASIC 8 byte currency value
    T_NBASICSTR     = 0x0005,   // Near BASIC string
    T_FBASICSTR     = 0x0006,   // Far BASIC string
    T_NOTTRANS      = 0x0007,   // type not translated by cvpack
    T_BIT           = 0x0060,   // bit
    T_PASCHAR       = 0x0061,   // Pascal CHAR


//      Character types

    T_CHAR          = 0x0010,   // 8 bit signed
    T_PCHAR         = 0x0110,   // 16 bit pointer to 8 bit signed
    T_PFCHAR        = 0x0210,   // 16:16 far pointer to 8 bit signed
    T_PHCHAR        = 0x0310,   // 16:16 huge pointer to 8 bit signed
    T_32PCHAR       = 0x0410,   // 32 bit pointer to 8 bit signed
    T_32PFCHAR      = 0x0510,   // 16:32 pointer to 8 bit signed
    T_64PCHAR       = 0x0610,   // 64 bit pointer to 8 bit signed

    T_UCHAR         = 0x0020,   // 8 bit unsigned
    T_PUCHAR        = 0x0120,   // 16 bit pointer to 8 bit unsigned
    T_PFUCHAR       = 0x0220,   // 16:16 far pointer to 8 bit unsigned
    T_PHUCHAR       = 0x0320,   // 16:16 huge pointer to 8 bit unsigned
    T_32PUCHAR      = 0x0420,   // 32 bit pointer to 8 bit unsigned
    T_32PFUCHAR     = 0x0520,   // 16:32 pointer to 8 bit unsigned
    T_64PUCHAR      = 0x0620,   // 64 bit pointer to 8 bit unsigned


//      really a character types

    T_RCHAR         = 0x0070,   // really a char
    T_PRCHAR        = 0x0170,   // 16 bit pointer to a real char
    T_PFRCHAR       = 0x0270,   // 16:16 far pointer to a real char
    T_PHRCHAR       = 0x0370,   // 16:16 huge pointer to a real char
    T_32PRCHAR      = 0x0470,   // 32 bit pointer to a real char
    T_32PFRCHAR     = 0x0570,   // 16:32 pointer to a real char
    T_64PRCHAR      = 0x0670,   // 64 bit pointer to a real char


//      really a wide character types

    T_WCHAR         = 0x0071,   // wide char
    T_PWCHAR        = 0x0171,   // 16 bit pointer to a wide char
    T_PFWCHAR       = 0x0271,   // 16:16 far pointer to a wide char
    T_PHWCHAR       = 0x0371,   // 16:16 huge pointer to a wide char
    T_32PWCHAR      = 0x0471,   // 32 bit pointer to a wide char
    T_32PFWCHAR     = 0x0571,   // 16:32 pointer to a wide char
    T_64PWCHAR      = 0x0671,   // 64 bit pointer to a wide char


//      8 bit int types

    T_INT1          = 0x0068,   // 8 bit signed int
    T_PINT1         = 0x0168,   // 16 bit pointer to 8 bit signed int
    T_PFINT1        = 0x0268,   // 16:16 far pointer to 8 bit signed int
    T_PHINT1        = 0x0368,   // 16:16 huge pointer to 8 bit signed int
    T_32PINT1       = 0x0468,   // 32 bit pointer to 8 bit signed int
    T_32PFINT1      = 0x0568,   // 16:32 pointer to 8 bit signed int
    T_64PINT1       = 0x0668,   // 64 bit pointer to 8 bit signed int

    T_UINT1         = 0x0069,   // 8 bit unsigned int
    T_PUINT1        = 0x0169,   // 16 bit pointer to 8 bit unsigned int
    T_PFUINT1       = 0x0269,   // 16:16 far pointer to 8 bit unsigned int
    T_PHUINT1       = 0x0369,   // 16:16 huge pointer to 8 bit unsigned int
    T_32PUINT1      = 0x0469,   // 32 bit pointer to 8 bit unsigned int
    T_32PFUINT1     = 0x0569,   // 16:32 pointer to 8 bit unsigned int
    T_64PUINT1      = 0x0669,   // 64 bit pointer to 8 bit unsigned int


//      16 bit short types

    T_SHORT         = 0x0011,   // 16 bit signed
    T_PSHORT        = 0x0111,   // 16 bit pointer to 16 bit signed
    T_PFSHORT       = 0x0211,   // 16:16 far pointer to 16 bit signed
    T_PHSHORT       = 0x0311,   // 16:16 huge pointer to 16 bit signed
    T_32PSHORT      = 0x0411,   // 32 bit pointer to 16 bit signed
    T_32PFSHORT     = 0x0511,   // 16:32 pointer to 16 bit signed
    T_64PSHORT      = 0x0611,   // 64 bit pointer to 16 bit signed

    T_USHORT        = 0x0021,   // 16 bit unsigned
    T_PUSHORT       = 0x0121,   // 16 bit pointer to 16 bit unsigned
    T_PFUSHORT      = 0x0221,   // 16:16 far pointer to 16 bit unsigned
    T_PHUSHORT      = 0x0321,   // 16:16 huge pointer to 16 bit unsigned
    T_32PUSHORT     = 0x0421,   // 32 bit pointer to 16 bit unsigned
    T_32PFUSHORT    = 0x0521,   // 16:32 pointer to 16 bit unsigned
    T_64PUSHORT     = 0x0621,   // 64 bit pointer to 16 bit unsigned


//      16 bit int types

    T_INT2          = 0x0072,   // 16 bit signed int
    T_PINT2         = 0x0172,   // 16 bit pointer to 16 bit signed int
    T_PFINT2        = 0x0272,   // 16:16 far pointer to 16 bit signed int
    T_PHINT2        = 0x0372,   // 16:16 huge pointer to 16 bit signed int
    T_32PINT2       = 0x0472,   // 32 bit pointer to 16 bit signed int
    T_32PFINT2      = 0x0572,   // 16:32 pointer to 16 bit signed int
    T_64PINT2       = 0x0672,   // 64 bit pointer to 16 bit signed int

    T_UINT2         = 0x0073,   // 16 bit unsigned int
    T_PUINT2        = 0x0173,   // 16 bit pointer to 16 bit unsigned int
    T_PFUINT2       = 0x0273,   // 16:16 far pointer to 16 bit unsigned int
    T_PHUINT2       = 0x0373,   // 16:16 huge pointer to 16 bit unsigned int
    T_32PUINT2      = 0x0473,   // 32 bit pointer to 16 bit unsigned int
    T_32PFUINT2     = 0x0573,   // 16:32 pointer to 16 bit unsigned int
    T_64PUINT2      = 0x0673,   // 64 bit pointer to 16 bit unsigned int


//      32 bit long types

    T_LONG          = 0x0012,   // 32 bit signed
    T_ULONG         = 0x0022,   // 32 bit unsigned
    T_PLONG         = 0x0112,   // 16 bit pointer to 32 bit signed
    T_PULONG        = 0x0122,   // 16 bit pointer to 32 bit unsigned
    T_PFLONG        = 0x0212,   // 16:16 far pointer to 32 bit signed
    T_PFULONG       = 0x0222,   // 16:16 far pointer to 32 bit unsigned
    T_PHLONG        = 0x0312,   // 16:16 huge pointer to 32 bit signed
    T_PHULONG       = 0x0322,   // 16:16 huge pointer to 32 bit unsigned

    T_32PLONG       = 0x0412,   // 32 bit pointer to 32 bit signed
    T_32PULONG      = 0x0422,   // 32 bit pointer to 32 bit unsigned
    T_32PFLONG      = 0x0512,   // 16:32 pointer to 32 bit signed
    T_32PFULONG     = 0x0522,   // 16:32 pointer to 32 bit unsigned
    T_64PLONG       = 0x0612,   // 64 bit pointer to 32 bit signed
    T_64PULONG      = 0x0622,   // 64 bit pointer to 32 bit unsigned


//      32 bit int types

    T_INT4          = 0x0074,   // 32 bit signed int
    T_PINT4         = 0x0174,   // 16 bit pointer to 32 bit signed int
    T_PFINT4        = 0x0274,   // 16:16 far pointer to 32 bit signed int
    T_PHINT4        = 0x0374,   // 16:16 huge pointer to 32 bit signed int
    T_32PINT4       = 0x0474,   // 32 bit pointer to 32 bit signed int
    T_32PFINT4      = 0x0574,   // 16:32 pointer to 32 bit signed int
    T_64PINT4       = 0x0674,   // 64 bit pointer to 32 bit signed int

    T_UINT4         = 0x0075,   // 32 bit unsigned int
    T_PUINT4        = 0x0175,   // 16 bit pointer to 32 bit unsigned int
    T_PFUINT4       = 0x0275,   // 16:16 far pointer to 32 bit unsigned int
    T_PHUINT4       = 0x0375,   // 16:16 huge pointer to 32 bit unsigned int
    T_32PUINT4      = 0x0475,   // 32 bit pointer to 32 bit unsigned int
    T_32PFUINT4     = 0x0575,   // 16:32 pointer to 32 bit unsigned int
    T_64PUINT4      = 0x0675,   // 64 bit pointer to 32 bit unsigned int


//      64 bit quad types

    T_QUAD          = 0x0013,   // 64 bit signed
    T_PQUAD         = 0x0113,   // 16 bit pointer to 64 bit signed
    T_PFQUAD        = 0x0213,   // 16:16 far pointer to 64 bit signed
    T_PHQUAD        = 0x0313,   // 16:16 huge pointer to 64 bit signed
    T_32PQUAD       = 0x0413,   // 32 bit pointer to 64 bit signed
    T_32PFQUAD      = 0x0513,   // 16:32 pointer to 64 bit signed
    T_64PQUAD       = 0x0613,   // 64 bit pointer to 64 bit signed

    T_UQUAD         = 0x0023,   // 64 bit unsigned
    T_PUQUAD        = 0x0123,   // 16 bit pointer to 64 bit unsigned
    T_PFUQUAD       = 0x0223,   // 16:16 far pointer to 64 bit unsigned
    T_PHUQUAD       = 0x0323,   // 16:16 huge pointer to 64 bit unsigned
    T_32PUQUAD      = 0x0423,   // 32 bit pointer to 64 bit unsigned
    T_32PFUQUAD     = 0x0523,   // 16:32 pointer to 64 bit unsigned
    T_64PUQUAD      = 0x0623,   // 64 bit pointer to 64 bit unsigned


//      64 bit int types

    T_INT8          = 0x0076,   // 64 bit signed int
    T_PINT8         = 0x0176,   // 16 bit pointer to 64 bit signed int
    T_PFINT8        = 0x0276,   // 16:16 far pointer to 64 bit signed int
    T_PHINT8        = 0x0376,   // 16:16 huge pointer to 64 bit signed int
    T_32PINT8       = 0x0476,   // 32 bit pointer to 64 bit signed int
    T_32PFINT8      = 0x0576,   // 16:32 pointer to 64 bit signed int
    T_64PINT8       = 0x0676,   // 64 bit pointer to 64 bit signed int

    T_UINT8         = 0x0077,   // 64 bit unsigned int
    T_PUINT8        = 0x0177,   // 16 bit pointer to 64 bit unsigned int
    T_PFUINT8       = 0x0277,   // 16:16 far pointer to 64 bit unsigned int
    T_PHUINT8       = 0x0377,   // 16:16 huge pointer to 64 bit unsigned int
    T_32PUINT8      = 0x0477,   // 32 bit pointer to 64 bit unsigned int
    T_32PFUINT8     = 0x0577,   // 16:32 pointer to 64 bit unsigned int
    T_64PUINT8      = 0x0677,   // 64 bit pointer to 64 bit unsigned int


//      128 bit octet types

    T_OCT           = 0x0014,   // 128 bit signed
    T_POCT          = 0x0114,   // 16 bit pointer to 128 bit signed
    T_PFOCT         = 0x0214,   // 16:16 far pointer to 128 bit signed
    T_PHOCT         = 0x0314,   // 16:16 huge pointer to 128 bit signed
    T_32POCT        = 0x0414,   // 32 bit pointer to 128 bit signed
    T_32PFOCT       = 0x0514,   // 16:32 pointer to 128 bit signed
    T_64POCT        = 0x0614,   // 64 bit pointer to 128 bit signed

    T_UOCT          = 0x0024,   // 128 bit unsigned
    T_PUOCT         = 0x0124,   // 16 bit pointer to 128 bit unsigned
    T_PFUOCT        = 0x0224,   // 16:16 far pointer to 128 bit unsigned
    T_PHUOCT        = 0x0324,   // 16:16 huge pointer to 128 bit unsigned
    T_32PUOCT       = 0x0424,   // 32 bit pointer to 128 bit unsigned
    T_32PFUOCT      = 0x0524,   // 16:32 pointer to 128 bit unsigned
    T_64PUOCT       = 0x0624,   // 64 bit pointer to 128 bit unsigned


//      128 bit int types

    T_INT16         = 0x0078,   // 128 bit signed int
    T_PINT16        = 0x0178,   // 16 bit pointer to 128 bit signed int
    T_PFINT16       = 0x0278,   // 16:16 far pointer to 128 bit signed int
    T_PHINT16       = 0x0378,   // 16:16 huge pointer to 128 bit signed int
    T_32PINT16      = 0x0478,   // 32 bit pointer to 128 bit signed int
    T_32PFINT16     = 0x0578,   // 16:32 pointer to 128 bit signed int
    T_64PINT16      = 0x0678,   // 64 bit pointer to 128 bit signed int

    T_UINT16        = 0x0079,   // 128 bit unsigned int
    T_PUINT16       = 0x0179,   // 16 bit pointer to 128 bit unsigned int
    T_PFUINT16      = 0x0279,   // 16:16 far pointer to 128 bit unsigned int
    T_PHUINT16      = 0x0379,   // 16:16 huge pointer to 128 bit unsigned int
    T_32PUINT16     = 0x0479,   // 32 bit pointer to 128 bit unsigned int
    T_32PFUINT16    = 0x0579,   // 16:32 pointer to 128 bit unsigned int
    T_64PUINT16     = 0x0679,   // 64 bit pointer to 128 bit unsigned int


//      32 bit real types

    T_REAL32        = 0x0040,   // 32 bit real
    T_PREAL32       = 0x0140,   // 16 bit pointer to 32 bit real
    T_PFREAL32      = 0x0240,   // 16:16 far pointer to 32 bit real
    T_PHREAL32      = 0x0340,   // 16:16 huge pointer to 32 bit real
    T_32PREAL32     = 0x0440,   // 32 bit pointer to 32 bit real
    T_32PFREAL32    = 0x0540,   // 16:32 pointer to 32 bit real
    T_64PREAL32     = 0x0640,   // 64 bit pointer to 32 bit real


//      48 bit real types

    T_REAL48        = 0x0044,   // 48 bit real
    T_PREAL48       = 0x0144,   // 16 bit pointer to 48 bit real
    T_PFREAL48      = 0x0244,   // 16:16 far pointer to 48 bit real
    T_PHREAL48      = 0x0344,   // 16:16 huge pointer to 48 bit real
    T_32PREAL48     = 0x0444,   // 32 bit pointer to 48 bit real
    T_32PFREAL48    = 0x0544,   // 16:32 pointer to 48 bit real
    T_64PREAL48     = 0x0644,   // 64 bit pointer to 48 bit real


//      64 bit real types

    T_REAL64        = 0x0041,   // 64 bit real
    T_PREAL64       = 0x0141,   // 16 bit pointer to 64 bit real
    T_PFREAL64      = 0x0241,   // 16:16 far pointer to 64 bit real
    T_PHREAL64      = 0x0341,   // 16:16 huge pointer to 64 bit real
    T_32PREAL64     = 0x0441,   // 32 bit pointer to 64 bit real
    T_32PFREAL64    = 0x0541,   // 16:32 pointer to 64 bit real
    T_64PREAL64     = 0x0641,   // 64 bit pointer to 64 bit real


//      80 bit real types

    T_REAL80        = 0x0042,   // 80 bit real
    T_PREAL80       = 0x0142,   // 16 bit pointer to 80 bit real
    T_PFREAL80      = 0x0242,   // 16:16 far pointer to 80 bit real
    T_PHREAL80      = 0x0342,   // 16:16 huge pointer to 80 bit real
    T_32PREAL80     = 0x0442,   // 32 bit pointer to 80 bit real
    T_32PFREAL80    = 0x0542,   // 16:32 pointer to 80 bit real
    T_64PREAL80     = 0x0642,   // 64 bit pointer to 80 bit real


//      128 bit real types

    T_REAL128       = 0x0043,   // 128 bit real
    T_PREAL128      = 0x0143,   // 16 bit pointer to 128 bit real
    T_PFREAL128     = 0x0243,   // 16:16 far pointer to 128 bit real
    T_PHREAL128     = 0x0343,   // 16:16 huge pointer to 128 bit real
    T_32PREAL128    = 0x0443,   // 32 bit pointer to 128 bit real
    T_32PFREAL128   = 0x0543,   // 16:32 pointer to 128 bit real
    T_64PREAL128    = 0x0643,   // 64 bit pointer to 128 bit real


//      32 bit complex types

    T_CPLX32        = 0x0050,   // 32 bit complex
    T_PCPLX32       = 0x0150,   // 16 bit pointer to 32 bit complex
    T_PFCPLX32      = 0x0250,   // 16:16 far pointer to 32 bit complex
    T_PHCPLX32      = 0x0350,   // 16:16 huge pointer to 32 bit complex
    T_32PCPLX32     = 0x0450,   // 32 bit pointer to 32 bit complex
    T_32PFCPLX32    = 0x0550,   // 16:32 pointer to 32 bit complex
    T_64PCPLX32     = 0x0650,   // 64 bit pointer to 32 bit complex


//      64 bit complex types

    T_CPLX64        = 0x0051,   // 64 bit complex
    T_PCPLX64       = 0x0151,   // 16 bit pointer to 64 bit complex
    T_PFCPLX64      = 0x0251,   // 16:16 far pointer to 64 bit complex
    T_PHCPLX64      = 0x0351,   // 16:16 huge pointer to 64 bit complex
    T_32PCPLX64     = 0x0451,   // 32 bit pointer to 64 bit complex
    T_32PFCPLX64    = 0x0551,   // 16:32 pointer to 64 bit complex
    T_64PCPLX64     = 0x0651,   // 64 bit pointer to 64 bit complex


//      80 bit complex types

    T_CPLX80        = 0x0052,   // 80 bit complex
    T_PCPLX80       = 0x0152,   // 16 bit pointer to 80 bit complex
    T_PFCPLX80      = 0x0252,   // 16:16 far pointer to 80 bit complex
    T_PHCPLX80      = 0x0352,   // 16:16 huge pointer to 80 bit complex
    T_32PCPLX80     = 0x0452,   // 32 bit pointer to 80 bit complex
    T_32PFCPLX80    = 0x0552,   // 16:32 pointer to 80 bit complex
    T_64PCPLX80     = 0x0652,   // 64 bit pointer to 80 bit complex


//      128 bit complex types

    T_CPLX128       = 0x0053,   // 128 bit complex
    T_PCPLX128      = 0x0153,   // 16 bit pointer to 128 bit complex
    T_PFCPLX128     = 0x0253,   // 16:16 far pointer to 128 bit complex
    T_PHCPLX128     = 0x0353,   // 16:16 huge pointer to 128 bit real
    T_32PCPLX128    = 0x0453,   // 32 bit pointer to 128 bit complex
    T_32PFCPLX128   = 0x0553,   // 16:32 pointer to 128 bit complex
    T_64PCPLX128    = 0x0653,   // 64 bit pointer to 128 bit complex


//      boolean types

    T_BOOL08        = 0x0030,   // 8 bit boolean
    T_PBOOL08       = 0x0130,   // 16 bit pointer to  8 bit boolean
    T_PFBOOL08      = 0x0230,   // 16:16 far pointer to  8 bit boolean
    T_PHBOOL08      = 0x0330,   // 16:16 huge pointer to  8 bit boolean
    T_32PBOOL08     = 0x0430,   // 32 bit pointer to 8 bit boolean
    T_32PFBOOL08    = 0x0530,   // 16:32 pointer to 8 bit boolean
    T_64PBOOL08     = 0x0630,   // 64 bit pointer to 8 bit boolean

    T_BOOL16        = 0x0031,   // 16 bit boolean
    T_PBOOL16       = 0x0131,   // 16 bit pointer to 16 bit boolean
    T_PFBOOL16      = 0x0231,   // 16:16 far pointer to 16 bit boolean
    T_PHBOOL16      = 0x0331,   // 16:16 huge pointer to 16 bit boolean
    T_32PBOOL16     = 0x0431,   // 32 bit pointer to 18 bit boolean
    T_32PFBOOL16    = 0x0531,   // 16:32 pointer to 16 bit boolean
    T_64PBOOL16     = 0x0631,   // 64 bit pointer to 18 bit boolean

    T_BOOL32        = 0x0032,   // 32 bit boolean
    T_PBOOL32       = 0x0132,   // 16 bit pointer to 32 bit boolean
    T_PFBOOL32      = 0x0232,   // 16:16 far pointer to 32 bit boolean
    T_PHBOOL32      = 0x0332,   // 16:16 huge pointer to 32 bit boolean
    T_32PBOOL32     = 0x0432,   // 32 bit pointer to 32 bit boolean
    T_32PFBOOL32    = 0x0532,   // 16:32 pointer to 32 bit boolean
    T_64PBOOL32     = 0x0632,   // 64 bit pointer to 32 bit boolean

    T_BOOL64        = 0x0033,   // 64 bit boolean
    T_PBOOL64       = 0x0133,   // 16 bit pointer to 64 bit boolean
    T_PFBOOL64      = 0x0233,   // 16:16 far pointer to 64 bit boolean
    T_PHBOOL64      = 0x0333,   // 16:16 huge pointer to 64 bit boolean
    T_32PBOOL64     = 0x0433,   // 32 bit pointer to 64 bit boolean
    T_32PFBOOL64    = 0x0533,   // 16:32 pointer to 64 bit boolean
    T_64PBOOL64     = 0x0633,   // 64 bit pointer to 64 bit boolean


//      ???

    T_NCVPTR        = 0x01f0,   // CV Internal type for created near pointers
    T_FCVPTR        = 0x02f0,   // CV Internal type for created far pointers
    T_HCVPTR        = 0x03f0,   // CV Internal type for created huge pointers
    T_32NCVPTR      = 0x04f0,   // CV Internal type for created near 32-bit pointers
    T_32FCVPTR      = 0x05f0,   // CV Internal type for created far 32-bit pointers
    T_64NCVPTR      = 0x06f0,   // CV Internal type for created near 64-bit pointers

} TYPE_ENUM_e;

/**     No leaf index can have a value of 0x0000.  The leaf indices are
 *      separated into ranges depending upon the use of the type record.
 *      The second range is for the type records that are directly referenced
 *      in symbols. The first range is for type records that are not
 *      referenced by symbols but instead are referenced by other type
 *      records.  All type records must have a starting leaf index in these
 *      first two ranges.  The third range of leaf indices are used to build
 *      up complex lists such as the field list of a class type record.  No
 *      type record can begin with one of the leaf indices. The fourth ranges
 *      of type indices are used to represent numeric data in a symbol or
 *      type record. These leaf indices are greater than 0x8000.  At the
 *      point that type or symbol processor is expecting a numeric field, the
 *      next two bytes in the type record are examined.  If the value is less
 *      than 0x8000, then the two bytes contain the numeric value.  If the
 *      value is greater than 0x8000, then the data follows the leaf index in
 *      a format specified by the leaf index. The final range of leaf indices
 *      are used to force alignment of subfields within a complex type record..
 */


typedef enum LEAF_ENUM_e {
    // leaf indices starting records but referenced from symbol records

    LF_MODIFIER_16t     = 0x0001,
    LF_POINTER_16t      = 0x0002,
    LF_ARRAY_16t        = 0x0003,
    LF_CLASS_16t        = 0x0004,
    LF_STRUCTURE_16t    = 0x0005,
    LF_UNION_16t        = 0x0006,
    LF_ENUM_16t         = 0x0007,
    LF_PROCEDURE_16t    = 0x0008,
    LF_MFUNCTION_16t    = 0x0009,
    LF_VTSHAPE          = 0x000a,
    LF_COBOL0_16t       = 0x000b,
    LF_COBOL1           = 0x000c,
    LF_BARRAY_16t       = 0x000d,
    LF_LABEL            = 0x000e,
    LF_NULL             = 0x000f,
    LF_NOTTRAN          = 0x0010,
    LF_DIMARRAY_16t     = 0x0011,
    LF_VFTPATH_16t      = 0x0012,
    LF_PRECOMP_16t      = 0x0013,       // not referenced from symbol
    LF_ENDPRECOMP       = 0x0014,       // not referenced from symbol
    LF_OEM_16t          = 0x0015,       // oem definable type string
#ifdef LNGNM
    LF_TYPESERVER_ST    = 0x0016,       // not referenced from symbol
#else
    LF_TYPESERVER       = 0x0016,       // not referenced from symbol
#endif

    // leaf indices starting records but referenced only from type records

    LF_SKIP_16t         = 0x0200,
    LF_ARGLIST_16t      = 0x0201,
    LF_DEFARG_16t       = 0x0202,
    LF_LIST             = 0x0203,
    LF_FIELDLIST_16t    = 0x0204,
    LF_DERIVED_16t      = 0x0205,
    LF_BITFIELD_16t     = 0x0206,
    LF_METHODLIST_16t   = 0x0207,
    LF_DIMCONU_16t      = 0x0208,
    LF_DIMCONLU_16t     = 0x0209,
    LF_DIMVARU_16t      = 0x020a,
    LF_DIMVARLU_16t     = 0x020b,
    LF_REFSYM           = 0x020c,

    LF_BCLASS_16t       = 0x0400,
    LF_VBCLASS_16t      = 0x0401,
    LF_IVBCLASS_16t     = 0x0402,
#ifdef LNGNM
    LF_ENUMERATE_ST     = 0x0403,
#else
    LF_ENUMERATE        = 0x0403,
#endif
    LF_FRIENDFCN_16t    = 0x0404,
    LF_INDEX_16t        = 0x0405,
    LF_MEMBER_16t       = 0x0406,
    LF_STMEMBER_16t     = 0x0407,
    LF_METHOD_16t       = 0x0408,
    LF_NESTTYPE_16t     = 0x0409,
    LF_VFUNCTAB_16t     = 0x040a,
    LF_FRIENDCLS_16t    = 0x040b,
    LF_ONEMETHOD_16t    = 0x040c,
    LF_VFUNCOFF_16t     = 0x040d,

// 32-bit type index versions of leaves, all have the 0x1000 bit set
//
    LF_TI16_MAX         = 0x1000,

    LF_MODIFIER         = 0x1001,
    LF_POINTER          = 0x1002,
#ifdef LNGNM
    LF_ARRAY_ST         = 0x1003,
    LF_CLASS_ST         = 0x1004,
    LF_STRUCTURE_ST     = 0x1005,
    LF_UNION_ST         = 0x1006,
    LF_ENUM_ST          = 0x1007,
#else
    LF_ARRAY            = 0x1003,
    LF_CLASS            = 0x1004,
    LF_STRUCTURE        = 0x1005,
    LF_UNION            = 0x1006,
    LF_ENUM             = 0x1007,
#endif
    LF_PROCEDURE        = 0x1008,
    LF_MFUNCTION        = 0x1009,
    LF_COBOL0           = 0x100a,
    LF_BARRAY           = 0x100b,
#ifdef LNGNM
    LF_DIMARRAY_ST      = 0x100c,
#else
    LF_DIMARRAY         = 0x100c,
#endif
    LF_VFTPATH          = 0x100d,
#ifdef LNGNM
    LF_PRECOMP_ST       = 0x100e,       // not referenced from symbol
#else
    LF_PRECOMP          = 0x100e,       // not referenced from symbol
#endif
    LF_OEM              = 0x100f,       // oem definable type string
#ifdef LNGNM
    LF_ALIAS_ST         = 0x1010,       // alias (typedef) type
#else
    LF_ALIAS            = 0x1010,       // alias (typedef) type
#endif
    LF_OEM2             = 0x1011,       // oem definable type string

    // leaf indices starting records but referenced only from type records

    LF_SKIP             = 0x1200,
    LF_ARGLIST          = 0x1201,
#ifdef LNGNM
    LF_DEFARG_ST        = 0x1202,
#else
    LF_DEFARG           = 0x1202,
#endif
    LF_FIELDLIST        = 0x1203,
    LF_DERIVED          = 0x1204,
    LF_BITFIELD         = 0x1205,
    LF_METHODLIST       = 0x1206,
    LF_DIMCONU          = 0x1207,
    LF_DIMCONLU         = 0x1208,
    LF_DIMVARU          = 0x1209,
    LF_DIMVARLU         = 0x120a,

    LF_BCLASS           = 0x1400,
    LF_VBCLASS          = 0x1401,
    LF_IVBCLASS         = 0x1402,
#ifdef LNGNM
    LF_FRIENDFCN_ST     = 0x1403,
#else
    LF_FRIENDFCN        = 0x1403,
#endif
    LF_INDEX            = 0x1404,
#ifdef LNGNM
    LF_MEMBER_ST        = 0x1405,
    LF_STMEMBER_ST      = 0x1406,
    LF_METHOD_ST        = 0x1407,
    LF_NESTTYPE_ST      = 0x1408,
#else
    LF_MEMBER           = 0x1405,
    LF_STMEMBER         = 0x1406,
    LF_METHOD           = 0x1407,
    LF_NESTTYPE         = 0x1408,
#endif
    LF_VFUNCTAB         = 0x1409,
    LF_FRIENDCLS        = 0x140a,
#ifdef LNGNM
    LF_ONEMETHOD_ST     = 0x140b,
#else
    LF_ONEMETHOD        = 0x140b,
#endif
    LF_VFUNCOFF         = 0x140c,
#ifndef LNGNM
    LF_NESTTYPEEX       = 0x140d,
    LF_MEMBERMODIFY     = 0x140e,
    LF_MANAGED          = 0x140f,

#else
    LF_NESTTYPEEX_ST    = 0x140d,
    LF_MEMBERMODIFY_ST  = 0x140e,
    LF_MANAGED_ST       = 0x140f,

    // Types w/ SZ names

    LF_ST_MAX           = 0x1500,

    LF_TYPESERVER       = 0x1501,       // not referenced from symbol
    LF_ENUMERATE        = 0x1502,
    LF_ARRAY            = 0x1503,
    LF_CLASS            = 0x1504,
    LF_STRUCTURE        = 0x1505,
    LF_UNION            = 0x1506,
    LF_ENUM             = 0x1507,
    LF_DIMARRAY         = 0x1508,
    LF_PRECOMP          = 0x1509,       // not referenced from symbol
    LF_ALIAS            = 0x150a,       // alias (typedef) type
    LF_DEFARG           = 0x150b,
    LF_FRIENDFCN        = 0x150c,
    LF_MEMBER           = 0x150d,
    LF_STMEMBER         = 0x150e,
    LF_METHOD           = 0x150f,
    LF_NESTTYPE         = 0x1510,
    LF_ONEMETHOD        = 0x1511,
    LF_NESTTYPEEX       = 0x1512,
    LF_MEMBERMODIFY     = 0x1513,
    LF_MANAGED          = 0x1514,
    LF_TYPESERVER2      = 0x1515,
#endif


    LF_NUMERIC          = 0x8000,
    LF_CHAR             = 0x8000,
    LF_SHORT            = 0x8001,
    LF_USHORT           = 0x8002,
    LF_LONG             = 0x8003,
    LF_ULONG            = 0x8004,
    LF_REAL32           = 0x8005,
    LF_REAL64           = 0x8006,
    LF_REAL80           = 0x8007,
    LF_REAL128          = 0x8008,
    LF_QUADWORD         = 0x8009,
    LF_UQUADWORD        = 0x800a,
    LF_REAL48           = 0x800b,
    LF_COMPLEX32        = 0x800c,
    LF_COMPLEX64        = 0x800d,
    LF_COMPLEX80        = 0x800e,
    LF_COMPLEX128       = 0x800f,
    LF_VARSTRING        = 0x8010,

    LF_OCTWORD          = 0x8017,
    LF_UOCTWORD         = 0x8018,

    LF_DECIMAL          = 0x8019,
    LF_DATE             = 0x801a,
    LF_UTF8STRING       = 0x801b,

    LF_PAD0             = 0xf0,
    LF_PAD1             = 0xf1,
    LF_PAD2             = 0xf2,
    LF_PAD3             = 0xf3,
    LF_PAD4             = 0xf4,
    LF_PAD5             = 0xf5,
    LF_PAD6             = 0xf6,
    LF_PAD7             = 0xf7,
    LF_PAD8             = 0xf8,
    LF_PAD9             = 0xf9,
    LF_PAD10            = 0xfa,
    LF_PAD11            = 0xfb,
    LF_PAD12            = 0xfc,
    LF_PAD13            = 0xfd,
    LF_PAD14            = 0xfe,
    LF_PAD15            = 0xff,

} LEAF_ENUM_e;

// end of leaf indices




//      Type enum for pointer records
//      Pointers can be one of the following types


typedef enum CV_ptrtype_e {
    CV_PTR_NEAR         = 0x00, // 16 bit pointer
    CV_PTR_FAR          = 0x01, // 16:16 far pointer
    CV_PTR_HUGE         = 0x02, // 16:16 huge pointer
    CV_PTR_BASE_SEG     = 0x03, // based on segment
    CV_PTR_BASE_VAL     = 0x04, // based on value of base
    CV_PTR_BASE_SEGVAL  = 0x05, // based on segment value of base
    CV_PTR_BASE_ADDR    = 0x06, // based on address of base
    CV_PTR_BASE_SEGADDR = 0x07, // based on segment address of base
    CV_PTR_BASE_TYPE    = 0x08, // based on type
    CV_PTR_BASE_SELF    = 0x09, // based on self
    CV_PTR_NEAR32       = 0x0a, // 32 bit pointer
    CV_PTR_FAR32        = 0x0b, // 16:32 pointer
    CV_PTR_64           = 0x0c, // 64 bit pointer
    CV_PTR_UNUSEDPTR    = 0x0d  // first unused pointer type
} CV_ptrtype_e;





//      Mode enum for pointers
//      Pointers can have one of the following modes


typedef enum CV_ptrmode_e {
    CV_PTR_MODE_PTR     = 0x00, // "normal" pointer
    CV_PTR_MODE_REF     = 0x01, // reference
    CV_PTR_MODE_PMEM    = 0x02, // pointer to data member
    CV_PTR_MODE_PMFUNC  = 0x03, // pointer to member function
    CV_PTR_MODE_RESERVED= 0x04  // first unused pointer mode
} CV_ptrmode_e;


//      enumeration for method properties

typedef enum CV_methodprop_e {
    CV_MTvanilla        = 0x00,
    CV_MTvirtual        = 0x01,
    CV_MTstatic         = 0x02,
    CV_MTfriend         = 0x03,
    CV_MTintro          = 0x04,
    CV_MTpurevirt       = 0x05,
    CV_MTpureintro      = 0x06
} CV_methodprop_e;




//      enumeration for virtual shape table entries

typedef enum CV_VTS_desc_e {
    CV_VTS_near         = 0x00,
    CV_VTS_far          = 0x01,
    CV_VTS_thin         = 0x02,
    CV_VTS_outer        = 0x03,
    CV_VTS_meta         = 0x04,
    CV_VTS_near32       = 0x05,
    CV_VTS_far32        = 0x06,
    CV_VTS_unused       = 0x07
} CV_VTS_desc_e;




//      enumeration for LF_LABEL address modes

typedef enum CV_LABEL_TYPE_e {
    CV_LABEL_NEAR = 0,       // near return
    CV_LABEL_FAR  = 4        // far return
} CV_LABEL_TYPE_e;



//      enumeration for LF_MODIFIER values


typedef struct CV_modifier_t {
    unsigned short  MOD_const       :1;
    unsigned short  MOD_volatile    :1;
    unsigned short  MOD_unaligned   :1;
    unsigned short  MOD_unused      :13;
} CV_modifier_t;


//  bit field structure describing class/struct/union/enum properties

typedef struct CV_prop_t {
    unsigned short  packed      :1;     // true if structure is packed
    unsigned short  ctor        :1;     // true if constructors or destructors present
    unsigned short  ovlops      :1;     // true if overloaded operators present
    unsigned short  isnested    :1;     // true if this is a nested class
    unsigned short  cnested     :1;     // true if this class contains nested types
    unsigned short  opassign    :1;     // true if overloaded assignment (=)
    unsigned short  opcast      :1;     // true if casting methods
    unsigned short  fwdref      :1;     // true if forward reference (incomplete defn)
    unsigned short  scoped      :1;     // scoped definition
    unsigned short  reserved    :7;
} CV_prop_t;




//  class field attribute

typedef struct CV_fldattr_t {
    unsigned short  access      :2;     // access protection CV_access_t
    unsigned short  mprop       :3;     // method properties CV_methodprop_t
    unsigned short  pseudo      :1;     // compiler generated fcn and does not exist
    unsigned short  noinherit   :1;     // true if class cannot be inherited
    unsigned short  noconstruct :1;     // true if class cannot be constructed
    unsigned short  compgenx    :1;     // compiler generated fcn and does exist
    unsigned short  unused      :7;     // unused
} CV_fldattr_t;



//  Structures to access to the type records


typedef struct TYPTYPE {
    unsigned short  len;
    unsigned short  leaf;
    unsigned char   data[CV_ZEROLEN];
} TYPTYPE;          // general types record


__INLINE char *NextType (char * pType) {
    return (pType + ((TYPTYPE *)pType)->len + sizeof(unsigned short));
}

typedef enum CV_PMEMBER {
    CV_PDM16_NONVIRT    = 0x00, // 16:16 data no virtual fcn or base
    CV_PDM16_VFCN       = 0x01, // 16:16 data with virtual functions
    CV_PDM16_VBASE      = 0x02, // 16:16 data with virtual bases
    CV_PDM32_NVVFCN     = 0x03, // 16:32 data w/wo virtual functions
    CV_PDM32_VBASE      = 0x04, // 16:32 data with virtual bases

    CV_PMF16_NEARNVSA   = 0x05, // 16:16 near method nonvirtual single address point
    CV_PMF16_NEARNVMA   = 0x06, // 16:16 near method nonvirtual multiple address points
    CV_PMF16_NEARVBASE  = 0x07, // 16:16 near method virtual bases
    CV_PMF16_FARNVSA    = 0x08, // 16:16 far method nonvirtual single address point
    CV_PMF16_FARNVMA    = 0x09, // 16:16 far method nonvirtual multiple address points
    CV_PMF16_FARVBASE   = 0x0a, // 16:16 far method virtual bases

    CV_PMF32_NVSA       = 0x0b, // 16:32 method nonvirtual single address point
    CV_PMF32_NVMA       = 0x0c, // 16:32 method nonvirtual multiple address point
    CV_PMF32_VBASE      = 0x0d  // 16:32 method virtual bases
} CV_PMEMBER;



//  memory representation of pointer to member.  These representations are
//  indexed by the enumeration above in the LF_POINTER record




//  representation of a 16:16 pointer to data for a class with no
//  virtual functions or virtual bases


struct CV_PDMR16_NONVIRT {
    CV_off16_t      mdisp;      // displacement to data (NULL = -1)
};




//  representation of a 16:16 pointer to data for a class with virtual
//  functions


struct CV_PMDR16_VFCN {
    CV_off16_t      mdisp;      // displacement to data ( NULL = 0)
};




//  representation of a 16:16 pointer to data for a class with
//  virtual bases


struct CV_PDMR16_VBASE {
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement to vbptr
    CV_off16_t      vdisp;      // displacement within vbase table
                                // NULL = (,,0xffff)
};




//  representation of a 32 bit pointer to data for a class with
//  or without virtual functions and no virtual bases


struct CV_PDMR32_NVVFCN {
    CV_off32_t      mdisp;      // displacement to data (NULL = 0x80000000)
};




//  representation of a 32 bit pointer to data for a class
//  with virtual bases


struct CV_PDMR32_VBASE {
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
                                // NULL = (,,0xffffffff)
};




//  representation of a 16:16 pointer to near member function for a
//  class with no virtual functions or bases and a single address point


struct CV_PMFR16_NEARNVSA {
    CV_uoff16_t     off;        // near address of function (NULL = 0)
};



//  representation of a 16 bit pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_NEARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x)
    signed short    disp;
};




//  representation of a 16 bit pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_NEARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0,x,x,x)
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement
};




//  representation of a 16:16 pointer to far member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR16_FARNVSA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0)
    unsigned short  seg;        // segment of function
};




//  representation of a 16:16 far pointer to member functions of a
//  class with no virtual bases and multiple address points


struct CV_PMFR16_FARNVMA {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x)
    unsigned short  seg;
    signed short    disp;
};




//  representation of a 16:16 far pointer to member function of a
//  class with virtual bases


struct CV_PMFR16_FARVBASE {
    CV_uoff16_t     off;        // offset of function (NULL = 0:0,x,x,x)
    unsigned short  seg;
    CV_off16_t      mdisp;      // displacement to data
    CV_off16_t      pdisp;      // this pointer displacement
    CV_off16_t      vdisp;      // vbase table displacement

};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and a single address point


struct CV_PMFR32_NVSA {
    CV_uoff32_t      off;        // near address of function (NULL = 0L)
};




//  representation of a 32 bit pointer to member function for a
//  class with no virtual bases and multiple address points


struct CV_PMFR32_NVMA {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x)
    CV_off32_t      disp;
};




//  representation of a 32 bit pointer to member function for a
//  class with virtual bases


struct CV_PMFR32_VBASE {
    CV_uoff32_t     off;        // near address of function (NULL = 0L,x,x,x)
    CV_off32_t      mdisp;      // displacement to data
    CV_off32_t      pdisp;      // this pointer displacement
    CV_off32_t      vdisp;      // vbase table displacement
};





//  Easy leaf - used for generic casting to reference leaf field
//  of a subfield of a complex list

typedef struct lfEasy {
    unsigned short  leaf;           // LF_...
} lfEasy;


/**     The following type records are basically variant records of the
 *      above structure.  The "unsigned short leaf" of the above structure and
 *      the "unsigned short leaf" of the following type definitions are the same
 *      symbol.  When the OMF record is locked via the MHOMFLock API
 *      call, the address of the "unsigned short leaf" is returned
 */

/**     Notes on alignment
 *      Alignment of the fields in most of the type records is done on the
 *      basis of the TYPTYPE record base.  That is why in most of the lf*
 *      records that the CV_typ_t (32-bit types) is located on what appears to
 *      be a offset mod 4 == 2 boundary.  The exception to this rule are those
 *      records that are in a list (lfFieldList, lfMethodList), which are
 *      aligned to their own bases since they don't have the length field
 */

/**** Change log for 16-bit to 32-bit type and symbol records

    Record type         Change (f == field arrangement, p = padding added)
    ----------------------------------------------------------------------
    lfModifer           f
    lfPointer           fp
    lfClass             f
    lfStructure         f
    lfUnion             f
    lfEnum              f
    lfVFTPath           p
    lfPreComp           p
    lfOEM               p
    lfArgList           p
    lfDerived           p
    mlMethod            p   (method list member)
    lfBitField          f
    lfDimCon            f
    lfDimVar            p
    lfIndex             p   (field list member)
    lfBClass            f   (field list member)
    lfVBClass           f   (field list member)
    lfFriendCls         p   (field list member)
    lfFriendFcn         p   (field list member)
    lfMember            f   (field list member)
    lfSTMember          f   (field list member)
    lfVFuncTab          p   (field list member)
    lfVFuncOff          p   (field list member)
    lfNestType          p   (field list member)

    DATASYM32           f
    PROCSYM32           f
    VPATHSYM32          f
    REGREL32            f
    THREADSYM32         f
    PROCSYMMIPS         f


*/

//      Type record for LF_MODIFIER

typedef struct lfModifier_16t {
    unsigned short  leaf;           // LF_MODIFIER_16t
    CV_modifier_t   attr;           // modifier attribute modifier_t
    CV_typ16_t      type;           // modified type
} lfModifier_16t;

typedef struct lfModifier {
    unsigned short  leaf;           // LF_MODIFIER
    CV_typ_t        type;           // modified type
    CV_modifier_t   attr;           // modifier attribute modifier_t
} lfModifier;




//      type record for LF_POINTER

#ifndef __cplusplus
typedef struct lfPointer_16t {
#endif
    struct lfPointerBody_16t {
        unsigned short      leaf;           // LF_POINTER_16t
        struct lfPointerAttr_16t {
            unsigned char   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned char   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned char   isflat32    :1; // true if 0:32 pointer
            unsigned char   isvolatile  :1; // TRUE if volatile pointer
            unsigned char   isconst     :1; // TRUE if const pointer
            unsigned char   isunaligned :1; // TRUE if unaligned pointer
            unsigned char   unused      :4;
        } attr;
        CV_typ16_t  utype;          // type index of the underlying type
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer_16t : public lfPointerBody_16t {
#endif
    union {
        struct {
            CV_typ16_t      pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ16_t      index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer_16t;

#ifndef __cplusplus
typedef struct lfPointer {
#endif
    struct lfPointerBody {
        unsigned short      leaf;           // LF_POINTER
        CV_typ_t            utype;          // type index of the underlying type
        struct lfPointerAttr {
            unsigned long   ptrtype     :5; // ordinal specifying pointer type (CV_ptrtype_e)
            unsigned long   ptrmode     :3; // ordinal specifying pointer mode (CV_ptrmode_e)
            unsigned long   isflat32    :1; // true if 0:32 pointer
            unsigned long   isvolatile  :1; // TRUE if volatile pointer
            unsigned long   isconst     :1; // TRUE if const pointer
            unsigned long   isunaligned :1; // TRUE if unaligned pointer
            unsigned long   isrestrict  :1; // TRUE if restricted pointer (allow agressive opts)
            unsigned long   unused      :19;// pad out to 32-bits for following cv_typ_t's
        } attr;
#if (defined(__cplusplus) || defined(_MSC_VER)) // for C++ and MS compilers that support unnamed unions
    };
#else
    } u;
#endif
#ifdef  __cplusplus
typedef struct lfPointer : public lfPointerBody {
#endif
    union {
        struct {
            CV_typ_t        pmclass;    // index of containing class for pointer to member
            unsigned short  pmenum;     // enumeration specifying pm format
        } pm;
        unsigned short      bseg;       // base segment if PTR_BASE_SEG
        unsigned char       Sym[1];     // copy of base symbol record (including length)
        struct  {
            CV_typ_t        index;      // type index if CV_PTR_BASE_TYPE
            unsigned char   name[1];    // name of base type
        } btype;
    } pbase;
} lfPointer;




//      type record for LF_ARRAY


typedef struct lfArray_16t {
    unsigned short  leaf;           // LF_ARRAY_16t
    CV_typ16_t      elemtype;       // type index of element type
    CV_typ16_t      idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray_16t;

typedef struct lfArray {
    unsigned short  leaf;           // LF_ARRAY
    CV_typ_t        elemtype;       // type index of element type
    CV_typ_t        idxtype;        // type index of indexing type
    unsigned char   data[CV_ZEROLEN];         // variable length data specifying
                                    // size in bytes and name
} lfArray;




//      type record for LF_CLASS, LF_STRUCTURE


typedef struct lfClass_16t {
    unsigned short  leaf;           // LF_CLASS_16t, LF_STRUCT_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ16_t      derived;        // type index of derived from list if not zero
    CV_typ16_t      vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass_16t;
typedef lfClass_16t lfStructure_16t;


typedef struct lfClass {
    unsigned short  leaf;           // LF_CLASS, LF_STRUCT
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field (prop_t)
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    CV_typ_t        derived;        // type index of derived from list if not zero
    CV_typ_t        vshape;         // type index of vshape table for this class
    unsigned char   data[CV_ZEROLEN];         // data describing length of structure in
                                    // bytes and name
} lfClass;
typedef lfClass lfStructure;




//      type record for LF_UNION


typedef struct lfUnion_16t {
    unsigned short  leaf;           // LF_UNION_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion_16t;


typedef struct lfUnion {
    unsigned short  leaf;           // LF_UNION
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   data[CV_ZEROLEN];         // variable length data describing length of
                                    // structure and name
} lfUnion;


//      type record for LF_ALIAS

typedef struct lfAlias {
    unsigned short  leaf;           // LF_ALIAS
    CV_typ_t        utype;          // underlying type
    unsigned char   Name[1];        // alias name
} lfAlias;


//      type record for LF_MANAGED

typedef struct lfManaged {
    unsigned short  leaf;           // LF_MANAGED
    unsigned char   Name[1];        // utf8, zero terminated managed type name
} lfManaged;


//      type record for LF_ENUM


typedef struct lfEnum_16t {
    unsigned short  leaf;           // LF_ENUM_16t
    unsigned short  count;          // count of number of elements in class
    CV_typ16_t      utype;          // underlying type of the enum
    CV_typ16_t      field;          // type index of LF_FIELD descriptor list
    CV_prop_t       property;       // property attribute field
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum_16t;

typedef struct lfEnum {
    unsigned short  leaf;           // LF_ENUM
    unsigned short  count;          // count of number of elements in class
    CV_prop_t       property;       // property attribute field
    CV_typ_t        utype;          // underlying type of the enum
    CV_typ_t        field;          // type index of LF_FIELD descriptor list
    unsigned char   Name[1];        // length prefixed name of enum
} lfEnum;




//      Type record for LF_PROCEDURE


typedef struct lfProc_16t {
    unsigned short  leaf;           // LF_PROCEDURE_16t
    CV_typ16_t      rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
} lfProc_16t;

typedef struct lfProc {
    unsigned short  leaf;           // LF_PROCEDURE
    CV_typ_t        rvtype;         // type index of return value
    unsigned char   calltype;       // calling convention (CV_call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
} lfProc;



//      Type record for member function


typedef struct lfMFunc_16t {
    unsigned short  leaf;           // LF_MFUNCTION_16t
    CV_typ16_t      rvtype;         // type index of return value
    CV_typ16_t      classtype;      // type index of containing class
    CV_typ16_t      thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ16_t      arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc_16t;

typedef struct lfMFunc {
    unsigned short  leaf;           // LF_MFUNCTION
    CV_typ_t        rvtype;         // type index of return value
    CV_typ_t        classtype;      // type index of containing class
    CV_typ_t        thistype;       // type index of this pointer (model specific)
    unsigned char   calltype;       // calling convention (call_t)
    unsigned char   reserved;       // reserved for future use
    unsigned short  parmcount;      // number of parameters
    CV_typ_t        arglist;        // type index of argument list
    long            thisadjust;     // this adjuster (long because pad required anyway)
} lfMFunc;




//     type record for virtual function table shape


typedef struct lfVTShape {
    unsigned short  leaf;       // LF_VTSHAPE
    unsigned short  count;      // number of entries in vfunctable
    unsigned char   desc[CV_ZEROLEN];     // 4 bit (CV_VTS_desc) descriptors
} lfVTShape;




//      type record for cobol0


typedef struct lfCobol0_16t {
    unsigned short  leaf;       // LF_COBOL0_16t
    CV_typ16_t      type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0_16t;

typedef struct lfCobol0 {
    unsigned short  leaf;       // LF_COBOL0
    CV_typ_t        type;       // parent type record index
    unsigned char   data[CV_ZEROLEN];
} lfCobol0;




//      type record for cobol1


typedef struct lfCobol1 {
    unsigned short  leaf;       // LF_COBOL1
    unsigned char   data[CV_ZEROLEN];
} lfCobol1;




//      type record for basic array


typedef struct lfBArray_16t {
    unsigned short  leaf;       // LF_BARRAY_16t
    CV_typ16_t      utype;      // type index of underlying type
} lfBArray_16t;

typedef struct lfBArray {
    unsigned short  leaf;       // LF_BARRAY
    CV_typ_t        utype;      // type index of underlying type
} lfBArray;

//      type record for assembler labels


typedef struct lfLabel {
    unsigned short  leaf;       // LF_LABEL
    unsigned short  mode;       // addressing mode of label
} lfLabel;



//      type record for dimensioned arrays


typedef struct lfDimArray_16t {
    unsigned short  leaf;       // LF_DIMARRAY_16t
    CV_typ16_t      utype;      // underlying type of the array
    CV_typ16_t      diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray_16t;

typedef struct lfDimArray {
    unsigned short  leaf;       // LF_DIMARRAY
    CV_typ_t        utype;      // underlying type of the array
    CV_typ_t        diminfo;    // dimension information
    unsigned char   name[1];    // length prefixed name
} lfDimArray;



//      type record describing path to virtual function table


typedef struct lfVFTPath_16t {
    unsigned short  leaf;       // LF_VFTPATH_16t
    unsigned short  count;      // count of number of bases in path
    CV_typ16_t      base[1];    // bases from root to leaf
} lfVFTPath_16t;

typedef struct lfVFTPath {
    unsigned short  leaf;       // LF_VFTPATH
    unsigned long   count;      // count of number of bases in path
    CV_typ_t        base[1];    // bases from root to leaf
} lfVFTPath;


//      type record describing inclusion of precompiled types


typedef struct lfPreComp_16t {
    unsigned short  leaf;       // LF_PRECOMP_16t
    unsigned short  start;      // starting type index included
    unsigned short  count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp_16t;

typedef struct lfPreComp {
    unsigned short  leaf;       // LF_PRECOMP
    unsigned long   start;      // starting type index included
    unsigned long   count;      // number of types in inclusion
    unsigned long   signature;  // signature
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of included type file
} lfPreComp;



//      type record describing end of precompiled types that can be
//      included by another file


typedef struct lfEndPreComp {
    unsigned short  leaf;       // LF_ENDPRECOMP
    unsigned long   signature;  // signature
} lfEndPreComp;





//      type record for OEM definable type strings


typedef struct lfOEM_16t {
    unsigned short  leaf;       // LF_OEM_16t
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned short  count;      // count of type indices to follow
    CV_typ16_t      index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM_16t;

typedef struct lfOEM {
    unsigned short  leaf;       // LF_OEM
    unsigned short  cvOEM;      // MS assigned OEM identified
    unsigned short  recOEM;     // OEM assigned type identifier
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM;

#define OEM_MS_FORTRAN90        0xF090
#define OEM_ODI                 0x0010
#define OEM_THOMSON_SOFTWARE    0x5453
#define OEM_ODI_REC_BASELIST    0x0000

typedef struct lfOEM2 {
    unsigned short  leaf;       // LF_OEM2
    unsigned char   idOem[16];  // an oem ID (GUID)
    unsigned long   count;      // count of type indices to follow
    CV_typ_t        index[CV_ZEROLEN];  // array of type indices followed
                                // by OEM defined data
} lfOEM2;

//      type record describing using of a type server

typedef struct lfTypeServer {
    unsigned short  leaf;       // LF_TYPESERVER
    unsigned long   signature;  // signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer;

//      type record describing using of a type server with v7 (GUID) signatures

typedef struct lfTypeServer2 {
    unsigned short  leaf;       // LF_TYPESERVER2
    SIG70           sig70;      // guid signature
    unsigned long   age;        // age of database used by this module
    unsigned char   name[CV_ZEROLEN];     // length prefixed name of PDB
} lfTypeServer2;

//      description of type records that can be referenced from
//      type records referenced by symbols



//      type record for skip record


typedef struct lfSkip_16t {
    unsigned short  leaf;       // LF_SKIP_16t
    CV_typ16_t      type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip_16t;

typedef struct lfSkip {
    unsigned short  leaf;       // LF_SKIP
    CV_typ_t        type;       // next valid index
    unsigned char   data[CV_ZEROLEN];     // pad data
} lfSkip;



//      argument list leaf


typedef struct lfArgList_16t {
    unsigned short  leaf;           // LF_ARGLIST_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      arg[CV_ZEROLEN];      // number of arguments
} lfArgList_16t;

typedef struct lfArgList {
    unsigned short  leaf;           // LF_ARGLIST
    unsigned long   count;          // number of arguments
    CV_typ_t        arg[CV_ZEROLEN];      // number of arguments
} lfArgList;




//      derived class list leaf


typedef struct lfDerived_16t {
    unsigned short  leaf;           // LF_DERIVED_16t
    unsigned short  count;          // number of arguments
    CV_typ16_t      drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived_16t;

typedef struct lfDerived {
    unsigned short  leaf;           // LF_DERIVED
    unsigned long   count;          // number of arguments
    CV_typ_t        drvdcls[CV_ZEROLEN];      // type indices of derived classes
} lfDerived;




//      leaf for default arguments


typedef struct lfDefArg_16t {
    unsigned short  leaf;               // LF_DEFARG_16t
    CV_typ16_t      type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg_16t;

typedef struct lfDefArg {
    unsigned short  leaf;               // LF_DEFARG
    CV_typ_t        type;               // type of resulting expression
    unsigned char   expr[CV_ZEROLEN];   // length prefixed expression string
} lfDefArg;



//      list leaf
//          This list should no longer be used because the utilities cannot
//          verify the contents of the list without knowing what type of list
//          it is.  New specific leaf indices should be used instead.


typedef struct lfList {
    unsigned short  leaf;           // LF_LIST
    char            data[CV_ZEROLEN];         // data format specified by indexing type
} lfList;




//      field list leaf
//      This is the header leaf for a complex list of class and structure
//      subfields.


typedef struct lfFieldList_16t {
    unsigned short  leaf;           // LF_FIELDLIST_16t
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList_16t;


typedef struct lfFieldList {
    unsigned short  leaf;           // LF_FIELDLIST
    char            data[CV_ZEROLEN];         // field list sub lists
} lfFieldList;







//  type record for non-static methods and friends in overloaded method list

typedef struct mlMethod_16t {
    CV_fldattr_t   attr;           // method attribute
    CV_typ16_t     index;          // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod_16t;

typedef struct mlMethod {
    CV_fldattr_t    attr;           // method attribute
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record for procedure
    unsigned long   vbaseoff[CV_ZEROLEN];    // offset in vfunctable if intro virtual
} mlMethod;


typedef struct lfMethodList_16t {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod_16t type
} lfMethodList_16t;

typedef struct lfMethodList {
    unsigned short leaf;
    unsigned char  mList[CV_ZEROLEN];         // really a mlMethod type
} lfMethodList;





//      type record for LF_BITFIELD


typedef struct lfBitfield_16t {
    unsigned short  leaf;           // LF_BITFIELD_16t
    unsigned char   length;
    unsigned char   position;
    CV_typ16_t      type;           // type of bitfield

} lfBitfield_16t;

typedef struct lfBitfield {
    unsigned short  leaf;           // LF_BITFIELD
    CV_typ_t        type;           // type of bitfield
    unsigned char   length;
    unsigned char   position;

} lfBitfield;




//      type record for dimensioned array with constant bounds


typedef struct lfDimCon_16t {
    unsigned short  leaf;           // LF_DIMCONU_16t or LF_DIMCONLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon_16t;

typedef struct lfDimCon {
    unsigned short  leaf;           // LF_DIMCONU or LF_DIMCONLU
    CV_typ_t        typ;            // type of index
    unsigned short  rank;           // number of dimensions
    unsigned char   dim[CV_ZEROLEN];          // array of dimension information with
                                    // either upper bounds or lower/upper bound
} lfDimCon;




//      type record for dimensioned array with variable bounds


typedef struct lfDimVar_16t {
    unsigned short  leaf;           // LF_DIMVARU_16t or LF_DIMVARLU_16t
    unsigned short  rank;           // number of dimensions
    CV_typ16_t      typ;            // type of index
    CV_typ16_t      dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The referenced
                                    // types must be LF_REFSYM or T_VOID
} lfDimVar_16t;

typedef struct lfDimVar {
    unsigned short  leaf;           // LF_DIMVARU or LF_DIMVARLU
    unsigned long   rank;           // number of dimensions
    CV_typ_t        typ;            // type of index
    CV_typ_t        dim[CV_ZEROLEN];          // array of type indices for either
                                    // variable upper bound or variable
                                    // lower/upper bound.  The count of type
                                    // indices is rank or rank*2 depending on
                                    // whether it is LFDIMVARU or LF_DIMVARLU.
                                    // The referenced types must be
                                    // LF_REFSYM or T_VOID
} lfDimVar;




//      type record for referenced symbol


typedef struct lfRefSym {
    unsigned short  leaf;           // LF_REFSYM
    unsigned char   Sym[1];         // copy of referenced symbol record
                                    // (including length)
} lfRefSym;





/**     the following are numeric leaves.  They are used to indicate the
 *      size of the following variable length data.  When the numeric
 *      data is a single byte less than 0x8000, then the data is output
 *      directly.  If the data is more the 0x8000 or is a negative value,
 *      then the data is preceeded by the proper index.
 */



//      signed character leaf

typedef struct lfChar {
    unsigned short  leaf;           // LF_CHAR
    signed char     val;            // signed 8-bit value
} lfChar;




//      signed short leaf

typedef struct lfShort {
    unsigned short  leaf;           // LF_SHORT
    short           val;            // signed 16-bit value
} lfShort;




//      unsigned short leaf

typedef struct lfUShort {
    unsigned short  leaf;           // LF_unsigned short
    unsigned short  val;            // unsigned 16-bit value
} lfUShort;




//      signed long leaf

typedef struct lfLong {
    unsigned short  leaf;           // LF_LONG
    long            val;            // signed 32-bit value
} lfLong;




//      unsigned long leaf

typedef struct lfULong {
    unsigned short  leaf;           // LF_ULONG
    unsigned long   val;            // unsigned 32-bit value
} lfULong;




//      signed quad leaf

typedef struct lfQuad {
    unsigned short  leaf;           // LF_QUAD
    unsigned char   val[8];         // signed 64-bit value
} lfQuad;




//      unsigned quad leaf

typedef struct lfUQuad {
    unsigned short  leaf;           // LF_UQUAD
    unsigned char   val[8];         // unsigned 64-bit value
} lfUQuad;


//      signed int128 leaf

typedef struct lfOct {
    unsigned short  leaf;           // LF_OCT
    unsigned char   val[16];        // signed 128-bit value
} lfOct;

//      unsigned int128 leaf

typedef struct lfUOct {
    unsigned short  leaf;           // LF_UOCT
    unsigned char   val[16];        // unsigned 128-bit value
} lfUOct;




//      real 32-bit leaf

typedef struct lfReal32 {
    unsigned short  leaf;           // LF_REAL32
    float           val;            // 32-bit real value
} lfReal32;




//      real 48-bit leaf

typedef struct lfReal48 {
    unsigned short  leaf;           // LF_REAL48
    unsigned char   val[6];         // 48-bit real value
} lfReal48;




//      real 64-bit leaf

typedef struct lfReal64 {
    unsigned short  leaf;           // LF_REAL64
    double          val;            // 64-bit real value
} lfReal64;




//      real 80-bit leaf

typedef struct lfReal80 {
    unsigned short  leaf;           // LF_REAL80
    FLOAT10         val;            // real 80-bit value
} lfReal80;




//      real 128-bit leaf

typedef struct lfReal128 {
    unsigned short  leaf;           // LF_REAL128
    char            val[16];        // real 128-bit value
} lfReal128;




//      complex 32-bit leaf

typedef struct lfCmplx32 {
    unsigned short  leaf;           // LF_COMPLEX32
    float           val_real;       // real component
    float           val_imag;       // imaginary component
} lfCmplx32;




//      complex 64-bit leaf

typedef struct lfCmplx64 {
    unsigned short  leaf;           // LF_COMPLEX64
    double          val_real;       // real component
    double          val_imag;       // imaginary component
} flCmplx64;




//      complex 80-bit leaf

typedef struct lfCmplx80 {
    unsigned short  leaf;           // LF_COMPLEX80
    FLOAT10         val_real;       // real component
    FLOAT10         val_imag;       // imaginary component
} lfCmplx80;




//      complex 128-bit leaf

typedef struct lfCmplx128 {
    unsigned short  leaf;           // LF_COMPLEX128
    char            val_real[16];   // real component
    char            val_imag[16];   // imaginary component
} lfCmplx128;



//  variable length numeric field

typedef struct lfVarString {
    unsigned short  leaf;       // LF_VARSTRING
    unsigned short  len;        // length of value in bytes
    unsigned char   value[CV_ZEROLEN];  // value
} lfVarString;

//***********************************************************************


//      index leaf - contains type index of another leaf
//      a major use of this leaf is to allow the compilers to emit a
//      long complex list (LF_FIELD) in smaller pieces.

typedef struct lfIndex_16t {
    unsigned short  leaf;           // LF_INDEX_16t
    CV_typ16_t      index;          // type index of referenced leaf
} lfIndex_16t;

typedef struct lfIndex {
    unsigned short  leaf;           // LF_INDEX
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // type index of referenced leaf
} lfIndex;


//      subfield record for base class field

typedef struct lfBClass_16t {
    unsigned short  leaf;           // LF_BCLASS_16t
    CV_typ16_t      index;          // type index of base class
    CV_fldattr_t    attr;           // attribute
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass_16t;

typedef struct lfBClass {
    unsigned short  leaf;           // LF_BCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of base class
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of base within class
} lfBClass;





//      subfield record for direct and indirect virtual base class field

typedef struct lfVBClass_16t {
    unsigned short  leaf;           // LF_VBCLASS_16t | LV_IVBCLASS_16t
    CV_typ16_t      index;          // type index of direct virtual base class
    CV_typ16_t      vbptr;          // type index of virtual base pointer
    CV_fldattr_t    attr;           // attribute
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass_16t;

typedef struct lfVBClass {
    unsigned short  leaf;           // LF_VBCLASS | LV_IVBCLASS
    CV_fldattr_t    attr;           // attribute
    CV_typ_t        index;          // type index of direct virtual base class
    CV_typ_t        vbptr;          // type index of virtual base pointer
    unsigned char   vbpoff[CV_ZEROLEN];       // virtual base pointer offset from address point
                                    // followed by virtual base offset from vbtable
} lfVBClass;





//      subfield record for friend class


typedef struct lfFriendCls_16t {
    unsigned short  leaf;           // LF_FRIENDCLS_16t
    CV_typ16_t      index;          // index to type record of friend class
} lfFriendCls_16t;

typedef struct lfFriendCls {
    unsigned short  leaf;           // LF_FRIENDCLS
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend class
} lfFriendCls;





//      subfield record for friend function


typedef struct lfFriendFcn_16t {
    unsigned short  leaf;           // LF_FRIENDFCN_16t
    CV_typ16_t      index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn_16t;

typedef struct lfFriendFcn {
    unsigned short  leaf;           // LF_FRIENDFCN
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        index;          // index to type record of friend function
    unsigned char   Name[1];        // name of friend function
} lfFriendFcn;



//      subfield record for non-static data members

typedef struct lfMember_16t {
    unsigned short  leaf;           // LF_MEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember_16t;

typedef struct lfMember {
    unsigned short  leaf;           // LF_MEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   offset[CV_ZEROLEN];       // variable length offset of field followed
                                    // by length prefixed name of field
} lfMember;



//  type record for static data members

typedef struct lfSTMember_16t {
    unsigned short  leaf;           // LF_STMEMBER_16t
    CV_typ16_t      index;          // index of type record for field
    CV_fldattr_t    attr;           // attribute mask
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember_16t;

typedef struct lfSTMember {
    unsigned short  leaf;           // LF_STMEMBER
    CV_fldattr_t    attr;           // attribute mask
    CV_typ_t        index;          // index of type record for field
    unsigned char   Name[1];        // length prefixed name of field
} lfSTMember;



//      subfield record for virtual function table pointer

typedef struct lfVFuncTab_16t {
    unsigned short  leaf;           // LF_VFUNCTAB_16t
    CV_typ16_t      type;           // type index of pointer
} lfVFuncTab_16t;

typedef struct lfVFuncTab {
    unsigned short  leaf;           // LF_VFUNCTAB
    _2BYTEPAD       pad0;           // internal padding, must be 0
    CV_typ_t        type;           // type index of pointer
} lfVFuncTab;



//      subfield record for virtual function table pointer with offset

typedef struct lfVFuncOff_16t {
    unsigned short  leaf;           // LF_VFUNCOFF_16t
    CV_typ16_t      type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff_16t;

typedef struct lfVFuncOff {
    unsigned short  leaf;           // LF_VFUNCOFF
    _2BYTEPAD       pad0;           // internal padding, must be 0.
    CV_typ_t        type;           // type index of pointer
    CV_off32_t      offset;         // offset of virtual function table pointer
} lfVFuncOff;



//      subfield record for overloaded method list


typedef struct lfMethod_16t {
    unsigned short  leaf;           // LF_METHOD_16t
    unsigned short  count;          // number of occurrences of function
    CV_typ16_t      mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod_16t;

typedef struct lfMethod {
    unsigned short  leaf;           // LF_METHOD
    unsigned short  count;          // number of occurrences of function
    CV_typ_t        mList;          // index to LF_METHODLIST record
    unsigned char   Name[1];        // length prefixed name of method
} lfMethod;



//      subfield record for nonoverloaded method


typedef struct lfOneMethod_16t {
    unsigned short leaf;            // LF_ONEMETHOD_16t
    CV_fldattr_t   attr;            // method attribute
    CV_typ16_t     index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod_16t;

typedef struct lfOneMethod {
    unsigned short leaf;            // LF_ONEMETHOD
    CV_fldattr_t   attr;            // method attribute
    CV_typ_t       index;           // index to type record for procedure
    unsigned long  vbaseoff[CV_ZEROLEN];    // offset in vfunctable if
                                    // intro virtual followed by
                                    // length prefixed name of method
} lfOneMethod;


//      subfield record for enumerate

typedef struct lfEnumerate {
    unsigned short  leaf;       // LF_ENUMERATE
    CV_fldattr_t    attr;       // access
    unsigned char   value[CV_ZEROLEN];    // variable length value field followed
                                // by length prefixed name
} lfEnumerate;


//  type record for nested (scoped) type definition

typedef struct lfNestType_16t {
    unsigned short  leaf;       // LF_NESTTYPE_16t
    CV_typ16_t      index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType_16t;

typedef struct lfNestType {
    unsigned short  leaf;       // LF_NESTTYPE
    _2BYTEPAD       pad0;       // internal padding, must be 0
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestType;

//  type record for nested (scoped) type definition, with attributes
//  new records for vC v5.0, no need to have 16-bit ti versions.

typedef struct lfNestTypeEx {
    unsigned short  leaf;       // LF_NESTTYPEEX
    CV_fldattr_t    attr;       // member access
    CV_typ_t        index;      // index of nested type definition
    unsigned char   Name[1];    // length prefixed type name
} lfNestTypeEx;

//  type record for modifications to members

typedef struct lfMemberModify {
    unsigned short  leaf;       // LF_MEMBERMODIFY
    CV_fldattr_t    attr;       // the new attributes
    CV_typ_t        index;      // index of base class type definition
    unsigned char   Name[1];    // length prefixed member name
} lfMemberModify;

//  type record for pad leaf

typedef struct lfPad {
    unsigned char   leaf;
} SYM_PAD;



//  Symbol definitions

typedef enum SYM_ENUM_e {
    S_COMPILE       =  0x0001, // Compile flags symbol
    S_REGISTER_16t  =  0x0002, // Register variable
    S_CONSTANT_16t  =  0x0003, // constant symbol
    S_UDT_16t       =  0x0004, // User defined type
    S_SSEARCH       =  0x0005, // Start Search
    S_END           =  0x0006, // Block, procedure, "with" or thunk end
    S_SKIP          =  0x0007, // Reserve symbol space in $$Symbols table
    S_CVRESERVE     =  0x0008, // Reserved symbol for CV internal use
#ifdef LNGNM
    S_OBJNAME_ST    =  0x0009, // path to object file name
#else
    S_OBJNAME       =  0x0009, // path to object file name
#endif
    S_ENDARG        =  0x000a, // end of argument/return list
    S_COBOLUDT_16t  =  0x000b, // special UDT for cobol that does not symbol pack
    S_MANYREG_16t   =  0x000c, // multiple register variable
    S_RETURN        =  0x000d, // return description symbol
    S_ENTRYTHIS     =  0x000e, // description of this pointer on entry

    S_BPREL16       =  0x0100, // BP-relative
    S_LDATA16       =  0x0101, // Module-local symbol
    S_GDATA16       =  0x0102, // Global data symbol
    S_PUB16         =  0x0103, // a public symbol
    S_LPROC16       =  0x0104, // Local procedure start
    S_GPROC16       =  0x0105, // Global procedure start
    S_THUNK16       =  0x0106, // Thunk Start
    S_BLOCK16       =  0x0107, // block start
    S_WITH16        =  0x0108, // with start
    S_LABEL16       =  0x0109, // code label
    S_CEXMODEL16    =  0x010a, // change execution model
    S_VFTABLE16     =  0x010b, // address of virtual function table
    S_REGREL16      =  0x010c, // register relative address

    S_BPREL32_16t   =  0x0200, // BP-relative
    S_LDATA32_16t   =  0x0201, // Module-local symbol
    S_GDATA32_16t   =  0x0202, // Global data symbol
    S_PUB32_16t     =  0x0203, // a public symbol (CV internal reserved)
    S_LPROC32_16t   =  0x0204, // Local procedure start
    S_GPROC32_16t   =  0x0205, // Global procedure start
#ifdef LNGNM
    S_THUNK32_ST    =  0x0206, // Thunk Start
    S_BLOCK32_ST    =  0x0207, // block start
    S_WITH32_ST     =  0x0208, // with start
    S_LABEL32_ST    =  0x0209, // code label
#else
    S_THUNK32       =  0x0206, // Thunk Start
    S_BLOCK32       =  0x0207, // block start
    S_WITH32        =  0x0208, // with start
    S_LABEL32       =  0x0209, // code label
#endif
    S_CEXMODEL32    =  0x020a, // change execution model
    S_VFTABLE32_16t =  0x020b, // address of virtual function table
    S_REGREL32_16t  =  0x020c, // register relative address
    S_LTHREAD32_16t =  0x020d, // local thread storage
    S_GTHREAD32_16t =  0x020e, // global thread storage
    S_SLINK32       =  0x020f, // static link for MIPS EH implementation

    S_LPROCMIPS_16t =  0x0300, // Local procedure start
    S_GPROCMIPS_16t =  0x0301, // Global procedure start

#ifdef LNGNM
    // if these ref symbols have names following then the names are in ST format
    S_PROCREF_ST    =  0x0400, // Reference to a procedure
    S_DATAREF_ST    =  0x0401, // Reference to data
#else
    S_PROCREF       =  0x0400, // Reference to a procedure
    S_DATAREF       =  0x0401, // Reference to data
#endif
    S_ALIGN         =  0x0402, // Used for page alignment of symbols

#ifdef LNGNM
    S_LPROCREF_ST   =  0x0403, // Local Reference to a procedure
#else
    S_LPROCREF      =  0x0403, // Local Reference to a procedure
#endif
    S_OEM           =  0x0404, // OEM defined symbol

    // sym records with 32-bit types embedded instead of 16-bit
    // all have 0x1000 bit set for easy identification
    // only do the 32-bit target versions since we don't really
    // care about 16-bit ones anymore.
    S_TI16_MAX          =  0x1000,
#ifndef LNGNM
    S_REGISTER      =  0x1001, // Register variable
    S_CONSTANT      =  0x1002, // constant symbol
    S_UDT           =  0x1003, // User defined type
    S_COBOLUDT      =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x1005, // multiple register variable
    S_BPREL32       =  0x1006, // BP-relative
    S_LDATA32       =  0x1007, // Module-local symbol
    S_GDATA32       =  0x1008, // Global data symbol
    S_PUB32         =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x100a, // Local procedure start
    S_GPROC32       =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32      =  0x100d, // register relative address
    S_LTHREAD32     =  0x100e, // local thread storage
    S_GTHREAD32     =  0x100f, // global thread storage

    S_LPROCMIPS     =  0x1010, // Local procedure start
    S_GPROCMIPS     =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2      =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2      =  0x1014, // multiple register variable
    S_LPROCIA64     =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT     = 0x1017,  // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC      =  0x101a,  // Global proc
    S_LMANPROC      =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA      =  0x1020,  // Static data
    S_GMANDATA      =  0x1021,  // Global data
    S_MANFRAMEREL   =  0x1022,  // Frame relative local var or param
    S_MANREGISTER   =  0x1023,  // Register local var or param
    S_MANSLOT       =  0x1024,  // Slot local var or param
    S_MANMANYREG    =  0x1025,  // Multiple register local var or param
    S_MANREGREL     =  0x1026,  // Register relative local var or param
    S_MANMANYREG2   =  0x1027,  // Multiple register local var or param
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE    =  0x1029,  // Using namespace

    S_NOLNGNAMEMAX,
    S_NOLNGNAMELAST = S_NOLNGNAMEMAX - 1,

    // Keep the long name and non-long name versions of S_ANNOTATIONREF
    // and S_TOKENREF the same
    //
    S_ANNOTATIONREF =  0x1128,  // Reference to S_ANNOTATION symbol

#else
    S_REGISTER_ST   =  0x1001, // Register variable
    S_CONSTANT_ST   =  0x1002, // constant symbol
    S_UDT_ST        =  0x1003, // User defined type
    S_COBOLUDT_ST   =  0x1004, // special UDT for cobol that does not symbol pack
    S_MANYREG_ST    =  0x1005, // multiple register variable
    S_BPREL32_ST    =  0x1006, // BP-relative
    S_LDATA32_ST    =  0x1007, // Module-local symbol
    S_GDATA32_ST    =  0x1008, // Global data symbol
    S_PUB32_ST      =  0x1009, // a public symbol (CV internal reserved)
    S_LPROC32_ST    =  0x100a, // Local procedure start
    S_GPROC32_ST    =  0x100b, // Global procedure start
    S_VFTABLE32     =  0x100c, // address of virtual function table
    S_REGREL32_ST   =  0x100d, // register relative address
    S_LTHREAD32_ST  =  0x100e, // local thread storage
    S_GTHREAD32_ST  =  0x100f, // global thread storage

    S_LPROCMIPS_ST  =  0x1010, // Local procedure start
    S_GPROCMIPS_ST  =  0x1011, // Global procedure start

    // new symbol records for edit and continue information

    S_FRAMEPROC     =  0x1012, // extra frame and proc information
    S_COMPILE2_ST   =  0x1013, // extended compile flags and info

    // new symbols necessary for 16-bit enumerates of IA64 registers
    // and IA64 specific symbols

    S_MANYREG2_ST   =  0x1014, // multiple register variable
    S_LPROCIA64_ST  =  0x1015, // Local procedure start (IA64)
    S_GPROCIA64_ST  =  0x1016, // Global procedure start (IA64)

    // Local symbols for IL
    S_LOCALSLOT_ST  = 0x1017,  // local IL sym with field for local slot index
    S_PARAMSLOT_ST  = 0x1018,  // local IL sym with field for parameter slot index

    S_ANNOTATION    =  0x1019, // Annotation string literals

    // symbols to support managed code debugging
    S_GMANPROC_ST   =  0x101a,  // Global proc
    S_LMANPROC_ST   =  0x101b,  // Local proc
    S_RESERVED1     =  0x101c,  // reserved
    S_RESERVED2     =  0x101d,  // reserved
    S_RESERVED3     =  0x101e,  // reserved
    S_RESERVED4     =  0x101f,  // reserved
    S_LMANDATA_ST   =  0x1020,
    S_GMANDATA_ST   =  0x1021,
    S_MANFRAMEREL_ST=  0x1022,
    S_MANREGISTER_ST=  0x1023,
    S_MANSLOT_ST    =  0x1024,
    S_MANMANYREG_ST =  0x1025,
    S_MANREGREL_ST  =  0x1026,
    S_MANMANYREG2_ST=  0x1027,
    S_MANTYPREF     =  0x1028,  // Index for type referenced by name from metadata
    S_UNAMESPACE_ST =  0x1029,  // Using namespace

    // Symbols w/ SZ name fields. All name fields contain utf8 encoded strings.
    S_ST_MAX        =  0x1100,  // starting point for SZ name symbols

    S_OBJNAME       =  0x1101, // path to object file name
    S_THUNK32       =  0x1102, // Thunk Start
    S_BLOCK32       =  0x1103, // block start
    S_WITH32        =  0x1104, // with start
    S_LABEL32       =  0x1105, // code label
    S_REGISTER      =  0x1106, // Register variable
    S_CONSTANT      =  0x1107, // constant symbol
    S_UDT           =  0x1108, // User defined type
    S_COBOLUDT      =  0x1109, // special UDT for cobol that does not symbol pack
    S_MANYREG       =  0x110a, // multiple register variable
    S_BPREL32       =  0x110b, // BP-relative
    S_LDATA32       =  0x110c, // Module-local symbol
    S_GDATA32       =  0x110d, // Global data symbol
    S_PUB32         =  0x110e, // a public symbol (CV internal reserved)
    S_LPROC32       =  0x110f, // Local procedure start
    S_GPROC32       =  0x1110, // Global procedure start
    S_REGREL32      =  0x1111, // register relative address
    S_LTHREAD32     =  0x1112, // local thread storage
    S_GTHREAD32     =  0x1113, // global thread storage

    S_LPROCMIPS     =  0x1114, // Local procedure start
    S_GPROCMIPS     =  0x1115, // Global procedure start
    S_COMPILE2      =  0x1116, // extended compile flags and info
    S_MANYREG2      =  0x1117, // multiple register variable
    S_LPROCIA64     =  0x1118, // Local procedure start (IA64)
    S_GPROCIA64     =  0x1119, // Global procedure start (IA64)
    S_LOCALSLOT     =  0x111a, // local IL sym with field for local slot index
    S_SLOT          = S_LOCALSLOT,  // alias for LOCALSLOT
    S_PARAMSLOT     =  0x111b, // local IL sym with field for parameter slot index

    // symbols to support managed code debugging
    S_LMANDATA      =  0x111c,
    S_GMANDATA      =  0x111d,
    S_MANFRAMEREL   =  0x111e,
    S_MANREGISTER   =  0x111f,
    S_MANSLOT       =  0x1120,
    S_MANMANYREG    =  0x1121,
    S_MANREGREL     =  0x1122,
    S_MANMANYREG2   =  0x1123,
    S_UNAMESPACE    =  0x1124,  // Using namespace

    // ref symbols with name fields
    S_PROCREF       =  0x1125, // Reference to a procedure
    S_DATAREF       =  0x1126, // Reference to data
    S_LPROCREF      =  0x1127, // Local Reference to a procedure
    S_ANNOTATIONREF =  0x1128,  // Reference to an S_ANNOTATION symbol
    S_TOKENREF      =  0x1129,  // Reference to one of the many MANPROCSYM's

    // continuation of managed symbols
    S_GMANPROC      =  0x112a,  // Global proc
    S_LMANPROC      =  0x112b,  // Local proc

    // short, light-weight thunks
    S_TRAMPOLINE    =  0x112c,  // trampoline thunks
    S_MANCONSTANT   =  0x112d,  // constants with metadata type info
#endif

    S_RECTYPE_MAX,             // one greater than last
    S_RECTYPE_LAST  = S_RECTYPE_MAX - 1,

} SYM_ENUM_e;






//  enum describing compile flag ambient data model


typedef enum CV_CFL_DATA {
    CV_CFL_DNEAR    = 0x00,
    CV_CFL_DFAR     = 0x01,
    CV_CFL_DHUGE    = 0x02
} CV_CFL_DATA;




//  enum describing compile flag ambiant code model


typedef enum CV_CFL_CODE_e {
    CV_CFL_CNEAR    = 0x00,
    CV_CFL_CFAR     = 0x01,
    CV_CFL_CHUGE    = 0x02
} CV_CFL_CODE_e;




//  enum describing compile flag target floating point package

typedef enum CV_CFL_FPKG_e {
    CV_CFL_NDP      = 0x00,
    CV_CFL_EMU      = 0x01,
    CV_CFL_ALT      = 0x02
} CV_CFL_FPKG_e;


// enum describing function return method


typedef struct CV_PROCFLAGS {
    union {
        unsigned char   bAll;
        unsigned char   grfAll;
        struct {
            unsigned char CV_PFLAG_NOFPO     :1; // frame pointer present
            unsigned char CV_PFLAG_INT       :1; // interrupt return
            unsigned char CV_PFLAG_FAR       :1; // far return
            unsigned char CV_PFLAG_NEVER     :1; // function does not return
            unsigned char CV_PFLAG_NOTREACHED:1; // label isn't fallen into
            unsigned char CV_PFLAG_CUST_CALL :1; // custom calling convention
            unsigned char CV_PFLAG_NOINLINE  :1; // function marked as noinline
            unsigned char unused             :1; //
        };
    };
} CV_PROCFLAGS;

// Extended proc flags
//
typedef struct CV_EXPROCFLAGS {
    CV_PROCFLAGS cvpf;
    union {
        unsigned char   grfAll;
        struct {
            unsigned char   __reserved      :8; // must be zero
        };
    };
} CV_EXPROCFLAGS;

// local variable flags
typedef struct CV_LVARFLAGS {
    unsigned short fIsParam          :1; // variable is a parameter
    unsigned short fAddrTaken        :1; // address is taken
    unsigned short fCompGenx         :1; // variable is compiler generated
    unsigned short unused            :13;// must be zero
} CV_LVARFLAGS;

// extended attributes common to all local variables
typedef struct CV_lvar_attr {
    CV_uoff32_t     off;        // first code address where var is live
    unsigned short  seg;
    CV_LVARFLAGS    flags;      // local var flags
} CV_lvar_attr;

// enum describing function data return method

typedef enum CV_GENERIC_STYLE_e {
    CV_GENERIC_VOID   = 0x00,       // void return type
    CV_GENERIC_REG    = 0x01,       // return data is in registers
    CV_GENERIC_ICAN   = 0x02,       // indirect caller allocated near
    CV_GENERIC_ICAF   = 0x03,       // indirect caller allocated far
    CV_GENERIC_IRAN   = 0x04,       // indirect returnee allocated near
    CV_GENERIC_IRAF   = 0x05,       // indirect returnee allocated far
    CV_GENERIC_UNUSED = 0x06        // first unused
} CV_GENERIC_STYLE_e;


typedef struct CV_GENERIC_FLAG {
    unsigned short  cstyle  :1;     // true push varargs right to left
    unsigned short  rsclean :1;     // true if returnee stack cleanup
    unsigned short  unused  :14;    // unused
} CV_GENERIC_FLAG;





typedef struct SYMTYPE {
    unsigned short      reclen;     // Record length
    unsigned short      rectyp;     // Record type
    char                data[CV_ZEROLEN];
} SYMTYPE;

__INLINE SYMTYPE *NextSym (SYMTYPE * pSym) {
    return (SYMTYPE *) ((char *)pSym + pSym->reclen + sizeof(unsigned short));
}

//      non-model specific symbol types



typedef struct REGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER_16t
    CV_typ16_t      typind;     // Type index
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM_16t;

typedef struct REGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} REGSYM;

typedef struct ATTRREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGISTER
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  reg;        // register enumerate
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGSYM;

typedef struct MANYREGSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM_16t;

typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index or metadata token
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;

typedef struct ATTRMANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} ATTRMANYREGSYM;

typedef struct ATTRMANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANMANYREG2
    CV_typ_t        typind;     // Type index or metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} ATTRMANYREGSYM2;

typedef struct CONSTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT_16t
    CV_typ16_t      typind;     // Type index (containing enum if enumerate)
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM_16t;

typedef struct CONSTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CONSTANT or S_MANCONSTANT
    CV_typ_t        typind;     // Type index (containing enum if enumerate) or metadata token
    unsigned short  value;      // numeric leaf containing value
    unsigned char   name[CV_ZEROLEN];     // Length-prefixed name
} CONSTSYM;


typedef struct UDTSYM_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT_16t | S_COBOLUDT_16t
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM_16t;


typedef struct UDTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UDT | S_COBOLUDT
    CV_typ_t        typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} UDTSYM;

typedef struct MANTYPREF {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANTYPREF
    CV_typ_t        typind;     // Type index
} MANTYPREF;

typedef struct SEARCHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_SSEARCH
    unsigned long   startsym;   // offset of the procedure
    unsigned short  seg;        // segment of symbol
} SEARCHSYM;


typedef struct CFLAGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE
    unsigned char   machine;    // target processor
    struct  {
        unsigned char   language    :8; // language index
        unsigned char   pcode       :1; // true if pcode present
        unsigned char   floatprec   :2; // floating precision
        unsigned char   floatpkg    :2; // float package
        unsigned char   ambdata     :3; // ambient data model
        unsigned char   ambcode     :3; // ambient code model
        unsigned char   mode32      :1; // true if compiled 32 bit mode
        unsigned char   pad         :4; // reserved
    } flags;
    unsigned char       ver[1];     // Length-prefixed compiler version string
} CFLAGSYM;


typedef struct COMPILESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_COMPILE2
    struct {
        unsigned long   iLanguage       :  8;   // language index
        unsigned long   fEC             :  1;   // compiled for E/C
        unsigned long   fNoDbgInfo      :  1;   // not compiled with debug info
        unsigned long   fLTCG           :  1;   // compiled with LTCG
        unsigned long   fNoDataAlign    :  1;   // compiled with -Bzalign
        unsigned long   fManagedPresent :  1;   // managed code/data present
        unsigned long   pad             : 19;   // reserved, must be 0
    } flags;
    unsigned short  machine;    // target processor
    unsigned short  verFEMajor; // front end major version #
    unsigned short  verFEMinor; // front end minor version #
    unsigned short  verFEBuild; // front end build version #
    unsigned short  verMajor;   // back end major version #
    unsigned short  verMinor;   // back end minor version #
    unsigned short  verBuild;   // back end build version #
    unsigned char   verSt[1];   // Length-prefixed compiler version string, followed
                                //  by an optional block of zero terminated strings
                                //  terminated with a double zero.
} COMPILESYM;


typedef struct OBJNAMESYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OBJNAME
    unsigned long   signature;  // signature
    unsigned char   name[1];    // Length-prefixed name
} OBJNAMESYM;


typedef struct ENDARGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENDARG
} ENDARGSYM;


typedef struct RETURNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_RETURN
    CV_GENERIC_FLAG flags;      // flags
    unsigned char   style;      // CV_GENERIC_STYLE_e return style
                                // followed by return method data
} RETURNSYM;


typedef struct ENTRYTHISSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ENTRYTHIS
    unsigned char   thissym;    // symbol describing this pointer on entry
} ENTRYTHISSYM;


//      symbol types for 16:16 memory model


typedef struct BPRELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL16
    CV_off16_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM16;


typedef struct DATASYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA or S_GDATA
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM16;
typedef DATASYM16 PUBSYM16;


typedef struct PROCSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned short  len;        // Proc length
    unsigned short  DbgStart;   // Debug start offset
    unsigned short  DbgEnd;     // Debug end offset
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM16;


typedef struct THUNKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // name of thunk
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM16;

typedef struct LABELSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM16;


typedef struct BLOCKSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM16;


typedef struct WITHSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned short  len;        // Block length
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned char   expr[1];    // Length-prefixed expression
} WITHSYM16;


typedef enum CEXM_MODEL_e {
    CEXM_MDL_table          = 0x00, // not executable
    CEXM_MDL_jumptable      = 0x01, // Compiler generated jump table
    CEXM_MDL_datapad        = 0x02, // Data padding for alignment
    CEXM_MDL_native         = 0x20, // native (actually not-pcode)
    CEXM_MDL_cobol          = 0x21, // cobol
    CEXM_MDL_codepad        = 0x22, // Code padding for alignment
    CEXM_MDL_code           = 0x23, // code
    CEXM_MDL_sql            = 0x30, // sql
    CEXM_MDL_pcode          = 0x40, // pcode
    CEXM_MDL_pcode32Mac     = 0x41, // macintosh 32 bit pcode
    CEXM_MDL_pcode32MacNep  = 0x42, // macintosh 32 bit pcode native entry point
    CEXM_MDL_javaInt        = 0x50,
    CEXM_MDL_unknown        = 0xff
} CEXM_MODEL_e;

// use the correct enumerate name
#define CEXM_MDL_SQL CEXM_MDL_sql

typedef enum CV_COBOL_e {
    CV_COBOL_dontstop,
    CV_COBOL_pfm,
    CV_COBOL_false,
    CV_COBOL_extcall
} CV_COBOL_e;

typedef struct CEXMSYM16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff16_t pcdtable;   // offset to pcode function table
            CV_uoff16_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
    };
} CEXMSYM16;


typedef struct VPATHSYM16 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTPATH16
    CV_uoff16_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM16;


typedef struct REGREL16 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL16
    CV_uoff16_t     off;        // offset of symbol
    unsigned short  reg;        // register index
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL16;


typedef struct BPRELSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32_16t
    CV_off32_t      off;        // BP-relative offset
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32_16t;

typedef struct BPRELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BPREL32
    CV_off32_t      off;        // BP-relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} BPRELSYM32;

typedef struct FRAMERELSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANFRAMEREL
    CV_off32_t      off;        // Frame relative offset
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} FRAMERELSYM;

typedef struct SLOTSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LOCALSLOT or S_PARAMSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    unsigned char   name[1];    // Length-prefixed name
} SLOTSYM32;

typedef struct ATTRSLOTSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANSLOT
    unsigned long   iSlot;      // slot index
    CV_typ_t        typind;     // Type index or Metadata token
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRSLOTSYM;

typedef struct ANNOTATIONSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ANNOTATION
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  csz;        // Count of zero terminated annotation strings
    unsigned char   rgsz[1];    // Sequence of zero terminated annotation strings
} ANNOTATIONSYM;

typedef struct DATASYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32_16t, S_GDATA32_16t or S_PUB32_16t
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32_16t;
typedef DATASYM32_16t PUBSYM32_16t;

typedef struct DATASYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LDATA32, S_GDATA32 or S_PUB32, S_LMANDATA, S_GMANDATA
    CV_typ_t        typind;     // Type index, or Metadata token if a managed symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} DATASYM32;

typedef enum CV_PUBSYMFLAGS_e
 {
    cvpsfNone     = 0,
    cvpsfCode     = 0x00000001,
    cvpsfFunction = 0x00000002,
    cvpsfManaged  = 0x00000004,
    cvpsfMSIL     = 0x00000008,
} CV_PUBSYMFLAGS_e;

typedef union CV_PUBSYMFLAGS {
    CV_pubsymflag_t grfFlags;
    struct {
        CV_pubsymflag_t fCode       : 1;    // set if public symbol refers to a code address
        CV_pubsymflag_t fFunction   : 1;    // set if public symbol is a function
        CV_pubsymflag_t fManaged    : 1;    // set if managed code (native or IL)
        CV_pubsymflag_t fMSIL       : 1;    // set if managed IL code
        CV_pubsymflag_t __unused    :28;    // must be zero
    };
} CV_PUBSYMFLAGS;

typedef struct PUBSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PUB32
    CV_PUBSYMFLAGS  pubsymflags;
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   name[1];    // Length-prefixed name
} PUBSYM32;


typedef struct PROCSYM32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32_16t or S_LPROC32_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_typ16_t      typind;     // Type index
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32_16t;

typedef struct PROCSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC32 or S_LPROC32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYM32;

typedef struct MANPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROC, S_LMANPROC, S_GMANPROCIA64 or S_LMANPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_tkn_t        token;      // COM+ metadata token for method
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned short  retReg;     // Register return value is in (may not be used for all archs)
    unsigned char   name[1];    // optional name field
} MANPROCSYM;

typedef struct MANPROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GMANPROCMIPS or S_LMANPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_tkn_t        token;      // COM+ token type
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // optional name field
} MANPROCSYMMIPS;

typedef struct THUNKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    CV_uoff32_t     off;
    unsigned short  seg;
    unsigned short  len;        // length of thunk
    unsigned char   ord;        // THUNK_ORDINAL specifying type of thunk
    unsigned char   name[1];    // Length-prefixed name
    unsigned char   variant[CV_ZEROLEN]; // variant portion of thunk
} THUNKSYM32;

typedef enum TRAMP_e {      // Trampoline subtype
    trampIncremental,           // incremental thunks
    trampBranchIsland,          // Branch island thunks
} TRAMP_e;

typedef struct TRAMPOLINESYM {  // Trampoline thunk symbol
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_TRAMPOLINE
    unsigned short  trampType;  // trampoline sym subtype
    unsigned short  cbThunk;    // size of the thunk
    CV_uoff32_t     offThunk;   // offset of the thunk
    CV_uoff32_t     offTarget;  // offset of the target of the thunk
    unsigned short  sectThunk;  // section index of the thunk
    unsigned short  sectTarget; // section index of the target of the thunk
} TRAMPOLINE;

typedef struct LABELSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_LABEL32
    CV_uoff32_t     off;
    unsigned short  seg;
    CV_PROCFLAGS    flags;      // flags
    unsigned char   name[1];    // Length-prefixed name
} LABELSYM32;


typedef struct BLOCKSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   name[1];    // Length-prefixed name
} BLOCKSYM32;


typedef struct WITHSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH32
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   len;        // Block length
    CV_uoff32_t     off;        // Offset in code segment
    unsigned short  seg;        // segment of label
    unsigned char   expr[1];    // Length-prefixed expression string
} WITHSYM32;



typedef struct CEXMSYM32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_CEXMODEL32
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  seg;        // segment of symbol
    unsigned short  model;      // execution model
    union {
        struct  {
            CV_uoff32_t pcdtable;   // offset to pcode function table
            CV_uoff32_t pcdspi;     // offset to segment pcode information
        } pcode;
        struct {
            unsigned short  subtype;   // see CV_COBOL_e above
            unsigned short  flag;
        } cobol;
        struct {
            CV_uoff32_t calltableOff; // offset to function table
            unsigned short calltableSeg; // segment of function table
        } pcode32Mac;
    };
} CEXMSYM32;



typedef struct VPATHSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32_16t
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
    CV_typ16_t      root;       // type index of the root of path
    CV_typ16_t      path;       // type index of the path record
} VPATHSYM32_16t;

typedef struct VPATHSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_VFTABLE32
    CV_typ_t        root;       // type index of the root of path
    CV_typ_t        path;       // type index of the path record
    CV_uoff32_t     off;        // offset of virtual function table
    unsigned short  seg;        // segment of virtual function table
} VPATHSYM32;





typedef struct REGREL32_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32_16t
    CV_uoff32_t     off;        // offset of symbol
    unsigned short  reg;        // register index for symbol
    CV_typ16_t      typind;     // Type index
    unsigned char   name[1];    // Length-prefixed name
} REGREL32_16t;

typedef struct REGREL32 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_REGREL32
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    unsigned char   name[1];    // Length-prefixed name
} REGREL32;

typedef struct ATTRREGREL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANREGREL
    CV_uoff32_t     off;        // offset of symbol
    CV_typ_t        typind;     // Type index or metadata token
    unsigned short  reg;        // register index for symbol
    CV_lvar_attr    attr;       // local var attributes
    unsigned char   name[1];    // Length-prefixed name
} ATTRREGREL;

typedef struct THREADSYM32_16t {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32_16t | S_GTHREAD32_16t
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    CV_typ16_t      typind;     // type index
    unsigned char   name[1];    // length prefixed name
} THREADSYM32_16t;

typedef struct THREADSYM32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_LTHREAD32 | S_GTHREAD32
    CV_typ_t        typind;     // type index
    CV_uoff32_t     off;        // offset into thread storage
    unsigned short  seg;        // segment of thread storage
    unsigned char   name[1];    // length prefixed name
} THREADSYM32;

typedef struct SLINK32 {
    unsigned short  reclen;     // record length
    unsigned short  rectyp;     // S_SLINK32
    unsigned long   framesize;  // frame size of parent procedure
    CV_off32_t      off;        // signed offset where the static link was saved relative to the value of reg
    unsigned short  reg;
} SLINK32;

typedef struct PROCSYMMIPS_16t {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS_16t or S_LPROCMIPS_16t
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    CV_typ16_t      typind;     // Type index
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS_16t;

typedef struct PROCSYMMIPS {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCMIPS or S_LPROCMIPS
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    unsigned long   regSave;    // int register save mask
    unsigned long   fpSave;     // fp register save mask
    CV_uoff32_t     intOff;     // int register save offset
    CV_uoff32_t     fpOff;      // fp register save offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned char   retReg;     // Register return value is in
    unsigned char   frameReg;   // Frame pointer register
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMMIPS;

typedef struct PROCSYMIA64 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROCIA64 or S_LPROCIA64
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
    unsigned long   len;        // Proc length
    unsigned long   DbgStart;   // Debug start offset
    unsigned long   DbgEnd;     // Debug end offset
    CV_typ_t        typind;     // Type index
    CV_uoff32_t     off;        // Symbol offset
    unsigned short  seg;        // Symbol segment
    unsigned short  retReg;     // Register return value is in
    CV_PROCFLAGS    flags;      // Proc flags
    unsigned char   name[1];    // Length-prefixed name
} PROCSYMIA64;

typedef struct REFSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF_ST, S_DATAREF_ST, or S_LPROCREF_ST
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned short  usFill;     // align this record
} REFSYM;

typedef struct REFSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_PROCREF, S_DATAREF, or S_LPROCREF
    unsigned long   sumName;    // SUC of the name
    unsigned long   ibSym;      // Offset of actual symbol in $$Symbols
    unsigned short  imod;       // Module containing the actual symbol
    unsigned char   name[1];    // hidden name made a first class member
} REFSYM2;

typedef struct ALIGNSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_ALIGN
} ALIGNSYM;

typedef struct OEMSYMBOL {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_OEM
    unsigned char   idOem[16];  // an oem ID (GUID)
    CV_typ_t        typind;     // Type index
    unsigned long   rgl[];      // user data, force 4-byte alignment
} OEMSYMBOL;

//  generic block definition symbols
//  these are similar to the equivalent 16:16 or 16:32 symbols but
//  only define the length, type and linkage fields

typedef struct PROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_GPROC16 or S_LPROC16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} PROCSYM;


typedef struct THUNKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_THUNK
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
    unsigned long   pNext;      // pointer to next symbol
} THUNKSYM;

typedef struct BLOCKSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_BLOCK16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} BLOCKSYM;


typedef struct WITHSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_WITH16
    unsigned long   pParent;    // pointer to the parent
    unsigned long   pEnd;       // pointer to this blocks end
} WITHSYM;

typedef struct FRAMEPROCSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_FRAMEPROC
    unsigned long   cbFrame;    // count of bytes of total frame of procedure
    unsigned long   cbPad;      // count of bytes of padding in the frame
    CV_uoff32_t     offPad;     // offset (relative to frame poniter) to where
                                //  padding starts
    unsigned long   cbSaveRegs; // count of bytes of callee save registers
    CV_uoff32_t     offExHdlr;  // offset of exception handler
    unsigned short  sectExHdlr; // section id of exception handler

    struct {
        unsigned long   fHasAlloca  :  1;   // function uses _alloca()
        unsigned long   fHasSetJmp  :  1;   // function uses setjmp()
        unsigned long   fHasLongJmp :  1;   // function uses longjmp()
        unsigned long   fHasInlAsm  :  1;   // function uses inline asm
        unsigned long   fHasEH      :  1;   // function has EH states
        unsigned long   fInlSpec    :  1;   // function was speced as inline
        unsigned long   fHasSEH     :  1;   // function has SEH
        unsigned long   pad         : 25;   // must be zero
    } flags;
} FRAMEPROCSYM;

typedef struct UNAMESPACE {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_UNAMESPACE
    unsigned char   name[1];    // name
} UNAMESPACE;

//
// V7 line number data types
//

enum DEBUG_S_SUBSECTION_TYPE {
    DEBUG_S_IGNORE = 0x80000000,   // if this bit is set in a subsection type then ignore the subsection contents

    DEBUG_S_SYMBOLS = 0xf1,
    DEBUG_S_LINES,
    DEBUG_S_STRINGTABLE,
    DEBUG_S_FILECHKSMS,
    DEBUG_S_FRAMEDATA,
};

//
// Line flags (data present)
//
#define CV_LINES_HAVE_COLUMNS 0x0001

struct CV_Line_t {
        unsigned long   offset;             // Offset to start of code bytes for line number
        unsigned long   linenumStart:24;    // line where statement/expression starts
        unsigned long   deltaLineEnd:7;     // delta to line where statement ends (optional)
        unsigned long   fStatement:1;       // true if a statement linenumber, else an expression line num
};

typedef unsigned short CV_columnpos_t;    // byte offset in a source line

struct CV_Column_t {
    CV_columnpos_t offColumnStart;
    CV_columnpos_t offColumnEnd;
};


struct tagFRAMEDATA {
    unsigned long   ulRvaStart;
    unsigned long   cbBlock;
    unsigned long   cbLocals;
    unsigned long   cbParams;
    unsigned long   cbStkMax;
    unsigned long   frameFunc;
    unsigned short  cbProlog;
    unsigned short  cbSavedRegs;
    unsigned long   fHasSEH:1;
    unsigned long   fHasEH:1;
    unsigned long   fIsFunctionStart:1;
    unsigned long   reserved:29;
};

typedef struct tagFRAMEDATA FRAMEDATA, * PFRAMEDATA;

typedef struct tagXFIXUP_DATA {
   unsigned short wType;
   unsigned short wExtra;
   unsigned long rva;
   unsigned long rvaTarget;
} XFIXUP_DATA;


#pragma pack ( pop )

#endif /* CV_INFO_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvr16.h ===
// CVR: CodeView Record utilities

#if CC_CVTYPE32
#include "./cvr32.h"
#else

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __CVR_INCLUDED__
#define __CVR_INCLUDED__

#ifndef __PDB_INCLUDED__
#include <pdb.h>
#endif
#ifndef _CV_INFO_INCLUDED
#include <cvinfo.h>
#endif
#ifndef _INC_STDDEF
#include <stddef.h>
#endif
#ifndef _WINDOWS_
// get rid of baggage we don't need from windows.h
#define WIN32_LEAN_AND_MEAN
//#define NOGDI
#define NOUSER
#define NONLS
#include "windows.h"
#endif

typedef BYTE* PB;
typedef long CB;
typedef char* SZ;		// zero terminated string
typedef char* ST;		// length prefixed string
typedef SYMTYPE* PSYM;
typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
typedef TYPTYPE* PTYPE;

//////////////////////////////////////////////////////////////////////////////
// TII (type index iterator) implementation declarations

typedef ptrdiff_t IB;

struct TYTI { // position of type indices within a type record with the given leaf
	USHORT leaf;
	SZ sz;						// leaf type name
	short cib;
	const IB* rgibTI;
	TI* (*pfn)(PTYPE ptype, int iib, PB* ppb, PB pbEnd); // fn to call if cib == cibFunction
	PB  (*pfnPbAfter)(void* pv);	  // end of record fn to call for elements of a field list
};

// all pointers to a TYTI are pointing to const TYTIs
typedef const TYTI *	PTYTI;

struct SYTI { // position of symbol indices within a symbol recoord with the given rectyp
	USHORT rectyp;
	SZ sz;						// symbol rectyp name
	IB	ibName;					// position of symbol name
	ST (*pfnstName)(PSYM psym);	// function to call if name offset variable
	BOOL  isGlobal;				// symbol is global
	short cib;
	const IB* rgibTI;
};

// all pointers to a SYTI are pointing to const SYTIs
typedef const SYTI *	PSYTI;


#if	defined(PDB_LIBRARY)
#define CVR_EXPORT
#else
#if defined(CVR_IMP)
#define CVR_EXPORT	__declspec(dllexport)
#else
#define CVR_EXPORT	__declspec(dllimport)
#endif
#endif

#ifndef CVRAPI
#define CVRAPI	 __cdecl
#endif

class SymTiIter { // type indices within symbol record iterator
public:
	CVR_EXPORT	SymTiIter(PSYM psym_);
	inline TI&  rti();
	inline BOOL next();
private:
	PSYM psym;			// current symbol
	int  iib;			// index of curren TI in this symbol record
	PSYTI psyti;		// address of symbol->ti-info for current symbol record
};

inline TI& SymTiIter::rti()
{
	return *(TI*)((PB)psym + psyti->rgibTI[iib]);
}

inline BOOL SymTiIter::next()
{
	return ++iib < psyti->cib;
}

class TypeTiIter { // type indices within type record iterator
public:
	TypeTiIter(TYPTYPE* ptype);
	inline TI& rti();
	BOOL next();
	PB pbFindField(unsigned leaf);
private:
	void init();
	BOOL nextField();

	PTYPE ptype;		// current type
	USHORT* pleaf;		// leaf part of current type
	unsigned	leaf;	// cached, aligned, no op-size override version of leaf
	PB   pbFnState;		// private state of current iterating fn (iff ptyti->cib == cibFunction)
	PB   pbEnd;			// pointer just past end of type record
	int  iib;  			// index of current TI in this type record
	BOOL isFieldList;	// TRUE if this type record is a LF_FIELDLIST
	TI*  pti;			// address of current TI
	PTYTI ptyti;		// address of type->ti-info for current type record
};

inline TI& TypeTiIter::rti()
{
	return *pti;
}

// utility function protos
CVR_EXPORT BOOL CVRAPI fGetSymName(PSYM psym, OUT ST* pst);
		   BOOL fSymIsGlobal(PSYM psym);
		   BOOL fGetTypeLeafName(PTYPE ptype, OUT SZ* psz);
CVR_EXPORT BOOL CVRAPI fGetSymRecTypName(PSYM psym, OUT SZ* psz);

////////////////////////////////////////////////////////////////////////////////
// Inline utility functions.

// Return the number of bytes in an ST
inline CB cbForSt(ST st)
{
	return *(PB)st + 1;
}

// Return the number of bytes the type record occupies.
//
inline CB cbForType(PTYPE ptype)
{
	return ptype->len + sizeof(ptype->len);
}

// Return a pointer to the byte just past the end of the type record.
//
inline PB pbEndType(PTYPE ptype)
{
	return (PB)ptype + cbForType(ptype);
}

// Return the number of bytes the symbol record occupies.
//
#define MDALIGNTYPE_	DWORD

inline CB cbAlign_(CB cb)
{
	return ((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);
}

inline CB cbForSym(PSYMUNALIGNED psym)
{
	CB cb = psym->reclen + sizeof(psym->reclen);
	// procrefs also have a hidden length preceeded name following the record
	if ((psym->rectyp == S_PROCREF) || (psym->rectyp == S_LPROCREF))
		cb += cbAlign_(cbForSt((ST)((PB)psym + cb)));
	return cb;
}

// Return a pointer to the byte just past the end of the symbol record.
//
inline PB pbEndSym(PSYM psym)
{
	return (PB)psym + cbForSym(psym);
}

#endif // CC_CVTYPE32
#endif // __CVR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvexefmt.h ===
/***    cvexefmt.h - format of CodeView information in exe
 *
 *      Structures, constants, etc. for reading CodeView information
 *      from the executable.
 *
 */


/***    The master copy of this file resides in the LANGAPI project.
 *      All Microsoft projects are required to use the master copy without
 *      modification.  Modification of the master version or a copy
 *      without consultation with all parties concerned is extremely
 *      risky.
 *
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif



//  The following structures and constants describe the format of the
//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and
//  later.  These are executables with signatures of NB05, NB06 and NB08.
//  There is some confusion about the signatures NB03 and NB04 so none
//  of the utilites will accept executables with these signatures.  NB07 is
//  the signature for QCWIN 1.0 packed executables.

//  All of the structures described below must start on a long word boundary
//  to maintain natural alignment.  Pad space can be inserted during the
//  write operation and the addresses adjusted without affecting the contents
//  of the structures.

#ifndef _CV_INFO_INCLUDED
#include "cvinfo.h"
#endif

#ifndef FAR
#if _M_IX86 >= 300
#define FAR
#else
#define FAR far
#endif
#endif

#pragma warning(push)
#pragma warning(disable : 4200)     // disable zero-sized array in struct/union

//  Type of subsection entry.

#define sstModule           0x120
#define sstTypes            0x121
#define sstPublic           0x122
#define sstPublicSym        0x123   // publics as symbol (waiting for link)
#define sstSymbols          0x124
#define sstAlignSym         0x125
#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule
#define sstSrcModule        0x127
#define sstLibraries        0x128
#define sstGlobalSym        0x129
#define sstGlobalPub        0x12a
#define sstGlobalTypes      0x12b
#define sstMPC              0x12c
#define sstSegMap           0x12d
#define sstSegName          0x12e
#define sstPreComp          0x12f   // precompiled types
#define sstPreCompMap       0x130   // map precompiled types in global types
#define sstOffsetMap16      0x131
#define sstOffsetMap32      0x132
#define sstFileIndex        0x133   // Index of file names
#define sstStaticSym        0x134

typedef enum OMFHash {
    OMFHASH_NONE,           // no hashing
    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table
    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table
    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table
    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table
} OMFHASH;

//  CodeView Debug OMF signature.  The signature at the end of the file is
//  a negative offset from the end of the file to another signature.  At
//  the negative offset (base address) is another signature whose filepos
//  field points to the first OMFDirHeader in a chain of directories.
//  The NB05 signature is used by the link utility to indicated a completely
//  unpacked file.  The NB06 signature is used by ilink to indicate that the
//  executable has had CodeView information from an incremental link appended
//  to the executable.  The NB08 signature is used by cvpack to indicate that
//  the CodeView Debug OMF has been packed.  CodeView will only process
//  executables with the NB08 signature.


typedef struct OMFSignature {
    char            Signature[4];   // "NBxx"
    long            filepos;        // offset in file
} OMFSignature;



//  directory information structure
//  This structure contains the information describing the directory.
//  It is pointed to by the signature at the base address or the directory
//  link field of a preceeding directory.  The directory entries immediately
//  follow this structure.


typedef struct OMFDirHeader {
    unsigned short  cbDirHeader;    // length of this structure
    unsigned short  cbDirEntry;     // number of bytes in each directory entry
    unsigned long   cDir;           // number of directorie entries
    long            lfoNextDir;     // offset from base of next directory
    unsigned long   flags;          // status flags
} OMFDirHeader;




//  directory structure
//  The data in this structure is used to reference the data for each
//  subsection of the CodeView Debug OMF information.  Tables that are
//  not associated with a specific module will have a module index of
//  oxffff.  These tables are the global types table, the global symbol
//  table, the global public table and the library table.


typedef struct OMFDirEntry {
    unsigned short  SubSection;     // subsection type (sst...)
    unsigned short  iMod;           // module index
    long            lfo;            // large file offset of subsection
    unsigned long   cb;             // number of bytes in subsection
} OMFDirEntry;



//  information decribing each segment in a module

typedef struct OMFSegDesc {
    unsigned short  Seg;            // segment index
    unsigned short  pad;            // pad to maintain alignment
    unsigned long   Off;            // offset of code in segment
    unsigned long   cbSeg;          // number of bytes in segment
} OMFSegDesc;


//  per module information
//  There is one of these subsection entries for each module
//  in the executable.  The entry is generated by link/ilink.
//  This table will probably require padding because of the
//  variable length module name.

typedef struct OMFModule {
    unsigned short  ovlNumber;      // overlay number
    unsigned short  iLib;           // library that the module was linked from
    unsigned short  cSeg;           // count of number of segments in module
    char            Style[2];       // debugging style "CV"
    OMFSegDesc      SegInfo[1];     // describes segments in module
    char            Name[];         // length prefixed module name padded to
                                    // long word boundary
} OMFModule;



//  Symbol hash table format
//  This structure immediately preceeds the global publics table
//  and global symbol tables.

typedef struct  OMFSymHash {
    unsigned short  symhash;        // symbol hash function index
    unsigned short  addrhash;       // address hash function index
    unsigned long   cbSymbol;       // length of symbol information
    unsigned long   cbHSym;         // length of symbol hash data
    unsigned long   cbHAddr;        // length of address hashdata
} OMFSymHash;



//  Global types subsection format
//  This structure immediately preceeds the global types table.
//  The offsets in the typeOffset array are relative to the address
//  of ctypes.  Each type entry following the typeOffset array must
//  begin on a long word boundary.

typedef struct OMFTypeFlags {
    unsigned long   sig     :8;
    unsigned long   unused  :24;
} OMFTypeFlags;


typedef struct OMFGlobalTypes {
    OMFTypeFlags    flags;
    unsigned long   cTypes;         // number of types
    unsigned long   typeOffset[];   // array of offsets to types
} OMFGlobalTypes;




//  Precompiled types mapping table
//  This table should be ignored by all consumers except the incremental
//  packer.


typedef struct OMFPreCompMap {
    CV_typ_t        FirstType;      // first precompiled type index
    CV_typ_t        cTypes;         // number of precompiled types
    unsigned long   signature;      // precompiled types signature
    CV_typ_t        map[];          // mapping of precompiled types
} OMFPreCompMap;



//  Source line to address mapping table.
//  This table is generated by the link/ilink utility from line number
//  information contained in the object file OMF data.  This table contains
//  only the code contribution for one segment from one source file.


typedef struct OMFSourceLine {
    unsigned short  Seg;            // linker segment index
    unsigned short  cLnOff;         // count of line/offset pairs
    unsigned long   offset[1];      // array of offsets in segment
    unsigned short  lineNbr[1];     // array of line lumber in source
} OMFSourceLine;

typedef OMFSourceLine * LPSL;


//  Source file description
//  This table is generated by the linker


typedef struct OMFSourceFile {
    unsigned short  cSeg;           // number of segments from source file
    unsigned short  reserved;       // reserved
    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables
                                    // this array is followed by array
                                    // of segment start/end pairs followed by
                                    // an array of linker indices
                                    // for each segment in the file
    unsigned short  cFName;         // length of source file name
    char            Name;           // name of file padded to long boundary
} OMFSourceFile;

typedef OMFSourceFile * LPSF;


//  Source line to address mapping header structure
//  This structure describes the number and location of the
//  OMFAddrLine tables for a module.  The offSrcLine entries are
//  relative to the beginning of this structure.


typedef struct OMFSourceModule {
    unsigned short  cFile;          // number of OMFSourceTables
    unsigned short  cSeg;           // number of segments in module
    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table
                                    // this array is followed by array
                                    // of segment start/end pairs followed
                                    // by an array of linker indices
                                    // for each segment in the module
} OMFSourceModule;

typedef OMFSourceModule * LPSM;

//  sstLibraries

typedef struct OMFLibrary {
    unsigned char   cbLibs;     // count of library names
    char            Libs[1];    // array of length prefixed lib names (first entry zero length)
} OMFLibrary;


// sstFileIndex - An index of all of the files contributing to an
//  executable.

typedef struct OMFFileIndex {
    unsigned short  cmodules;       // Number of modules
    unsigned short  cfilerefs;      // Number of file references
    unsigned short  modulelist[1];  // Index to beginning of list of files
                                    // for module i. (0 for module w/o files)
    unsigned short  cfiles[1];      // Number of file names associated
                                    // with module i.
    unsigned long   ulNames[1];     // Offsets from the beginning of this
                                    // table to the file names
    char            Names[];        // The length prefixed names of files
} OMFFileIndex;


//  Offset mapping table
//  This table provides a mapping from logical to physical offsets.
//  This mapping is applied between the logical to physical mapping
//  described by the seg map table.

typedef struct OMFOffsetMap16 {
    unsigned long   csegment;       // Count of physical segments

    // The next six items are repeated for each segment

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned short  rgoffLog[1];    // Array of logical offsets
    short           rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned short  rgoffPhys[1];   // Array of physical offsets
    short           rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap16;

typedef struct OMFOffsetMap32 {
    unsigned long   csection;       // Count of physical sections

    // The next six items are repeated for each section

    unsigned long   crangeLog;      // Count of logical offset ranges
    unsigned long   rgoffLog[1];    // Array of logical offsets
    long            rgbiasLog[1];   // Array of logical->physical bias
    unsigned long   crangePhys;     // Count of physical offset ranges
    unsigned long   rgoffPhys[1];   // Array of physical offsets
    long            rgbiasPhys[1];  // Array of physical->logical bias
} OMFOffsetMap32;

//  Pcode support.  This subsection contains debug information generated
//  by the MPC utility used to process Pcode executables.  Currently
//  it contains a mapping table from segment index (zero based) to
//  frame paragraph.  MPC converts segmented exe's to non-segmented
//  exe's for DOS support.  To avoid backpatching all CV info, this
//  table is provided for the mapping.  Additional info may be provided
//  in the future for profiler support.

typedef struct OMFMpcDebugInfo {
    unsigned short  cSeg;       // number of segments in module
    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame
} OMFMpcDebugInfo;

//  The following structures and constants describe the format of the
//  CodeView Debug OMF for linkers that emit executables with the NB02
//  signature.  Current utilities with the exception of cvpack and cvdump
//  will not accept or emit executables with the NB02 signature.  Cvdump
//  will dump an unpacked executable with the NB02 signature.  Cvpack will
//  read an executable with the NB02 signature but the packed executable
//  will be written with the table format, contents and signature of NB08.





//  subsection type constants

#define SSTMODULE       0x101   // Basic info. about object module
#define SSTPUBLIC       0x102   // Public symbols
#define SSTTYPES        0x103   // Type information
#define SSTSYMBOLS      0x104   // Symbol Data
#define SSTSRCLINES     0x105   // Source line information
#define SSTLIBRARIES    0x106   // Names of all library files used
#define SSTIMPORTS      0x107   // Symbols for DLL fixups
#define SSTCOMPACTED    0x108   // Compacted types section
#define SSTSRCLNSEG     0x109   // Same as source lines, contains segment


typedef struct DirEntry{
    unsigned short  SubSectionType;
    unsigned short  ModuleIndex;
    long            lfoStart;
    unsigned short  Size;
} DirEntry;


//  information decribing each segment in a module

typedef struct oldnsg {
    unsigned short  Seg;            // segment index
    unsigned short  Off;            // offset of code in segment
    unsigned short  cbSeg;          // number of bytes in segment
} oldnsg;


//   old subsection module information

typedef struct oldsmd {
    oldnsg          SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg          arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd;

typedef struct{
    unsigned short  Seg;
    unsigned long   Off;
    unsigned long   cbSeg;
} oldnsg32;

typedef struct {
    oldnsg32        SegInfo;        // describes first segment in module
    unsigned short  ovlNbr;         // overlay number
    unsigned short  iLib;
    unsigned char   cSeg;           // Number of segments in module
    char            reserved;
    unsigned char   cbName[1];      // length prefixed name of module
    oldnsg32        arnsg[];        // cSeg-1 structures exist for alloc text or comdat code
} oldsmd32;


// OMFSegMap - This table contains the mapping between the logical segment indices
// used in the symbol table and the physical segments where the program is loaded

typedef struct OMFSegMapFlags {
    union {
        struct {
            unsigned short      fRead   :1;
            unsigned short      fWrite  :1;
            unsigned short      fExecute:1;
            unsigned short      f32Bit  :1;
            unsigned short      res1    :4;
            unsigned short      fSel    :1;
            unsigned short      fAbs    :1;
            unsigned short      res2    :2;
            unsigned short      fGroup  :1;  // OBSOLETE - do not use, debugger will assert
            unsigned short      res3    :3;
        };
        unsigned short fAll;
    };
} OMFSegMapFlags;

typedef struct OMFSegMapDesc {
    OMFSegMapFlags  flags;          // descriptor flags bit field.
    unsigned short  ovl;            // the logical overlay number
    unsigned short  group;          // group index into the descriptor array
    unsigned short  frame;          // logical segment index - interpreted via flags
    unsigned short  iSegName;       // segment or group name - index into sstSegName
    unsigned short  iClassName;     // class name - index into sstSegName
    unsigned long   offset;         // byte offset of the logical within the physical segment
    unsigned long   cbSeg;          // byte count of the logical segment or group
} OMFSegMapDesc;

typedef struct OMFSegMap {
    unsigned short  cSeg;           // total number of segment descriptors
    unsigned short  cSegLog;        // number of logical segment descriptors
    OMFSegMapDesc   rgDesc[0];      // array of segment descriptors
} OMFSegMap;

#pragma warning(pop)                // restore all warnings to what they were
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
//
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals   - only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

enum LocationType
{
    LocIsNull,
    LocIsStatic,
    LocIsTLS,
    LocIsRegRel,
    LocIsThisRel,
    LocIsEnregistered,
    LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
    LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum UdtKind
{
    UdtStruct,
    UdtClass,
    UdtUnion
};

enum BasicType
{
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btLong = 13,
    btULong = 14,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_RESERVED1    = 0xD0,
    CV_CFL_EBC          = 0xE0,
    CV_CFL_THUMB        = 0xF0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194,
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,

    CV_REG_XMM0H    =  202,
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212, // EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228,
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0    =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,

    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,

    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

} CV_HREG_e;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\debug_s.h ===
#ifndef _DEBUG_S_H_
#define _DEBUG_S_H_

#include "unknwn.h"
#include "crefobj.h"
#include "ref.h"

#if defined(MSOBJ_LIBRARY)
#define IMPORT_EXPORT
#else
#if !defined(OBJECTFILE_IMPL)
#define IMPORT_EXPORT   __declspec(dllimport)
#else
#define IMPORT_EXPORT   __declspec(dllexport)
#endif
#endif

struct tagFRAMEDATA;
typedef struct tagFRAMEDATA FRAMEDATA;

// {D8047B7D-1A6F-4bbd-B05C-A67AFBFA25CF}
static const GUID IID_IDebugSSectionWriter = 
{ 0xd8047b7d, 0x1a6f, 0x4bbd, { 0xb0, 0x5c, 0xa6, 0x7a, 0xfb, 0xfa, 0x25, 0xcf } };

class IDebugSSectionWriter: public IUnknown
{
public:
    enum {
        BAD_INDEX = 0xffffffff
    };
	//
	//  FInitWriter - initialize the section writer
    //	fEmitColumns - true iff the line number information will contain column data
    //
    IMPORT_EXPORT static bool __cdecl FCreateWriter( bool fEmitColumns, IDebugSSectionWriter** ppWriter, DWORD sig, bool f1stSection );

    //
    // StartSection
    //  symidSection - symbol id for the associated section. All offsets in line numbers are
    //                  relative to the start of the associated section. If this is the first debug$S section
    //                  then it typically is not assocaited with another section, so symidSection should
    //                  be given as 0.
    // Multiple sections can be written by repeating the sequence:
    //      StartSection()
    //      .. other calls ..
    //      EndSection()
    //      GetSectionBytes()
    //      GetSectionRelocs()
    //
    virtual bool StartSection( DWORD offset, WORD segment, DWORD cb = 0 ) = 0;
    virtual bool StartSectionSymId( DWORD symidSection, DWORD cb = 0 ) = 0;
	//
	// Append bytes to the symbols sub-stream
	//	pb - pointer to bytes to append
	//	cb - number of bytes to append
    //  poffset - if non-null then return section offset of bytes just appended
	//
	virtual bool AppendToSymbols( BYTE* pb, DWORD cb, DWORD* poffset ) = 0;
    //
    // Append a relocation to this section.
    virtual bool AppendRelocation( DWORD offset, DWORD symid, WORD type ) = 0;
    //
    // Add a string to the string table
    //      sz - the string
    // returns the string offset in the table
    //
	virtual DWORD AddString( const wchar_t* sz ) = 0;
	virtual DWORD AddUtf8String( const char* sz ) = 0;      // utf-8 encoded version
	//
	//   Name the file for the next set of line numbers to emit. Succeeding calls to AddLines routines 
    //   will assume this source file.
 	// 	    szFile - filename
    //      pbChksum - pointer to chksum bytes
    //      cbChksum - number of bytes of chksum
    //      chksumType - Chksum type
    //   Returns an index for the file in the source file table
	//
    virtual DWORD AddSourceFile( const wchar_t* szFilename, const BYTE* pbChksum, size_t cbChksum, DWORD chksumType ) = 0;
    //
	// Add a line with no column information
    //  idFile - a return value from AddSourceFile
	//	offset - offset from section start
	//	linenumStart - line number for start of statement
	//	linenumEnd - line number for end of statement, or zero if not emitting start/end pairs
    //  fStatement - true if this is a statement line number, otherwise it is an expression line.
	//
    // AddLine calls must occur in ascending order by offset. 
	virtual bool AddLine( DWORD idFile, DWORD offset, DWORD linenumStart, DWORD linenumEnd = 0, bool fStatement = true ) = 0;
	//
	// Add a line with column information
    //  idFile - a return value from AddSourceFile
	//	offset - offset from section start
	//	linenumStart - line number for start of statement
	//	boColumnStart - byte offset on source line for start of statement
	//	linenumEnd - line number for end of statement, or zero if not emitting start/end pairs
	//	boColumnEnd - byte offset on source line for end of statement, or zero
    //  fStatement - true if this is a statement line number, otherwise it is an expression line.
	//
    // AddLineWithColumn calls must occur in ascending order by offset. 
	virtual bool AddLineWithColumn( DWORD idFile, DWORD offset, DWORD linenumStart, DWORD linenumEnd = 0,
        DWORD offColumnStart = 0, DWORD offColumnEnd = 0, bool fStatement = true ) = 0;

    //
    // Add FRAMEDATA
    //
    //  Any rva fields of the framedata are section relative when added. The linker will adjust them
    //  to true rva's, no reloc's are necessary.
    //
    virtual bool AddFrameData( FRAMEDATA* pData ) = 0;

    //
    // EndSection - complete the section
    //
    virtual bool EndSection( DWORD cb = 0 ) pure;    
    //
    // GetSection[Bytes, Relocs] -
    //      Get the raw bytes and relocations for this debug$S section
    //      Pointer's returned are to memory managed by the IDebugSSectionWriter, they are
    //      good while the object exists and no calls to StartSection have been executed.
    // Must first call EndSection.
    //
    virtual size_t GetSectionBytes( BYTE** ppbSection ) = 0;
    virtual size_t GetSectionRelocs( BYTE** ppbRelocs ) = 0;
};

class IDebugSSubSectionEnum;
class IDebugSStringEnum;
class IDebugSLineBlockEnum;
class IDebugSLineEnum;
class IDebugSFileEnum;
class IDebugSStringTable;
class IDebugSFileInfo;

interface MapStrs
{
    virtual bool mapStrId( DWORD oldId, DWORD* newId ) = 0;
};

//
// QI the IDebugSSubSection based on Type() results for the correct SubSection interface
//
// {7DEF5160-D85A-472c-8644-1C5479AF1385}
static const GUID IID_IDebugSSubSection = 
{ 0x7def5160, 0xd85a, 0x472c, { 0x86, 0x44, 0x1c, 0x54, 0x79, 0xaf, 0x13, 0x85 } };

class IDebugSSubSection: public IUnknown
{
public:
    virtual DWORD Type() = 0;   // one of DEBUG_S_SUBSECTION_TYPE
    //
    // Get a pointer to the data, return the size of the data
    //
    virtual size_t GetData( BYTE** ppb ) = 0;       // bytes of the data part of the subsection
    virtual size_t GetRawBytes( BYTE** ppb ) = 0;   // raw bytes of entire subsection (incl's header)
    virtual void Dump() = 0;                        // dump to std out
    virtual bool remap( MapStrs* pRemaper ) = 0;    // remap string table ids to a new string table
};

// {F9C7819B-4FE7-43cc-A337-D2B93807EBF2}
static const GUID IID_IDebugSSubSectionEnum = 
{ 0xf9c7819b, 0x4fe7, 0x43cc, { 0xa3, 0x37, 0xd2, 0xb9, 0x38, 0x7, 0xeb, 0xf2 } };

class IDebugSSubSectionEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    virtual void Get( IDebugSSubSection** ppSubSection ) = 0;
    virtual bool clone( IDebugSSubSectionEnum **ppClone ) = 0;
};

// {C03407A4-245F-416c-B465-F9EE9209C1D8}
static const GUID IID_IDebugSSectionReader = 
{ 0xc03407a4, 0x245f, 0x416c, { 0xb4, 0x65, 0xf9, 0xee, 0x92, 0x9, 0xc1, 0xd8 } };

class IDebugSSectionReader: public IUnknown
{
public:
    IMPORT_EXPORT static bool __cdecl FCreateReader( BYTE* pb, size_t cb, IDebugSSectionReader** ppReader, DWORD sig );
    
    virtual bool GetSectionEnum( IDebugSSubSectionEnum** ppEnum ) = 0;
    virtual bool GetStringTable( IDebugSStringTable** ppSection ) = 0;
    virtual bool GetFileInfo( IDebugSFileInfo** ppSection ) = 0;
};

// {E9B6D889-CC8B-46c9-9B3C-57643BB8680E}
static const GUID IID_IDebugSSymbols = 
{ 0xe9b6d889, 0xcc8b, 0x46c9, { 0x9b, 0x3c, 0x57, 0x64, 0x3b, 0xb8, 0x68, 0xe } };

class IDebugSSymbols: public IUnknown
{
public:
    //
    // Get a pointer to the buffer of symbol bytes, return the size of the buffer
    //
    virtual size_t GetData( BYTE** ppb ) = 0;
};

// {75A7CDBA-5FC4-41c1-B4BC-294090508A03}
static const GUID IID_IDebugSStringEnum = 
{ 0x75a7cdba, 0x5fc4, 0x41c1, { 0xb4, 0xbc, 0x29, 0x40, 0x90, 0x50, 0x8a, 0x3 } };

class IDebugSStringEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    //
    // Get the string and its offset in the section
    //
    virtual void GetUtf8( char** ppUtf8Str, DWORD* pOff ) = 0;   
    virtual void Get( wchar_t* szStr, DWORD* pccStr, DWORD* pOff ) = 0;   
};

// {B0C076E0-F631-465e-9945-8D083FFEE95E}
static const GUID IID_IDebugSStringTable = 
{ 0xb0c076e0, 0xf631, 0x465e, { 0x99, 0x45, 0x8d, 0x8, 0x3f, 0xfe, 0xe9, 0x5e } };

class IDebugSStringTable: public IUnknown
{
public:
    virtual bool GetStringEnum( IDebugSStringEnum** ppEnum ) = 0;
    virtual bool GetStringByOff( DWORD off, char** ppUtf8Str ) = 0;
};

// {D9F9F9A5-3C35-4c7d-95B1-AF55F899EF0F}
static const GUID IID_IDebugSFileEnum = 
{ 0xd9f9f9a5, 0x3c35, 0x4c7d, { 0x95, 0xb1, 0xaf, 0x55, 0xf8, 0x99, 0xef, 0xf } };

class IDebugSFileEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    //
    // Get the string offset, and its checksum info
    //
    virtual void Get( DWORD* idFile, DWORD* pOffString, DWORD* pChksumType, BYTE** ppChksum, DWORD* pcbChksum ) = 0;   
};
// {F71E95AA-95E9-4549-B72D-A0F4E1C576BA}
static const GUID IID_IDebugSFileInfo = 
{ 0xf71e95aa, 0x95e9, 0x4549, { 0xb7, 0x2d, 0xa0, 0xf4, 0xe1, 0xc5, 0x76, 0xba } };

class IDebugSFileInfo: public IUnknown
{
public:
    virtual bool GetFileEnum( IDebugSFileEnum** ppEnum ) = 0;
    virtual bool GetFileById( DWORD index, DWORD* pOffString, DWORD* pChksumType, BYTE** ppChksum, DWORD* pcbChksum ) = 0;
};

// {B3D97B8F-ADAC-49c9-8C04-B773F34DACFE}
static const GUID IID_IDebugSLineEnum = 
{ 0xb3d97b8f, 0xadac, 0x49c9, { 0x8c, 0x4, 0xb7, 0x73, 0xf3, 0x4d, 0xac, 0xfe } };

class IDebugSLineEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    //
    // Get the line details
    //
    //virtual void Get( DWORD* pindex) = 0;
    virtual void Get( CV_Line_t* pLine, CV_Column_t* pColumn ) = 0;
};

// {2BBCDB3E-D4AC-4076-8F0A-FACF3E6132A6}
static const GUID IID_IDebugSLineBlockEnum = 
{ 0x2bbcdb3e, 0xd4ac, 0x4076, { 0x8f, 0xa, 0xfa, 0xcf, 0x3e, 0x61, 0x32, 0xa6 } };

class IDebugSLineBlockEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    //
    // Get the file id
    //
    virtual void GetFileId( DWORD* pidFile ) = 0;
    virtual bool GetLineEnum( IDebugSLineEnum** ppEnum ) = 0;
    virtual void Get( DWORD* cLines, CV_Line_t** ppLines, CV_Column_t** ppColumns ) = 0;
    virtual bool GetSegOffset( WORD* pSeg, DWORD* pOffset, DWORD* pcb ) = 0;
    virtual bool clone( IDebugSLineBlockEnum **ppClone ) = 0;
};

// {A55C0A25-5402-4419-830D-903068898E13}
static const GUID IID_IDebugSLines = 
{ 0xa55c0a25, 0x5402, 0x4419, { 0x83, 0xd, 0x90, 0x30, 0x68, 0x89, 0x8e, 0x13 } };

class IDebugSLines: public IUnknown
{
public:
    virtual DWORD GetFlags() = 0;
    virtual bool GetSegOffset( WORD* pSeg, DWORD* pOffset, DWORD* pcb ) = 0;
    //virtual void GetLineEnum( IDebugSLineEnum** ppEnum ) = 0;
    virtual bool GetBlockEnum( IDebugSLineBlockEnum** ppEnum ) = 0;
};

// {6260200D-7F1E-44a1-8998-FCC8A0EEB4A0}
static const GUID IID_IDebugSFrameDataEnum = 
{ 0x6260200d, 0x7f1e, 0x44a1, { 0x89, 0x98, 0xfc, 0xc8, 0xa0, 0xee, 0xb4, 0xa0 } };

class IDebugSFrameDataEnum: public IUnknown
{
public:
    virtual void Reset() = 0;
    virtual bool Next() = 0;
    virtual void Get( FRAMEDATA* pData ) = 0;   
};

// {9BB21FD2-1F4B-46dc-8E03-AC7BED2730B4}
static const GUID IID_IDebugSFrameData = 
{ 0x9bb21fd2, 0x1f4b, 0x46dc, { 0x8e, 0x3, 0xac, 0x7b, 0xed, 0x27, 0x30, 0xb4 } };


class IDebugSFrameData: public IUnknown
{
public:
    virtual bool GetFrameDataEnum( IDebugSFrameDataEnum** ppEnum ) = 0;
    virtual bool GetFrameDataByRva( DWORD rva, FRAMEDATA* pData ) = 0;
    virtual bool GetSectionRva( DWORD* prva ) = 0;
    virtual bool ApplyReloc() = 0;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\fbrdbg.h ===
/* fbrdbg.h 
 * 
 * Definitions used for the FIBER DEBUG system service
 *
 * Steven Steiner 
 * 9/26/96
 */

typedef enum _OFBR {
	OFBR_QUERY_LIST_SIZE =0,
	OFBR_GET_LIST,
	OFBR_SET_FBRCNTX,
	OFBR_DISABLE_FBRS,
	OFBR_ENABLE_FBRS
} OFBR;

typedef struct _OFBRS {
	OFBR	op;
	LPVOID	FbrCntx;
} OFBRS;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\dbgoledb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Jan 08 17:02:50 1999
 */
/* Compiler settings for dbgoledb.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dbgoledb_h__
#define __dbgoledb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __DbgOleDB_FWD_DEFINED__
#define __DbgOleDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class DbgOleDB DbgOleDB;
#else
typedef struct DbgOleDB DbgOleDB;
#endif /* __cplusplus */

#endif 	/* __DbgOleDB_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dbgoledb_0000 */
/* [local] */ 


enum DBPROP_SESS
    {	DBPROP_INIT_EXE_TIMESTAMP	= 0x100L,
	DBPROP_INIT_SEARCHPATH	= DBPROP_INIT_EXE_TIMESTAMP + 1,
	DBPROP_SESS_LOADADDRESS	= DBPROP_INIT_SEARCHPATH + 1
    };

enum __MIDL___MIDL_itf_dbgoledb_0000_0001
    {	E_PDB_OK	= ( HRESULT  )(( unsigned long  )1 << 31 | ( unsigned long  )( LONG  )0x6d << 16 | ( unsigned long  )1),
	E_PDB_USAGE	= E_PDB_OK + 1,
	E_PDB_FILE_SYSTEM	= E_PDB_USAGE + 1,
	E_PDB_NOT_FOUND	= E_PDB_FILE_SYSTEM + 1,
	E_PDB_INVALID_SIG	= E_PDB_NOT_FOUND + 1,
	E_PDB_INVALID_AGE	= E_PDB_INVALID_SIG + 1,
	E_PDB_PRECOMP_REQUIRED	= E_PDB_INVALID_AGE + 1,
	E_PDB_OUT_OF_TI	= E_PDB_PRECOMP_REQUIRED + 1,
	E_PDB_V1_PDB	= E_PDB_OUT_OF_TI + 1,
	E_PDB_FORMAT	= E_PDB_V1_PDB + 1,
	E_PDB_LIMIT	= E_PDB_FORMAT + 1,
	E_PDB_CORRUPT	= E_PDB_LIMIT + 1,
	E_PDB_TI16	= E_PDB_CORRUPT + 1,
	E_PDB_ILLEGAL_TYPE_EDIT	= E_PDB_TI16 + 1,
	E_PDB_INVALID_EXECUTABLE	= E_PDB_ILLEGAL_TYPE_EDIT + 1,
	E_PDB_DBG_NOT_FOUND	= E_PDB_INVALID_EXECUTABLE + 1,
	E_PDB_NO_DEBUG_INFO	= E_PDB_DBG_NOT_FOUND + 1,
	E_PDB_INVALID_EXE_TIMESTAMP	= E_PDB_NO_DEBUG_INFO + 1,
	E_PDB_DEBUG_INFO_NOT_IN_PDB	= E_PDB_INVALID_EXE_TIMESTAMP + 1
    };

enum SymTagEnum
    {	SymTagNull	= 0,
	SymTagExe	= SymTagNull + 1,
	SymTagCompiland	= SymTagExe + 1,
	SymTagFunctionSymbol	= SymTagCompiland + 1,
	SymTagBlock	= SymTagFunctionSymbol + 1,
	SymTagData	= SymTagBlock + 1,
	SymTagConstant	= SymTagData + 1,
	SymTagLabel	= SymTagConstant + 1,
	SymTagPublicSymbol	= SymTagLabel + 1,
	SymTagUDT	= SymTagPublicSymbol + 1,
	SymTagEnum	= SymTagUDT + 1,
	SymTagFunctionType	= SymTagEnum + 1,
	SymTagPointerType	= SymTagFunctionType + 1,
	SymTagArrayType	= SymTagPointerType + 1,
	SymTagBaseType	= SymTagArrayType + 1,
	SymTagTypedef	= SymTagBaseType + 1,
	SymTagFunctionArgType	= SymTagTypedef + 1,
	SymTagFuncDebugStart	= SymTagFunctionArgType + 1,
	SymTagFuncDebugEnd	= SymTagFuncDebugStart + 1,
	SymTagCustom	= SymTagFuncDebugEnd + 1,
	SymTagMax	= SymTagCustom + 1
    };

enum LocationType
    {	LocIsStatic	= 0,
	LocIsTLS	= LocIsStatic + 1,
	LocIsRegRel	= LocIsTLS + 1,
	LocIsThisRel	= LocIsRegRel + 1,
	LocIsEnregistered	= LocIsThisRel + 1,
	LocIsBitField	= LocIsEnregistered + 1,
	LocTypeMax	= LocIsBitField + 1
    };

enum AccessSpecifier
    {	ASPublic	= 0,
	ASPrivate	= ASPublic + 1,
	ASProtect	= ASPrivate + 1
    };

enum FuncLanguageEnum
    {	FuncLanguageC	= 0,
	FuncLanguageCPlus	= FuncLanguageC + 1,
	FuncLanguageBasic	= FuncLanguageCPlus + 1,
	FuncLanguageFortran	= FuncLanguageBasic + 1,
	FuncLanguagePascal	= FuncLanguageFortran + 1,
	FuncLanguageJava	= FuncLanguagePascal + 1
    };

enum FuncThunkOrdinal
    {	FuncTONotAThunk	= 0,
	FuncTONoType	= FuncTONotAThunk + 1,
	FuncTOAdjustor	= FuncTONoType + 1,
	FuncTOVCall	= FuncTOAdjustor + 1,
	FuncTOPcode	= FuncTOVCall + 1,
	FuncTODelayLoad	= FuncTOPcode + 1
    };

enum BasicType
    {	btNoType	= 0,
	btVoid	= btNoType + 1,
	btChar	= btVoid + 1,
	btWChar	= btChar + 1,
	btSChar	= btWChar + 1,
	btUChar	= btSChar + 1,
	btInt	= btUChar + 1,
	btUInt	= btInt + 1,
	btFloat	= btUInt + 1,
	btBCD	= btFloat + 1,
	btBool	= btBCD + 1,
	btShort	= btBool + 1,
	btUShort	= btShort + 1,
	btLong	= btUShort + 1,
	btULong	= btLong + 1,
	btInt8	= btULong + 1,
	btInt16	= btInt8 + 1,
	btInt32	= btInt16 + 1,
	btInt64	= btInt32 + 1,
	btInt128	= btInt64 + 1,
	btUInt8	= btInt128 + 1,
	btUInt16	= btUInt8 + 1,
	btUInt32	= btUInt16 + 1,
	btUInt64	= btUInt32 + 1,
	btUInt128	= btUInt64 + 1,
	btCurrency	= btUInt128 + 1,
	btDate	= btCurrency + 1,
	btVariant	= btDate + 1,
	btComplex	= btVariant + 1,
	btBit	= btComplex + 1,
	btBSTR	= btBit + 1
    };

enum FunctionCallingConvention
    {	fccCdecl	= 0,
	fccStdcall	= fccCdecl + 1,
	fccFastcall	= fccStdcall + 1,
	fccThiscall	= fccFastcall + 1,
	fccPascal	= fccThiscall + 1,
	fccSyscall	= fccPascal + 1,
	fccCorcall	= fccSyscall + 1,
	fccMipsCall	= fccCorcall + 1,
	fccGeneric	= fccMipsCall + 1,
	fccAlpha	= fccGeneric + 1,
	fccPPC	= fccAlpha + 1,
	fccSHcall	= fccPPC + 1,
	fccArmcall	= fccSHcall + 1,
	fccUnknown	= fccArmcall + 1
    };


extern RPC_IF_HANDLE __MIDL_itf_dbgoledb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgoledb_0000_v0_0_s_ifspec;


#ifndef __DBGOLEDBLib_LIBRARY_DEFINED__
#define __DBGOLEDBLib_LIBRARY_DEFINED__

/* library DBGOLEDBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DBGOLEDBLib;

EXTERN_C const CLSID CLSID_DbgOleDB;

#ifdef __cplusplus

class DECLSPEC_UUID("4072ED30-BEA4-11D1-AC7E-00A0C90D2884")
DbgOleDB;
#endif
#endif /* __DBGOLEDBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\cvr.h ===
// CVR: CodeView Record utilities

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __CVR_INCLUDED__
#define __CVR_INCLUDED__

#include <pdb.h>
#include <cvinfo.h>
#include <stddef.h>
#ifndef _WINDOWS_
// get rid of baggage we don't need from windows.h
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
#define NOUSER
#define NONLS
#include "windows.h"
#endif

typedef BYTE* PB;
typedef long CB;
typedef char* SZ;       // zero terminated string
typedef wchar_t* USZ;   // unicode zero terminated string
typedef char* ST;       // length prefixed string
typedef SYMTYPE* PSYM;
typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
typedef TYPTYPE* PTYPE;

//////////////////////////////////////////////////////////////////////////////
// TII (type index iterator) implementation declarations

typedef ptrdiff_t IB;
typedef TI*     (*PfnTyti)(PTYPE, int, PB*, PB);
typedef TI16*   (*PfnTyti16)(PTYPE, int, PB*, PB);

struct TYTI { // position of type indices within a type record with the given leaf
    unsigned leaf;
    SZ sz;                      // leaf type name
    int cib;
    const IB* rgibTI;
    union {                     // fn to call if cib == cibFunction
        PfnTyti     pfn;
        PfnTyti16   pfn16;
    };
    PB  (*pfnPbAfter)(void* pv);      // end of record fn to call for elements of a field list
};

// all pointers to a TYTI are pointing to const TYTIs
typedef const TYTI *    PTYTI;

struct SYTI { // position of symbol indices within a symbol recoord with the given rectyp
    unsigned rectyp;
    SZ sz;                      // symbol rectyp name
    IB  ibName;                 // position of symbol name
    ST (*pfnstName)(PSYM psym); // function to call if name offset variable
    BOOL isGlobal;              // symbol is global
    int cib;
    const IB* rgibTI;
};

// all pointers to a SYTI are pointing to const SYTIs
typedef const SYTI *    PSYTI;

#if defined(PDB_LIBRARY)
#define CVR_EXPORT
#else
#if defined(CVR_IMP)
#define CVR_EXPORT  __declspec(dllexport)
#else
#define CVR_EXPORT  __declspec(dllimport)
#endif
#endif

#ifndef CVRAPI
#define CVRAPI   __cdecl
#endif

// functions that are in widenti.cpp
unsigned __fastcall
MapLeaf16To32 ( unsigned leaf16 );

unsigned __fastcall
MapSymRec16To32 ( unsigned rectyp16 );

#ifdef LNGNM

// New data type

typedef char *UTFSZ;

// functions from sttosz.cpp

CVR_EXPORT unsigned CVRAPI
MapLeafStToSz ( unsigned leafST );

CVR_EXPORT unsigned CVRAPI
MapSymRecStToSz ( unsigned rectypST );

inline bool fNeedsSzConversion( PSYM psym )
{
    return MapSymRecStToSz( psym->rectyp ) != psym->rectyp;
}

inline bool fIsStFieldList(PTYPE);
inline bool fIsStRefSym(PTYPE);

inline bool fNeedsSzConversion( PTYPE ptype )
{
    if (ptype->leaf == LF_FIELDLIST)
        return fIsStFieldList(ptype);
    else if (ptype->leaf == LF_REFSYM)
        return fIsStRefSym(ptype);
    else
        return MapLeafStToSz( ptype->leaf ) != ptype->leaf;
}

CVR_EXPORT BOOL CVRAPI fConvertSymRecStToSz(PSYM psymST);
CVR_EXPORT BOOL CVRAPI fConvertTypeRecStToSz(PTYPE ptype);
CVR_EXPORT BOOL CVRAPI fConvertSymRecStToSz(PB pbSrc, CB cbSrc, PB pbDest, CB *pcbDest);
CVR_EXPORT BOOL CVRAPI fConvertSymRecStToSzWithSig(PB pbSrc, CB cbSrc, PB pbDest, CB *pcbDest);
CVR_EXPORT BOOL CVRAPI fConvertSymRecStToSzInPlace(PB pbSyms, CB cbSyms);
CVR_EXPORT BOOL CVRAPI fConvertTypeRecsStToSz(PB pbSrc, PB pbDest, CB *pcb);

// It's just too bad putting #ifdef LNGNM ... #endif
// around simple statements like assert, a little better way ...

#define SZSYMIDX(n)         (MapSymRecStToSz(n))
#define SZLEAFIDX(n)        (MapLeafStToSz(n))

#define IS_SZ_FORMAT_PDB(p) (p->fIsSZPDB())

#else

#define SZSYMIDX(n)         (n)
#define SZLEAFIDX(n)        (n)

#endif

// utility functions for determining if type/symbol records may/must be
// converted from 16 to 32 bits.
inline bool fIs16bitTypRec(unsigned leaf)
{
    return leaf < LF_TI16_MAX;
}

inline bool fIs16bitSymRec(unsigned rectyp)
{
    return rectyp < S_TI16_MAX;
}

inline bool fIs16bitRec(PTYPE ptype)
{
    return fIs16bitTypRec ( ptype->leaf );
}

inline bool fIs16bitRec(PSYM psym)
{
    return psym->rectyp < S_TI16_MAX;
}

inline bool fNeeds16bitConversion(PSYM psym)
{
    unsigned rectyp = psym->rectyp;
    return
        rectyp < S_TI16_MAX &&
        MapSymRec16To32(rectyp) != rectyp;
}

inline bool fNeeds16bitConversion(PTYPE ptype)
{
    unsigned leaf = ptype->leaf;
    if (leaf < LF_TI16_MAX) {
        if (leaf == LF_REFSYM) {
            return fNeeds16bitConversion(PSYM(((lfRefSym*)(&ptype->leaf))->Sym));
        }
        return MapLeaf16To32(leaf) != leaf;
    }
    return false;
}

class SymTiIter { // type indices within symbol record iterator
public:
    CVR_EXPORT  SymTiIter(PSYM psym_);
    inline TI&  rti();
    inline BOOL next();

    inline TI16& rti16();
    inline BOOL f16Ti();
    inline unsigned cti();
    inline PB pbEndRecordSansPad();

private:
    PSYM psym;          // current symbol
    int  iib;           // index of current TI in this symbol record
    PSYTI psyti;        // address of symbol->ti-info for current symbol record
};

inline TI& SymTiIter::rti()
{
    return *(TI*)((PB)psym + psyti->rgibTI[iib]);
}

inline TI16& SymTiIter::rti16()
{
    return *(TI16*)((PB)psym + psyti->rgibTI[iib]);
}

inline BOOL SymTiIter::f16Ti()
{
    return psyti->rectyp < S_TI16_MAX;
}

inline unsigned SymTiIter::cti()
{
    return psyti->cib;
}


inline BOOL SymTiIter::next()
{
    return ++iib < psyti->cib;
}

inline PB SymTiIter::pbEndRecordSansPad()
{
    if (psyti->ibName) {
        PB  pbT = PB(psym) + psyti->ibName;
        return pbT + *pbT + 1;
    }
    else if (psyti->pfnstName) {
        PB  pbT = PB((psyti->pfnstName)(psym));
        return pbT + *pbT + 1;
    }
    else
        return 0;
}

class TypeTiIter { // type indices within type record iterator
public:
    CVR_EXPORT  TypeTiIter(TYPTYPE* ptype);

    inline TI&
    rti();

    CVR_EXPORT  BOOL
    next();

    PB
    pbFindField(unsigned leaf);

    inline TI16&
    rti16();

    inline BOOL
    f16Ti();

    inline PB
    pbCurField();

    inline void
    leafChanged();

    CVR_EXPORT  BOOL
    nextField();

    CB
    cbPadForCurField();

    PB
    pbEndCurFieldSansPad();

    CVR_EXPORT  PB
    pbEndRecordSansPad();

private:
    void
    init();

    PTYPE ptype;        // current type
    USHORT* pleaf;      // leaf part of current type
    unsigned    leaf;   // cached, aligned, no op-size override version of leaf
    PB   pbFnState;     // private state of current iterating fn (iff ptyti->cib == cibFunction)
    PB   pbEnd;         // pointer just past end of type record
    int  iib;           // index of current TI in this type record
    BOOL isFieldList;   // TRUE if this type record is a LF_FIELDLIST
    TI*  pti;           // address of current TI
    PTYTI ptyti;        // address of type->ti-info for current type record
};

inline TI& TypeTiIter::rti()
{
    return *pti;
}

inline TI16& TypeTiIter::rti16()
{
    return *PTi16(pti);
}

inline BOOL TypeTiIter::f16Ti()
{
    return ptyti->leaf < LF_TI16_MAX;
}

inline PB TypeTiIter::pbCurField()
{
    if (isFieldList && PB(pleaf) < pbEnd)
        return PB(pleaf);
    return 0;
}

// when we widen types, we need to reset the data since we change the
// leaf value of field lists out from under the iterator
inline void TypeTiIter::leafChanged()
{
    leaf = *pleaf;
    init();
}


// utility function protos
CVR_EXPORT BOOL CVRAPI fGetSymName(PSYM psym, OUT ST* pst);
           BOOL fSymIsGlobal(PSYM psym);
           bool fSymIsData(PSYM);
           BOOL fGetTypeLeafName(PTYPE ptype, OUT SZ* psz);
CVR_EXPORT BOOL CVRAPI fGetSymRecTypName(PSYM psym, OUT SZ* psz);

#ifdef LNGNM
// utility functions for unicode names
CVR_EXPORT bool CVRAPI fNameFromSym( PSYM psym, OUT wchar_t* szName, IN OUT unsigned long* pcch);
CVR_EXPORT bool CVRAPI fNameFromType( PTYPE ptype, OUT wchar_t* szName, IN OUT unsigned long* pcch);

inline bool fNameIsSz( PSYM psym )
{
    return psym->rectyp > S_ST_MAX;
}

inline bool fIsStFieldList(PTYPE ptype)
{
    TypeTiIter tii(ptype);

    while (tii.pbCurField() != NULL)
    {
        lfEasy *plf = (lfEasy *) tii.pbCurField();
        if (MapLeafStToSz(plf->leaf) != plf->leaf)
            return TRUE;
        if ( plf->leaf > LF_ST_MAX )    // a new leaf, cannot be st.
            return FALSE;
        if (!tii.nextField())
            break;
    }

    return FALSE;
}

inline bool fIsStRefSym(PTYPE ptype)
{
    return fNeedsSzConversion(PSYM(((lfRefSym *)&ptype->leaf)->Sym));
}

#endif

////////////////////////////////////////////////////////////////////////////////
// Inline utility functions.

// Return the number of bytes in an ST
inline CB cbForSt(ST st)
{
    return *(PB)st + 1;
}

// Return the number of bytes the type record occupies.
//
inline CB cbForType(PTYPE ptype)
{
    return ptype->len + sizeof(ptype->len);
}

// Return a pointer to the byte just past the end of the type record.
//
inline PB pbEndType(PTYPE ptype)
{
    return (PB)ptype + cbForType(ptype);
}

// Return the number of bytes the symbol record occupies.
//
#define MDALIGNTYPE_    DWORD

inline CB cbAlign_(CB cb)
{
    return ((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);
}

inline bool fIsRefSym(PSYMUNALIGNED psym)
{
    unsigned    rectyp = SZSYMIDX(psym->rectyp);
    return
        rectyp == S_PROCREF ||
        rectyp == S_DATAREF ||
        rectyp == S_LPROCREF ||
        rectyp == S_ANNOTATIONREF
#if defined(LNGNM)
        ||
        rectyp == S_TOKENREF
#endif
        ;
}

inline bool fIsThunkSym(PSYMUNALIGNED psym)
{
    unsigned rectyp = SZSYMIDX(psym->rectyp);
    return rectyp == S_THUNK32
#ifdef LNGNM
        || rectyp == S_TRAMPOLINE
#endif
    ;
}

inline CB cbForSym(PSYMUNALIGNED psym)
{
    CB cb = psym->reclen + sizeof(psym->reclen);
    // REFSYMs also have a hidden length preceeded name following the record,
    // REFSYM2s do not, as they have a first class name field.
    // S_ANNOTATIONREF symbols are REFSYM2s, even in 6.0 PDBs.
    //
    if (fIsRefSym(psym)) {
        unsigned    rectypCur = psym->rectyp;

#if defined(LNGNM)
        unsigned    rectypNew = MapSymRecStToSz(rectypCur);

        // S_ANNOTATIONREF syms are the same in old and new,
        // so this check will keep us from adding in bytes to
        // the length on the REFSYM2 for the S_ANNOTATIONREF.
        if (rectypNew != rectypCur)
#else
        if (rectypCur != S_ANNOTATIONREF)
#endif
        {
            cb += cbAlign_(cbForSt((ST)((PB)psym + cb)));
        }
    }
    return cb;
}

// Return a pointer to the byte just past the end of the symbol record.
//
inline PB pbEndSym(PSYM psym)
{
    return (PB)psym + cbForSym(psym);
}

inline BOOL fIntroducingVirtual ( CV_methodprop_e mprop )
{
    return mprop == CV_MTintro || mprop == CV_MTpureintro;
}

inline BOOL fVirtual ( CV_methodprop_e mprop )
{
    return
        fIntroducingVirtual ( mprop ) ||
        mprop == CV_MTvirtual ||
        mprop == CV_MTpurevirt
        ;
}


#endif // __CVR_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\exe_vxd.h ===
/*
 *  Title
 *
 *	exe386.h
 *	Wieslaw Kalkus
 *	(C) Copyright Microsoft Corp 1988-1992
 *	5 August 1988
 *
 *  Description
 *
 *	Data structure definitions for the OS/2
 *	executable file format (flat model).
 *
 *  Modification History
 *
 *	88/08/05	Wieslaw Kalkus	Initial version
 */


#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	OS/2 .EXE FILE HEADER DEFINITION - 386 version 0:32	       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#define BITPERWORD	16
#define BITPERBYTE	8
#define OBJPAGELEN	4096
#define E32MAGIC1	'L'		/* New magic number  "LE" */
#define E32MAGIC2	'E'		/* New magic number  "LE" */
#define E32MAGIC        0x454c          /* New magic number  "LE" */
#define E32RESBYTES1    0               /* First bytes reserved */
#define E32RESBYTES2	0		/* Second bytes reserved */
#define E32RESBYTES3	24		/* Third bytes reserved */
#define E32LEBO 	0x00		/* Little Endian Byte Order */
#define E32BEBO 	0x01		/* Big Endian Byte Order */
#define E32LEWO 	0x00		/* Little Endian Word Order */
#define E32BEWO 	0x01		/* Big Endian Word Order */
#define E32LEVEL	0L		/* 32-bit EXE format level */
#define E32CPU286	0x001		/* Intel 80286 or upwardly compatibile */
#define E32CPU386	0x002		/* Intel 80386 or upwardly compatibile */
#define E32CPU486	0x003		/* Intel 80486 or upwardly compatibile */



struct e32_exe {			/* New 32-bit .EXE header */
    unsigned char	e32_magic[2];	/* Magic number E32_MAGIC */
    unsigned char	e32_border;	/* The byte ordering for the .EXE */
    unsigned char	e32_worder;	/* The word ordering for the .EXE */
    unsigned long	e32_level;	/* The EXE format level for now = 0 */
    unsigned short	e32_cpu;	/* The CPU type */
    unsigned short	e32_os; 	/* The OS type */
    unsigned long	e32_ver;	/* Module version */
    unsigned long	e32_mflags;	/* Module flags */
    unsigned long	e32_mpages;	/* Module # pages */
    unsigned long	e32_startobj;	/* Object # for instruction pointer */
    unsigned long	e32_eip;	/* Extended instruction pointer */
    unsigned long	e32_stackobj;	/* Object # for stack pointer */
    unsigned long	e32_esp;	/* Extended stack pointer */
    unsigned long	e32_pagesize;	/* .EXE page size */
    unsigned long       e32_lastpagesize;/* Last page size in .EXE */
    unsigned long	e32_fixupsize;	/* Fixup section size */
    unsigned long	e32_fixupsum;	/* Fixup section checksum */
    unsigned long	e32_ldrsize;	/* Loader section size */
    unsigned long	e32_ldrsum;	/* Loader section checksum */
    unsigned long	e32_objtab;	/* Object table offset */
    unsigned long	e32_objcnt;	/* Number of objects in module */
    unsigned long	e32_objmap;	/* Object page map offset */
    unsigned long	e32_itermap;	/* Object iterated data map offset */
    unsigned long	e32_rsrctab;	/* Offset of Resource Table */
    unsigned long	e32_rsrccnt;	/* Number of resource entries */
    unsigned long	e32_restab;	/* Offset of resident name table */
    unsigned long	e32_enttab;	/* Offset of Entry Table */
    unsigned long	e32_dirtab;	/* Offset of Module Directive Table */
    unsigned long	e32_dircnt;	/* Number of module directives */
    unsigned long	e32_fpagetab;	/* Offset of Fixup Page Table */
    unsigned long	e32_frectab;	/* Offset of Fixup Record Table */
    unsigned long	e32_impmod;	/* Offset of Import Module Name Table */
    unsigned long	e32_impmodcnt;	/* Number of entries in Import Module Name Table */
    unsigned long	e32_impproc;	/* Offset of Import Procedure Name Table */
    unsigned long	e32_pagesum;	/* Offset of Per-Page Checksum Table */
    unsigned long	e32_datapage;	/* Offset of Enumerated Data Pages */
    unsigned long	e32_preload;	/* Number of preload pages */
    unsigned long	e32_nrestab;	/* Offset of Non-resident Names Table */
    unsigned long	e32_cbnrestab;	/* Size of Non-resident Name Table */
    unsigned long	e32_nressum;	/* Non-resident Name Table Checksum */
    unsigned long	e32_autodata;	/* Object # for automatic data object */
    unsigned long	e32_debuginfo;	/* Offset of the debugging information */
    unsigned long	e32_debuglen;	/* The length of the debugging info. in bytes */
    unsigned long	e32_instpreload;/* Number of instance pages in preload section of .EXE file */
    unsigned long	e32_instdemand; /* Number of instance pages in demand load section of .EXE file */
    unsigned long	e32_heapsize;	/* Size of heap - for 16-bit apps */
    unsigned char	e32_res3[E32RESBYTES3 - 4 - 8];
					/* Pad structure to 192 bytes */
    unsigned long	e32_winresoff ;
    unsigned long	e32_winreslen ;
    unsigned short	Dev386_Device_ID;
					/* Device ID for VxD */
    unsigned short	Dev386_DDK_Version;
					/* DDK version for VxD */
};



#define E32_MAGIC1(x)	    (x).e32_magic[0]
#define E32_MAGIC2(x)	    (x).e32_magic[1]
#define E32_BORDER(x)	    (x).e32_border
#define E32_WORDER(x)	    (x).e32_worder
#define E32_LEVEL(x)	    (x).e32_level
#define E32_CPU(x)	    (x).e32_cpu
#define E32_OS(x)	    (x).e32_os
#define E32_VER(x)	    (x).e32_ver
#define E32_MFLAGS(x)	    (x).e32_mflags
#define E32_MPAGES(x)	    (x).e32_mpages
#define E32_STARTOBJ(x)     (x).e32_startobj
#define E32_EIP(x)	    (x).e32_eip
#define E32_STACKOBJ(x)     (x).e32_stackobj
#define E32_ESP(x)	    (x).e32_esp
#define E32_PAGESIZE(x)     (x).e32_pagesize
#define E32_LASTPAGESIZE(x) (x).e32_lastpagesize
#define E32_FIXUPSIZE(x)    (x).e32_fixupsize
#define E32_FIXUPSUM(x)     (x).e32_fixupsum
#define E32_LDRSIZE(x)	    (x).e32_ldrsize
#define E32_LDRSUM(x)	    (x).e32_ldrsum
#define E32_OBJTAB(x)	    (x).e32_objtab
#define E32_OBJCNT(x)	    (x).e32_objcnt
#define E32_OBJMAP(x)	    (x).e32_objmap
#define E32_ITERMAP(x)	    (x).e32_itermap
#define E32_RSRCTAB(x)	    (x).e32_rsrctab
#define E32_RSRCCNT(x)	    (x).e32_rsrccnt
#define E32_RESTAB(x)	    (x).e32_restab
#define E32_ENTTAB(x)	    (x).e32_enttab
#define E32_DIRTAB(x)	    (x).e32_dirtab
#define E32_DIRCNT(x)	    (x).e32_dircnt
#define E32_FPAGETAB(x)     (x).e32_fpagetab
#define E32_FRECTAB(x)	    (x).e32_frectab
#define E32_IMPMOD(x)	    (x).e32_impmod
#define E32_IMPMODCNT(x)    (x).e32_impmodcnt
#define E32_IMPPROC(x)	    (x).e32_impproc
#define E32_PAGESUM(x)	    (x).e32_pagesum
#define E32_DATAPAGE(x)     (x).e32_datapage
#define E32_PRELOAD(x)	    (x).e32_preload
#define E32_NRESTAB(x)	    (x).e32_nrestab
#define E32_CBNRESTAB(x)    (x).e32_cbnrestab
#define E32_NRESSUM(x)	    (x).e32_nressum
#define E32_AUTODATA(x)     (x).e32_autodata
#define E32_DEBUGINFO(x)    (x).e32_debuginfo
#define E32_DEBUGLEN(x)     (x).e32_debuglen
#define E32_INSTPRELOAD(x)  (x).e32_instpreload
#define E32_INSTDEMAND(x)   (x).e32_instdemand
#define E32_HEAPSIZE(x)     (x).e32_heapsize



/*
 *  Format of E32_MFLAGS(x):
 *
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	   |	    | | |     | |   |
 *   |	   |	    | | |     | |   +------- Per-Process Library Initialization
 *   |	   |	    | | |     | +----------- No Internal Fixups for Module in .EXE
 *   |	   |	    | | |     +------------- No External Fixups for Module in .EXE
 *   |	   |	    | | +------------------- Incompatible with PM Windowing
 *   |	   |	    | +--------------------- Compatible with PM Windowing
 *   |	   |	    +----------------------- Uses PM Windowing API
 *   |	   +-------------------------------- Module not Loadable
 *   +-------------------------------------- Library Module
 */


#define E32NOTP 	 0x8000L	/* Library Module - used as NENOTP */
#define E32NOLOAD	 0x2000L	/* Module not Loadable */
#define E32PMAPI	 0x0300L	/* Uses PM Windowing API */
#define E32PMW		 0x0200L	/* Compatible with PM Windowing */
#define E32NOPMW	 0x0100L	/* Incompatible with PM Windowing */
#define E32NOEXTFIX	 0x0020L	/* NO External Fixups in .EXE */
#define E32NOINTFIX	 0x0010L	/* NO Internal Fixups in .EXE */
#define E32LIBINIT	 0x0004L	/* Per-Process Library Initialization */
#define E32APPMASK	 0x0700L	/* Aplication Type Mask */


/*
 *  Format of E32_MFLAGS(x):
 *
 *  High word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *				      | |
 *				      | +--- Protected memory library module
 *				      +----- Device driver
 */

#define E32PROTDLL	 0x10000L	// Protected memory library module
#define E32DEVICE	 0x20000L	// Device driver
#define E32MODEXE	 0x00000L	// .EXE module
#define E32MODDLL	 0x08000L	// .DLL module
#define E32MODPROTDLL	 0x18000L	// Protected memory library module
#define E32MODPDEV	 0x20000L	// Physical device driver
#define E32MODVDEV	 0x28000L	// Virtual device driver
#define E32MODVDEVDYN	 0x38000L	// Virtual device driver (dynamic)
#define E32MODMASK	 0x38000L	// Module type mask

/*
 *  RELOCATION DEFINITIONS - RUN-TIME FIXUPS
 */


#pragma pack(1) 			/* This data must be packed */


typedef union _offset
{
    unsigned short offset16;
    unsigned long  offset32;
}
    offset;				/* 16-bit or 32-bit offset */


/***ET+	r32_rlc - Relocation item */

struct r32_rlc {			/* Relocation item */
    unsigned char nr_stype;		/* Source type - shared with new_rlc */
    unsigned char nr_flags;		/* Flag byte - shared with new_rlc */
    short r32_soff;			/* Source page offset */
    unsigned short r32_objmod;		/* Target obj. no. or Module ordinal */

    union targetid {			/* BEGIN UNION */
	unsigned long intref;		/* Internal fixup offset */
	unsigned long proc;		/* Procedure name offset */
	unsigned long ord;	 	/* Procedure ordinal */
    } r32_target;			/* END UNION */
    unsigned long addval;		/* Value added to the address */
    unsigned short r32_srccount;	/* Number of chained fixup records */
    unsigned short r32_chain;		/* Chain head */
};


#pragma pack()				/* Stop packing */


/*
 *  In 32-bit .EXE file run-time relocations are written as varying size
 *  records, so we need many size definitions.
 */

#define RINTSIZE16	8
#define RINTSIZE32	10
#define RORDSIZE	8
#define RNAMSIZE16	8
#define RNAMSIZE32	10
#define RADDSIZE16	10
#define RADDSIZE32	12



#if FALSE
/*
 *  Access macros defined in NEWEXE.H !!!
 */
#define NR_STYPE(x)	 (x).nr_stype
#define NR_FLAGS(x)	 (x).nr_flags
#endif

#define R32_SOFF(x)	 (x).r32_soff
#define R32_OBJNO(x)	 (x).r32_objmod
#define R32_MODORD(x)	 (x).r32_objmod
#define R32_OFFSET(x)    (x).r32_target.intref
#define R32_PROCOFF(x)   (x).r32_target.proc
#define R32_PROCORD(x)	 (x).r32_target.ord
#define R32_ADDVAL(x)    (x).addval
#define R32_SRCCNT(x)	 (x).r32_srccount
#define R32_CHAIN(x)	 (x).r32_chain



/*
 *  Format of NR_STYPE(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	     | | | | | |
 *	     | | +-+-+-+--- Source type
 *	     | +----------- Fixup to 16:16 alias
 *	     +------------- List of source offset follows fixup record
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48 	0x06		/* 16:32 pointer (48-bits) */
#define NROFF32 	0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */
#endif


#define NRSRCMASK	0x0f		/* Source type mask */
#define NRALIAS 	0x10		/* Fixup to alias */
#define NRCHAIN 	0x20		/* List of source offset follows */
					/* fixup record, source offset field */
					/* in fixup record contains number */
					/* of elements in list */

/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | |   | | |
 *	 | | | |   | +-+--- Reference type
 *	 | | | |   +------- Additive fixup
 *	 | | | +----------- 32-bit Target Offset Flag (1 - 32-bit; 0 - 16-bit)
 *	 | | +------------- 32-bit Additive Flag (1 - 32-bit; 0 - 16-bit)
 *	 | +--------------- 16-bit Object/Module ordinal (1 - 16-bit; 0 - 8-bit)
 *	 +----------------- 8-bit import ordinal (1 - 8-bit;
 *						  0 - NR32BITOFF toggles
 *						      between 16 and 32 bit
 *						      ordinal)
 */

#if FALSE

	    /* DEFINED in newexe.h !!! */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#endif

#define NRRENT		0x03		/* Internal entry table fixup */

#define NR32BITOFF	0x10		/* 32-bit Target Offset */
#define NR32BITADD	0x20		/* 32-bit Additive fixup */
#define NR16OBJMOD	0x40		/* 16-bit Object/Module ordinal */
#define NR8BITORD	0x80		/* 8-bit import ordinal */
/*end*/

/*
 *  Data structures for storing run-time fixups in linker virtual memory.
 *
 *  Each object has a list of Object Page Directories which specify
 *  fixups for given page. Each page has its own hash table which is
 *  used to detect fixups to the same target.
 */

#define PAGEPERDIR	62
#define LG2DIR		7


typedef struct _OBJPAGEDIR
{
    DWORD   next;			/* Virtual pointer to next dir on list */
    WORD    ht[PAGEPERDIR];		/* Pointers to individual hash tables */
}
    OBJPAGEDIR;



/*
 *  OBJECT TABLE
 */

/***ET+	o32_obj Object Table Entry */

struct o32_obj				/* Flat .EXE object table entry */
{
    unsigned long	o32_size;	/* Object virtual size */
    unsigned long	o32_base;	/* Object base virtual address */
    unsigned long	o32_flags;	/* Attribute flags */
    unsigned long	o32_pagemap;	/* Object page map index */
    unsigned long	o32_mapsize;	/* Number of entries in object page map */
    unsigned long	o32_reserved;	/* Reserved */
};


#define O32_SIZE(x)	(x).o32_size
#define O32_BASE(x)	(x).o32_base
#define O32_FLAGS(x)	(x).o32_flags
#define O32_PAGEMAP(x)	(x).o32_pagemap
#define O32_MAPSIZE(x)	(x).o32_mapsize
#define O32_RESERVED(x) (x).o32_reserved



/*
 *  Format of O32_FLAGS(x)
 *
 *  High word of dword flag field is not used for now.
 *  Low word has the following format:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *   |	|  |  |     | | | | | | | | | | |
 *   |	|  |  |     | | | | | | | | | | +--- Readable Object
 *   |	|  |  |     | | | | | | | | | +----- Writeable Object
 *   |	|  |  |     | | | | | | | | +------- Executable Object
 *   |	|  |  |     | | | | | | | +--------- Resource Object
 *   |	|  |  |     | | | | | | +----------- Object is Discardable
 *   |	|  |  |     | | | | | +------------- Object is Shared
 *   |	|  |  |     | | | | +--------------- Object has preload pages
 *   |	|  |  |     | | | +----------------- Object has invalid pages
 *   |	|  |  |     | | +------------------- Object is permanent and swappable
 *   |	|  |  |     | +--------------------- Object is permanent and resident
 *   |	|  |  |     +----------------------- Object is permanent and long lockable
 *   |	|  |  +----------------------------- 16:16 alias required (80x86 specific)
 *   |	|  +-------------------------------- Big/Default bit setting (80x86 specific)
 *   |	+----------------------------------- Object is conforming for code (80x86 specific)
 *   +-------------------------------------- Object I/O privilege level (80x86 specific)
 *
 */

#define OBJREAD 	0x0001L 	    /* Readable Object	 */
#define OBJWRITE	0x0002L 	    /* Writeable Object  */
#define OBJRSRC 	0x0008L 	    /* Resource Object	 */
#define OBJINVALID	0x0080L 	    /* Object has invalid pages  */
#define OBJNONPERM	0x0600L 	    /* Object is nonpermanent - should be */
					    /* zero in the .EXE but internally we use 6 */
#define OBJPERM 	0x0100L 	    /* Object is permanent and swappable */
#define OBJRESIDENT	0x0200L 	    /* Object is permanent and resident */
#define OBJCONTIG	0x0300L 	    /* Object is resident and contiguous */
#define OBJDYNAMIC	0x0400L 	    /* Object is permanent and long locable */
#define OBJTYPEMASK	0x0700L 	    /* Object type mask */
#define OBJALIAS16	0x1000L 	    /* 16:16 alias required (80x86 specific)	       */
#define OBJBIGDEF	0x2000L 	    /* Big/Default bit setting (80x86 specific)        */
#define OBJIOPL 	0x8000L 	    /* Object I/O privilege level (80x86 specific)     */

#define OBJDISCARD	 0x0010L	    /* Object is Discardable */
#define OBJSHARED	 0x0020L	    /* Object is Shared */
#define OBJPRELOAD	 0x0040L	    /* Object has preload pages  */
#define OBJEXEC 	 0x0004L	    /* Executable Object */
#define OBJCONFORM	 0x4000L	    /* Object is conforming for code (80x86 specific)  */

/*
 *  Life will be easier, if we keep the same names for the following flags:
 */
#define NSDISCARD	OBJDISCARD 	    /* Object is Discardable */
#define NSMOVE		NSDISCARD	    /* Moveable object is for sure Discardable */
#define NSSHARED	OBJSHARED 	    /* Object is Shared */
#define NSPRELOAD	OBJPRELOAD 	    /* Object has preload pages  */
#define NSEXRD		OBJEXEC 	    /* Executable Object */
#define NSCONFORM	OBJCONFORM 	    /* Object is conforming for code (80x86 specific)  */
/*end*/

/***ET+	o32_map - Object Page Map entry */

struct o32_map				    /* Object Page Map entry */
{
    unsigned char   o32_pageidx[3];	    /* 24-bit page # in .EXE file */
    unsigned char   o32_pageflags;	    /* Per-Page attributes */
};


#define GETPAGEIDX(x)	((((unsigned long)((x).o32_pageidx[0])) << BITPERWORD) + \
			 (((x).o32_pageidx[1]) << BITPERBYTE) + \
			   (x).o32_pageidx[2])

#define PUTPAGEIDX(x,i) ((x).o32_pageidx[0] = (unsigned char) ((unsigned long)(i) >> BITPERWORD), \
			 (x).o32_pageidx[1] = (unsigned char) ((i) >> BITPERBYTE), \
			 (x).o32_pageidx[2] = (unsigned char) ((i) &  0xff))

#define PAGEFLAGS(x)	(x).o32_pageflags


#define VALID		0x00		    /* Valid Physical Page in .EXE */
#define ITERDATA	0x01		    /* Iterated Data Page */
#define INVALID 	0x02		    /* Invalid Page */
#define ZEROED		0x03		    /* Zero Filled Page */
#define RANGE		0x04		    /* Range of pages */
/*end*/

/*
 *  RESOURCE TABLE
 */

/***ET+	rsrc32 - Resource Table Entry */

struct rsrc32				    /* Resource Table Entry */
{
    unsigned short	type;		    /* Resource type */
    unsigned short	name;		    /* Resource name */
    unsigned long	cb;		    /* Resource size */
    unsigned short	obj;		    /* Object number */
    unsigned long	offset; 	    /* Offset within object */
};
/*end*/


#pragma pack(1) 			/* This data must be packed */

/*
 *  ENTRY TABLE DEFINITIONS
 */

/***ET+	b32_bundle - Entry Table */

struct b32_bundle
{
    unsigned char	b32_cnt;	/* Number of entries in this bundle */
    unsigned char	b32_type;	/* Bundle type */
    unsigned short	b32_obj;	/* Object number */
};					/* Follows entry types */

struct e32_entry
{
    unsigned char	e32_flags;	/* Entry point flags */
    union entrykind
    {
	offset		e32_offset;	/* 16-bit/32-bit offset entry */
	struct
	{
	    unsigned short offset;	/* Offset in segment */
	    unsigned short callgate;	/* Callgate selector */
	}
			e32_callgate;	/* 286 (16-bit) call gate */
	struct
	{
	    unsigned short  modord;	/* Module ordinal number */
	    unsigned long   value;	/* Proc name offset or ordinal */
	}
			e32_fwd;	/* Forwarder */
    }
			e32_variant;	/* Entry variant */
};

#pragma pack()				/* Stop packing */


#define B32_CNT(x)	(x).b32_cnt
#define B32_TYPE(x)	(x).b32_type
#define B32_OBJ(x)	(x).b32_obj

#define E32_EFLAGS(x)	(x).e32_flags
#define E32_OFFSET16(x) (x).e32_variant.e32_offset.offset16
#define E32_OFFSET32(x) (x).e32_variant.e32_offset.offset32
#define E32_GATEOFF(x)	(x).e32_variant.e32_callgate.offset
#define E32_GATE(x)	(x).e32_variant.e32_callgate.callgate
#define E32_MODORD(x)	(x).e32_variant.e32_fwd.modord
#define E32_VALUE(x)	(x).e32_variant.e32_fwd.value

#define FIXENT16	3
#define FIXENT32	5
#define GATEENT16	5
#define FWDENT		7

/*
 *  BUNDLE TYPES
 */

#define EMPTY	     0x00		/* Empty bundle */
#define ENTRY16      0x01		/* 16-bit offset entry point */
#define GATE16	     0x02		/* 286 call gate (16-bit IOPL) */
#define ENTRY32      0x03		/* 32-bit offset entry point */
#define ENTRYFWD     0x04		/* Forwarder entry point */
#define TYPEINFO     0x80		/* Typing information present flag */


/*
 *  Format for E32_EFLAGS(x)
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *	 | | | | | | | |
 *	 | | | | | | | +--- exported entry
 *	 | | | | | | +----- uses shared data
 *	 +-+-+-+-+-+------- parameter word count
 */

#define E32EXPORT	0x01		/* Exported entry */
#define E32SHARED	0x02		/* Uses shared data */
#define E32PARAMS	0xf8		/* Parameter word count mask */

/*
 *  Flags for forwarders only:
 */

#define FWD_ORDINAL	0x01		/* Imported by ordinal */
/*end*/


struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Reserved0;        /* INIT <0> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\ilstore.h ===
// ILStore API
// Copyright (C) 1994, Microsoft Corp.  All Rights Reserved.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __ILSTORE_INCLUDED__
#define __ILSTORE_INCLUDED__

#ifndef __PDB_INCLUDED__
#include "pdb.h"
#endif

typedef unsigned long KEY;		// temporary
typedef unsigned long ILSig; 	// signature of an ILStream
typedef unsigned char ILSType;	// ILStream type: GL, EX, SY, IN, etc.
typedef unsigned char ILSpace;	// storage domain hint: module, shared, PCH, etc.
typedef unsigned short ILVer;	// version (no. of times changed) of an IL contribution

enum {
	ilstypeNil,
	ilstypeGL,
	ilstypeEX,
	ilstypeSY,
	ilstypeIN,
	ilstypeEEA
};

enum {
	ilspaceNil,
	ilspaceMod,
	ilspaceShared,
};

enum {
	ilverNil,
	ilverNew,
	ilverMax = 65535
};

struct ILStore;
struct ILMod;
struct Buf;
typedef struct ILStore ILStore;
typedef struct ILMod ILMod;
typedef struct Buf Buf;

#if defined(__cplusplus)

PdbInterface ILStore {
	static PDBAPI(BOOL) open(PDB* ppdb, BOOL write, OUT ILStore** pilstore);
	virtual BOOL release() pure;

	virtual BOOL reset() pure;
	virtual BOOL getILMod(const char* szModule, OUT ILMod** ppilmod) pure;
	virtual BOOL getEnumILModNames(OUT EnumNameMap** ppenum) pure;

	virtual BOOL getILSType(const char* szILSType, OUT ILSType* pilstype) pure;
	// virtual BOOL getILSTypeMap(const char* szILSType, OUT const NameMap** ppnmILSType) pure;
	virtual BOOL getILSpace(const char* szILSpace, OUT ILSpace* pilspace) pure;
	// virtual BOOL getILSpaceMap(const char* szILSpace, OUT const NameMap** ppnmILSpace) pure;
#ifdef _DEBUG
	virtual BOOL getInfo( OUT long *pcStreamSz,
		OUT long *pcTotalILU,	OUT ULONG *pnumberOfILU,
		OUT long *pcTotShILU=NULL, OUT ULONG *pNumSharedILU=NULL ) pure;
#endif
};

PdbInterface EnumKeyType : Enum {
	virtual void get(OUT KEY* pkey, OUT ILSType *pilt, OUT ILSpace *pils) pure;
};

PdbInterface ILMod {
	virtual BOOL release() pure;

	virtual BOOL reset() pure;
	virtual BOOL getIL(KEY key, ILSType ilstype, OUT Buf *pbuf, OUT SIG* psig) pure;
	virtual BOOL getILVer(KEY key, OUT ILVer* pilver) pure;
	virtual BOOL putIL(KEY key, ILSType ilstype, Buf buf, ILSpace ilspace) pure;
	virtual BOOL getEnumILKT(OUT EnumKeyType** ppenum) pure;
	// virtual BOOL getEnumILStreams(ILSpace ilspace, OUT EnumStreams** ppenum) pure;
	// gets information and checks for inconsistencies

	// only succeeds in debug builds
	virtual BOOL getInfo( OUT long *pcStreamSz, 
		OUT long *pcTotalILU,	OUT ULONG *pnumberOfILU,
		OUT long *pcTotShILU=NULL, OUT ULONG *pNumSharedILU=NULL ) pure;

	virtual BOOL getAllIL(ILSType ilstype, OUT Buf* pbuf) pure;
	virtual BOOL deleteIL(KEY key, ILSType ilstype) pure;
};
#endif // __cplusplus

struct Buf {
	BYTE* pb;
	long cb;
#ifdef __cplusplus
	Buf() { }
	Buf(BYTE* pb_, long cb_) {
		pb = pb_;
		cb = cb_;
	}
#endif
};

#ifdef __cplusplus
extern "C" {
#endif

PDBAPI(BOOL) ILStoreOpen(PDB* ppdb, BOOL write, OUT ILStore** pilstore);
PDBAPI(BOOL) ILStoreRelease(ILStore* pilstore);
PDBAPI(BOOL) ILStoreReset(ILStore* pilstore);
PDBAPI(BOOL) ILStoreGetILMod(ILStore* pilstore, const char* szModule, OUT ILMod** ppilmod);
PDBAPI(BOOL) ILStoreGetILSType(ILStore* pilstore, const char* szILSType, OUT ILSType* pilstype);
PDBAPI(BOOL) ILStoreGetILSpace(ILStore* pilstore, const char* szILSpace, OUT ILSpace* pilspace);

PDBAPI(BOOL) ILModRelease(ILMod* pilmod);
PDBAPI(BOOL) ILModReset(ILMod* pilmod);
PDBAPI(BOOL) ILModGetIL(ILMod* pilmod, KEY key, ILSType ilstype, OUT Buf *pbuf, OUT SIG* psig);
PDBAPI(BOOL) ILModGetAllIL(ILMod* pilmod, ILSType ilstype, OUT Buf *pbuf);
PDBAPI(BOOL) ILModGetILVer(ILMod* pilmod, KEY key, OUT ILVer* pilver);
PDBAPI(BOOL) ILModPutIL(ILMod* pilmod, KEY key, ILSType ilstype, Buf buf, ILSpace ilspace);

#ifdef __cplusplus
};
#endif

#endif //!__ILSTORE_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*	01-25-00  GB    Declared _CxxThrowException __declspec(noreturn)
*	02-08-00  GB    Added HT_ISCOMPLUSEH
*	03-27-00  PML   Remove CC_P7_SOFT25, which is now on permanently.
*       09-20-00  GB    Add __cdecl to URT C++ EH support routines (vs7#89576)
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#ifdef ONLY_VALUES
#define _EHDATA_NOHEADERS
#endif

#ifndef _CRTBLD
#ifndef _VC_VER_INC
#ifdef _M_ALPHA
#include "vcver.h"
#else
#include "..\include\vcver.h"
#endif
#endif
#endif /* _CRTBLD */


#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#if defined(_M_IA64) || defined(_M_AMD64)
#define EH_EXCEPTION_PARAMETERS 4			// Number of parameters in exception record
#else
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record
#endif

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

#define EH_EMPTY_STATE	-1

#ifndef ONLY_VALUES

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
	__int32		mdisp;		// Offset of intended data within base
	__int32		pdisp;		// Displacement to virtual base pointer
	__int32		vdisp;		// Index within vbTable to offset of base
#else
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
#endif
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

#ifndef WANT_NO_TYPES
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
typedef	__int32	PMFN;					// Image relative offset of Member Function
#else
typedef void (* __ptr64 PMFN)(void* __ptr64);
#endif
#else
typedef void (*PMFN)(void);
#endif
#endif // WANT_NO_TYPES

//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7) || defined(_M_AMD64)
#pragma pack(push, TypeDescriptor, 8)
#endif

#ifndef WANT_NO_TYPES
typedef struct TypeDescriptor
{
#if defined(_WIN64) /*IFSTRIP=IGN*/
	const void * __ptr64	pVFTable;	// Field overloaded by RTTI
	void * __ptr64			spare;		// reserved, possible for RTTI
#else	// _WIN64
#if defined(_RTTI)
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
#endif	// _WIN64
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#endif // WANT_NO_TYPES

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_P7) || defined(_M_AMD64)
#pragma pack(pop, TypeDescriptor)
#endif
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pType;					// Image relative offset of TypeDescriptor
#else
	TypeDescriptor * __ptr64 pType;			// Pointer to the type descriptor for this type
#endif
#else
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
#endif
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;
#endif // WANT_NO_TYPES

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#if defined(_M_IA64) || defined(_M_AMD64)
#define CT_PTD_IB(ct,ib)		((TypeDescriptor *)((ib) + (ct).pType))
#define CT_COPYFUNC_IB(ct,ib)	((void (* __ptr64)(void* __ptr64))((ib) + (ct).copyFunction))
#else
#define CT_PTD(ct)			((ct).pType)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#endif
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			arrayOfCatchableTypes[];	// Image relative offset of Catchable Types
#else
	CatchableType	* __ptr64 arrayOfCatchableTypes[];
#endif
#else
	CatchableType	*arrayOfCatchableTypes[];
#endif
	} CatchableTypeArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_P7)	/*IFSTRIP=IGN*/
	__int32			pForwardCompat;		// Image relative offset of Forward compatibility frame handler
	__int32			pCatchableTypeArray;// Image relative offset of CatchableTypeArray
#else
	int	(__cdecl* __ptr64 pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	* __ptr64 pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
#else
	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
} ThrowInfo;
#endif // WANT_NO_TYPES

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#if defined(_M_IA64) || defined(_M_AMD64)
#define THROW_UNWINDFUNC_IB(t,ib)		((void (* __ptr64)(void* __ptr64))((ib) + (t).pmfnUnwind))
#define THROW_FORWARDCOMPAT_IB(t,ib)	((int(__cdecl * __ptr64)(...))((ib) + (t).pForwardCompat))
#define THROW_CTARRAY_IB(t,ib)			((CatchableTypeArray*)((ib) + (t).pCatchableTypeArray))
#define THROW_COUNT_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->nCatchableTypes)
#define THROW_CTLIST_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->arrayOfCatchableTypes)
#else
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#endif
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#ifndef WANT_NO_TYPES
extern "C" int __cdecl __CxxExceptionFilter(void*, void*, int, void *);

// Returns true if the object is really a C++ exception
// If it is, stores the previous exception in *storage, and saves the current one
// This is needed to keep track of the current exception object (used for rethrow & destruction)
extern "C" int __cdecl __CxxRegisterExceptionObject(void *exception, void *storage);

// Returns true if exception is a C++ rethrown exception
// This is needed, so Unregister can know whether or not to destroy the object
extern "C" int __cdecl __CxxDetectRethrow(void *exception);

// Returns the byte count of stack space required to store the exception info
extern "C" int __cdecl __CxxQueryExceptionSize(void);

// Pops the current exception, restoring the previous one from *storage
// This detects whether or not the exception object needs to be destroyed
extern "C" void __cdecl __CxxUnregisterExceptionObject(void *storage, int rethrow);

#endif // WANT_NO_TYPES

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index


//
// HandlerType - description of a single 'catch'
//

#ifndef WANT_NO_TYPES
typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
	__int32			dispType;			// Image relative offset of the corresponding type descriptor
	__int32			dispCatchObj;		// Displacement of catch object from base
	__int32			dispOfHandler;		// Image relative offset of 'catch' code
#if defined(_M_AMD64)
    __int32         dispFrame;          // displacement of address of function frame wrt establisher frame
#endif
#else
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
#if defined(_M_ALPHA64)
	__int32			dispCatchObj;		// Displacement of catch object from base
#else
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
#endif
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
#endif
} HandlerType;
#endif

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)
#define HT_IsComplusEh      0x80000000      // Is handling within complus eh.

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#define HT_PTD_IB(ht,ib)		((TypeDescriptor*)((ib) + (ht).dispType))
#define HT_HANDLER_IB(ht,ib)	((void* __ptr64)((ib) + (ht).dispOfHandler))
#else
#define HT_PTD(ht)				((ht).pType)
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#endif
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)
#define SET_HT_ISCOMPLUSEH(ht)  (HT_ADJECTIVES(ht) |= HT_IsComplusEh)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)
#define HT_ISCOMPLUSEH(ht)      (HT_ADJECTIVES(ht) & HT_IsComplusEh)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		dispHandlerArray;	// Image relative offset of list of handlers for this try
#else
	HandlerType *pHandlerArray;		// List of handlers for this try
#endif
} TryBlockMapEntry;
#endif // WANT_NO_TYPES

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
#define TBME_PLIST(hm,ib)	((HandlerType*)((ib) + (hm).dispHandlerArray))
#define TBME_CATCH(hm,n,ib)	(TBME_PLIST(hm,ib)[n])
#define TBME_PCATCH(hm,n,ib)(&(TBME_PLIST(hm,ib)[n]))
#else
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32			action;				// Image relative offset of funclet
#else
	void			(*action)(void);	// Funclet to call to effect state change
#endif
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UWE_ACTION_IB(uwe,ib)	((void (*__ptr64)(void))((ib) + (uwe).action))
#else
#define UWE_ACTION(uwe)			((uwe).action)
#endif

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		Ip;		// Image relative offset of IP
#else
	ULONG		Ip;
#endif
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

// bbtFlags values
#define BBT_UNIQUE_FUNCINFO 1

#ifndef WANT_NO_TYPES
typedef const struct _s_FuncInfo
{
    unsigned int		magicNumber:29;		// Identifies version of compiler
    unsigned int        bbtFlags:3;         // flags that may be set by BBT processing
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
#if defined(_M_IA64) || defined (_M_AMD64)	/*IFSTRIP=IGN*/
	__int32				dispUnwindMap;		// Image relative offset of the unwind map
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	__int32				dispTryBlockMap;	// Image relative offset of the handler map
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
	__int32				dispIPtoStateMap;	// Image relative offset of the IP to state map
	__int32				dispUwindHelp;		// Displacement of unwind helpers from base
#else
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;		// An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
#endif
} FuncInfo;
#endif // WANT_NO_TYPES

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#if defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_PUNWINDMAP(fi,ib)	((UnwindMapEntry*)((ib) + (fi).dispUnwindMap))
#define FUNC_PHANDLERMAP(fi,ib)	((TryBlockMapEntry*)((ib) + (fi).dispTryBlockMap))
#define FUNC_IPMAP(fi,ib)		((IptoStateMapEntry*)((ib) + (fi).dispIPtoStateMap))
#define FUNC_UNWIND(fi,st,ib)	(FUNC_PUNWINDMAP(fi,ib)[st])
#define FUNC_PUNWIND(fi,st,ib)	(&FUNC_UNWIND(fi,st,ib))
#define FUNC_TRYBLOCK(fi,n,ib)	(FUNC_PHANDLERMAP(fi,ib)[n])
#define FUNC_PTRYBLOCK(fi,n,ib)	(&FUNC_TRYBLOCK(fi,n,ib))
#else
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#endif
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_IPTOSTATE(fi,n,ib)	(FUNC_IPMAP(fi,ib)[n])
#define FUNC_PIPTOSTATE(fi,n,ib)(&FUNC_IPTOSTATE(fi,n,ib))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUwindHelp)
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_IA64) /*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _FRAME_POINTERS {
    __int64 MemoryStackFp;                     // memory stack frame pointer
    __int64 BackingStoreFp;                    // backing store frame pointer
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _UNWIND_INFO {
    unsigned __int16 Version;                  // Version Number
    unsigned __int16 Flags;                    // Flags
    unsigned __int32 DataLength;               // Length of Descriptor Data
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions


//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef FRAME_POINTERS EHRegistrationNode;

#elif defined(_M_AMD64)/*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef union _UNWIND_CODE {
    struct {
        unsigned char CodeOffset;
        unsigned char UnwindOp : 4;
        unsigned char OpInfo : 4;
    };
    unsigned short FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;
typedef struct _UNWIND_INFO {
    unsigned char Version : 3;                 // Version Number
    unsigned char Flags   : 5;                 // Flags
    unsigned char SizeOfProlog;
    unsigned char CountOfCodes;
    unsigned FrameRegister : 4;
    unsigned FrameOffset   : 4;
    UNWIND_CODE UnwindCode[1];
/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes+1)&~1)-1];
 *  union {
 *      OPTIONAL ULONG ExceptionHandler;
 *      OPTIONAL ULONG FunctionEntry;
 *  };
 *  OPTIONAL ULONG ExceptionData[];
 */
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif


typedef struct _xDISPATCHER_CONTEXT {
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;
    ULONG64 TargetIp;
    PCONTEXT ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(push, EHContext, 8)
#endif

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG_PTR BeginAddress;
    ULONG_PTR EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG_PTR PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG_PTR ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;
#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, EHContext)
#endif

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#else
#error "Machine not supported"
#endif

/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//
#if defined(_M_IA64) || defined(_M_ALPHA64)	|| defined(_M_AMD64) /*IFSTRIP=IGN*/
#pragma pack(push, ExceptionRecord, 8)
#endif
#ifndef WANT_NO_TYPES
typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
#if defined(_M_IA64) || defined(_M_AMD64)
		void		*pThrowImageBase;	// Image base of thrown object
#endif
		} params;
} EHExceptionRecord;
#endif // WANT_NO_TYPES
#if defined(_M_IA64) || defined(_M_ALPHA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, ExceptionRecord)
#endif

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#if defined(_M_IA64) || defined(_M_AMD64)
#define PER_PTHROWIB(per)	((per)->params.pThrowImageBase)
#endif
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))

/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_IA64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     unsigned __int64 *TargetGp
    );
#elif defined(_M_AMD64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
RtlUnwind2 (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

RtlUnwindEx (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord,
    IN void *HistoryTable
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     void             *HistoryTable
    );
#endif

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#endif /* ONLY_VALUES */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\instrapi.h ===
// Dolphin Performance Team Instrumentation API

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

typedef char* SZ;
typedef void* LOG;
typedef enum {
	letypeMin,
	letypeBegin = letypeMin,
	letypeEnd,
	letypeEvent,
	letypeMax
} LETYPE; // type of log event

#ifdef __cplusplus
#define C_LINKAGE extern "C"
#else
#define C_LINKAGE
#endif

#ifndef DLLSPEC
#if defined(_X86_) || defined(_MIPS_)
#ifdef __INSTRAPI_DLL__
#define DLLSPEC __declspec(dllexport)
#else
#define DLLSPEC __declspec(dllimport)
#endif
#else
#define DLLSPEC
#endif
#endif

C_LINKAGE LOG DLLSPEC _cdecl LogOpen(void);
// Open a log.  Returns 0 upon failure.  If failure, do not issue diagnostics;
// logging is simply disabled.

C_LINKAGE void DLLSPEC _cdecl LogNoteEvent(LOG log, SZ szComponent, SZ szSubComponent,
							LETYPE letype, SZ szMiscFmt, ...);
// Note some event to the log.  log may be 0, in which case nothing happens.
// szComponent, szSubComponent, letype, and szMisc describe the component,
// subcomponent, log event type, and miscellaneous description of the event
// as described above (all lowercase, please).  Note that if any of the sz*
// parameters are 0, reasonable defaults will be supplied.
//
// Note that szMiscFmt is a sprintf format string and can be followed by
// additional arguments as necessary.  It is not necessary to add a newline,
// however.

C_LINKAGE void DLLSPEC _cdecl LogClose(LOG log);
// Close the log.  log may be 0, in which case nothing happens.

// (Failure strategy: we never assert, but upon errors may silently disable
// logging.)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\macimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    macimage.h

IMAGE_SYM_CLASS_FAR_EXTERNAL

Abstract:

    This is the include file that describes all mac-specific image info

Author:

    Bill Joyce (billjoy)  Oct 1992

Revision History:

--*/

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef _MACIMAGE_
#define _MACIMAGE_

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(push, 2)
#else
#pragma pack(2)
#endif

#define IMAGE_FILE_MACHINE_M68K 0x268

// Macintosh relocation types
#define IMAGE_REL_M68K_DTOD16        0   // 16-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC16        1   // 16-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOD32        2   // 32-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC32        3   // 32-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOABSD32     4   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_DTOABSC32     5   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_CTOD16        6   // 16-bit code-to-data reference
#define IMAGE_REL_M68K_CTOC16        7   // 16-bit code-to-code reference
#define IMAGE_REL_M68K_CTOT16        8   // 16-bit code-to-thunk reference
#define IMAGE_REL_M68K_CTOD32        9   // 32-bit code-to-data reference
#define IMAGE_REL_M68K_CTOABSD32     10  // 32-bit code-to-absolute data reference
#define IMAGE_REL_M68K_CTOABSC32     11  // 32-bit code-to-absolute code reference
#define IMAGE_REL_M68K_CTOABST32     12  // 32-bit code-to-absolute thunk reference

#define IMAGE_REL_M68K_MACPROF32     19  // Profiler-specific relocation
#define IMAGE_REL_M68K_PCODETOC32    20  // 32-bit PCode-to-code reference
#define IMAGE_REL_M68K_CTOCS16       21  // 16-bit code space data-to-code reference
#define IMAGE_REL_M68K_CTOABSCS32    22  // 32-bit code space data-to-absolute code reference
#define IMAGE_REL_M68K_CV            23  // Direct 32-bit reference to the symbols virtual address, base not included

#define IMAGE_REL_M68K_DTOU16        25  // 16-bit data-to-unknown
#define IMAGE_REL_M68K_DTOU32        26  // 32-bit data-to-unknown
#define IMAGE_REL_M68K_DTOABSU32     27  // 32-bit data-to-unknown absolute
#define IMAGE_REL_M68K_CTOU16        28  // 16-bit code-to-unknown
#define IMAGE_REL_M68K_CTOABSU32     29  // 32-bit code-to-unknown absolute
#define IMAGE_REL_M68K_DIFF8         30  // Computed 8-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF16        31  // Computed 16-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF32        32  // Computed 32-bit difference between two symbols

#define IMAGE_REL_M68K_CSECTABLEB16       35  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEW16       36  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLEL16       37  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_CSECTABLEBABS32    38  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEWABS32    39  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLELABS32    40  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_DUPCON16           41  // Duplicate the contributor where this symbol is defined and put it in this PE section
#define IMAGE_REL_M68K_DUPCONABS32        42  // Duplicate the contributor where this symbol is defined and put it in this PE section

#define IMAGE_REL_M68K_PCODESN16          45  // Write the section number of the code where the fixup occurs
#define IMAGE_REL_M68K_PCODETOD24         46  // 24-bit code-to-data ref
#define IMAGE_REL_M68K_PCODETOT24         47  // 24-bit code-to-thunk ref
#define IMAGE_REL_M68K_PCODETOCS24        48  // 24-bit code-to-codespacedata ref
#define IMAGE_REL_M68K_PCODENEPE16        49  // 16-bit NEP elimination fixup
#define IMAGE_REL_M68K_PCODETONATIVE32    50  // 32-bit PCode-to-native reference

// MacProf constants
#define MACPROF_MAX_SECTIONS         2047  
#define MACPROF_CBITSINOFF             21
#define MACPROF_SN_MASK        0xFFE00000  // 11 bits for sn (up to 2047 sections)
#define MACPROF_OFF_MASK       0x001FFFFF  // 21 bits for offset (shifted right once to support sections up to 4 Meg)

// Data section header
typedef struct {
    unsigned long cbNearbss;   // size of near uninitialized data
    unsigned long cbNeardata;  // size of near initialized data
    unsigned long cbFarbss;    // size of near uninitialized data
    unsigned long cbFardata;   // size of near initialized data
} DATASECHDR;


// .resmap structure used by MRC to map resources to their type and ID
typedef struct {
    LONG typRes;                // resource type ("CODE", "DATA", etc)
    short iRes;                 // resource index
} RRM;                          // Raw to Resource Map

#define szsecRESMAP ".resmap"
#define szsecJTABLE ".jtable"
#define szsecDFIX   ".dfix"
#define szsecMSCV   ".mscv"
#define szsecSWAP   ".swap"
#define szsecFARBSS ".farbss"

#if 0 // These are defined in ntimage.h and are only included for reference.

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

#endif // 0

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.

// MAC section header flags
#define IMAGE_SCN_MEM_PROTECTED              0x00004000  
#define IMAGE_SCN_MEM_FARDATA                0x00008000  
#define IMAGE_SCN_MEM_SYSHEAP                0x00010000  
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000  
#define IMAGE_SCN_MEM_LOCKED                 0x00040000  
#define IMAGE_SCN_MEM_PRELOAD                0x00080000  

// MAC symbol class
// undefine for new win32 headers #define IMAGE_SYM_CLASS_FAR_EXTERNAL		 68
// Now defined in winnt.h

// Misc Symbol Types
// pcode flag currently used only for mac, but can be used easily by anyone
#define IMAGE_SYM_TYPE_PCODE            0x8000

// Data section masks
#define BSS_MASK      (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define DATA_MASK     (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define NBSS          IMAGE_SCN_CNT_UNINITIALIZED_DATA 
#define NDATA         IMAGE_SCN_CNT_INITIALIZED_DATA   
#define FBSS          (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define FDATA         (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define BSS_OR_DATA_MASK (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA)

// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE	0x40		// fd_Attr1
#define	FINDER_FLAG_SET			0x01		// fd_Attr1
#define FINDER_FLAG_BNDL		0x20		// ditto

#define FINDER_INFO_SIZE			32
typedef struct {
	unsigned char	fd_Type[4];
	unsigned char	fd_Creator[4];
	unsigned char	fd_Attr1;			// Bits 8-15
	unsigned char	fd_Attr2;			// Bits 0-7
	unsigned char	fd_Location[4];
	unsigned char	fd_FDWindow[2];
	unsigned char	fd_OtherStuff[16];
	} FINDERINFO, *PFINDERINFO;


// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	unsigned char pd_FileType[2];
	unsigned char pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
typedef struct _AfpInfo {
	unsigned long		afpi_Signature;			// Signature
	long				afpi_Version;			// Version
	unsigned long		afpi_Id;				// AFP File or directory Id
	unsigned long		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO  afpi_ProDosInfo;		// ProDos Info (6 bytes)

	unsigned short		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	unsigned char		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	unsigned char		afpi_AccessGroup;		// Directories only
	unsigned char		afpi_AccessWorld;
	} AFPINFO, *PAFPINFO;

#define AFP_SERVER_SIGNATURE		(*(unsigned long *)"AFP")
#define	AFP_SERVER_VERSION			0x00010000
#define	BEGINNING_OF_TIME 			0x80000000

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(pAfpInfo,AfpId,IsDir)	\
	memset(pAfpInfo,0,sizeof(AFPINFO)); \
	(pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE; \
	(pAfpInfo)->afpi_Version = AFP_SERVER_VERSION; \
	(pAfpInfo)->afpi_BackupTime = BEGINNING_OF_TIME; \
	(pAfpInfo)->afpi_Id = AfpId; \
	(pAfpInfo)->afpi_Attributes = 0; \
	if (IsDir) \
	{ \
		(pAfpInfo)->afpi_AccessOwner = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessGroup = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	} \
	else \
	{ \
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(pop)
#else
#pragma pack()
#endif

#endif // _MACIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\getmsg.h ===
// getmsg.h

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __GETMSG_H__
#define __GETMSG_H__

#ifdef  __cplusplus
extern "C" {
#endif

char *get_err(int);
const wchar_t *get_errW(int);
long SetHInstace(long hInstModule);

#ifdef  __cplusplus
}
#endif

#endif __GETMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\migrate.h ===
/* 
   Migrate.h
  
   The contain of this file should eventually get merged into the NT hearder
   files.

   Copyright (C) 1997, Microsoft Corp.  All Rights Reserved.
*/

//
// Type values for COR methods
//

#define IMAGE_SYM_TYPE_NEW             0x0010  // cor_new
#define IMAGE_SYM_TYPE_INSTANCEOF      0x0020  // cor_instanceof
#define IMAGE_SYM_TYPE_VIRTUAL         0x0030  // cor_virtual
#define IMAGE_SYM_TYPE_METHOD          0x0040  // cor_[static, special, newnew]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\nowin.h ===
/***
*nowin.h -
*
*	Copyright (c) 1996, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for non-Windows platforms that would
*       normally be declared in windows.h
*
*Revision History:
*       04-25-96  PNT	Module Created.
*
****/

#if !defined(_NOWIN_INCLUDED)
#define _NOWIN_INCLUDED

typedef unsigned int            UINT;
typedef long                    LONG;
typedef unsigned long           ULONG;
typedef ULONG                   *PULONG;
typedef unsigned short          USHORT;
typedef USHORT                  *PUSHORT;
typedef char                    CHAR;
typedef CHAR                    *PCHAR;
typedef unsigned char           UCHAR;
typedef UCHAR                   *PUCHAR;
typedef char                    *PSZ;
typedef unsigned char           BYTE;
typedef unsigned short          WORD;
typedef unsigned long           DWORD;
typedef int                     BOOL;
typedef unsigned char           BOOLEAN;
typedef BOOLEAN                 *PBOOLEAN;
typedef void                    VOID;
typedef VOID                    *PVOID;

#define FALSE	                0
#define TRUE	                1

#define IN
#define OUT
#define OPTIONAL

#define FAR
#define WINAPI
typedef int                     (FAR WINAPI *FARPROC)();

typedef ULONG                   NTSTATUS;

#ifndef NOMINMAX

#ifndef max
#define max(a, b)               (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a, b)               (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */

// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

//
// Exception record definition.
//

#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters

typedef struct _EXCEPTION_RECORD {
    /*lint -e18 */  // Don't complain about different definitions
    LONG ExceptionCode;
    /*lint +e18 */  // Resume checking for different definitions
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

#if defined(_M_MPPC)
//
// Context Frame
//
//  N.B. This frame must be exactly a multiple of 16 bytes in length.
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  3) it is used to construct a call frame for exception dispatching
//  in user mode, and 4) it is used in the user level thread creation
//  routines.
//
//  Requires at least 8-byte alignment (double)
//

typedef struct _CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    double Fpr0;                        // Floating registers 0..31
    double Fpr1;
    double Fpr2;
    double Fpr3;
    double Fpr4;
    double Fpr5;
    double Fpr6;
    double Fpr7;
    double Fpr8;
    double Fpr9;
    double Fpr10;
    double Fpr11;
    double Fpr12;
    double Fpr13;
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    double Fpscr;                       // Floating point status/control reg

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //

    ULONG Gpr0;                         // General registers 0..31
    ULONG Gpr1;
    ULONG Gpr2;
    ULONG Gpr3;
    ULONG Gpr4;
    ULONG Gpr5;
    ULONG Gpr6;
    ULONG Gpr7;
    ULONG Gpr8;
    ULONG Gpr9;
    ULONG Gpr10;
    ULONG Gpr11;
    ULONG Gpr12;
    ULONG Gpr13;
    ULONG Gpr14;
    ULONG Gpr15;
    ULONG Gpr16;
    ULONG Gpr17;
    ULONG Gpr18;
    ULONG Gpr19;
    ULONG Gpr20;
    ULONG Gpr21;
    ULONG Gpr22;
    ULONG Gpr23;
    ULONG Gpr24;
    ULONG Gpr25;
    ULONG Gpr26;
    ULONG Gpr27;
    ULONG Gpr28;
    ULONG Gpr29;
    ULONG Gpr30;
    ULONG Gpr31;

    ULONG Cr;                           // Condition register
    ULONG Xer;                          // Fixed point exception register

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    ULONG Msr;                          // Machine status register
    ULONG Iar;                          // Instruction address register
    ULONG Lr;                           // Link register
    ULONG Ctr;                          // Count register

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;

    ULONG Fill[3];                      // Pad out to multiple of 16 bytes

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //
    ULONG Dr0;                          // Breakpoint Register 1
    ULONG Dr1;                          // Breakpoint Register 2
    ULONG Dr2;                          // Breakpoint Register 3
    ULONG Dr3;                          // Breakpoint Register 4
    ULONG Dr4;                          // Breakpoint Register 5
    ULONG Dr5;                          // Breakpoint Register 6
    ULONG Dr6;                          // Debug Status Register
    ULONG Dr7;                          // Debug Control Register

} CONTEXT, *PCONTEXT;

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    PULONG FloatingContext[32];
    PULONG FpscrContext;
    PULONG IntegerContext[32];
    PULONG CrContext;
    PULONG XerContext;
    PULONG MsrContext;
    PULONG IarContext;
    PULONG LrContext;
    PULONG CtrContext;
} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\ppcimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ppcimage.h

Abstract:

    This is the include file that describes ppc-specific image info

Author:

    James Stulz (v-james)  July 1993

Revision History:

--*/

#ifndef _PPCIMAGE_
#define _PPCIMAGE_

#define IMAGE_FILE_MACHINE_MPPC_601         0x601   // PowerPC 601.
#define IMAGE_FILE_MPPC_DLL                 0x4000

//
// Power Macintosh relocation types
//

#define IMAGE_REL_MPPC_DESCREL              0x0000
#define IMAGE_REL_MPPC_LCALL                0x0001
#define IMAGE_REL_MPPC_DATAREL              0x0002
#define IMAGE_REL_MPPC_JMPADDR              0x0003
#define IMAGE_REL_MPPC_CREATEDESCRREL       0x0004
#define IMAGE_REL_MPPC_DATADESCRREL         0x0005
#define IMAGE_REL_MPPC_TOCREL               0x0006
#define IMAGE_REL_MPPC_SECTION              0x000A
#define IMAGE_REL_MPPC_SECREL               0x000B
#define IMAGE_REL_MPPC_ADDR24               0x000C // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_MPPC_ADDR14               0x000D // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_MPPC_REL24                0x000E // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_MPPC_REL14                0x000F // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_MPPC_CV                   0x0013
#define IMAGE_REL_MPPC_TOCINDIRCALL         0x0022
#define IMAGE_REL_MPPC_TOCCALLREL           0x0025
#define IMAGE_REL_MPPC_PCODECALL            0x0028
#define IMAGE_REL_MPPC_PCODECALLTONATIVE    0x0029
#define IMAGE_REL_MPPC_PCODENEPE            0x002A

#endif // _PPCIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\mrengine.h ===
// Interface for minimum rebuild engine
//

#if !defined(_mrengine_h)
#define _mrengine_h

// get rid of baggage we don't need from windows.h
#define WIN32_LEAN_AND_MEAN
//#define NOGDI
#define NOUSER
#define NONLS

// include pdb, msf, and nameserver
#include <pdb.h>
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <limits.h>
#include <stddef.h>

//
// Get the calling conventions and declspec stuff out of the way
//
#if defined(_X86_) || defined(_M_IX86)
#define MRECALL         __stdcall
#else
#define MRECALL         __cdecl
#endif

#if defined(MR_ENGINE_STATIC)
#define MREAPI(rtype)       rtype MRECALL
#elif !defined(MR_ENGINE_IMPL)
#define MREAPI(rtype)       rtype __declspec(dllimport) MRECALL
#else
#define MREAPI(rtype)       rtype __declspec(dllexport) MRECALL
#endif

//
// Our C++ Interfaces
//
PdbInterface                   MREngine;
typedef PdbInterface MREngine  MREngine;
typedef MREngine *          PMREngine;

PdbInterface                   MREDrv;
typedef PdbInterface MREDrv    MREDrv;
typedef MREDrv *            PMREDrv;

PdbInterface                   MRECmp;
typedef PdbInterface MRECmp    MRECmp;
typedef MRECmp *            PMRECmp;

PdbInterface                   MREUtil;
typedef PdbInterface MREUtil   MREUtil;
typedef MREUtil *           PMREUtil;

PdbInterface                   MREFile;
typedef PdbInterface MREFile   MREFile;
typedef MREFile *           PMREFile;

PdbInterface                   MREBag;
typedef PdbInterface MREBag    MREBag;
typedef MREBag *            PMREBag;

PdbInterface                   MRELog;
typedef PdbInterface MRELog    MRELog;
typedef MRELog *            PMRELog;

//
// other interesting things
//
#if !defined(FALSE)
#define FALSE 0
#define TRUE 1
#endif

#if !defined(fFalse)
#define fFalse FALSE
#define fTrue TRUE
#endif

// compile time assert
#if !defined(CASSERT)
    #if defined(_DEBUG)
        #define CASSERT(x) extern char dummyAssert[ (x) ]
    #else
        #define CASSERT(x)
    #endif
#endif

typedef _TCHAR *            SZ;         // String
typedef const _TCHAR *      SZC;        // const String
typedef DWORD               _CB;

#pragma warning(disable:4200)

typedef struct DepData {
    size_t  cb;
    BYTE    rgb[];
    } DepData, *PDepData;

#pragma warning(default:4200)

#if _INTEGRAL_MAX_BITS >= 64
typedef unsigned __int64    QWORD;      // 64-bit unsigned int
#else
typedef ULARGE_INTEGER      QWORD;
#endif

typedef PDB *               PPDB;
typedef NameMap *           PNMP;

typedef enum DEPON {            // depends on bits
    deponName = 0,                  // nothing...requires a name
    deponVtshape = 0x1,             // depon virtual functions/bases
    deponShape = 0x2,               // depon size or offsets of class
    deponAll = -1,                  // pseudo deps, not stored, but union
                                    //  of all the above...
    } DEPON;

// file out-of-date structure/enumerations/flags
typedef enum YNM {  // Yes No Maybe
    ynmNo,
    ynmMaybe,
    ynmYes
    } YNM;
typedef struct SRCTARG *    PSRCTARG;
typedef struct SRCTARG {
    PSRCTARG    psrctargNext;
    BOOL        fCpp;
    SZC         szSrc;
    SZC         szTarg;
    SZC         szOptions;
    DWORD       dwWeightMaybe;
    } SRCTARG, **PPSRCTARG;

typedef struct CAList {     // Compile Action List
    PSRCTARG    pstDoCompile;
    PSRCTARG    pstMaybeCompile;
    PSRCTARG    pstDontCompile;
    PSRCTARG    pstDone;
    PSRCTARG    pstError;
    } CAList, *PCAList;

typedef enum TrgType {
    trgtypeObject,
    trgtypeSbr
    } TrgType;

// inline functions to manipulate lists of SRCTARGs
//
// Insert at a particular pst location, can be anywhere in the list
__inline PPSRCTARG
InsertSrcTarg ( PPSRCTARG ppstAt, PSRCTARG pst ) {
    pst->psrctargNext = *ppstAt;
    *ppstAt = pst;
    return &pst->psrctargNext;
    }

// Delete does a find on the pst then snips from the list
//
__inline void
DeleteSrcTarg ( PPSRCTARG ppstListHead, PSRCTARG pst ) {
    PPSRCTARG   ppstCur = ppstListHead;
    PPSRCTARG   ppstPrev = ppstCur;

    // find the matching pst
    while ( *ppstCur && *ppstCur != pst ) {
        ppstPrev = ppstCur;
        ppstCur = &(*ppstCur)->psrctargNext;
        }
    if ( *ppstCur ) {
        *ppstPrev = (*ppstCur)->psrctargNext;
        }
    }

// Delete a particular pst, given its pst and a pst whose psrctargNext
//  points to pst.
__inline void
DeleteSrcTargAt ( PSRCTARG pst, PPSRCTARG ppstPrev ) {
    *ppstPrev = pst->psrctargNext;
    }

// NextSrcTarg, so simple, no comment
//
__inline PSRCTARG
PstNext ( PSRCTARG pst ) {
    return pst ? pst->psrctargNext : 0;
    }

// Return the address of the last pst (a PPSRCTARG) in the list
//
__inline PPSRCTARG
PpstLast ( PPSRCTARG ppstHead ) {
    PSRCTARG    pst = *ppstHead;
    PPSRCTARG   ppstRet = ppstHead;

    while ( pst = PstNext ( pst ) ) {
        ppstRet = &pst->psrctargNext;
        }

    return ppstRet;
    }
//
// PDB api required by MRE.  Passed in in cases where the caller is using
// a wide bandwidth api to the PDB already.
//
typedef struct MreToPdb {
    PDB *       ppdb;           // the IDB file pdb api
    NameMap *   pnamemap;       // the namemap in the IDB
    TPI *       ptpi;           // the tpi in the PDB
    PDB *       ppdbPdbFile;    // the PDB file pdb api
    void *      pvReserved1;
    void *      pvReserved2;
    } MreToPdb, *PMreToPdb;

#if defined(__cplusplus)

// C++ bindings

// callback functions and datatypes for enumerating files and dependencies
enum EnumType { etSource, etDep };

enum ChgState { chgstUnknown, chgstClass, chgstRude };

// File Status Masks
enum FSM {
    fsmNil = 0,
    fsmOutOfDate = 0x1,
    fsmHasTarget = 0x2,
    fsmIsTarget = 0x4,
    fsmVisited = 0x8,
    fsmIgnoreDep = 0x10,
    fsmInclByPch = 0x20,
    fsmCreatesPch = 0x40,
    fsmUsesPch = 0x80,
    fsmFileType = 0x300,
    fsmIsPch = 0x400,
    fsmIsTlb = 0x800,
    fsmIsAssembly = 0x1000,
    fsmFileTypeMask = 0x1c00,
    fsmUnused = 0xe000,
    fsmIsetPch = 0xffff0000,
    };

// File Type so we can infer what to do with dependencies when compiler changes
// and what is valid to do when checking for dependencies.
enum FileType {
    ftC = 0,
    ftCpp = 1,
    ftPch = 2,
    ftOther = 3,
    };

// Include Type lets us know what type of file was included in the compiler
//
enum IncludeType {
    itText = 0,
    itTlb = 1,
    itAssembly = 2,
    };

union MREFT {           // MRE FileTime
    FILETIME    ft;
    QWORD       qwft;
    };

typedef unsigned long   BldId;
const BldId bldidMax = ULONG_MAX;

struct FILEINFO {
    NI      niFile;         // main index value
    union {
        DWORD   dwStatus;       // file status bits
        // These are mostly for reference during debugging, but are used.
        struct {
            unsigned    fOutOfDate      : 1;
            unsigned    fHasTarget      : 1;
            unsigned    fIsTarget       : 1;
            unsigned    fVisited        : 1;
            unsigned    fIgnoreDep      : 1;
            unsigned    fInclByPch      : 1;
            unsigned    fCreatesPch     : 1;
            unsigned    fUsesPch        : 1;
            unsigned    ftCompiland     : 2;
            unsigned    fIsPch          : 1;
            unsigned    ftInclude       : 3;
            unsigned    fUnused         : 2;
            unsigned    isetPch         : 16;
            };
        };
    MREFT   fiTime;         // time stamp
    QWORD   fiSize;         // file size
    NI      niOptions;      // option string (src only)
    NI      niRelated;      // for src, it is the target, for target, it is src
    BldId   bldid;          // tell when (wrt the pdb) last built (src only)
    NI      niRelated2;     // secondary related file, for pch creation.
    };

// make sure the sizes and offsets are what we expect, as well as 8byte alignment
CASSERT(offsetof(FILEINFO, fiTime) == sizeof(NI)+sizeof(DWORD));
CASSERT((sizeof(FILEINFO) & 0x7) == 0);

struct FILESUMMARYINFO {
    DWORD   cFileDeps;
    DWORD   cClasses;
    };
typedef FILESUMMARYINFO FSI;

struct EnumFile {
    SZC         szFileSrc;
    SZC         szFileTrg;
    FILEINFO    fiSrc;
    FILEINFO    fiTrg;
    FSI         fsiSrc;
    SZC         szOptions;
    void *      pvContext;
    };

struct EnumClass {
    NI          niClass;
    SZC         szClassName;
    DWORD       depon;
    DWORD       cMembersHit;
    DWORD       cMembersBits;
    TI          tiClass;
    void *      pvContext;
    };

// enumfile source (root) file callback
typedef BOOL (MRECALL * PfnFEFSrcCallBack) ( PMREUtil, EnumFile &, EnumType et =etSource );
// enumfile dep file callback
typedef BOOL (MRECALL * PfnFEFDepCallBack) ( PMREUtil, EnumFile &, EnumType et =etDep );
// enumfile all files callback
typedef BOOL (MRECALL * PfnFEFAllCallBack) ( PMREUtil, EnumFile & );
// enumclass callback
typedef BOOL (MRECALL * PfnFEClassCallBack) ( PMREUtil, EnumClass & );

// status (bytes, sizes, etc.)
struct StreamUtilization {
    DWORD   cbUsed;         // actually used by data we need
    DWORD   cbInternal;     // internal size (maps, sets)
    DWORD   cbExternal;     // external size (stream)

    StreamUtilization &
    operator += ( const StreamUtilization & su ) {
        cbUsed += su.cbUsed;
        cbInternal += su.cbInternal;
        cbExternal += su.cbExternal;
        return *this;
        }
    StreamUtilization
    operator + ( const StreamUtilization & su ) {
        StreamUtilization   suNew = *this;
        return suNew += su;
        }

    };

struct MreStats {
    DWORD               cSrcFiles;
    DWORD               cTrgFiles;
    DWORD               cDepFiles;
    DWORD               cClasses;
    DWORD               cBoringClasses;
    DWORD               cDedicatedStreams;
    size_t              cbFilesInNamemap;
    size_t              cbClassesInNamemap;
    StreamUtilization   suFileInfo;
    StreamUtilization   suClassInfo;
    StreamUtilization   suPerFileInfo;
    StreamUtilization   suTotal;
    };

PdbInterface MREDrv {  // compiler driver port
    // release this PdbInterface
    virtual BOOL        FRelease() pure;

    // expensive operation!  the driver will call this once per list of
    //  files to compile.
    virtual BOOL        FRefreshFileSysInfo() pure;

    // called by the driver after each successful compilation, this lets the
    //  mr engine know that a file was successfully compiled or not.
    virtual BOOL        FSuccessfulCompile (
                            BOOL    fOk,
                            SZC     szFileSrc,
                            SZC     szFileTarg
                            ) pure;

    // To check if a file is really out of date wrt our fine grained deps...
    virtual YNM         YnmFileOutOfDate ( SRCTARG & ) pure;

    // alternate way, batch the files up, will segregate files into the
    //  appropriate lists inside of the CAList structure.
    virtual BOOL        FFilesOutOfDate ( PCAList pst ) pure;

    // post pass for files we didn't actually compile, but may need to update
    virtual BOOL        FUpdateTargetFile ( SZC szTrg, TrgType ) pure;

    // one-time driver init function.  called once per driver invocation ONLY.
    virtual void        OneTimeInit() pure;
    };

PdbInterface MRECmp {  // compiler front end port
    // release this PdbInterface
    virtual BOOL        FRelease() pure;

    // this method is used to get things rolling on each compiland.
    virtual BOOL        FOpenCompiland (
                            OUT PMREFile * ppmrefile,
                            IN SZC szFileSrc,
                            IN SZC szFileTarg
                            ) pure;

    // after all is said and done with the compile, this needs to get called
    //  to do folding, propagation, and flattening, after the compiler
    //  has run successfully.
    virtual BOOL        FCloseCompiland ( PMREFile pmrefile, BOOL fCommit ) pure;

    // called when moving to an #include'ed file
    virtual BOOL        FPushFile (
                            OUT PMREFile * ppmrefile,
                            IN SZC szFile,
                            IN HANDLE hFile =INVALID_HANDLE_VALUE
                            ) pure;

    // called when leaving an #include'ed file.
    //  returns PMREFile of enclosing (previous) file.
    virtual PMREFile    PmrefilePopFile() pure;

    // save/restore the dependencies (at pch create/restore time).
    //  Call FStoreDepData with a pointer to a DepData structure with a valid
    //  size  (the _cb field needs to be included).  The smallest possible
    //  DepBlob size is sizeof(CB).  A good size to start with is probably 8K.
    //  This call will fill in the actual size of the data so the
    //  block of memory can be trimmed back if you like.  Likewise, if the
    //  block is not big enough, this will return false with the size needed
    //  filled into the DepData.  If that size is 0, then there is no DepData
    //  to store.
    virtual BOOL        FStoreDepData ( PDepData ) pure;
    virtual BOOL        FRestoreDepData ( PDepData ) pure;

    // tell me a class in not interesting to store deps for (not changing much?)
    virtual void        ClassIsBoring ( NI niClass ) pure;

    };

PdbInterface MREUtil { // utility port, stats, enumerations, etc.
    // release this PdbInterface
    virtual BOOL        FRelease() pure;

    // support for offline tools to dump and otherwise peruse the
    //  mregine storage
    virtual void        EnumSrcFiles (
                            PfnFEFSrcCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
    virtual void        EnumDepFiles ( EnumFile &, PfnFEFDepCallBack ) pure;
    virtual void        EnumAllFiles (
                            PfnFEFAllCallBack,
                            SZC szFileSrc = NULL,
                            void * pvContext = NULL
                            ) pure;
    virtual void        EnumClasses (
                            PfnFEClassCallBack,
                            SZC szFileSrc,
                            void * pvContext = NULL
                            ) pure;
    virtual void        SummaryStats ( MreStats & ) pure;

    };

// basically, we have a hierarchy: an MRE has MREFiles which in turn
//  have MREBags.
//
PdbInterface MREngine {
    // open methods by pdb * and pdb name
    static MREAPI(BOOL) FOpen (
        OUT PMREngine * ppmre,
        PPDB            ppdb,
        PNMP            pnmp,
        BOOL            fWrite,
        BOOL            fClosePdb = fFalse
        );
    static MREAPI(BOOL) FOpen (
        OUT PMREngine * ppmre,
        SZC             szPdb,
        EC &            ec,
        _TCHAR          szErr[ cbErrMax ],
        BOOL            fReproSig,
        BOOL            fWrite
        );
    static MREAPI(BOOL) FOpen (
        OUT PMREngine * ppmre,
        PMreToPdb       pmretopdb,
        BOOL            fWrite,
        BOOL            fClosePdb = fFalse
        );


    // remove all MRE related streams from the PDB.
    virtual BOOL        FDelete() pure;

    // close and optionally commit new data
    virtual BOOL        FClose ( BOOL fCommit ) pure;

    // get the pdb api we are using
    virtual void        QueryPdbApi ( PDB *& rppdb, NameMap *& rpnamemap ) pure;

    // get the MreLog api
    virtual void        QueryMreLog ( PMRELog & rpmrelog ) pure;

    // get the various PdbInterface ptrs
    virtual void        QueryMreDrv ( PMREDrv & rpmredrv ) pure;
    virtual void        QueryMreCmp ( PMRECmp & rpmrecmp, TPI * ) pure;
    virtual void        QueryMreUtil ( PMREUtil & rpmreutil ) pure;

    // commit the global portions (actually, just write the streams...
    // a PDB/MSF commit must happen as well)
    virtual BOOL        FCommit() pure;

    };

//
// ClassChanged enumeration types for MREFile PdbInterface
//
typedef BOOL (MREFile::* MfnNoteClassTI) ( NI, TI );
typedef BOOL (__cdecl * PfnEnumClassChange) ( NI, PMREFile, MfnNoteClassTI );

PdbInterface MREFile {

    // icc -> mr flags
    //
    // iccfClassMrEdit implies that the class has a change that is detectable
    //  via cv type info changes downstream from the icc.
    //
    // iccfClassRudeEdit implies that something changed in the class that
    //  is not detectable downstream via type info and that at the very least,
    //  any code dependent in any way on the class needs to be recompiled.
    //
    // iccfFileRudeEdit means that something in the header file is rude,
    //  either added, removed, or continuing to be rude.
    //
    // iccfMethodEdit means that a change to class::method needs to be
    //  generated and any code dependent on class::method compiled.
    //
    // iccfAllCodeCompiled is used to detect when all code in a compiland
    //  has been compiled or not.  the incrememtal compiler may skip functions,
    //  in which case, the MR will merge the previous class deps with the new
    //  class deps in order to not lose dependency information.
    enum {
        iccfClassRudeEdit = 0x1,
        iccfClassMrEdit = 0x2,
        iccfFileRudeEdit = 0x4,
        iccfMethodEdit = 0x8,
        iccfAllCodeCompiled = 0x20,
        iccfAnyRude = iccfClassRudeEdit | iccfFileRudeEdit,
        //
        // We also overload filetype information in this so the compiler
        // can inform us of the file type it has included/used, etc.
        //
        ftShift = 11,
        ftText = itText << ftShift,         // should be 0!  The default.
        ftTlb = itTlb << ftShift,           // should be 0x800,
        ftAssembly = itAssembly << ftShift, // should be 0x1000
        ftMask = 7 << ftShift,              // should be 0x3800
        };

    virtual BOOL        FOpenBag ( OUT PMREBag * ppmrebag, NI niNameBag ) pure;
    virtual BOOL        FnoteEndInclude ( DWORD dwFlags ) pure;
    virtual BOOL        FnoteClassMod ( NI niClass, DWORD dwFlags ) pure;
    virtual BOOL        FnoteInlineMethodMod (
                            NI      niClass,
                            SZC     szMember,
                            DWORD   dwFlags
                            ) pure;
    virtual BOOL        FnoteLineDelta ( DWORD dwLineBase, INT delta ) pure;
    virtual void        EnumerateChangedClasses ( PfnEnumClassChange ) pure;
    virtual BOOL        FnoteClassTI ( NI, TI ) pure;
    virtual BOOL        FIsBoring() pure;
    virtual BOOL        FnotePchCreateUse (
                            SZC szPchCreate,
                            SZC szPchUse
                            ) pure;
    };

PdbInterface MREBag {
    virtual BOOL        FAddDep (
                            NI      niDep,              // class name's NI
                            TI      tiDep,              // class type index
                            SZC     szMemberName,       // member name
                            DEPON   deponHow,           // how it depends on it
                            DWORD   dwLine =0           // where referenced
                            ) pure;
    virtual BOOL        FClose() pure;
    };

PdbInterface MRELog {
    virtual void        TranslateToText ( BOOL fClear, _TCHAR ** pptch ) pure ;
    virtual void        TranslateToText ( BOOL fClear, FILE * pfile ) pure;
    };


#endif  // __cpluscplus

#if defined(__cplusplus)
extern "C" {
#endif

// C interfaces for MRE
MREAPI(BOOL)        MREFOpenEx (
                        OUT PMREngine * ppmre,
                        PMreToPdb       pmretopdb,
                        BOOL            fWrite
                        );
MREAPI ( BOOL )     MREFOpen (
                        OUT PMREngine * ppmre,
                        PPDB            ppdb,
                        PNMP            pnmp,
                        BOOL            fWrite
                        );
MREAPI ( BOOL )     MREFOpenByName (
                        OUT PMREngine * ppmre,
                        SZC             szPdb,
                        EC *            pec,
                        _TCHAR          szErr[ cbErrMax ],
                        BOOL            fReproSig,
                        BOOL            fWrite
                        );
MREAPI ( BOOL )     MREFDelete ( PMREngine );
MREAPI ( BOOL )     MREFClose ( PMREngine, BOOL fCommit ) ;
MREAPI ( void )     MREQueryMreDrv ( PMREngine, OUT PMREDrv *);
MREAPI ( void )     MREQueryMreCmp ( PMREngine, OUT PMRECmp *, IN TPI * );
MREAPI ( void )     MREQueryMreUtil ( PMREngine, OUT PMREUtil * );

// C interfaces for MREDrv
MREAPI ( BOOL )     MREDrvFRelease ( PMREDrv );
MREAPI ( BOOL )     MREDrvFRefreshFileSysInfo ( PMREDrv );
MREAPI ( BOOL )     MREDrvFSuccessfulCompile (
                        PMREDrv,
                        BOOL fOk,
                        SZC szFileSrc,
                        SZC szFileTarg
                        );
#if !defined(NO_YNM)
MREAPI ( YNM )      MREDrvYnmFileOutOfDate ( PMREDrv, SRCTARG * );
#endif

MREAPI ( BOOL )     MREDrvFFilesOutOfDate ( PMREDrv, PCAList pCAList );
MREAPI ( BOOL )     MREDrvFUpdateTargetFile ( PMREDrv, SZC szTrg, TrgType );
MREAPI ( void )     MREDrvOneTimeInit ( PMREDrv );

// C PdbInterface for MRECmp
MREAPI ( BOOL )     MRECmpFRelease ( PMRECmp );
MREAPI ( BOOL )     MRECmpFOpenCompiland (
                        PMRECmp,
                        OUT PMREFile *  ppmrefile,
                        IN SZC          szFileSrc,
                        IN SZC          szFileTarg
                        );
MREAPI ( BOOL )     MRECmpFCloseCompiland ( PMRECmp, PMREFile, BOOL fCommit );
MREAPI ( BOOL )     MRECmpFPushFile (
                        PMRECmp,
                        OUT PMREFile *  ppmrefile,
                        IN SZC          szFile,
                        IN HANDLE       hfile
                        );
MREAPI ( PMREFile ) MRECmpPmrefilePopFile ( PMRECmp ) ;
MREAPI ( BOOL )     MRECmpFStoreDepData ( PMRECmp, PDepData );
MREAPI ( BOOL )     MRECmpFRestoreDepData ( PMRECmp, PDepData );
MREAPI ( void )     MRECmpClassIsBoring ( PMRECmp, NI );



// C interfaces for MREFile
MREAPI ( BOOL )     MREFileFOpenBag ( PMREFile, OUT PMREBag *, NI );

// C interfaces for MREBag
MREAPI ( BOOL )     MREBagFAddDep (
                        PMREBag,
                        NI niDep,
                        TI tiDep,
                        SZC szMemberName,
                        DEPON depon
                        );
MREAPI ( BOOL )     MREBagFClose ( PMREBag );

#if defined(__cplusplus)
}   // extern "C"
#endif

#endif  // _mrengine_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\sbrfdef.h ===
// sdbfdef.h    Source Browser .SBR file definitions

#define SBR_L_UNDEF         0       // Undefined         
#define SBR_L_BASIC         1       // Basic
#define SBR_L_C             2       // C
#define SBR_L_FORTRAN       3       // Fortran
#define SBR_L_MASM          4       // Macro
#define SBR_L_PASCAL        5       // Pascal
#define SBR_L_COBOL			6		// Cobol
#define SBR_L_CXX			7		// C++

#define SBR_REC_HEADER      0x00    // Header
#define SBR_REC_MODULE      0x01    // Module definition
#define SBR_REC_LINDEF      0x02    // Line Number
#define SBR_REC_SYMDEF      0x03    // Symbol Definition
#define SBR_REC_SYMREFUSE   0x04    // Symbol Reference
#define SBR_REC_SYMREFSET   0x05    // Symbol Ref assign
#define SBR_REC_MACROBEG    0x06    // Macro Start
#define SBR_REC_MACROEND    0x07    // Macro End
#define SBR_REC_BLKBEG      0x08    // Block Start
#define SBR_REC_BLKEND      0x09    // Block End
#define SBR_REC_MODEND      0x0A    // Module End
#define SBR_REC_OWNER		0x0B	// Scope Owner
#define SBR_REC_BASE		0x0C	// Define base class of owner
#define SBR_REC_FRIEND		0x0D	// Define friend of owner
#define SBR_REC_ABORT		0x0E	// Compiler aborted, .sbr file ended early
#define SBR_REC_PCHNAME		0x0F	// Precompiler header include
#define SBR_REC_PCHMARK		0x10	// Precompiler header highwater mark

//  psuedo records for internal use.

#define SBR_REC_ERROR       0x11    // error-record -- xlated to symdef
#define SBR_REC_MACROREF    0x12	// this space for rent
#define SBR_REC_MACRODEF    0x13	// this space for rent
#define SBR_REC_IGNORE      0x14    // abort condition discovered
									// after record already enqueued

// icc related records (these actually occur in .sbr files)

#define SBR_REC_LINDELTA	0x15	// 16 bit signed line number delta
#define SBR_REC_INFOSEP		0x16	// begins any ICC section + ends previous
#define SBR_REC_PATCHTAB	0x17	// introduces patch table entry
#define SBR_REC_PATCHTERM	0x18	// ends the patch table (includes cookie)
#define SBR_REC_SYMDECL		0x19	// used in fe internally for icc browse

#define SBR_COOKIE_ICC		0x4A525301	// cookie at EOF if ICC patch present

//
//  records which have extended keys (when the keys don't fit in 16 bits.)
//
#define SBR_REC_SYMDEF_X    (SBR_REC_SYMDEF | SBR_REC_EXTENDED_KEYS)	// Extended key symbol definition
#define SBR_REC_SYMREFUSE_X (SBR_REC_SYMREFUSE | SBR_REC_EXTENDED_KEYS)	// Extended key symbol reference
#define SBR_REC_SYMREFSET_X (SBR_REC_SYMREFSET | SBR_REC_EXTENDED_KEYS)	// Extended key symbol ref assign
#define SBR_REC_OWNER_X     (SBR_REC_OWNER | SBR_REC_EXTENDED_KEYS)		// Extended key scope owner
#define SBR_REC_BASE_X      (SBR_REC_BASE | SBR_REC_EXTENDED_KEYS)		// Extended key base class
#define SBR_REC_FRIEND_X	(SBR_REC_FRIEND | SBR_REC_EXTENDED_KEYS)	// Extended key friend of owner

#define SBR_REC_BUMP_N      0x20    // Bump the line number N+1 times

#define	SBR_REC_EXTENDED_KEYS		0x40	// the keys are bigger than 16 bits.

#define	SBR_REC_EXTENDED_MASK		(SBR_REC_EXTENDED_KEYS)	//  add more as required

#define	GetSbrRecType(v)			(v & (~ SBR_REC_EXTENDED_MASK ))

#define	SetSbrRecExtendedAttrib(v,a)	(v |= (a))
#define	ClrSbrRecExtendedAttrib(v,a)	(v &= ~(a))
#define	IsSetSbrRecExtendedAttrib(v,a)	(v & (a))

#define SBR_REC_NOCOLUMN    1       // Missing column default 1

#define SBR_TYP_FUNCTION    0x01
#define SBR_TYP_LABEL       0x02
#define SBR_TYP_PARAMETER   0x03
#define SBR_TYP_VARIABLE    0x04
#define SBR_TYP_CONSTANT    0x05
#define SBR_TYP_MACRO       0x06
#define SBR_TYP_TYPEDEF     0x07
#define SBR_TYP_STRUCNAM    0x08
#define SBR_TYP_ENUMNAM     0x09
#define SBR_TYP_ENUMMEM     0x0A
#define SBR_TYP_UNIONNAM    0x0B
#define SBR_TYP_SEGMENT	    0x0C
#define SBR_TYP_GROUP	    0x0D
#define SBR_TYP_PROGRAM	    0x0E
#define SBR_TYP_CLASSNAM    0x0F
#define SBR_TYP_MEMFUNC	    0x10
#define SBR_TYP_MEMVAR	    0x11
#define SBR_TYP_ERROR		0x12

#define SBR_ATR_LOCAL	    0x001
#define SBR_ATR_STATIC	    0x002
#define SBR_ATR_SHARED	    0x004
#define SBR_ATR_NEAR	    0x008
#define SBR_ATR_COMMON	    0x010
#define SBR_ATR_DECL		0x020
#define SBR_ATR_DECL_ONLY	0x020	// synonym for the above
#define SBR_ATR_PUBLIC      0x040
#define SBR_ATR_NAMED	    0x080
#define SBR_ATR_MODULE		0x100
#define SBR_ATR_VIRTUAL		0x200
#define SBR_ATR_PRIVATE		0x400
#define SBR_ATR_PROTECT		0x800

#define SBR_ITYP_VIRTUAL	0x01
#define SBR_ITYP_PRIVATE	0x02
#define SBR_ITYP_PUBLIC		0x04
#define SBR_ITYP_PROTECT	0x08

#define SBR_VER_MAJOR       2       // Major version
#define SBR_VER_MINOR       0       // Minor version

#define SBR_LIMIT_ID_LENGTH	256		// At the moment (12Apr94) bscmake can't take longer names
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\prodids.h ===
//
// define the product identifiers and tags used to identify
// which MS tool built any particular object file
//
#pragma once
#if !defined(_prodids_h)
#define _prodids_h

// define the product ids, encodes version + language

enum PRODID {
    prodidUnknown           = 0x0000,
    prodidImport0           = 0x0001,   // Linker generated import object version 0
    prodidLinker510         = 0x0002,   // LINK 5.10 (Visual Studio 97 SP3)
    prodidCvtomf510         = 0x0003,   // LINK 5.10 (Visual Studio 97 SP3) OMF to COFF conversion
    prodidLinker600         = 0x0004,   // LINK 6.00 (Visual Studio 98)
    prodidCvtomf600         = 0x0005,   // LINK 6.00 (Visual Studio 98) OMF to COFF conversion
    prodidCvtres500         = 0x0006,   // CVTRES 5.00
    prodidUtc11_Basic       = 0x0007,   // VB 5.0 native code
    prodidUtc11_C           = 0x0008,   // VC++ 5.0 C/C++
    prodidUtc12_Basic       = 0x0009,   // VB 6.0 native code
    prodidUtc12_C           = 0x000a,   // VC++ 6.0 C
    prodidUtc12_CPP         = 0x000b,   // VC++ 6.0 C++
    prodidAliasObj60        = 0x000c,   // ALIASOBJ.EXE (CRT Tool that builds OLDNAMES.LIB)
    prodidVisualBasic60     = 0x000d,   // VB 6.0 generated object
    prodidMasm613           = 0x000e,   // MASM 6.13
    prodidMasm701           = 0x000f,   // MASM 7.01
    prodidLinker511         = 0x0010,   // LINK 5.11
    prodidCvtomf511         = 0x0011,   // LINK 5.11 OMF to COFF conversion
    prodidMasm614           = 0x0012,   // MASM 6.14 (MMX2 support)
    prodidLinker512         = 0x0013,   // LINK 5.12
    prodidCvtomf512         = 0x0014,   // LINK 5.12 OMF to COFF conversion
    prodidUtc12_C_Std       = 0x0015,   // VC++ 6.0 C standard edition
    prodidUtc12_CPP_Std     = 0x0016,   // VC++ 6.0 C++ standard edition
    prodidUtc12_C_Book      = 0x0017,   // VC++ 6.0 C book edition
    prodidUtc12_CPP_Book    = 0x0018,   // VC++ 6.0 C++ book edition
    prodidImplib700         = 0x0019,   // LINK 7.00 Import library
    prodidCvtomf700         = 0x001a,   // LINK 7.00 OMF to COFF conversion
    prodidUtc13_Basic       = 0x001b,   // VB 7.0 native code
    prodidUtc13_C           = 0x001c,   // VC++ 7.0 C
    prodidUtc13_CPP         = 0x001d,   // VC++ 7.0 C++
    prodidLinker610         = 0x001e,   // LINK 6.10
    prodidCvtomf610         = 0x001f,   // LINK 6.10 OMF to COFF conversion
    prodidLinker601         = 0x0020,   // LINK 6.01
    prodidCvtomf601         = 0x0021,   // LINK 6.01 OMF to COFF conversion
    prodidUtc12_1_Basic     = 0x0022,   // VB 6.1 native code
    prodidUtc12_1_C         = 0x0023,   // VC++ 6.1 C
    prodidUtc12_1_CPP       = 0x0024,   // VC++ 6.1 C++
    prodidLinker620         = 0x0025,   // LINK 6.20
    prodidCvtomf620         = 0x0026,   // LINK 6.20 OMF to COFF conversion
    prodidAliasObj70        = 0x0027,   // ALIASOBJ.EXE (CRT Tool that builds OLDNAMES.LIB)
    prodidLinker621         = 0x0028,   // LINK 6.21
    prodidCvtomf621         = 0x0029,   // LINK 6.21 OMF to COFF conversion
    prodidMasm615           = 0x002a,   // MASM 6.15
    prodidUtc13_LTCG_C      = 0x002b,   // VC++ 7.0 C via LTCG
    prodidUtc13_LTCG_CPP    = 0x002c,   // VC++ 7.0 C++ via LTCG
    prodidMasm620           = 0x002d,   // MASM 6.20
    prodidILAsm100          = 0x002e,   // IL Assembler 1.00
    prodidUtc12_2_Basic     = 0x002f,   // VB 6.0 native code w/Processor Pack
    prodidUtc12_2_C         = 0x0030,   // VC++ 6.0 Processor Pack C
    prodidUtc12_2_CPP       = 0x0031,   // VC++ 6.0 Processor Pack C++
    prodidUtc12_2_C_Std     = 0x0032,   // VC++ 6.0 Processor Pack C standard edition
    prodidUtc12_2_CPP_Std   = 0x0033,   // VC++ 6.0 Processor Pack C++ standard edition
    prodidUtc12_2_C_Book    = 0x0034,   // VC++ 6.0 Processor Pack C book edition
    prodidUtc12_2_CPP_Book  = 0x0035,   // VC++ 6.0 Processor Pack C++ book edition
    prodidImplib622         = 0x0036,   // LINK 6.22 Import library
    prodidCvtomf622         = 0x0037,   // LINK 6.22 OMF to COFF conversion
    prodidCvtres501         = 0x0038,   // CVTRES 5.01
    prodidUtc13_C_Std       = 0x0039,   // VC++ 7.0 C standard edition
    prodidUtc13_CPP_Std     = 0x003a,   // VC++ 7.0 C++ standard edition
    prodidCvtpgd1300        = 0x003b,   // CVTPGD 13.00
    prodidLinker622         = 0x003c,   // LINK 6.22
    prodidLinker700         = 0x003d,   // LINK 7.00
    prodidExport622         = 0x003e,   // LINK 6.22 EXP file
    prodidExport700         = 0x003f,   // LINK 7.00 EXP file
    prodidMasm700           = 0x0040,   // MASM 7.00
    prodidUtc13_POGO_I_C    = 0x0041,   // VC++ 7.0 C via LTCG with POGO instrumentation
    prodidUtc13_POGO_I_CPP  = 0x0042,   // VC++ 7.0 C++ via LTCG with POGO instrumentation
    prodidUtc13_POGO_O_C    = 0x0043,   // VC++ 7.0 C via LTCG with POGO optimization
    prodidUtc13_POGO_O_CPP  = 0x0044,   // VC++ 7.0 C++ via LTCG with POGO optimization
    prodidCvtres700         = 0x0045,   // CVTRES 7.00
};

#define DwProdidFromProdidWBuild(prodid, wBuild) ((((unsigned long) (prodid)) << 16) | (wBuild))
#define ProdidFromDwProdid(dwProdid)             ((PRODID) ((dwProdid) >> 16))
#define WBuildFromDwProdid(dwProdid)             ((dwProdid) & 0xFFFF)


    // Symbol name and attributes in coff symbol table (requires windows.h)

#define symProdIdentName    "@comp.id"
#define symProdIdentClass   IMAGE_SYM_CLASS_STATIC
#define symProdIdentSection IMAGE_SYM_ABSOLUTE


    // Define the image data format

typedef struct PRODITEM {
    unsigned long   dwProdid;          // Product identity
    unsigned long   dwCount;           // Count of objects built with that product
} PRODITEM;


enum {
    tagEndID    = 0x536e6144,
    tagBegID    = 0x68636952,
};

/*
  Normally, the DOS header and PE header are contiguous.  We place some data
  in between them if we find at least one tagged object file.

  struct {
    IMAGE_DOS_HEADER dosHeader;
    BYTE             rgbDosStub[N];          // MS-DOS stub
    PRODITEM         { tagEndID, 0 };        // start of tallies (Masked with dwMask)
    PRODITEM         { 0, 0 };               // end of tallies   (Masked with dwMask)
    PRODITEM         rgproditem[];           // variable sized   (Masked with dwMask)
    PRODITEM         { tagBegID, dwMask };   // end of tallies
    PRODITEM         { 0, 0 };               // variable sized
    IMAGE_PE_HEADER  peHeader;
    };

*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\pogodb.h ===
// pogodb.h
//
// Pogo Data Base reading/writing interfaces

#if __cplusplus
extern "C" {
#endif

#include <pdb.h>


#pragma warning(push)

#pragma warning(disable: 4200)     // allow 0 sized array in struct/union
#pragma warning(disable: 4201)     // Allow nameless struct/union


#include <stddef.h>
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef unsigned __int64 QWORD;


// REVIEW: May want to typedef DWORD PGDSYMID;

#if !defined(POGODB_DLL_BUILD)

#define POGODLL __declspec(dllimport)

#else

#define POGODLL __declspec(dllexport)

#endif

#define POGODLLAPI(type) POGODLL type __stdcall


#if defined(_M_ALPHA)

#define POGODB_MACHINE IMAGE_FILE_MACHINE_ALPHA

#elif defined(_M_IX86)

#define POGODB_MACHINE IMAGE_FILE_MACHINE_I386

#elif defined(_M_IA64)

#define POGODB_MACHINE IMAGE_FILE_MACHINE_IA64

#else

#error Unsupported host platform

#endif


// Database sig/ver defines.

#define POGODB_HEADER_SIGNATURE 0x4F474F50
#define POGODB_HEADER_VERSION   0x00000020


// Pogo database operating modes.  These control access to various APIs and
// such.

typedef enum {
    POGODB_TOOL_READ,     // for Pogo profile data tools
    POGODB_TOOL_WRITE,
    POGODB_COMPILER_READ, // VC++ compiler
    POGODB_COMPILER_WRITE,
    POGODB_OVERRIDE_READ, // for non-Pogo override info tools
    POGODB_OVERRIDE_WRITE,
    POGODB_LINKER_READ,   // VC++ linker
    POGODB_LINKER_WRITE
} POGODB_MODE;


// Enumeration of profile streams (must be in sync with names in pogodb.cpp)
// Don't forget to add per-module streams to PogoDbOpenStream and
// PogoDbSetModule.

typedef enum {
    PGDS_HEADER = 0,
    PGDS_HISTORY,
    PGDS_OBJECT_INFO,
    PGDS_LINK_INFO,
    PGDS_SYMBOL_TABLE,
    PGDS_PROBE_ID,
    PGDS_ENTRY,
    PGDS_MODULE,
    PGDS_FUNCTIONS,
    PGDS_PROBE_INFO,
    PGDS_PROBE_DATA,
    PGDS_VALUE_DATA,
    PGDS_MDS_DATA,
    PGDS_FLOW_GRAPH,
    PGDS_CALL_GRAPH,
    PGDS_BRANCH_INFO,
    PGDS_OVERRIDE_INFO,
    PGDS_FUNC_HASH,
    PGDS_TOB_DATA,
    PGDS_VCALL_TABLE,
    PGDS_MAX
} POGODB_STREAM;
extern POGODLL const char * const PogoDbStreamNames[];

// Enumeration of error codes.

typedef enum {
    PGDE_OK = 0,
    PGDE_ERROR, // generic error
    PGDE_NOT_FOUND, // file not found
    PGDE_SHARING_VIOLATION, // sharing violation (opened for write elsewhere)
    PGDE_PDB_ERROR, // PDB error not explicitly handled
    PGDE_SIGNATURE_MISMATCH,
    PGDE_VERSION_MISMATCH,
    PGDE_READ_ONLY,
    PGDE_LTCG_MISMATCH,   // PGD is LTCG and compile isn't or vice-versa
    PGDE_OUT_OF_MEMORY,
    PGDE_BAD_PARAMETER,
    PGDE_NO_DATA, // no data of the requested type
    PGDE_PGD_NOT_OPEN,
    PGDE_MODULE_NOT_OPEN,
    PGDE_FUNCTION_NOT_OPEN,
    PGDE_MISSING_STREAM,
    PGDE_INVALID_STREAM = PGDE_MISSING_STREAM + PGDS_MAX,
    PGDE_REPLACE_ERROR = PGDE_INVALID_STREAM + PGDS_MAX,
    PGDE_WRITE_ERROR = PGDE_REPLACE_ERROR + PGDS_MAX,
    PGDE_APPEND_ERROR = PGDE_WRITE_ERROR + PGDS_MAX,
    PGDE_STREAM_NOT_OPEN = PGDE_APPEND_ERROR + PGDS_MAX,
    PGDE_MAX = PGDE_STREAM_NOT_OPEN + PGDS_MAX
} POGODB_ERROR;


typedef enum {
    PGDH_CLEAR=0, PGDH_ADD, PGDH_SUB, PGDH_COMP, PGDH_OPT,
    PGDH_MAX
} POGODB_HISTORY_TYPE;
extern POGODLL const char * const PogoDbHistoryType[];


struct tagPGDHEADER                 // POGO Database Header
{
    DWORD Signature;              // Magic number
    DWORD Version;                // Database version

    // !!! Do not add any members above this comment !!!
    
    DWORD Id;                     // "Unique" identified for this database
    DWORD Machine;                // Machine that generated the PGD
    DWORD HeaderFlags;            // flags
    LONG  numEntryProbe;          // Count of function entry probe handles
    LONG  numSimpleProbe;         // Count of simple probe handles
    LONG  numValueProbe;          // Count of special value probe handles
    DWORD fBigEndian;             // true if created on big-endian machine
    LONG  OffsetNextSymItem;      // Offset to next Symbol table record
    LONG  OffsetEntryProbeList;   // Offset to list of avail entry probe ids
    LONG  OffsetSimpleProbeList;  // Offset to list of avail simple probe ids
    LONG  OffsetValueProbeList;   // Offset to list of avail value probe ids
    LONG  OffsetFreeProbeList;    // Offset to list of unused probe blocks
    LONG  numModules;             // Count of number modules (files) compiled
    LONG  numFunctions;           // Count of functions in all modules
    QWORD ModTime;                // Time of last update
    QWORD HotRegionThreshold;     // Dyn instr count for a region to be hot
    DWORD dwTOB;                  // Last valid TOB DWORD
};
typedef struct tagPGDHEADER PGDHEADER, *PPGDHEADER;

// Pogo DB Header flags
#define POGODB_HF_LTCG               0x80000000
#define POGODB_HF_OVERRIDE_ONLY      0x40000000

struct tagPGDHISTORYRECORD {
    QWORD  ModTime;                // Time of last update
    QWORD  MergeFileTime;          // Time stamp from idf file
    POGODB_HISTORY_TYPE  HistoryType;
    char PathName[0];
};
typedef struct tagPGDHISTORYRECORD PGDHISTORYRECORD, *PPGDHISTORYRECORD;


struct tagPGDOBJECTRECORD {
    union {
        const char *szObjName; // for clients
        NI nameIndex;    // persisted
    };
    QWORD ObjectTime;
    QWORD FileTime;
};
typedef struct tagPGDOBJECTRECORD PGDOBJECTRECORD, *PPGDOBJECTRECORD;


struct tagPGDSYMFLAGS {
    DWORD ModuleId:20;      // module where symbol is defined
    DWORD unused:9;         //
    DWORD fCalleeSaved:1;   // 1 => force all registers to be callee saved
    DWORD SymbolType:2;     // see below for definition
};
typedef struct tagPGDSYMFLAGS PGDSYMFLAGS;

// Pogo Symtab Flags (PSF)
#define PSF_MODULEID         0x000FFFFF
#define PSF_unused           0x1FF00000
#define PSF_CALLEESAVED      0x20000000
#define PSF_SYMBOLTYPE       0xC0000000
#define PSF_GLOBALINLINE     0x40000000
#define PSF_LOCAL            0x80000000
#define PSF_MODULE           0xC0000000

// WARNING: there is code that assumes OffsetNextHash is the first field
struct tagPGDSYMTABRECORD      {
    LONG OffsetNextHash;  // offset to next item with same hash value
    LONG OffsetNextSym;   // offset to next item with same symbol value
    NI   NameIndex;       // symbol name index
    union {
        DWORD SymbolFlagsWord;
        PGDSYMFLAGS SymbolFlags;
    };
};
typedef struct tagPGDSYMTABRECORD PGDSYMTABRECORD, *PPGDSYMTABRECORD;


// forward pointer definitions needed for MODULERECORD
typedef struct tagPGDVALUECOUNTRECORD *PPGDVALUECOUNT;
typedef struct tagPGDVALUEDATARECORD  *PPGDVALUEPROBEDATA;
typedef struct tagPGDCALLGRAPHNODE    *PPGDCALLGRAPHNODE;


struct tagPGDMODULERECORD {
    DWORD SymbolId;          // Offset to Symtab record
    WORD  numFunctions;      // Count of functions in module
    WORD  numBaseDataSets;   // Count of data sets in module(before pogoopt)
    LONG  numSimpleProbe;    // Count of simple probe handles
    LONG  numValueProbe;     // Count of special value probe handles
    LONG  OffsetCallGraph;   // Offset to call graph in graph stream
    DWORD Checksum;          // Call graph checksum for source edit checking
};
typedef struct tagPGDMODULERECORD PGDMODULERECORD, *PPGDMODULERECORD;


struct tagPGDOPTFLAGS {
    WORD fOptOt:1;               // 1 => -Ot, 0 => -Os
    WORD fInline:1;              // 1 => inline into caller (should be just 1)
    WORD unused:14;              // available for expansion
};
typedef struct tagPGDOPTFLAGS PGDOPTFLAGS;


// WARNING: there is code that assumes OffsetNextHash is the first field
struct tagPGDFUNCHASHRECORD   {
    LONG OffsetNextHash;   // offset to next item with same hash value
    LONG SymbolId;         // function symbol ID
    LONG OffsetFuncData;   // offset to function data in func data stream
};
typedef struct tagPGDFUNCHASHRECORD PGDFUNCHASHRECORD, *PPGDFUNCHASHRECORD;


struct tagPGDFUNCRECORD {
    DWORD LineNumberBase;         // Starting line number for this function
    DWORD EntryProbeId;           // Entry probe id for this func

    WORD  numSimpleProbe;         // Number of logical simple probe handles
    WORD  MaxSimpleProbe;         // Max number of simple probe handles

    WORD  numValueProbe;          // Count of value probe handles
    WORD  MaxValueProbe;          // Max number of value probe handles

    WORD  numBranchRecords;       //
    WORD  numDataSetRecords;      // 0 if !MDS, also 0 if none seen

    struct {
        WORD fMDS    : 1;       // MDS function
        WORD _unused : 15;
    };
    union {
        WORD optFlagsWord;
        PGDOPTFLAGS optFlags;
    };

    WORD  LinkOrderIndex;         // Opt: link order

    LONG  OffsetOverride;         // Offset into Override stream
    LONG  OffsetBranch;           // Offset into Branch stream
    LONG  OffsetProbeInfo;        // Offset into ProbeInfo stream
    LONG  OffsetProbeData;        // Offset into ProbeData stream
    LONG  OffsetTOBData;          // Offset into TOB stream

    LONG  DataSetIndex;           // Index into DataSet stream (0 if !MDS)

    LONG  SymbolId;               // Offset to Symtab record

    DWORD Checksum;               // Checksum for source edit determination

    WORD  numPhysSimpleProbe;     // Number of physical simple probes
                                  // (doesn't count duplicates)
};
typedef struct tagPGDFUNCRECORD PGDFUNCRECORD, *PPGDFUNCRECORD;

struct tagPGDFUNCOVERRIDE {
    DWORD fOptOt:1;               // 1 => -Ot, 0 => -Os
    DWORD fUnused:31;
    DWORD mask; // valid fields
};
typedef struct tagPGDFUNCOVERRIDE PGDFUNCOVERRIDE, *PPGDFUNCOVERRIDE;

#define PFO_OPTOT 0x00000001


// Pogo Probe Flags (PPF)

// Common to all types

#define PPF_VALUE                0x80000000

// Simple flags

#define PPF_DUPLICATE            0x40000000
#define PPF_CALL                 0x20000000

// Value flags

#define PPF_TEMPLATED            0x40000000


// !!!WARNING!!!
// there is code that relies on sizeof(SIMPLEPROBE) == sizeof(VALUEPROBE)
// UNDONE: we need a compile time assert to that fact (markro)

struct tagPGDSIMPLEPROBERECORD {
    WORD LineNumber;     // line number of probe relative to current function
    WORD ProbeId;        // probe index relative to current function
    union {
        DWORD  ProbeField;
        // NOTE: Experiments with Excel showed a probe count of only 19-20
        //       total bits.  Hence, it should be extremely safe to use the
        //       highest 3 bits for flags.
        struct {
            DWORD ProbeOffset:29; // probe index relative to entire database
            DWORD fCall:1;        // 1 => probe is for a CALL
            DWORD fDup:1;         // 1 => probe has a duplicate ProbeOffset
            DWORD fValueProbe:1;  // 0 => simple probe
        };
    };
};
typedef struct tagPGDSIMPLEPROBERECORD PGDSIMPLEPROBE, *PPGDSIMPLEPROBE;

// Value probe type enumeration.

typedef enum {
    POGODB_VPT_NONE = 0, POGODB_VPT_LINEAR_SWITCH, POGODB_VPT_JUMP_SWITCH,
    POGODB_VPT_BINARY_SWITCH, POGODB_VPT_DEAD,
    POGODB_VPT_DIV, POGODB_VPT_REM, POGODB_VPT_DIVREM, POGODB_VPT_MUL,
    POGODB_VPT_CALL,
    POGODB_VPT_MAX
} POGODB_VPT_ENUM;
extern POGODLL const char * const PogoDbValueProbeTypeNames[];

struct tagPGDVALUEPROBERECORD {
    WORD LineNumber;     // line number of probe relative to current function
    WORD ProbeId;        // probe index relative to current function
    union {
        DWORD  ProbeField;
        // NOTE: Experiments with Excel showed a probe count of only 19-20
        //       total bits.  Hence, it should be extremely safe to use the
        //       highest 6 bits for other fields.
        // NOTE2: Currently probe offsets come from single pool so the
        // valid range is actually min(simple,value).  If we were to allocate
        // value probes first, we could get away with differing offset field
        // sizes, but that doesn't seem important given the above NOTE was
        // based on all plain probes, not the more common MDS scenario.
        struct {
            DWORD ProbeOffset:26; // probe index relative to entire database
            DWORD Type:4;         // switch/value probe type
            DWORD fTemplated:1;   // 1 => templated value probe
            DWORD fValueProbe:1;  // 1 => value probe
        };
    };
};
typedef struct tagPGDVALUEPROBERECORD PGDVALUEPROBE, *PPGDVALUEPROBE;

// !!!WARNING!!!
// there is code that relies on sizeof(SIMPLECOUNT) == sizeof(VALUECOUNT)
// UNDONE: we need a compile time assert to that fact (markro)

struct tagPGDSIMPLECOUNTRECORD {
    QWORD  ProbeCount;      // execution count collected when program runs
};
typedef struct tagPGDSIMPLECOUNTRECORD PGDSIMPLECOUNT, *PPGDSIMPLECOUNT;

struct tagPGDVALUECOUNTRECORD {
    union {
        LONG  NumDataValues;  // count of selection records
        struct {
            DWORD NDVDummy:31;  //
            DWORD fTmpPointer:1;// whether ValueDataIndex is offset or pointer
        };
    };
    LONG ValueDataIndex;  // index into module value data stream
};
typedef struct tagPGDVALUECOUNTRECORD PGDVALUECOUNT, *PPGDVALUECOUNT;

struct tagPGDVALUEDATARECORD  {
    DWORD SelectionValue;  // case value for this item
    DWORD Unused;          // (because of QWORD alignment requirement)
// ISSUE: if space becomes a problem, we could make this a DWORD? (markro)
    QWORD ProbeCount;      // execution count collected when program runs
};
typedef struct tagPGDVALUEDATARECORD PGDVALUEPROBEDATA, *PPGDVALUEPROBEDATA;

struct tagPGDENTRYRECORD {
    WORD  numSimpleProbe;  // Count of simple probe handles
    WORD  numValueProbe;   // Count of special value probe handles
    DWORD pEntryData;      // This field is used by POGO runtime
};
typedef struct tagPGDENTRYRECORD PGDENTRYRECORD, *PPGDENTRYRECORD;

struct tagPGDPROBERANGERECORD  {
    LONG LowValue;        // low end of free probe values
    LONG HighValue;       // high end of free probe values
    LONG OffsetNext;      // offset to next probe range record
                            // -1 => end of list
};
typedef struct tagPGDPROBERANGERECORD PGDPROBERANGERECORD, *PPGDPROBERANGERECORD;

struct tagPGDDATASETRECORD {
    union {
        DWORD DataSetField;   //
        struct {
            DWORD pathVal:30;     // indentifies source of data (0 if !MDS)
            DWORD fInline:1;      // should inline at call site?
            DWORD fSynthesized:1; // created by pogoopt?
        };
    };
    LONG   OffsetProbeData; // offset into probe data stream
    LONG   OffsetTOBData;   // offset into TOB stream
};
typedef struct tagPGDDATASETRECORD PGDDATASET, *PPGDDATASET;

struct tagPGDBRANCHRECORD {
    WORD BranchId;               // branch index relative to current function
    WORD Type : 4;               // branch type
    WORD SubNumber : 4;          // branch number relative to statement
    WORD Status : 4;             // branch status
    WORD LoopTest : 1;           // branch is loop test
    WORD unused : 3;             //
};
typedef struct tagPGDBRANCHRECORD PGDBRANCHRECORD, *PPGDBRANCHRECORD;


typedef enum {
    POGODB_FG_COND = 0, POGODB_FG_UNCOND, POGODB_FG_SWITCH, POGODB_FG_USWITCH,
    POGODB_FG_RETURN, POGODB_FG_FALL_THROUGH, POGODB_FG_DUMMY,
    POGODB_FG_MAX
} POGODB_FG_ENUM;
extern POGODLL const char * const PogoDbFGNodeType[];


// Note: these structures do not appear in the compiler (although, one could
// argue they should to hide the DB encoding).  They are currently only
// populated by pogodb.c for use by the dumpers.  All these DWORD are really
// WORD on disk, but no point in memory.

struct tagPGDFGSWITCHDATA {
    DWORD val;
    DWORD target;
};
typedef struct tagPGDFGSWITCHDATA PGDFGSWITCHDATA, *PPGDFGSWITCHDATA;

struct tagPGDFGCALLDATA {
    DWORD num;
    DWORD index;
    DWORD id;
    DWORD indirValueId;
};
typedef struct tagPGDFGCALLDATA PGDFGCALLDATA, *PPGDFGCALLDATA;

struct tagPGDFLOWGRAPHNODE {
    DWORD blockNum;
    DWORD startLine, endLine;
    DWORD numInstrs, numCalls, numIndirectCalls;
    DWORD fFoldableCmp : 1;
    DWORD fUnused : 31;
    POGODB_FG_ENUM type;
    DWORD blockTarget;

    union {
        struct {
            DWORD condNum;
            DWORD condSubNum;
            DWORD condType;
            DWORD condStatus;
        };
        struct {
            DWORD switchNum;
            DWORD switchCount;
            PPGDFGSWITCHDATA pSwitchData;
        };
    };
    PPGDFGCALLDATA pCallData;
};
typedef struct tagPGDFLOWGRAPHNODE PGDFLOWGRAPHNODE, *PPGDFLOWGRAPHNODE;


struct tagPGDFLOWGRAPHINFO {
    DWORD prologInstrs;
    DWORD epilogInstrs;
};
typedef struct tagPGDFLOWGRAPHINFO PGDFLOWGRAPHINFO, *PPGDFLOWGRAPHINFO;

struct tagPGDFOLDEDCMP {
    DWORD num;
    DWORD subNum; // -1 == switch
};
typedef struct tagPGDFOLDEDCMP PGDFOLDEDCMP, *PPGDFOLDEDCMP;

#define PGDFC_SWITCH_SUBNUM -1

struct tagPGDINLINESAVINGS {
    DWORD foldedSize;
    DWORD numFoldedCmps;
    PGDFOLDEDCMP foldedCmps[]; // array of size numFoldedCmps
};
typedef struct tagPGDINLINESAVINGS PGDINLINESAVINGS, *PPGDINLINESAVINGS;

struct tagPGDCALLGRAPHCALLEE {
    DWORD num;
    DWORD callSiteNum;
    DWORD pathInc;
    PPGDINLINESAVINGS pInlSavings;
};
typedef struct tagPGDCALLGRAPHCALLEE PGDCALLGRAPHCALLEE, *PPGDCALLGRAPHCALLEE;

struct tagPGDCALLGRAPHNODE {
    DWORD id;
    DWORD flags;
    DWORD numCallees;
    DWORD startPathValOpt;
    DWORD startPathValInst;
    DWORD overheadSize;
    PPGDCALLGRAPHCALLEE callees;
};
typedef struct tagPGDCALLGRAPHNODE PGDCALLGRAPHNODE, *PPGDCALLGRAPHNODE;

#define PGDCGNF_PATHPROFILE 0x01
#define PGDCGNF_REDIRECTOR  0x02


// This record is a copy of MLE from merge.h in the bbt tree.  There are a
// couple of unused fields for POGO.

struct tagPGDMERGERECORD {
   QWORD    qwStartTime;           // Instrumentation start time
   DWORD    dwWeight;              // Weight (relative importance)
   DWORD    iSequenceEndBoot;      // Sequence number of the last boot time code or resource
   DWORD    iIntervalEndBoot;      // Last time interval of boot
   BOOL     fSubtract;             // True if subtracting this merge
};
typedef struct tagPGDMERGERECORD PGDMERGERECORD, *PPGDMERGERECORD;


// This is not a database record, but is shared by the compiler and runtime
// so this is the best place to define it.

struct tagPOGOVALUETEMPLATE {
    DWORD   probeOffset;           // probe offset (must be first!)
                                   // this is a runtime convenience to avoid
                                   // passing both the template pointer and
                                   // probe offset to the probe thunks
    WORD    numCases;              // number of cases in template
    struct {
        WORD fSixtyFourBits:1;     // Size of values: 0 = 32, 1 = 64
        WORD fSigned:1;            // Signed or unsigned
        WORD fUnused:14;
    };
    void *data;                    // numCases * 32/64 ...
};
typedef struct tagPOGOVALUETEMPLATE POGOVALUETEMPLATE, *PPOGOVALUETEMPLATE;


// External representation.

struct tagPGDTOBCHUNK {
    DWORD    firstInterval;          // time interval of bit 0
    DWORD    bits;                   // bits for intervals firstInterval..+31
};
typedef struct tagPGDTOBCHUNK PGDTOBCHUNK, *PPGDTOBCHUNK;

struct tagPGDTOBVECTOR {
    unsigned len;                    // number of chunks in bit vector
    PPGDTOBCHUNK pChunks;           // array of chunks
};
typedef struct tagPGDTOBVECTOR PGDTOBVECTOR, *PPGDTOBVECTOR;

// Internal representation.

struct tagPGDTOBDATA {
    PGDTOBCHUNK chunk;
    LONG offsetNext;            // offset to next TOB
};
typedef struct tagPGDTOBDATA PGDTOBDATA, *PPGDTOBDATA;


extern POGODLLAPI(POGODB_ERROR) PogoDbGetLastError(void);
extern POGODLLAPI(const char *) PogoDbGetErrorText(POGODB_ERROR error);
extern POGODLLAPI(BOOL) PogoDbFormatTime(const QWORD *time, char *buffer);
extern POGODLLAPI(const char *) PogoDbGetMachineName(DWORD idMachine);
extern POGODLLAPI(DWORD) PogoDbGetMachineId(const char *szName);
extern POGODLLAPI(BOOL) PogoDbGenerateModuleName(const char *PGDName, const char *OBJName, char *moduleName, size_t bufLen);

extern POGODLLAPI(BOOL) PogoDbOpen(const char *name, POGODB_MODE mode, BOOL fLTCG);
extern POGODLLAPI(BOOL) PogoDbClose(void);

extern POGODLLAPI(void *) PogoDbReadStream(POGODB_STREAM stream, LONG *cb);
extern POGODLLAPI(BOOL) PogoDbStreamQueryCb(POGODB_STREAM stream, LONG *cb);
extern POGODLLAPI(BOOL) PogoDbStreamTruncate(POGODB_STREAM stream, LONG cb);
extern POGODLLAPI(BOOL) PogoDbStreamReplace(POGODB_STREAM stream, void *pData, LONG cb);
extern POGODLLAPI(BOOL) PogoDbStreamWrite(POGODB_STREAM stream, DWORD offset, void *pData, LONG cb);
extern POGODLLAPI(BOOL) PogoDbStreamAppend(POGODB_STREAM stream, void *pData, LONG cb);
extern POGODLLAPI(PPGDHEADER) PogoDbReadHeader(void);
extern POGODLLAPI(PPGDHISTORYRECORD) PogoDbReadHistory(PPGDHISTORYRECORD pHistory);
extern POGODLLAPI(PPGDMODULERECORD) PogoDbReadModule(PPGDMODULERECORD pMod);

extern POGODLLAPI(PPGDMODULERECORD) PogoDbGetLogicalModule(void);
extern POGODLLAPI(PPGDSYMTABRECORD) PogoDbGetSymtabRecord(LONG offset);
extern POGODLLAPI(const char *) PogoDbGetSymbol(LONG id);
extern POGODLLAPI(DWORD) PogoDbLookupSymbol(const char *pSym);
extern POGODLLAPI(BOOL) PogoDbModifiedSymbolTable(void);
extern POGODLLAPI(DWORD) PogoDbLookupNextId(DWORD id, DWORD FlagsMask, DWORD FlagsValue);
extern POGODLLAPI(DWORD) PogoDbLookupId(const char *pSym, DWORD FlagsMask, DWORD FlagsValue);

extern POGODLLAPI(BOOL) PogoDbWriteObjectInfoStart(void);
extern POGODLLAPI(BOOL) PogoDbWriteObjectInfo(const char *szObjectName, QWORD ObjectTime, QWORD FileTime);
extern POGODLLAPI(BOOL) PogoDbWriteObjectInfoEnd(void);
extern POGODLLAPI(PPGDOBJECTRECORD) PogoDbReadObjectInfo(PPGDOBJECTRECORD pObj);

extern POGODLLAPI(BOOL) PogoDbWriteLinkInfo(struct LinkInfo *pLinkInfo);
extern POGODLLAPI(BOOL) PogoDbReadLinkInfo(struct LinkInfo **ppLinkInfo);

extern POGODLLAPI(BOOL) PogoDbOpenModule(PPGDMODULERECORD pMod);
extern POGODLLAPI(BOOL) PogoDbWriteModuleChecksum(DWORD checksum);
extern POGODLLAPI(DWORD) PogoDbReadModuleChecksum(void);
extern POGODLLAPI(const char *) PogoDbGetModuleName(void);
extern POGODLLAPI(void) PogoDbCloseModule(void);

extern POGODLLAPI(BOOL) PogoDbLocateFunctionRecord(DWORD id, PPGDFUNCRECORD *pFunc);
extern POGODLLAPI(BOOL) PogoDbSetFunction(const char *funcName, DWORD symFlags);
extern POGODLLAPI(PPGDFUNCRECORD) PogoDbReadFunction(PPGDFUNCRECORD pFunc);
extern POGODLLAPI(BOOL) PogoDbOpenFunction(PPGDFUNCRECORD pFunc);
extern POGODLLAPI(const char *) PogoDbGetFunctionName(void);
extern POGODLLAPI(PPGDENTRYRECORD) PogoDbReadFunctionEntry(void);
extern POGODLLAPI(DWORD) PogoDbReadFunctionChecksum(PPGDFUNCRECORD pFunc);
extern POGODLLAPI(BOOL) PogoDbReadFunctionOverride(PPGDFUNCOVERRIDE pOverride);
extern POGODLLAPI(BOOL) PogoDbWriteFunctionOverride(PPGDFUNCOVERRIDE pOverride);
extern POGODLLAPI(void) PogoDbCloseFunction(void);

extern POGODLLAPI(BOOL) PogoDbModifiedFunctionData(void);
extern POGODLLAPI(BOOL) PogoDbModifiedDataSets(void);

extern POGODLLAPI(PPGDSIMPLEPROBE) PogoDbReadSimpleProbe(PPGDSIMPLEPROBE pSimple, PPGDSIMPLECOUNT *ppSimpleCount, DWORD offset);
extern POGODLLAPI(PPGDSIMPLEPROBE) PogoDbReadSimpleProbeEx(PPGDSIMPLEPROBE pSimple, PPGDSIMPLECOUNT *ppSimpleCount, PPGDFUNCRECORD pFunc, DWORD offset);
extern POGODLLAPI(PPGDVALUEPROBE) PogoDbReadValueProbe(PPGDVALUEPROBE pValue, PPGDVALUECOUNT *ppValueCount, DWORD offset);
extern POGODLLAPI(PPGDVALUEPROBE) PogoDbReadValueProbeEx(PPGDVALUEPROBE pValue, PPGDVALUECOUNT *ppValueCount, PPGDFUNCRECORD pFunc, DWORD offset);
extern POGODLLAPI(PPGDVALUEPROBEDATA) PogoDbReadValueProbeData(PPGDVALUEPROBEDATA pValueData, PPGDVALUECOUNT pValueCount);
extern POGODLLAPI(PPGDTOBVECTOR) PogoDbReadTOBVector(LONG offset);

extern POGODLLAPI(PPGDDATASET) PogoDbReadDataSet(PPGDDATASET pMDS);
extern POGODLLAPI(PPGDDATASET) PogoDbReadDataSetEx(PPGDDATASET pMDS, PPGDFUNCRECORD pFunc);
extern POGODLLAPI(BOOL) PogoDbLocateDataSet(DWORD CallPathId);
extern POGODLLAPI(PPGDBRANCHRECORD) PogoDbReadBranchData(PPGDBRANCHRECORD pBranch);
extern POGODLLAPI(PPGDBRANCHRECORD) PogoDbReadBranchDataEx(PPGDBRANCHRECORD pBranch, PPGDFUNCRECORD pFunc);
extern POGODLLAPI(PPGDFLOWGRAPHNODE) PogoDbReadFlowGraph(PPGDFLOWGRAPHNODE pFG);
extern POGODLLAPI(PPGDFLOWGRAPHINFO) PogoDbReadFlowGraphInfo(void);

extern POGODLLAPI(BOOL) PogoDbOpenCallGraph(DWORD *numNodes);
extern POGODLLAPI(PPGDCALLGRAPHNODE) PogoDbReadCallGraphNode(PPGDCALLGRAPHNODE pLast);
extern POGODLLAPI(DWORD) PogoDbGetCallGraphNodeSym(DWORD iNode);
extern POGODLLAPI(PPGDCALLGRAPHCALLEE) PogoDbReadCallGraphCallee(PPGDCALLGRAPHCALLEE pLast, PPGDCALLGRAPHNODE pNode);
extern POGODLLAPI(void) PogoDbCloseCallGraph(void);

extern POGODLLAPI(BOOL) PogoDbUpdateHistory(POGODB_HISTORY_TYPE type, QWORD MergeFileTime, const char *name);

extern POGODLLAPI(BOOL) PogoDbStartNewFunction(void);
extern POGODLLAPI(BOOL) PogoDbWriteFunctionChecksum(DWORD checksum);

extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphStart(void);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphNode(DWORD blkNum, DWORD startLineOffset, DWORD endLineOffset, DWORD instrs, DWORD calls, DWORD indirectCalls);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphSwitch(DWORD id, BOOL fSigned, DWORD defaultTarget, DWORD cases, BOOL fFoldable);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphSwitchData(DWORD val, DWORD target);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphCond(DWORD num, DWORD subNum, DWORD type, DWORD status, DWORD target, BOOL fFoldable);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphUncond(DWORD target);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphReturn(void);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphFallThrough(void);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphDummy(void);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphCall(DWORD num, DWORD index, DWORD id, DWORD indirValueId);
extern POGODLLAPI(BOOL) PogoDbWriteFlowGraphEnd(DWORD prologInstrs, DWORD epilogInstrs);

extern POGODLLAPI(BOOL) PogoDbWriteBranchInfoStart(void);
extern POGODLLAPI(BOOL) PogoDbWriteBranchInfo(DWORD Id, DWORD Type, DWORD subnumber, DWORD Status, BOOL LoopTest);
extern POGODLLAPI(BOOL) PogoDbWriteBranchInfoEnd(void);

extern POGODLLAPI(void) PogoDbInitOffsetAllocation(BOOL fMDS);
extern POGODLLAPI(DWORD) PogoDbValueProbeOffset(void);
extern POGODLLAPI(BOOL) PogoDbWriteProbeInfoStart(void);
extern POGODLLAPI(BOOL) PogoDbWriteSimpleProbeInfo(DWORD lineOffset, DWORD id, DWORD offset, DWORD flags);
extern POGODLLAPI(BOOL) PogoDbWriteValueProbeInfo(DWORD lineOffset, DWORD id, DWORD offset, DWORD type, DWORD flags);
extern POGODLLAPI(BOOL) PogoDbWriteProbeInfoEnd(void);

extern POGODLLAPI(BOOL) PogoDbWriteCallGraphStart(DWORD nodes);
extern POGODLLAPI(BOOL) PogoDbWriteCallGraphNode(DWORD id, DWORD flags, DWORD startPathValOpt, DWORD startPathValInst, DWORD callees, DWORD overheadSize);
extern POGODLLAPI(BOOL) PogoDbWriteCallGraphCallee(DWORD num, DWORD index, DWORD pathInc);
extern POGODLLAPI(BOOL) PogoDbWriteCallGraphCalleeInlineSavings(DWORD foldedSize, DWORD numFoldedCmps);
extern POGODLLAPI(BOOL) PogoDbWriteCallGraphCalleeFoldedCmp(DWORD id, DWORD subNum);
extern POGODLLAPI(BOOL) PogoDbWriteCallGraphEnd(void);

extern POGODLLAPI(DWORD) PogoDbAllocEntryProbeId(void);
extern POGODLLAPI(DWORD) PogoDbAllocSimpleProbeId(void);
extern POGODLLAPI(DWORD) PogoDbAllocValueProbeId(void);

extern POGODLLAPI(DWORD) PogoDbLookupFunctionRef(const char *szFuncName, BOOL fLocalRef, DWORD SymFlags);
extern POGODLLAPI(BOOL) PogoDbSetModule(const char *moduleName);
extern POGODLLAPI(BOOL) PogoDbSetLogicalModule(PPGDMODULERECORD pModule);
extern POGODLLAPI(BOOL) PogoDbSetLogicalModuleFromName(const char *moduleName);
extern POGODLLAPI(PPGDHEADER) PogoDbCreateGlobalStreams(const char *pdbName);
extern POGODLLAPI(BOOL) PogoDbReadGlobalStreams(void);
extern POGODLLAPI(BOOL) PogoDbWriteFunctionInfo(DWORD LineNumberBase, DWORD MaxSimpleProbe, DWORD MaxValueProbe, DWORD EntryProbeId, const char *szFuncName, DWORD SymFlags, BOOL fMDS);
extern POGODLLAPI(BOOL) PogoDbFinishFunction(void);

extern POGODLLAPI(DWORD) PogoDbGetSymbolHashPrime(void);
extern POGODLLAPI(DWORD) PogoDbGetFuncHashPrime(void);

extern POGODLLAPI(BOOL) PogoDbWriteVCallTarget(DWORD id);
extern POGODLLAPI(BOOL) PogoDbReadVCallTargets(DWORD **pTable, DWORD *num);


#pragma warning(pop)

#if __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\objectfile.h ===
//-----------------------------------------------------------------------------
//	ObjectFile.h
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  Purpose:
//		Define the classes for reading and groking object files
//
//  Revision History:
//
//	[]		10-Feb-1997 Dans	Created
//
//-----------------------------------------------------------------------------
#pragma once

#if !defined(_objectfile_h)
#define _objectfile_h 1

#include "crefobj.h"
#include "ref.h"
//#include "buffer.h"
#include "simparray.h"

#if defined(MSOBJ_LIBRARY)
#define IMPORT_EXPORT
#else
#if !defined(OBJECTFILE_IMPL)
#define IMPORT_EXPORT   __declspec(dllimport)
#else
#define IMPORT_EXPORT   __declspec(dllexport)
#endif
#endif

typedef BYTE *                  PB;
typedef const PB                PCB;

namespace objf {

    typedef IMAGE_ARCHIVE_MEMBER_HEADER ImgArchMbrHdr;
    typedef ImgArchMbrHdr *         PImgArchMbrHdr;
    typedef const ImgArchMbrHdr *   PCImgArchMbrHdr;

    typedef IMAGE_FILE_HEADER       ImgFileHdr;
    typedef ImgFileHdr UNALIGNED *  PImgFileHdr;
    typedef const ImgFileHdr UNALIGNED *
                                    PCImgFileHdr;

    typedef IMAGE_SECTION_HEADER    ImgSectHdr;
    typedef ImgSectHdr UNALIGNED *  PImgSectHdr;
    typedef const ImgSectHdr UNALIGNED *
                                    PCImgSectHdr;

    typedef IMAGE_RELOCATION        ImgReloc;
    typedef PIMAGE_RELOCATION       PImgReloc;
    typedef const ImgReloc UNALIGNED *
                                    PCImgReloc;

    typedef IMAGE_LINENUMBER        ImgLineNo;
    typedef PIMAGE_LINENUMBER       PImgLineNo;

    typedef IMAGE_SYMBOL            ImgSym;
    typedef PIMAGE_SYMBOL           PImgSym;
    typedef const ImgSym UNALIGNED *
                                    PCImgSym;

    typedef IMAGE_AUX_SYMBOL        ImgAuxSym;
    typedef PIMAGE_AUX_SYMBOL       PImgAuxSym;
    typedef const ImgAuxSym UNALIGNED *
                                    PCImgAuxSym;

    // symbol index (not COFF symbol index)
    typedef DWORD                   SYMI;
    const SYMI                      symiNil = 0;

    // coff symbol table index
    typedef DWORD                   COFFSYMI;
    const COFFSYMI                  coffsymiNil = COFFSYMI(-1);


    // munged info for fixups.  
    struct FixupMap {
        DWORD   off;    // offset of fixup (in the section)
        DWORD   cb;     // how many bytes the fixup consumes in the data
        };

    typedef SimpleArray<BYTE>       RGBYTE;
    typedef SimpleArray<FixupMap>   RGFIXUPMAP;
    typedef SimpleString            RGCH;

    // 
    struct SectionStat {
        bool     fComdat : 1;
        bool     fAssoc : 1;
        bool     fFunc : 1;
        bool     fExternal : 1;
        COFFSYMI csymi;
        bool     fImgSec : 1;
        };


    #if !defined(pure)
    #define pure = 0
    #endif

    #define Align(p, x)                (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

    class ObjectCode;
    class Section;
    typedef RefPtr< ObjectCode >    RefObj;
    typedef RefPtr< Section >       RefSec;
    typedef RefPtr<SimpleString>    RefStr;

    PdbInterface EnumSection;
    PdbInterface EnumRelocation;
    PdbInterface EnumImgSymbol;
    typedef int             ISection;
    const ISection          iSectionNil = 0;

    const DWORD dwOrdNil = 0;       // 0 is an invalid ordinal number


    // Dump flags
    enum ODF {          // Object Dump Flags
        odfHdrs     = 0x01,
        odfSects    = 0x02,
        odfFixups   = 0x04,
        odfSyms     = 0x08,
        odfLineNum  = 0x10,
        odfAll      = (odfHdrs | odfSects | odfFixups | odfSyms | odfLineNum),
        odfFmtLong  = 0x20,
        odfFmtShort = 0x40,
        odfFmtByte  = 0x80
        };


    // This interface is used by the objfile object to query the caller
    // for the location of symbols at runtime.  Used in Section::FApplyFixups, for example.

    typedef DWORD CRC;

    PdbInterface RunTimeSymTab
    {
        // Given a symbol that's undefined in the current module, returns its address,
        // section, and offset.
        virtual bool FAddrFromName( const char*, ISECT*, OFF*, DWORD* ) pure;

        // this returns the location where an object's contribution was loaded, given a name that that
        // contribution exports
        virtual bool FSectAddrFromName( const char*, ISECT*, OFF*, DWORD* ) pure;

        // this returns the location where an object contribution was loaded, given the CRC's that 
        // identify the component - used for statics that aren't defined in the same section
        // as some external.
        virtual bool FSectAddrFromCrc( CRC crcData, CRC crcReloc, DWORD cb, ISECT*, OFF*, DWORD* ) pure;

        // update the callee with line number information
        virtual bool FAddLines ( const char *, ISection, long, CB, long, USHORT, BYTE *, CB ) pure;
    };

    typedef RunTimeSymTab * PRunTimeSymTab;

    // define the interface class to the rest of the world.
    class ObjectCode : public CRefCountedObj {
    
    public:
        // provide static creation methods so we don't have to expose operator
        // new/delete semantics
        IMPORT_EXPORT static bool __cdecl
        FCreate ( RefObj &, DWORD dwMachineTypeExpected, LPCTSTR szFileName, LPCTSTR szMemberName = 0 );

        IMPORT_EXPORT static bool __cdecl
        FCreate2 ( RefObj &, DWORD dwMachineTypeExpected, LPCTSTR szFileName,
                  LPCTSTR szMemberName = 0, DWORD offset =0, DWORD cbObj = 0 );

        IMPORT_EXPORT static bool __cdecl
        FCreateFromBytes ( RefObj &, DWORD dwMachineTypeExpected, PB pData, DWORD cbData, LPCTSTR szFileName,
                  LPCTSTR szMemberName = 0, DWORD offset =0, DWORD cbObj = 0 );

        virtual COFFSYMI
        CoffSymiFromSymi ( SYMI symi ) const pure;

        // get the symbol index for a particular name
        virtual SYMI
        SymiFromSz ( LPCTSTR szName ) const pure;

        // get the name from a particular symbol index
        virtual LPCTSTR
        SzFromSymi ( SYMI symi ) const pure;

        virtual SYMI
        SymiFromCoffsymi ( COFFSYMI coffsymi ) const pure;

        // get a PImgSym from a coff symbol index
        virtual PCImgSym
        PCImgSymFromCoffsymi ( COFFSYMI coffsymi ) const pure;

        // determine whether the object represents an import
        virtual bool
        FImport ( ) const pure;

        // if the object's an import, return the dll name
        virtual char *
        SzDllName ( RefStr& ) const pure;

        // if the object is an import, returns the ordinal, or
        // dwOrdNil and its exported name
        virtual DWORD
        DwExportOrdinalName ( RefStr& ) const pure;

        virtual bool
        FSectionFromSzSymbol (
            LPCTSTR             szSymbolName,
            PCImgSectHdr &      pcImgSectHdr,
            RefPtr<RGBYTE> &    rgbSectdata,
            RefPtr<RGFIXUPMAP> &rgfixup
            ) const pure;

        virtual bool
        FSectionFromSzSymbol (
            LPCTSTR             szSymbolName,
            RefSec &            rSection
            ) const pure;

        // get the count of sections
        virtual DWORD
        CSections ( ) const pure;

        // get the count of image symbols
        virtual DWORD
        CImgSym ( ) const pure;

        // get a section enumerator
        virtual bool
        FGetEnumSection ( EnumSection ** ) const pure;

        // get a symbol enumerator
        virtual bool
        FGetEnumImgSymbol ( EnumImgSymbol ** ) const pure;

        // get the name of the object
        virtual char*
        SzName ( RefStr& ) const pure;

        // get the name of a symbol
        virtual LPCTSTR
        SzSymbol ( PCImgSym ) const pure;

        // get comdat symbol name defined by isection
        virtual void
        SzSymForIsec ( RGCH&, ISection ) const pure;

        virtual const char *
        SzRelocationType ( WORD, WORD *, bool * ) const pure;

        // emit an object
        virtual bool
        FEmitObject ( LPCTSTR ) pure;

        // emit an object, excluding a list of sections
        virtual bool
        FEmitObject ( LPCTSTR, LPCTSTR *, int ) pure;

        // dump an object
        virtual void
        Dump ( ODF ) const pure;

       };


    // define the Section interface class to the rest of the world.
    class Section : public CRefCountedObj {

    public:

        virtual DWORD
        CRelocation ( ) const pure;

        // get a relocation enumerator
        virtual bool
        FGetEnumRelocation ( EnumRelocation ** ) const pure;

        // get the name of the section
        virtual char *
        SzName ( RefPtr<RGCH>& szName ) const pure;

        virtual DWORD
        CLineNum ( ) const pure;

        virtual DWORD
        CbRawData ( ) const pure;

        virtual DWORD
        dwCharacteristics ( ) const pure;

        virtual CB 
        cbAlignment() const pure;

        virtual bool
        FRawData( RefPtr<RGBYTE>& rgbSectdata ) const pure;

        virtual void
        LoadData ( void * ) const pure;

        virtual bool
        IsComdat() const pure;

        virtual bool
        IsAssociativeComdat() const pure;

        virtual ISection
        AssociativeSection() const pure;

        virtual bool
        FAssociativeSection( RefSec& rsec ) pure;

        virtual bool
        FAbsentInImage( PRunTimeSymTab ) const pure;

        virtual bool
        FImageSection() const pure;

        // apply fixups to the section's data
        virtual bool
        FApplyFixups ( DWORD vaImgBase, DWORD vaSection, PRunTimeSymTab, RefPtr<RGBYTE>& ) pure;

        // retrieve a block of line numbers
        virtual bool
        FGetLineNumbers ( DWORD, ISection, PRunTimeSymTab ) const pure;

        // get the section's statistics
        virtual void
        GetSectionStatistics( SectionStat& ) const pure;

        virtual void
        LoadFixupMap ( void * ) const pure;

        virtual void
        LoadLineNumbers ( void * ) const pure;

        virtual void
        Dump ( ODF ) const pure;

        // get an external symbol enumerator
        virtual bool
        FGetEnumExSymbol ( EnumImgSymbol ** ) const pure;

        // get an associative comdat enumerator
        virtual bool
        FGetEnumComdat ( EnumSection ** ) const pure;

        virtual bool
        FGetCrcs ( CRC* pcrcData, CRC* pcrcReloc ) const pure;

        virtual PImgSectHdr
        GetSectionHeader ( ImgSectHdr& ) const pure;

        virtual void
        SetSectionHeader ( ImgSectHdr& ) pure;
    
        virtual void *
        GetDataPtr ( void ) const pure;

        // get a symbol enumerator
        virtual bool
        FGetEnumImgSymbol ( EnumImgSymbol ** ) const pure;

        // set a section's raw data
        virtual bool
        FSetRawData ( RefPtr<RGBYTE>& rgbSectdata ) pure;
    };
    
    typedef Section *       PSection;

    // section enumerator
    PdbInterface EnumSection : public Enum {
        virtual void get( RefPtr<Section>& ) pure;
    };

    // relocation/fixup enumerator
    PdbInterface EnumRelocation : public Enum {
        virtual void get( PImgReloc * const ) pure;
    };

    // symbol enumerator
    PdbInterface EnumImgSymbol : public Enum {
        virtual void get ( PImgSym * const ) pure;
        virtual void get( RefPtr<RGCH>& szName, OFF* poff, bool* fFunc) pure;
    };

    // external symbol enumerator
    typedef EnumImgSymbol EnumExSymbol;



    PdbInterface Library;
    typedef RefPtr<Library> RefLib;

    // Object enumerator
    PdbInterface EnumObject : public Enum {
        virtual void get( RefObj& ) pure;
    };

    // symbol enumerator
    PdbInterface EnumSymbol : public Enum {
        virtual void get ( RefStr& ) pure;
    };

    PdbInterface Library : public CRefCountedObj {
    
    public:
        // provide static creation methods so we don't have to expose operator
        // new/delete semantics
        IMPORT_EXPORT static bool __cdecl
        FCreate ( RefLib &, DWORD, LPCTSTR );

        virtual bool
        FObjectFromSzSymbol (
            LPCTSTR,
            RefObj&
            ) const pure;

        virtual bool
        FObjectFromSzName (
            LPCTSTR,
            RefObj&
            ) const pure;

        // get the count of objects
        virtual DWORD
        CObjects ( ) const pure;

        // get the count of symbols
        virtual DWORD
        CSymbols ( ) const pure;

        // get an object enumerator
        virtual bool
        FGetEnumObject ( EnumObject ** ) const pure;

        // get a symbol enumerator
        virtual bool
        FGetEnumSymbol ( EnumSymbol ** ) const pure;

        // get the name of the library
        virtual char*
        SzName ( RefStr& ) const pure;

    };

    PdbInterface Image;
    typedef RefPtr<Image>     RefImg;

    // import enumerator
    PdbInterface EnumImport : public Enum {
        virtual void get ( RefStr& ) pure;
    };

    // export enumerator
    PdbInterface EnumExport : public Enum {
        virtual void get ( RefStr& rstrName, DWORD* pordinal, DWORD* prva, RefStr& rstrForward ) pure;
    };

    PdbInterface EnumSectionHeaders : public Enum {
        virtual void get ( PImgSectHdr * ) pure;
    };

    PdbInterface Image : public CRefCountedObj 
    {
        IMPORT_EXPORT static bool __cdecl
        FCreate ( RefImg &, DWORD dwMachineTypeExpected, LPCTSTR szFileName );

        IMPORT_EXPORT static bool __cdecl
        FCreate ( RefImg &rimg, PB pb, CB cb, DWORD dwMachineTypeExpected );

        virtual bool 
        FExportRvaByOrdinal( DWORD dwOrdinal, DWORD* prva, RefStr&  ) const pure;  // rva of export by ordinal

        virtual bool
        FExportRvaByName( LPCTSTR szName, DWORD* prva, RefStr&  )  const pure;  // rva by export name

        virtual bool
        FGetEnumImport ( EnumImport ** ) const pure;

        virtual void Dump( ODF odf ) const pure;

        // get the name of the image

        virtual char*
        SzName ( RefStr& ) const pure;

        // Get a specific debug dir, if it exists.
        // First arg is the debug type, one of IMAGE_DEBUG_TYPE_XXX from
        // winnt.h.

        virtual bool
        FGetDebugDir ( UINT, IMAGE_DEBUG_DIRECTORY *, PB * ) const pure;

        // Get a section header enumerator.

        virtual bool
        FGetEnumSectionHeaders ( EnumSectionHeaders ** ) const pure;

        // Get an export enumerator.

        virtual bool
        FGetEnumExport ( EnumExport ** ) const pure;
    };

};      // end of namespace

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\rttidata.h ===
//
//	_RTTIBaseClassDescriptor
//
//	TypeDescriptor is declared in ehdata.h
//
#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(push, rttidata, 4)
#endif

#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassDescriptor	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32     					pTypeDescriptor;    // Image relative offset of TypeDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
#endif
	DWORD							numContainedBases;
	PMD								where;
	DWORD							attributes;
	} _RTTIBaseClassDescriptor;
#endif // WANT_NO_TYPES

#define BCD_NOTVISIBLE				0x00000001
#define BCD_AMBIGUOUS				0x00000002
#define BCD_PRIVORPROTINCOMPOBJ		0x00000004
#define BCD_PRIVORPROTBASE			0x00000008
#define BCD_VBOFCONTOBJ				0x00000010
#define BCD_NONPOLYMORPHIC			0x00000020

#define BCD_PTD(bcd)				((bcd).pTypeDescriptor)
#define BCD_NUMCONTBASES(bcd)		((bcd).numContainedBases)
#define BCD_WHERE(bcd)				((bcd).where)
#define BCD_ATTRIBUTES(bcd)			((bcd).attributes)
#if defined(_M_IA64)
#define BCD_PTD_IB(bcd,ib)			((TypeDescriptor*)((ib) + (bcd).pTypeDescriptor))
#endif


//
//	_RTTIBaseClassArray
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassArray	{
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32                 		arrayOfBaseClassDescriptors[];  // Image relative offset of _RTTIBaseClassDescriptor
#else
	_RTTIBaseClassDescriptor		*arrayOfBaseClassDescriptors[];
#endif
	} _RTTIBaseClassArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
//	_RTTIClassHierarchyDescriptor
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIClassHierarchyDescriptor	{
	DWORD							signature;
	DWORD							attributes;
	DWORD							numBaseClasses;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32         				pBaseClassArray;    // Image relative offset of _RTTIBaseClassArray
#else
	_RTTIBaseClassArray				*pBaseClassArray;
#endif
	} _RTTIClassHierarchyDescriptor;
#endif // WANT_NO_TYPES

#define CHD_MULTINH					0x00000001
#define CHD_VIRTINH					0x00000002
#define CHD_AMBIGUOUS				0x00000004

#define CHD_SIGNATURE(chd)			((chd).signature)
#define CHD_ATTRIBUTES(chd)			((chd).attributes)
#define CHD_NUMBASES(chd)			((chd).numBaseClasses)
#define CHD_PBCA(chd)				((chd).pBaseClassArray)
#define CHD_PBCD(bcd)				(bcd)
#if defined(_M_IA64)
#define CHD_PBCA_IB(chd,ib)			((_RTTIBaseClassArray*)((ib) + (chd).pBaseClassArray))
#define CHD_PBCD_IB(bcd,ib)			((_RTTIBaseClassDescriptor*)((ib) + bcd))
#endif

//
//	_RTTICompleteObjectLocator
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTICompleteObjectLocator	{
	DWORD							signature;
	DWORD							offset;
	DWORD							cdOffset;
#if defined(_M_IA64) && !defined(VERSP_P7)
	__int32		    			    pTypeDescriptor;    // Image relative offset of TypeDescriptor
	__int32                         pClassDescriptor;   // Image relative offset of _RTTIClassHierarchyDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
	_RTTIClassHierarchyDescriptor	*pClassDescriptor;
#endif
	} _RTTICompleteObjectLocator;
#endif // WANT_NO_TYPES

#define COL_SIGNATURE(col)			((col).signature)
#define COL_OFFSET(col)				((col).offset)
#define COL_CDOFFSET(col)			((col).cdOffset)
#define COL_PTD(col)				((col).pTypeDescriptor)
#define COL_PCHD(col)				((col).pClassDescriptor)
#if defined(_M_IA64)
#define COL_PTD_IB(col,ib)			((TypeDescriptor*)((ib) + (col).pTypeDescriptor))
#define COL_PCHD_IB(col,ib)			((_RTTIClassHierarchyDescriptor*)((ib) + (col).pClassDescriptor))
#endif

#ifdef BUILDING_TYPESRC_C
//
// Type of the result of __RTtypeid and internal applications of typeid().
// This also introduces the tag "type_info" as an incomplete type.
//

typedef const class type_info &__RTtypeidReturnType;

//
// Declaration of CRT entrypoints, as seen by the compiler.  Types are 
// simplified so as to avoid type matching hassles.
//

#ifndef THROWSPEC
#if _MSC_VER >= 1300
#define THROWSPEC(_ex) throw _ex
#else
#define THROWSPEC(_ex)
#endif
#endif

// Perform a dynamic_cast on obj. of polymorphic type
extern "C" PVOID __cdecl __RTDynamicCast (
								PVOID,				// ptr to vfptr
								LONG,				// offset of vftable
								PVOID,				// src type
								PVOID,				// target type
								BOOL) THROWSPEC((...)); // isReference

// Perform 'typeid' on obj. of polymorphic type
extern "C" PVOID __cdecl __RTtypeid (PVOID)  THROWSPEC((...));	// ptr to vfptr

// Perform a dynamic_cast from obj. of polymorphic type to void*
extern "C" PVOID __cdecl __RTCastToVoid (PVOID)  THROWSPEC((...)); // ptr to vfptr
#endif

#if defined(_M_IA64) || defined(VERSP_P7)	/*IFSTRIP=IGN*/
#pragma pack(pop, rttidata)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\objint.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0342 */
/* at Wed Mar 14 14:21:50 2001
 */
/* Compiler settings for objint.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objint_h__
#define __objint_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILinkDataRO_FWD_DEFINED__
#define __ILinkDataRO_FWD_DEFINED__
typedef interface ILinkDataRO ILinkDataRO;
#endif 	/* __ILinkDataRO_FWD_DEFINED__ */


#ifndef __ILinkDataRW_FWD_DEFINED__
#define __ILinkDataRW_FWD_DEFINED__
typedef interface ILinkDataRW ILinkDataRW;
#endif 	/* __ILinkDataRW_FWD_DEFINED__ */


#ifndef __IPublicSym_FWD_DEFINED__
#define __IPublicSym_FWD_DEFINED__
typedef interface IPublicSym IPublicSym;
#endif 	/* __IPublicSym_FWD_DEFINED__ */


#ifndef __IEnumPublics_FWD_DEFINED__
#define __IEnumPublics_FWD_DEFINED__
typedef interface IEnumPublics IEnumPublics;
#endif 	/* __IEnumPublics_FWD_DEFINED__ */


#ifndef __IObjFile_FWD_DEFINED__
#define __IObjFile_FWD_DEFINED__
typedef interface IObjFile IObjFile;
#endif 	/* __IObjFile_FWD_DEFINED__ */


#ifndef __IObjHandler_FWD_DEFINED__
#define __IObjHandler_FWD_DEFINED__
typedef interface IObjHandler IObjHandler;
#endif 	/* __IObjHandler_FWD_DEFINED__ */


#ifndef __IObjectContrib_FWD_DEFINED__
#define __IObjectContrib_FWD_DEFINED__
typedef interface IObjectContrib IObjectContrib;
#endif 	/* __IObjectContrib_FWD_DEFINED__ */


#ifndef __IEnumContrib_FWD_DEFINED__
#define __IEnumContrib_FWD_DEFINED__
typedef interface IEnumContrib IEnumContrib;
#endif 	/* __IEnumContrib_FWD_DEFINED__ */


#ifndef __ICOFFAuxSym_FWD_DEFINED__
#define __ICOFFAuxSym_FWD_DEFINED__
typedef interface ICOFFAuxSym ICOFFAuxSym;
#endif 	/* __ICOFFAuxSym_FWD_DEFINED__ */


#ifndef __IEnumAuxSym_FWD_DEFINED__
#define __IEnumAuxSym_FWD_DEFINED__
typedef interface IEnumAuxSym IEnumAuxSym;
#endif 	/* __IEnumAuxSym_FWD_DEFINED__ */


#ifndef __ICOFFSymRO_FWD_DEFINED__
#define __ICOFFSymRO_FWD_DEFINED__
typedef interface ICOFFSymRO ICOFFSymRO;
#endif 	/* __ICOFFSymRO_FWD_DEFINED__ */


#ifndef __ICOFFSymRW_FWD_DEFINED__
#define __ICOFFSymRW_FWD_DEFINED__
typedef interface ICOFFSymRW ICOFFSymRW;
#endif 	/* __ICOFFSymRW_FWD_DEFINED__ */


#ifndef __IEnumCOFFSymRO_FWD_DEFINED__
#define __IEnumCOFFSymRO_FWD_DEFINED__
typedef interface IEnumCOFFSymRO IEnumCOFFSymRO;
#endif 	/* __IEnumCOFFSymRO_FWD_DEFINED__ */


#ifndef __IEnumCOFFSymRW_FWD_DEFINED__
#define __IEnumCOFFSymRW_FWD_DEFINED__
typedef interface IEnumCOFFSymRW IEnumCOFFSymRW;
#endif 	/* __IEnumCOFFSymRW_FWD_DEFINED__ */


#ifndef __ICOFFSymTabRO_FWD_DEFINED__
#define __ICOFFSymTabRO_FWD_DEFINED__
typedef interface ICOFFSymTabRO ICOFFSymTabRO;
#endif 	/* __ICOFFSymTabRO_FWD_DEFINED__ */


#ifndef __ICOFFSymTabRW_FWD_DEFINED__
#define __ICOFFSymTabRW_FWD_DEFINED__
typedef interface ICOFFSymTabRW ICOFFSymTabRW;
#endif 	/* __ICOFFSymTabRW_FWD_DEFINED__ */


#ifndef __ICOFFObj_FWD_DEFINED__
#define __ICOFFObj_FWD_DEFINED__
typedef interface ICOFFObj ICOFFObj;
#endif 	/* __ICOFFObj_FWD_DEFINED__ */


#ifndef __ILinkError_FWD_DEFINED__
#define __ILinkError_FWD_DEFINED__
typedef interface ILinkError ILinkError;
#endif 	/* __ILinkError_FWD_DEFINED__ */


#ifndef __ILinkNotify_FWD_DEFINED__
#define __ILinkNotify_FWD_DEFINED__
typedef interface ILinkNotify ILinkNotify;
#endif 	/* __ILinkNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_objint_0000 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_objint_0000_0001
    {	psymtNil	= 0,
	psymtRef	= psymtNil + 1,
	psymtDef	= psymtRef + 1,
	psymtAbs	= psymtDef + 1,
	psymtCom	= psymtAbs + 1,
	psymtAlias	= psymtCom + 1,
	psymtWeak	= psymtAlias + 1,
	psymtLazy	= psymtWeak + 1
    } 	PSYMT;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_objint_0000_0002
    {	oftCIL	= 0,
	oftCOFF	= oftCIL + 1,
	oftMSILPE	= oftCOFF + 1
    } 	OFT;

typedef DWORDLONG OBJTK;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_objint_0000_0003
    {	objtktNil	= 0
    } 	OBJTKT;

typedef DWORDLONG ISYM;

typedef DWORD ICOFFSYM;



extern RPC_IF_HANDLE __MIDL_itf_objint_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objint_0000_v0_0_s_ifspec;

#ifndef __ILinkDataRO_INTERFACE_DEFINED__
#define __ILinkDataRO_INTERFACE_DEFINED__

/* interface ILinkDataRO */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ILinkDataRO *PLinkDataRO;


EXTERN_C const IID IID_ILinkDataRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0CE9B320-AE0F-11d1-A719-0060083E8C78")
    ILinkDataRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataPointer( 
            /* [out] */ BYTE **__MIDL_0004,
            /* [out] */ int *__MIDL_0005) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkDataROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILinkDataRO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILinkDataRO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILinkDataRO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataPointer )( 
            ILinkDataRO * This,
            /* [out] */ BYTE **__MIDL_0004,
            /* [out] */ int *__MIDL_0005);
        
        END_INTERFACE
    } ILinkDataROVtbl;

    interface ILinkDataRO
    {
        CONST_VTBL struct ILinkDataROVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkDataRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkDataRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkDataRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkDataRO_GetDataPointer(This,__MIDL_0004,__MIDL_0005)	\
    (This)->lpVtbl -> GetDataPointer(This,__MIDL_0004,__MIDL_0005)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkDataRO_GetDataPointer_Proxy( 
    ILinkDataRO * This,
    /* [out] */ BYTE **__MIDL_0004,
    /* [out] */ int *__MIDL_0005);


void __RPC_STUB ILinkDataRO_GetDataPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkDataRO_INTERFACE_DEFINED__ */


#ifndef __ILinkDataRW_INTERFACE_DEFINED__
#define __ILinkDataRW_INTERFACE_DEFINED__

/* interface ILinkDataRW */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ILinkDataRW *PLinkDataRW;


EXTERN_C const IID IID_ILinkDataRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB97C491-AE41-11d1-A719-0060083E8C78")
    ILinkDataRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDataPointer( 
            /* [out] */ BYTE **__MIDL_0006,
            /* [out] */ int *__MIDL_0007) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkDataRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILinkDataRW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILinkDataRW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILinkDataRW * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataPointer )( 
            ILinkDataRW * This,
            /* [out] */ BYTE **__MIDL_0006,
            /* [out] */ int *__MIDL_0007);
        
        END_INTERFACE
    } ILinkDataRWVtbl;

    interface ILinkDataRW
    {
        CONST_VTBL struct ILinkDataRWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkDataRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkDataRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkDataRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkDataRW_GetDataPointer(This,__MIDL_0006,__MIDL_0007)	\
    (This)->lpVtbl -> GetDataPointer(This,__MIDL_0006,__MIDL_0007)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkDataRW_GetDataPointer_Proxy( 
    ILinkDataRW * This,
    /* [out] */ BYTE **__MIDL_0006,
    /* [out] */ int *__MIDL_0007);


void __RPC_STUB ILinkDataRW_GetDataPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkDataRW_INTERFACE_DEFINED__ */


#ifndef __IPublicSym_INTERFACE_DEFINED__
#define __IPublicSym_INTERFACE_DEFINED__

/* interface IPublicSym */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPublicSym *LPPubSym;


EXTERN_C const IID IID_IPublicSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18851AD0-910F-11d1-A712-0060083E8C78")
    IPublicSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FComdat( 
            /* [out] */ BOOL *__MIDL_0008,
            /* [out] */ BYTE *__MIDL_0009) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ ISYM *__MIDL_0010) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK *__MIDL_0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO *__MIDL_0012) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SymType( 
            /* [out] */ PSYMT *__MIDL_0013) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzNameDefaultSym( 
            /* [out] */ PLinkDataRO *__MIDL_0014) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPublicSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPublicSym * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPublicSym * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPublicSym * This);
        
        HRESULT ( STDMETHODCALLTYPE *FComdat )( 
            IPublicSym * This,
            /* [out] */ BOOL *__MIDL_0008,
            /* [out] */ BYTE *__MIDL_0009);
        
        HRESULT ( STDMETHODCALLTYPE *ISym )( 
            IPublicSym * This,
            /* [out] */ ISYM *__MIDL_0010);
        
        HRESULT ( STDMETHODCALLTYPE *TkFile )( 
            IPublicSym * This,
            /* [out] */ OBJTK *__MIDL_0011);
        
        HRESULT ( STDMETHODCALLTYPE *SzName )( 
            IPublicSym * This,
            /* [out] */ PLinkDataRO *__MIDL_0012);
        
        HRESULT ( STDMETHODCALLTYPE *SymType )( 
            IPublicSym * This,
            /* [out] */ PSYMT *__MIDL_0013);
        
        HRESULT ( STDMETHODCALLTYPE *SzNameDefaultSym )( 
            IPublicSym * This,
            /* [out] */ PLinkDataRO *__MIDL_0014);
        
        END_INTERFACE
    } IPublicSymVtbl;

    interface IPublicSym
    {
        CONST_VTBL struct IPublicSymVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPublicSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublicSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPublicSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPublicSym_FComdat(This,__MIDL_0008,__MIDL_0009)	\
    (This)->lpVtbl -> FComdat(This,__MIDL_0008,__MIDL_0009)

#define IPublicSym_ISym(This,__MIDL_0010)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0010)

#define IPublicSym_TkFile(This,__MIDL_0011)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0011)

#define IPublicSym_SzName(This,__MIDL_0012)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0012)

#define IPublicSym_SymType(This,__MIDL_0013)	\
    (This)->lpVtbl -> SymType(This,__MIDL_0013)

#define IPublicSym_SzNameDefaultSym(This,__MIDL_0014)	\
    (This)->lpVtbl -> SzNameDefaultSym(This,__MIDL_0014)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPublicSym_FComdat_Proxy( 
    IPublicSym * This,
    /* [out] */ BOOL *__MIDL_0008,
    /* [out] */ BYTE *__MIDL_0009);


void __RPC_STUB IPublicSym_FComdat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_ISym_Proxy( 
    IPublicSym * This,
    /* [out] */ ISYM *__MIDL_0010);


void __RPC_STUB IPublicSym_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_TkFile_Proxy( 
    IPublicSym * This,
    /* [out] */ OBJTK *__MIDL_0011);


void __RPC_STUB IPublicSym_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SzName_Proxy( 
    IPublicSym * This,
    /* [out] */ PLinkDataRO *__MIDL_0012);


void __RPC_STUB IPublicSym_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SymType_Proxy( 
    IPublicSym * This,
    /* [out] */ PSYMT *__MIDL_0013);


void __RPC_STUB IPublicSym_SymType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPublicSym_SzNameDefaultSym_Proxy( 
    IPublicSym * This,
    /* [out] */ PLinkDataRO *__MIDL_0014);


void __RPC_STUB IPublicSym_SzNameDefaultSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPublicSym_INTERFACE_DEFINED__ */


#ifndef __IEnumPublics_INTERFACE_DEFINED__
#define __IEnumPublics_INTERFACE_DEFINED__

/* interface IEnumPublics */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumPublics *LPEnumPub;


EXTERN_C const IID IID_IEnumPublics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BFA6690-9113-11d1-A712-0060083E8C78")
    IEnumPublics : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0015,
            /* [out] */ IPublicSym **__MIDL_0016,
            /* [out] */ ULONG *__MIDL_0017) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0018) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPublics **__MIDL_0019) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPublicsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPublics * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPublics * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPublics * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPublics * This,
            /* [in] */ ULONG __MIDL_0015,
            /* [out] */ IPublicSym **__MIDL_0016,
            /* [out] */ ULONG *__MIDL_0017);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPublics * This,
            /* [in] */ ULONG __MIDL_0018);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPublics * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPublics * This,
            /* [out] */ IEnumPublics **__MIDL_0019);
        
        END_INTERFACE
    } IEnumPublicsVtbl;

    interface IEnumPublics
    {
        CONST_VTBL struct IEnumPublicsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPublics_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPublics_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPublics_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPublics_Next(This,__MIDL_0015,__MIDL_0016,__MIDL_0017)	\
    (This)->lpVtbl -> Next(This,__MIDL_0015,__MIDL_0016,__MIDL_0017)

#define IEnumPublics_Skip(This,__MIDL_0018)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0018)

#define IEnumPublics_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPublics_Clone(This,__MIDL_0019)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0019)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPublics_Next_Proxy( 
    IEnumPublics * This,
    /* [in] */ ULONG __MIDL_0015,
    /* [out] */ IPublicSym **__MIDL_0016,
    /* [out] */ ULONG *__MIDL_0017);


void __RPC_STUB IEnumPublics_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Skip_Proxy( 
    IEnumPublics * This,
    /* [in] */ ULONG __MIDL_0018);


void __RPC_STUB IEnumPublics_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Reset_Proxy( 
    IEnumPublics * This);


void __RPC_STUB IEnumPublics_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPublics_Clone_Proxy( 
    IEnumPublics * This,
    /* [out] */ IEnumPublics **__MIDL_0019);


void __RPC_STUB IEnumPublics_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPublics_INTERFACE_DEFINED__ */


#ifndef __IObjFile_INTERFACE_DEFINED__
#define __IObjFile_INTERFACE_DEFINED__

/* interface IObjFile */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AEA3330-911D-11d1-A712-0060083E8C78")
    IObjFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Characteristics( 
            /* [out] */ DWORD *__MIDL_0020) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseCache( 
            /* [in] */ BOOL __MIDL_0021) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPublics( 
            /* [out] */ IEnumPublics **__MIDL_0022,
            /* [in] */ OBJTK __MIDL_0023) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FNative( 
            BOOL *__MIDL_0024) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Machine( 
            /* [out] */ WORD *__MIDL_0025) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbDirectives( 
            /* [out] */ PLinkDataRO *__MIDL_0026) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgISymForeignRefs( 
            /* [out] */ PLinkDataRO *__MIDL_0027) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbExternalFilenames( 
            /* [out] */ PLinkDataRO *__MIDL_0028) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjFile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *Characteristics )( 
            IObjFile * This,
            /* [out] */ DWORD *__MIDL_0020);
        
        HRESULT ( STDMETHODCALLTYPE *CloseCache )( 
            IObjFile * This,
            /* [in] */ BOOL __MIDL_0021);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPublics )( 
            IObjFile * This,
            /* [out] */ IEnumPublics **__MIDL_0022,
            /* [in] */ OBJTK __MIDL_0023);
        
        HRESULT ( STDMETHODCALLTYPE *FNative )( 
            IObjFile * This,
            BOOL *__MIDL_0024);
        
        HRESULT ( STDMETHODCALLTYPE *Machine )( 
            IObjFile * This,
            /* [out] */ WORD *__MIDL_0025);
        
        HRESULT ( STDMETHODCALLTYPE *PbDirectives )( 
            IObjFile * This,
            /* [out] */ PLinkDataRO *__MIDL_0026);
        
        HRESULT ( STDMETHODCALLTYPE *RgISymForeignRefs )( 
            IObjFile * This,
            /* [out] */ PLinkDataRO *__MIDL_0027);
        
        HRESULT ( STDMETHODCALLTYPE *PbExternalFilenames )( 
            IObjFile * This,
            /* [out] */ PLinkDataRO *__MIDL_0028);
        
        END_INTERFACE
    } IObjFileVtbl;

    interface IObjFile
    {
        CONST_VTBL struct IObjFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjFile_Characteristics(This,__MIDL_0020)	\
    (This)->lpVtbl -> Characteristics(This,__MIDL_0020)

#define IObjFile_CloseCache(This,__MIDL_0021)	\
    (This)->lpVtbl -> CloseCache(This,__MIDL_0021)

#define IObjFile_EnumPublics(This,__MIDL_0022,__MIDL_0023)	\
    (This)->lpVtbl -> EnumPublics(This,__MIDL_0022,__MIDL_0023)

#define IObjFile_FNative(This,__MIDL_0024)	\
    (This)->lpVtbl -> FNative(This,__MIDL_0024)

#define IObjFile_Machine(This,__MIDL_0025)	\
    (This)->lpVtbl -> Machine(This,__MIDL_0025)

#define IObjFile_PbDirectives(This,__MIDL_0026)	\
    (This)->lpVtbl -> PbDirectives(This,__MIDL_0026)

#define IObjFile_RgISymForeignRefs(This,__MIDL_0027)	\
    (This)->lpVtbl -> RgISymForeignRefs(This,__MIDL_0027)

#define IObjFile_PbExternalFilenames(This,__MIDL_0028)	\
    (This)->lpVtbl -> PbExternalFilenames(This,__MIDL_0028)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjFile_Characteristics_Proxy( 
    IObjFile * This,
    /* [out] */ DWORD *__MIDL_0020);


void __RPC_STUB IObjFile_Characteristics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_CloseCache_Proxy( 
    IObjFile * This,
    /* [in] */ BOOL __MIDL_0021);


void __RPC_STUB IObjFile_CloseCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_EnumPublics_Proxy( 
    IObjFile * This,
    /* [out] */ IEnumPublics **__MIDL_0022,
    /* [in] */ OBJTK __MIDL_0023);


void __RPC_STUB IObjFile_EnumPublics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_FNative_Proxy( 
    IObjFile * This,
    BOOL *__MIDL_0024);


void __RPC_STUB IObjFile_FNative_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_Machine_Proxy( 
    IObjFile * This,
    /* [out] */ WORD *__MIDL_0025);


void __RPC_STUB IObjFile_Machine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_PbDirectives_Proxy( 
    IObjFile * This,
    /* [out] */ PLinkDataRO *__MIDL_0026);


void __RPC_STUB IObjFile_PbDirectives_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_RgISymForeignRefs_Proxy( 
    IObjFile * This,
    /* [out] */ PLinkDataRO *__MIDL_0027);


void __RPC_STUB IObjFile_RgISymForeignRefs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjFile_PbExternalFilenames_Proxy( 
    IObjFile * This,
    /* [out] */ PLinkDataRO *__MIDL_0028);


void __RPC_STUB IObjFile_PbExternalFilenames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjFile_INTERFACE_DEFINED__ */


#ifndef __IObjHandler_INTERFACE_DEFINED__
#define __IObjHandler_INTERFACE_DEFINED__

/* interface IObjHandler */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IObjHandler *PObjHandler;


EXTERN_C const IID IID_IObjHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54222448-B583-4cf1-89CA-1737C9F4613B")
    IObjHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CodeGen( 
            /* [in] */ int __MIDL_0029,
            /* [in] */ unsigned char **__MIDL_0030,
            /* [in] */ PLinkDataRO __MIDL_0031,
            /* [out] */ PLinkDataRO *__MIDL_0032) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IUnknown *__MIDL_0033,
            /* [in] */ BOOL __MIDL_0034,
            /* [in] */ int __MIDL_0035,
            /* [in] */ unsigned char **__MIDL_0036) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IObjFileForFile( 
            /* [in] */ BSTR __MIDL_0037,
            /* [in] */ WORD __MIDL_0038,
            /* [in] */ DWORD __MIDL_0039,
            /* [in] */ DWORD __MIDL_0040,
            /* [in] */ OBJTK __MIDL_0041,
            /* [in] */ OFT __MIDL_0042,
            /* [out] */ IObjFile **__MIDL_0043) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCtrlC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CodeGen )( 
            IObjHandler * This,
            /* [in] */ int __MIDL_0029,
            /* [in] */ unsigned char **__MIDL_0030,
            /* [in] */ PLinkDataRO __MIDL_0031,
            /* [out] */ PLinkDataRO *__MIDL_0032);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IObjHandler * This,
            /* [in] */ IUnknown *__MIDL_0033,
            /* [in] */ BOOL __MIDL_0034,
            /* [in] */ int __MIDL_0035,
            /* [in] */ unsigned char **__MIDL_0036);
        
        HRESULT ( STDMETHODCALLTYPE *IObjFileForFile )( 
            IObjHandler * This,
            /* [in] */ BSTR __MIDL_0037,
            /* [in] */ WORD __MIDL_0038,
            /* [in] */ DWORD __MIDL_0039,
            /* [in] */ DWORD __MIDL_0040,
            /* [in] */ OBJTK __MIDL_0041,
            /* [in] */ OFT __MIDL_0042,
            /* [out] */ IObjFile **__MIDL_0043);
        
        HRESULT ( STDMETHODCALLTYPE *OnCtrlC )( 
            IObjHandler * This);
        
        END_INTERFACE
    } IObjHandlerVtbl;

    interface IObjHandler
    {
        CONST_VTBL struct IObjHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjHandler_CodeGen(This,__MIDL_0029,__MIDL_0030,__MIDL_0031,__MIDL_0032)	\
    (This)->lpVtbl -> CodeGen(This,__MIDL_0029,__MIDL_0030,__MIDL_0031,__MIDL_0032)

#define IObjHandler_Init(This,__MIDL_0033,__MIDL_0034,__MIDL_0035,__MIDL_0036)	\
    (This)->lpVtbl -> Init(This,__MIDL_0033,__MIDL_0034,__MIDL_0035,__MIDL_0036)

#define IObjHandler_IObjFileForFile(This,__MIDL_0037,__MIDL_0038,__MIDL_0039,__MIDL_0040,__MIDL_0041,__MIDL_0042,__MIDL_0043)	\
    (This)->lpVtbl -> IObjFileForFile(This,__MIDL_0037,__MIDL_0038,__MIDL_0039,__MIDL_0040,__MIDL_0041,__MIDL_0042,__MIDL_0043)

#define IObjHandler_OnCtrlC(This)	\
    (This)->lpVtbl -> OnCtrlC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjHandler_CodeGen_Proxy( 
    IObjHandler * This,
    /* [in] */ int __MIDL_0029,
    /* [in] */ unsigned char **__MIDL_0030,
    /* [in] */ PLinkDataRO __MIDL_0031,
    /* [out] */ PLinkDataRO *__MIDL_0032);


void __RPC_STUB IObjHandler_CodeGen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_Init_Proxy( 
    IObjHandler * This,
    /* [in] */ IUnknown *__MIDL_0033,
    /* [in] */ BOOL __MIDL_0034,
    /* [in] */ int __MIDL_0035,
    /* [in] */ unsigned char **__MIDL_0036);


void __RPC_STUB IObjHandler_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_IObjFileForFile_Proxy( 
    IObjHandler * This,
    /* [in] */ BSTR __MIDL_0037,
    /* [in] */ WORD __MIDL_0038,
    /* [in] */ DWORD __MIDL_0039,
    /* [in] */ DWORD __MIDL_0040,
    /* [in] */ OBJTK __MIDL_0041,
    /* [in] */ OFT __MIDL_0042,
    /* [out] */ IObjFile **__MIDL_0043);


void __RPC_STUB IObjHandler_IObjFileForFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjHandler_OnCtrlC_Proxy( 
    IObjHandler * This);


void __RPC_STUB IObjHandler_OnCtrlC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjHandler_INTERFACE_DEFINED__ */


#ifndef __IObjectContrib_INTERFACE_DEFINED__
#define __IObjectContrib_INTERFACE_DEFINED__

/* interface IObjectContrib */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IObjectContrib *PObjContrib;


EXTERN_C const IID IID_IObjectContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A461E470-911E-11d1-A712-0060083E8C78")
    IObjectContrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CbContents( 
            /* [out] */ DWORD *__MIDL_0044) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Characteristics( 
            /* [out] */ DWORD *__MIDL_0045) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CLineNo( 
            /* [out] */ DWORD *__MIDL_0046) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CRelocs( 
            /* [out] */ DWORD *__MIDL_0047) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ DWORD *__MIDL_0048) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContents( 
            /* [out] */ BYTE *__MIDL_0049,
            /* [in] */ DWORD __MIDL_0050,
            /* [out] */ DWORD *__MIDL_0051) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContentsRO( 
            /* [out] */ PLinkDataRO *__MIDL_0052) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PbContentsRW( 
            /* [out] */ PLinkDataRW *__MIDL_0053) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgLineNo( 
            /* [out] */ PLinkDataRO *__MIDL_0054) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgRelocs( 
            /* [out] */ PLinkDataRO *__MIDL_0055) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RgRelocsEx( 
            /* [out] */ BYTE *__MIDL_0056,
            /* [in] */ DWORD __MIDL_0057) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzSectionName( 
            /* [out] */ PLinkDataRO *__MIDL_0058) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK *__MIDL_0059) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualAddress( 
            /* [out] */ DWORD *__MIDL_0060) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectContrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *CbContents )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0044);
        
        HRESULT ( STDMETHODCALLTYPE *Characteristics )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0045);
        
        HRESULT ( STDMETHODCALLTYPE *CLineNo )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0046);
        
        HRESULT ( STDMETHODCALLTYPE *CRelocs )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0047);
        
        HRESULT ( STDMETHODCALLTYPE *ISection )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0048);
        
        HRESULT ( STDMETHODCALLTYPE *PbContents )( 
            IObjectContrib * This,
            /* [out] */ BYTE *__MIDL_0049,
            /* [in] */ DWORD __MIDL_0050,
            /* [out] */ DWORD *__MIDL_0051);
        
        HRESULT ( STDMETHODCALLTYPE *PbContentsRO )( 
            IObjectContrib * This,
            /* [out] */ PLinkDataRO *__MIDL_0052);
        
        HRESULT ( STDMETHODCALLTYPE *PbContentsRW )( 
            IObjectContrib * This,
            /* [out] */ PLinkDataRW *__MIDL_0053);
        
        HRESULT ( STDMETHODCALLTYPE *RgLineNo )( 
            IObjectContrib * This,
            /* [out] */ PLinkDataRO *__MIDL_0054);
        
        HRESULT ( STDMETHODCALLTYPE *RgRelocs )( 
            IObjectContrib * This,
            /* [out] */ PLinkDataRO *__MIDL_0055);
        
        HRESULT ( STDMETHODCALLTYPE *RgRelocsEx )( 
            IObjectContrib * This,
            /* [out] */ BYTE *__MIDL_0056,
            /* [in] */ DWORD __MIDL_0057);
        
        HRESULT ( STDMETHODCALLTYPE *SzSectionName )( 
            IObjectContrib * This,
            /* [out] */ PLinkDataRO *__MIDL_0058);
        
        HRESULT ( STDMETHODCALLTYPE *TkFile )( 
            IObjectContrib * This,
            /* [out] */ OBJTK *__MIDL_0059);
        
        HRESULT ( STDMETHODCALLTYPE *VirtualAddress )( 
            IObjectContrib * This,
            /* [out] */ DWORD *__MIDL_0060);
        
        END_INTERFACE
    } IObjectContribVtbl;

    interface IObjectContrib
    {
        CONST_VTBL struct IObjectContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectContrib_CbContents(This,__MIDL_0044)	\
    (This)->lpVtbl -> CbContents(This,__MIDL_0044)

#define IObjectContrib_Characteristics(This,__MIDL_0045)	\
    (This)->lpVtbl -> Characteristics(This,__MIDL_0045)

#define IObjectContrib_CLineNo(This,__MIDL_0046)	\
    (This)->lpVtbl -> CLineNo(This,__MIDL_0046)

#define IObjectContrib_CRelocs(This,__MIDL_0047)	\
    (This)->lpVtbl -> CRelocs(This,__MIDL_0047)

#define IObjectContrib_ISection(This,__MIDL_0048)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0048)

#define IObjectContrib_PbContents(This,__MIDL_0049,__MIDL_0050,__MIDL_0051)	\
    (This)->lpVtbl -> PbContents(This,__MIDL_0049,__MIDL_0050,__MIDL_0051)

#define IObjectContrib_PbContentsRO(This,__MIDL_0052)	\
    (This)->lpVtbl -> PbContentsRO(This,__MIDL_0052)

#define IObjectContrib_PbContentsRW(This,__MIDL_0053)	\
    (This)->lpVtbl -> PbContentsRW(This,__MIDL_0053)

#define IObjectContrib_RgLineNo(This,__MIDL_0054)	\
    (This)->lpVtbl -> RgLineNo(This,__MIDL_0054)

#define IObjectContrib_RgRelocs(This,__MIDL_0055)	\
    (This)->lpVtbl -> RgRelocs(This,__MIDL_0055)

#define IObjectContrib_RgRelocsEx(This,__MIDL_0056,__MIDL_0057)	\
    (This)->lpVtbl -> RgRelocsEx(This,__MIDL_0056,__MIDL_0057)

#define IObjectContrib_SzSectionName(This,__MIDL_0058)	\
    (This)->lpVtbl -> SzSectionName(This,__MIDL_0058)

#define IObjectContrib_TkFile(This,__MIDL_0059)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0059)

#define IObjectContrib_VirtualAddress(This,__MIDL_0060)	\
    (This)->lpVtbl -> VirtualAddress(This,__MIDL_0060)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectContrib_CbContents_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0044);


void __RPC_STUB IObjectContrib_CbContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_Characteristics_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0045);


void __RPC_STUB IObjectContrib_Characteristics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_CLineNo_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0046);


void __RPC_STUB IObjectContrib_CLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_CRelocs_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0047);


void __RPC_STUB IObjectContrib_CRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_ISection_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0048);


void __RPC_STUB IObjectContrib_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContents_Proxy( 
    IObjectContrib * This,
    /* [out] */ BYTE *__MIDL_0049,
    /* [in] */ DWORD __MIDL_0050,
    /* [out] */ DWORD *__MIDL_0051);


void __RPC_STUB IObjectContrib_PbContents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContentsRO_Proxy( 
    IObjectContrib * This,
    /* [out] */ PLinkDataRO *__MIDL_0052);


void __RPC_STUB IObjectContrib_PbContentsRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_PbContentsRW_Proxy( 
    IObjectContrib * This,
    /* [out] */ PLinkDataRW *__MIDL_0053);


void __RPC_STUB IObjectContrib_PbContentsRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgLineNo_Proxy( 
    IObjectContrib * This,
    /* [out] */ PLinkDataRO *__MIDL_0054);


void __RPC_STUB IObjectContrib_RgLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgRelocs_Proxy( 
    IObjectContrib * This,
    /* [out] */ PLinkDataRO *__MIDL_0055);


void __RPC_STUB IObjectContrib_RgRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_RgRelocsEx_Proxy( 
    IObjectContrib * This,
    /* [out] */ BYTE *__MIDL_0056,
    /* [in] */ DWORD __MIDL_0057);


void __RPC_STUB IObjectContrib_RgRelocsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_SzSectionName_Proxy( 
    IObjectContrib * This,
    /* [out] */ PLinkDataRO *__MIDL_0058);


void __RPC_STUB IObjectContrib_SzSectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_TkFile_Proxy( 
    IObjectContrib * This,
    /* [out] */ OBJTK *__MIDL_0059);


void __RPC_STUB IObjectContrib_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectContrib_VirtualAddress_Proxy( 
    IObjectContrib * This,
    /* [out] */ DWORD *__MIDL_0060);


void __RPC_STUB IObjectContrib_VirtualAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectContrib_INTERFACE_DEFINED__ */


#ifndef __IEnumContrib_INTERFACE_DEFINED__
#define __IEnumContrib_INTERFACE_DEFINED__

/* interface IEnumContrib */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumContrib *PEnumContrib;


EXTERN_C const IID IID_IEnumContrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6EC1C970-911F-11d1-A712-0060083E8C78")
    IEnumContrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0061,
            /* [out] */ IObjectContrib **__MIDL_0062,
            /* [out] */ ULONG *__MIDL_0063) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0064) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ PEnumContrib *__MIDL_0065) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumContribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumContrib * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumContrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumContrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumContrib * This,
            /* [in] */ ULONG __MIDL_0061,
            /* [out] */ IObjectContrib **__MIDL_0062,
            /* [out] */ ULONG *__MIDL_0063);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumContrib * This,
            /* [in] */ ULONG __MIDL_0064);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumContrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumContrib * This,
            /* [out] */ PEnumContrib *__MIDL_0065);
        
        END_INTERFACE
    } IEnumContribVtbl;

    interface IEnumContrib
    {
        CONST_VTBL struct IEnumContribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumContrib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumContrib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumContrib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumContrib_Next(This,__MIDL_0061,__MIDL_0062,__MIDL_0063)	\
    (This)->lpVtbl -> Next(This,__MIDL_0061,__MIDL_0062,__MIDL_0063)

#define IEnumContrib_Skip(This,__MIDL_0064)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0064)

#define IEnumContrib_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumContrib_Clone(This,__MIDL_0065)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0065)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumContrib_Next_Proxy( 
    IEnumContrib * This,
    /* [in] */ ULONG __MIDL_0061,
    /* [out] */ IObjectContrib **__MIDL_0062,
    /* [out] */ ULONG *__MIDL_0063);


void __RPC_STUB IEnumContrib_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Skip_Proxy( 
    IEnumContrib * This,
    /* [in] */ ULONG __MIDL_0064);


void __RPC_STUB IEnumContrib_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Reset_Proxy( 
    IEnumContrib * This);


void __RPC_STUB IEnumContrib_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumContrib_Clone_Proxy( 
    IEnumContrib * This,
    /* [out] */ PEnumContrib *__MIDL_0065);


void __RPC_STUB IEnumContrib_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumContrib_INTERFACE_DEFINED__ */


#ifndef __ICOFFAuxSym_INTERFACE_DEFINED__
#define __ICOFFAuxSym_INTERFACE_DEFINED__

/* interface ICOFFAuxSym */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFAuxSym *PCOFFAuxSym;


EXTERN_C const IID IID_ICOFFAuxSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63C3815F-9FFA-48CD-8B2B-472E795FBA94")
    ICOFFAuxSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK *__MIDL_0066) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ImgAuxSym( 
            /* [in] */ BYTE *__MIDL_0067) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Length( 
            /* [out] */ DWORD *__MIDL_0068) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CRelocs( 
            /* [out] */ DWORD *__MIDL_0069) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CLineNo( 
            /* [out] */ DWORD *__MIDL_0070) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckSum( 
            /* [out] */ DWORD *__MIDL_0071) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int *__MIDL_0072) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelType( 
            /* [out] */ BYTE *__MIDL_0073) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TagIndex( 
            /* [out] */ DWORD *__MIDL_0074) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscLineNo( 
            /* [out] */ DWORD *__MIDL_0075) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscSize( 
            /* [out] */ DWORD *__MIDL_0076) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MiscTotalSize( 
            /* [out] */ DWORD *__MIDL_0077) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FcnPLineNo( 
            /* [out] */ DWORD *__MIDL_0078) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FcnPNextFcn( 
            /* [out] */ DWORD *__MIDL_0079) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AryDim( 
            /* [in] */ DWORD *__MIDL_0080,
            /* [in] */ DWORD __MIDL_0081) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewSymCrc( 
            /* [out] */ DWORD *__MIDL_0082) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AuxType( 
            /* [out] */ BYTE *__MIDL_0083) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Tocid( 
            /* [out] */ BYTE *__MIDL_0084) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TokenDef( 
            /* [out] */ DWORD *__MIDL_0085) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFAuxSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFAuxSym * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFAuxSym * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFAuxSym * This);
        
        HRESULT ( STDMETHODCALLTYPE *TkFile )( 
            ICOFFAuxSym * This,
            /* [out] */ OBJTK *__MIDL_0066);
        
        HRESULT ( STDMETHODCALLTYPE *ImgAuxSym )( 
            ICOFFAuxSym * This,
            /* [in] */ BYTE *__MIDL_0067);
        
        HRESULT ( STDMETHODCALLTYPE *Length )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0068);
        
        HRESULT ( STDMETHODCALLTYPE *CRelocs )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0069);
        
        HRESULT ( STDMETHODCALLTYPE *CLineNo )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0070);
        
        HRESULT ( STDMETHODCALLTYPE *CheckSum )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0071);
        
        HRESULT ( STDMETHODCALLTYPE *ISection )( 
            ICOFFAuxSym * This,
            /* [out] */ int *__MIDL_0072);
        
        HRESULT ( STDMETHODCALLTYPE *SelType )( 
            ICOFFAuxSym * This,
            /* [out] */ BYTE *__MIDL_0073);
        
        HRESULT ( STDMETHODCALLTYPE *TagIndex )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0074);
        
        HRESULT ( STDMETHODCALLTYPE *MiscLineNo )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0075);
        
        HRESULT ( STDMETHODCALLTYPE *MiscSize )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0076);
        
        HRESULT ( STDMETHODCALLTYPE *MiscTotalSize )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0077);
        
        HRESULT ( STDMETHODCALLTYPE *FcnPLineNo )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0078);
        
        HRESULT ( STDMETHODCALLTYPE *FcnPNextFcn )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0079);
        
        HRESULT ( STDMETHODCALLTYPE *AryDim )( 
            ICOFFAuxSym * This,
            /* [in] */ DWORD *__MIDL_0080,
            /* [in] */ DWORD __MIDL_0081);
        
        HRESULT ( STDMETHODCALLTYPE *NewSymCrc )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0082);
        
        HRESULT ( STDMETHODCALLTYPE *AuxType )( 
            ICOFFAuxSym * This,
            /* [out] */ BYTE *__MIDL_0083);
        
        HRESULT ( STDMETHODCALLTYPE *Tocid )( 
            ICOFFAuxSym * This,
            /* [out] */ BYTE *__MIDL_0084);
        
        HRESULT ( STDMETHODCALLTYPE *TokenDef )( 
            ICOFFAuxSym * This,
            /* [out] */ DWORD *__MIDL_0085);
        
        END_INTERFACE
    } ICOFFAuxSymVtbl;

    interface ICOFFAuxSym
    {
        CONST_VTBL struct ICOFFAuxSymVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFAuxSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFAuxSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFAuxSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFAuxSym_TkFile(This,__MIDL_0066)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0066)

#define ICOFFAuxSym_ImgAuxSym(This,__MIDL_0067)	\
    (This)->lpVtbl -> ImgAuxSym(This,__MIDL_0067)

#define ICOFFAuxSym_Length(This,__MIDL_0068)	\
    (This)->lpVtbl -> Length(This,__MIDL_0068)

#define ICOFFAuxSym_CRelocs(This,__MIDL_0069)	\
    (This)->lpVtbl -> CRelocs(This,__MIDL_0069)

#define ICOFFAuxSym_CLineNo(This,__MIDL_0070)	\
    (This)->lpVtbl -> CLineNo(This,__MIDL_0070)

#define ICOFFAuxSym_CheckSum(This,__MIDL_0071)	\
    (This)->lpVtbl -> CheckSum(This,__MIDL_0071)

#define ICOFFAuxSym_ISection(This,__MIDL_0072)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0072)

#define ICOFFAuxSym_SelType(This,__MIDL_0073)	\
    (This)->lpVtbl -> SelType(This,__MIDL_0073)

#define ICOFFAuxSym_TagIndex(This,__MIDL_0074)	\
    (This)->lpVtbl -> TagIndex(This,__MIDL_0074)

#define ICOFFAuxSym_MiscLineNo(This,__MIDL_0075)	\
    (This)->lpVtbl -> MiscLineNo(This,__MIDL_0075)

#define ICOFFAuxSym_MiscSize(This,__MIDL_0076)	\
    (This)->lpVtbl -> MiscSize(This,__MIDL_0076)

#define ICOFFAuxSym_MiscTotalSize(This,__MIDL_0077)	\
    (This)->lpVtbl -> MiscTotalSize(This,__MIDL_0077)

#define ICOFFAuxSym_FcnPLineNo(This,__MIDL_0078)	\
    (This)->lpVtbl -> FcnPLineNo(This,__MIDL_0078)

#define ICOFFAuxSym_FcnPNextFcn(This,__MIDL_0079)	\
    (This)->lpVtbl -> FcnPNextFcn(This,__MIDL_0079)

#define ICOFFAuxSym_AryDim(This,__MIDL_0080,__MIDL_0081)	\
    (This)->lpVtbl -> AryDim(This,__MIDL_0080,__MIDL_0081)

#define ICOFFAuxSym_NewSymCrc(This,__MIDL_0082)	\
    (This)->lpVtbl -> NewSymCrc(This,__MIDL_0082)

#define ICOFFAuxSym_AuxType(This,__MIDL_0083)	\
    (This)->lpVtbl -> AuxType(This,__MIDL_0083)

#define ICOFFAuxSym_Tocid(This,__MIDL_0084)	\
    (This)->lpVtbl -> Tocid(This,__MIDL_0084)

#define ICOFFAuxSym_TokenDef(This,__MIDL_0085)	\
    (This)->lpVtbl -> TokenDef(This,__MIDL_0085)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFAuxSym_TkFile_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ OBJTK *__MIDL_0066);


void __RPC_STUB ICOFFAuxSym_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_ImgAuxSym_Proxy( 
    ICOFFAuxSym * This,
    /* [in] */ BYTE *__MIDL_0067);


void __RPC_STUB ICOFFAuxSym_ImgAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_Length_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0068);


void __RPC_STUB ICOFFAuxSym_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CRelocs_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0069);


void __RPC_STUB ICOFFAuxSym_CRelocs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CLineNo_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0070);


void __RPC_STUB ICOFFAuxSym_CLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_CheckSum_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0071);


void __RPC_STUB ICOFFAuxSym_CheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_ISection_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ int *__MIDL_0072);


void __RPC_STUB ICOFFAuxSym_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_SelType_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ BYTE *__MIDL_0073);


void __RPC_STUB ICOFFAuxSym_SelType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_TagIndex_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0074);


void __RPC_STUB ICOFFAuxSym_TagIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscLineNo_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0075);


void __RPC_STUB ICOFFAuxSym_MiscLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscSize_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0076);


void __RPC_STUB ICOFFAuxSym_MiscSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_MiscTotalSize_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0077);


void __RPC_STUB ICOFFAuxSym_MiscTotalSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_FcnPLineNo_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0078);


void __RPC_STUB ICOFFAuxSym_FcnPLineNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_FcnPNextFcn_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0079);


void __RPC_STUB ICOFFAuxSym_FcnPNextFcn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_AryDim_Proxy( 
    ICOFFAuxSym * This,
    /* [in] */ DWORD *__MIDL_0080,
    /* [in] */ DWORD __MIDL_0081);


void __RPC_STUB ICOFFAuxSym_AryDim_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_NewSymCrc_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0082);


void __RPC_STUB ICOFFAuxSym_NewSymCrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_AuxType_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ BYTE *__MIDL_0083);


void __RPC_STUB ICOFFAuxSym_AuxType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_Tocid_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ BYTE *__MIDL_0084);


void __RPC_STUB ICOFFAuxSym_Tocid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFAuxSym_TokenDef_Proxy( 
    ICOFFAuxSym * This,
    /* [out] */ DWORD *__MIDL_0085);


void __RPC_STUB ICOFFAuxSym_TokenDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFAuxSym_INTERFACE_DEFINED__ */


#ifndef __IEnumAuxSym_INTERFACE_DEFINED__
#define __IEnumAuxSym_INTERFACE_DEFINED__

/* interface IEnumAuxSym */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumAuxSym *PEnumAuxSym;


EXTERN_C const IID IID_IEnumAuxSym;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("083DE150-B461-11d1-A71B-0060083E8C78")
    IEnumAuxSym : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0086,
            /* [out] */ ICOFFAuxSym **__MIDL_0087,
            /* [out] */ ULONG *__MIDL_0088) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0089) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumAuxSym **__MIDL_0090) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAuxSymVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAuxSym * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAuxSym * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAuxSym * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAuxSym * This,
            /* [in] */ ULONG __MIDL_0086,
            /* [out] */ ICOFFAuxSym **__MIDL_0087,
            /* [out] */ ULONG *__MIDL_0088);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAuxSym * This,
            /* [in] */ ULONG __MIDL_0089);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAuxSym * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAuxSym * This,
            /* [out] */ IEnumAuxSym **__MIDL_0090);
        
        END_INTERFACE
    } IEnumAuxSymVtbl;

    interface IEnumAuxSym
    {
        CONST_VTBL struct IEnumAuxSymVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAuxSym_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAuxSym_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAuxSym_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAuxSym_Next(This,__MIDL_0086,__MIDL_0087,__MIDL_0088)	\
    (This)->lpVtbl -> Next(This,__MIDL_0086,__MIDL_0087,__MIDL_0088)

#define IEnumAuxSym_Skip(This,__MIDL_0089)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0089)

#define IEnumAuxSym_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAuxSym_Clone(This,__MIDL_0090)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0090)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAuxSym_Next_Proxy( 
    IEnumAuxSym * This,
    /* [in] */ ULONG __MIDL_0086,
    /* [out] */ ICOFFAuxSym **__MIDL_0087,
    /* [out] */ ULONG *__MIDL_0088);


void __RPC_STUB IEnumAuxSym_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Skip_Proxy( 
    IEnumAuxSym * This,
    /* [in] */ ULONG __MIDL_0089);


void __RPC_STUB IEnumAuxSym_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Reset_Proxy( 
    IEnumAuxSym * This);


void __RPC_STUB IEnumAuxSym_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAuxSym_Clone_Proxy( 
    IEnumAuxSym * This,
    /* [out] */ IEnumAuxSym **__MIDL_0090);


void __RPC_STUB IEnumAuxSym_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAuxSym_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymRO_INTERFACE_DEFINED__
#define __ICOFFSymRO_INTERFACE_DEFINED__

/* interface ICOFFSymRO */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFSymRO *PCOFFSymRO;


EXTERN_C const IID IID_ICOFFSymRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CBDFD0D1-B21F-11d1-A71B-0060083E8C78")
    ICOFFSymRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CAuxSym( 
            /* [out] */ BYTE *__MIDL_0091) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int *__MIDL_0092) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ DWORD *__MIDL_0093) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StorageClass( 
            /* [out] */ BYTE *__MIDL_0094) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzFile( 
            /* [out] */ PLinkDataRO *__MIDL_0095) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO *__MIDL_0096) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK *__MIDL_0097) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Type( 
            /* [out] */ WORD *__MIDL_0098) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Value( 
            /* [out] */ DWORD *__MIDL_0099) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAuxSym( 
            /* [out] */ IEnumAuxSym **__MIDL_0100) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFSymRO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFSymRO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFSymRO * This);
        
        HRESULT ( STDMETHODCALLTYPE *CAuxSym )( 
            ICOFFSymRO * This,
            /* [out] */ BYTE *__MIDL_0091);
        
        HRESULT ( STDMETHODCALLTYPE *ISection )( 
            ICOFFSymRO * This,
            /* [out] */ int *__MIDL_0092);
        
        HRESULT ( STDMETHODCALLTYPE *ISym )( 
            ICOFFSymRO * This,
            /* [out] */ DWORD *__MIDL_0093);
        
        HRESULT ( STDMETHODCALLTYPE *StorageClass )( 
            ICOFFSymRO * This,
            /* [out] */ BYTE *__MIDL_0094);
        
        HRESULT ( STDMETHODCALLTYPE *SzFile )( 
            ICOFFSymRO * This,
            /* [out] */ PLinkDataRO *__MIDL_0095);
        
        HRESULT ( STDMETHODCALLTYPE *SzName )( 
            ICOFFSymRO * This,
            /* [out] */ PLinkDataRO *__MIDL_0096);
        
        HRESULT ( STDMETHODCALLTYPE *TkFile )( 
            ICOFFSymRO * This,
            /* [out] */ OBJTK *__MIDL_0097);
        
        HRESULT ( STDMETHODCALLTYPE *Type )( 
            ICOFFSymRO * This,
            /* [out] */ WORD *__MIDL_0098);
        
        HRESULT ( STDMETHODCALLTYPE *Value )( 
            ICOFFSymRO * This,
            /* [out] */ DWORD *__MIDL_0099);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAuxSym )( 
            ICOFFSymRO * This,
            /* [out] */ IEnumAuxSym **__MIDL_0100);
        
        END_INTERFACE
    } ICOFFSymROVtbl;

    interface ICOFFSymRO
    {
        CONST_VTBL struct ICOFFSymROVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymRO_CAuxSym(This,__MIDL_0091)	\
    (This)->lpVtbl -> CAuxSym(This,__MIDL_0091)

#define ICOFFSymRO_ISection(This,__MIDL_0092)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0092)

#define ICOFFSymRO_ISym(This,__MIDL_0093)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0093)

#define ICOFFSymRO_StorageClass(This,__MIDL_0094)	\
    (This)->lpVtbl -> StorageClass(This,__MIDL_0094)

#define ICOFFSymRO_SzFile(This,__MIDL_0095)	\
    (This)->lpVtbl -> SzFile(This,__MIDL_0095)

#define ICOFFSymRO_SzName(This,__MIDL_0096)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0096)

#define ICOFFSymRO_TkFile(This,__MIDL_0097)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0097)

#define ICOFFSymRO_Type(This,__MIDL_0098)	\
    (This)->lpVtbl -> Type(This,__MIDL_0098)

#define ICOFFSymRO_Value(This,__MIDL_0099)	\
    (This)->lpVtbl -> Value(This,__MIDL_0099)

#define ICOFFSymRO_EnumAuxSym(This,__MIDL_0100)	\
    (This)->lpVtbl -> EnumAuxSym(This,__MIDL_0100)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymRO_CAuxSym_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ BYTE *__MIDL_0091);


void __RPC_STUB ICOFFSymRO_CAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_ISection_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ int *__MIDL_0092);


void __RPC_STUB ICOFFSymRO_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_ISym_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ DWORD *__MIDL_0093);


void __RPC_STUB ICOFFSymRO_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_StorageClass_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ BYTE *__MIDL_0094);


void __RPC_STUB ICOFFSymRO_StorageClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_SzFile_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ PLinkDataRO *__MIDL_0095);


void __RPC_STUB ICOFFSymRO_SzFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_SzName_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ PLinkDataRO *__MIDL_0096);


void __RPC_STUB ICOFFSymRO_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_TkFile_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ OBJTK *__MIDL_0097);


void __RPC_STUB ICOFFSymRO_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_Type_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ WORD *__MIDL_0098);


void __RPC_STUB ICOFFSymRO_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_Value_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ DWORD *__MIDL_0099);


void __RPC_STUB ICOFFSymRO_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRO_EnumAuxSym_Proxy( 
    ICOFFSymRO * This,
    /* [out] */ IEnumAuxSym **__MIDL_0100);


void __RPC_STUB ICOFFSymRO_EnumAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymRO_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymRW_INTERFACE_DEFINED__
#define __ICOFFSymRW_INTERFACE_DEFINED__

/* interface ICOFFSymRW */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFSymRW *PCOFFSymRW;


EXTERN_C const IID IID_ICOFFSymRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B966F266-47C9-42EE-BF73-E8B006231883")
    ICOFFSymRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CAuxSym( 
            /* [out] */ BYTE *__MIDL_0101) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISection( 
            /* [out] */ int *__MIDL_0102) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISym( 
            /* [out] */ DWORD *__MIDL_0103) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StorageClass( 
            /* [out] */ BYTE *__MIDL_0104) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzFile( 
            /* [out] */ PLinkDataRO *__MIDL_0105) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzName( 
            /* [out] */ PLinkDataRO *__MIDL_0106) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TkFile( 
            /* [out] */ OBJTK *__MIDL_0107) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Type( 
            /* [out] */ WORD *__MIDL_0108) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Value( 
            /* [out] */ DWORD *__MIDL_0109) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAuxSym( 
            /* [out] */ IEnumAuxSym **__MIDL_0110) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetISection( 
            /* [in] */ int __MIDL_0111) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ WORD __MIDL_0112) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ DWORD __MIDL_0113) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFSymRW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFSymRW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFSymRW * This);
        
        HRESULT ( STDMETHODCALLTYPE *CAuxSym )( 
            ICOFFSymRW * This,
            /* [out] */ BYTE *__MIDL_0101);
        
        HRESULT ( STDMETHODCALLTYPE *ISection )( 
            ICOFFSymRW * This,
            /* [out] */ int *__MIDL_0102);
        
        HRESULT ( STDMETHODCALLTYPE *ISym )( 
            ICOFFSymRW * This,
            /* [out] */ DWORD *__MIDL_0103);
        
        HRESULT ( STDMETHODCALLTYPE *StorageClass )( 
            ICOFFSymRW * This,
            /* [out] */ BYTE *__MIDL_0104);
        
        HRESULT ( STDMETHODCALLTYPE *SzFile )( 
            ICOFFSymRW * This,
            /* [out] */ PLinkDataRO *__MIDL_0105);
        
        HRESULT ( STDMETHODCALLTYPE *SzName )( 
            ICOFFSymRW * This,
            /* [out] */ PLinkDataRO *__MIDL_0106);
        
        HRESULT ( STDMETHODCALLTYPE *TkFile )( 
            ICOFFSymRW * This,
            /* [out] */ OBJTK *__MIDL_0107);
        
        HRESULT ( STDMETHODCALLTYPE *Type )( 
            ICOFFSymRW * This,
            /* [out] */ WORD *__MIDL_0108);
        
        HRESULT ( STDMETHODCALLTYPE *Value )( 
            ICOFFSymRW * This,
            /* [out] */ DWORD *__MIDL_0109);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAuxSym )( 
            ICOFFSymRW * This,
            /* [out] */ IEnumAuxSym **__MIDL_0110);
        
        HRESULT ( STDMETHODCALLTYPE *SetISection )( 
            ICOFFSymRW * This,
            /* [in] */ int __MIDL_0111);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            ICOFFSymRW * This,
            /* [in] */ WORD __MIDL_0112);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICOFFSymRW * This,
            /* [in] */ DWORD __MIDL_0113);
        
        END_INTERFACE
    } ICOFFSymRWVtbl;

    interface ICOFFSymRW
    {
        CONST_VTBL struct ICOFFSymRWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymRW_CAuxSym(This,__MIDL_0101)	\
    (This)->lpVtbl -> CAuxSym(This,__MIDL_0101)

#define ICOFFSymRW_ISection(This,__MIDL_0102)	\
    (This)->lpVtbl -> ISection(This,__MIDL_0102)

#define ICOFFSymRW_ISym(This,__MIDL_0103)	\
    (This)->lpVtbl -> ISym(This,__MIDL_0103)

#define ICOFFSymRW_StorageClass(This,__MIDL_0104)	\
    (This)->lpVtbl -> StorageClass(This,__MIDL_0104)

#define ICOFFSymRW_SzFile(This,__MIDL_0105)	\
    (This)->lpVtbl -> SzFile(This,__MIDL_0105)

#define ICOFFSymRW_SzName(This,__MIDL_0106)	\
    (This)->lpVtbl -> SzName(This,__MIDL_0106)

#define ICOFFSymRW_TkFile(This,__MIDL_0107)	\
    (This)->lpVtbl -> TkFile(This,__MIDL_0107)

#define ICOFFSymRW_Type(This,__MIDL_0108)	\
    (This)->lpVtbl -> Type(This,__MIDL_0108)

#define ICOFFSymRW_Value(This,__MIDL_0109)	\
    (This)->lpVtbl -> Value(This,__MIDL_0109)

#define ICOFFSymRW_EnumAuxSym(This,__MIDL_0110)	\
    (This)->lpVtbl -> EnumAuxSym(This,__MIDL_0110)

#define ICOFFSymRW_SetISection(This,__MIDL_0111)	\
    (This)->lpVtbl -> SetISection(This,__MIDL_0111)

#define ICOFFSymRW_SetType(This,__MIDL_0112)	\
    (This)->lpVtbl -> SetType(This,__MIDL_0112)

#define ICOFFSymRW_SetValue(This,__MIDL_0113)	\
    (This)->lpVtbl -> SetValue(This,__MIDL_0113)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymRW_CAuxSym_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ BYTE *__MIDL_0101);


void __RPC_STUB ICOFFSymRW_CAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_ISection_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ int *__MIDL_0102);


void __RPC_STUB ICOFFSymRW_ISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_ISym_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ DWORD *__MIDL_0103);


void __RPC_STUB ICOFFSymRW_ISym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_StorageClass_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ BYTE *__MIDL_0104);


void __RPC_STUB ICOFFSymRW_StorageClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SzFile_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ PLinkDataRO *__MIDL_0105);


void __RPC_STUB ICOFFSymRW_SzFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SzName_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ PLinkDataRO *__MIDL_0106);


void __RPC_STUB ICOFFSymRW_SzName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_TkFile_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ OBJTK *__MIDL_0107);


void __RPC_STUB ICOFFSymRW_TkFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_Type_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ WORD *__MIDL_0108);


void __RPC_STUB ICOFFSymRW_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_Value_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ DWORD *__MIDL_0109);


void __RPC_STUB ICOFFSymRW_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_EnumAuxSym_Proxy( 
    ICOFFSymRW * This,
    /* [out] */ IEnumAuxSym **__MIDL_0110);


void __RPC_STUB ICOFFSymRW_EnumAuxSym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SetISection_Proxy( 
    ICOFFSymRW * This,
    /* [in] */ int __MIDL_0111);


void __RPC_STUB ICOFFSymRW_SetISection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SetType_Proxy( 
    ICOFFSymRW * This,
    /* [in] */ WORD __MIDL_0112);


void __RPC_STUB ICOFFSymRW_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymRW_SetValue_Proxy( 
    ICOFFSymRW * This,
    /* [in] */ DWORD __MIDL_0113);


void __RPC_STUB ICOFFSymRW_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymRW_INTERFACE_DEFINED__ */


#ifndef __IEnumCOFFSymRO_INTERFACE_DEFINED__
#define __IEnumCOFFSymRO_INTERFACE_DEFINED__

/* interface IEnumCOFFSymRO */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumCOFFSymRO *PEnumCOFFSymRO;


EXTERN_C const IID IID_IEnumCOFFSymRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33640AD0-B2C6-11d1-A71B-0060083E8C78")
    IEnumCOFFSymRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0114,
            /* [out] */ ICOFFSymRO **__MIDL_0115,
            /* [out] */ ULONG *__MIDL_0116) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0117) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCOFFSymRO **__MIDL_0118) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCOFFSymROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCOFFSymRO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCOFFSymRO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCOFFSymRO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCOFFSymRO * This,
            /* [in] */ ULONG __MIDL_0114,
            /* [out] */ ICOFFSymRO **__MIDL_0115,
            /* [out] */ ULONG *__MIDL_0116);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCOFFSymRO * This,
            /* [in] */ ULONG __MIDL_0117);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCOFFSymRO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCOFFSymRO * This,
            /* [out] */ IEnumCOFFSymRO **__MIDL_0118);
        
        END_INTERFACE
    } IEnumCOFFSymROVtbl;

    interface IEnumCOFFSymRO
    {
        CONST_VTBL struct IEnumCOFFSymROVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCOFFSymRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCOFFSymRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCOFFSymRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCOFFSymRO_Next(This,__MIDL_0114,__MIDL_0115,__MIDL_0116)	\
    (This)->lpVtbl -> Next(This,__MIDL_0114,__MIDL_0115,__MIDL_0116)

#define IEnumCOFFSymRO_Skip(This,__MIDL_0117)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0117)

#define IEnumCOFFSymRO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCOFFSymRO_Clone(This,__MIDL_0118)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0118)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Next_Proxy( 
    IEnumCOFFSymRO * This,
    /* [in] */ ULONG __MIDL_0114,
    /* [out] */ ICOFFSymRO **__MIDL_0115,
    /* [out] */ ULONG *__MIDL_0116);


void __RPC_STUB IEnumCOFFSymRO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Skip_Proxy( 
    IEnumCOFFSymRO * This,
    /* [in] */ ULONG __MIDL_0117);


void __RPC_STUB IEnumCOFFSymRO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Reset_Proxy( 
    IEnumCOFFSymRO * This);


void __RPC_STUB IEnumCOFFSymRO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRO_Clone_Proxy( 
    IEnumCOFFSymRO * This,
    /* [out] */ IEnumCOFFSymRO **__MIDL_0118);


void __RPC_STUB IEnumCOFFSymRO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCOFFSymRO_INTERFACE_DEFINED__ */


#ifndef __IEnumCOFFSymRW_INTERFACE_DEFINED__
#define __IEnumCOFFSymRW_INTERFACE_DEFINED__

/* interface IEnumCOFFSymRW */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumCOFFSymRW *PEnumCOFFSymRW;


EXTERN_C const IID IID_IEnumCOFFSymRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01B3C322-B2FC-11d1-A71B-0060083E8C78")
    IEnumCOFFSymRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG __MIDL_0119,
            /* [out] */ ICOFFSymRW **__MIDL_0120,
            /* [out] */ ULONG *__MIDL_0121) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG __MIDL_0122) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCOFFSymRW **__MIDL_0123) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCOFFSymRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCOFFSymRW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCOFFSymRW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCOFFSymRW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCOFFSymRW * This,
            /* [in] */ ULONG __MIDL_0119,
            /* [out] */ ICOFFSymRW **__MIDL_0120,
            /* [out] */ ULONG *__MIDL_0121);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCOFFSymRW * This,
            /* [in] */ ULONG __MIDL_0122);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCOFFSymRW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCOFFSymRW * This,
            /* [out] */ IEnumCOFFSymRW **__MIDL_0123);
        
        END_INTERFACE
    } IEnumCOFFSymRWVtbl;

    interface IEnumCOFFSymRW
    {
        CONST_VTBL struct IEnumCOFFSymRWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCOFFSymRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCOFFSymRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCOFFSymRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCOFFSymRW_Next(This,__MIDL_0119,__MIDL_0120,__MIDL_0121)	\
    (This)->lpVtbl -> Next(This,__MIDL_0119,__MIDL_0120,__MIDL_0121)

#define IEnumCOFFSymRW_Skip(This,__MIDL_0122)	\
    (This)->lpVtbl -> Skip(This,__MIDL_0122)

#define IEnumCOFFSymRW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCOFFSymRW_Clone(This,__MIDL_0123)	\
    (This)->lpVtbl -> Clone(This,__MIDL_0123)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Next_Proxy( 
    IEnumCOFFSymRW * This,
    /* [in] */ ULONG __MIDL_0119,
    /* [out] */ ICOFFSymRW **__MIDL_0120,
    /* [out] */ ULONG *__MIDL_0121);


void __RPC_STUB IEnumCOFFSymRW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Skip_Proxy( 
    IEnumCOFFSymRW * This,
    /* [in] */ ULONG __MIDL_0122);


void __RPC_STUB IEnumCOFFSymRW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Reset_Proxy( 
    IEnumCOFFSymRW * This);


void __RPC_STUB IEnumCOFFSymRW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCOFFSymRW_Clone_Proxy( 
    IEnumCOFFSymRW * This,
    /* [out] */ IEnumCOFFSymRW **__MIDL_0123);


void __RPC_STUB IEnumCOFFSymRW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCOFFSymRW_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymTabRO_INTERFACE_DEFINED__
#define __ICOFFSymTabRO_INTERFACE_DEFINED__

/* interface ICOFFSymTabRO */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFSymTabRO *PCOFFSymTabRO;


EXTERN_C const IID IID_ICOFFSymTabRO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CBDFD0D0-B21F-11d1-A71B-0060083E8C78")
    ICOFFSymTabRO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD *__MIDL_0124) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOFFSymRO( 
            /* [in] */ DWORD __MIDL_0125,
            /* [out] */ ICOFFSymRO **__MIDL_0126) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISYMNextCOFFSymRO( 
            /* [in] */ ICOFFSymRO *__MIDL_0127,
            /* [out] */ DWORD *__MIDL_0128) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmitCOFFSymbolTable( 
            /* [out] */ BYTE *__MIDL_0129,
            /* [in] */ DWORD __MIDL_0130) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCOFFSymRO( 
            /* [out] */ IEnumCOFFSymRO **__MIDL_0131) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymTabROVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFSymTabRO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFSymTabRO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFSymTabRO * This);
        
        HRESULT ( STDMETHODCALLTYPE *CSymbols )( 
            ICOFFSymTabRO * This,
            /* [out] */ DWORD *__MIDL_0124);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOFFSymRO )( 
            ICOFFSymTabRO * This,
            /* [in] */ DWORD __MIDL_0125,
            /* [out] */ ICOFFSymRO **__MIDL_0126);
        
        HRESULT ( STDMETHODCALLTYPE *ISYMNextCOFFSymRO )( 
            ICOFFSymTabRO * This,
            /* [in] */ ICOFFSymRO *__MIDL_0127,
            /* [out] */ DWORD *__MIDL_0128);
        
        HRESULT ( STDMETHODCALLTYPE *EmitCOFFSymbolTable )( 
            ICOFFSymTabRO * This,
            /* [out] */ BYTE *__MIDL_0129,
            /* [in] */ DWORD __MIDL_0130);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCOFFSymRO )( 
            ICOFFSymTabRO * This,
            /* [out] */ IEnumCOFFSymRO **__MIDL_0131);
        
        END_INTERFACE
    } ICOFFSymTabROVtbl;

    interface ICOFFSymTabRO
    {
        CONST_VTBL struct ICOFFSymTabROVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymTabRO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymTabRO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymTabRO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymTabRO_CSymbols(This,__MIDL_0124)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0124)

#define ICOFFSymTabRO_GetCOFFSymRO(This,__MIDL_0125,__MIDL_0126)	\
    (This)->lpVtbl -> GetCOFFSymRO(This,__MIDL_0125,__MIDL_0126)

#define ICOFFSymTabRO_ISYMNextCOFFSymRO(This,__MIDL_0127,__MIDL_0128)	\
    (This)->lpVtbl -> ISYMNextCOFFSymRO(This,__MIDL_0127,__MIDL_0128)

#define ICOFFSymTabRO_EmitCOFFSymbolTable(This,__MIDL_0129,__MIDL_0130)	\
    (This)->lpVtbl -> EmitCOFFSymbolTable(This,__MIDL_0129,__MIDL_0130)

#define ICOFFSymTabRO_EnumCOFFSymRO(This,__MIDL_0131)	\
    (This)->lpVtbl -> EnumCOFFSymRO(This,__MIDL_0131)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_CSymbols_Proxy( 
    ICOFFSymTabRO * This,
    /* [out] */ DWORD *__MIDL_0124);


void __RPC_STUB ICOFFSymTabRO_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_GetCOFFSymRO_Proxy( 
    ICOFFSymTabRO * This,
    /* [in] */ DWORD __MIDL_0125,
    /* [out] */ ICOFFSymRO **__MIDL_0126);


void __RPC_STUB ICOFFSymTabRO_GetCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_ISYMNextCOFFSymRO_Proxy( 
    ICOFFSymTabRO * This,
    /* [in] */ ICOFFSymRO *__MIDL_0127,
    /* [out] */ DWORD *__MIDL_0128);


void __RPC_STUB ICOFFSymTabRO_ISYMNextCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_EmitCOFFSymbolTable_Proxy( 
    ICOFFSymTabRO * This,
    /* [out] */ BYTE *__MIDL_0129,
    /* [in] */ DWORD __MIDL_0130);


void __RPC_STUB ICOFFSymTabRO_EmitCOFFSymbolTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRO_EnumCOFFSymRO_Proxy( 
    ICOFFSymTabRO * This,
    /* [out] */ IEnumCOFFSymRO **__MIDL_0131);


void __RPC_STUB ICOFFSymTabRO_EnumCOFFSymRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymTabRO_INTERFACE_DEFINED__ */


#ifndef __ICOFFSymTabRW_INTERFACE_DEFINED__
#define __ICOFFSymTabRW_INTERFACE_DEFINED__

/* interface ICOFFSymTabRW */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFSymTabRW *PCOFFSymTabRW;


EXTERN_C const IID IID_ICOFFSymTabRW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D2C4950-B788-11d1-A71B-0060083E8C78")
    ICOFFSymTabRW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD *__MIDL_0132) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCOFFSymRW( 
            /* [in] */ DWORD __MIDL_0133,
            /* [out] */ ICOFFSymRW **__MIDL_0134) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ISYMNextCOFFSymRW( 
            /* [in] */ ICOFFSymRW *__MIDL_0135,
            /* [out] */ DWORD *__MIDL_0136) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmitCOFFSymbolTable( 
            /* [out] */ BYTE *__MIDL_0137,
            /* [in] */ DWORD __MIDL_0138) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCOFFSymRW( 
            /* [out] */ IEnumCOFFSymRW **__MIDL_0139) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFSymTabRWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFSymTabRW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFSymTabRW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFSymTabRW * This);
        
        HRESULT ( STDMETHODCALLTYPE *CSymbols )( 
            ICOFFSymTabRW * This,
            /* [out] */ DWORD *__MIDL_0132);
        
        HRESULT ( STDMETHODCALLTYPE *GetCOFFSymRW )( 
            ICOFFSymTabRW * This,
            /* [in] */ DWORD __MIDL_0133,
            /* [out] */ ICOFFSymRW **__MIDL_0134);
        
        HRESULT ( STDMETHODCALLTYPE *ISYMNextCOFFSymRW )( 
            ICOFFSymTabRW * This,
            /* [in] */ ICOFFSymRW *__MIDL_0135,
            /* [out] */ DWORD *__MIDL_0136);
        
        HRESULT ( STDMETHODCALLTYPE *EmitCOFFSymbolTable )( 
            ICOFFSymTabRW * This,
            /* [out] */ BYTE *__MIDL_0137,
            /* [in] */ DWORD __MIDL_0138);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCOFFSymRW )( 
            ICOFFSymTabRW * This,
            /* [out] */ IEnumCOFFSymRW **__MIDL_0139);
        
        END_INTERFACE
    } ICOFFSymTabRWVtbl;

    interface ICOFFSymTabRW
    {
        CONST_VTBL struct ICOFFSymTabRWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFSymTabRW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFSymTabRW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFSymTabRW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFSymTabRW_CSymbols(This,__MIDL_0132)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0132)

#define ICOFFSymTabRW_GetCOFFSymRW(This,__MIDL_0133,__MIDL_0134)	\
    (This)->lpVtbl -> GetCOFFSymRW(This,__MIDL_0133,__MIDL_0134)

#define ICOFFSymTabRW_ISYMNextCOFFSymRW(This,__MIDL_0135,__MIDL_0136)	\
    (This)->lpVtbl -> ISYMNextCOFFSymRW(This,__MIDL_0135,__MIDL_0136)

#define ICOFFSymTabRW_EmitCOFFSymbolTable(This,__MIDL_0137,__MIDL_0138)	\
    (This)->lpVtbl -> EmitCOFFSymbolTable(This,__MIDL_0137,__MIDL_0138)

#define ICOFFSymTabRW_EnumCOFFSymRW(This,__MIDL_0139)	\
    (This)->lpVtbl -> EnumCOFFSymRW(This,__MIDL_0139)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_CSymbols_Proxy( 
    ICOFFSymTabRW * This,
    /* [out] */ DWORD *__MIDL_0132);


void __RPC_STUB ICOFFSymTabRW_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_GetCOFFSymRW_Proxy( 
    ICOFFSymTabRW * This,
    /* [in] */ DWORD __MIDL_0133,
    /* [out] */ ICOFFSymRW **__MIDL_0134);


void __RPC_STUB ICOFFSymTabRW_GetCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_ISYMNextCOFFSymRW_Proxy( 
    ICOFFSymTabRW * This,
    /* [in] */ ICOFFSymRW *__MIDL_0135,
    /* [out] */ DWORD *__MIDL_0136);


void __RPC_STUB ICOFFSymTabRW_ISYMNextCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_EmitCOFFSymbolTable_Proxy( 
    ICOFFSymTabRW * This,
    /* [out] */ BYTE *__MIDL_0137,
    /* [in] */ DWORD __MIDL_0138);


void __RPC_STUB ICOFFSymTabRW_EmitCOFFSymbolTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFSymTabRW_EnumCOFFSymRW_Proxy( 
    ICOFFSymTabRW * This,
    /* [out] */ IEnumCOFFSymRW **__MIDL_0139);


void __RPC_STUB ICOFFSymTabRW_EnumCOFFSymRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFSymTabRW_INTERFACE_DEFINED__ */


#ifndef __ICOFFObj_INTERFACE_DEFINED__
#define __ICOFFObj_INTERFACE_DEFINED__

/* interface ICOFFObj */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICOFFObj *PCOFFObj;


EXTERN_C const IID IID_ICOFFObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9470BB0-911F-11d1-A712-0060083E8C78")
    ICOFFObj : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginOptCaching( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CContrib( 
            /* [out] */ DWORD *__MIDL_0140) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ BOOL __MIDL_0141) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COFFTimeStamp( 
            /* [out] */ DWORD *__MIDL_0142) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CSymbols( 
            /* [out] */ DWORD *__MIDL_0143) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOptCaching( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContrib( 
            /* [out] */ IEnumContrib **__MIDL_0144) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContribForISec( 
            /* [in] */ DWORD __MIDL_0145,
            /* [out] */ IObjectContrib **__MIDL_0146) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FImportObj( 
            /* [out] */ BOOL *__MIDL_0147) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringTable( 
            /* [out] */ PLinkDataRO *__MIDL_0148) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolTableRO( 
            /* [out] */ ICOFFSymTabRO **__MIDL_0149) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolTableRW( 
            /* [out] */ ICOFFSymTabRW **__MIDL_0150) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjtkFromSzSymbol( 
            /* [in] */ PLinkDataRO __MIDL_0151,
            /* [out] */ OBJTK *__MIDL_0152) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeStamp( 
            /* [out] */ DWORD *__MIDL_0153) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SzRefForIsym( 
            /* [in] */ ISYM __MIDL_0154,
            /* [out] */ PLinkDataRO *__MIDL_0155) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICOFFObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICOFFObj * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICOFFObj * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICOFFObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginOptCaching )( 
            ICOFFObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *CContrib )( 
            ICOFFObj * This,
            /* [out] */ DWORD *__MIDL_0140);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ICOFFObj * This,
            /* [in] */ BOOL __MIDL_0141);
        
        HRESULT ( STDMETHODCALLTYPE *COFFTimeStamp )( 
            ICOFFObj * This,
            /* [out] */ DWORD *__MIDL_0142);
        
        HRESULT ( STDMETHODCALLTYPE *CSymbols )( 
            ICOFFObj * This,
            /* [out] */ DWORD *__MIDL_0143);
        
        HRESULT ( STDMETHODCALLTYPE *EndOptCaching )( 
            ICOFFObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContrib )( 
            ICOFFObj * This,
            /* [out] */ IEnumContrib **__MIDL_0144);
        
        HRESULT ( STDMETHODCALLTYPE *GetContribForISec )( 
            ICOFFObj * This,
            /* [in] */ DWORD __MIDL_0145,
            /* [out] */ IObjectContrib **__MIDL_0146);
        
        HRESULT ( STDMETHODCALLTYPE *FImportObj )( 
            ICOFFObj * This,
            /* [out] */ BOOL *__MIDL_0147);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringTable )( 
            ICOFFObj * This,
            /* [out] */ PLinkDataRO *__MIDL_0148);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolTableRO )( 
            ICOFFObj * This,
            /* [out] */ ICOFFSymTabRO **__MIDL_0149);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolTableRW )( 
            ICOFFObj * This,
            /* [out] */ ICOFFSymTabRW **__MIDL_0150);
        
        HRESULT ( STDMETHODCALLTYPE *ObjtkFromSzSymbol )( 
            ICOFFObj * This,
            /* [in] */ PLinkDataRO __MIDL_0151,
            /* [out] */ OBJTK *__MIDL_0152);
        
        HRESULT ( STDMETHODCALLTYPE *TimeStamp )( 
            ICOFFObj * This,
            /* [out] */ DWORD *__MIDL_0153);
        
        HRESULT ( STDMETHODCALLTYPE *SzRefForIsym )( 
            ICOFFObj * This,
            /* [in] */ ISYM __MIDL_0154,
            /* [out] */ PLinkDataRO *__MIDL_0155);
        
        END_INTERFACE
    } ICOFFObjVtbl;

    interface ICOFFObj
    {
        CONST_VTBL struct ICOFFObjVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICOFFObj_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICOFFObj_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICOFFObj_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICOFFObj_BeginOptCaching(This)	\
    (This)->lpVtbl -> BeginOptCaching(This)

#define ICOFFObj_CContrib(This,__MIDL_0140)	\
    (This)->lpVtbl -> CContrib(This,__MIDL_0140)

#define ICOFFObj_Close(This,__MIDL_0141)	\
    (This)->lpVtbl -> Close(This,__MIDL_0141)

#define ICOFFObj_COFFTimeStamp(This,__MIDL_0142)	\
    (This)->lpVtbl -> COFFTimeStamp(This,__MIDL_0142)

#define ICOFFObj_CSymbols(This,__MIDL_0143)	\
    (This)->lpVtbl -> CSymbols(This,__MIDL_0143)

#define ICOFFObj_EndOptCaching(This)	\
    (This)->lpVtbl -> EndOptCaching(This)

#define ICOFFObj_EnumContrib(This,__MIDL_0144)	\
    (This)->lpVtbl -> EnumContrib(This,__MIDL_0144)

#define ICOFFObj_GetContribForISec(This,__MIDL_0145,__MIDL_0146)	\
    (This)->lpVtbl -> GetContribForISec(This,__MIDL_0145,__MIDL_0146)

#define ICOFFObj_FImportObj(This,__MIDL_0147)	\
    (This)->lpVtbl -> FImportObj(This,__MIDL_0147)

#define ICOFFObj_GetStringTable(This,__MIDL_0148)	\
    (This)->lpVtbl -> GetStringTable(This,__MIDL_0148)

#define ICOFFObj_GetSymbolTableRO(This,__MIDL_0149)	\
    (This)->lpVtbl -> GetSymbolTableRO(This,__MIDL_0149)

#define ICOFFObj_GetSymbolTableRW(This,__MIDL_0150)	\
    (This)->lpVtbl -> GetSymbolTableRW(This,__MIDL_0150)

#define ICOFFObj_ObjtkFromSzSymbol(This,__MIDL_0151,__MIDL_0152)	\
    (This)->lpVtbl -> ObjtkFromSzSymbol(This,__MIDL_0151,__MIDL_0152)

#define ICOFFObj_TimeStamp(This,__MIDL_0153)	\
    (This)->lpVtbl -> TimeStamp(This,__MIDL_0153)

#define ICOFFObj_SzRefForIsym(This,__MIDL_0154,__MIDL_0155)	\
    (This)->lpVtbl -> SzRefForIsym(This,__MIDL_0154,__MIDL_0155)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICOFFObj_BeginOptCaching_Proxy( 
    ICOFFObj * This);


void __RPC_STUB ICOFFObj_BeginOptCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_CContrib_Proxy( 
    ICOFFObj * This,
    /* [out] */ DWORD *__MIDL_0140);


void __RPC_STUB ICOFFObj_CContrib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_Close_Proxy( 
    ICOFFObj * This,
    /* [in] */ BOOL __MIDL_0141);


void __RPC_STUB ICOFFObj_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_COFFTimeStamp_Proxy( 
    ICOFFObj * This,
    /* [out] */ DWORD *__MIDL_0142);


void __RPC_STUB ICOFFObj_COFFTimeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_CSymbols_Proxy( 
    ICOFFObj * This,
    /* [out] */ DWORD *__MIDL_0143);


void __RPC_STUB ICOFFObj_CSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_EndOptCaching_Proxy( 
    ICOFFObj * This);


void __RPC_STUB ICOFFObj_EndOptCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_EnumContrib_Proxy( 
    ICOFFObj * This,
    /* [out] */ IEnumContrib **__MIDL_0144);


void __RPC_STUB ICOFFObj_EnumContrib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetContribForISec_Proxy( 
    ICOFFObj * This,
    /* [in] */ DWORD __MIDL_0145,
    /* [out] */ IObjectContrib **__MIDL_0146);


void __RPC_STUB ICOFFObj_GetContribForISec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_FImportObj_Proxy( 
    ICOFFObj * This,
    /* [out] */ BOOL *__MIDL_0147);


void __RPC_STUB ICOFFObj_FImportObj_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetStringTable_Proxy( 
    ICOFFObj * This,
    /* [out] */ PLinkDataRO *__MIDL_0148);


void __RPC_STUB ICOFFObj_GetStringTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetSymbolTableRO_Proxy( 
    ICOFFObj * This,
    /* [out] */ ICOFFSymTabRO **__MIDL_0149);


void __RPC_STUB ICOFFObj_GetSymbolTableRO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_GetSymbolTableRW_Proxy( 
    ICOFFObj * This,
    /* [out] */ ICOFFSymTabRW **__MIDL_0150);


void __RPC_STUB ICOFFObj_GetSymbolTableRW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_ObjtkFromSzSymbol_Proxy( 
    ICOFFObj * This,
    /* [in] */ PLinkDataRO __MIDL_0151,
    /* [out] */ OBJTK *__MIDL_0152);


void __RPC_STUB ICOFFObj_ObjtkFromSzSymbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_TimeStamp_Proxy( 
    ICOFFObj * This,
    /* [out] */ DWORD *__MIDL_0153);


void __RPC_STUB ICOFFObj_TimeStamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICOFFObj_SzRefForIsym_Proxy( 
    ICOFFObj * This,
    /* [in] */ ISYM __MIDL_0154,
    /* [out] */ PLinkDataRO *__MIDL_0155);


void __RPC_STUB ICOFFObj_SzRefForIsym_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICOFFObj_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_objint_0102 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_objint_0102_0001
    {	tleMultDef	= 0,
	tleSecAttrib	= tleMultDef + 1,
	tleMessage	= tleSecAttrib + 1,
	tleWarning	= tleMessage + 1,
	tleError	= tleWarning + 1,
	tleFatal	= tleError + 1
    } 	TLE;



extern RPC_IF_HANDLE __MIDL_itf_objint_0102_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objint_0102_v0_0_s_ifspec;

#ifndef __ILinkError_INTERFACE_DEFINED__
#define __ILinkError_INTERFACE_DEFINED__

/* interface ILinkError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILinkError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2DEBF730-F5C3-11d1-A73F-0060083E8C78")
    ILinkError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ErrorType( 
            /* [out] */ TLE *__MIDL_0156) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Objtk1( 
            /* [out] */ OBJTK *__MIDL_0157) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Objtk2( 
            /* [out] */ OBJTK *__MIDL_0158) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sz( 
            /* [out] */ PLinkDataRO *__MIDL_0159) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DwInfo( 
            /* [out] */ DWORD *__MIDL_0160) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILinkError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILinkError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILinkError * This);
        
        HRESULT ( STDMETHODCALLTYPE *ErrorType )( 
            ILinkError * This,
            /* [out] */ TLE *__MIDL_0156);
        
        HRESULT ( STDMETHODCALLTYPE *Objtk1 )( 
            ILinkError * This,
            /* [out] */ OBJTK *__MIDL_0157);
        
        HRESULT ( STDMETHODCALLTYPE *Objtk2 )( 
            ILinkError * This,
            /* [out] */ OBJTK *__MIDL_0158);
        
        HRESULT ( STDMETHODCALLTYPE *Sz )( 
            ILinkError * This,
            /* [out] */ PLinkDataRO *__MIDL_0159);
        
        HRESULT ( STDMETHODCALLTYPE *DwInfo )( 
            ILinkError * This,
            /* [out] */ DWORD *__MIDL_0160);
        
        END_INTERFACE
    } ILinkErrorVtbl;

    interface ILinkError
    {
        CONST_VTBL struct ILinkErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkError_ErrorType(This,__MIDL_0156)	\
    (This)->lpVtbl -> ErrorType(This,__MIDL_0156)

#define ILinkError_Objtk1(This,__MIDL_0157)	\
    (This)->lpVtbl -> Objtk1(This,__MIDL_0157)

#define ILinkError_Objtk2(This,__MIDL_0158)	\
    (This)->lpVtbl -> Objtk2(This,__MIDL_0158)

#define ILinkError_Sz(This,__MIDL_0159)	\
    (This)->lpVtbl -> Sz(This,__MIDL_0159)

#define ILinkError_DwInfo(This,__MIDL_0160)	\
    (This)->lpVtbl -> DwInfo(This,__MIDL_0160)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkError_ErrorType_Proxy( 
    ILinkError * This,
    /* [out] */ TLE *__MIDL_0156);


void __RPC_STUB ILinkError_ErrorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Objtk1_Proxy( 
    ILinkError * This,
    /* [out] */ OBJTK *__MIDL_0157);


void __RPC_STUB ILinkError_Objtk1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Objtk2_Proxy( 
    ILinkError * This,
    /* [out] */ OBJTK *__MIDL_0158);


void __RPC_STUB ILinkError_Objtk2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_Sz_Proxy( 
    ILinkError * This,
    /* [out] */ PLinkDataRO *__MIDL_0159);


void __RPC_STUB ILinkError_Sz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkError_DwInfo_Proxy( 
    ILinkError * This,
    /* [out] */ DWORD *__MIDL_0160);


void __RPC_STUB ILinkError_DwInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkError_INTERFACE_DEFINED__ */


#ifndef __ILinkNotify_INTERFACE_DEFINED__
#define __ILinkNotify_INTERFACE_DEFINED__

/* interface ILinkNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ILinkNotify *PLinkNotify;


EXTERN_C const IID IID_ILinkNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D7E97A0-F5B6-11d1-A73F-0060083E8C78")
    ILinkNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnError( 
            /* [in] */ ILinkError *__MIDL_0161) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ DWORD __MIDL_0162,
            /* [in] */ DWORD __MIDL_0163) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILinkNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILinkNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILinkNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILinkNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnError )( 
            ILinkNotify * This,
            /* [in] */ ILinkError *__MIDL_0161);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            ILinkNotify * This,
            /* [in] */ DWORD __MIDL_0162,
            /* [in] */ DWORD __MIDL_0163);
        
        END_INTERFACE
    } ILinkNotifyVtbl;

    interface ILinkNotify
    {
        CONST_VTBL struct ILinkNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILinkNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILinkNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILinkNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILinkNotify_OnError(This,__MIDL_0161)	\
    (This)->lpVtbl -> OnError(This,__MIDL_0161)

#define ILinkNotify_OnStatus(This,__MIDL_0162,__MIDL_0163)	\
    (This)->lpVtbl -> OnStatus(This,__MIDL_0162,__MIDL_0163)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILinkNotify_OnError_Proxy( 
    ILinkNotify * This,
    /* [in] */ ILinkError *__MIDL_0161);


void __RPC_STUB ILinkNotify_OnError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILinkNotify_OnStatus_Proxy( 
    ILinkNotify * This,
    /* [in] */ DWORD __MIDL_0162,
    /* [in] */ DWORD __MIDL_0163);


void __RPC_STUB ILinkNotify_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILinkNotify_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\ref.h ===
#pragma once

#if !defined(_ref_h)
#define _ref_h 1

#define refNil  0

template <class TARG>
class RefPtr {
  private:
    TARG *  _ptarg;

    // unuse pointer and free if last user
    void Release() {
        if (_ptarg != NULL && _ptarg->FUnUse()) {
            delete _ptarg;
            }

        // put garbage in pointer
        Debug(_ptarg = (TARG *) 0xdadadadadadadadaui64);
        }

  public:
    // constructors
    RefPtr<TARG>() {
        _ptarg = NULL;
        }

    RefPtr<TARG>(TARG * ptargNew) {
        _ptarg = ptargNew;
        if (ptargNew != NULL) {
            ptargNew->Use();
            }
        }

    RefPtr<TARG>(const RefPtr<TARG> & rtarg) {
        _ptarg = rtarg._ptarg;
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->Use();
            }
        }

    // destructor
   ~RefPtr<TARG>() {
        Release();
        }

    // assignment functions (mirror the ctors)
    RefPtr<TARG>& operator=(TARG *ptargNew) {
        if (ptargNew != NULL) {
            ptargNew->Use();
            }

        Release();
        _ptarg = ptargNew;

        return *this;
        }

    RefPtr<TARG>& operator=(const RefPtr<TARG> &rtarg) {
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->Use();
            }

        Release();
        _ptarg = rtarg._ptarg;

        return *this;
        }

    bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
    bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
    TARG &operator*()             const { return *_ptarg;          }
    TARG *operator->()            const { return  _ptarg;          }
          operator TARG *()       const { return  _ptarg;          }
    };

template <class TARG>
class COMRefPtr {
  private:
    TARG *  _ptarg;

    // unuse pointer and free if last user
    void Release() {
        if (_ptarg != NULL) {
            _ptarg->Release();
            }

        // put garbage in pointer
//      Debug(_ptarg = (TARG *) 0xdadadada);
        }

  public:
    // constructors
    COMRefPtr<TARG>() {
        _ptarg = NULL;
        }

    COMRefPtr<TARG>(TARG * ptargNew) {
        _ptarg = ptargNew;
        if (ptargNew != NULL) {
            ptargNew->AddRef();
            }
        }

    COMRefPtr<TARG>(const RefPtr<TARG> & rtarg) {
        _ptarg = rtarg._ptarg;
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->AddRef();
            }
        }

    // destructor
   ~COMRefPtr<TARG>() {
        Release();
        }

    // assignment functions (mirror the ctors)
    COMRefPtr<TARG>& operator=(TARG *ptargNew) {
        if (ptargNew != NULL) {
            ptargNew->AddRef();
            }

        Release();
        _ptarg = ptargNew;

        return *this;
        }

    COMRefPtr<TARG>& operator=(const COMRefPtr<TARG> &rtarg) {
        if (rtarg._ptarg != NULL) {
            rtarg._ptarg->AddRef();
            }

        Release();
        _ptarg = rtarg._ptarg;

        return *this;
        }
    TARG **operator&() {
        if (_ptarg != NULL) {
            _ptarg->Release();
            _ptarg = NULL;
            }

        return &_ptarg;
        }

    bool  operator==(TARG *ptarg) const { return  _ptarg == ptarg; }
    bool  operator!=(TARG *ptarg) const { return  _ptarg != ptarg; }
    TARG &operator*()             const { return *_ptarg;          }
    TARG *operator->()            const { return  _ptarg;          }
    operator TARG *()       const { return  _ptarg;          }
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\sqlprxky.h ===
// SqldprxyKey.h - startup key for sqldprxy

// proxy gets started up with 2 args, the first is the key,
// the 2nd is the event name (which includes the PID to make it unique)
#define SZSQLPROXYKEY	"SqlProxyKeyArg"

void __inline BuildProxyEventName( char *p )
{
	wsprintf(p, "MS.MSDev.Event.Ent.%x", GetCurrentProcessId() );
}

#ifdef DEBUG
#define	szSqlProxyBase	"sqlprxyd"
#else
#define	szSqlProxyBase	"sqlprxy"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\sqlpkapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	SQLPKAPI.H
//		SQL specific package interface declarations.

// IMPORTANT: this file is used by debugger components so:
// 1. Needs to be C-parsable ie no C++ luxuries (easier said than done I know)
// 2. Must not require MFC types or headers
// 3. Make sure you use the OLE macros in a C-compatible way (ditto)
// 4. If this changes, the debugger bits will need a rebuild

#ifndef __SQLPKAPI_H__
#define __SQLPKAPI_H__

interface ISqlExec;
interface ISrcDebug;

#ifdef __cplusplus
typedef ISqlExec* LPSQLEXEC;
typedef ISrcDebug* LPSRCDEBUG;
#endif

/////////////////////////////////////////////////////////////////////////////
// ISqlExec

#undef  INTERFACE
#define INTERFACE ISqlExec

enum LoadNotifyType {lntBeforeLoad, lntAfterLoad, lntTerminatingAndRestoringBPs, lntDebugSessionEnding, lntSQLThreadCreated,
			lntProgLoad, lntProgTerm, lntBadDriver};

typedef WORD SPCOOKIE;
typedef SPCOOKIE *PSPCOOKIE;

DECLARE_INTERFACE_(ISqlExec, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISqlExec methods

	STDMETHOD_(void, GoSql)(THIS) PURE;
	STDMETHOD_(void, StepIntoSql)(THIS) PURE;
	STDMETHOD_(void, StepOverSql)(THIS) PURE;
	STDMETHOD_(void, AddTmpBpSql)(THIS) PURE;
	STDMETHOD_(void, ToggleBPSql)(THIS) PURE;

	STDMETHOD_(BOOL, DebuggeeLoadNotify)(THIS_ enum LoadNotifyType lnt, LPVOID) PURE;
	STDMETHOD_(BOOL, GetSqlSPInfo)(THIS_ SPCOOKIE Cookie, char *ServerName, char *DBN, char *Name, WORD *cLine, WORD) PURE;
	STDMETHOD_(BOOL, GetSqlLocation)(THIS_ WORD *pline, PSPCOOKIE pCookie, WORD) PURE;

	STDMETHOD_(BOOL, FindSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(BOOL, SetSqlSymbol)(THIS_ PVOID pSymInfo, WORD nlvl ) PURE;
	STDMETHOD_(UINT, CountSqlLocals)(THIS_ WORD nlvl, BOOL ) PURE;
	STDMETHOD_(BOOL, GetSqlLocalName)(THIS_ char*, WORD, UINT, BOOL ) PURE;

	STDMETHOD_(void, StepToReturnSql)(THIS) PURE;
	STDMETHOD_(void, HackRefCount)(THIS_ int ) PURE;
	STDMETHOD_(void, KillSql)(THIS_ unsigned long, BOOL fAsync ) PURE;

	STDMETHOD_(void*,FindSqlDocument)(THIS_ char*, BOOL) PURE;
	STDMETHOD_(BOOL, GetSqlStack)(THIS_ WORD*, int, PSPCOOKIE, WORD*) PURE;
	STDMETHOD_(BOOL, SetSqlBreakpoint)(THIS_ BOOL, SPCOOKIE, WORD ) PURE;

	STDMETHOD_(BOOL, FindCookie)(THIS_ char* szSrvr, char* szDBN, char* szProc, SPCOOKIE *pCookie) PURE;

	STDMETHOD_(BOOL, ParseSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, BuildSqlPath)(THIS_ char* szPath, char *szServ, char *szDB, char *szSP, int) PURE;
	STDMETHOD_(BOOL, GetCodeLines)(THIS_ SPCOOKIE, int*pSize, unsigned short** ppList) PURE;

	STDMETHOD_(BOOL, InProcSql)(THIS_ char* szPath) PURE;
    STDMETHOD(LoadDocument)(LPCTSTR szName) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// ISrcDebug

#undef  INTERFACE
#define INTERFACE ISrcDebug

DECLARE_INTERFACE_(ISrcDebug, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISrcDebug methods

	STDMETHOD_(BOOL, DebugSystemService)(THIS_ int i1, int i2, int i3, void *pv1, int i4, void *pv2) PURE;
	STDMETHOD_(void, UpdateBPViews)(THIS) PURE;
};


#endif	// __SQLPKAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\vcexcept.h ===
// defined exceptions used by Visual C++
// [created apennell 6/24/97]
// must be kept in sync in both V6 and V7 langapi trees

#pragma once
#if !defined(_vcexcept_h)
#define _vcexcept_h

// the facility code we have chosen is based on the fact that we already
// use an exception of 'msc' when we throw C++ exceptions

#define FACILITY_VISUALCPP  ((LONG)0x6D)

#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

/////////////////////////////////////////////////////////////////
// define all exceptions here, so we don't mess with each other
/////////////////////////////////////////////////////////////////

// used by CRTs for C++ exceptions, really defined in ehdata.h
//#define EH_EXCEPTION_NUMBER   VcppException( 3<<30, 0x7363 )      // SEV_ERROR, used by CRTs for C++

// used by debugger to do e.g. SetThreadName call
#define EXCEPTION_VISUALCPP_DEBUGGER    VcppException(1<<30, 5000)      // SEV_INFORMATIONAL

#endif	// _vcexcept_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\vcbudefs.h ===
// VCBUDEFS.H - standard defs to be used for hungarian notation

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef VCBUDEFS_INCLUDED
#define VCBUDEFS_INCLUDED

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef ULONG	INTV;		// interface version number
typedef ULONG	IMPV;		// implementation version number
typedef ULONG	SIG;		// unique (across PDB instances) signature
typedef ULONG	AGE;		// no. of times this instance has been updated
typedef BYTE*	PB;			// pointer to some bytes
typedef long	CB;			// count of bytes
typedef char*	SZ;			// zero terminated string
typedef const char*	SZ_CONST;// const zero terminated string
typedef char*	PCH;		// char ptr
typedef USHORT	IFILE;		// file index
typedef USHORT	IMOD;		// module index
typedef USHORT	ISECT;		// section index
typedef USHORT	LINE;		// line number
typedef long	OFF;		// offset
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\pdb.h ===
// Debug Information API
// Copyright (C) 1993-1996, Microsoft Corp.  All Rights Reserved.

#pragma once

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef __PDB_INCLUDED__
#define __PDB_INCLUDED__

typedef int BOOL;
typedef unsigned UINT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef unsigned __int64 DWORDLONG;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef ULONG   INTV;       // interface version number
typedef ULONG   IMPV;       // implementation version number
typedef ULONG   SIG;        // unique (across PDB instances) signature
typedef ULONG   AGE;        // no. of times this instance has been updated
typedef const char*     SZ_CONST;   // const string
typedef void *          PV;
typedef const void *    PCV;

#ifdef  LNGNM
#define LNGNM_CONST	const
#else   // LNGNM
#define LNGNM_CONST
#endif  // LNGNM

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;

#endif // !GUID_DEFINED

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef long HRESULT;

#endif // !_HRESULT_DEFINED


typedef GUID            SIG70;      // new to 7.0 are 16-byte guid-like signatures
typedef SIG70 *         PSIG70;
typedef const SIG70 *   PCSIG70;

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

enum {
#ifdef LNGNM
    PDBIntv70   = 20001102,
    PDBIntv70Dep = 20000406,
#else
    PDBIntv70   = 20000301,
#endif
    PDBIntv69   = 19990511,
    PDBIntv61   = 19980914,
    PDBIntv50a  = 19970116,
    PDBIntv60   = PDBIntv50a,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
#ifdef LNGNM
    PDBIntv     = PDBIntv70,   // Now we support both 50 & 60, 69 is only an intermediate version
    PDBIntvAlt  = PDBIntv50,   
    PDBIntvAlt2 = PDBIntv60,   
    PDBIntvAlt3 = PDBIntv69,
#else
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntvAlt2 = PDBIntv60,   // Alternate (backward compatible) supported interface
    PDBIntvAlt3 = PDBIntv61,
    PDBIntv     = PDBIntv69,
#endif  
};

enum {
    PDBImpvVC2  = 19941610,
    PDBImpvVC4  = 19950623,
    PDBImpvVC41 = 19950814,
    PDBImpvVC50 = 19960307,
    PDBImpvVC98 = 19970604,
    PDBImpvVC70 = 20000404,
    PDBImpvVC70Dep = 19990604,  // deprecated vc70 implementation version
#ifdef LNGNM
    PDBImpv     = PDBImpvVC70,
#else
    PDBImpv     = PDBImpvVC98,
#endif
};


enum {
    niNil        = 0,
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,
};

// cvinfo.h type index, intentionally typedef'ed here to check equivalence.
typedef unsigned short  CV_typ16_t;
typedef unsigned long   CV_typ_t;
typedef unsigned long   CV_pubsymflag_t;    // must be same as CV_typ_t.

typedef CV_typ_t        TI;     // PDB name for type index
typedef CV_typ16_t      TI16;   // 16-bit version
typedef unsigned long   NI;     // name index
typedef TI *            PTi;
typedef TI16 *          PTi16;

typedef BYTE            ITSM;   // type server map index
typedef ITSM*           PITSM;

typedef BOOL    (__stdcall *PFNVALIDATEDEBUGINFOFILE) (const char * szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancilliary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    char *  szMod;                      // exe/dll
    char *  szLib;                      // lib if appropriate
    char *  szObj;                      // object file
    char * *rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char  szValidatedFile[PDB_MAX_PATH];// output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
    char *  szExe;                      // exe/dll
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

typedef BOOL ( __stdcall * PfnFindDebugInfoFile) ( PSEARCHDEBUGINFO );

#define PdbInterface struct

PdbInterface PDB;                   // program database
PdbInterface DBI;                   // debug information within the PDB
PdbInterface Mod;                   // a module within the DBI
PdbInterface TPI;                   // type info within the DBI
PdbInterface GSI;                   // global symbol info
PdbInterface SO;                    
PdbInterface Stream;                // some named bytestream in the PDB
PdbInterface StreamImage;           // some memory mapped stream
PdbInterface NameMap;              // name mapping
PdbInterface Enum;                 // generic enumerator
PdbInterface EnumNameMap;          // enumerate names within a NameMap
PdbInterface EnumContrib;          // enumerate contributions
PdbInterface Dbg;                   // misc debug data (FPO, OMAP, etc)
PdbInterface Src;                   // Src file data
PdbInterface EnumSrc;               // Src file enumerator
PdbInterface SrcHash;               // Src file hasher
PdbInterface EnumLines;

typedef PdbInterface PDB PDB;
typedef PdbInterface DBI DBI;
typedef PdbInterface Mod Mod;
typedef PdbInterface TPI TPI;
typedef PdbInterface GSI GSI;
typedef PdbInterface SO SO;
typedef PdbInterface Stream Stream;
typedef PdbInterface StreamImage StreamImage;
typedef PdbInterface NameMap NameMap;
typedef PdbInterface Enum Enum;
typedef PdbInterface EnumStreamNames EnumStreamNames;
typedef PdbInterface EnumNameMap EnumNameMap;
typedef PdbInterface EnumContrib EnumContrib;
typedef PdbInterface EnumSyms EnumSyms;
typedef PdbInterface WidenTi WidenTi;
typedef PdbInterface Dbg Dbg;
typedef PdbInterface EnumThunk EnumThunk;
typedef PdbInterface Src Src;
typedef PdbInterface EnumSrc EnumSrc;
typedef PdbInterface SrcHash SrcHash;

typedef SrcHash *   PSrcHash;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_ILLEGAL_TYPE_EDIT,   // trying to edit types in read-only mode
    EC_INVALID_EXECUTABLE,  // not recogized as a valid executable
    EC_DBG_NOT_FOUND,       // A required .DBG file was not found
    EC_NO_DEBUG_INFO,       // No recognized debug info found
    EC_INVALID_EXE_TIMESTAMP, // Invalid timestamp on Openvalidate of exe
    EC_RESERVED, // RESERVED for future use
    EC_DEBUG_INFO_NOT_IN_PDB, // returned by OpenValidateX
    EC_MAX
};

#if !defined(pure)
#define  pure = 0
#endif

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#ifdef PDB_SERVER
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllexport) RTYPE PDBCALL
#elif   defined(PDB_LIBRARY)
#define PDB_IMPORT_EXPORT(RTYPE)    RTYPE PDBCALL
#else
#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL
#endif

#define PDBAPI PDB_IMPORT_EXPORT

#ifndef IN
#define IN                  /* in parameter, parameters are IN by default */
#endif
#ifndef OUT
#define OUT                 /* out parameter */
#endif

// Type of callback arg to PDB::OpenValidate5

enum POVC
{
    povcNotifyDebugDir,
    povcNotifyOpenDBG,
    povcNotifyOpenPDB,
    povcReserved,
    povcReadExecutableAt,
    povcReadExecutableAtRVA,
    povcRestrictRegistry,
    povcRestrictSymsrv,
    povcRestrictSystemRoot,
    povcNotifyMiscPath,
};

typedef int (PDBCALL *PDBCALLBACK)();

typedef PDBCALLBACK (PDBCALL *PfnPDBQueryCallback)(void *pvClient, enum POVC povc);

typedef void (PDBCALL *PfnPDBNotifyDebugDir)(void *pvClient, BOOL fExecutable, const struct _IMAGE_DEBUG_DIRECTORY *pdbgdir);
typedef void (PDBCALL *PfnPDBNotifyOpenDBG)(void *pvClient, const wchar_t *wszDbgPath, enum PDBErrors ec, const wchar_t *wszError);
typedef void (PDBCALL *PfnPDBNotifyOpenPDB)(void *pvClient, const wchar_t *wszPdbPath, enum PDBErrors ec, const wchar_t *wszError);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAt)(void *pvClient, DWORDLONG fo, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBReadExecutableAtRVA)(void *pvClient, DWORD rva, DWORD cb, void *pv);
typedef HRESULT (PDBCALL *PfnPDBRestrictRegistry)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSymsrv)(void *pvClient);
typedef HRESULT (PDBCALL *PfnPDBRestrictSystemRoot)(void *pvClient);
typedef void (PDBCALL *PfnPDBNotifyMiscPath)(void *pvClient, const wchar_t *wszMiscPath);

// type of callback arg to PDB::GetRawBytes
typedef BOOL (PDBCALL *PFNfReadPDBRawBytes)(const void *, long);

// WidenTi interface needs a couple of structures to communicate info back
// and forth.
struct OffMap {
    ULONG       offOld;
    ULONG       offNew;
};
typedef struct OffMap   OffMap;
typedef OffMap *        POffMap;

struct SymConvertInfo {
    ULONG       cbSyms;             // size necessary for converting a block
    ULONG       cSyms;              // count of symbols, necessary to allocate
                                    // mpoffOldoffNew array.
    BYTE *      pbSyms;             // block of symbols (output side)
    OffMap *    rgOffMap;           // OffMap rgOffMap[cSyms]
};
typedef struct SymConvertInfo   SymConvertInfo;
enum { wtiSymsNB09 = 0, wtiSymsNB10 = 1 };

// Filter values for PDBCopyTo
enum { 
    copyRemovePrivate       = 0x00000001,   // remove private debug information
    copyCreateNewSig        = 0x00000002,   // create new signature for target pdb
};

// PDBCopy callback signatures and function pointer types for PDB::CopyTo2 and CopyToW2
//
enum PCC {
    pccFilterPublics,
};

#if !defined(__cplusplus)
typedef enum PCC    PCC;
#endif  // __cplusplus

typedef BOOL (PDBCALL *PDBCOPYCALLBACK)();
typedef PDBCOPYCALLBACK (PDBCALL *PfnPDBCopyQueryCallback)(void *pvClientContext, PCC pcc);

// Return (true, pszNewPublic==NULL) to keep the name as is,
// (true, pszNewPublic!=NULL) changes name to pszNewPublic,
// false to discard public entirely.
//
typedef BOOL (PDBCALL *PfnPDBCopyFilterPublics)(
    void *          pvClientContext,
    DWORD           dwFilterFlags,
    unsigned int    offPublic,
    unsigned int    sectPublic,
    unsigned int    grfPublic,      // see cvinfo.h, definition of CV_PUBSYMFLAGS_e and
                                    // CV_PUBSYMFLAGS give the format of this bitfield.
    const wchar_t * szPublic,
    wchar_t **      pszNewPublic
    );

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,   // deprecated
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
#if !defined(VER60)
    dbgtypeTokenRidMap,
    dbgtypeXdata,
    dbgtypePdata,
    dbgtypeNewFPO,
    dbgtypeSectionHdrOrig,
#endif
    dbgtypeMax          // must be last!
};

typedef enum DBGTYPE DBGTYPE;

// We add a slight bit of structure to dbg blobs so we can record extra
// relevant information there.  Generally, the blobs are lifted right out
// of an image, and need some extra info anyway.  In the case of Xdata, we
// store RVA base of the Xdata there.  This is used to interpret the
// UnwindInfoAddress RVA in the IA64 Pdata entries.
//
enum VerDataBlob {
    vdbOne = 1,
    vdbXdataCur = vdbOne,
    vdbPdataCur = vdbOne,
};

// default blob header
//
typedef struct DbgBlob {
    ULONG   ver;
    ULONG   cbHdr;
    ULONG   cbData;
    //BYTE    rgbDataBlob[];    // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgBlob;

// "store rva of the base and va of image base" blob header
//
typedef struct DbgRvaVaBlob {
    ULONG       ver;
    ULONG       cbHdr;
    ULONG       cbData;
    ULONG       rvaDataBase;
    DWORDLONG   vaImageBase;
    ULONG       ulReserved1;    // reserved, must be 0
    ULONG       ulReserved2;    // reserved, must be 0
    //BYTE      rgbDataBlob[];  // Data follows, but to enable simple embedding,
                                // don't use a zero-sized array here.
} DbgRvaVaBlob;

// Linker data necessary for relinking an image.  Record contains two SZ strings
// off of the end of the record with two offsets from the base 
//
enum VerLinkInfo {
    vliOne = 1,
    vliTwo = 2,
    vliCur = vliTwo,
};

struct LinkInfo {
    ULONG           cb;             // size of the whole record.  computed as
                                    //  sizeof(LinkInfo) + strlen(szCwd) + 1 +
                                    //  strlen(szCommand) + 1
    ULONG           ver;            // version of this record (VerLinkInfo)
    ULONG           offszCwd;       // offset from base of this record to szCwd
    ULONG           offszCommand;   // offset from base of this record
    ULONG           ichOutfile;     // index of start of output file in szCommand
    ULONG           offszLibs;      // offset from base of this record to szLibs

    // The command includes the full path to the linker, the -re and -out:...
    // swithches.
    // A sample might look like the following:
    // "c:\program files\msdev\bin\link.exe -re -out:debug\foo.exe"
    // with ichOutfile being 48.
    // the -out switch is guaranteed to be the last item in the command line.
#ifdef __cplusplus
    VerLinkInfo Ver() const {
        return VerLinkInfo(ver);
    }
    long Cb() const {
        return cb;
    }
    char *     SzCwd() const {
        return (char *)((char *)(this) + offszCwd);
    }
    char *    SzCommand() const {
        return (char *)((char *)(this) + offszCommand);
    }
    char *    SzOutFile() const {
        return SzCommand() + ichOutfile;
    }
    LinkInfo() :
        cb(0), ver(vliCur), offszCwd(0), offszCommand(0), ichOutfile(0)
    {
    }
    char *    SzLibs() const {
        return (char *)((char *)(this) + offszLibs);
    }

#endif
};

#ifdef LNGNM
#ifdef __cplusplus
struct LinkInfoW : public LinkInfo
{
    wchar_t* SzCwdW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCwd);
    }
    wchar_t* SzCommandW() const {
        return (wchar_t *)((wchar_t *)(this) + offszCommand);
    }
    wchar_t* SzOutFileW() const {
        return SzCommandW() + ichOutfile;
    }
    wchar_t* SzLibsW() const {
        return (wchar_t *)((wchar_t *)(this) + offszLibs);
    }
};
#else
typedef struct LinkInfo LinkInfoW;
#endif  // __cplusplus

typedef LinkInfoW * PLinkInfoW;

#endif  // LNGNM

typedef struct LinkInfo LinkInfo;
typedef LinkInfo *      PLinkInfo;


//
// Source (Src) info
//
// This is the source file server for virtual and real source code.
// It is structured as an index on the object file name concatenated
// with 
enum SrcVer {
    srcverOne = 19980827,
};

enum SrcCompress {
    srccompressNone,
    srccompressRLE,
    srccompressHuffman,
    srccompressLZ,
};

#ifdef LNGNM
struct tagSrcHeader {
#else
struct SrcHeader {
#endif
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
#ifndef LNGNM
    unsigned char   szNames[1]; // file names (szFile "\0" szObj "\0" szVirtual,
                                //  as in: "f.cpp" "\0" "f.obj" "\0" "*inj:1:f.obj")
                                // in the case of non-virtual files, szVirtual is
                                // the same as szFile.
#endif
};

#ifdef LNGNM
struct SrcHeader : public tagSrcHeader
{
    unsigned char szNames[1];   // see comment above
};

struct SrcHeaderW : public tagSrcHeader
{
    wchar_t szNames[1];   // see comment above
};

typedef struct SrcHeaderW    SrcHeaderW;
typedef SrcHeaderW *         PSrcHeaderW;
typedef const SrcHeaderW *   PCSrcHeaderW;

//cassert(offsetof(SrcHeader,szNames) == sizeof(tagSrcHeader));
//cassert(offsetof(SrcHeaderW,szNames) == sizeof(tagSrcHeader));

#endif      // LNGNM

typedef struct SrcHeader    SrcHeader;
typedef SrcHeader *         PSrcHeader;
typedef const SrcHeader *   PCSrcHeader;

// header used for storing the info and for output to clients who are reading
//
struct SrcHeaderOut {
    unsigned long   cb;         // record length
    unsigned long   ver;        // header version
    unsigned long   sig;        // CRC of the data for uniqueness w/o full compare
    unsigned long   cbSource;   // count of bytes of the resulting source
    unsigned long   niFile;
    unsigned long   niObj;
    unsigned long   niVirt;
    unsigned char   srccompress;// compression algorithm used
    union {
        unsigned char       grFlags;
        struct {
            unsigned char   fVirtual : 1;   // file is a virtual file (injected)
            unsigned char   pad : 7;        // must be zero
        };
    };
    short           sPad;
    union {
        void *      pvReserved1;
        __int64     pv64Reserved2;
    };
};

typedef struct SrcHeaderOut SrcHeaderOut;
typedef SrcHeaderOut *      PSrcHeaderOut;
typedef const SrcHeaderOut *PCSrcHeaderOut;

struct SrcHeaderBlock {
    __int32     ver;
    __int32     cb;
    struct {
        DWORD   dwLowDateTime;
        DWORD   dwHighDateTime;
    } ft;
    __int32     age;
    BYTE        rgbPad[44];
};

typedef struct SrcHeaderBlock   SrcHeaderBlock;


#ifdef __cplusplus

struct IStream;

// C++ Binding

PdbInterface PDB {                 // program database
    enum {
        intv  = PDBIntv,
#if defined(LNGNM)
        intvVC70Dep = PDBIntv70Dep,     // deprecated
#endif
        intvAlt = PDBIntvAlt,
        intvAlt2 = PDBIntvAlt2,
        intvAlt3 = PDBIntvAlt3,
    };

    static PDBAPI(BOOL)
           OpenValidate(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           Open(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidateEx2(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szPathOrig,
               LNGNM_CONST char *szSearchPath,
               LNGNM_CONST char *szMode,
               SIG sig,
               AGE age,
               long cbPage,
               OUT EC* pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx(
               LNGNM_CONST char *szPDB,
               LNGNM_CONST char *szMode,
               SIG sigInitial,
               long cbPage,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate3(
               const char *szExecutable,
               const char *szSearchPath,
               OUT EC *pec,
               OUT char szError[cbErrMax],
               OUT char szDbgPath[PDB_MAX_PATH],
               OUT DWORD *pfo,
               OUT DWORD *pcb,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate4(
               const wchar_t *wszPDB,
               const char *szMode,
               PCSIG70 pcsig70,
               SIG sig,
               AGE age,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) OpenInStream(
               IStream *pIStream,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL) ExportValidateInterface(INTV intv);
    static PDBAPI(BOOL) ExportValidateImplementation(IMPV impv);

    static PDBAPI(IMPV) QueryImplementationVersionStatic();
    static PDBAPI(INTV) QueryInterfaceVersionStatic();

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual EC   QueryLastError(OUT char szError[cbErrMax]) pure;
    virtual char*QueryPDBName(OUT char szPDB[PDB_MAX_PATH]) pure;
    virtual SIG  QuerySignature() pure;
    virtual AGE  QueryAge() pure;
    virtual BOOL CreateDBI(const char* szTarget, OUT DBI** ppdbi) pure;
    virtual BOOL OpenDBI(const char* szTarget, const char* szMode, OUT DBI** ppdbi ) pure;
    virtual BOOL OpenTpi(const char* szMode, OUT TPI** pptpi) pure;

    virtual BOOL Commit() pure;
    virtual BOOL Close() pure;
    virtual BOOL OpenStream(const char* szStream, OUT Stream** ppstream) pure;
    virtual BOOL GetEnumStreamNameMap(OUT Enum** ppenum) pure;
    virtual BOOL GetRawBytes(PFNfReadPDBRawBytes pfnfSnarfRawBytes) pure;
    virtual IMPV QueryPdbImplementationVersion() pure;

    virtual BOOL OpenDBIEx(const char* szTarget, const char* szMode, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn=0) pure;

    virtual BOOL CopyTo(const char *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;

    //
    // support for source file data
    //
    virtual BOOL OpenSrc(OUT Src** ppsrc) pure;

    virtual EC   QueryLastErrorExW(OUT wchar_t *wszError, size_t cchMax) pure;
    virtual wchar_t *QueryPDBNameExW(OUT wchar_t *wszPDB, size_t cchMax) pure;
    virtual BOOL QuerySignature2(PSIG70 psig70) pure;
    virtual BOOL CopyToW(const wchar_t *szDst, DWORD dwCopyFilter, DWORD dwReserved) pure;
    virtual BOOL fIsSZPDB() const pure;

    // Implemented only on 7.0 and above versions.
    //
    virtual BOOL OpenStreamW(const wchar_t * szStream, OUT Stream** ppstream) pure;

	// Implemented in both 6.0 and 7.0 builds

    virtual BOOL CopyToW2(
        const wchar_t *         szDst,
        DWORD                   dwCopyFilter,
        PfnPDBCopyQueryCallback pfnCallBack,
        void *                  pvClientContext
        ) pure;


    inline BOOL ValidateInterface()
    {
        return ExportValidateInterface(intv);
    }

    static PDBAPI(BOOL)
           Open2W(
               const wchar_t *wszPDB,
               const char *szMode,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenEx2W(
               const wchar_t *wszPDB,
               const char *szMode,
               long cbPage,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);

    static PDBAPI(BOOL)
           OpenValidate5(
               const wchar_t *wszExecutable,
               const wchar_t *wszSearchPath,
               void *pvClient,
               PfnPDBQueryCallback pfnQueryCallback,
               OUT EC *pec,
               OUT wchar_t *wszError,
               size_t cchErrMax,
               OUT PDB **pppdb);


};


// Review: a stream directory service would be more appropriate
// than Stream::Delete, ...

PdbInterface Stream {
    virtual long QueryCb() pure;
    virtual BOOL Read(long off, void* pvBuf, long* pcbBuf) pure;
    virtual BOOL Write(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Replace(void* pvBuf, long cbBuf) pure;
    virtual BOOL Append(void* pvBuf, long cbBuf) pure;
    virtual BOOL Delete() pure;
    virtual BOOL Release() pure;
    virtual BOOL Read2(long off, void* pvBuf, long cbBuf) pure;
    virtual BOOL Truncate(long cb) pure;
};

PdbInterface StreamImage {
    static PDBAPI(BOOL) open(Stream* pstream, long cb, OUT StreamImage** ppsi);
    virtual long size() pure;
    virtual void* base() pure;
    virtual BOOL noteRead(long off, long cb, OUT void** ppv) pure;
    virtual BOOL noteWrite(long off, long cb, OUT void** ppv) pure;
    virtual BOOL writeBack() pure;
    virtual BOOL release() pure;
};

PdbInterface DBI {             // debug information
    enum { intv = PDBIntv };
    virtual IMPV QueryImplementationVersion() pure;
    virtual INTV QueryInterfaceVersion() pure;
    virtual BOOL OpenMod(const char* szModule, const char* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteMod(const char* szModule) pure;
    virtual BOOL QueryNextMod(Mod* pmod, Mod** ppmodNext) pure;
    virtual BOOL OpenGlobals(OUT GSI **ppgsi) pure;
    virtual BOOL OpenPublics(OUT GSI **ppgsi) pure;
    virtual BOOL AddSec(USHORT isect, USHORT flags, long off, long cb) pure;
#if defined(LNGNM) && (_MSC_VER >= 1300)
    //__declspec(deprecated)
#endif
    virtual BOOL QueryModFromAddr(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb) pure;
    virtual BOOL QuerySecMap(OUT BYTE* pb, long* pcb) pure;
    virtual BOOL QueryFileInfo(OUT BYTE* pb, long* pcb) pure;
    virtual void DumpMods() pure;
    virtual void DumpSecContribs() pure;
    virtual void DumpSecMap() pure;

    virtual BOOL Close() pure;
    virtual BOOL AddThunkMap(long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                    struct SO* psoSectMap, unsigned nSects,
                    USHORT isectThunkTable, long offThunkTable) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL getEnumContrib(OUT Enum** ppenum) pure;
    virtual BOOL QueryTypeServer( ITSM itsm, OUT TPI** pptpi ) pure;
    virtual BOOL QueryItsmForTi( TI ti, OUT ITSM* pitsm ) pure;
    virtual BOOL QueryNextItsm( ITSM itsm, OUT ITSM *inext ) pure;
    virtual BOOL QueryLazyTypes() pure;
    virtual BOOL SetLazyTypes( BOOL fLazy ) pure;   // lazy is default and can only be turned off
    virtual BOOL FindTypeServers( OUT EC* pec, OUT char szError[cbErrMax] ) pure;
    virtual void DumpTypeServers() pure;
    virtual BOOL OpenDbg(DBGTYPE dbgtype, OUT Dbg **ppdbg) pure;
    virtual BOOL QueryDbgTypes(OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype) pure;
    // apis to support EnC work
    virtual BOOL QueryAddrForSec(OUT USHORT* pisect, OUT long* poff, 
            USHORT imod, long cb, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdb( OUT PDB** pppdb ) pure;
    virtual BOOL AddLinkInfo(IN PLinkInfo ) pure;
    virtual BOOL QueryLinkInfo(PLinkInfo, OUT long * pcb) pure;
    // new to vc6
    virtual AGE  QueryAge() const pure;
    virtual void * QueryHeader() const pure;
    virtual void FlushTypeServers() pure;
    virtual BOOL QueryTypeServerByPdb(const char* szPdb, OUT ITSM* pitsm) pure;

#ifdef LNGNM        // Long filename support
    virtual BOOL OpenModW(const wchar_t* szModule, const wchar_t* szFile, OUT Mod** ppmod) pure;
    virtual BOOL DeleteModW(const wchar_t* szModule) pure;
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL QueryTypeServerByPdbW( const wchar_t* szPdb, OUT ITSM* pitsm ) pure;
    virtual BOOL AddLinkInfoW(IN PLinkInfoW ) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual USHORT QueryMachineType() const pure;
    virtual void SetMachineType(USHORT wMachine) pure;
    virtual void RemoveDataForRva( ULONG rva, ULONG cb ) pure;
    virtual bool FStripped() const pure;
    virtual BOOL QueryModFromAddr2(USHORT isect, long off, OUT Mod** ppmod,
                    OUT USHORT* pisect, OUT long* poff, OUT long* pcb,
                    OUT ULONG * pdwCharacteristics) pure;
#else
    virtual bool FStripped() const pure;
#endif
};

PdbInterface Mod {             // info for one module within DBI
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BOOL AddTypes(BYTE* pbTypes, long cb) pure;
    virtual BOOL AddSymbols(BYTE* pbSym, long cb) pure;
    virtual BOOL AddPublic(const char* szPublic, USHORT isect, long off) pure;
    virtual BOOL AddLines(const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          USHORT lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL AddSecContrib(USHORT isect, long off, long cb, ULONG dwCharacteristics) pure;
    virtual BOOL QueryCBName(OUT long* pcb) pure;
    virtual BOOL QueryName(OUT char szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySymbols(BYTE* pbSym, long* pcb) pure;
    virtual BOOL QueryLines(BYTE* pbLines, long* pcb) pure;

    virtual BOOL SetPvClient(void *pvClient) pure;
    virtual BOOL GetPvClient(OUT void** ppvClient) pure;
    virtual BOOL QueryFirstCodeSecContrib(OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
//
// Make all users of this api use the real one, as this is exactly what it was
// supposed to query in the first place
//
#define QuerySecContrib QueryFirstCodeSecContrib

    virtual BOOL QueryImod(OUT USHORT* pimod) pure;
    virtual BOOL QueryDBI(OUT DBI** ppdbi) pure;
    virtual BOOL Close() pure;
    virtual BOOL QueryCBFile(OUT long* pcb) pure;
    virtual BOOL QueryFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryTpi(OUT TPI** pptpi) pure; // return this Mod's Tpi
    // apis to support EnC work
    virtual BOOL AddSecContribEx(USHORT isect, long off, long cb, ULONG dwCharacteristics, DWORD dwDataCrc, DWORD dwRelocCrc) pure;
    virtual BOOL QueryItsm(OUT USHORT* pitsm) pure;
    virtual BOOL QuerySrcFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySupportsEC() pure;
    virtual BOOL QueryPdbFile(OUT char szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL ReplaceLines(BYTE* pbLines, long cb) pure;
#ifdef LNGNM
    // V7 line number support
	virtual bool GetEnumLines( EnumLines** ppenum ) pure;
	virtual bool QueryLineFlags( OUT DWORD* pdwFlags ) pure;	// what data is present?
	virtual bool QueryFileNameInfo( 
                    IN DWORD        fileId,                 // source file identifier
                    OUT wchar_t*    szFilename,             // file name string 
                    IN OUT DWORD*   pccFilename,            // length of string
                    OUT DWORD*      pChksumType,            // type of chksum
                    OUT BYTE*       pbChksum,   	        // pointer to buffer for chksum data
                    IN OUT DWORD*   pcbChksum		        // number of bytes of chksum (in/out)
                    ) pure; 	    
    // Long filenames support
    virtual BOOL AddPublicW(const wchar_t* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL AddLinesW(const wchar_t* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                          ULONG lineStart, BYTE* pbCoff, long cbCoff) pure;
    virtual BOOL QueryNameW(OUT wchar_t szName[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QuerySrcFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL QueryPdbFileW(OUT wchar_t szFile[PDB_MAX_PATH], OUT long* pcb) pure;
    virtual BOOL AddPublic2(const char* szPublic, USHORT isect, long off, CV_pubsymflag_t cvpsf =0) pure;
    virtual BOOL InsertLines(BYTE* pbLines, long cb) pure;
#endif
};

PdbInterface TPI {             // type info

    enum { intv = PDBIntv };

    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;

    virtual BOOL QueryTi16ForCVRecord(BYTE* pb, OUT TI16* pti) pure;
    virtual BOOL QueryCVRecordForTi16(TI16 ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi16(TI16 ti, OUT BYTE** ppb) pure;
    virtual TI16 QueryTi16Min() pure;
    virtual TI16 QueryTi16Mac() pure;

    virtual long QueryCb() pure;
    virtual BOOL Close() pure;
    virtual BOOL Commit() pure;

    virtual BOOL QueryTi16ForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI16* pti) pure;
    virtual BOOL SupportQueryTiForUDT() pure;

    // the new versions that truly take 32-bit types
    virtual BOOL fIs16bitTypePool() pure;
    virtual BOOL QueryTiForUDT(LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti) pure;
    virtual BOOL QueryTiForCVRecord(BYTE* pb, OUT TI* pti) pure;
    virtual BOOL QueryCVRecordForTi(TI ti, OUT BYTE* pb, IN OUT long* pcb) pure;
    virtual BOOL QueryPbCVRecordForTi(TI ti, OUT BYTE** ppb) pure;
    virtual TI   QueryTiMin() pure;
    virtual TI   QueryTiMac() pure;
    virtual BOOL AreTypesEqual( TI ti1, TI ti2 ) pure;
    virtual BOOL IsTypeServed( TI ti ) pure;
#ifdef LNGNM
    virtual BOOL QueryTiForUDTW(const wchar_t *wcs, BOOL fCase, OUT TI* pti) pure;
#endif
};

PdbInterface GSI {
    enum { intv = PDBIntv };
    virtual INTV QueryInterfaceVersion() pure;
    virtual IMPV QueryImplementationVersion() pure;
    virtual BYTE* NextSym(BYTE* pbSym) pure;
    virtual BYTE* HashSym(const char* szName, BYTE* pbSym) pure;
    virtual BYTE* NearestSym(USHORT isect, long off, OUT long* pdisp) pure;      //currently only supported for publics
    virtual BOOL Close() pure;
    virtual BOOL getEnumThunk(USHORT isect, long off, OUT EnumThunk** ppenum) pure;
    virtual unsigned long OffForSym(BYTE *pbSym) pure;
    virtual BYTE* SymForOff(unsigned long off) pure;
#ifdef LNGNM
    virtual BYTE* HashSymW(const wchar_t *wcsName, BYTE* pbSym) pure;
#endif
    virtual BOOL getEnumByAddr(EnumSyms **ppEnum) pure;
};


PdbInterface NameMap {
    static PDBAPI(BOOL) open(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
    virtual BOOL close() pure;
    virtual BOOL reinitialize() pure;
    virtual BOOL getNi(const char* sz, OUT NI* pni) pure;
    virtual BOOL getName(NI ni, OUT const char** psz) pure;
    virtual BOOL getEnumNameMap(OUT Enum** ppenum) pure;
    virtual BOOL contains(const char* sz, OUT NI* pni) pure;
    virtual BOOL commit() pure;
    virtual BOOL isValidNi(NI ni) pure;
#ifdef LNGNM
    virtual BOOL getNiW(const wchar_t* sz, OUT NI* pni) pure;
    virtual BOOL getNameW(NI ni, OUT wchar_t* szName, IN OUT size_t * pcch) pure;
    virtual BOOL containsW(const wchar_t *sz, OUT NI* pni) pure;
    virtual BOOL containsUTF8(const char* sz, OUT NI* pni) pure;
    virtual BOOL getNiUTF8(const char *sz, OUT NI* pni) pure;
    virtual BOOL getNameA(NI ni, OUT const char ** psz) pure;
    virtual BOOL getNameW2(NI ni, OUT const wchar_t ** pwsz) pure;
#endif
};

#define __ENUM_INCLUDED__
PdbInterface Enum {
    virtual void release() pure;
    virtual void reset() pure;
    virtual BOOL next() pure;
};

PdbInterface EnumNameMap : Enum {
    virtual void get(OUT const char** psz, OUT NI* pni) pure;
};

PdbInterface EnumContrib : Enum {
    virtual void get(OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics) pure;
    virtual void getCrcs(OUT DWORD* pcrcData, OUT DWORD* pcrcReloc ) pure;
    virtual bool fUpdate(IN long off, IN long cb) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumContrib **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};

PdbInterface EnumThunk: Enum {
	virtual void get( OUT USHORT* pisect, OUT long* poff, OUT long* pcb ) pure;
};

PdbInterface EnumSyms : Enum {
    virtual void get( BYTE** ppbSym ) pure;
    virtual BOOL prev() pure;
    virtual BOOL clone( OUT EnumSyms **ppEnum ) pure;
    virtual BOOL locate( IN long isect, IN long off ) pure;
};
struct CV_Line_t;
struct CV_Column_t;
PdbInterface EnumLines: public Enum
{
    // 
    // Blocks of lines are always in offset order, lines within blocks are also ordered by offset
    //
    virtual bool getLines( 	
        OUT DWORD*      fileId, 	// id for the filename
        OUT DWORD*      poffset,	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines, 	// number of lines (in/out)
        OUT CV_Line_t*  pLines		// pointer to buffer for line info
        ) = 0;
    virtual bool getLinesColumns( 	
        OUT DWORD*      fileId,     // id for the filename	    
        OUT DWORD*      poffset, 	// offset part of address
        OUT WORD*	    pseg, 		// segment part of address
        OUT DWORD*      pcb,        // count of bytes of code described by this block
        IN OUT DWORD*   pcLines,    // number of lines (in/out)
        OUT CV_Line_t*  pLines,		// pointer to buffer for line info
        OUT CV_Column_t*pColumns	// pointer to buffer for column info
        ) = 0;
    virtual bool clone( 
        OUT EnumLines **ppEnum      // return pointer to the clone
        ) = 0;
};

//
// interface to use to widen type indices from 16 to 32 bits
// and store the results in a new location.
//
PdbInterface WidenTi {
public:
    static PDBAPI(BOOL)
    fCreate (
        WidenTi *&,
        unsigned cTypeInitialCache =256,
        BOOL fNB10Syms =wtiSymsNB09
        );

    virtual void
    release() pure;

    virtual BYTE /* TYPTYPE */ *
    pTypeWidenTi ( TI ti16, BYTE /* TYPTYPE */ * ) pure;

    virtual BYTE /* SYMTYPE */ *
    pSymWidenTi ( BYTE /* SYMTYPE */ * ) pure;

    virtual BOOL
    fTypeWidenTiNoCache ( BYTE * pbTypeDst, BYTE * pbTypeSrc, long & cbDst ) pure;

    virtual BOOL
    fSymWidenTiNoCache ( BYTE * pbSymDst, BYTE * pbSymSrc, long & cbDst ) pure;

    virtual BOOL
    fTypeNeedsWidening ( BYTE * pbType ) pure;

    virtual BOOL
    fSymNeedsWidening ( BYTE * pbSym ) pure;

    virtual BOOL
    freeRecord ( void * ) pure;

    // symbol block converters/query.  symbols start at doff from pbSymIn,
    // converted symbols will go at sci.pbSyms + doff, cbSyms are all including
    // doff.
    virtual BOOL
        fQuerySymConvertInfo (
        SymConvertInfo &    sciOut,
        BYTE *              pbSym,
        long                cbSym,
        int                 doff =0
        ) pure;

    virtual BOOL
    fConvertSymbolBlock (
        SymConvertInfo &    sciOut,
        BYTE *              pbSymIn,
        long                cbSymIn,
        int                 doff =0
        ) pure;
};

// interface for managing Dbg data
PdbInterface Dbg {
   // close Dbg Interface
   virtual BOOL Close() pure;
   // return number of elements (NOT bytes)
   virtual long QuerySize() pure;
   // reset enumeration index
   virtual void Reset() pure;
   // skip next celt elements (move enumeration index)
   virtual BOOL Skip(ULONG celt) pure;
   // query next celt elements into user-supplied buffer
   virtual BOOL QueryNext(ULONG celt, OUT void *rgelt) pure;
   // search for an element and fill in the entire struct given a field.
   // Only supported for the following debug types and fields:
   // DBG_FPO              'ulOffStart' field of FPO_DATA
   // DBG_FUNC             'StartingAddress' field of IMAGE_FUNCTION_ENTRY
   // DBG_OMAP             'rva' field of OMAP
   virtual BOOL Find(IN OUT void *pelt) pure;
   // remove debug data
   virtual BOOL Clear() pure;
   // append celt elements
   virtual BOOL Append(ULONG celt, const void *rgelt) pure;
   // replace next celt elements
   virtual BOOL ReplaceNext(ULONG celt, const void *rgelt) pure;
   // create a clone of this interface
   virtual BOOL Clone( Dbg** ppDbg ) pure;
};

PdbInterface Src {
    // close and commit the changes (when open for write)
    virtual bool
    Close() pure;

    // add a source file or file-ette
    virtual bool
    Add(IN PCSrcHeader psrcheader, IN const void * pvData) pure;

    // remove a file or file-ette or all of the injected code for
    // one particular compiland (using the object file name)
    virtual bool
    Remove(IN SZ_CONST szFile) pure;

    // query and copy the header/control data to the output buffer
    virtual bool
    QueryByName(IN SZ_CONST szFile, OUT PSrcHeaderOut psrcheaderOut) const pure;

    // copy the file data (the size of the buffer is in the SrcHeaderOut
    // structure) to the output buffer.
    virtual bool
    GetData(IN PCSrcHeaderOut pcsrcheader, OUT void * pvData) const pure;

    // create an enumerator to traverse all of the files included
    // in the mapping.
    virtual bool
    GetEnum(OUT EnumSrc ** ppenum) const pure;

    // Get the header block (master header) of the Src data.
    // Includes age, time stamp, version, and size of the master stream
    virtual bool
    GetHeaderBlock(SrcHeaderBlock & shb) const pure;
#ifdef LNGNM
    virtual bool RemoveW(IN wchar_t *wcsFile) pure;
    virtual bool QueryByNameW(IN wchar_t *wcsFile, OUT PSrcHeaderOut psrcheaderOut) const pure;
    virtual bool AddW(IN PCSrcHeaderW psrcheader, IN const void * pvData) pure;
#endif
};

PdbInterface EnumSrc : Enum {
    virtual void get(OUT PCSrcHeaderOut * ppcsrcheader) pure;
};


PdbInterface SrcHash {

    // Various types we need
    //
    
    // Tri-state return type
    //
    enum TriState {
        tsYes,
        tsNo,
        tsMaybe,
    };

    // Hash identifier
    //
    enum HID {
        hidNone,
        hidMD5,
        hidMax,
    };

    // Define machine independent types for storage of HashID and size_t
    //
    typedef __int32 HashID_t;
    typedef unsigned __int32 CbHash_t;

    // Create a SrcHash object with the usual two-stage construction technique
    //
    static PDBAPI(bool)
    FCreateSrcHash(OUT PSrcHash &);

    // Accumulate more bytes into the hash
    //
    virtual bool
    FHashBuffer(IN PCV pvBuf, IN size_t cbBuf) pure;

    // Query the hash id
    //
    virtual HashID_t
    HashID() const pure;

    // Query the size of the hash 
    //
    virtual CbHash_t
    CbHash() const pure;

    // Copy the hash bytes to the client buffer
    //
    virtual void
    GetHash(OUT PV pvHash, IN CbHash_t cbHash) const pure;

    // Verify the incoming hash against a target buffer of bytes
    // returning a yes it matches, no it doesn't, or indeterminate.
    //
    virtual TriState
    TsVerifyHash(
        IN HID,
        IN CbHash_t cbHash,
        IN PCV pvHash,
        IN size_t cbBuf,
        IN PCV pvBuf
        ) pure;

    // Reset this object to pristine condition
    //
    virtual bool
    FReset() pure;

    // Close off and release this object
    //
    virtual void
    Close() pure;
};

#endif  // __cplusplus

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

typedef BOOL (PDBCALL *PfnPDBOpen)(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **);

PDBAPI(BOOL)
PDBOpen(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szMode,
    SIG sigInitial,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpen2W(
    const wchar_t *wszPDB,
    const char *szMode,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenEx2W(
    const wchar_t *wszPDB,
    const char *szMode,
    long cbPage,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidateEx2(
    LNGNM_CONST char *szPDB,
    LNGNM_CONST char *szPathOrig,
    LNGNM_CONST char *szSearchPath,
    LNGNM_CONST char *szMode,
    SIG sig,
    AGE age,
    long cbPage,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate3(
    const char *szExecutable,
    const char *szSearchPath,
    OUT EC *pec,
    OUT char szError[cbErrMax],
    OUT char szDbgPath[PDB_MAX_PATH],
    OUT DWORD *pfo,
    OUT DWORD *pcb,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate4(
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

PDBAPI(BOOL)
PDBOpenValidate5(
    const wchar_t *wszExecutable,
    const wchar_t *wszSearchPath,
    void *pvClient,
    PfnPDBQueryCallback pfnQueryCallback,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI(BOOL)
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface(void)
{
    return PDBExportValidateInterface(PDBIntv);
}

typedef BOOL (PDBCALL *PfnPDBExportValidateInterface)(INTV);

__inline BOOL PDBValidateInterfacePfn(PfnPDBExportValidateInterface pfn)
{
    return (*pfn)(PDBIntv);
}

PDBAPI(EC)     PDBQueryLastError(PDB *ppdb, OUT char szError[cbErrMax]);
PDBAPI(INTV)   PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI(IMPV)   PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI(char*)  PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI(SIG)    PDBQuerySignature(PDB* ppdb);
PDBAPI(BOOL)   PDBQuerySignature2(PDB* ppdb, PSIG70 psig70);
PDBAPI(AGE)    PDBQueryAge(PDB* ppdb);
PDBAPI(BOOL)   PDBCreateDBI(PDB* ppdb, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenDBIEx(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi, PfnFindDebugInfoFile pfn);
PDBAPI(BOOL)   PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi);
PDBAPI(BOOL)   PDBOpenTpi(PDB* ppdb, const char* szMode, OUT TPI** pptpi);
PDBAPI(BOOL)   PDBCommit(PDB* ppdb);
PDBAPI(BOOL)   PDBClose(PDB* ppdb);
PDBAPI(BOOL)   PDBOpenStream(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
PDBAPI(BOOL)   PDBCopyTo(PDB *ppdb, const char *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBCopyToW(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved);
PDBAPI(BOOL)   PDBfIsSZPDB(PDB *ppdb);
PDBAPI(BOOL)   PDBCopyToW2(PDB *ppdb, const wchar_t *szTargetPdb, DWORD dwCopyFilter, PfnPDBCopyQueryCallback pfnCallBack, void * pvClientContext);

PDBAPI(INTV)   DBIQueryInterfaceVersion(DBI* pdbi);
PDBAPI(IMPV)   DBIQueryImplementationVersion(DBI* pdbi);
PDBAPI(BOOL)   DBIOpenMod(DBI* pdbi, const char* szModule, const char* szFile, OUT Mod** ppmod);
PDBAPI(BOOL)   DBIDeleteMod(DBI* pdbi, const char* szModule);
PDBAPI(BOOL)   DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI(BOOL)   DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI(BOOL)   DBIAddSec(DBI* pdbi, USHORT isect, USHORT flags, long off, long cb);
PDBAPI(BOOL)   DBIAddPublic(DBI* pdbi, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb);
#ifdef LNGNM
PDBAPI(BOOL)   DBIQueryModFromAddr2(DBI* pdbi, USHORT isect, long off, OUT Mod** ppmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG *pdwCharacteristics);
#endif
PDBAPI(BOOL)   DBIQuerySecMap(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQueryFileInfo(DBI* pdbi, OUT BYTE* pb, long* pcb);
PDBAPI(BOOL)   DBIQuerySupportsEC(DBI* pdbi);
PDBAPI(void)   DBIDumpMods(DBI* pdbi);
PDBAPI(void)   DBIDumpSecContribs(DBI* pdbi);
PDBAPI(void)   DBIDumpSecMap(DBI* pdbi);
PDBAPI(BOOL)   DBIClose(DBI* pdbi);
PDBAPI(BOOL)   DBIAddThunkMap(DBI* pdbi, long* poffThunkMap, unsigned nThunks, long cbSizeOfThunk,
                              struct SO* psoSectMap, unsigned nSects, USHORT isectThunkTable, long offThunkTable);
PDBAPI(BOOL)   DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI(BOOL)   DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI(BOOL)   DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI(BOOL)   DBIQueryNextItsm(DBI* pdbi, ITSM itsm, OUT ITSM *inext );
PDBAPI(BOOL)   DBIQueryLazyTypes(DBI* pdbi);
PDBAPI(BOOL)   DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI(BOOL)   DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI(BOOL)   DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);
PDBAPI(BOOL)   DBIAddLinkInfo(DBI* pdbi, IN PLinkInfo);
PDBAPI(BOOL)   DBIQueryLinkInfo(DBI* pdbi, PLinkInfo, IN OUT long * pcb);
PDBAPI(BOOL)   DBIFStripped(DBI* pdbi);

PDBAPI(INTV)   ModQueryInterfaceVersion(Mod* pmod);
PDBAPI(IMPV)   ModQueryImplementationVersion(Mod* pmod);
PDBAPI(BOOL)   ModAddTypes(Mod* pmod, BYTE* pbTypes, long cb);
PDBAPI(BOOL)   ModAddSymbols(Mod* pmod, BYTE* pbSym, long cb);
PDBAPI(BOOL)   ModAddPublic(Mod* pmod, const char* szPublic, USHORT isect, long off);
PDBAPI(BOOL)   ModAddLines(Mod* pmod, const char* szSrc, USHORT isect, long offCon, long cbCon, long doff,
                           USHORT lineStart, BYTE* pbCoff, long cbCoff);
PDBAPI(BOOL)   ModAddSecContrib(Mod * pmod, USHORT isect, long off, long cb, ULONG dwCharacteristics);
PDBAPI(BOOL)   ModQueryCBName(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySymbols(Mod* pmod, BYTE* pbSym, long* pcb);
PDBAPI(BOOL)   ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb);
PDBAPI(BOOL)   ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI(BOOL)   ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI(BOOL)   ModQuerySecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryFirstCodeSecContrib(Mod* pmod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(BOOL)   ModQueryImod(Mod* pmod, OUT USHORT* pimod);
PDBAPI(BOOL)   ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI(BOOL)   ModClose(Mod* pmod);
PDBAPI(BOOL)   ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI(BOOL)   ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySrcFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQueryPdbFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI(BOOL)   ModQuerySupportsEC(Mod* pmod);
PDBAPI(BOOL)   ModQueryTpi(Mod* pmod, OUT TPI** pptpi);
PDBAPI(BOOL)   ModReplaceLines(Mod* pmod, BYTE* pbLines, long cb);

PDBAPI(INTV)   TypesQueryInterfaceVersion(TPI* ptpi);
PDBAPI(IMPV)   TypesQueryImplementationVersion(TPI* ptpi);
// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)   TypesQueryTiForCVRecordEx(TPI* ptpi, BYTE* pb, OUT TI* pti);
PDBAPI(BOOL)   TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE* pb, IN OUT long* pcb);
PDBAPI(BOOL)   TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT BYTE** ppb);
PDBAPI(TI)     TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)     TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(long)   TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)   TypesClose(TPI* ptpi);
PDBAPI(BOOL)   TypesCommit(TPI* ptpi);
PDBAPI(BOOL)   TypesQueryTiForUDTEx(TPI* ptpi, LNGNM_CONST char *sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)   TypesSupportQueryTiForUDT(TPI*);
PDBAPI(BOOL)   TypesfIs16bitTypePool(TPI*);
// Map all old ones to new ones for new compilands.
#define TypesQueryTiForCVRecord     TypesQueryTiForCVRecordEx
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx
#define TypesQueryTiForUDT          TypesQueryTiForUDTEx
PDBAPI(BOOL)    TypesAreTypesEqual( TPI* ptpi, TI ti1, TI ti2 );
PDBAPI(BOOL)    TypesIsTypeServed( TPI* ptpi, TI ti );

PDBAPI(BYTE*)  GSINextSym (GSI* pgsi, BYTE* pbSym);
PDBAPI(BYTE*)  GSIHashSym (GSI* pgsi, const char* szName, BYTE* pbSym);
PDBAPI(BYTE*)  GSINearestSym (GSI* pgsi, USHORT isect, long off,OUT long* pdisp);//currently only supported for publics
PDBAPI(BOOL)   GSIClose(GSI* pgsi);
PDBAPI(unsigned long)   GSIOffForSym( GSI* pgsi, BYTE* pbSym );
PDBAPI(BYTE*)   GSISymForOff( GSI* pgsi, unsigned long off );

PDBAPI(long)   StreamQueryCb(Stream* pstream);
PDBAPI(BOOL)   StreamRead(Stream* pstream, long off, void* pvBuf, long* pcbBuf);
PDBAPI(BOOL)   StreamWrite(Stream* pstream, long off, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamReplace(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamAppend(Stream* pstream, void* pvBuf, long cbBuf);
PDBAPI(BOOL)   StreamDelete(Stream* pstream);
PDBAPI(BOOL)   StreamTruncate(Stream* pstream, long cb);
PDBAPI(BOOL)   StreamRelease(Stream* pstream);

PDBAPI(BOOL)   StreamImageOpen(Stream* pstream, long cb, OUT StreamImage** ppsi);
PDBAPI(void*)  StreamImageBase(StreamImage* psi);
PDBAPI(long)   StreamImageSize(StreamImage* psi);
PDBAPI(BOOL)   StreamImageNoteRead(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageNoteWrite(StreamImage* psi, long off, long cb, OUT void** ppv);
PDBAPI(BOOL)   StreamImageWriteBack(StreamImage* psi);
PDBAPI(BOOL)   StreamImageRelease(StreamImage* psi);

PDBAPI(BOOL)   NameMapOpen(PDB* ppdb, BOOL fWrite, OUT NameMap** ppnm);
PDBAPI(BOOL)   NameMapClose(NameMap* pnm);
PDBAPI(BOOL)   NameMapReinitialize(NameMap* pnm);
PDBAPI(BOOL)   NameMapGetNi(NameMap* pnm, const char* sz, OUT NI* pni);
PDBAPI(BOOL)   NameMapGetName(NameMap* pnm, NI ni, OUT const char** psz);
PDBAPI(BOOL)   NameMapGetEnumNameMap(NameMap* pnm, OUT Enum** ppenum);
PDBAPI(BOOL)   NameMapCommit(NameMap* pnm);

PDBAPI(void)   EnumNameMapRelease(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapReset(EnumNameMap* penum);
PDBAPI(BOOL)   EnumNameMapNext(EnumNameMap* penum);
PDBAPI(void)   EnumNameMapGet(EnumNameMap* penum, OUT const char** psz, OUT NI* pni);

PDBAPI(void)   EnumContribRelease(EnumContrib* penum);
PDBAPI(void)   EnumContribReset(EnumContrib* penum);
PDBAPI(BOOL)   EnumContribNext(EnumContrib* penum);
PDBAPI(void)   EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI(void)   EnumContribGetCrcs(EnumContrib* penum, OUT DWORD* pcrcData, OUT DWORD* pcrcReloc);
PDBAPI(BOOL)   EnumContribfUpdate(EnumContrib* penum, IN long off, IN long cb);

PDBAPI(SIG)    SigForPbCb(BYTE* pb, size_t cb, SIG sig);
PDBAPI(void)   TruncStFromSz(char *stDst, const char *szSrc, size_t cbSrc);

PDBAPI(BOOL)   DbgClose(Dbg *pdbg);
PDBAPI(long)   DbgQuerySize(Dbg *pdbg);
PDBAPI(void)   DbgReset(Dbg *pdbg);
PDBAPI(BOOL)   DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI(BOOL)   DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI(BOOL)   DbgFind(Dbg *pdbg, IN OUT void *pelt);
PDBAPI(BOOL)   DbgClear(Dbg *pdbg);
PDBAPI(BOOL)   DbgAppend(Dbg *pdbg, ULONG celt, const void *rgelt);
PDBAPI(BOOL)   DbgReplaceNext(Dbg *pdbg, ULONG celt, const void *rgelt);

#if __cplusplus
};
#endif

struct SO {
    long off;
    USHORT isect;
    unsigned short pad;
};

#ifndef cbNil
#define cbNil   ((long)-1)
#endif
#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((USHORT)(-1))

#define pdbWrite                "w"
#define pdbRead                 "r"
#define pdbGetTiOnly            "i"
#define pdbGetRecordsOnly       "c"
#define pdbFullBuild            "f"
#define pdbTypeAppend           "a"
#define pdbRepro                "z"
#define pdbFSCompress           "C"

#endif // __PDB_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\sdci.h ===
//
// sdci.h
//
// ODBC/DBLib private entry point 
// Copyright (C) 1996, Microsoft Corp.	All Rights Reserved.
//

#ifndef __SDCI_INCLUDED__
#define __SDCI_INCLUDED__

#ifndef ULONG
typedef unsigned long ULONG;
#endif 

enum {
	cbMaxMchName = 32,
	cbMaxDLLName = 16
};

typedef struct _SDCI {
	ULONG		cbLength;			// size of this struct
	ULONG		dbgpid;				// pid of debugger
	ULONG		pid;				// pid to start/stop debugging 
	char		rgchMchName[cbMaxMchName];	// machine name of debugger
	UNALIGNED void *pvData;				// future use
	ULONG		cbData;				// size of data
	char		rgchSDIDLLName[cbMaxDLLName];	// name of DLL to load
	ULONG		fOption;			// 1 - start debugging; 0 - stop debugging
} SDCI, *PSDCI;


BOOL _stdcall SQLDebug(SDCI *psdci);

typedef BOOL (_stdcall *pfnSQLDebug) (SDCI *psdci);

#define	SDCI_CODE_BREAK		1
#define	SDCI_CODE_ENABLE	2
#define	SDCI_CODE_RESUME	3

#endif // __SDCI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\typesrvr.h ===
// Type server interface.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#if (defined (_M_IX86) && (_M_IX86) < 300) || (_MSC_VER < 800)
#define PDBFAR	__far
#else
#define PDBFAR
#endif

typedef void PDBFAR*	TS;		// type server, opaque type
typedef unsigned short	TI;		// type index
typedef unsigned long	TSIG;	// type database signature
typedef unsigned long	TVER;	// type server version
typedef unsigned long	TAGE;	// type database age
typedef char PDBFAR*		PB;		// pointer to some bytes
typedef unsigned long	CB;		// count of bytes
typedef CB PDBFAR*	PCB;	// pointer to count of bytes
typedef PB				SZ;		// zero terminated string
typedef int				PDBBOOL;// Boolean

#define	tsNil			((TS)0)
#define	tiNil			((TI)0)

#define	tdbWrite				"w"
#define	tdbRead					"r"
#define	tdbGetTiOnly			"i"
#define	tdbGetRecordsOnly		"c"

#ifdef __cplusplus
extern "C" {
#endif

TVER	TypesQueryServerVersion(void);
TS		TypesOpen(SZ szDatabase, SZ szMode, TSIG sig);
TSIG	TypesQuerySignature(TS ts);
TAGE	TypesQueryAge(TS ts);
TI		TypesQueryTiForCVRecord(TS ts, PB pb);
PB		TypesQueryPbCVRecordForTi(TS ts, TI ti);
void	TypesQueryCVRecordForTi(TS ts, TI ti, PB pb, PCB pcb);
TI		TypesQueryTiMin(TS ts);
TI		TypesQueryTiMac(TS ts);
CB		TypesQueryCb(TS ts);
PDBBOOL	TypesCommit(TS ts);
PDBBOOL	TypesClose(TS ts);

#ifdef __cplusplus
};
#endif

struct THDR { // type database header:
	char	szMagic[0x2C];
	TVER	tver;			// version which created this file
	TSIG	tsig;			// signature
	TAGE	tage;			// age (no. of times written)
	TI		tiMin;			// lowest TI
	TI		tiMac;			// highest TI + 1
	CB		cb;				// count of bytes used by the gprec which follows.
	// rest of file is "REC gprec[];"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\simparray.h ===
#pragma once
#include "crefobj.h"

template <class T>
class SimpleArray : public CRefCountedObj {
protected:
    size_t      _cT;
    T *         _rgT;

public:
    SimpleArray ( size_t cT ) {
        if ( cT ) {
            _rgT = new T[cT];
            if ( _rgT ) {
                _cT = cT;
                }
            }
        else {
            _cT = 0;
            _rgT = 0;
            }
        }

    ~SimpleArray() {
        if ( _rgT ) {
            delete [] _rgT;
            }
        _cT = 0;
        _rgT = 0;
        }

    size_t Count() const {
        return _cT;
        }

    const T * Base() const {
        return _rgT;
        }

    T * Base() {
        return _rgT;
        }

    T & operator[] ( unsigned it ) {
        return _rgT[it];
        }

    const T & operator[] ( unsigned it ) const {
        return _rgT[it];
        }
    };

class SimpleString: public SimpleArray<char>
{
public:
    size_t Length() const { return strlen( _rgT ); } // # non-nulls
    const char* operator=( const char *str ) {
        return Set( str, strlen( str ) );
    }
    bool operator==( SimpleString& str ) { return *this == str.Base(); }
    bool operator!=( SimpleString& str ) { return !(*this == str); }
    bool operator==( const char* str ) {
        return strcmp( str, Base() ) == 0; 
    }
    bool operator!=( const char* str ) { return !(*this == str); }
    void Clear() {
        assert( Count() > 0 );
        Set( "", 0 );
    }
    const char* Set( const char* str, size_t len ) {
        Grow( len+1 );
        strncpy( _rgT, str, len );
        _rgT[ len ] = '\0';
        return Base();
    }
    SimpleString( const SimpleString& str ) 
        : SimpleArray<char>( str.Length()+1 ) {
        Set( str.Base(), str.Length()+1 );
    }
    SimpleString( unsigned len = 256 ) : SimpleArray<char>( max( len, 1 ) ) {
        Set( "", 0 );
    }
private:
    bool Grow( size_t cb ) {
        if ( Count() < cb ) {
            delete [] _rgT;
            _rgT = new char[cb];
            _cT = cb;
        }
        return _rgT != 0;
    }

};
    
class SimpleUString: public SimpleArray<wchar_t>
{
public:
    size_t Length() const { return wcslen( _rgT ); } // # non-nulls
    const wchar_t* operator=( const wchar_t *str ) {
        return Set( str, wcslen( str ) );
    }
    bool operator==( SimpleUString& str ) { return *this == str.Base(); }
    bool operator!=( SimpleUString& str ) { return !(*this == str); }
    bool operator==( const wchar_t* str ) {
        return wcscmp( str, Base() ) == 0; 
    }
    bool operator!=( const wchar_t* str ) { return !(*this == str); }
    void Clear() {
        assert( Count() > 0 );
        Set( L"", 0 );
    }
    const wchar_t* Set( const wchar_t* str, size_t len ) {
        Grow( len+1 );
        wcsncpy( _rgT, str, len );
        _rgT[ len ] = L'\0';
        return Base();
    }
    SimpleUString( const SimpleUString& str ) 
        : SimpleArray<wchar_t>( str.Length()+1 ) {
        Set( str.Base(), str.Length() );
    }
    SimpleUString( size_t len = 256 ) : SimpleArray<wchar_t>( max( len, 1 ) ) {
        Set( L"", 0 );
    }
private:
    bool Grow( size_t cch ) {
        if ( Count() < cch ) {
            delete [] _rgT;
            _rgT = new wchar_t[cch];
            _cT = cch;
        }
        return _rgT != 0;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\sqlguid.h ===
// Interface ID for SQL Execution control

DEFINE_GUID(IID_ISqlExec, 
0xfbca3ca2, 0x6abe, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\vcver.h ===
#ifndef _VC_VER_INC
#define _VC_VER_INC
#ifndef _VC_VER
#define _VC_VER 550
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\version.h ===
// DO NOT EDIT OR MODIFY!
// Automatically Generated File!
// Sat 01/05/2002@ 0:00:56.41, jdate = 9466
//
#define rmj 7 
#define rmm 0
#define rup 9466
#define szVerName  "Visual Studio 7.0"
#define szVerUser  "$Client: VSBLD208 $"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\verstamp.h ===
#ifndef _VERSION_H_INCL
#include "version.h"                   /* SLM maintained version file */
#endif
#include "bld_version.h"               /* User maintained build version */

#if defined(_WIN32) || defined(WIN32)
#include <winver.h>
#else   /* !WIN32 */
#include <ver.h>
#endif  /* !WIN32 */

#if     (rmm < 10)
#define rmmpad "0"
#define rmmpad_W L"0"
#else
#define rmmpad
#define rmmpad_W
#endif

#if     (rbld == 0)
#define VERSION_STR1(a,b,c,d)       #a "." rmmpad #b "." ruppad #c
#define VERSION_STR1_W(a,b,c,d)     L#a L"." rmmpad_W L#b L"." ruppad_W L#c
#else
#define VERSION_STR1(a,b,c,d)       #a "." rmmpad #b "." ruppad #c "." #d
#define VERSION_STR1_W(a,b,c,d)     L#a L"." rmmpad_W L#b L"." ruppad_W L#c L"." L#d
#endif

#if     (rup < 10)
#define ruppad "000"
#define ruppad_W L"000"
#elif   (rup < 100)
#define ruppad "00"
#define ruppad_W L"00"
#elif   (rup < 1000)
#define ruppad "0"
#define ruppad_W L"0"
#else
#define ruppad
#define ruppad_W
#endif

#define VERSION_STR2(a,b,c,d)       VERSION_STR1(a,b,c,d)
#define VERSION_STR2_W(a,b,c,d)     VERSION_STR1_W(a,b,c,d)
#define VER_PRODUCTVERSION_STR      VERSION_STR2(rmj,rmm,rup,rbld)
#define VER_PRODUCTVERSION_STR_W    VERSION_STR2_W(rmj,rmm,rup,rbld)
#define VER_PRODUCTVERSION          rmj,rmm,rup,rbld

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD            0
#else
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE              0
#else
#define VER_PRERELEASE              VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS                  VOS__WINDOWS32
#else
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_COMPANYNAME_STR_W       L"Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Visual Studio .NET"
#define VER_PRODUCTNAME_STR_W       L"Microsoft\256 Visual Studio .NET"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\ssvc.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    ssvc.h

Abstract:

    This header contains the enumeration of system services provided
    by OSDebug 4.

Author:

    Kent Forschmiedt (kentf) 09-Oct-1996

Environment:

    Win32, User Mode

--*/



typedef enum {
        ssvcNull = 0,
        ssvcDumpLocalHeap,
        ssvcDumpGlobalHeap,
        ssvcDumpModuleList,
        ssvcCrackLocalHmem,
        ssvcCrackGlobalHmem,
        ssvcKillApplication,
        ssvcFreeLibrary,
        ssvcInput,
        ssvcOutput,
        ssvcOleRpc,             // Enable/disable OLE Remote Procedure Call tracing
                                    // Pass cb = 1, rgb[0] = fEnable.  Before this is
                                    // called the first time, OLE RPC debugging is
                                    // disabled.  Also see mtrcOleRpc.
        ssvcHackFlipScreen,     // Hack for testing: toggle switching previous
                                    // foreground window back to foreground on F8/F10.
        ssvcNativeDebugger,     // Activate remote debugger
        ssvcSetETS,
        ssvcCvtRez2Seg,
        ssvcSqlDebug,
        ssvcFiberDebug,
} SSVC;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\zxenc.h ===
//
// zxenc.h
//
// Define common structs used by Edit and Continue communications between
// the IDE and the C/C++ compiler.
//

#ifndef _ZXENC_INC
#define _ZXENC_INC

//
// Header at the start of the memory-mapped buffer holding the text to
// compile from memory.
//
// [in]   Set by IDE, read by compiler
// [out]  Set by compiler, read by IDE

struct EncMemBufHeader {
    DWORD   dwVersion;      // [in]  version control number
    DWORD   dwOff;          // [in]  offset of text buffer start from header
    DWORD   dwLen;          // [in]  length of text buffer
    DWORD   dwOffRead;      // [out] offset in buffer of PCH read point
    BOOL    bSetProcessWorkingSetSizeOK;
                            // [out] TRUE if SetProcessWorkingSetSize in
                            //       compiler succeeded
    HANDLE  hBufDoneEvent;  // [in]  event fired by compiler when preparing
                            //       to read the PCH, after dwOffRead set
    HANDLE  hKillEvent;     // [in]  event fired by IDE to kill the compile
                            //       after compiler has read PCH and paused
    HANDLE  hContinueEvent; // [in]  event fired by IDE to allow compile to
                            //       continue after pausing once PCH read
};

#define ENC_MEMBUF_VERNO    0x0001

#endif  // _ZXENC_INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\assert_.h ===
// assert_.h - assert specific to the pdb project
extern "C" void ncfailAssertion(const char* szFile, int line);
extern "C" void failExpect(const char* szFile, int line);
#if defined(_DEBUG)
#define assert(x)		if (!(x)) { ncfailAssertion(__FILE__, __LINE__); } else
#define verify(x)		assert(x)
#define	dassert(x)		assert(x)
#define expect(x)		if (!(x)) { failExpect(__FILE__, __LINE__); } else
extern BOOL rgbEnableDiagnostic[20];
#define	dprintf(args)	printf args
#define	debug(x)		x
#else
#define assert(x)
#define verify(x)		(x)
#define	dassert(x)
#define expect(x)
#define	dprintf(args)
#define	debug(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\bscext.h ===
// bscext.h
//	Extension for the bsc interface
#ifndef __BSCEXT_H__
#define __BSCEXT_H__

#include "bsc.h"

#if CC_MULTIPLE_STORES
#undef IINST_GLOBALS
#undef isTheGlobalIinst
#undef iinstNil

#define IINST_GLOBALS   0x0FFF0001
#define isTheGlobalIinst(iinst)    (((iinst) & 0x0FFFFFFF) == IINST_GLOBALS)
#define iinstNil 0x0FFFFFFF

// store type
enum STORE_TYP {
	ST_PREBUILT, ST_CXXRT, 
	// ST_USER must be the last one
	ST_USER
};
#else
#pragma message("Not Using Multiple Stores ...")
#endif	// CC_MULTIPLE_STORES

PdbInterface NcbNameMap;

// NCB language attributes:
#define NCB_LANGUAGE_ALL		0xff
#define NCB_LANGUAGE_CPP		0x01
#define NCB_LANGUAGE_JAVA		0x02
#define NCB_LANGUAGE_ODL		0x04
#define NCB_LANGUAGE_FORTRAN	0x08
#define NCB_LANGUAGE_HTML		0x10

enum __BSCEX_SEARCHOPT
{
    SRCH_SEARCHPREBUILTS = 0x01,
    SRCH_SCOPEDSEARCH    = 0x02
};

typedef DWORD BSCEX_SEARCHOPT;

PdbInterface BscEx : public Bsc
{
	virtual BOOL irefEndInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL idefEndInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL getGlobalsFrImod (IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual void setLanguage (BYTE bLanguage) pure;
	virtual void getLanguage (BYTE * pbLanguage) pure;
	virtual BOOL isModInLang (BYTE bLanguage, IMOD imod) pure;

	// IDL interfaces
	virtual BOOL getIDLAttrib (IINST iinst, OUT IINST **ppiiAttr, OUT ULONG *pciinst) pure;
	virtual BOOL getIDLAttribVal (IINST iiAttr, OUT SZ *pszValue) pure;
	virtual BOOL isIDLAttrib (IINST iinst, SZ szAttrib, OUT IINST *piiAttr, OUT SZ *pszValue) pure;
	virtual BOOL filterInTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) pure;
	virtual BOOL filterOutTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) pure;
	virtual BOOL getIDLMFCComment (IINST iinst, OUT IINST **ppiiComment, OUT ULONG * pciinst) pure;
	virtual BOOL getIDLMFCCommentClass (IINST iiComment, OUT SZ * pszClass) pure;
	virtual BOOL isIDLMFCComment (IINST iinst, SZ szType, OUT IINST * piiComment, OUT SZ * pszValue) pure;
	// back to general interface

	// get the line number for the declaration
	virtual BOOL ideclInfo(IINST iinst, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL ideclInfo(IINST iinst, OUT SZ *pszModule, OUT LINE *piline, OUT LINE *piEndline) pure;
	virtual BOOL getMapIinst (IINST iiClass, SZ szMapType, OUT IINST **ppIinst, OUT ULONG * pciinst) pure;
	virtual BOOL getAllArray (MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst) pure;
	virtual BOOL isLangInProject (BYTE bLanguage) pure;

#if CC_MULTIPLE_STORES
	// store specific API
	virtual BOOL isExistingStore(SZ szName, OUT STORE_TYP* pst, OUT USHORT* psi) pure;
	virtual SZ   szFrStoreTyp(STORE_TYP st) pure; 
	virtual BOOL getAllStoresArray(OUT NI** ppni, OUT USHORT* pcStores) pure;
	virtual SZ   szFrStoreIndex(USHORT idx) pure;
#endif	// CC_MULTIPLE_STORES

	// get type with name inserted in proper position
	virtual SZ   getTypeWithName(IINST iinst, SZ szName) pure;
    
	// Support for searching global array of NIs
	virtual ULONG InitializeNIArrays(NcbNameMap *pncbnmpCurClass, NcbNameMap *pncbnmpCurFunc, BOOL fAddPrebuiltStore) pure;
	virtual void ReleaseNIArrays() pure;
	virtual	BOOL GetInfoOnIndexIntoNIArrays (ULONG uIndex, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr, OUT IINST *piinst) pure;
	virtual BOOL GetBestMatch(SZ_CONST szSoFar, long iLength, long *piIndex, SZ *pszUnambiguousMatch) pure;
	virtual BOOL GetEmptyNcbNameMap(BOOL fAllowDuplicates, OUT NcbNameMap ** ppncbnmp) pure;
	virtual BOOL GetClassMembersNameMap(IINST iinst, SZ szTemplateArgs, BOOL fAllowDuplicates, BOOL fOnlyBases, OUT NcbNameMap ** ppncbnmp, BOOL fConstructors) pure;
	virtual BOOL GetNameSpaceNameMap(SZ szNS, OUT NcbNameMap ** ppncbnmp) pure;
	
	// compare two IINST if they have the same signature
	virtual BOOL compareIinst (IINST iinst1, IINST iinst2, DWORD * pdwFlags) pure;

	// get attributes for an iinst
	virtual BOOL getAttributeArray(IINST iinst, OUT IINST ** ppiinst, OUT ULONG * pciinst) pure;
	virtual BOOL getGlobalAttributeArray(OUT IINST ** ppiinst, OUT ULONG * pciinst) pure;

	virtual BOOL getParentIinst(IINST iinstChild, IINST *piinstParent) pure;
	virtual BOOL isIinstInProject(IINST iinst) pure;
	virtual BOOL isIinstInProject(HTARGET htarget, IINST iinst) pure;
	virtual BOOL isUserIinst(IINST iinst) pure;

	// returns an mbf with all bits set for which TypFilter(typ, mbfXXX) == true
	virtual MBF TypToMBF(TYP typ) pure;

	// returns whether the given IINST is in the given language
	virtual BOOL isIinstInLang(BYTE bLanguage, IINST iinst) pure;

	// get the project a particular IINST is part of
	virtual BOOL getProjectForIinst(IINST iinst, OUT HTARGET* phTarget) pure;

	virtual BOOL getAllTarget(IMOD imod, OUT HTARGET ** ppTarget, OUT ULONG * pcTarget) pure;
	virtual USHORT IModFrIinst(IINST iinst) pure;

	// given a pattern, return all the strings stored in the named index map that match that pattern
	virtual BOOL getNIsWithPattern(SZ szPattern, SZ **ppNIs, ULONG *pcNIs) pure;

	// get all the IINSTs that this string appears in
	virtual BOOL getRefInfo(SZ szName, IINST **ppiinst, ULONG *pciinst) pure;

	// conversion from an imod to its corresponding iinst
	virtual IINST getModuleIinst(IMOD imod) pure;
	
	// get the name for this iinst including any parent namespaces
	virtual BOOL iinstNameWithNamespace(IINST iinst, SZ szOut, ULONG_PTR cchOut, ULONG_PTR *pcchNeeded) pure;

	// gets the declaration iinst given a definition iinst
	virtual BOOL getDeclForDefn(SZ sz, TYP typ, ATR32 atr, IINST defnIinst, OUT IINST *piinst) pure;
    virtual SZ  getMacroDefinition(IINST iinst) pure;
    // get an overload 
	virtual BOOL getOverloadArrayWithWildcard(SZ sz, MBF mbf, BSCEX_SEARCHOPT eSrcOpts, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;	
	// extended iinst search functions
	virtual BOOL getIinstByvalue3(SZ sz, TYP typ, ATR32 atr, OUT IINST** ppiinst, OUT ULONG* pciinst) pure;
	virtual BOOL getIinstByvalue3(HTARGET hTarget, BYTE bLanguage, SZ sz, TYP typ, ATR32 atr, OUT IINST** ppiinst, OUT ULONG* pciinst) pure;

	virtual SZ getAttributeParam(IINST iinst, USHORT index, BOOL *pfisDefault) pure;
};

#endif __BSCEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\dllmap.h ===
#ifndef __DLLMAP_H__
#define __DLLMAP_H__

#define BEGIN_DLLNAME_MAP(var)		inline CFuncInfo * GetFuncInfo##var(void) { static CFuncInfo s_arrFuncInfo[] = {
#define FUNCTION_ITEM(name)	{ name, 0},
#define END_DLLNAME_MAP()		{0,0}}; return s_arrFuncInfo; }

#define FUNC_PROLOGUE()			if (!DllInit()) return FALSE;

#define INIT_WRAPPER(name)			protected:\
										name() {};\
									public:\
										name (const _TCHAR * szDll) :\
											CDllWrapper (szDll, GetFuncInfo##name())\
										{};

#define DECLARE_DLLWRAPPER(var, cls, dll)	cls var (dll);

struct CFuncInfo
{
	TCHAR *	m_szRoutine;
	FARPROC			m_pfn;
};

// wrapper class for Dll Loading
class CDllWrapper 
{
protected:
	CDllWrapper() {}; // private default ctor
	CFuncInfo * m_arrFuncInfo;	// array of functions loaded
private:
	BOOL m_fDllInit;		// check if we have tried to load or not
	HINSTANCE	m_hInst;	// handle to dll
	_TCHAR		m_szDll[_MAX_PATH]; // dll name
public:
	CDllWrapper (const _TCHAR * szDll, CFuncInfo * arrFuncInfo)
	{
		m_arrFuncInfo = arrFuncInfo;
		m_fDllInit = FALSE;
		m_hInst = 0;
		_tcscpy (m_szDll, szDll);
	}

	~CDllWrapper ()
	{
		if (m_hInst)
			FreeLibrary (m_hInst);
		m_hInst = 0;
		m_fDllInit = FALSE;
	}

	// initialiaze dll only if we have never tried to load
	BOOL DllInit ()
	{
		if (m_hInst)
			return TRUE;
		else if (m_fDllInit)
			return FALSE;
		else 
		{
			HINSTANCE hInst = LoadLibrary (m_szDll);
			m_fDllInit = TRUE;
			if (hInst)
			{
				m_hInst = hInst;
				CFuncInfo * arrFuncInfo;
				BOOL fRoutineOK = TRUE;

				for (arrFuncInfo = m_arrFuncInfo; arrFuncInfo->m_szRoutine; arrFuncInfo++)
				{
					fRoutineOK = fRoutineOK &&
						(arrFuncInfo->m_pfn = GetProcAddress (hInst, arrFuncInfo->m_szRoutine));
					if (!fRoutineOK)
					{
						char szBuf[2048];
						sprintf (szBuf, "Cannot load library: %s because of GetProcAddress (%s) fails\n", m_szDll, arrFuncInfo->m_szRoutine); 
						_ASSERT (szBuf);
						break;
					}
				}

				if (!fRoutineOK)
				{
					FreeLibrary (hInst);
					m_hInst = 0;
					return FALSE;
				}
			}
			else
				return FALSE;
		}
		return TRUE;
	}

	BOOL FInit () const 
	{
		return m_fDllInit;
	}

	BOOL FLoaded () const
	{
		return m_hInst != 0;
	}

	FARPROC FuncMap( UINT iRoutine ) 
	{
		return m_arrFuncInfo[iRoutine].m_pfn;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\feacp.h ===
#pragma once

#include "IDE_ParseInfo.h"

// NOTE: These prototypes are also defined in cxxfe\sl\p1\c\main.c
// If you change them here, change them there
extern "C" {

//
// FEACP dll entrypoint to parse a source file and populate the NCB with the
// results.  This is called for a file on disk, generally by the IDE when
// creating a new NCB or after a file has been saved in the editor.
//
	int WINAPI DoRealParse(
			NcbParseEx *	pNCBDB,
			IMOD			imod,
			HTARGET			hTarget,
			PYCBCALLBACK	pCallBack,
			int				argc,
			char **			argv
	);


//
// FEACP dll entrypoint to parse a source file and populate the NCB with the
// results.  This is called for a file in memory, generally by the IDE during
// dynamic parsing.
//
	int WINAPI DoRealParseFromBuffer(
			NcbParseEx *	pNCBDB,
			IMOD			imod,
			HTARGET			hTarget,
			PYCBCALLBACK	pCallBack,
			int				argc,
			char **			argv,
			void *			pFileBuf,
			ULONG			cbFileBuf
	);


//
// FEACP dll entrypoint to parse a prototype for a function and then do
// signature matching on that prototype against the NCB, looking for the
// matching IINST, which is returned.
//
	int WINAPI ParseFunction(
			int argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to compile
			ULONG			cbFileBuf,			// [in] length of source buffer
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			PFNALLOC		pfnalloc,			// [in] memory allocator
			char ***		prgArray,			// [out] array with (retval, 
												//       funcname, [params...])
			ULONG *			puSize,				// [out] size of array
			IINST *			piinst,				// [in/out] IINST for the 
												//          resolved symbol
			DWORD *			pdwFlags,			// [out] E_PARSE_*
			DWORD			dwParseFlags		// [in] PF_*
	);


//
// FEACP dll entrypoint to signature matching on two prototypes from the 
// NCB given the IINST's for the two functions.
//
	int WINAPI SignatureMatch(
			int				argc,
			char **			argv,
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			IINST			iinst1,				// [in] IINST for the first 
												//      symbol
			IINST			iinst2,				// [in] IINST for the second 
												//      symbol
			DWORD *			pdwFlags			// [out] E_PARSE_*
	);

//
// FEACP dll entrypoint to assist autocompletion on the right hand side of a
// -> or . operator.  We are passed the text of the current function.  Parse
// until the points-to expression, then return the type of the left-hand side
// (without pointer) as a string, e.g. given
//
//		void foo(void) {
//			CFoo *pfoo;
//			pfoo-><!>; // cursor position at the <!>
//		}
//
// this will return the string "CFoo".
//
	int WINAPI GetTypeFromBuffer(
			int				argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to compile
			ULONG			cbFileBuf,			// [in] length of source buffer
			ULONG			ulCaretLoc,			// [in] offset of cursor 
												//      position 
												//      in source buffer
			int				nStartLine,			// [in] line # of start of 
												//      source buffer
			int				nStopLine,			// [in] line # of cursor 
												//      position in source 
												//      buffer
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			char *			szTypeBuf,			// [out] buffer for returning 
												//       type name
			int				cbTypeBuf,			// [in] length of buffer for 
												//      returning type 
			USHORT			targetImod,			// [in] the file where we are trying QI or AC
			ULONG			parentCl			// [in] the class whose inline member function we are in
	);


//
// FEACP dll entrypoint to perform "identifier info" dynamic parsing.  We are
// passed the text of the current function, with the cursor position on some
// identifier.  Parse up to that identifier, then return a string giving the
// type and name (e.g. "CFoo *pfoo").
//
	int WINAPI GetIdentTypeFromBuffer(
			int				argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to compile
			ULONG			cbFileBuf,			// [in] length of source buffer
			ULONG			ulCaretLoc,			// [in] offset of cursor 
												//      position in source 
												//      buffer
			int 			nStartLine,			// [in] line # of start of 
												//      source buffer
			int 			nStopLine,			// [in] line # of cursor 
												//      position in source 
												//      buffer
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			char *			szTypeBuf,			// [out] buffer for returning 
												//       type name
			int				cbTypeBuf,			// [in] length of buffer for 
												//      returning type 
			USHORT			targetImod,			// [in] the file where we are trying QI or AC
			ULONG			parentCl			// [in] the class whose inline member function we are in
	);


//
// FEACP dll entrypoint to parse a block of text and report errors in there
//
	int WINAPI DoParseForErrors(
			int				argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to parse for errors
			ULONG			cbFileBuf,			// [in] length of source buffer
			int				nStartLine,			// [in] line # of start of 
												//      source buffer
			int				nStopLine,			// [in] line # of end of source 
												//      buffer
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			PFNREPORTERROR	pfnReportError		// [in] pfn to report errors
	);


//
// FEACP dll entrypoint to parse a block of text and report decl line# info
//
	int WINAPI DoParseTree(
			int				argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to parse for errors
			ULONG			cbFileBuf,			// [in] length of source buffer
			int				nStartLine,			// [in] line # of start of 
												//      source buffer
			int				nStopLine,			// [in] line # of end of source 
												//      buffer
			BscEx *			pNCBDB,				// [in] NCB store to query for 
												//      type info
			PFNALLOC		pfnAlloc,			// [in] pfn to allocator
			IDE_Decl_t **	ppDeclTree			// [out] ptr to decl tree
	);


//
// FEACP dll entrypoint to report include files in a buffer
//
	int WINAPI DoListIncludesFromBuffer(
			int				argc,
			char **			argv,
			void *			pFileBuf,			// [in] ptr to buffer of source 
												//      to list includes from
			ULONG			cbFileBuf,			// [in] length of source buffer
			int				nStartLine,			// [in] line # of start of 
												//      source buffer
			int				nStopLine,			// [in] line # of end of source 
												//      buffer
			PFNREPORTINC	pfnReportInclude	// [in] pfn to report an 
												//      include file
	);


//
// FEACP dll entrypoint to report include files for current file
//
	int WINAPI DoListIncludes(
			int				argc,
			char **			argv,
			PFNREPORTINC	pfnReportInclude	// [in] pfn to report an 
												//      include file
	);


//
// FEACP entry point to parse for reference information in a file.
//
	int WINAPI DoReferenceParse(
			NcbParseEx *	pNcbParseEx,
			BscEx *			pBscEx,
			IMOD 			imod,
			PYCBCALLBACK 	pCallBack,
			int 			argc,
			char **			argv
	);


//
// FEACP entry point to parse for reference information from a buffer.
//
	int WINAPI DoReferenceParseFromBuffer (
			NcbParseEx *	pNcbParseEx,
			BscEx *			pBscEx,
			IMOD			imod,
			PYCBCALLBACK	pCallBack,
			int				argc,
			char **			argv,
			void *			pFileBuf,			// buffer of source to parse
			ULONG			cbFileBuf			// length of source buffer
	);


//
// FEACP dll entrypoint to assist autocompletion when not in a points-to
// expression.  We are passed the text of the current function.  Parse up to
// the cursor position, then return a list of all in-scope local variables and
// types collected in an NcbNameMap.
//
	int WINAPI GetLocalsInScopeFromBuffer(
			int				argc,
			char **			argv,
			void *			pFileBuf,		// [in] ptr to buffer of source to 
											//      compile
			ULONG			cbFileBuf,		// [in] length of source buffer
			ULONG			ulCaretLoc,		// [in] offset of cursor position 
											//      in source buffer
			int				nStartLine,		// [in] line # of start of source 
											//      buffer
			int				nStopLine,		// [in] line # of cursor position 
											//      in source buffer
			BscEx *			pNCBDB,			// [in] NCB store to query for type 
											//      info
			NcbNameMap **	ppNcbNmp		// [out] NameMap for returning all 
											//       locals in scope
	);

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\bsc_wrap.h ===
/*
 * This file exists simply to fake the type of "ATR"; although ATR is
 * typedef'd in <bsc.h> as a USHORT, NCB needs to pretend that it is a
 * DWORD as more bits are needed to support MC++. This lets us get
 * away with not affecting current Bsc code. However, a client's
 * ability to transparently access NCB and BSC stores via the same
 * interface is lost. Accessing NCB stores via any member function
 * that takes an ATR* as an argument is likely to trash the caller's
 * stack frame or cause an access violation.
 */

#ifndef EXTENDED_ATTRIBUTES_HACK
#define EXTENDED_ATTRIBUTES_HACK /* causes <bsc.h> to typedef ATR as a
									DWORD rather than USHORT */		
#endif
#include <bsc.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\feload.h ===
#ifndef __FELOAD_H__
#define __FELOAD_H__

#include "dllmap.h"
#include "IDE_ParseInfo.h"

BEGIN_DLLNAME_MAP(CFELoader)
	FUNCTION_ITEM("_DoRealParse@24")
	FUNCTION_ITEM("_DoRealParseFromBuffer@32")
	FUNCTION_ITEM("_ParseFunction@44")
	FUNCTION_ITEM("_SignatureMatch@24")
	FUNCTION_ITEM("_GetTypeFromBuffer@48")
	FUNCTION_ITEM("_GetIdentTypeFromBuffer@48")
	FUNCTION_ITEM("_DoParseForErrors@32") 
	FUNCTION_ITEM("_DoParseTree@36")
	FUNCTION_ITEM("_DoListIncludesFromBuffer@28")
	FUNCTION_ITEM("_DoListIncludes@12")
	FUNCTION_ITEM("_DoReferenceParse@24")
	FUNCTION_ITEM("_DoReferenceParseFromBuffer@32")
	FUNCTION_ITEM("_GetLocalsInScopeFromBuffer@36")
END_DLLNAME_MAP()

class CFELoader : CDllWrapper {
	INIT_WRAPPER (CFELoader);

public:
	
	// Typedef definitions
//	typedef int (FAR WINAPI *ENTRYPROC) (NcbParse *, IMOD, HTARGET, void *, int, char **);
	
//	typedef int (FAR WINAPI *ENTRYBUFFERPROC) (NcbParse *, IMOD, HTARGET, void *, int, char **, LPCCH, ULONG);

	typedef int (FAR WINAPI *tdefDoRealParse) (NcbParse *, IMOD, HTARGET, void *, int, char **);

	typedef int (FAR WINAPI *tdefDoRealParseFromBuffer) (NcbParse *, IMOD, HTARGET, void *, int, char **, void *, ULONG);

	typedef int (FAR WINAPI *tdefParseFunction) (int, char **, void *, ULONG, BscEx *, PFNALLOC, char ***, ULONG *, IINST *, DWORD *, DWORD);

	typedef int (FAR WINAPI *tdefGetTypeFromBuffer) (int argc, char **, void *, ULONG, ULONG, ULONG, ULONG, BscEx *, char *, int, USHORT, ULONG);

	typedef int (FAR WINAPI *tdefSignatureMatch) (int, char **, BscEx *, IINST, IINST, DWORD *);	

	typedef int (FAR WINAPI *tdefGetIdentTypeFromBuffer) (int, char **, void *, ULONG, ULONG, ULONG, ULONG, BscEx *, char *, int, USHORT, ULONG);

	typedef int (FAR WINAPI *tdefDoParseForErrors) (int, char **, void *, ULONG, int, int, BscEx *, PFNREPORTERROR);
	
	typedef int (FAR WINAPI *tdefDoParseTree) (int, char **, void *, ULONG, int, int, BscEx *, PFNALLOC, IDE_Decl_t **);
	
	typedef int (FAR WINAPI *tdefDoListIncludesFromBuffer) (int, char **, void *, ULONG, int, int, PFNREPORTINC);
	
	typedef int (FAR WINAPI *tdefDoListIncludes) (int, char **, PFNREPORTINC);
	
	typedef int (FAR WINAPI *tdefDoReferenceParse) (NcbParse *, BscEx *, IMOD, void *, int, char **);
	
	typedef int (FAR WINAPI *tdefDoReferenceParseFromBuffer) (NcbParse *, BscEx *, IMOD, void *, int, char **, void *, ULONG);

	typedef int (FAR WINAPI *tdefGetLocalsInScopeFromBuffer)(int, char **, void *, ULONG, ULONG, int, int, BscEx *, NcbNameMap **);



	
	// Member Functions
	int DoRealParse (NcbParse *pNCBDB, IMOD imod, HTARGET hTarget, PYCBCALLBACK pfnIncludeInProject, int argc, char **argv)
	{
		FUNC_PROLOGUE();
		return tdefDoRealParse(FuncMap(0)) (pNCBDB, imod, hTarget, pfnIncludeInProject, argc, argv);
	};

	
	int DoRealParseFromBuffer (NcbParse *pNCBDB, IMOD imod, HTARGET hTarget, PYCBCALLBACK pfnIncludeInProject, int argc, char **argv, void *szBuf, ULONG cbBuf) 
	{
		FUNC_PROLOGUE();
		return tdefDoRealParseFromBuffer (FuncMap(1)) (pNCBDB, imod, hTarget, pfnIncludeInProject, argc, argv, szBuf, cbBuf);
	};

	
	int ParseFunction (
		int				argc,
		char**			argv,
		void*			pFileBuf,		// [in] ptr to buffer of source to compile
		ULONG			cbFileBuf,		// [in] length of source buffer
		BscEx*			pNCBDB,			// [in] NCB store to query for type info
		PFNALLOC		pfnalloc,		// [in] memory allocator
		char***			prgArray,		// [out] array with (retval, funcname, [params...])
		ULONG*			puSize,			// [out] size of array
		IINST*			piinst,			// [in/out] IINST for the resolved symbol
		DWORD*			pdwFlags,		// [out] E_PARSE_*
		DWORD			dwParseFlags)	// [in] PF_*
	{
		FUNC_PROLOGUE();
		return tdefParseFunction (FuncMap(2)) (argc, argv, pFileBuf, cbFileBuf, pNCBDB, pfnalloc, prgArray, puSize, piinst, pdwFlags, dwParseFlags);
	};

	
	int SignatureMatch(
		unsigned argc, 
		char ** argv, 
		BscEx* pNCB, 
		IINST iinst1, 
		IINST iinst2, 
		DWORD* pdwFlags)
	{
		FUNC_PROLOGUE();
		return tdefSignatureMatch (FuncMap(3)) (argc, argv, pNCB, iinst1, iinst2, pdwFlags);
	};

	
	int GetTypeFromBuffer(
		int				argc,
		char **			argv,
		void *			pFileBuf,		// [in] ptr to buffer of source to compile
		ULONG			cbFileBuf,		// [in] length of source buffer
		ULONG			ulCaretLoc,		// [in] offset of cursor position in source buffer
		ULONG 			ulFuncStart,	// [in] line # of start of source buffer
		ULONG			ulAnchorLine,	// [in] line # of cursor position in source buffer
		BscEx*			pNcbStore,		// [in] already-open NCB store
		char*			szBuffer,
		int				cbBuffer,
		USHORT			targetImod,		// [in] the file where we are trying QI or AC
		ULONG			parentCl)		// [in] the class whose inline member function we are in
	{
		FUNC_PROLOGUE();
		return tdefGetTypeFromBuffer (FuncMap(4)) (argc, argv, pFileBuf, cbFileBuf, ulCaretLoc, ulFuncStart, ulAnchorLine, pNcbStore, szBuffer, cbBuffer, targetImod, parentCl);
	};

	
	int GetIdentTypeFromBuffer(
		int				argc,
		char**			argv,
		void *			pFileBuf,		// [in] ptr to buffer of source to compile
		ULONG			cbFileBuf,		// [in] length of source buffer
		ULONG			ulCaretLoc,		// [in] offset of cursor position in source buffer
		ULONG 			ulFuncStart,	// [in] line # of start of source buffer
		ULONG			ulAnchorLine,	// [in] line # of cursor position in source buffer
		BscEx*			pNcbStore,		// [in] already-open NCB store
		char*			szBuffer,
		int				cbBuffer,
		USHORT			targetImod,		// [in] the file where we are trying QI or AC
		ULONG			parentCl)		// [in] the class whose inline member function we are in
	{
		FUNC_PROLOGUE();
		return tdefGetIdentTypeFromBuffer (FuncMap(5)) (argc, argv, pFileBuf, cbFileBuf, ulCaretLoc, ulFuncStart, ulAnchorLine, pNcbStore, szBuffer, cbBuffer, targetImod, parentCl);
	};

	
	int DoParseForErrors (
		int				argc,
		char**			argv,
		void *			pFileBuf,		// [in] ptr to buffer of source to parse for errors
		ULONG			cbFileBuf,		// [in] length of source buffer
		int 			nStartLine,		// [in] line # of start of source buffer
		int 			nStopLine,		// [in] line # of end of source buffer
		BscEx*			pNCBDB,			// [in] NCB store to query for type info
		PFNREPORTERROR pfnReportError)	// [in] pfn to report errors
	{

		FUNC_PROLOGUE();
		return tdefDoParseForErrors (FuncMap(6)) (argc, argv, pFileBuf, cbFileBuf, nStartLine, nStopLine, pNCBDB, pfnReportError);
	};

	
	int DoParseTree(
		int				argc,
		char**			argv,
		void*			pFileBuf,		// [in] ptr to buffer of source to parse
		ULONG			cbFileBuf,		// [in] length of source buffer
		int 			nStartLine,		// [in] line # of start of source buffer
		int 			nStopLine,		// [in] line # of end of source buffer
		BscEx*			pNCBDB,			// [in] NCB store to query for type info
		PFNALLOC		pfnAlloc,		// [in] pfn to allocator
		IDE_Decl_t**	ppDeclTree)		// [out] ptr to decl tree
	{

		FUNC_PROLOGUE();
		return tdefDoParseTree (FuncMap(7)) (argc, argv, pFileBuf, cbFileBuf, nStartLine, nStopLine, pNCBDB, pfnAlloc, ppDeclTree);
	};
	
	
	int DoListIncludesFromBuffer(
		int				argc,
		char**			argv,
		void *			pFileBuf,		// [in] ptr to buffer of source to parse
		ULONG			cbFileBuf,		// [in] length of source buffer
		int 			nStartLine,		// [in] line # of start of source buffer
		int 			nStopLine,		// [in] line # of end of source buffer
		PFNREPORTINC	pfnReportInc)	// [in] pfn to report includes
	{
		FUNC_PROLOGUE();
		return tdefDoListIncludesFromBuffer (FuncMap(8)) (argc, argv, pFileBuf, cbFileBuf, nStartLine, nStopLine, pfnReportInc);
	};

	
	int DoListIncludes(
		int				argc,
		char**			argv,
		PFNREPORTINC	pfnReportInc)	// [in] pfn to report includes
	{
		FUNC_PROLOGUE();
		return tdefDoListIncludes (FuncMap(9)) (argc, argv, pfnReportInc);
	};


	int DoReferenceParse (NcbParse *pNCBDB, BscEx *pBscEx, IMOD imod, PYCBCALLBACK pfnIncludeInProject, int argc, char **argv)
	{
		FUNC_PROLOGUE();
		return tdefDoReferenceParse(FuncMap(10)) (pNCBDB, pBscEx, imod, pfnIncludeInProject, argc, argv);
	};


	int DoReferenceParseFromBuffer (NcbParse *pNCBDB, BscEx *pBscEx, IMOD imod, PYCBCALLBACK pfnIncludeInProject, int argc, char **argv, void *szBuf, ULONG cbBuf)
	{
		FUNC_PROLOGUE();
		return tdefDoReferenceParseFromBuffer (FuncMap(11)) (pNCBDB, pBscEx, imod, pfnIncludeInProject, argc, argv, szBuf, cbBuf);
	};

	int GetLocalsInScopeFromBuffer(int argc, char ** argv, void * pFileBuf, ULONG cbFileBuf, ULONG ulCaretLoc, int nStartLine, int nStopLine, BscEx * pNCBDB, NcbNameMap **	ppNcbNmp)
	{
		FUNC_PROLOGUE();
		return tdefGetLocalsInScopeFromBuffer (FuncMap(12)) (argc, argv, pFileBuf, cbFileBuf, ulCaretLoc, nStartLine, nStopLine, pNCBDB, ppNcbNmp);
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbdef.h ===
#ifndef __NCBDEF_H__
#define __NCBDEF_H__

// definition for standard BSC interface
// and different ATRs and TYPs
#include "bscext.h"
#include "ncarray.h"
// TYP == BYTE
// ATR == USHORT (we don't use this)
// ATR32 == DWORD

// various kind of streams:
#define SZ_NCB_TARGET_INFO		"/ncb/targetinfo"
#define SZ_NCB_TARGET_PREFIX	"/ncb/target/"
#define SZ_NCB_MODULE_INFO		"/ncb/moduleinfo"
#define SZ_NCB_MODULE_PREFIX	"/ncb/module/"
#define SZ_NCB_STORE_INFO		"/ncb/storeinfo"
#define SZ_NCB_STORE_PREFIX		"/ncb/store/"
#define SZ_NCB_VERSION_INFO		"/ncb/versioninfo"
#define SZ_NCB_IINSTDEFS        "/ncb/iinstdefs"
#define SZ_NCB_REFERENCEINFO	"/ncb/referenceInfo"
#define SZ_NCB_PSEUDO_TARGET    "__NcbPseudoTarget__"

#define NCB_PSEUDO_TARGET		0xFFFFFFFD  // This target is used for files that are not part of the project
											// but that requires parsing. For example, the tli and tlh files
#define NCB_CURRENT_VERSION		0xE

struct NCB_VERSION_INFO
{
	DWORD	m_ver;
};

// for vc99, worry about making attrib 3 bytes or Dword
// consider packing using #pragma. Also make sure
// calculateCRC gives out the right size - Ignatius / ShankarV
// ATR32 is the new ATR type the NCBs will use
struct NCB_ENTITY 
{
	NI			m_ni;		// name index, index used in the name table (nmt)
	TYP			m_typ;		// type of the object, eg: function/var/typedef/class/etc and decl/defn
	ATR32		m_atr;      // attribute value, eg: static, virtual, private, protected
};


struct NCB_PROP
{
	NCB_ENTITY	m_en;		// entity (consists of:
							//	o index to name table (NI)
							//  o type of the object  (TYP)
							//	o attribute of the object (ATR32)
	USHORT	m_iUse;			// index to use (index to NCB_USE table) (iMac index)
	USHORT	m_iParam;		// index to return type and params (index to NI table) (iMac index)
	USHORT	m_lnStart;		// line number of the entity
	USHORT	m_lnEnd;		// end line number of the entity
};

// this is used for lookup 
struct NCB_USE
{
	BYTE	m_kind;			// kind of uses
	USHORT	m_iProp;		// index to prop table
};

// IN MEMORY representation of NCB_PROP (used when module content is loaded for
// write): (ie: loose version)
struct NCB_PROP_INMEM
{
	NCB_ENTITY	m_en;		// entity (consists of:
							// o index to name table (NI)
							// o type of the object (TYP)
							// o attribute of the object (ATR32)
	Array<NCB_USE> m_rgUse;	// array of NCB_USE (for each  prop)
	Array<NI>	m_rgParam;	// return value and parameters (for each prop)
	USHORT	m_lnStart;		// line number of the entity
	USHORT	m_lnEnd;		// end line number of the entity
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbmod.h ===
// ncmod.h
// No Compile Browser Module/File header structure
// 

#ifndef __NCMOD_H__
#define __NCMOD_H__

//#pragma pack(1)
#include "ncarray.h"

////////////////////////////////////////////////
// structure for the No Compile Module Header
//
////////////////////////////////////////////////
struct NCB_INCL
{
	USHORT	m_iModInfo;		// index to mod info
};

// Per target option:
struct NCB_TARGET
{
	NI		m_ni;			// target id
};

#if CC_MULTIPLE_STORES
// each store has the following in the storeinfo stream
struct NCB_STORE
{
	NI		m_ni;			// store id
	USHORT	m_storeType;	// type of store
	USHORT	m_index;		// index of store; currently not used
};
#endif	// CC_MULTIPLE_STORES

struct NCB_MODINFO
{
	USHORT	m_iModHdr;		// index to module header
};

struct NCB_MODINFO_INMEM
{
	USHORT	m_iModHdr;			// index to module header
	Array<NCB_INCL>	m_rgIncl;	// list of includes
	BOOL	m_bMember;			// member of project. 
								// With the original setup, we used to include project dependencies
								// under the regular target, and we used to mark m_bMember to be FALSE
								// Now we put all the project dependency files not part of the project
								// to be under the pseudo target - ShankarV
	BOOL	m_bDel;				// if it is deleted or not
	BOOL	m_bInit;			// initialized
};


#define CB_BITS_NI  128


struct NCB_MODHDR
{
	NI		m_ni;				// name of module
// header information, needed to load the file content info to
// the memory:
	NI		m_niMax;				// max ni in this module content
	USHORT	m_cProp;				// size of the prop array
	USHORT	m_cClassProp;			// size of the class in prop array
									// cClassProp <= cProp
	USHORT	m_cUse;					// size of the use array
	USHORT	m_cParam;				// size of the param array
	BYTE	m_bitsNi[CB_BITS_NI];   // cache bits for NIs
	time_t	m_tStamp;				// time stamp for file updates
	BYTE	m_bAtr;					// module attributes
	BYTE	m_bLanguage;			// module language attributes
};

struct NCB_CONTENT 
{
	BYTE		m_prio;		// priority (FIFO)
	USHORT		m_iModHdr;	// index to module
	NCB_PROP *	m_rgProp;	// array of symbol of info
	NCB_USE	*	m_rgUse;	// array of usage
	NI *		m_rgParam;	// array of parameters
//	DWORD		m_dwLocks;	// number of ReadLocks
};


// In Memory storage:
struct NCB_TARGETINFO
{
	NI				m_ni;						// target id
	HTARGET			m_hTarget;					// target
	NCArray<NCB_MODINFO_INMEM>	m_rgModInfo;	// array of Modules (should be growable)?
};

#if CC_MULTIPLE_STORES
// In memory storage per store
struct NCB_STORE_INMEM
{
	NI			m_ni;			// store id
	STORE_TYP	m_storeType;	// type of store
	PDB*		m_pPDB;			// pdb for opened store
};
#endif	// CC_MULTIPLE_STORES

// in memory for NCB content:
struct NCB_CONTENT_INMEM
{
	USHORT	m_iModHdr;					// index to module
	NCArray<NCB_PROP_INMEM>	m_rgProp;	// array of symbol info in memory (loose version)
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncarray.h ===
#ifndef __NCARRAY_H__
#define __NCARRAY_H__

#include "array_t.h"

template <class T> class NCArray {
	T* rgt;
	unsigned itMac;
	unsigned itMax;
	enum { itMaxMax = (1<<29) };
public:
	NCArray() {
		rgt = 0;
		itMac = itMax = 0;
	}
	NCArray(unsigned itMac_) {
		rgt = (itMac_ > 0) ? new T[itMac_] : 0;
		itMac = itMax = rgt ? itMac_ : 0;
	}
	~NCArray() {
		if (rgt)
			delete [] rgt;
	}
	BOOL isValidSubscript(unsigned it) const {
		return 0 <= it && it < itMac;
	}
	unsigned size() const {
		return itMac;
	}
	BOOL getAt(unsigned it, T** ppt) const {
		if (isValidSubscript(it)) {
			*ppt = &rgt[it];
			return TRUE;
		}
		else
			return FALSE;
	}
	BOOL putAt(unsigned it, const T& t) {
		if (isValidSubscript(it)) {
			rgt[it] = t;
			return TRUE;
		}
		else
			return FALSE;
	}
	T& operator[](unsigned it) const {
		precondition(isValidSubscript(it));
		return rgt[it];
	}
	BOOL append(T& t) {
		if (setSize(size() + 1)) {
			self[size() - 1] = t;
			return TRUE;
		} else
			return FALSE;
	}
	void swap(NCArray& a) {
		::swap(rgt,   a.rgt);
		::swap(itMac, a.itMac);
		::swap(itMax, a.itMax);
	}
	void reset() {
		setSize(0);
	}
	void fill(const T& t) {
		for (unsigned it = 0; it < size(); it++)
        {
            memcpy (&self[it], &t, sizeof (T));
        }
	}
	BOOL insertAt(unsigned itInsert, const T& t);
	void deleteAt(unsigned it);
	BOOL setSize(unsigned itMacNew);
	BOOL findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
	BOOL findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const;
	unsigned binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const;
	BOOL save(Buffer* pbuf) const;
	BOOL reload(PB* ppb);
	CB cbSave() const;
};

template <class T> inline BOOL NCArray<T>::insertAt(unsigned it, const T& t) {
	precondition(isValidSubscript(it) || it == size());

	if (setSize(size() + 1)) {
		memmove(&rgt[it + 1], &rgt[it], (size() - (it + 1)) * sizeof(T));
        memcpy (&rgt[it], &t, sizeof (T));
		return TRUE;
	}
	else
		return FALSE;
}

template <class T> inline void NCArray<T>::deleteAt(unsigned it) {
	precondition(isValidSubscript(it));

    T *temp = new T;
    memcpy (temp, &rgt[it], sizeof(T));
 	if (it+1 < size())
	{
		T *temp2 = new T;
		memmove(&rgt[it], &rgt[it + 1], (size() - (it + 1)) * sizeof(T));
		memcpy (&rgt[size()-1], temp2, sizeof(T));
		delete temp2;
	}
	else if (it + 1 == size())
	{
		T * temp2 = new T;
		memcpy (&rgt[size()-1], temp2, sizeof(T));
		delete temp2;
	}
	delete temp;
	itMac = itMac -1;
}

// Grow the array to a new size.
template <class T> inline
BOOL NCArray<T>::setSize(unsigned itMacNew) {
	precondition(0 <= itMacNew && itMacNew <= itMaxMax);

    if (itMacNew < itMac)
    {
        T * temp = new T[itMac - itMacNew];
        if (!temp)
            return FALSE;
        memcpy (temp, &rgt[itMacNew], (itMac- itMacNew) * sizeof (T));
        delete []temp;
		temp = new T[itMac - itMacNew];
		memcpy (&rgt[itMacNew], temp, (itMac - itMacNew) * sizeof (T));
		delete []temp;
    }

	if (itMacNew > itMax) {
		// Ensure growth is by at least 50% of former size.
		unsigned itMaxNew = max(itMacNew, 3*itMax/2);
 		assert(itMaxNew <= itMaxMax);

		T* rgtNew = new T[itMaxNew];
		if (!rgtNew)
			return FALSE;
		if (rgt) {
            memcpy (rgtNew, rgt, itMac * sizeof (T));
			T *temp = new T;
			unsigned i;
			for (i = 0; i < itMac; i++)
				memcpy (&rgt[i], temp, sizeof(T));
			delete temp;
			delete []rgt;
		}
		rgt = rgtNew;
		itMax = itMaxNew;
	}
	itMac = itMacNew;
	return TRUE;
}

template <class T> inline
BOOL NCArray<T>::save(Buffer* pbuf) const {
	return pbuf->Append((PB)&itMac, sizeof itMac) &&
		   (itMac == 0 || pbuf->Append((PB)rgt, itMac*sizeof(T)));
}

template <class T> inline
BOOL NCArray<T>::reload(PB* ppb) {
	unsigned itMacNew = *((unsigned UNALIGNED *&)*ppb)++;
	if (!setSize(itMacNew))
		return FALSE;
	memcpy(rgt, *ppb, itMac*sizeof(T));
	*ppb += itMac*sizeof(T);
	return TRUE;
}

template <class T> inline
CB NCArray<T>::cbSave() const {
	return sizeof(itMac) + itMac * sizeof(T);
}

template <class T> inline
BOOL NCArray<T>::findFirstEltSuchThat(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
{
	for (unsigned it = 0; it < size(); ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}
	return FALSE;
}

template <class T> inline
BOOL NCArray<T>::findFirstEltSuchThat_Rover(BOOL (*pfn)(T*, void*), void* pArg, unsigned *pit) const
{
	precondition(pit);

	if (!(0 <= *pit && *pit < size()))
		*pit = 0;

	for (unsigned it = *pit; it < size(); ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}

	for (it = 0; it < *pit; ++it) {
		if ((*pfn)(&rgt[it], pArg)) {
			*pit = it;
			return TRUE;
		}
	}

	return FALSE;
}

template <class T> inline
unsigned NCArray<T>::binarySearch(BOOL (*pfnLE)(T*, void*), void* pArg) const
{
	unsigned itLo = 0;
	unsigned itHi = size(); 
	while (itLo < itHi) {
		// (low + high) / 2 might overflow
		unsigned itMid = itLo + (itHi - itLo) / 2;
		if ((*pfnLE)(&rgt[itMid], pArg))
			itHi = itMid;
		else
			itLo = itMid + 1;
	}
	postcondition(itLo == 0      || !(*pfnLE)(&rgt[itLo - 1], pArg));
	postcondition(itLo == size() ||  (*pfnLE)(&rgt[itLo], pArg));
	return itLo;
}

#endif // !__ARRAY_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\helper.h ===
// helper.h
// header for helper.cpp
//	contains helper functions shared between bsc and ncb
////////////////////////////////////////////////////////
#ifndef __HELPER_H__
#define __HELPER_H__

#include <array_t.h>

void MaskFrNi (NI ni, NI niMax, const USHORT cBytes, int *pib, BYTE *pbMask);
SZ szFrNi (NameMap * pnm, NI ni);

//////////////////////////////////////////////////////////
//	MaskFrNi()
// Create a masking and byte index given NI and NI max
//////////////////////////////////////////////////////////
inline void MaskFrNi(NI ni, NI niMax, const USHORT cBytes, int *pib, BYTE *pbMask) 
{
	// find scaling factor for this module...
	int iDiv = 1 + niMax / (cBytes * 8);
	ni /= iDiv;

	*pbMask = 1<<(ni%8);	// bottom 3 bits to form the mask
	ni /= 8;				// now remove the 3 position bits
	ni %= cBytes;		// then modulo the remaining bits
	*pib = ni;
};

///////////////////////////////////////
// szFrNi ()
// get the name sz from given name map
///////////////////////////////////////
inline SZ szFrNi(NameMap * pnm, NI ni)
{
	SZ_CONST sz;
	verify(pnm->getName(ni, &sz));	// REVIEW: error?
	return (SZ)sz;
}

// copy from Array to regular array
template<class T> 
BOOL DupArray (T **ppNew, ULONG *pc, Array<T>& ar)
{
	*pc = ar.size();
	
	if (!*pc) {if (ppNew) *ppNew = NULL; return TRUE;	}
	
	CB cbAr = ar.size()*sizeof(T);
	if (*pc > 0)
	{
		//*ppNew =  new T[*pc];
        *ppNew = (T *) malloc (cbAr);
		if (!*ppNew) return FALSE;

		memcpy(*ppNew, &ar[0], cbAr);
	}
	return TRUE;
};

// copy from regular array to Array:
template<class T>
BOOL DupArray (Array<T>& arNew, ULONG cSize, T  *rg)
{
	if (!arNew.setSize (cSize))
		return FALSE;
	if (cSize > 0)
	{
		CB cbAr = cSize * sizeof (T);
		memcpy (&arNew[0], rg, cbAr);
	}
	return TRUE;
};

extern "C"
{
	inline void ncfailAssertion(SZ_CONST szFile, int line)
	{
		_ASSERT (FALSE);
	}
}

/*
BOOL DupArray(ULONG **ppNew, ULONG *pc, Array<ULONG>& ar)
{
	*pc = ar.size();
	
	if (!*pc) {if (ppNew) *ppNew = NULL; return TRUE;	}
	
	CB cbAr = ar.size()*sizeof(ULONG);

	*ppNew = (ULONG*)malloc(cbAr);
	if (!*ppNew) return FALSE;

	memcpy(*ppNew, &ar[0], cbAr);
	return TRUE;
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbiinst.h ===
// NCBIINST.H
//
// Define map from NIs to defining IINSTs within a single NCB.
// Used to greatly speed up Ncb::getOverloadArray
//

#ifndef __NCBIINST_H__
#define __NCBIINST_H__

#include <new.h>
#include <pdb.h>
#include <vcbudefs.h>
#include <bsc.h>
#include <map_t.h>

//
// IInstArray - Array of IINSTs suitable as the range of a Map<>.
// If count of IINSTs is 2 or more, this points to a heap-allocated list of
// IINSTs, otherwise the single IINST is local to this object.  Reduces memory
// requirements for the common case of a single IINST, while still maintaining
// a fixed-length object as needed by Map<>.
//

class IInstArray {
public:
    IInstArray(IINST iinst = iinstNil);
    IInstArray(const IInstArray &that);
    IInstArray(PB *ppb);
    ~IInstArray();
    IInstArray &operator =(const IInstArray &that);
    bool	operator ==(const IInstArray &that) const;
	DWORD	Count() const;
    BOOL	Find(IINST iinst) const;
    BOOL	Add(IINST iinst);
    BOOL	Remove(IINST iinst);
    DWORD	RemoveModule(IMOD imod);
    BOOL	Save(Buffer *pbuf) const;
	void	Replace(IINST *piinst);
    void	GetIInstArray(Array<IINST> *prgiinst) const;
private:
    DWORD m_cIInst;         // Count of IINSTs in this array
    union {
        IINST m_iinst;      // m_cIInst == 1 - the single IINST
        IINST *m_prgIInst;  // m_cIInst != 1 - pointer to the array of IINSTs
    };
};

inline
IInstArray::IInstArray(IINST iinst) : m_cIInst(1), m_iinst(iinst)
{
}

inline
IInstArray::~IInstArray()
{
    if (m_cIInst > 1) {
        delete [] m_prgIInst;
    }
}

inline DWORD
IInstArray::Count() const
{
	return m_cIInst;
}

//
// MapNiToIInstArray - wrapper for the Map<NI,IInstArray> used to map an NI to
// a list of IINSTs.  Used by the Ncb implementation to map NIs to all the
// IINSTs which define them.
//
// The NIs present in the map are also kept in an array, sorted alphabetically
// by the strings each represents.  This is the order in which the NIs are
// serialized to the NCB stream.  This sorted array can be queried to find all
// defined names within the NCB which start with a given prefix (used by
// identifier completion).
//

class MapNiToIInstArray {
public:
	// Initialize the object
    void Reset(NameMap *pnm);

	// Move from in memory <-> NCB stream
    BOOL Reload(PB *ppb);
    BOOL Save(Buffer *pbuf);

	// Add new mappings
    BOOL Add(NI ni, IINST iinst);

	// Remove mappings
    BOOL Remove(NI ni, IINST iinst);
    BOOL RemoveModule(IMOD imod);

	// Retrieve all mappings for a single NI
    BOOL GetIInstArray(NI ni, Array<IINST> *prgiinst) const;

	// Retrieve the sorted list of global NIs
	BOOL GetSortedGlobalNIs(const NI **ppni, ULONG *pcni) const;

private:
	// Update sorted NI array for RemoveModule
	void RemoveModuleHelper(Array<NI> &rgniRemoved);

	// Check if name is one we want to save in sorted NI list
	bool IsGlobalName(NI ni);

	// Do binary search for an NI in the sorted array
	bool SortedSearch(NI ni, unsigned *pidx) const;

	// Update the sorted NI array with recently added NIs
	void UpdateSortedNIs() const;

#ifdef _DEBUG
	// Check the validity of this object
	bool Validate() const;
#endif

private:
    Map<NI,IInstArray,LHcNi> m_map;
	NameMap *				m_pnm;
	mutable Array<NI>		m_rgniSorted;
	mutable Array<NI>		m_rgniAdded;
};

// Helper function to compare two strings derived from NIs.  The comparison is case-insensitive
// with a fall-back to case-sensitive if the first compare shows a match.
inline int StrCmpNIs(SZ_CONST sz1, SZ_CONST sz2)
{
	int iRes = _stricmp(sz1, sz2);
	if (iRes == 0) {
		iRes = strcmp(sz1, sz2);
	}
	return iRes;
}

#endif // !__NCBIINST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbapi.h ===
/////////////////////////////
// NCBAPI.H
//		NCB Package interface declaration
//

#ifndef __NCBAPI_H__
#define __NCBAPI_H__

PdbInterface INCB;

typedef INCB	* LPNCB;

///////////////////////////////////
// INCB
//
#include <ncparex.h>

// CLSID_NCB 
//
// {99EDEFAF-9B02-11D0-A51B-00A0C91F381B}
//

extern "C" const __declspec(selectany) CLSID CLSID_NCB = { 0x99EDEFAF, 0x9B02, 0x11D0, { 0xA5, 0x1B, 0x00, 0xA0, 0xC9, 0x1F, 0x38, 0x1B } };

// INCB
//

__interface __declspec(uuid("{9ADE0EB0-6273-11cf-BF4F-00AA006C2891}")) INCB : public IUnknown
{
	// INCB methods
	STDMETHOD(OpenNcbForReadFrName)(SZ szName, HTARGET hTarget, SZ szTarget, BOOL bWrite, Bsc ** ppBsc);
	STDMETHOD(OpenNcbForReadFrPdb)(PDB * ppdb, HTARGET hTarget, SZ szTarget, Bsc ** ppBsc);
	STDMETHOD(OpenNcbForWriteFrName)(SZ szName, BOOL bWrite, NcbParseEx ** ppNcParse);
	STDMETHOD(OpenNcbForWriteFrPdb)(PDB * ppdb, NcbParseEx **ppNcParse);

};

#if !defined(_NCB_COM_)

// This is so that the ncb package can be loaded with a LoadLib from the ycb\driv project
//

HRESULT OpenNcbForReadFrName(SZ szName, HTARGET hTarget, SZ szTarget, BOOL bWrite, Bsc ** ppBsc);
HRESULT OpenNcbForReadFrPdb(PDB * ppdb, HTARGET hTarget, SZ szTarget, Bsc ** ppBsc);
HRESULT OpenNcbForWriteFrName(SZ szName, BOOL bWrite, NcbParseEx ** ppNcParse);
HRESULT OpenNcbForWriteFrPdb(PDB * ppdb, NcbParseEx **ppNcParse);

#endif // _NCB_COM_

#endif // __NCBAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\IDE_parseinfo.h ===
#pragma once

//
// Microsoft (R) 32-bit C/C++ Optimizing Compiler Front-End
// Copyright (C) Microsoft Corp 1984-1999. All rights reserved.
//
// IDE_parseinfo.h
//
// Type declarations for parse info for IDE use throughout the compiler.  
//

// Typedefs used for entrypoints into FEACP
typedef void (WINAPI * PYCBCALLBACK)(char *pszFilename, bool fNewHeader);
typedef void * (__cdecl * PFNALLOC)(size_t);
typedef void (WINAPI * PFNREPORTERROR)(DWORD dwErrId, DWORD dwErrType, SZ szFileName, DWORD begLine, DWORD endLine, WORD begCol, WORD endCol, SZ szErrTxt);
typedef void (WINAPI *PFNREPORTINC)(const char * strHeaderFile);


// struct definition of struct where column info is maintained
typedef struct IDE_ColumnInfo_s {
	__int32 lineBegin;
	unsigned __int32	colEnd		: 12,
						colBegin	: 12,
						lineEnd		: 8;	// line number for colEnd is 
											// lineBegin + lineEnd
} IDE_ColumnInfo_t;



// The kinds of things that we may produce column info for
__declspec(selectany) char * IDE_kind_str[] = { "Object", "Function", "Class", "Struct", "Union", "Namespace", "Enum", "Template", "unknown" };

// NOTE: If you add any types, please add them before max_e. Also, update 
// IDE_kind_str[][] accordingly if you add or rearrange members of the enum
// declared below
typedef struct IDE_Decl_s {
	enum kind_t { object_e, function_e,  class_e, struct_e, union_e, namespace_e, enum_e, template_e, max_e };
	
	kind_t kind; // what "kind" of declaration is it?

	IDE_ColumnInfo_t declarator;	// eg: "int *(*foo)()" = 0; between quotes 
									// is the declarator

	IDE_ColumnInfo_t name;			// "foo" in the above example

	IDE_ColumnInfo_t init;			// "= 0" in the above example
									// note: "init" is "default arg" for a 
									// formal_e

	struct IDE_Decl_s *next;		// the "next" node at this same lexical 
									// level (eg, formal list, list of mbr 
									// funcs, etc)

	union {
		// function_e
		struct {
			IDE_Decl_s *formalList;	// list of formal arguments for a function_e
			IDE_Decl_s *cv_modifier;// cv_modifier col info for a function_e
		};
		
		struct {
			IDE_Decl_s *memberList;		// class_e, struct_e, union_e, 
										// namespace_e, enum_e, template_e
			IDE_Decl_s *baseClassList;	// class_e, struct_e, template_e
			IDE_Decl_s *templateLink;	// template_e
		};
    };

} IDE_Decl_t;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbnmp.h ===
// NCBNMP.H
//
// NCB package local namemap declaration

#ifndef __NCBNMP_H__
#define __NCBNMP_H__

#include <vcbudefs.h>
#include <bsc.h>

PdbInterface NcbNameMap {
	// Create a new NcbNameMap
	static BOOL Create(BOOL fAllowDuplicates, OUT NcbNameMap **ppncbnmp);

	// Release an NcbNameMap
	virtual BOOL Close() pure;

	// Add a new name along with its attribute and type to the namemap
	virtual BOOL AddItem(const char *sz, TYP typ, ATR32 atr, IINST iinst) pure;

	// Retrieve array of all NIs sorted alphabetically
	virtual BOOL GetSortedNIs(OUT const NI **ppni, OUT ULONG *pcni) pure;

	// Retrieve attribute and type for an item, given its index in the
	// sorted NI array
	virtual BOOL GetPropByIndex(ULONG idx, OUT TYP *ptyp, OUT ATR32 *patr, OUT IINST *piinst) pure;

	// Retrieve an array of iinsts for a given string given a sorted NI array
	// It is the responsibility of the client to release the arrays
	virtual BOOL GetIinstsFrSz(SZ szName, MBF mbfType, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;

	// Get the string corresponding to an NI from the namemap
	virtual SZ szFrNi(NI ni) pure;
};

#endif	// __NCBNMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncparex.h ===
#ifndef __NCPARSEEX_H__
#define __NCPARSEEX_H__

#include <ncparse.h>

struct UpdateItem
{
	IINST m_iinstOld;
	IINST m_iinstNew;
	IINST m_iinstParent;
	OPERATION m_op;
};

PdbInterface NcbParseEx : public NcbParse
{
	virtual BOOL setEndLine (IINST iinst, LINE lnEnd) pure;
	virtual BOOL irefEndInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual void setModLang (IMOD imod, BYTE bLanguage) pure;
	virtual BOOL setIDLAttrib (IINST iinst, SZ szName, SZ szValue, OUT IINST *piinst) pure;
	virtual BOOL setIDLMFCComment (IINST iinst, SZ szType, SZ szValue, OUT IINST *piinst) pure;
#if CC_MULTIPLE_STORES
	// New ones added to support multiple stores
	virtual BOOL addStore(SZ szName, STORE_TYP st) pure;
	virtual BOOL delStore(SZ szName) pure;
	virtual BOOL openNextStore() pure;
	virtual BOOL pageInNextStore() pure;
	virtual BOOL delAllStores() pure;
	virtual BOOL getAllStoresArray(OUT NI** ppni, OUT USHORT* pcStores) pure;
	virtual BOOL openStore(SZ szName, USHORT* pStoreIdx) pure;
	virtual BOOL closeStore(USHORT storeIdx) pure;
	virtual BOOL isExistingStore(SZ szName, OUT STORE_TYP* pst, OUT USHORT* psi) pure;
	virtual SZ szFrStoreIndex(USHORT idx) pure;
#endif	// CC_MULTIPLE_STORES
	virtual BOOL beforeUpdate(IMOD imod) pure;
	virtual BOOL afterUpdate(IMOD imod, UpdateItem **ppUpdates, ULONG *pcUpdates, BOOL *pfIncludesChanged) pure;

	virtual BOOL addReference(SZ szName, IINST iinst) pure;
	virtual BOOL delModuleReferences(IMOD imod) pure;
		// delete all modules not in the project - part of NcbParseEx
    virtual BOOL delAllUnrefMod() pure;

};


class CBscLock
{
private:
    NcbParseEx * m_pDBase;
public:
    CBscLock (NcbParseEx * pDBase)
    {
        m_pDBase = pDBase;
        m_pDBase->lock();
    };

    ~CBscLock()
    {
        m_pDBase->unlock();
        m_pDBase = NULL;
    };
};


#endif __NCPARSEEX__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncbrowse.h ===
// NCBROWSE.H
//
// implementation of no compile browser API for one source information
//
// REVIEWS:
// 1) need some locking mechanism for thread safe operation?
// 2) need some other interface for writing info from the parser thread?
// 

#ifndef __NCBROWSE_H__
#define __NCBROWSE_H__

// No compile browser will have the same interface as Bsc
#include "ncarray.h"
#include "ncparex.h"
#include "ncbdef.h"
#include "ncbmod.h"
#include "ncbiinst.h"
#include "ncsearch.h"
#include "simparray.h"
#include "nmt_t.h"
#include <tchar.h>

// Ncb = No Compile Browser
// derived from Bsc to provide common interface

// module content buffer size
// size of array defined to store module content in memory
// this is the number of modules we store in memory.
#define NCB_MOD_BUF_SIZE		12

// different flags for module status
// module content can be loaded for read or write
// or unloaded. (default is unloaded)
#define NCB_STATMOD_EMPTY		0x00
#define NCB_STATMOD_UNLOADED	0x01
#define NCB_STATMOD_LOAD_READ	0x02
#define NCB_STATMOD_LOAD_WRITE	0x04
#define NCB_STATMOD_DIRTY		0x08  // set to dirty when file content is modified
									  // so we have to write it out to the stream
									  // when we save.

// Currently supported maximum number of stores. Here's how the number came up ...
//
// We want the IINST to identify a store for the sake of speed. The IINST is
// made up of Imod (hi 16-bits) and IProp (low 16-bits). Currently the PDB format
// allows no more than 4K streams ... we use a stream per module. This means
// that we have never supported more than 4K modules. So we can use the top 4
// bits of the Imod to have a store index. The value 0x0 is reserved for the main
// store as this will be the most in use. The value 0xF is unavailable because
// we have previously used reserved values like 0xFFFFFFFE to designate
// IINST_UNDEFINED and 0xFFFF0001 to designate IINST_GLOBALS. Thus, it is safe to
// have as many as 15 stores open at the same time (including the main store).
// [We could in theory use a table to keep track of things and allow more than 4K
// mods per store ... this simply makes the code pretty complex. The above method
// is faster and less invasive]
// 
// To allow for future expansion and sharing of pre-built stores across projects
// we will do another optimization. The store index will not be saved in the physical
// store. We keep track of the store index and the IINST actually returned to users
// of the store will have the store index encoded in. -Sundeep-
#define NCB_MAXSTORES			15			// used commonly in FOR_ALL_STORES

class Ncb;

// string class for use in m_mapFilenameImod
class NcbString : public SimpleString
{
public:
	NcbString( unsigned len = 256 ) : SimpleString(len) {}
	// shall we move these to SimpleString itself?
	NcbString( const char *sz ) 
	{
		Set( sz, strlen(sz) + 1 );
	}
	NcbString& operator=( NcbString& str ) {
		Set( str.Base(), strlen( str.Base() ) );
		return *this;
	}
	void MakeLower()  { _tcslwr(Base()); }
};

class CNcbStringHasher
{
public:
	inline LHASH __fastcall operator()(NcbString &str)
	{
		return hashSz(str.Base());
	}
};

///////////////////////////////////////////////////////////
// needed to keep track the list of no compile browser object
///////////////////////////////////////////////////////////
struct NcbInfo
{
	Ncb *	m_pNcb;					// pointer to the real Ncb
	char 	m_szName[_MAX_PATH];	// filename
	PDB	*	m_pPdb;					// pointer to the pdb file
	int		m_count;				// the number of reference
	BOOL	m_bIOwnPdb;				// if I own the pdb
	Ncb *	m_pParentNcb;			// if opened by openStore()
	USHORT  m_storeIndex;			// store index in parent
};

////////////////////////////////////////////////
// data structures for notifications
////////////////////////////////////////////////

struct NcbNotifyQ
{
	HTARGET	m_hTarget;
	BYTE	m_bLanguage;
	BOOL	m_bDel;
	Array<NiQ> m_rgQ;
};

typedef enum { initMismatchVer = -1, initError, initOK} InitRetVal;

class Ncb: public BscEx, public NcbParseEx
{
private:
	static Array<NcbInfo>	*ms_prgNcbInfo;
	static BOOL OpenThePdb(SZ szName, PDB** ppPdb, BOOL bWrite);
public:
	static BOOL OpenNcb (SZ szName, BOOL bWrite, Ncb ** ppNcb);
	static BOOL OpenNcb (PDB * ppdb, Ncb ** ppNcb);
	static void DeleteNcbInfo()
	{
		//delete Ncb::ms_prgNcbInfo;
	}
	static NameMap *	m_pnmStatic; // Name map, our hash table
									 // used by CmpStrFrIProp
									 // as of a global for qsort()

public:
//////////////////////////////////////////////////////////////////////////////
// BEGIN of Bsc interface
	// open by name or by .pdb 
	virtual BOOL close();
	// primitives for getting the information that underlies a handle
	virtual BOOL iinstInfo(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr);
	virtual BOOL iinstInfo(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR *patr); // no longer supported
	virtual BOOL iinstInfo2(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr);
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL idefInfo(HTARGET hTarget, BYTE bLanguage, IDEF idef, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL idefInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule);
	virtual SZ   szFrTyp(TYP typ);
	virtual SZ   szFrAtr(ATR atr);								// no longer supported
	virtual SZ   szFrAtr2(ATR32 atr);


	// primitives for managing object instances (iinst)
	virtual BOOL getIinstByvalue(HTARGET hTarget, BYTE bLanguage, SZ sz, TYP typ, ATR32 atr, OUT IINST *piinst);	
	virtual BOOL getIinstByvalue(SZ sz, TYP typ, ATR atr, OUT IINST *piinst);	// no longer supported
	virtual BOOL getIinstByvalue2(SZ sz, TYP typ, ATR32 atr, OUT IINST *piinst);
	virtual BOOL getIinstByvalue3(SZ sz, TYP typ, ATR32 atr, OUT IINST** ppinst, OUT ULONG* pciinst);
	virtual BOOL getIinstByvalue3(HTARGET hTarget, BYTE bLanguage, SZ sz, TYP typ, ATR32 atr, OUT IINST** ppinst, OUT ULONG* pcinst);
	virtual BOOL getOverloadArray(HTARGET hTarget, BYTE bLanguage, SZ sz, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getOverloadArray(SZ sz, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getUsesArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getUsedByArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getBaseArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getBaseArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getDervArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getDervArray(IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getMembersArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getMembersArray(IINST iinst, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);

	// primitives for getting definition and reference information
	virtual BOOL getDefArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IDEF **ppidef, OUT ULONG *pciidef);
	virtual BOOL getDefArray(IINST iinst, OUT IDEF **ppidef, OUT ULONG *pciidef);
	virtual BOOL getRefArray(IINST iinst, OUT IREF **ppiref, OUT ULONG *pciiref);

	// primitives for managing source module contents
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getModuleContents(HTARGET hTarget, BYTE bLanguage, IMOD imod, MBF mbf, BOOL bGlobalOnly, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod);
	virtual BOOL getAllModulesArray(HTARGET hTarget, BYTE bLanguage, OUT IMOD **ppimod, OUT ULONG *pcimod);
	virtual BOOL getAllModulesArray(OUT IMOD **ppimod, OUT ULONG *pcimod);
	
	// call this when a computed array is no longer required
	virtual void disposeArray(void *pAnyArray);
	
	// call this to get a pretty form of a decorated name	
	virtual SZ  formatDname(SZ szDecor);

	// call this to do category testing on instances
	virtual BOOL fInstFilter(IINST iinst, MBF mbf);

	// primitives for converting index types
	virtual IINST iinstFrIref(IREF);
	virtual IINST iinstFrIdef(IDEF);
	virtual IINST iinstContextIref(IREF);

	// general size information
	virtual BOOL getStatistics(BSC_STAT *);
	virtual BOOL getModuleStatistics(IMOD, BSC_STAT *);

	// needed for no compile browser
	virtual SZ     getParams (IINST iinst);
	virtual USHORT getNumParam (IINST iinst);
	virtual SZ     getParam (IINST iinst, USHORT index);

	// get return type/variable type
	virtual SZ  getType (IINST iinst);
	virtual SZ	getTypeWithName(IINST iinst, SZ szName);
        virtual SZ  getMacroDefinition(IINST iinst);

	// get global information
	virtual BOOL fCaseSensitive ();
	virtual BOOL setCaseSensitivity (BOOL);
	virtual BOOL getAllGlobalsArray (MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL getAllGlobalsArray (HTARGET hTarget, BYTE bLanguage, MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL getAllGlobalsArray (MBF mbf, OUT IinstInfo ** ppiinstinfo, OUT ULONG * pciinst);
	virtual BOOL getAllGlobalsArray (HTARGET hTarget, BYTE bLanguage, MBF mbf, OUT IinstInfo ** ppiinstinfo, OUT ULONG * pciinst);
	virtual BOOL regNotify (pfnNotifyChange pNotify);
	virtual BOOL regNotify (HTARGET hTarget, pfnNotifyChange pNotify);
	// register to make sure that NCB will create change queue
	virtual BOOL regNotify ();
	virtual BOOL regNotify (HTARGET hTarget, OUT ULONG * pindex);
	virtual BOOL getQ (OUT NiQ ** ppQ, OUT ULONG * pcQ);
	virtual BOOL getQ (ULONG index, HTARGET hTarget, OUT NiQ ** ppQ, OUT ULONG * pcQ);
	virtual BOOL checkParams (IINST iinst, SZ * pszParam, ULONG cParam);
	virtual BOOL fHasMembers (IINST iinst, MBF mbf);
	virtual BOOL fHasMembers (HTARGET hTarget, BYTE bLanguage, IINST iinst, MBF mbf);
	// needed for class view for optimization
	virtual SZ szFrNi (NI ni);
	virtual BOOL niFrIinst (IINST iinst, NI *ni);
// END of Bsc interface
// BEGIN of BscEx interface
	virtual BOOL irefEndInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL idefEndInfo(IDEF idef, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL idefEndInfo(HTARGET hTarget, BYTE bLanguage, IDEF idef, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL getGlobalsFrImod (IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getGlobalsFrImod (HTARGET hTarget, BYTE bLanguage, IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual void setLanguage (BYTE bLanguage) {}; // default to nothing (used only by ncwrap)
	virtual void getLanguage (BYTE * pbLanguage){};
	virtual BOOL isModInLang (BYTE bLanguage, IMOD imod);
	virtual BOOL getIDLAttrib (IINST iinst, OUT IINST **ppiiAttr, OUT ULONG *pciinst);
	virtual BOOL getIDLAttribVal (IINST iiAttr, OUT SZ *pszValue);
	virtual BOOL isIDLAttrib (IINST iinst, SZ szAttrib, OUT IINST *piiAttr, OUT SZ *pszValue);
	virtual BOOL filterInTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) ;
	virtual BOOL filterOutTypeArray (IINST * piinst, ULONG ciinst, TYP type, 
									OUT IINST ** ppiinstOut, OUT ULONG * pciinstOut) ;
	// get the line number for the declaration
	virtual BOOL ideclInfo(IINST iinst, OUT SZ *pszModule, OUT LINE *piline);
	virtual BOOL ideclInfo(IINST iinst, OUT SZ *pszModule, OUT LINE *piline, OUT LINE *piEndline);
	virtual BOOL ideclInfo(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT SZ *pszModule, OUT LINE *piline, OUT LINE *piEndline = NULL);

	virtual BOOL getIDLMFCComment (IINST iinst, OUT IINST **ppiiComment, OUT ULONG * pciinst) ;
	virtual BOOL getIDLMFCCommentClass (IINST iiComment, OUT SZ * pszClass) ;
	virtual BOOL isIDLMFCComment (IINST iinst, SZ szType, OUT IINST * piiComment, OUT SZ * pszValue) ;
	virtual BOOL getMapIinst (IINST iiClass, SZ szMapType, OUT IINST **ppIinst, OUT ULONG *pciinst);
	virtual BOOL getMapIinst (HTARGET hTarget, BYTE bLanguage, IINST iiClass, SZ szMapType, OUT IINST **ppIinst, OUT ULONG *pciinst);
	virtual BOOL getAllArray (MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL getAllArray (HTARGET hTarget, BYTE bLanguage, MBF mbf, OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL isLangInProject (BYTE bLanguage);
	virtual BOOL isLangInProject (HTARGET hTarget, BYTE bLanguage);
#if CC_MULTIPLE_STORES
	// store related
	virtual BOOL isExistingStore(SZ szName, OUT STORE_TYP* pst, OUT USHORT* psi);
	virtual SZ   szFrStoreTyp(STORE_TYP st);
	virtual BOOL getAllStoresArray(OUT NI** ppni, OUT USHORT* pcStores);
	virtual SZ   szFrStoreIndex(USHORT idx);
#endif	// CC_MULTIPLE_STORES
	virtual BOOL compareIinst (IINST iinst1, IINST iinst2, DWORD * pdwFlags);
	virtual BOOL compareIinst (HTARGET hTarget, IINST iinst1, IINST iinst2, DWORD * pdwFlags);

	// get attributes ...
	virtual BOOL getAttributeArray(IINST iinst, OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL getAttributeArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IINST **ppiinst, OUT ULONG *pciinst);
	virtual BOOL getGlobalAttributeArray(OUT IINST ** ppiinst, OUT ULONG * pciinst);
	virtual BOOL getGlobalAttributeArray(HTARGET hTarget, BYTE bLanguage, OUT IINST ** ppiinst, OUT ULONG * pciinst);

	virtual BOOL getParentIinst(IINST iinstChild, IINST *piinstParent);
	virtual BOOL isIinstInProject(IINST iinst);
	virtual BOOL isIinstInProject(HTARGET hTarget, IINST iinst);
	virtual BOOL isUserIinst(IINST iinst);

	// returns an mbf with all bits set for which TypFilter(typ, mbfXXX) == true
	virtual MBF TypToMBF(TYP typ);

	// returns whether the given IINST is in the given language
	virtual BOOL isIinstInLang(BYTE bLanguage, IINST iinst);

	// get the project a particular IINST is part of
	virtual BOOL getProjectForIinst(IINST iinst, OUT HTARGET* phTarget);
	virtual USHORT IModFrIinst(IINST iinst);

	//get the list of ref info for this string
	virtual BOOL getRefInfo(SZ szName, IINST **ppiinst, ULONG *pciinst);
	virtual BOOL getNIsWithPattern(SZ szPattern, SZ **ppNIs, ULONG *pcNIs);
	virtual IINST getModuleIinst(IMOD imod);
	
	// get the name for this iinst including any parent namespaces
	virtual BOOL iinstNameWithNamespace(IINST iinst, SZ szOut, ULONG_PTR cchOut, ULONG_PTR *pcchNeeded);

	virtual BOOL getDeclForDefn(SZ sz, TYP typ, ATR32 atr, IINST defnIinst, OUT IINST *piinst);
	virtual BOOL getOverloadArrayWithWildcard(SZ sz, MBF mbf, BSCEX_SEARCHOPT eSrchOpts, OUT IINST **ppiinst, OUT ULONG *pciinst);
	
	virtual SZ getAttributeParam(IINST iinst, USHORT ind, BOOL *pfisDefault);
	// END of BscEx interface

//////////////////////////////////////////////////////////////////////////////
// BEGIN of NcbParse interface
	// open by name or by .pdb
	// INTERFACE FOR MODULE LEVEL
	virtual BOOL openMod (SZ szMod, BOOL bCreate, OUT IMOD * pimod);
	virtual BOOL closeMod (IMOD imod, BOOL bSave);
	virtual BOOL clearModContent (IMOD imod);
	virtual BOOL setModTime (IMOD imod, time_t tStamp);
	virtual BOOL getModTime (IMOD imod, time_t *ptStamp);
	virtual BOOL calculateCRC (IMOD imod, USHORT mask, SIG *pSig);

	// set module attributes
	virtual BOOL setModAtr (IMOD imod, BYTE bAtr);
	virtual BOOL getModAtr (IMOD imod, BYTE * pbAtr);

	// check if module is member of a specific target
	virtual BOOL isModInTarget (HTARGET hTarget, IMOD imod);
	virtual BOOL setModAsSrc (HTARGET hTarget, IMOD imod, BOOL bProjSrc);
	// primitives for adding a target to a module
	virtual BOOL addModToTarget (HTARGET hTarget, IMOD imod, BOOL bProjSrc);

	virtual BOOL isModTargetSource (HTARGET hTarget, IMOD imod);
	// primitives for adding an include file
	virtual BOOL addInclToMod (IMOD inclimod, HTARGET hTarget, IMOD imod); 
	virtual BOOL isInclInMod (IMOD inclimod, HTARGET hTarget, IMOD imod);
	// primitives for deleting an include file
	virtual BOOL delInclFrMod (IMOD inclimod, HTARGET hTarget, IMOD imod);

	// primitives for deleting all include files
	virtual BOOL delAllInclFrMod (HTARGET hTarget, IMOD imod);

	// primitives for deleting target from the database
	virtual BOOL delTarget (HTARGET hTarget);
	// primitives for adding a target to the database
	virtual BOOL addTarget (HTARGET hTarget);
	// primitives for deleting file from target
	virtual BOOL delModFrTarget (IMOD imod, HTARGET hTarget);

	virtual BOOL mapTargetToSz (HTARGET hTarget, SZ szTarget);
	virtual BOOL mapSzToTarget (SZ szTarget, HTARGET hTarget);

	virtual BOOL getAllInclMod (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod);
	virtual BOOL getAllTarget (IMOD imod, OUT HTARGET ** ppTarget, OUT ULONG * pcTarget);
	virtual BOOL getAllFlattenDeps (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod, BOOL &bNotifyBuild);

	// INTERFACE FOR OBJECT LEVEL
		// primitives for adding an info
		// IINST is used for containment
	virtual BOOL addProp (SZ szName, TYP typ, ATR32 atr, IMOD imod, OUT IINST * pinst);
	virtual BOOL setKind (IINST iinst, IINST iinstP, BYTE kind);
	virtual BOOL setLine (IINST iinst, LINE lnStart);
	virtual BOOL setDefn (IINST iinst);
	virtual BOOL delProp (IINST iinst);
	// For function, the 1st param is always return type followed by real params.
	// For variable, the 1st param is always type.
	virtual BOOL addParam (IINST iinst, SZ szName);
	// Locking mechanism:
	virtual BOOL lock();
	virtual BOOL unlock();
	virtual BOOL notify(); // flush out notification queue!!
	virtual BOOL suspendNotify ();
	virtual BOOL resumeNotify();
	virtual void graphBuilt();
	virtual BOOL delUnreachable(HTARGET hTarget); 
	virtual BOOL isInit (HTARGET hTarget, IMOD imod);
	virtual BOOL setInit (HTARGET hTarget, IMOD imod, BOOL bInit);
	virtual BOOL notifyImod (OPERATION op, IMOD imod, HTARGET hTarget);
	virtual BOOL notifyIinst (NiQ qItem, HTARGET hTarget, BYTE bLanguage);
	virtual BOOL getBsc (HTARGET hTarget, SZ szName, Bsc ** ppBsc);
	virtual BOOL delUninitTarget ();
    virtual BOOL imodFrSz (SZ szName, OUT IMOD *pimod);
	virtual BOOL getGlobalsArray (MBF mbf, IMOD imod, OUT IinstInfo ** ppiinstinfo, OUT ULONG * pciinst);

	virtual BOOL targetFiles (HTARGET hTarget, BOOL bSrcProjOnly, OUT IMOD ** ppimod, OUT ULONG * pcimod);
	virtual BOOL setAllInit (HTARGET hTarget, BOOL bInit);
	virtual void setNotifyBuild (IMOD imod, BOOL bNotifyBuild);
	virtual BOOL isNotifyBuild (IMOD imod);
	virtual BOOL notifyArrIinst (NiQ * pArrQ, ULONG uSize, HTARGET hTarget, BYTE bLanguage);
// END of NcbParse Interface
// BEGIN of NcbParseEx Interface
	// REVIEW: should be merged as ParseNcb Interface after we have 5.0 langapi project
	virtual BOOL setEndLine (IINST iinst, LINE lnEnd);
	virtual void setModLang (IMOD imod, BYTE bLanguage);
	virtual BOOL setIDLAttrib (IINST iinst, SZ szName, SZ szValue, OUT IINST *piinst);
	virtual BOOL setIDLMFCComment (IINST iinst, SZ szType, SZ szValue, OUT IINST *piinst);

	// This is for keeping a collection of NI search arrays
	virtual ULONG InitializeNIArrays(NcbNameMap *pncbnmpCurClass, NcbNameMap *pncbnmpCurFunc, BOOL fAddPrebuiltStore);
	virtual void ReleaseNIArrays();
	virtual BOOL GetInfoOnIndexIntoNIArrays (ULONG uIndex, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr, OUT IINST *piinst);
	virtual BOOL GetBestMatch(SZ_CONST szSoFar, long iLength, long *piIndex, SZ *pszUnambiguousMatch);
	virtual BOOL GetEmptyNcbNameMap(BOOL fAllowDuplicates, OUT NcbNameMap ** ppncbnmp);
	virtual BOOL GetClassMembersNameMap(IINST iinst, SZ szTemplateArgs, BOOL fAllowDuplicates, BOOL fOnlyBases, OUT NcbNameMap ** ppncbnmp, BOOL fConstructors);
	virtual BOOL GetNameSpaceNameMap(SZ szNS, OUT NcbNameMap ** ppncbnmp);

#if CC_MULTIPLE_STORES
	// New ones added to support multiple stores
	virtual BOOL addStore(SZ szName, STORE_TYP st = ST_USER);
	virtual BOOL delStore(SZ szName);
	virtual BOOL openNextStore();
	virtual BOOL pageInNextStore();
	virtual BOOL delAllStores();
	virtual BOOL openStore(SZ szName, USHORT* pStoreIdx);
	virtual BOOL closeStore(USHORT storeIdx);
#endif // CC_MULTIPLE_STORES
	virtual BOOL beforeUpdate(IMOD imod);
	virtual BOOL afterUpdate(IMOD imod, UpdateItem **ppUpdates, ULONG *pcUpdates, BOOL *pfIncludesChanged);

	virtual BOOL addReference(SZ szName, IINST iinst);
	virtual BOOL delModuleReferences(IMOD imod);
	// delete all modules not in the project - part of NcbParseEx
    virtual BOOL delAllUnrefMod();

	
	    

// END of NcbParseEx Interface
///////////////////////////////////////////////////////////////////////////////
	// these members can be accessed by anyone who can see 
	// the class definition
	Ncb(BOOL bWrite);
	~Ncb();
	InitRetVal init (PDB * pdb, BOOL bIgnoreVersion);
	BOOL unregNotify (pfnNotifyChange pNotify);
	BOOL unregNotify (ULONG index, HTARGET hTarget);
	void setLanguage (BYTE bLanguage, ULONG index);
	BOOL getOverloadArrayWithWildcard(HTARGET hTarget, BYTE bLanguage, SZ sz, MBF mbf, BSCEX_SEARCHOPT eSrchOpts, OUT IINST **ppiinst, OUT ULONG *pciinst);
	BOOL setCaseSensitivity (HTARGET hTarget, BOOL bCase);
   

private:
	// private functions:
	BOOL LoadVersion();
	BOOL SaveVersionToStream();
	BOOL LoadTargetsToMem();
	BOOL SaveTargetsToStream();
	BOOL LoadModHdrsToMem();
	BOOL SaveModHdrsToStream();
	BOOL LoadStoreInfo();
	BOOL SaveStoreInfoToStream();
	BOOL LoadMapToMem(char *szMapName, MapNiToIInstArray *pMap);
	BOOL SaveMapToStream(char *szMapName, MapNiToIInstArray *pMap);
	BOOL CompressTarget (NCB_TARGETINFO * ti, Array<NCB_MODINFO> &rgModInfo);
	BOOL DelUnreachable (NCB_TARGETINFO * ti);
	BOOL DelUnreachable (NCB_TARGETINFO * ti, USHORT i);
	BOOL CompressModHdr();
	BOOL LoadModForRead(USHORT iModHdr, OUT USHORT * pindex);
	BOOL SaveReadModToStream(USHORT iBuf);
	BOOL LoadFrReadToWrite (USHORT iBuf, OUT USHORT * piBuf);
	BOOL LoadFrWriteToRead (USHORT iBuf, OUT USHORT * piBuf);
	BOOL FindWriteIndex (USHORT iModHdr, OUT USHORT *pindex);
	BOOL SetLine (IINST iinst, LINE ln, BOOL bStartLine);
	// conversion from Iinst to imod or iprop
	USHORT IPropFrIinst (IINST iinst);

	// Helper functions for bsc interface:
	BOOL GetIDef (HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IDEF * piDef, OUT USHORT * piBuf);
	BOOL GetIDef (HTARGET hTarget, BYTE bLanguage, IINST iinst, NI ni, TYP typ, NI niBase, NI * rgParam, USHORT cParam, OUT IDEF * piDef, OUT USHORT * piBuf);
        BOOL GetIDefs (HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IDEF ** ppiDef, OUT USHORT * piBuf, ULONG *puCnt);
	BOOL GetIDefs (HTARGET hTarget, BYTE bLanguage, IINST iinst, NI ni, TYP typ, NI niBase, NI * rgParam, USHORT cParam, OUT IDEF ** ppiDef, OUT USHORT * piBuf, ULONG *puCnt);	
	BOOL GetIDecl (HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT IINST * piinstDecl);
	void UpdateBuffer (USHORT index);
	BOOL CheckParam (BYTE bLanguage, NI * rg1, USHORT c1, NI * rg2, USHORT c2);
	BOOL CompareParam (IINST iinst1, IINST iinst2);
	void GetClassFrMember (SZ szName, SZ * pszClass);

	// get a list of iProp given the modhdr
	BOOL GetIPropFrMod (NI ni, USHORT iModHdr, OUT USHORT * pindex, OUT USHORT ** prgProp, OUT ULONG * pcProp);
	void GetIPropFrMod (NI ni, USHORT cProp, NCB_PROP * rgProp, USHORT disp, OUT Array<USHORT> * prgProp); 
	BOOL GetIPropFrMod (SZ sz, USHORT iModHdr, OUT USHORT * pindex, OUT USHORT ** prgProp, OUT ULONG * pcProp);
	void GetIPropFrMod (SZ sz, USHORT cProp, NCB_PROP * rgProp, USHORT disp, OUT Array<USHORT> * prgProp); 
	BOOL FindFirstNi (SZ sz, USHORT cProp, NCB_PROP * rgProp, OUT USHORT * piFirst);
	BOOL getBaseArray (OUT IINST ** ppiinst, OUT ULONG * pciinst, USHORT iModHdr, NCB_USE * rgUse, USHORT count);
	BOOL getAttributeArray(HTARGET hTarget, BYTE bLanguage, IINST iinst, Array<IINST> * prgiinst);
	BOOL getAttributeArray(Array<IINST> * prgiinst, USHORT iModHdr, NCB_USE * rgUse, USHORT count);
	BOOL getParams (IINST iinst, OUT NI ** prgParam, OUT ULONG * pcParam);
	BOOL EnFrIinst (IINST iinst, NCB_ENTITY * pEn);
	BOOL EnFrIinst (IINST iinst, NCB_ENTITY * pEn, HTARGET hTarget);
	BOOL GetGlobalClass (IMOD imod, Array<IINST> * prgiinst, BOOL bGlobalOnly);
	BOOL GetGlobalClass (HTARGET hTarget, BYTE bLanguage, Array<IINST> * prgiinst, BOOL bGlobalOnly);
	BOOL GetGlobalOther(IMOD imod, MBF mbf, Array<IINST> * prgiinst, BOOL bGlobalOnly);
	BOOL GetGlobalOther (HTARGET hTarget, BYTE bLanguage, MBF mbf, Array<IINST> * prgiinst, BOOL bGlobalOnly);

	BOOL GetGlobalClass (IMOD imod, Array<IinstInfo> * prgiinst);
	BOOL GetGlobalClass (HTARGET hTarget, BYTE bLanguage, Array<IinstInfo> * prgiinst);
	BOOL GetGlobalOther(IMOD imod, MBF mbf, Array<IinstInfo> * prgiinst);
	BOOL GetGlobalOther (HTARGET hTarget, BYTE bLanguage, MBF mbf, Array<IinstInfo> * prgiinst);
	
	BOOL IrefInfo (IREF iref, BOOL bStart, OUT SZ *pszModule, OUT LINE *piline);
	BOOL IdefInfo (HTARGET hTarget, BYTE bLanguage, IDEF idef, BOOL bStart, OUT SZ *pszModule, OUT LINE *piline);
	BOOL IdeclInfo (HTARGET hTarget, BYTE bLanguage, IINST iinst, OUT SZ *pszModule, OUT LINE *piline, OUT LINE *piEndline = NULL);
	BOOL IsGlobalName (SZ_CONST sz);
	BOOL ImodFrNi (NI ni, OUT IMOD * pimod);
	BOOL CreateImod (NI ni, OUT IMOD * pimod);
	BOOL FindITarget (HTARGET hTarget, USHORT * piTarget);
	BOOL FindImodInfo (USHORT iTarget, IMOD imod, USHORT * piModInfo);
	BOOL IsIModInfoInIncl (USHORT iTarget, USHORT iModInfo, USHORT iInclModInfo, USHORT * piIncl);
	BOOL delAllInclFrMod (USHORT iTarget, USHORT iModInfo);
	BOOL isInTarget (IMOD imod, USHORT index);
	BOOL getAllFlattenDeps (HTARGET hTarget, IMOD imod, Array<IMOD> &rgMod, BOOL &bNotifyBuild);
	BOOL imodInArray (IMOD imod, Array<IMOD> &rgMod);
	BOOL fHasGlobals (HTARGET hTarget, BYTE bLanguage, MBF mbf);
	BOOL IsClassType (TYP typ);
	void AddToQ (NiQ * pqItem, UINT uSize, HTARGET hTarget, BYTE bLanguage);
	// used by OpenNcb:
	BOOL IsSzInTable (SZ szName, USHORT* pindex);
	BOOL IsPdbInTable (PDB * pdb, USHORT* pindex);
	// add/delete/change queue
	BOOL IsInQ (Array<NiQ> & rgiinst, IINST iinst, USHORT * pindex);
	BOOL delUnreachable();
	// helper functions
	BOOL getOverloadArray(HTARGET hTarget, BYTE bLanguage, SZ sz, MBF mbf, Array<IINST>* prgiinst);
	BOOL getOverloadArrayWildcardFromMap(HTARGET hTarget, BSCEX_SEARCHOPT eSrchOpts, SZ sz, MBF mbf, Array<IINST>* prgiinst, MapNiToIInstArray *map);
	BOOL StrMatchWildcard(SZ szPattern, SZ szCandidate, BOOL fCaseSensitive=TRUE);
	BOOL getAllModulesArray(HTARGET hTarget, BYTE bLanguage, Array<IMOD>* prgimod);
	SZ   getTypeHelper(IINST iinst);
	BOOL GetClassMembersNameMapHelper(IINST iinst, Array<SZ>* prgTArgs, Array<SZ>* prgTFormals, BOOL fOnlyBases, OUT NcbNameMap ** ppncbnmp, BOOL fConstructors);
	void StripNSQname(SZ szFullQname, SZ szPrevNS, SZ *pszName, SZ *pszPrevNS);
	BOOL getDeclForDefn(HTARGET hTarget, BYTE bLanguage, SZ sz, TYP typ, ATR32 atr, IINST defnIinst, OUT IINST *piinst);
	BOOL checkNamespaceParents(IINST iinst, SZ sz);
	BOOL getIinstByvalue3(HTARGET hTarget, BYTE bLang, SZ sz, TYP typ, ATR32 atr, Array<IINST>* rgiinst);


#if CC_MULTIPLE_STORES
	// store related
	BOOL addAStore(USHORT index, NI ni, STORE_TYP st);
	BOOL delAStore(USHORT index);
	BOOL IsChildNcb() const;					// child Ncb's are opened by openStore()
	Ncb* NcbForStore(USHORT index) const;
	// multiple store helper functions
	IMOD LogicalizeImod(IMOD imod, USHORT store) const;
	IMOD PhysicalizeImod(IMOD imod) const;
	IINST LogicalizeIinst(IINST iinst, USHORT store) const;
	IINST PhysicalizeIinst(IINST iinst) const;
	NI LogicalizeNi(NI ni, USHORT store) const;
	NI PhysicalizeNi(NI ni) const;
	USHORT StoreForImod(IMOD imod) const;
	USHORT StoreForIinst(IINST iinst) const;
	USHORT StoreForNi(NI ni) const;
	Ncb* GetNcbForStore(USHORT store);			// opens the store if needed
#endif	// CC_MULTIPLE_STORES



	// data members
	PDB	*		m_pdb;							// our PDB file
	NameMap *	m_pnm;							// Name map, our hash table
	USHORT		m_cTargets;
#if CC_MULTIPLE_STORES
	USHORT		m_cStores;						// used most commonly with FOR_ALL_EXISTING_STORES
#endif	// CC_MULTIPLE_STORES
	BOOL		m_fIOwnThePdb;
	BOOL		m_bGraphBuilt;
	BOOL		m_bWrite;
    BOOL        m_fCaseSensitiveOn;
	
	// target info headers
	NCArray<NCB_TARGETINFO>	m_rgTargetInfo;		// array of target information
												// each element represent target information
	Array<NCB_MODHDR>		m_rgModHdr;			// array of module headers
	Map<NcbString, IMOD, CNcbStringHasher> m_mapFilenameImod; // map of name to imod
    Array<NcbString>        m_rgFilenames;      // map of imod to filename
#if CC_MULTIPLE_STORES
	Array<NCB_STORE_INMEM>	m_rgStoreInfo;		// array of store information
#endif	// CC_MULTIPLE_STORES
	Array<BYTE>				m_rgStat;			// flags to check if the mods are loaded for read/write
												// size should be the same as m_rgModHdr
	Array<BYTE>				m_rgNotifyBuild;	// size should be the same as m_rgModHdr
												// REVIEW: should be merged as a structure
												// with m_rgStat.
												// Used to check if we need to notify the build
												// system when we init the file
												// Default is FALSE
	NCB_CONTENT m_rgContBuf[NCB_MOD_BUF_SIZE];	// content buffer. This buffer is used to load the
												// module into the memory for READ ONLY
												// We need another structure that is less restrictive
												// for WRITING
    void *m_rgEventBuffer,*m_rgAfterEventBuffer;// buffers for the beforeUpdate/afterUpdate arrays
	NCArray<NCB_CONTENT_INMEM> m_rgRWBuf;		// content buffer in a writable form.
	MapNiToIInstArray		m_mapNiDefs;        // map NIs to their defining IINSTs
	NCArray<NcbNotifyQ>		m_rgNotifyQ;
	BOOL					m_bNotifyNow;		// set the notification 
	CRITICAL_SECTION		m_cs;				// critical section for NCB access
	HANDLE					m_hMutex;			// mutex for notification queue
	int						m_nSearchRecurse;	// recursion level in Ncb::GetClassMembersNameMapHelper

	NISearchArrays			m_NISearchArrays;	// This is for keeping a collection of NI search arrays
	MapNiToIInstArray		m_mapRefInfo;		// map NIs to the enclosing IINSTs in which they appear
    BOOL                    m_fIModLimitExceeded;

	// friends and family:
	friend class EnumNi;	
	friend class NcWrap;						// wrapper class for Ncb



};


#if CC_MULTIPLE_STORES
// Use to iterate over all existing stores including current one
#define FOR_ALL_EXISTING_STORES_INCLUDING_PROJECT(x)	for (USHORT x=0; x <= m_cStores; x++)
// Use to iterate over all existing stores
#define FOR_ALL_EXISTING_STORES(x)	for (USHORT x=1; x <= m_cStores; x++)
// Use to iterate over the entire possible range of stores
#define FOR_ALL_STORES(x)	for (USHORT x=1; x < NCB_MAXSTORES; x++)
#endif	// CC_MULTIPLE_STORES

// helper function to match mbf with TYP defined in ncbsc.cpp
BOOL TypFilter (TYP typ, MBF mbf);

//////////////////////////////////
// class to enumerate all the object
// sharing the same Ni
//////////////////////////////////
class EnumNi 
{
public:
	IMOD	m_iModHdr;			// module header
	USHORT  m_index;			// index either to RWBuf or ContBuf
	BYTE	m_BufType;			// either in RWBuf or ContBuf
	USHORT	m_iProp;			// prop index
private:
	NI		m_ni;				// ni to compare: or
	SZ		m_sz;				// sz to compare:
	Ncb	*	m_pncb;				// pointer to Ncb
	USHORT	*m_rgProp;			// prop array
	ULONG	m_cProp;			// size of prop array
	USHORT	m_i;				// index to the m_rgProp;
	HTARGET m_hTarget;			// target specifier
	BYTE	m_bLanguage;		// language specifier
	BOOL	*m_rgbModVisit;		// a bool whether we have visited the mod or not 
public:
	EnumNi (HTARGET hTarget, BYTE bLanguage, NI ni, Ncb * pncb);
	EnumNi (HTARGET hTarget, BYTE bLanguage, SZ sz, Ncb * pncb);
	~EnumNi();
	BOOL GetNext();
	void SkipNi();
};



//////////////////////////////////
// Interface to get reference info
//	associated with each IINST.
//////////////////////////////////
PdbInterface RefBlock
{
	virtual BOOL getAllIinsts(IINST **ppiinst, ULONG *pciinst) pure;
	virtual BOOL getLineNumsForIinst(IINST iinst, ULONG **ppline, ULONG *pcline) pure;
	virtual void disposeArray(void *pAnyArray) pure;
	virtual BOOL close() pure;
};


#ifdef __NCB_INLINES__
#include "ncbrowse.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncparse.h ===
#ifndef __NCPARSE_H__
#define __NCPARSE_H__

#include <pdb.h>
#include <vcbudefs.h>
#include <time.h>
#include "bscext.h"

// values of kinds:
#define NCB_KIND_BASECLASS		0x01
#define NCB_KIND_CONTAINMENT	0x02
#define NCB_KIND_IDL_ATTR		0x03
#define NCB_KIND_IDL_CLASSTYPE	0x04
#define NCB_KIND_ATTRIBUTE		0x05

// PROP definition/declaration.
// This information is hidden in last four bits of ATR
#define INST_NCB_ATR_DECL	0x1000
#define INST_NCB_ATR_DEFN	0x2000
#if 0
/* We don't need java support anymore */
#define INST_NCB_ATR_JAVA   0x4000		
#define INST_NCB_ATR_FINAL	0x8000
#endif /*0*/

/* Define additional attributes for MC++ etc. */

#define INST_NCB_ATR_ABSTRACT			(1U << 14)		/* __abstract			*/
#define INST_NCB_ATR_DELEGATE			(1U << 15)		/* __delegate			*/
#define INST_NCB_ATR_DELEGATE_MCAST		(1U << 16)		/* __delegate(multicast)*/
#define INST_NCB_ATR_EVENT				(1U << 17)		/* __event				*/
#define INST_NCB_ATR_GC					(1U << 18)		/* 1==__gc; 0==__nogc	*/
#define INST_NCB_ATR_PROPERTY			(1U << 19)		/* __property			*/
#define INST_NCB_ATR_SEALED				(1U << 20)		/* __sealed				*/
#define INST_NCB_ATR_VALUETYPE			(1U << 21)		/* __value				*/
#define INST_NCB_ATR_INLINE				(1U << 22)		/* inline function		*/
#define INST_NCB_ATR_UNKNOWN				(1U << 23)		/* Unknown attr	(can be overloaded) for 
														   various typs if required. Using for enums_mems
														   with undefined values right now.	*/
#define INST_NCB_ATR_OPERATOR			(1U << 24)		/* operator function		*/

// Overload some of the BSC attribute bits which aren't used for NCBs
#define INST_ATR_CONST				INST_ATR_NEAR	// for 'const' this
#define INST_ATR_ZERO_MACRO_PARAMS	INST_ATR_NEAR	// e.g. #define MACRO_NAME() ...
#define INST_ATR_GEN_BY_ATTRIBUTE	INST_ATR_COMMON	// iinst was generated by an attribute block
#define INST_NCB_ATR_INJECTED		INST_ATR_GEN_BY_ATTRIBUTE		// injected code
#define INST_ATR_PURE				INST_ATR_SHARED	// for pure virtual function

#define NCB_MOD_ATR_NODEP	0x01

#if 0 /* remove unused macro */
#define NCBAttr(x)		((USHORT) (x & 0x0fff))
#endif

// Flags for masking while taking crc
#define NCB_MASK_LINENUMS	0x01

PdbInterface NcbParse
{
	// same as Bsc interface
	virtual BOOL close() pure; // close the ncbparse interface

// INTERFACE FOR MODULE LEVEL
	// primitives for getting module information
	
	// same as Bsc interface
	virtual BOOL getModuleByName(SZ sz, OUT IMOD *pimod) pure;
	// same as Bsc interface
	virtual BOOL getModuleContents(IMOD imod, MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	// same as Bsc interface
	virtual void disposeArray(void *pAnyArray) pure;

	virtual BOOL openMod (SZ szMod, BOOL bCreate, OUT IMOD * pimod) pure;
	virtual BOOL closeMod (IMOD imod, BOOL bSave) pure;
	virtual BOOL clearModContent (IMOD imod) pure;
	virtual BOOL setModTime (IMOD imod, time_t tStamp) pure;
	virtual BOOL getModTime (IMOD imod, time_t *ptStamp) pure;
	virtual BOOL calculateCRC (IMOD imod, USHORT mask, SIG *pSig) pure;
	
	// set module attributes
	virtual BOOL setModAtr (IMOD imod, BYTE bAtr) pure;
	virtual BOOL getModAtr (IMOD imod, BYTE * pbAtr) pure;

	// check if module is member of a specific target
	virtual BOOL isModInTarget (HTARGET hTarget, IMOD imod) pure;
	virtual BOOL setModAsSrc (HTARGET hTarget, IMOD imod, BOOL bSource) pure;
	virtual BOOL isModTargetSource (HTARGET hTarget, IMOD imod) pure;
	// primitives for adding a target to a module
	virtual BOOL addModToTarget (HTARGET hTarget, IMOD imod, BOOL bProjSrc) pure;

	// primitives for adding an include file
	virtual BOOL addInclToMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure; 
	virtual BOOL isInclInMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure;
	// primitives for deleting an include file
	virtual BOOL delInclFrMod (IMOD inclimod, HTARGET hTarget, IMOD imod) pure;

	// primitives for deleting all include files
	virtual BOOL delAllInclFrMod (HTARGET hTarget, IMOD imod) pure;

	// primitives for deleting target from the database
	virtual BOOL delTarget (HTARGET hTarget) pure;

	// primitives for adding a target to the database
	virtual BOOL addTarget (HTARGET hTarget) pure;

	// primitives for deleting file from target
	virtual BOOL delModFrTarget (IMOD imod, HTARGET hTarget) pure;

	// primitives for setting all the include files:
	virtual BOOL getAllInclMod (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod) pure;
	virtual BOOL getAllTarget (IMOD imod, OUT HTARGET ** ppTarget, OUT ULONG * pcTarget) pure;
	virtual BOOL getAllFlattenDeps (HTARGET hTarget, IMOD imod, OUT IMOD ** ppimod, OUT ULONG * pcmod, BOOL &bNotifyBuild) pure;
	// primitives for initializing target (ie: needs to do this
	// when target name change, first open a target)
	virtual BOOL mapTargetToSz (HTARGET hTarget, SZ szTarget) pure;
	virtual BOOL mapSzToTarget (SZ szTarget, HTARGET hTarget) pure;
	virtual BOOL imodInfo(IMOD imod, OUT SZ *pszModule) pure;
// INTERFACE FOR OBJECT LEVEL
	// primitives for adding an info
	// IINST is used for containment
	virtual BOOL addProp (SZ szName, TYP typ, ATR32 atr, IMOD imod, OUT IINST * pinst) pure;
	virtual BOOL setKind (IINST iinst, IINST iinstP, BYTE kind) pure;
	virtual BOOL setLine (IINST iinst, LINE lnStart) pure;
	virtual BOOL setDefn (IINST iinst) pure;
	virtual BOOL delProp (IINST iinst) pure;
	// For function, the 1st param is always return type followed by real params.
	// For variable, the 1st param is always type.
	virtual BOOL addParam (IINST iinst, SZ szName) pure;
	virtual BOOL iinstInfo2(IINST iinst, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IINST **ppiinst, OUT ULONG *pciinst) pure;
	virtual BOOL getAllGlobalsArray(MBF mbf, OUT IinstInfo **ppiinstinfo, OUT ULONG *pciinst) pure;
	virtual BOOL getGlobalsArray (MBF mbf, IMOD imod, OUT IinstInfo ** ppiinstinfo, OUT ULONG * pciinst) pure;
// Locking mechanism:
	virtual BOOL lock() pure;
	virtual BOOL unlock() pure;
	virtual BOOL notify() pure; // flush out notification queue!!
	virtual BOOL suspendNotify () pure;
	virtual BOOL resumeNotify() pure;
	virtual void graphBuilt() pure;
	virtual BOOL delUnreachable(HTARGET hTarget) pure;
	virtual BOOL isInit (HTARGET hTarget, IMOD imod) pure;
	virtual BOOL setInit (HTARGET hTarget, IMOD imod, BOOL bInit) pure;
	virtual BOOL notifyImod (OPERATION op, IMOD imod, HTARGET hTarget) pure;
	virtual BOOL notifyIinst (NiQ qItem, HTARGET hTarget, BYTE bLanguage) pure;
	virtual BOOL getBsc (HTARGET hTarget, SZ szTarget, Bsc ** ppBsc) pure;
	virtual BOOL delUninitTarget () pure;
    virtual BOOL imodFrSz (SZ szName, OUT IMOD *pimod) pure;
	virtual BOOL irefInfo(IREF iref, OUT SZ *pszModule, OUT LINE *piline) pure;
	virtual BOOL targetFiles (HTARGET hTarget, BOOL bSrcProjOnly, OUT IMOD ** ppimod, OUT ULONG * pcimod) pure;
	virtual BOOL setAllInit (HTARGET hTarget, BOOL bInit) pure;
	virtual void setNotifyBuild (IMOD imod, BOOL bNotifyBuild) pure;
	virtual BOOL isNotifyBuild (IMOD imod) pure;
	virtual BOOL notifyArrIinst (NiQ * pArrQ, ULONG uSize, HTARGET hTarget, BYTE bLanguage) pure;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\DirControl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Tue Jan 08 04:20:14 2002
 */
/* Compiler settings for dircontrol.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dircontrol_h__
#define __dircontrol_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirListSite_FWD_DEFINED__
#define __IDirListSite_FWD_DEFINED__
typedef interface IDirListSite IDirListSite;
#endif 	/* __IDirListSite_FWD_DEFINED__ */


#ifndef __IDirListEvents_FWD_DEFINED__
#define __IDirListEvents_FWD_DEFINED__
typedef interface IDirListEvents IDirListEvents;
#endif 	/* __IDirListEvents_FWD_DEFINED__ */


#ifndef __IDirList_FWD_DEFINED__
#define __IDirList_FWD_DEFINED__
typedef interface IDirList IDirList;
#endif 	/* __IDirList_FWD_DEFINED__ */


#ifndef __IDirAutoCompleteList_FWD_DEFINED__
#define __IDirAutoCompleteList_FWD_DEFINED__
typedef interface IDirAutoCompleteList IDirAutoCompleteList;
#endif 	/* __IDirAutoCompleteList_FWD_DEFINED__ */


#ifndef __DirList_FWD_DEFINED__
#define __DirList_FWD_DEFINED__

#ifdef __cplusplus
typedef class DirList DirList;
#else
typedef struct DirList DirList;
#endif /* __cplusplus */

#endif 	/* __DirList_FWD_DEFINED__ */


#ifndef __DirAutoCompleteList_FWD_DEFINED__
#define __DirAutoCompleteList_FWD_DEFINED__

#ifdef __cplusplus
typedef class DirAutoCompleteList DirAutoCompleteList;
#else
typedef struct DirAutoCompleteList DirAutoCompleteList;
#endif /* __cplusplus */

#endif 	/* __DirAutoCompleteList_FWD_DEFINED__ */


#ifndef __DirListPackage_FWD_DEFINED__
#define __DirListPackage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DirListPackage DirListPackage;
#else
typedef struct DirListPackage DirListPackage;
#endif /* __cplusplus */

#endif 	/* __DirListPackage_FWD_DEFINED__ */


#ifndef __IDirListEvents_FWD_DEFINED__
#define __IDirListEvents_FWD_DEFINED__
typedef interface IDirListEvents IDirListEvents;
#endif 	/* __IDirListEvents_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dircontrol_0000 */
/* [local] */ 

extern "C" const __declspec(selectany) GUID SID_SDirList = { 0x5403ac85L,0xc8c8,0x4967,0xbd,0xb0,0x66,0x2d,0x48,0x5f,0x0c,0x28 };


extern RPC_IF_HANDLE __MIDL_itf_dircontrol_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dircontrol_0000_v0_0_s_ifspec;

#ifndef __IDirListSite_INTERFACE_DEFINED__
#define __IDirListSite_INTERFACE_DEFINED__

/* interface IDirListSite */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirListSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3270982-3ADA-42bf-8EC5-0681DD3F7789")
    IDirListSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ IUnknown *__MIDL_0011) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirListSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirListSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirListSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirListSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSite )( 
            IDirListSite * This,
            /* [in] */ IUnknown *__MIDL_0011);
        
        END_INTERFACE
    } IDirListSiteVtbl;

    interface IDirListSite
    {
        CONST_VTBL struct IDirListSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirListSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirListSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirListSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirListSite_SetSite(This,__MIDL_0011)	\
    (This)->lpVtbl -> SetSite(This,__MIDL_0011)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirListSite_SetSite_Proxy( 
    IDirListSite * This,
    /* [in] */ IUnknown *__MIDL_0011);


void __RPC_STUB IDirListSite_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirListSite_INTERFACE_DEFINED__ */


#ifndef __IDirListEvents_INTERFACE_DEFINED__
#define __IDirListEvents_INTERFACE_DEFINED__

/* interface IDirListEvents */
/* [object][dual][uuid] */ 


EXTERN_C const IID IID_IDirListEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4A68351F-7AEB-4af0-9771-3F206E1FF62F")
    IDirListEvents : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OnChange( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirListEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirListEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirListEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirListEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirListEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirListEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirListEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirListEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            IDirListEvents * This);
        
        END_INTERFACE
    } IDirListEventsVtbl;

    interface IDirListEvents
    {
        CONST_VTBL struct IDirListEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirListEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirListEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirListEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirListEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDirListEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDirListEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDirListEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDirListEvents_OnChange(This)	\
    (This)->lpVtbl -> OnChange(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDirListEvents_OnChange_Proxy( 
    IDirListEvents * This);


void __RPC_STUB IDirListEvents_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirListEvents_INTERFACE_DEFINED__ */


#ifndef __IDirList_INTERFACE_DEFINED__
#define __IDirList_INTERFACE_DEFINED__

/* interface IDirList */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13ACEC02-FA52-4C89-915B-888D05844A6F")
    IDirList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ LONG_PTR *pHWND) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstrDescription) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Title( 
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowTitle( 
            /* [in] */ VARIANT_BOOL bShow) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShowCheck( 
            /* [in] */ VARIANT_BOOL bShow) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *nItems) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Index( 
            /* [in] */ long nItem,
            /* [retval][out] */ BSTR *pbstrItem) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrItem) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HWND )( 
            IDirList * This,
            /* [retval][out] */ LONG_PTR *pHWND);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IDirList * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IDirList * This,
            /* [in] */ BSTR bstrDescription);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IDirList * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Title )( 
            IDirList * This,
            /* [in] */ BSTR bstrTitle);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTitle )( 
            IDirList * This,
            /* [in] */ VARIANT_BOOL bShow);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ShowCheck )( 
            IDirList * This,
            /* [in] */ VARIANT_BOOL bShow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDirList * This,
            /* [retval][out] */ long *nItems);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Index )( 
            IDirList * This,
            /* [in] */ long nItem,
            /* [retval][out] */ BSTR *pbstrItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDirList * This,
            /* [in] */ BSTR bstrItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDirList * This);
        
        END_INTERFACE
    } IDirListVtbl;

    interface IDirList
    {
        CONST_VTBL struct IDirListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDirList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDirList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDirList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDirList_get_HWND(This,pHWND)	\
    (This)->lpVtbl -> get_HWND(This,pHWND)

#define IDirList_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IDirList_put_Description(This,bstrDescription)	\
    (This)->lpVtbl -> put_Description(This,bstrDescription)

#define IDirList_get_Title(This,pbstrTitle)	\
    (This)->lpVtbl -> get_Title(This,pbstrTitle)

#define IDirList_put_Title(This,bstrTitle)	\
    (This)->lpVtbl -> put_Title(This,bstrTitle)

#define IDirList_put_ShowTitle(This,bShow)	\
    (This)->lpVtbl -> put_ShowTitle(This,bShow)

#define IDirList_put_ShowCheck(This,bShow)	\
    (This)->lpVtbl -> put_ShowCheck(This,bShow)

#define IDirList_get_Count(This,nItems)	\
    (This)->lpVtbl -> get_Count(This,nItems)

#define IDirList_Index(This,nItem,pbstrItem)	\
    (This)->lpVtbl -> Index(This,nItem,pbstrItem)

#define IDirList_Add(This,bstrItem)	\
    (This)->lpVtbl -> Add(This,bstrItem)

#define IDirList_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDirList_get_HWND_Proxy( 
    IDirList * This,
    /* [retval][out] */ LONG_PTR *pHWND);


void __RPC_STUB IDirList_get_HWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDirList_get_Description_Proxy( 
    IDirList * This,
    /* [retval][out] */ BSTR *pbstrDescription);


void __RPC_STUB IDirList_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDirList_put_Description_Proxy( 
    IDirList * This,
    /* [in] */ BSTR bstrDescription);


void __RPC_STUB IDirList_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDirList_get_Title_Proxy( 
    IDirList * This,
    /* [retval][out] */ BSTR *pbstrTitle);


void __RPC_STUB IDirList_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDirList_put_Title_Proxy( 
    IDirList * This,
    /* [in] */ BSTR bstrTitle);


void __RPC_STUB IDirList_put_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDirList_put_ShowTitle_Proxy( 
    IDirList * This,
    /* [in] */ VARIANT_BOOL bShow);


void __RPC_STUB IDirList_put_ShowTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDirList_put_ShowCheck_Proxy( 
    IDirList * This,
    /* [in] */ VARIANT_BOOL bShow);


void __RPC_STUB IDirList_put_ShowCheck_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDirList_get_Count_Proxy( 
    IDirList * This,
    /* [retval][out] */ long *nItems);


void __RPC_STUB IDirList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDirList_Index_Proxy( 
    IDirList * This,
    /* [in] */ long nItem,
    /* [retval][out] */ BSTR *pbstrItem);


void __RPC_STUB IDirList_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDirList_Add_Proxy( 
    IDirList * This,
    /* [in] */ BSTR bstrItem);


void __RPC_STUB IDirList_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDirList_Reset_Proxy( 
    IDirList * This);


void __RPC_STUB IDirList_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirList_INTERFACE_DEFINED__ */


#ifndef __IDirAutoCompleteList_INTERFACE_DEFINED__
#define __IDirAutoCompleteList_INTERFACE_DEFINED__

/* interface IDirAutoCompleteList */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirAutoCompleteList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A51B0B6-C730-44CF-9833-EC5D666B23DB")
    IDirAutoCompleteList : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDirAutoCompleteListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirAutoCompleteList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirAutoCompleteList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirAutoCompleteList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirAutoCompleteList * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirAutoCompleteList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirAutoCompleteList * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirAutoCompleteList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IDirAutoCompleteListVtbl;

    interface IDirAutoCompleteList
    {
        CONST_VTBL struct IDirAutoCompleteListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirAutoCompleteList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirAutoCompleteList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirAutoCompleteList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirAutoCompleteList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDirAutoCompleteList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDirAutoCompleteList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDirAutoCompleteList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirAutoCompleteList_INTERFACE_DEFINED__ */



#ifndef __DirControlLib_LIBRARY_DEFINED__
#define __DirControlLib_LIBRARY_DEFINED__

/* library DirControlLib */
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_DirControlLib;

EXTERN_C const CLSID CLSID_DirList;

#ifdef __cplusplus

class DECLSPEC_UUID("AFD20A96-EED8-4D8C-A4EA-18AB96F6C432")
DirList;
#endif

EXTERN_C const CLSID CLSID_DirAutoCompleteList;

#ifdef __cplusplus

class DECLSPEC_UUID("106E2A2B-F06A-4535-9894-43FA4673F9BE")
DirAutoCompleteList;
#endif

EXTERN_C const CLSID CLSID_DirListPackage;

#ifdef __cplusplus

class DECLSPEC_UUID("5010C52F-44AB-4051-8CE1-D36C20D989B4")
DirListPackage;
#endif
#endif /* __DirControlLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\ncsearch.h ===
// NCSEARCH.H
//
// This keeps a collection of sorted NI Arrays and aids in searching
// and retrieving an appropriate index
//

#ifndef __NCSEARCH_H__
#define __NCSEARCH_H__

class Ncb; // forward declaration

struct NIArrayInfo {
    const NI    *pNIArray;
    ULONG       ulSize; // size of the array
    ULONG       ulIndex;    // index into the array
    Ncb         *pNcb;
    NcbNameMap  *pnmp;
    USHORT      store;
};


class NISearchArrays {
public:
    NISearchArrays();
    ~NISearchArrays();
    // This is for keeping a collection of NI search arrays
    ULONG       InitializeNIArrays();
    void        ReleaseNIArrays();
    BOOL        GetInfoOnIndexIntoNIArrays 
                    (ULONG uIndex, OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr, OUT IINST *piinst);
    BOOL        GetBestMatch(SZ_CONST szSoFar, long iLength, long *piIndex, SZ *pszUnambiguousMatch);
    ULONG       m_cNIArrays;
    NIArrayInfo **m_ppNIArrayInfo;
    BOOL        m_bGlobals;

private:
    int     m_iAnchorNI; // this is the NI array info that has the correct rank
    ULONG   m_ulAnchorRank; // This is the rank of the m_ppNIArrayInfo[m_iAnchorNI]->ulIndex in the merged list
    ULONG   m_ulTotal;  // Total count of the number of items in all the NI Search arrays
    BOOL    BinSearch(NIArrayInfo *ptr, SZ_CONST strName, ULONG num, OUT ULONG *puIndex);
    void    ForwardSequentialSearch(ULONG uIndex);
    void    ReverseSequentialSearch(ULONG uIndex);
    void    GetIinstInfoAtAnchor(OUT SZ *psz, OUT TYP *ptyp, OUT ATR32 *patr, OUT IINST *piinst);
};


#endif // !__NCSEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\ncb\parseerr.h ===
//
// ParseErr.h
//


//
// Flags used by ParseFunction() ...
//
#define PF_PARSE_SYMBOL_DECL	0x00000001		// break decl down into components
#define PF_PARAM_NAMES			0x00000002		// include func param names
#define PF_PARAM_DEFAULTS		0x00000004		// include func param default
#define PF_LOOKUP_IINST_DEFN	0x00000008		// Lookup the iinst of the defn in the NCB
#define PF_LOOKUP_IINST_DECL	0x00000010		// Lookup the iinst of the decl in the NCB
#define PF_COMPARE_IINST		0x00000020		// Compare with given iinst in the NCB



//
// Error codes returned by SignatureMatch and ParseFunction in FEACP
//
// Note: The original values come from "ide\pkgs\include\parse.h"
//
#define PARSE_NOERROR				0			// matched perfectly
#define E_PARSE_MISMATCH_PARENT		1
#define E_PARSE_NO_TEMPLATE_DEFN	2
#define E_PARSE_NO_DEFN				3
#define E_PARSE_MULTI_LINE			4
#define E_PARSE_INVALID_TOKEN		5
#define E_PARSE_NO_LEXER			6
#define E_PARSE_EMPTY_STREAM		7
#define E_PARSE_MISMATCH_BRACKET	8
#define E_PARSE_UNEXPECTED_EOL		9
#define E_PARSE_EXTRA_TOKEN			10
#define E_PARSE_CTOR_RET_TYPE		11
#define E_PARSE_DUP_ACCESS_SPEC		12
#define E_PARSE_INVALID_MODIFIER	13
#define E_PARSE_MACROERROR			14
// except for the following new ones ...
#define E_PARSE_NOMATCH				20			// symbol name's don't match up
#define E_PARSE_LOOKUP_FAILED		21			// No symbol's with that name in the NCB
#define E_PARSE_NUM_MISMATCH		22			// mismatched number of parameters
#define E_PARSE_PARAM_MISMATCH		23			// parameter mismatched
#define E_PARSE_RET_TYPE_CONFLICT	24			// Return type incorrect
#define E_PARSE_BAD_IINST1			25			// bad iinst1 parameter to SignatureMatch(<other-args>, iinst1, iinst2)
#define E_PARSE_BAD_IINST2			26			// bad iinst2 parameter to SignatureMatch(<other-args>, iinst1, iinst2)
#define E_PARSE_NOT_IMPLEMENTED		27			// Signature Matching encountered symbol type not yet implemented
#define E_PARSE_NO_DECL_FOUND		28			// ParseFunction could not find a declaration
#define E_PARSE_NO_DEFN_FOUND		29			// ParseFunction could not find a declaration
#define E_PARSE_THIS_MISMATCH		30			// this pointer modifiers mismatched (e.g. const)
#define E_PARSE_ALLOC_FAILED		31			// ParseFunction could not allocate space for array
#define E_PARSE_REPEATED_PARAM		32			// ParseFunction found a repeated param name
#define E_PARSE_SYNTAX_ERROR		33			// ParseFunction found a syntax error


//
// Error codes returned by GetTypeFromBuffer (./-> completion)
// and GetIdentTypeFromBuffer (QuickInfo)
//
#define	ACP_NOERROR					0
#define	E_ACP_FAULT					1			// Hit an access violation
#define	E_ACP_STACK_OVERFLOW		2			// Hit a stack overflow
#define	E_ACP_EOF_ABORT				3			// Hit an unexpected EOF we couldn't recover from
#define	E_ACP_FATAL_OVERFLOW		4			// Hit too many fatal error messages
#define	E_ACP_ERROR_OVERFLOW		5			// Hit too many error messages
#define	E_ACP_PARSER_OVERFLOW		6			// Hit a yacc parser stack overflow
#define	E_ACP_CHKBUF_OVERFLOW		7			// Failed to expand buffer in chkbuf
#define E_ACP_NCB_CALL_FAILED		8			// NCB call failed
#define E_ACP_OUT_OF_HEAP_MEMORY	9			// Call to obtain heap memory failed

// GetTypeFromBuffer specific errors:
#define	E_ACP_DA_NOTREE				10			// LHS of ./-> is in error (no tree)
#define	E_ACP_DA_NOTYPE				11			// LHS of ./-> doesn't have a type
#define	E_ACP_DA_INDIRECTION		12			// LHS of ./-> has inappropriate level of indirection
#define	E_ACP_DA_NOTCSU				13			// LHS of ./-> doesn't name a class/struct/union
#define E_ACP_DA_NO_DOT_ARROW		14			// Call to autocomplete entrypoint without ./-> as EOB
#define E_ACP_DA_TENTATIVE			15			// e.g.   <!>void foo() { Ty *pT; pT-><!> }
												// We know that the type is Ty but Ty was not found in NCB
												// and therefore is just a guess.
#define E_ACP_DA_TEMPLATE_PARAMETER	16			// Resolving type of expression on LHS of ./-> depends on an
												// uninstanciated template parameter.

// GetIdentTypeFromBuffer specific errors:
#define	E_ACP_QI_NOTFOUND			20			// Identifier not found in symbol table or NCB
#define	E_ACP_QI_NOTYPE				21			// Identifier isn't something with a type
#define	E_ACP_QI_TENTATIVE			22			// Identifier is an artificial tentative tag
#define	E_ACP_QI_ERRSYM				23			// Identifier is an error symbol
#define E_ACP_QI_KEYWORD			24			// Identifier was a C/C++ keyword
#define E_ACP_QI_NOT_IDENT			25			// Cursor was not on an identifier but on a hard token

// DoParseForErrors specific errors
#define E_ACP_PE_ABORT				30			// Aborting due to errors from injected text from NCB's

// More general acd errors continued after 9 ...
#define E_ACP_NO_TARGET_FOR_IMOD	40			// The specified imod did not exist in NCB / did not
												// have any target associated with it
#define E_ACP_DECORATED_NAME		41			// Return string was a decorated name

// DoListIncludes specific errors
#define E_ACP_LI_ABORT				50			// Fatal error during LI

//
// Base error count on returning normally from feacp.  If feacp doesn't detect
// the cursor and just compiles to the end of the buffer, it will return the
// current error count, which is actually E_ACP_EXIT_ERRORS + # of real errors
//
#define	E_ACP_EXIT_ERRORS			100

//
// Flags returned by ReportError() which is callback from DoParseForErrors()
//
//
#define RE_FATAL_ERROR		0x00000001
#define RE_ERROR			0x00000002
#define RE_ERROR_3			0x00000003
#define RE_WARNING			0x00000004
#define RE_RESERVED_5		0x00000005
#define RE_NOTE				0x00000006
#define RE_RESERVED_7		0x00000007
#define RE_RESERVED_8		0x00000008
#define RE_RESERVED_9		0x00000009
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\activscp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sat Jan 05 01:23:41 2002
 */
/* Compiler settings for activscp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activscp_h__
#define __activscp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveScriptSite_FWD_DEFINED__
#define __IActiveScriptSite_FWD_DEFINED__
typedef interface IActiveScriptSite IActiveScriptSite;
#endif 	/* __IActiveScriptSite_FWD_DEFINED__ */


#ifndef __IActiveScriptError_FWD_DEFINED__
#define __IActiveScriptError_FWD_DEFINED__
typedef interface IActiveScriptError IActiveScriptError;
#endif 	/* __IActiveScriptError_FWD_DEFINED__ */


#ifndef __IActiveScriptError64_FWD_DEFINED__
#define __IActiveScriptError64_FWD_DEFINED__
typedef interface IActiveScriptError64 IActiveScriptError64;
#endif 	/* __IActiveScriptError64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_FWD_DEFINED__
#define __IActiveScriptSiteWindow_FWD_DEFINED__
typedef interface IActiveScriptSiteWindow IActiveScriptSiteWindow;
#endif 	/* __IActiveScriptSiteWindow_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
#define __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
typedef interface IActiveScriptSiteInterruptPoll IActiveScriptSiteInterruptPoll;
#endif 	/* __IActiveScriptSiteInterruptPoll_FWD_DEFINED__ */


#ifndef __IActiveScript_FWD_DEFINED__
#define __IActiveScript_FWD_DEFINED__
typedef interface IActiveScript IActiveScript;
#endif 	/* __IActiveScript_FWD_DEFINED__ */


#ifndef __IActiveScriptParse32_FWD_DEFINED__
#define __IActiveScriptParse32_FWD_DEFINED__
typedef interface IActiveScriptParse32 IActiveScriptParse32;
#endif 	/* __IActiveScriptParse32_FWD_DEFINED__ */


#ifndef __IActiveScriptParse64_FWD_DEFINED__
#define __IActiveScriptParse64_FWD_DEFINED__
typedef interface IActiveScriptParse64 IActiveScriptParse64;
#endif 	/* __IActiveScriptParse64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld32_FWD_DEFINED__
#define __IActiveScriptParseProcedureOld32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedureOld32 IActiveScriptParseProcedureOld32;
#endif 	/* __IActiveScriptParseProcedureOld32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld64_FWD_DEFINED__
#define __IActiveScriptParseProcedureOld64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedureOld64 IActiveScriptParseProcedureOld64;
#endif 	/* __IActiveScriptParseProcedureOld64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure32_FWD_DEFINED__
#define __IActiveScriptParseProcedure32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure32 IActiveScriptParseProcedure32;
#endif 	/* __IActiveScriptParseProcedure32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure64_FWD_DEFINED__
#define __IActiveScriptParseProcedure64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure64 IActiveScriptParseProcedure64;
#endif 	/* __IActiveScriptParseProcedure64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_32_FWD_DEFINED__
#define __IActiveScriptParseProcedure2_32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure2_32 IActiveScriptParseProcedure2_32;
#endif 	/* __IActiveScriptParseProcedure2_32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_64_FWD_DEFINED__
#define __IActiveScriptParseProcedure2_64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure2_64 IActiveScriptParseProcedure2_64;
#endif 	/* __IActiveScriptParseProcedure2_64_FWD_DEFINED__ */


#ifndef __IActiveScriptEncode_FWD_DEFINED__
#define __IActiveScriptEncode_FWD_DEFINED__
typedef interface IActiveScriptEncode IActiveScriptEncode;
#endif 	/* __IActiveScriptEncode_FWD_DEFINED__ */


#ifndef __IActiveScriptHostEncode_FWD_DEFINED__
#define __IActiveScriptHostEncode_FWD_DEFINED__
typedef interface IActiveScriptHostEncode IActiveScriptHostEncode;
#endif 	/* __IActiveScriptHostEncode_FWD_DEFINED__ */


#ifndef __IBindEventHandler_FWD_DEFINED__
#define __IBindEventHandler_FWD_DEFINED__
typedef interface IBindEventHandler IBindEventHandler;
#endif 	/* __IBindEventHandler_FWD_DEFINED__ */


#ifndef __IActiveScriptStats_FWD_DEFINED__
#define __IActiveScriptStats_FWD_DEFINED__
typedef interface IActiveScriptStats IActiveScriptStats;
#endif 	/* __IActiveScriptStats_FWD_DEFINED__ */


#ifndef __IActiveScriptProperty_FWD_DEFINED__
#define __IActiveScriptProperty_FWD_DEFINED__
typedef interface IActiveScriptProperty IActiveScriptProperty;
#endif 	/* __IActiveScriptProperty_FWD_DEFINED__ */


#ifndef __ITridentEventSink_FWD_DEFINED__
#define __ITridentEventSink_FWD_DEFINED__
typedef interface ITridentEventSink ITridentEventSink;
#endif 	/* __ITridentEventSink_FWD_DEFINED__ */


#ifndef __IActiveScriptGarbageCollector_FWD_DEFINED__
#define __IActiveScriptGarbageCollector_FWD_DEFINED__
typedef interface IActiveScriptGarbageCollector IActiveScriptGarbageCollector;
#endif 	/* __IActiveScriptGarbageCollector_FWD_DEFINED__ */


#ifndef __IActiveScriptSIPInfo_FWD_DEFINED__
#define __IActiveScriptSIPInfo_FWD_DEFINED__
typedef interface IActiveScriptSIPInfo IActiveScriptSIPInfo;
#endif 	/* __IActiveScriptSIPInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_activscp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ActivScp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Scripting host applications and script engines.
//

#ifndef __ActivScp_h
#define __ActivScp_h

/* GUIDs
 ********/

#ifndef _NO_SCRIPT_GUIDS
// {F0B7A1A1-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScript, 0xf0b7a1a1, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A2-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptParse, 0xf0b7a1a2, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A3-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptEncode, 0xf0b7a1a3, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE1-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScript, 0xbb1a2ae1, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE2-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptParse32, 0xbb1a2ae2, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
// {C7EF7658-E1EE-480E-97EA-D52CB4D76D17}
DEFINE_GUID(IID_IActiveScriptParse64, 0xc7ef7658, 0xe1ee, 0x480e, 0x97, 0xea, 0xd5, 0x2c, 0xb4, 0xd7, 0x6d, 0x17);

// {BB1A2AE3-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptEncode, 0xbb1a2ae3, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BEE9B76E-CFE3-11d1-B747-00C04FC2B085}
DEFINE_GUID(IID_IActiveScriptHostEncode, 0xbee9b76e, 0xcfe3, 0x11d1, 0xb7, 0x47, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {1CFF0050-6FDD-11d0-9328-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedureOld32, 0x1cff0050, 0x6fdd, 0x11d0, 0x93, 0x28, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
// {21F57128-08C9-4638-BA12-22D15D88DC5C}
DEFINE_GUID(IID_IActiveScriptParseProcedureOld64, 0x21f57128, 0x08c9, 0x4638, 0xba, 0x12, 0x22, 0xd1, 0x5d, 0x88, 0xdc, 0x5c);

// {AA5B6A80-B834-11d0-932F-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedure32, 0xaa5b6a80, 0xb834, 0x11d0, 0x93, 0x2f, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
// {C64713B6-E029-4CC5-9200-438B72890B6A}
DEFINE_GUID(IID_IActiveScriptParseProcedure64, 0xc64713b6, 0xe029, 0x4cc5, 0x92, 0x00, 0x43, 0x8b, 0x72, 0x89, 0x0b, 0x6a);

// {71EE5B20-FB04-11d1-B3A8-00A0C911E8B2}
DEFINE_GUID(IID_IActiveScriptParseProcedure2_32, 0x71ee5b20, 0xfb04, 0x11d1, 0xb3, 0xa8, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);
// {FE7C4271-210C-448D-9F54-76DAB7047B28}
DEFINE_GUID(IID_IActiveScriptParseProcedure2_64, 0xfe7c4271, 0x210c, 0x448d, 0x9f, 0x54, 0x76, 0xda, 0xb7, 0x04, 0x7b, 0x28);

// {DB01A1E3-A42B-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSite, 0xdb01a1e3, 0xa42b, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {D10F6761-83E9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSiteWindow, 0xd10f6761, 0x83e9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {539698A0-CDCA-11CF-A5EB-00AA0047A063}
DEFINE_GUID(IID_IActiveScriptSiteInterruptPoll, 0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);

// {EAE1BA61-A4ED-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptError,   0xeae1ba61, 0xa4ed, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
// {B21FB2A1-5B8F-4963-8C21-21450F84ED7F}
DEFINE_GUID(IID_IActiveScriptError64, 0xb21fb2a1, 0x5b8f, 0x4963, 0x8c, 0x21, 0x21, 0x45, 0x0f, 0x84, 0xed, 0x7f);

// {63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(IID_IBindEventHandler, 0x63cdbcb0, 0xc1b1, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);

// {B8DA6310-E19B-11d0-933C-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptStats, 0xb8da6310, 0xe19b, 0x11d0, 0x93, 0x3c, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);

// {4954E0D0-FBC7-11D1-8410-006008C3FBFC}
DEFINE_GUID(IID_IActiveScriptProperty, 0x4954E0D0, 0xFBC7, 0x11D1, 0x84, 0x10, 0x00, 0x60, 0x08, 0xC3, 0xFB, 0xFC);

// {1DC9CA50-06EF-11d2-8415-006008C3FBFC}
DEFINE_GUID(IID_ITridentEventSink, 0x1dc9ca50, 0x6ef, 0x11d2, 0x84, 0x15, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc);

// {6AA2C4A0-2B53-11d4-A2A0-00104BD35090}
DEFINE_GUID(IID_IActiveScriptGarbageCollector, 0x6aa2c4a0, 0x2b53, 0x11d4, 0xa2, 0xa0, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {764651D0-38DE-11d4-A2A3-00104BD35090}
DEFINE_GUID(IID_IActiveScriptSIPInfo, 0x764651d0, 0x38de, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {1629F04E-2799-4db5-8FE5-ACE10F17EBAB}
DEFINE_GUID(OID_VBSSIP, 0x1629f04e, 0x2799, 0x4db5, 0x8f, 0xe5, 0xac, 0xe1, 0x0f, 0x17, 0xeb, 0xab);

// {06C9E010-38CE-11d4-A2A3-00104BD35090}
DEFINE_GUID(OID_JSSIP,  0x6c9e010, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {1A610570-38CE-11d4-A2A3-00104BD35090}
DEFINE_GUID(OID_WSFSIP, 0x1a610570, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

#endif // _NO_SCRIPT_GUIDS

// Constants used by ActiveX Scripting:
//

/* IActiveScript::AddNamedItem() input flags */

#define SCRIPTITEM_ISVISIBLE            0x00000002
#define SCRIPTITEM_ISSOURCE             0x00000004
#define SCRIPTITEM_GLOBALMEMBERS        0x00000008
#define SCRIPTITEM_ISPERSISTENT         0x00000040
#define SCRIPTITEM_CODEONLY             0x00000200
#define SCRIPTITEM_NOCODE               0x00000400

#define SCRIPTITEM_ALL_FLAGS            (SCRIPTITEM_ISSOURCE | \
                                         SCRIPTITEM_ISVISIBLE | \
                                         SCRIPTITEM_ISPERSISTENT | \
                                         SCRIPTITEM_GLOBALMEMBERS | \
                                         SCRIPTITEM_NOCODE | \
                                         SCRIPTITEM_CODEONLY)

/* IActiveScript::AddTypeLib() input flags */

#define SCRIPTTYPELIB_ISCONTROL         0x00000010
#define SCRIPTTYPELIB_ISPERSISTENT      0x00000040
#define SCRIPTTYPELIB_ALL_FLAGS         (SCRIPTTYPELIB_ISCONTROL | SCRIPTTYPELIB_ISPERSISTENT)

/* IActiveScriptParse::AddScriptlet() and IActiveScriptParse::ParseScriptText() input flags */

#define SCRIPTTEXT_DELAYEXECUTION       0x00000001
#define SCRIPTTEXT_ISVISIBLE            0x00000002
#define SCRIPTTEXT_ISEXPRESSION         0x00000020
#define SCRIPTTEXT_ISPERSISTENT         0x00000040
#define SCRIPTTEXT_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTTEXT_ALL_FLAGS            (SCRIPTTEXT_DELAYEXECUTION | \
                                         SCRIPTTEXT_ISVISIBLE | \
                                         SCRIPTTEXT_ISEXPRESSION | \
                                         SCRIPTTEXT_ISPERSISTENT | \
                                         SCRIPTTEXT_HOSTMANAGESSOURCE)

/* IActiveScriptParseProcedure::ParseProcedureText() input flags */

#define SCRIPTPROC_ISEXPRESSION         0x00000020
#define SCRIPTPROC_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTPROC_IMPLICIT_THIS        0x00000100
#define SCRIPTPROC_IMPLICIT_PARENTS     0x00000200
#define SCRIPTPROC_ALL_FLAGS            (SCRIPTPROC_HOSTMANAGESSOURCE | \
                                         SCRIPTPROC_ISEXPRESSION | \
                                         SCRIPTPROC_IMPLICIT_THIS | \
                                         SCRIPTPROC_IMPLICIT_PARENTS)

/* IActiveScriptSite::GetItemInfo() input flags */

#define SCRIPTINFO_IUNKNOWN             0x00000001
#define SCRIPTINFO_ITYPEINFO            0x00000002
#define SCRIPTINFO_ALL_FLAGS            (SCRIPTINFO_IUNKNOWN | \
                                         SCRIPTINFO_ITYPEINFO)

/* IActiveScript::Interrupt() Flags */

#define SCRIPTINTERRUPT_DEBUG           0x00000001
#define SCRIPTINTERRUPT_RAISEEXCEPTION  0x00000002
#define SCRIPTINTERRUPT_ALL_FLAGS       (SCRIPTINTERRUPT_DEBUG | \
                                         SCRIPTINTERRUPT_RAISEEXCEPTION)

/* IActiveScriptStats::GetStat() values */

#define SCRIPTSTAT_STATEMENT_COUNT       1
#define SCRIPTSTAT_INSTRUCTION_COUNT     2
#define SCRIPTSTAT_INTSTRUCTION_TIME     3
#define SCRIPTSTAT_TOTAL_TIME            4

/* IActiveScriptEncode::AddSection() input flags */

#define SCRIPT_ENCODE_SECTION         0x00000001

#define SCRIPT_ENCODE_DEFAULT_LANGUAGE        0x00000001
#define SCRIPT_ENCODE_NO_ASP_LANGUAGE         0x00000002

/* Properties for IActiveScriptProperty */
#define SCRIPTPROP_NAME                     0x00000000
#define SCRIPTPROP_MAJORVERSION             0x00000001
#define SCRIPTPROP_MINORVERSION             0x00000002
#define SCRIPTPROP_BUILDNUMBER              0x00000003

#define SCRIPTPROP_DELAYEDEVENTSINKING      0x00001000
#define SCRIPTPROP_CATCHEXCEPTION           0x00001001
#define SCRIPTPROP_CONVERSIONLCID           0x00001002
#define SCRIPTPROP_HOSTSTACKREQUIRED        0x00001003

#define SCRIPTPROP_DEBUGGER                 0x00001100
#define SCRIPTPROP_JITDEBUG                 0x00001101

// These properties are defined and available, but are not
// officially supported.
#define SCRIPTPROP_HACK_FIBERSUPPORT        0x70000000
#define SCRIPTPROP_HACK_TRIDENTEVENTSINK    0x70000001

typedef 
enum tagSCRIPTSTATE
    {	SCRIPTSTATE_UNINITIALIZED	= 0,
	SCRIPTSTATE_INITIALIZED	= 5,
	SCRIPTSTATE_STARTED	= 1,
	SCRIPTSTATE_CONNECTED	= 2,
	SCRIPTSTATE_DISCONNECTED	= 3,
	SCRIPTSTATE_CLOSED	= 4
    } 	SCRIPTSTATE;


/* script thread state values */

typedef 
enum tagSCRIPTTHREADSTATE
    {	SCRIPTTHREADSTATE_NOTINSCRIPT	= 0,
	SCRIPTTHREADSTATE_RUNNING	= 1
    } 	SCRIPTTHREADSTATE;


/* IActiveScriptCollectGarbage constants */

typedef 
enum tagSCRIPTGCTYPE
    {	SCRIPTGCTYPE_NORMAL	= 0,
	SCRIPTGCTYPE_EXHAUSTIVE	= 1
    } 	SCRIPTGCTYPE;



/* Thread IDs */

typedef DWORD SCRIPTTHREADID;


#define SCRIPTTHREADID_CURRENT  ((SCRIPTTHREADID)-1)
#define SCRIPTTHREADID_BASE     ((SCRIPTTHREADID)-2)
#define SCRIPTTHREADID_ALL      ((SCRIPTTHREADID)-3)

/* Structures */

/* Interfaces
 *************/


























extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_v0_0_s_ifspec;

#ifndef __IActiveScriptSite_INTERFACE_DEFINED__
#define __IActiveScriptSite_INTERFACE_DEFINED__

/* interface IActiveScriptSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB01A1E3-A42B-11cf-8F20-00805F2CD064")
    IActiveScriptSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLCID( 
            /* [out] */ LCID *plcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown **ppiunkItem,
            /* [out] */ ITypeInfo **ppti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocVersionString( 
            /* [out] */ BSTR *pbstrVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate( 
            /* [in] */ const VARIANT *pvarResult,
            /* [in] */ const EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ SCRIPTSTATE ssScriptState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptError( 
            /* [in] */ IActiveScriptError *pscripterror) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLCID )( 
            IActiveScriptSite * This,
            /* [out] */ LCID *plcid);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemInfo )( 
            IActiveScriptSite * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown **ppiunkItem,
            /* [out] */ ITypeInfo **ppti);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocVersionString )( 
            IActiveScriptSite * This,
            /* [out] */ BSTR *pbstrVersion);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptTerminate )( 
            IActiveScriptSite * This,
            /* [in] */ const VARIANT *pvarResult,
            /* [in] */ const EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            IActiveScriptSite * This,
            /* [in] */ SCRIPTSTATE ssScriptState);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptError )( 
            IActiveScriptSite * This,
            /* [in] */ IActiveScriptError *pscripterror);
        
        HRESULT ( STDMETHODCALLTYPE *OnEnterScript )( 
            IActiveScriptSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLeaveScript )( 
            IActiveScriptSite * This);
        
        END_INTERFACE
    } IActiveScriptSiteVtbl;

    interface IActiveScriptSite
    {
        CONST_VTBL struct IActiveScriptSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSite_GetLCID(This,plcid)	\
    (This)->lpVtbl -> GetLCID(This,plcid)

#define IActiveScriptSite_GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti)	\
    (This)->lpVtbl -> GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti)

#define IActiveScriptSite_GetDocVersionString(This,pbstrVersion)	\
    (This)->lpVtbl -> GetDocVersionString(This,pbstrVersion)

#define IActiveScriptSite_OnScriptTerminate(This,pvarResult,pexcepinfo)	\
    (This)->lpVtbl -> OnScriptTerminate(This,pvarResult,pexcepinfo)

#define IActiveScriptSite_OnStateChange(This,ssScriptState)	\
    (This)->lpVtbl -> OnStateChange(This,ssScriptState)

#define IActiveScriptSite_OnScriptError(This,pscripterror)	\
    (This)->lpVtbl -> OnScriptError(This,pscripterror)

#define IActiveScriptSite_OnEnterScript(This)	\
    (This)->lpVtbl -> OnEnterScript(This)

#define IActiveScriptSite_OnLeaveScript(This)	\
    (This)->lpVtbl -> OnLeaveScript(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetLCID_Proxy( 
    IActiveScriptSite * This,
    /* [out] */ LCID *plcid);


void __RPC_STUB IActiveScriptSite_GetLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetItemInfo_Proxy( 
    IActiveScriptSite * This,
    /* [in] */ LPCOLESTR pstrName,
    /* [in] */ DWORD dwReturnMask,
    /* [out] */ IUnknown **ppiunkItem,
    /* [out] */ ITypeInfo **ppti);


void __RPC_STUB IActiveScriptSite_GetItemInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_GetDocVersionString_Proxy( 
    IActiveScriptSite * This,
    /* [out] */ BSTR *pbstrVersion);


void __RPC_STUB IActiveScriptSite_GetDocVersionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnScriptTerminate_Proxy( 
    IActiveScriptSite * This,
    /* [in] */ const VARIANT *pvarResult,
    /* [in] */ const EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptSite_OnScriptTerminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnStateChange_Proxy( 
    IActiveScriptSite * This,
    /* [in] */ SCRIPTSTATE ssScriptState);


void __RPC_STUB IActiveScriptSite_OnStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnScriptError_Proxy( 
    IActiveScriptSite * This,
    /* [in] */ IActiveScriptError *pscripterror);


void __RPC_STUB IActiveScriptSite_OnScriptError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnEnterScript_Proxy( 
    IActiveScriptSite * This);


void __RPC_STUB IActiveScriptSite_OnEnterScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSite_OnLeaveScript_Proxy( 
    IActiveScriptSite * This);


void __RPC_STUB IActiveScriptSite_OnLeaveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSite_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptError_INTERFACE_DEFINED__
#define __IActiveScriptError_INTERFACE_DEFINED__

/* interface IActiveScriptError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE1BA61-A4ED-11cf-8F20-00805F2CD064")
    IActiveScriptError : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetExceptionInfo( 
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceLineText( 
            /* [out] */ BSTR *pbstrSourceLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptError * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExceptionInfo )( 
            IActiveScriptError * This,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IActiveScriptError * This,
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLineText )( 
            IActiveScriptError * This,
            /* [out] */ BSTR *pbstrSourceLine);
        
        END_INTERFACE
    } IActiveScriptErrorVtbl;

    interface IActiveScriptError
    {
        CONST_VTBL struct IActiveScriptErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptError_GetExceptionInfo(This,pexcepinfo)	\
    (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo)

#define IActiveScriptError_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)

#define IActiveScriptError_GetSourceLineText(This,pbstrSourceLine)	\
    (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_RemoteGetExceptionInfo_Proxy( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptError_RemoteGetExceptionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptError_GetSourcePosition_Proxy( 
    IActiveScriptError * This,
    /* [out] */ DWORD *pdwSourceContext,
    /* [out] */ ULONG *pulLineNumber,
    /* [out] */ LONG *plCharacterPosition);


void __RPC_STUB IActiveScriptError_GetSourcePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptError_GetSourceLineText_Proxy( 
    IActiveScriptError * This,
    /* [out] */ BSTR *pbstrSourceLine);


void __RPC_STUB IActiveScriptError_GetSourceLineText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptError_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptError64_INTERFACE_DEFINED__
#define __IActiveScriptError64_INTERFACE_DEFINED__

/* interface IActiveScriptError64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptError64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B21FB2A1-5B8F-4963-8C21-21450F84ED7F")
    IActiveScriptError64 : public IActiveScriptError
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition64( 
            /* [out] */ DWORDLONG *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptError64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptError64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptError64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptError64 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExceptionInfo )( 
            IActiveScriptError64 * This,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IActiveScriptError64 * This,
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLineText )( 
            IActiveScriptError64 * This,
            /* [out] */ BSTR *pbstrSourceLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition64 )( 
            IActiveScriptError64 * This,
            /* [out] */ DWORDLONG *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        END_INTERFACE
    } IActiveScriptError64Vtbl;

    interface IActiveScriptError64
    {
        CONST_VTBL struct IActiveScriptError64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptError64_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptError64_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptError64_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptError64_GetExceptionInfo(This,pexcepinfo)	\
    (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo)

#define IActiveScriptError64_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)

#define IActiveScriptError64_GetSourceLineText(This,pbstrSourceLine)	\
    (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine)


#define IActiveScriptError64_GetSourcePosition64(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    (This)->lpVtbl -> GetSourcePosition64(This,pdwSourceContext,pulLineNumber,plCharacterPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptError64_GetSourcePosition64_Proxy( 
    IActiveScriptError64 * This,
    /* [out] */ DWORDLONG *pdwSourceContext,
    /* [out] */ ULONG *pulLineNumber,
    /* [out] */ LONG *plCharacterPosition);


void __RPC_STUB IActiveScriptError64_GetSourcePosition64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptError64_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_INTERFACE_DEFINED__
#define __IActiveScriptSiteWindow_INTERFACE_DEFINED__

/* interface IActiveScriptSiteWindow */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D10F6761-83E9-11cf-8F20-00805F2CD064")
    IActiveScriptSiteWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IActiveScriptSiteWindow * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IActiveScriptSiteWindow * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IActiveScriptSiteWindowVtbl;

    interface IActiveScriptSiteWindow
    {
        CONST_VTBL struct IActiveScriptSiteWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteWindow_GetWindow(This,phwnd)	\
    (This)->lpVtbl -> GetWindow(This,phwnd)

#define IActiveScriptSiteWindow_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteWindow_GetWindow_Proxy( 
    IActiveScriptSiteWindow * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB IActiveScriptSiteWindow_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteWindow_EnableModeless_Proxy( 
    IActiveScriptSiteWindow * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IActiveScriptSiteWindow_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSiteWindow_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__
#define __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__

/* interface IActiveScriptSiteInterruptPoll */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteInterruptPoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("539698A0-CDCA-11CF-A5EB-00AA0047A063")
    IActiveScriptSiteInterruptPoll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteInterruptPollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteInterruptPoll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteInterruptPoll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteInterruptPoll * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            IActiveScriptSiteInterruptPoll * This);
        
        END_INTERFACE
    } IActiveScriptSiteInterruptPollVtbl;

    interface IActiveScriptSiteInterruptPoll
    {
        CONST_VTBL struct IActiveScriptSiteInterruptPollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteInterruptPoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteInterruptPoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteInterruptPoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteInterruptPoll_QueryContinue(This)	\
    (This)->lpVtbl -> QueryContinue(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteInterruptPoll_QueryContinue_Proxy( 
    IActiveScriptSiteInterruptPoll * This);


void __RPC_STUB IActiveScriptSiteInterruptPoll_QueryContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__ */


#ifndef __IActiveScript_INTERFACE_DEFINED__
#define __IActiveScript_INTERFACE_DEFINED__

/* interface IActiveScript */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE1-A4F9-11cf-8F20-00805F2CD064")
    IActiveScript : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScriptSite( 
            /* [in] */ IActiveScriptSite *pass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptSite( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScriptState( 
            /* [in] */ SCRIPTSTATE ss) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptState( 
            /* [out] */ SCRIPTSTATE *pssState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNamedItem( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTypeLib( 
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptDispatch( 
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch **ppdisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentScriptThreadID( 
            /* [out] */ SCRIPTTHREADID *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadID( 
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadState( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE *pstsState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterruptScriptThread( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO *pexcepinfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IActiveScript **ppscript) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScript * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetScriptSite )( 
            IActiveScript * This,
            /* [in] */ IActiveScriptSite *pass);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptSite )( 
            IActiveScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetScriptState )( 
            IActiveScript * This,
            /* [in] */ SCRIPTSTATE ss);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptState )( 
            IActiveScript * This,
            /* [out] */ SCRIPTSTATE *pssState);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IActiveScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddNamedItem )( 
            IActiveScript * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddTypeLib )( 
            IActiveScript * This,
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptDispatch )( 
            IActiveScript * This,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch **ppdisp);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentScriptThreadID )( 
            IActiveScript * This,
            /* [out] */ SCRIPTTHREADID *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptThreadID )( 
            IActiveScript * This,
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptThreadState )( 
            IActiveScript * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE *pstsState);
        
        HRESULT ( STDMETHODCALLTYPE *InterruptScriptThread )( 
            IActiveScript * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO *pexcepinfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IActiveScript * This,
            /* [out] */ IActiveScript **ppscript);
        
        END_INTERFACE
    } IActiveScriptVtbl;

    interface IActiveScript
    {
        CONST_VTBL struct IActiveScriptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScript_SetScriptSite(This,pass)	\
    (This)->lpVtbl -> SetScriptSite(This,pass)

#define IActiveScript_GetScriptSite(This,riid,ppvObject)	\
    (This)->lpVtbl -> GetScriptSite(This,riid,ppvObject)

#define IActiveScript_SetScriptState(This,ss)	\
    (This)->lpVtbl -> SetScriptState(This,ss)

#define IActiveScript_GetScriptState(This,pssState)	\
    (This)->lpVtbl -> GetScriptState(This,pssState)

#define IActiveScript_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IActiveScript_AddNamedItem(This,pstrName,dwFlags)	\
    (This)->lpVtbl -> AddNamedItem(This,pstrName,dwFlags)

#define IActiveScript_AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)	\
    (This)->lpVtbl -> AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)

#define IActiveScript_GetScriptDispatch(This,pstrItemName,ppdisp)	\
    (This)->lpVtbl -> GetScriptDispatch(This,pstrItemName,ppdisp)

#define IActiveScript_GetCurrentScriptThreadID(This,pstidThread)	\
    (This)->lpVtbl -> GetCurrentScriptThreadID(This,pstidThread)

#define IActiveScript_GetScriptThreadID(This,dwWin32ThreadId,pstidThread)	\
    (This)->lpVtbl -> GetScriptThreadID(This,dwWin32ThreadId,pstidThread)

#define IActiveScript_GetScriptThreadState(This,stidThread,pstsState)	\
    (This)->lpVtbl -> GetScriptThreadState(This,stidThread,pstsState)

#define IActiveScript_InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags)	\
    (This)->lpVtbl -> InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags)

#define IActiveScript_Clone(This,ppscript)	\
    (This)->lpVtbl -> Clone(This,ppscript)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScript_SetScriptSite_Proxy( 
    IActiveScript * This,
    /* [in] */ IActiveScriptSite *pass);


void __RPC_STUB IActiveScript_SetScriptSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptSite_Proxy( 
    IActiveScript * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB IActiveScript_GetScriptSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_SetScriptState_Proxy( 
    IActiveScript * This,
    /* [in] */ SCRIPTSTATE ss);


void __RPC_STUB IActiveScript_SetScriptState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptState_Proxy( 
    IActiveScript * This,
    /* [out] */ SCRIPTSTATE *pssState);


void __RPC_STUB IActiveScript_GetScriptState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_Close_Proxy( 
    IActiveScript * This);


void __RPC_STUB IActiveScript_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_AddNamedItem_Proxy( 
    IActiveScript * This,
    /* [in] */ LPCOLESTR pstrName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_AddNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_AddTypeLib_Proxy( 
    IActiveScript * This,
    /* [in] */ REFGUID rguidTypeLib,
    /* [in] */ DWORD dwMajor,
    /* [in] */ DWORD dwMinor,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_AddTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptDispatch_Proxy( 
    IActiveScript * This,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [out] */ IDispatch **ppdisp);


void __RPC_STUB IActiveScript_GetScriptDispatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetCurrentScriptThreadID_Proxy( 
    IActiveScript * This,
    /* [out] */ SCRIPTTHREADID *pstidThread);


void __RPC_STUB IActiveScript_GetCurrentScriptThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptThreadID_Proxy( 
    IActiveScript * This,
    /* [in] */ DWORD dwWin32ThreadId,
    /* [out] */ SCRIPTTHREADID *pstidThread);


void __RPC_STUB IActiveScript_GetScriptThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_GetScriptThreadState_Proxy( 
    IActiveScript * This,
    /* [in] */ SCRIPTTHREADID stidThread,
    /* [out] */ SCRIPTTHREADSTATE *pstsState);


void __RPC_STUB IActiveScript_GetScriptThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_InterruptScriptThread_Proxy( 
    IActiveScript * This,
    /* [in] */ SCRIPTTHREADID stidThread,
    /* [in] */ const EXCEPINFO *pexcepinfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScript_InterruptScriptThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScript_Clone_Proxy( 
    IActiveScript * This,
    /* [out] */ IActiveScript **ppscript);


void __RPC_STUB IActiveScript_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScript_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParse32_INTERFACE_DEFINED__
#define __IActiveScriptParse32_INTERFACE_DEFINED__

/* interface IActiveScriptParse32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParse32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE2-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptParse32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParse32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParse32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParse32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParse32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IActiveScriptParse32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddScriptlet )( 
            IActiveScriptParse32 * This,
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *ParseScriptText )( 
            IActiveScriptParse32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        END_INTERFACE
    } IActiveScriptParse32Vtbl;

    interface IActiveScriptParse32
    {
        CONST_VTBL struct IActiveScriptParse32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParse32_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParse32_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParse32_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParse32_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IActiveScriptParse32_AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)	\
    (This)->lpVtbl -> AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)

#define IActiveScriptParse32_ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)	\
    (This)->lpVtbl -> ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParse32_InitNew_Proxy( 
    IActiveScriptParse32 * This);


void __RPC_STUB IActiveScriptParse32_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse32_AddScriptlet_Proxy( 
    IActiveScriptParse32 * This,
    /* [in] */ LPCOLESTR pstrDefaultName,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ LPCOLESTR pstrSubItemName,
    /* [in] */ LPCOLESTR pstrEventName,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BSTR *pbstrName,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptParse32_AddScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse32_ParseScriptText_Proxy( 
    IActiveScriptParse32 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ VARIANT *pvarResult,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptParse32_ParseScriptText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParse32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParse64_INTERFACE_DEFINED__
#define __IActiveScriptParse64_INTERFACE_DEFINED__

/* interface IActiveScriptParse64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParse64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7EF7658-E1EE-480E-97EA-D52CB4D76D17")
    IActiveScriptParse64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParse64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParse64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParse64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParse64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IActiveScriptParse64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddScriptlet )( 
            IActiveScriptParse64 * This,
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *ParseScriptText )( 
            IActiveScriptParse64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        END_INTERFACE
    } IActiveScriptParse64Vtbl;

    interface IActiveScriptParse64
    {
        CONST_VTBL struct IActiveScriptParse64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParse64_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParse64_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParse64_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParse64_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IActiveScriptParse64_AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)	\
    (This)->lpVtbl -> AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)

#define IActiveScriptParse64_ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)	\
    (This)->lpVtbl -> ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParse64_InitNew_Proxy( 
    IActiveScriptParse64 * This);


void __RPC_STUB IActiveScriptParse64_InitNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse64_AddScriptlet_Proxy( 
    IActiveScriptParse64 * This,
    /* [in] */ LPCOLESTR pstrDefaultName,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ LPCOLESTR pstrSubItemName,
    /* [in] */ LPCOLESTR pstrEventName,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORDLONG dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BSTR *pbstrName,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptParse64_AddScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptParse64_ParseScriptText_Proxy( 
    IActiveScriptParse64 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORDLONG dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ VARIANT *pvarResult,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptParse64_ParseScriptText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParse64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0260 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParse     IActiveScriptParse64
#define IID_IActiveScriptParse IID_IActiveScriptParse64
#else
#define     IActiveScriptParse     IActiveScriptParse32
#define IID_IActiveScriptParse IID_IActiveScriptParse32
#endif
typedef IActiveScriptParse *PIActiveScriptParse;



extern RPC_IF_HANDLE __MIDL_itf_activscp_0260_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0260_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedureOld32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedureOld32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CFF0050-6FDD-11d0-9328-00A0C90DCAA9")
    IActiveScriptParseProcedureOld32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureOld32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedureOld32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedureOld32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedureOld32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedureOld32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureOld32Vtbl;

    interface IActiveScriptParseProcedureOld32
    {
        CONST_VTBL struct IActiveScriptParseProcedureOld32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedureOld32_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedureOld32_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedureOld32_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedureOld32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedureOld32_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedureOld32 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch **ppdisp);


void __RPC_STUB IActiveScriptParseProcedureOld32_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedureOld64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedureOld64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21F57128-08C9-4638-BA12-22D15D88DC5C")
    IActiveScriptParseProcedureOld64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureOld64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedureOld64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedureOld64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedureOld64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedureOld64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureOld64Vtbl;

    interface IActiveScriptParseProcedureOld64
    {
        CONST_VTBL struct IActiveScriptParseProcedureOld64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedureOld64_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedureOld64_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedureOld64_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedureOld64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedureOld64_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedureOld64 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORDLONG dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch **ppdisp);


void __RPC_STUB IActiveScriptParseProcedureOld64_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0262 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedureOld     IActiveScriptParseProcedureOld64
#define IID_IActiveScriptParseProcedureOld IID_IActiveScriptParseProcedureOld64
#else
#define     IActiveScriptParseProcedureOld     IActiveScriptParseProcedureOld32
#define IID_IActiveScriptParseProcedureOld IID_IActiveScriptParseProcedureOld32
#endif
typedef IActiveScriptParseProcedureOld *PIActiveScriptParseProcedureOld;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0262_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedure32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA5B6A80-B834-11d0-932F-00A0C90DCAA9")
    IActiveScriptParseProcedure32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure32Vtbl;

    interface IActiveScriptParseProcedure32
    {
        CONST_VTBL struct IActiveScriptParseProcedure32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure32_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure32_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure32_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedure32_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedure32 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrProcedureName,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch **ppdisp);


void __RPC_STUB IActiveScriptParseProcedure32_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedure32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C64713B6-E029-4CC5-9200-438B72890B6A")
    IActiveScriptParseProcedure64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure64Vtbl;

    interface IActiveScriptParseProcedure64
    {
        CONST_VTBL struct IActiveScriptParseProcedure64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure64_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure64_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure64_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptParseProcedure64_ParseProcedureText_Proxy( 
    IActiveScriptParseProcedure64 * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ LPCOLESTR pstrFormalParams,
    /* [in] */ LPCOLESTR pstrProcedureName,
    /* [in] */ LPCOLESTR pstrItemName,
    /* [in] */ IUnknown *punkContext,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORDLONG dwSourceContextCookie,
    /* [in] */ ULONG ulStartingLineNumber,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDispatch **ppdisp);


void __RPC_STUB IActiveScriptParseProcedure64_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptParseProcedure64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0264 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedure     IActiveScriptParseProcedure64
#define IID_IActiveScriptParseProcedure IID_IActiveScriptParseProcedure64
#else
#define     IActiveScriptParseProcedure     IActiveScriptParseProcedure32
#define IID_IActiveScriptParseProcedure IID_IActiveScriptParseProcedure32
#endif
typedef IActiveScriptParseProcedure *PIActiveScriptParseProcedure;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0264_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure2_32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure2_32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")
    IActiveScriptParseProcedure2_32 : public IActiveScriptParseProcedure32
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure2_32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure2_32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure2_32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure2_32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure2_32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure2_32Vtbl;

    interface IActiveScriptParseProcedure2_32
    {
        CONST_VTBL struct IActiveScriptParseProcedure2_32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure2_32_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure2_32_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure2_32_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure2_32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure2_64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure2_64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE7C4271-210C-448D-9F54-76DAB7047B28")
    IActiveScriptParseProcedure2_64 : public IActiveScriptParseProcedure64
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure2_64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure2_64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure2_64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure2_64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure2_64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure2_64Vtbl;

    interface IActiveScriptParseProcedure2_64
    {
        CONST_VTBL struct IActiveScriptParseProcedure2_64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure2_64_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptParseProcedure2_64_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptParseProcedure2_64_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptParseProcedure2_64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0266 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedure2     IActiveScriptParseProcedure2_64
#define IID_IActiveScriptParseProcedure2 IID_IActiveScriptParseProcedure2_64
#else
#define     IActiveScriptParseProcedure2     IActiveScriptParseProcedure2_32
#define IID_IActiveScriptParseProcedure2 IID_IActiveScriptParseProcedure2_32
#endif
typedef IActiveScriptParseProcedure2 *PIActiveScriptParseProcedure2;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0266_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0266_v0_0_s_ifspec;

#ifndef __IActiveScriptEncode_INTERFACE_DEFINED__
#define __IActiveScriptEncode_INTERFACE_DEFINED__

/* interface IActiveScriptEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE3-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeSection( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DecodeScript( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncodeProgId( 
            /* [out][in] */ BSTR *pbstrOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptEncode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptEncode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *EncodeSection )( 
            IActiveScriptEncode * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE *DecodeScript )( 
            IActiveScriptEncode * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncodeProgId )( 
            IActiveScriptEncode * This,
            /* [out][in] */ BSTR *pbstrOut);
        
        END_INTERFACE
    } IActiveScriptEncodeVtbl;

    interface IActiveScriptEncode
    {
        CONST_VTBL struct IActiveScriptEncodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptEncode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptEncode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptEncode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptEncode_EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    (This)->lpVtbl -> EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet)

#define IActiveScriptEncode_DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    (This)->lpVtbl -> DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet)

#define IActiveScriptEncode_GetEncodeProgId(This,pbstrOut)	\
    (This)->lpVtbl -> GetEncodeProgId(This,pbstrOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptEncode_EncodeSection_Proxy( 
    IActiveScriptEncode * This,
    /* [in] */ LPCOLESTR pchIn,
    /* [in] */ DWORD cchIn,
    /* [out][in] */ LPOLESTR pchOut,
    /* [in] */ DWORD cchOut,
    /* [out][in] */ DWORD *pcchRet);


void __RPC_STUB IActiveScriptEncode_EncodeSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptEncode_DecodeScript_Proxy( 
    IActiveScriptEncode * This,
    /* [in] */ LPCOLESTR pchIn,
    /* [in] */ DWORD cchIn,
    /* [out][in] */ LPOLESTR pchOut,
    /* [in] */ DWORD cchOut,
    /* [out][in] */ DWORD *pcchRet);


void __RPC_STUB IActiveScriptEncode_DecodeScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptEncode_GetEncodeProgId_Proxy( 
    IActiveScriptEncode * This,
    /* [out][in] */ BSTR *pbstrOut);


void __RPC_STUB IActiveScriptEncode_GetEncodeProgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptEncode_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptHostEncode_INTERFACE_DEFINED__
#define __IActiveScriptHostEncode_INTERFACE_DEFINED__

/* interface IActiveScriptHostEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptHostEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEE9B76E-CFE3-11d1-B747-00C04FC2B085")
    IActiveScriptHostEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeScriptHostFile( 
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptHostEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptHostEncode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptHostEncode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptHostEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *EncodeScriptHostFile )( 
            IActiveScriptHostEncode * This,
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang);
        
        END_INTERFACE
    } IActiveScriptHostEncodeVtbl;

    interface IActiveScriptHostEncode
    {
        CONST_VTBL struct IActiveScriptHostEncodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptHostEncode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptHostEncode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptHostEncode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptHostEncode_EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang)	\
    (This)->lpVtbl -> EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptHostEncode_EncodeScriptHostFile_Proxy( 
    IActiveScriptHostEncode * This,
    /* [in] */ BSTR bstrInFile,
    /* [out][in] */ BSTR *pbstrOutFile,
    /* [in] */ unsigned long cFlags,
    /* [in] */ BSTR bstrDefaultLang);


void __RPC_STUB IActiveScriptHostEncode_EncodeScriptHostFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptHostEncode_INTERFACE_DEFINED__ */


#ifndef __IBindEventHandler_INTERFACE_DEFINED__
#define __IBindEventHandler_INTERFACE_DEFINED__

/* interface IBindEventHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBindEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9")
    IBindEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindHandler( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindEventHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindHandler )( 
            IBindEventHandler * This,
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch *pdisp);
        
        END_INTERFACE
    } IBindEventHandlerVtbl;

    interface IBindEventHandler
    {
        CONST_VTBL struct IBindEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindEventHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindEventHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindEventHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindEventHandler_BindHandler(This,pstrEvent,pdisp)	\
    (This)->lpVtbl -> BindHandler(This,pstrEvent,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindEventHandler_BindHandler_Proxy( 
    IBindEventHandler * This,
    /* [in] */ LPCOLESTR pstrEvent,
    /* [in] */ IDispatch *pdisp);


void __RPC_STUB IBindEventHandler_BindHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindEventHandler_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptStats_INTERFACE_DEFINED__
#define __IActiveScriptStats_INTERFACE_DEFINED__

/* interface IActiveScriptStats */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8DA6310-E19B-11d0-933C-00A0C90DCAA9")
    IActiveScriptStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStat( 
            /* [in] */ DWORD stid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatEx( 
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetStats( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStat )( 
            IActiveScriptStats * This,
            /* [in] */ DWORD stid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatEx )( 
            IActiveScriptStats * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE *ResetStats )( 
            IActiveScriptStats * This);
        
        END_INTERFACE
    } IActiveScriptStatsVtbl;

    interface IActiveScriptStats
    {
        CONST_VTBL struct IActiveScriptStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptStats_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptStats_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptStats_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptStats_GetStat(This,stid,pluHi,pluLo)	\
    (This)->lpVtbl -> GetStat(This,stid,pluHi,pluLo)

#define IActiveScriptStats_GetStatEx(This,guid,pluHi,pluLo)	\
    (This)->lpVtbl -> GetStatEx(This,guid,pluHi,pluLo)

#define IActiveScriptStats_ResetStats(This)	\
    (This)->lpVtbl -> ResetStats(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptStats_GetStat_Proxy( 
    IActiveScriptStats * This,
    /* [in] */ DWORD stid,
    /* [out] */ ULONG *pluHi,
    /* [out] */ ULONG *pluLo);


void __RPC_STUB IActiveScriptStats_GetStat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptStats_GetStatEx_Proxy( 
    IActiveScriptStats * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ULONG *pluHi,
    /* [out] */ ULONG *pluLo);


void __RPC_STUB IActiveScriptStats_GetStatEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptStats_ResetStats_Proxy( 
    IActiveScriptStats * This);


void __RPC_STUB IActiveScriptStats_ResetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptStats_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptProperty_INTERFACE_DEFINED__
#define __IActiveScriptProperty_INTERFACE_DEFINED__

/* interface IActiveScriptProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4954E0D0-FBC7-11D1-8410-006008C3FBFC")
    IActiveScriptProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [in] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveScriptProperty * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IActiveScriptProperty * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [in] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } IActiveScriptPropertyVtbl;

    interface IActiveScriptProperty
    {
        CONST_VTBL struct IActiveScriptPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptProperty_GetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    (This)->lpVtbl -> GetProperty(This,dwProperty,pvarIndex,pvarValue)

#define IActiveScriptProperty_SetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    (This)->lpVtbl -> SetProperty(This,dwProperty,pvarIndex,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptProperty_GetProperty_Proxy( 
    IActiveScriptProperty * This,
    /* [in] */ DWORD dwProperty,
    /* [in] */ VARIANT *pvarIndex,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB IActiveScriptProperty_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptProperty_SetProperty_Proxy( 
    IActiveScriptProperty * This,
    /* [in] */ DWORD dwProperty,
    /* [in] */ VARIANT *pvarIndex,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB IActiveScriptProperty_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptProperty_INTERFACE_DEFINED__ */


#ifndef __ITridentEventSink_INTERFACE_DEFINED__
#define __ITridentEventSink_INTERFACE_DEFINED__

/* interface ITridentEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITridentEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DC9CA50-06EF-11d2-8415-006008C3FBFC")
    ITridentEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITridentEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITridentEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITridentEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITridentEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireEvent )( 
            ITridentEventSink * This,
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei);
        
        END_INTERFACE
    } ITridentEventSinkVtbl;

    interface ITridentEventSink
    {
        CONST_VTBL struct ITridentEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITridentEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITridentEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITridentEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITridentEventSink_FireEvent(This,pstrEvent,pdp,pvarRes,pei)	\
    (This)->lpVtbl -> FireEvent(This,pstrEvent,pdp,pvarRes,pei)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITridentEventSink_FireEvent_Proxy( 
    ITridentEventSink * This,
    /* [in] */ LPCOLESTR pstrEvent,
    /* [in] */ DISPPARAMS *pdp,
    /* [out] */ VARIANT *pvarRes,
    /* [out] */ EXCEPINFO *pei);


void __RPC_STUB ITridentEventSink_FireEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITridentEventSink_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptGarbageCollector_INTERFACE_DEFINED__
#define __IActiveScriptGarbageCollector_INTERFACE_DEFINED__

/* interface IActiveScriptGarbageCollector */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptGarbageCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AA2C4A0-2B53-11d4-A2A0-00104BD35090")
    IActiveScriptGarbageCollector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CollectGarbage( 
            SCRIPTGCTYPE scriptgctype) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptGarbageCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptGarbageCollector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptGarbageCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptGarbageCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *CollectGarbage )( 
            IActiveScriptGarbageCollector * This,
            SCRIPTGCTYPE scriptgctype);
        
        END_INTERFACE
    } IActiveScriptGarbageCollectorVtbl;

    interface IActiveScriptGarbageCollector
    {
        CONST_VTBL struct IActiveScriptGarbageCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptGarbageCollector_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptGarbageCollector_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptGarbageCollector_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptGarbageCollector_CollectGarbage(This,scriptgctype)	\
    (This)->lpVtbl -> CollectGarbage(This,scriptgctype)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptGarbageCollector_CollectGarbage_Proxy( 
    IActiveScriptGarbageCollector * This,
    SCRIPTGCTYPE scriptgctype);


void __RPC_STUB IActiveScriptGarbageCollector_CollectGarbage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptGarbageCollector_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSIPInfo_INTERFACE_DEFINED__
#define __IActiveScriptSIPInfo_INTERFACE_DEFINED__

/* interface IActiveScriptSIPInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSIPInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("764651D0-38DE-11d4-A2A3-00104BD35090")
    IActiveScriptSIPInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSIPOID( 
            /* [out] */ GUID *poid_sip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSIPInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSIPInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSIPInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSIPInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIPOID )( 
            IActiveScriptSIPInfo * This,
            /* [out] */ GUID *poid_sip);
        
        END_INTERFACE
    } IActiveScriptSIPInfoVtbl;

    interface IActiveScriptSIPInfo
    {
        CONST_VTBL struct IActiveScriptSIPInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSIPInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSIPInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSIPInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSIPInfo_GetSIPOID(This,poid_sip)	\
    (This)->lpVtbl -> GetSIPOID(This,poid_sip)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSIPInfo_GetSIPOID_Proxy( 
    IActiveScriptSIPInfo * This,
    /* [out] */ GUID *poid_sip);


void __RPC_STUB IActiveScriptSIPInfo_GetSIPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptSIPInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0274 */
/* [local] */ 


#endif  // __ActivScp_h



extern RPC_IF_HANDLE __MIDL_itf_activscp_0274_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0274_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_GetExceptionInfo_Proxy( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_GetExceptionInfo_Stub( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\helpsys.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Tue Jan 08 04:19:27 2002
 */
/* Compiler settings for helpsys.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __helpsys_h__
#define __helpsys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVsHelpSystem_FWD_DEFINED__
#define __IVsHelpSystem_FWD_DEFINED__
typedef interface IVsHelpSystem IVsHelpSystem;
#endif 	/* __IVsHelpSystem_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_helpsys_0000 */
/* [local] */ 

#ifndef INT_TYPE
#define INT_TYPE DWORD_PTR
#define LCID_TYPE DWORD
#endif
typedef /* [public][v1_enum] */ 
enum _VsHelpErrors
    {	VSHELP_E_HTMLHELP_UNKNOWN	= 0x80000000 | 4 << 16 | 0x1000,
	VSHELP_E_COLLECTIONDOESNOTEXIST	= 0x80000000 | 4 << 16 | 0x1001,
	VSHELP_E_COLLECTIONNOTREGISTERED	= 0x80000000 | 4 << 16 | 0x1002,
	VSHELP_E_REGISTRATION	= 0x80000000 | 4 << 16 | 0x1003,
	VSHELP_E_PREFERREDCOLLECTION	= 0x80000000 | 4 << 16 | 0x1004
    } 	VsHelpErrors;



extern RPC_IF_HANDLE __MIDL_itf_helpsys_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_helpsys_0000_v0_0_s_ifspec;

#ifndef __IVsHelpSystem_INTERFACE_DEFINED__
#define __IVsHelpSystem_INTERFACE_DEFINED__

/* interface IVsHelpSystem */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][v1_enum] */ 
enum _VHS_COMMANDS
    {	VHS_Default	= 0,
	VHS_NoErrorMessages	= 0x8,
	VHS_UseBrowser	= 0x1,
	VHS_UseHelp	= 0x2,
	VHS_Localize	= 0x4,
	VHS_OutsideCollectionSpace	= 0x10
    } 	VHS_COMMAND;


EXTERN_C const IID IID_IVsHelpSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("854d7ac0-bc3d-11d0-b421-00a0c90f9dc4")
    IVsHelpSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearch( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ALinkSearch( 
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE KeywordSearchDlg( 
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FullTextSearchDlg( 
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentURL( 
            /* [out] */ BSTR *ppszURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromURL( 
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD_PTR Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayTopicFromIdentifier( 
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD_PTR Id,
            /* [in] */ const DWORD_PTR Command) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ActivateHelpSystem( 
            /* [in] */ const DWORD_PTR dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reserved( 
            /* [in] */ VHS_COMMAND command,
            /* [in] */ VsHelpErrors error) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVsHelpSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVsHelpSystem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVsHelpSystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVsHelpSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *KeywordSearch )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ALinkSearch )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszALink,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *KeywordSearchDlg )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszKeyword,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FullTextSearchDlg )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszQuery,
            /* [in] */ const DWORD_PTR dwFlags,
            /* [in] */ DWORD_PTR dwReserved);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentURL )( 
            IVsHelpSystem * This,
            /* [out] */ BSTR *ppszURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisplayTopicFromURL )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszURL,
            /* [in] */ const DWORD_PTR Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisplayTopicFromIdentifier )( 
            IVsHelpSystem * This,
            /* [in] */ LPCOLESTR pszFile,
            /* [in] */ const DWORD_PTR Id,
            /* [in] */ const DWORD_PTR Command);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ActivateHelpSystem )( 
            IVsHelpSystem * This,
            /* [in] */ const DWORD_PTR dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reserved )( 
            IVsHelpSystem * This,
            /* [in] */ VHS_COMMAND command,
            /* [in] */ VsHelpErrors error);
        
        END_INTERFACE
    } IVsHelpSystemVtbl;

    interface IVsHelpSystem
    {
        CONST_VTBL struct IVsHelpSystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVsHelpSystem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVsHelpSystem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVsHelpSystem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVsHelpSystem_KeywordSearch(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearch(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_ALinkSearch(This,pszALink,dwFlags,dwReserved)	\
    (This)->lpVtbl -> ALinkSearch(This,pszALink,dwFlags,dwReserved)

#define IVsHelpSystem_KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)	\
    (This)->lpVtbl -> KeywordSearchDlg(This,pszKeyword,dwFlags,dwReserved)

#define IVsHelpSystem_FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)	\
    (This)->lpVtbl -> FullTextSearchDlg(This,pszQuery,dwFlags,dwReserved)

#define IVsHelpSystem_GetCurrentURL(This,ppszURL)	\
    (This)->lpVtbl -> GetCurrentURL(This,ppszURL)

#define IVsHelpSystem_DisplayTopicFromURL(This,pszURL,Command)	\
    (This)->lpVtbl -> DisplayTopicFromURL(This,pszURL,Command)

#define IVsHelpSystem_DisplayTopicFromIdentifier(This,pszFile,Id,Command)	\
    (This)->lpVtbl -> DisplayTopicFromIdentifier(This,pszFile,Id,Command)

#define IVsHelpSystem_ActivateHelpSystem(This,dwFlags)	\
    (This)->lpVtbl -> ActivateHelpSystem(This,dwFlags)

#define IVsHelpSystem_Reserved(This,command,error)	\
    (This)->lpVtbl -> Reserved(This,command,error)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearch_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD_PTR dwFlags,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ALinkSearch_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszALink,
    /* [in] */ const DWORD_PTR dwFlags,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IVsHelpSystem_ALinkSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_KeywordSearchDlg_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszKeyword,
    /* [in] */ const DWORD_PTR dwFlags,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IVsHelpSystem_KeywordSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_FullTextSearchDlg_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszQuery,
    /* [in] */ const DWORD_PTR dwFlags,
    /* [in] */ DWORD_PTR dwReserved);


void __RPC_STUB IVsHelpSystem_FullTextSearchDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_GetCurrentURL_Proxy( 
    IVsHelpSystem * This,
    /* [out] */ BSTR *ppszURL);


void __RPC_STUB IVsHelpSystem_GetCurrentURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromURL_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszURL,
    /* [in] */ const DWORD_PTR Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_DisplayTopicFromIdentifier_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ LPCOLESTR pszFile,
    /* [in] */ const DWORD_PTR Id,
    /* [in] */ const DWORD_PTR Command);


void __RPC_STUB IVsHelpSystem_DisplayTopicFromIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_ActivateHelpSystem_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ const DWORD_PTR dwFlags);


void __RPC_STUB IVsHelpSystem_ActivateHelpSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVsHelpSystem_Reserved_Proxy( 
    IVsHelpSystem * This,
    /* [in] */ VHS_COMMAND command,
    /* [in] */ VsHelpErrors error);


void __RPC_STUB IVsHelpSystem_Reserved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVsHelpSystem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_helpsys_0252 */
/* [local] */ 

#define SID_SVsHelpService IID_IVsHelpSystem
#define SID_SHelpService IID_IVsHelpSystem


extern RPC_IF_HANDLE __MIDL_itf_helpsys_0252_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_helpsys_0252_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\msdbg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sat Jan 05 01:24:02 2002
 */
/* Compiler settings for msdbg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msdbg_h__
#define __msdbg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDebugMachine2_FWD_DEFINED__
#define __IDebugMachine2_FWD_DEFINED__
typedef interface IDebugMachine2 IDebugMachine2;
#endif 	/* __IDebugMachine2_FWD_DEFINED__ */


#ifndef __IDebugMachineEx2_FWD_DEFINED__
#define __IDebugMachineEx2_FWD_DEFINED__
typedef interface IDebugMachineEx2 IDebugMachineEx2;
#endif 	/* __IDebugMachineEx2_FWD_DEFINED__ */


#ifndef __IDebugPortSupplier2_FWD_DEFINED__
#define __IDebugPortSupplier2_FWD_DEFINED__
typedef interface IDebugPortSupplier2 IDebugPortSupplier2;
#endif 	/* __IDebugPortSupplier2_FWD_DEFINED__ */


#ifndef __IDebugPort2_FWD_DEFINED__
#define __IDebugPort2_FWD_DEFINED__
typedef interface IDebugPort2 IDebugPort2;
#endif 	/* __IDebugPort2_FWD_DEFINED__ */


#ifndef __IDebugPortRequest2_FWD_DEFINED__
#define __IDebugPortRequest2_FWD_DEFINED__
typedef interface IDebugPortRequest2 IDebugPortRequest2;
#endif 	/* __IDebugPortRequest2_FWD_DEFINED__ */


#ifndef __IDebugPortNotify2_FWD_DEFINED__
#define __IDebugPortNotify2_FWD_DEFINED__
typedef interface IDebugPortNotify2 IDebugPortNotify2;
#endif 	/* __IDebugPortNotify2_FWD_DEFINED__ */


#ifndef __IDebugPortEvents2_FWD_DEFINED__
#define __IDebugPortEvents2_FWD_DEFINED__
typedef interface IDebugPortEvents2 IDebugPortEvents2;
#endif 	/* __IDebugPortEvents2_FWD_DEFINED__ */


#ifndef __IDebugMDMUtil2_FWD_DEFINED__
#define __IDebugMDMUtil2_FWD_DEFINED__
typedef interface IDebugMDMUtil2 IDebugMDMUtil2;
#endif 	/* __IDebugMDMUtil2_FWD_DEFINED__ */


#ifndef __IDebugSession2_FWD_DEFINED__
#define __IDebugSession2_FWD_DEFINED__
typedef interface IDebugSession2 IDebugSession2;
#endif 	/* __IDebugSession2_FWD_DEFINED__ */


#ifndef __IDebugEngine2_FWD_DEFINED__
#define __IDebugEngine2_FWD_DEFINED__
typedef interface IDebugEngine2 IDebugEngine2;
#endif 	/* __IDebugEngine2_FWD_DEFINED__ */


#ifndef __IDebugEngineLaunch2_FWD_DEFINED__
#define __IDebugEngineLaunch2_FWD_DEFINED__
typedef interface IDebugEngineLaunch2 IDebugEngineLaunch2;
#endif 	/* __IDebugEngineLaunch2_FWD_DEFINED__ */


#ifndef __IDebugEventCallback2_FWD_DEFINED__
#define __IDebugEventCallback2_FWD_DEFINED__
typedef interface IDebugEventCallback2 IDebugEventCallback2;
#endif 	/* __IDebugEventCallback2_FWD_DEFINED__ */


#ifndef __IDebugEvent2_FWD_DEFINED__
#define __IDebugEvent2_FWD_DEFINED__
typedef interface IDebugEvent2 IDebugEvent2;
#endif 	/* __IDebugEvent2_FWD_DEFINED__ */


#ifndef __IDebugSessionCreateEvent2_FWD_DEFINED__
#define __IDebugSessionCreateEvent2_FWD_DEFINED__
typedef interface IDebugSessionCreateEvent2 IDebugSessionCreateEvent2;
#endif 	/* __IDebugSessionCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugSessionDestroyEvent2_FWD_DEFINED__
#define __IDebugSessionDestroyEvent2_FWD_DEFINED__
typedef interface IDebugSessionDestroyEvent2 IDebugSessionDestroyEvent2;
#endif 	/* __IDebugSessionDestroyEvent2_FWD_DEFINED__ */


#ifndef __IDebugEngineCreateEvent2_FWD_DEFINED__
#define __IDebugEngineCreateEvent2_FWD_DEFINED__
typedef interface IDebugEngineCreateEvent2 IDebugEngineCreateEvent2;
#endif 	/* __IDebugEngineCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugProcessCreateEvent2_FWD_DEFINED__
#define __IDebugProcessCreateEvent2_FWD_DEFINED__
typedef interface IDebugProcessCreateEvent2 IDebugProcessCreateEvent2;
#endif 	/* __IDebugProcessCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugProcessDestroyEvent2_FWD_DEFINED__
#define __IDebugProcessDestroyEvent2_FWD_DEFINED__
typedef interface IDebugProcessDestroyEvent2 IDebugProcessDestroyEvent2;
#endif 	/* __IDebugProcessDestroyEvent2_FWD_DEFINED__ */


#ifndef __IDebugProgramCreateEvent2_FWD_DEFINED__
#define __IDebugProgramCreateEvent2_FWD_DEFINED__
typedef interface IDebugProgramCreateEvent2 IDebugProgramCreateEvent2;
#endif 	/* __IDebugProgramCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugProgramDestroyEvent2_FWD_DEFINED__
#define __IDebugProgramDestroyEvent2_FWD_DEFINED__
typedef interface IDebugProgramDestroyEvent2 IDebugProgramDestroyEvent2;
#endif 	/* __IDebugProgramDestroyEvent2_FWD_DEFINED__ */


#ifndef __IDebugThreadCreateEvent2_FWD_DEFINED__
#define __IDebugThreadCreateEvent2_FWD_DEFINED__
typedef interface IDebugThreadCreateEvent2 IDebugThreadCreateEvent2;
#endif 	/* __IDebugThreadCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugThreadDestroyEvent2_FWD_DEFINED__
#define __IDebugThreadDestroyEvent2_FWD_DEFINED__
typedef interface IDebugThreadDestroyEvent2 IDebugThreadDestroyEvent2;
#endif 	/* __IDebugThreadDestroyEvent2_FWD_DEFINED__ */


#ifndef __IDebugLoadCompleteEvent2_FWD_DEFINED__
#define __IDebugLoadCompleteEvent2_FWD_DEFINED__
typedef interface IDebugLoadCompleteEvent2 IDebugLoadCompleteEvent2;
#endif 	/* __IDebugLoadCompleteEvent2_FWD_DEFINED__ */


#ifndef __IDebugEntryPointEvent2_FWD_DEFINED__
#define __IDebugEntryPointEvent2_FWD_DEFINED__
typedef interface IDebugEntryPointEvent2 IDebugEntryPointEvent2;
#endif 	/* __IDebugEntryPointEvent2_FWD_DEFINED__ */


#ifndef __IDebugStepCompleteEvent2_FWD_DEFINED__
#define __IDebugStepCompleteEvent2_FWD_DEFINED__
typedef interface IDebugStepCompleteEvent2 IDebugStepCompleteEvent2;
#endif 	/* __IDebugStepCompleteEvent2_FWD_DEFINED__ */


#ifndef __IDebugCanStopEvent2_FWD_DEFINED__
#define __IDebugCanStopEvent2_FWD_DEFINED__
typedef interface IDebugCanStopEvent2 IDebugCanStopEvent2;
#endif 	/* __IDebugCanStopEvent2_FWD_DEFINED__ */


#ifndef __IDebugBreakEvent2_FWD_DEFINED__
#define __IDebugBreakEvent2_FWD_DEFINED__
typedef interface IDebugBreakEvent2 IDebugBreakEvent2;
#endif 	/* __IDebugBreakEvent2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointEvent2_FWD_DEFINED__
#define __IDebugBreakpointEvent2_FWD_DEFINED__
typedef interface IDebugBreakpointEvent2 IDebugBreakpointEvent2;
#endif 	/* __IDebugBreakpointEvent2_FWD_DEFINED__ */


#ifndef __IDebugExceptionEvent2_FWD_DEFINED__
#define __IDebugExceptionEvent2_FWD_DEFINED__
typedef interface IDebugExceptionEvent2 IDebugExceptionEvent2;
#endif 	/* __IDebugExceptionEvent2_FWD_DEFINED__ */


#ifndef __IDebugOutputStringEvent2_FWD_DEFINED__
#define __IDebugOutputStringEvent2_FWD_DEFINED__
typedef interface IDebugOutputStringEvent2 IDebugOutputStringEvent2;
#endif 	/* __IDebugOutputStringEvent2_FWD_DEFINED__ */


#ifndef __IDebugModuleLoadEvent2_FWD_DEFINED__
#define __IDebugModuleLoadEvent2_FWD_DEFINED__
typedef interface IDebugModuleLoadEvent2 IDebugModuleLoadEvent2;
#endif 	/* __IDebugModuleLoadEvent2_FWD_DEFINED__ */


#ifndef __IDebugPropertyCreateEvent2_FWD_DEFINED__
#define __IDebugPropertyCreateEvent2_FWD_DEFINED__
typedef interface IDebugPropertyCreateEvent2 IDebugPropertyCreateEvent2;
#endif 	/* __IDebugPropertyCreateEvent2_FWD_DEFINED__ */


#ifndef __IDebugPropertyDestroyEvent2_FWD_DEFINED__
#define __IDebugPropertyDestroyEvent2_FWD_DEFINED__
typedef interface IDebugPropertyDestroyEvent2 IDebugPropertyDestroyEvent2;
#endif 	/* __IDebugPropertyDestroyEvent2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointBoundEvent2_FWD_DEFINED__
#define __IDebugBreakpointBoundEvent2_FWD_DEFINED__
typedef interface IDebugBreakpointBoundEvent2 IDebugBreakpointBoundEvent2;
#endif 	/* __IDebugBreakpointBoundEvent2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointUnboundEvent2_FWD_DEFINED__
#define __IDebugBreakpointUnboundEvent2_FWD_DEFINED__
typedef interface IDebugBreakpointUnboundEvent2 IDebugBreakpointUnboundEvent2;
#endif 	/* __IDebugBreakpointUnboundEvent2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointErrorEvent2_FWD_DEFINED__
#define __IDebugBreakpointErrorEvent2_FWD_DEFINED__
typedef interface IDebugBreakpointErrorEvent2 IDebugBreakpointErrorEvent2;
#endif 	/* __IDebugBreakpointErrorEvent2_FWD_DEFINED__ */


#ifndef __IDebugExpressionEvaluationCompleteEvent2_FWD_DEFINED__
#define __IDebugExpressionEvaluationCompleteEvent2_FWD_DEFINED__
typedef interface IDebugExpressionEvaluationCompleteEvent2 IDebugExpressionEvaluationCompleteEvent2;
#endif 	/* __IDebugExpressionEvaluationCompleteEvent2_FWD_DEFINED__ */


#ifndef __IDebugReturnValueEvent2_FWD_DEFINED__
#define __IDebugReturnValueEvent2_FWD_DEFINED__
typedef interface IDebugReturnValueEvent2 IDebugReturnValueEvent2;
#endif 	/* __IDebugReturnValueEvent2_FWD_DEFINED__ */


#ifndef __IDebugFindSymbolEvent2_FWD_DEFINED__
#define __IDebugFindSymbolEvent2_FWD_DEFINED__
typedef interface IDebugFindSymbolEvent2 IDebugFindSymbolEvent2;
#endif 	/* __IDebugFindSymbolEvent2_FWD_DEFINED__ */


#ifndef __IDebugNoSymbolsEvent2_FWD_DEFINED__
#define __IDebugNoSymbolsEvent2_FWD_DEFINED__
typedef interface IDebugNoSymbolsEvent2 IDebugNoSymbolsEvent2;
#endif 	/* __IDebugNoSymbolsEvent2_FWD_DEFINED__ */


#ifndef __IDebugProgramNameChangedEvent2_FWD_DEFINED__
#define __IDebugProgramNameChangedEvent2_FWD_DEFINED__
typedef interface IDebugProgramNameChangedEvent2 IDebugProgramNameChangedEvent2;
#endif 	/* __IDebugProgramNameChangedEvent2_FWD_DEFINED__ */


#ifndef __IDebugThreadNameChangedEvent2_FWD_DEFINED__
#define __IDebugThreadNameChangedEvent2_FWD_DEFINED__
typedef interface IDebugThreadNameChangedEvent2 IDebugThreadNameChangedEvent2;
#endif 	/* __IDebugThreadNameChangedEvent2_FWD_DEFINED__ */


#ifndef __IDebugMessageEvent2_FWD_DEFINED__
#define __IDebugMessageEvent2_FWD_DEFINED__
typedef interface IDebugMessageEvent2 IDebugMessageEvent2;
#endif 	/* __IDebugMessageEvent2_FWD_DEFINED__ */


#ifndef __IDebugActivateDocumentEvent2_FWD_DEFINED__
#define __IDebugActivateDocumentEvent2_FWD_DEFINED__
typedef interface IDebugActivateDocumentEvent2 IDebugActivateDocumentEvent2;
#endif 	/* __IDebugActivateDocumentEvent2_FWD_DEFINED__ */


#ifndef __IDebugProcess2_FWD_DEFINED__
#define __IDebugProcess2_FWD_DEFINED__
typedef interface IDebugProcess2 IDebugProcess2;
#endif 	/* __IDebugProcess2_FWD_DEFINED__ */


#ifndef __IDebugProgram2_FWD_DEFINED__
#define __IDebugProgram2_FWD_DEFINED__
typedef interface IDebugProgram2 IDebugProgram2;
#endif 	/* __IDebugProgram2_FWD_DEFINED__ */


#ifndef __IDebugEngineProgram2_FWD_DEFINED__
#define __IDebugEngineProgram2_FWD_DEFINED__
typedef interface IDebugEngineProgram2 IDebugEngineProgram2;
#endif 	/* __IDebugEngineProgram2_FWD_DEFINED__ */


#ifndef __IDebugProgramHost2_FWD_DEFINED__
#define __IDebugProgramHost2_FWD_DEFINED__
typedef interface IDebugProgramHost2 IDebugProgramHost2;
#endif 	/* __IDebugProgramHost2_FWD_DEFINED__ */


#ifndef __IDebugProgramNode2_FWD_DEFINED__
#define __IDebugProgramNode2_FWD_DEFINED__
typedef interface IDebugProgramNode2 IDebugProgramNode2;
#endif 	/* __IDebugProgramNode2_FWD_DEFINED__ */


#ifndef __IDebugProgramEngines2_FWD_DEFINED__
#define __IDebugProgramEngines2_FWD_DEFINED__
typedef interface IDebugProgramEngines2 IDebugProgramEngines2;
#endif 	/* __IDebugProgramEngines2_FWD_DEFINED__ */


#ifndef __IDebugThread2_FWD_DEFINED__
#define __IDebugThread2_FWD_DEFINED__
typedef interface IDebugThread2 IDebugThread2;
#endif 	/* __IDebugThread2_FWD_DEFINED__ */


#ifndef __IDebugLogicalThread2_FWD_DEFINED__
#define __IDebugLogicalThread2_FWD_DEFINED__
typedef interface IDebugLogicalThread2 IDebugLogicalThread2;
#endif 	/* __IDebugLogicalThread2_FWD_DEFINED__ */


#ifndef __IDebugProperty2_FWD_DEFINED__
#define __IDebugProperty2_FWD_DEFINED__
typedef interface IDebugProperty2 IDebugProperty2;
#endif 	/* __IDebugProperty2_FWD_DEFINED__ */


#ifndef __IDebugReference2_FWD_DEFINED__
#define __IDebugReference2_FWD_DEFINED__
typedef interface IDebugReference2 IDebugReference2;
#endif 	/* __IDebugReference2_FWD_DEFINED__ */


#ifndef __IDebugStackFrame2_FWD_DEFINED__
#define __IDebugStackFrame2_FWD_DEFINED__
typedef interface IDebugStackFrame2 IDebugStackFrame2;
#endif 	/* __IDebugStackFrame2_FWD_DEFINED__ */


#ifndef __IDebugMemoryContext2_FWD_DEFINED__
#define __IDebugMemoryContext2_FWD_DEFINED__
typedef interface IDebugMemoryContext2 IDebugMemoryContext2;
#endif 	/* __IDebugMemoryContext2_FWD_DEFINED__ */


#ifndef __IDebugCodeContext2_FWD_DEFINED__
#define __IDebugCodeContext2_FWD_DEFINED__
typedef interface IDebugCodeContext2 IDebugCodeContext2;
#endif 	/* __IDebugCodeContext2_FWD_DEFINED__ */


#ifndef __IDebugMemoryBytes2_FWD_DEFINED__
#define __IDebugMemoryBytes2_FWD_DEFINED__
typedef interface IDebugMemoryBytes2 IDebugMemoryBytes2;
#endif 	/* __IDebugMemoryBytes2_FWD_DEFINED__ */


#ifndef __IDebugDisassemblyStream2_FWD_DEFINED__
#define __IDebugDisassemblyStream2_FWD_DEFINED__
typedef interface IDebugDisassemblyStream2 IDebugDisassemblyStream2;
#endif 	/* __IDebugDisassemblyStream2_FWD_DEFINED__ */


#ifndef __IDebugDocumentContext2_FWD_DEFINED__
#define __IDebugDocumentContext2_FWD_DEFINED__
typedef interface IDebugDocumentContext2 IDebugDocumentContext2;
#endif 	/* __IDebugDocumentContext2_FWD_DEFINED__ */


#ifndef __IDebugExpressionContext2_FWD_DEFINED__
#define __IDebugExpressionContext2_FWD_DEFINED__
typedef interface IDebugExpressionContext2 IDebugExpressionContext2;
#endif 	/* __IDebugExpressionContext2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointRequest2_FWD_DEFINED__
#define __IDebugBreakpointRequest2_FWD_DEFINED__
typedef interface IDebugBreakpointRequest2 IDebugBreakpointRequest2;
#endif 	/* __IDebugBreakpointRequest2_FWD_DEFINED__ */


#ifndef __IDebugBreakpointResolution2_FWD_DEFINED__
#define __IDebugBreakpointResolution2_FWD_DEFINED__
typedef interface IDebugBreakpointResolution2 IDebugBreakpointResolution2;
#endif 	/* __IDebugBreakpointResolution2_FWD_DEFINED__ */


#ifndef __IDebugErrorBreakpointResolution2_FWD_DEFINED__
#define __IDebugErrorBreakpointResolution2_FWD_DEFINED__
typedef interface IDebugErrorBreakpointResolution2 IDebugErrorBreakpointResolution2;
#endif 	/* __IDebugErrorBreakpointResolution2_FWD_DEFINED__ */


#ifndef __IDebugBoundBreakpoint2_FWD_DEFINED__
#define __IDebugBoundBreakpoint2_FWD_DEFINED__
typedef interface IDebugBoundBreakpoint2 IDebugBoundBreakpoint2;
#endif 	/* __IDebugBoundBreakpoint2_FWD_DEFINED__ */


#ifndef __IDebugPendingBreakpoint2_FWD_DEFINED__
#define __IDebugPendingBreakpoint2_FWD_DEFINED__
typedef interface IDebugPendingBreakpoint2 IDebugPendingBreakpoint2;
#endif 	/* __IDebugPendingBreakpoint2_FWD_DEFINED__ */


#ifndef __IDebugErrorBreakpoint2_FWD_DEFINED__
#define __IDebugErrorBreakpoint2_FWD_DEFINED__
typedef interface IDebugErrorBreakpoint2 IDebugErrorBreakpoint2;
#endif 	/* __IDebugErrorBreakpoint2_FWD_DEFINED__ */


#ifndef __IDebugExpression2_FWD_DEFINED__
#define __IDebugExpression2_FWD_DEFINED__
typedef interface IDebugExpression2 IDebugExpression2;
#endif 	/* __IDebugExpression2_FWD_DEFINED__ */


#ifndef __IDebugModule2_FWD_DEFINED__
#define __IDebugModule2_FWD_DEFINED__
typedef interface IDebugModule2 IDebugModule2;
#endif 	/* __IDebugModule2_FWD_DEFINED__ */


#ifndef __IDebugModuleManaged_FWD_DEFINED__
#define __IDebugModuleManaged_FWD_DEFINED__
typedef interface IDebugModuleManaged IDebugModuleManaged;
#endif 	/* __IDebugModuleManaged_FWD_DEFINED__ */


#ifndef __IDebugDocument2_FWD_DEFINED__
#define __IDebugDocument2_FWD_DEFINED__
typedef interface IDebugDocument2 IDebugDocument2;
#endif 	/* __IDebugDocument2_FWD_DEFINED__ */


#ifndef __IDebugDocumentText2_FWD_DEFINED__
#define __IDebugDocumentText2_FWD_DEFINED__
typedef interface IDebugDocumentText2 IDebugDocumentText2;
#endif 	/* __IDebugDocumentText2_FWD_DEFINED__ */


#ifndef __IDebugDocumentPosition2_FWD_DEFINED__
#define __IDebugDocumentPosition2_FWD_DEFINED__
typedef interface IDebugDocumentPosition2 IDebugDocumentPosition2;
#endif 	/* __IDebugDocumentPosition2_FWD_DEFINED__ */


#ifndef __IDebugDocumentPositionOffset2_FWD_DEFINED__
#define __IDebugDocumentPositionOffset2_FWD_DEFINED__
typedef interface IDebugDocumentPositionOffset2 IDebugDocumentPositionOffset2;
#endif 	/* __IDebugDocumentPositionOffset2_FWD_DEFINED__ */


#ifndef __IDebugFunctionPosition2_FWD_DEFINED__
#define __IDebugFunctionPosition2_FWD_DEFINED__
typedef interface IDebugFunctionPosition2 IDebugFunctionPosition2;
#endif 	/* __IDebugFunctionPosition2_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextEvents2_FWD_DEFINED__
#define __IDebugDocumentTextEvents2_FWD_DEFINED__
typedef interface IDebugDocumentTextEvents2 IDebugDocumentTextEvents2;
#endif 	/* __IDebugDocumentTextEvents2_FWD_DEFINED__ */


#ifndef __IDebugQueryEngine2_FWD_DEFINED__
#define __IDebugQueryEngine2_FWD_DEFINED__
typedef interface IDebugQueryEngine2 IDebugQueryEngine2;
#endif 	/* __IDebugQueryEngine2_FWD_DEFINED__ */


#ifndef __IEnumDebugProcesses2_FWD_DEFINED__
#define __IEnumDebugProcesses2_FWD_DEFINED__
typedef interface IEnumDebugProcesses2 IEnumDebugProcesses2;
#endif 	/* __IEnumDebugProcesses2_FWD_DEFINED__ */


#ifndef __IEnumDebugPrograms2_FWD_DEFINED__
#define __IEnumDebugPrograms2_FWD_DEFINED__
typedef interface IEnumDebugPrograms2 IEnumDebugPrograms2;
#endif 	/* __IEnumDebugPrograms2_FWD_DEFINED__ */


#ifndef __IEnumDebugThreads2_FWD_DEFINED__
#define __IEnumDebugThreads2_FWD_DEFINED__
typedef interface IEnumDebugThreads2 IEnumDebugThreads2;
#endif 	/* __IEnumDebugThreads2_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames2_FWD_DEFINED__
#define __IEnumDebugStackFrames2_FWD_DEFINED__
typedef interface IEnumDebugStackFrames2 IEnumDebugStackFrames2;
#endif 	/* __IEnumDebugStackFrames2_FWD_DEFINED__ */


#ifndef __IEnumDebugCodeContexts2_FWD_DEFINED__
#define __IEnumDebugCodeContexts2_FWD_DEFINED__
typedef interface IEnumDebugCodeContexts2 IEnumDebugCodeContexts2;
#endif 	/* __IEnumDebugCodeContexts2_FWD_DEFINED__ */


#ifndef __IEnumDebugBoundBreakpoints2_FWD_DEFINED__
#define __IEnumDebugBoundBreakpoints2_FWD_DEFINED__
typedef interface IEnumDebugBoundBreakpoints2 IEnumDebugBoundBreakpoints2;
#endif 	/* __IEnumDebugBoundBreakpoints2_FWD_DEFINED__ */


#ifndef __IEnumDebugPendingBreakpoints2_FWD_DEFINED__
#define __IEnumDebugPendingBreakpoints2_FWD_DEFINED__
typedef interface IEnumDebugPendingBreakpoints2 IEnumDebugPendingBreakpoints2;
#endif 	/* __IEnumDebugPendingBreakpoints2_FWD_DEFINED__ */


#ifndef __IEnumDebugErrorBreakpoints2_FWD_DEFINED__
#define __IEnumDebugErrorBreakpoints2_FWD_DEFINED__
typedef interface IEnumDebugErrorBreakpoints2 IEnumDebugErrorBreakpoints2;
#endif 	/* __IEnumDebugErrorBreakpoints2_FWD_DEFINED__ */


#ifndef __IEnumDebugMachines2_FWD_DEFINED__
#define __IEnumDebugMachines2_FWD_DEFINED__
typedef interface IEnumDebugMachines2 IEnumDebugMachines2;
#endif 	/* __IEnumDebugMachines2_FWD_DEFINED__ */


#ifndef __IEnumDebugExceptionInfo2_FWD_DEFINED__
#define __IEnumDebugExceptionInfo2_FWD_DEFINED__
typedef interface IEnumDebugExceptionInfo2 IEnumDebugExceptionInfo2;
#endif 	/* __IEnumDebugExceptionInfo2_FWD_DEFINED__ */


#ifndef __IEnumDebugFrameInfo2_FWD_DEFINED__
#define __IEnumDebugFrameInfo2_FWD_DEFINED__
typedef interface IEnumDebugFrameInfo2 IEnumDebugFrameInfo2;
#endif 	/* __IEnumDebugFrameInfo2_FWD_DEFINED__ */


#ifndef __IEnumCodePaths2_FWD_DEFINED__
#define __IEnumCodePaths2_FWD_DEFINED__
typedef interface IEnumCodePaths2 IEnumCodePaths2;
#endif 	/* __IEnumCodePaths2_FWD_DEFINED__ */


#ifndef __IEnumDebugModules2_FWD_DEFINED__
#define __IEnumDebugModules2_FWD_DEFINED__
typedef interface IEnumDebugModules2 IEnumDebugModules2;
#endif 	/* __IEnumDebugModules2_FWD_DEFINED__ */


#ifndef __IEnumDebugPortSuppliers2_FWD_DEFINED__
#define __IEnumDebugPortSuppliers2_FWD_DEFINED__
typedef interface IEnumDebugPortSuppliers2 IEnumDebugPortSuppliers2;
#endif 	/* __IEnumDebugPortSuppliers2_FWD_DEFINED__ */


#ifndef __IEnumDebugPorts2_FWD_DEFINED__
#define __IEnumDebugPorts2_FWD_DEFINED__
typedef interface IEnumDebugPorts2 IEnumDebugPorts2;
#endif 	/* __IEnumDebugPorts2_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo2_FWD_DEFINED__
#define __IEnumDebugPropertyInfo2_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo2 IEnumDebugPropertyInfo2;
#endif 	/* __IEnumDebugPropertyInfo2_FWD_DEFINED__ */


#ifndef __IEnumDebugReferenceInfo2_FWD_DEFINED__
#define __IEnumDebugReferenceInfo2_FWD_DEFINED__
typedef interface IEnumDebugReferenceInfo2 IEnumDebugReferenceInfo2;
#endif 	/* __IEnumDebugReferenceInfo2_FWD_DEFINED__ */


#ifndef __SDMServer_FWD_DEFINED__
#define __SDMServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SDMServer SDMServer;
#else
typedef struct SDMServer SDMServer;
#endif /* __cplusplus */

#endif 	/* __SDMServer_FWD_DEFINED__ */


#ifndef __MsMachineDebugManager_FWD_DEFINED__
#define __MsMachineDebugManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsMachineDebugManager MsMachineDebugManager;
#else
typedef struct MsMachineDebugManager MsMachineDebugManager;
#endif /* __cplusplus */

#endif 	/* __MsMachineDebugManager_FWD_DEFINED__ */


#ifndef __MDMUtilServer_FWD_DEFINED__
#define __MDMUtilServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class MDMUtilServer MDMUtilServer;
#else
typedef struct MDMUtilServer MDMUtilServer;
#endif /* __cplusplus */

#endif 	/* __MDMUtilServer_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "enc.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msdbg_0000 */
/* [local] */ 

#ifndef _BASETSD_H_
#pragma once
typedef signed char INT8;

typedef signed char *PINT8;

typedef short INT16;

typedef short *PINT16;

typedef int INT32;

typedef int *PINT32;

typedef __int64 INT64;

typedef __int64 *PINT64;

typedef unsigned char UINT8;

typedef unsigned char *PUINT8;

typedef unsigned short UINT16;

typedef unsigned short *PUINT16;

typedef unsigned int UINT32;

typedef unsigned int *PUINT32;

typedef unsigned __int64 UINT64;

typedef unsigned __int64 *PUINT64;

typedef int LONG32;

typedef int *PLONG32;

typedef unsigned int ULONG32;

typedef unsigned int *PULONG32;

typedef unsigned int DWORD32;

typedef unsigned int *PDWORD32;

typedef /* [public] */ __int3264 INT_PTR;

typedef /* [public] */ __int3264 *PINT_PTR;

typedef /* [public] */ unsigned __int3264 UINT_PTR;

typedef /* [public] */ unsigned __int3264 *PUINT_PTR;

typedef /* [public] */ __int3264 LONG_PTR;

typedef /* [public] */ __int3264 *PLONG_PTR;

typedef /* [public] */ unsigned __int3264 ULONG_PTR;

typedef /* [public] */ unsigned __int3264 *PULONG_PTR;

typedef unsigned short UHALF_PTR;

typedef unsigned short *PUHALF_PTR;

typedef short HALF_PTR;

typedef short *PHALF_PTR;

typedef long SHANDLE_PTR;

typedef unsigned long HANDLE_PTR;

typedef ULONG_PTR SIZE_T;

typedef ULONG_PTR *PSIZE_T;

typedef LONG_PTR SSIZE_T;

typedef LONG_PTR *PSSIZE_T;

typedef ULONG_PTR DWORD_PTR;

typedef ULONG_PTR *PDWORD_PTR;

typedef __int64 LONG64;

typedef __int64 *PLONG64;

typedef unsigned __int64 ULONG64;

typedef unsigned __int64 *PULONG64;

typedef unsigned __int64 DWORD64;

typedef unsigned __int64 *PDWORD64;

typedef ULONG_PTR KAFFINITY;

typedef KAFFINITY *PKAFFINITY;

#endif // _BASETSD_H_
#define	MSDBG_VERSION	( 7126 )

#define E_ATTACH_DEBUGGER_ALREADY_ATTACHED						MAKE_HRESULT(1, FACILITY_ITF, 0x0001)
#define E_ATTACH_DEBUGGEE_PROCESS_SECURITY_VIOLATION				MAKE_HRESULT(1, FACILITY_ITF, 0x0002)
#define E_ATTACH_CANNOT_ATTACH_TO_DESKTOP						MAKE_HRESULT(1, FACILITY_ITF, 0x0003)
#define S_ATTACH_DEFERRED										MAKE_HRESULT(0, FACILITY_ITF, 0x0004)
#define E_LAUNCH_NO_INTEROP                                      MAKE_HRESULT(1, FACILITY_ITF, 0x0005)
#define E_LAUNCH_DEBUGGING_NOT_POSSIBLE                          MAKE_HRESULT(1, FACILITY_ITF, 0x0006)
#define E_LAUNCH_KERNEL_DEBUGGER_ENABLED                         MAKE_HRESULT(1, FACILITY_ITF, 0x0007)
#define E_LAUNCH_KERNEL_DEBUGGER_PRESENT                         MAKE_HRESULT(1, FACILITY_ITF, 0x0008)
#define E_INTEROP_NOT_SUPPORTED                                  MAKE_HRESULT(1, FACILITY_ITF, 0x0009)
#define E_TOO_MANY_PROCESSES                                     MAKE_HRESULT(1, FACILITY_ITF, 0x000A)
#define E_MACHINE_NOT_AVAILABLE									MAKE_HRESULT(1, FACILITY_ITF, 0x0010)
#define E_MACHINE_DOES_NOT_EXIST									MAKE_HRESULT(1, FACILITY_ITF, 0x0020)
#define E_MACHINE_ACCESS_DENIED									MAKE_HRESULT(1, FACILITY_ITF, 0x0021)
#define E_MACHINE_MDM_EXEC_FAILURE								MAKE_HRESULT(1, FACILITY_ITF, 0x0022)
#define E_MACHINE_DEBUGGER_NOT_REGISTERED_PROPERLY				MAKE_HRESULT(1, FACILITY_ITF, 0x0023)
#define E_EVALUATE_BUSY_WITH_EVALUATION							MAKE_HRESULT(1, FACILITY_ITF, 0x0030)
#define E_EVALUATE_TIMEOUT										MAKE_HRESULT(1, FACILITY_ITF, 0x0031)
#define E_MEMORY_NOTSUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0040)
#define E_DISASM_NOTSUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0041)
#define E_DISASM_BADADDRESS                                      MAKE_HRESULT(1, FACILITY_ITF, 0x0042)
#define E_DISASM_NOTAVAILABLE                                    MAKE_HRESULT(1, FACILITY_ITF, 0x0043)
#define E_BP_DELETED												MAKE_HRESULT(1, FACILITY_ITF, 0x0060)
#define E_PROCESS_DESTROYED										MAKE_HRESULT(1, FACILITY_ITF, 0x0070)
#define E_PROCESS_DEBUGGER_IS_DEBUGGEE							MAKE_HRESULT(1, FACILITY_ITF, 0x0071)
#define E_PORTSUPPLIER_NO_PORT									MAKE_HRESULT(1, FACILITY_ITF, 0x0080)
#define E_PORT_NO_REQUEST										MAKE_HRESULT(1, FACILITY_ITF, 0x0090)
#define E_COMPARE_CANNOT_COMPARE									MAKE_HRESULT(1, FACILITY_ITF, 0x00a0)
#define S_JIT_USERCANCELLED										MAKE_HRESULT(0, FACILITY_ITF, 0x00b0)
#define E_JIT_INVALID_PID										MAKE_HRESULT(1, FACILITY_ITF, 0x00b1)
#define E_JIT_REMOTE_FAILED										MAKE_HRESULT(0, FACILITY_ITF, 0x00b2)
#define S_TERMINATE_PROCESSES_STILL_DETACHING					MAKE_HRESULT(0, FACILITY_ITF, 0x00c0)
#define E_DETACH_NO_PROXY								        MAKE_HRESULT(1, FACILITY_ITF, 0x00d0)
#define E_DETACH_TS_UNSUPPORTED						            MAKE_HRESULT(1, FACILITY_ITF, 0x00e0)
#define E_DETACH_IMPERSONATE_FAILURE						        MAKE_HRESULT(1, FACILITY_ITF, 0x00f0)
#define E_CANNOT_SET_NEXT_STATEMENT_ON_NONLEAF_FRAME				MAKE_HRESULT(1, FACILITY_ITF, 0x0100)
#define E_CANNOT_SETIP_TO_DIFFERENT_FUNCTION                     MAKE_HRESULT(1, FACILITY_ITF, 0x0104)
#define E_CANNOT_SET_NEXT_STATEMENT_ON_EXCEPTION                 MAKE_HRESULT(1, FACILITY_ITF, 0x0105)
#define E_CANNOT_DEBUG_MDM										MAKE_HRESULT(1, FACILITY_ITF, 0x0110)
#define E_TARGET_FILE_MISSING									MAKE_HRESULT(1, FACILITY_ITF, 0x0100)
#define E_TARGET_FILE_MISMATCH									MAKE_HRESULT(1, FACILITY_ITF, 0x0101)
#define E_IMAGE_NOT_LOADED										MAKE_HRESULT(1, FACILITY_ITF, 0x0102)
#define E_FIBER_NOT_SUPPORTED									MAKE_HRESULT(1, FACILITY_ITF, 0x0103)
#define E_ASYNCBREAK_NO_PROGRAMS									MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0110)
#define E_ASYNCBREAK_DEBUGGEE_NOT_INITIALIZED					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0111)
#define E_CANNOT_GET_UNMANAGED_MEMORY_CONTEXT					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0561)
#define E_DESTROYED												MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 1)
#define E_REMOTE_NOMSVCMON										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 2)
#define E_REMOTE_BADIPADDRESS									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 3)
#define E_REMOTE_MACHINEDOWN										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 4)
#define E_REMOTE_MACHINEUNSPECIFIED								MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 5)
#define E_CRASHDUMP_ACTIVE										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 6)
#define E_ALL_THREADS_SUSPENDED									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 7)
#define E_LOAD_DLL_TL											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 8)
#define E_LOAD_DLL_SH											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 9)
#define E_LOAD_DLL_EM											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 10)
#define E_LOAD_DLL_EE											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 11)
#define E_LOAD_DLL_DM											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 12)
#define E_LOAD_DLL_MD											MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 13)
#define E_IOREDIR_BADFILE										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 14)
#define E_IOREDIR_BADSYNTAX										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 15)
#define E_REMOTE_BADVERSION										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 16)
#define E_CRASHDUMP_UNSUPPORTED									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 17)
#define E_UNSUPPORTED_BINARY										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 21)
#define E_DEBUGGEE_BLOCKED										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 22)
#define E_REMOTE_NOUSERMSVCMON									MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 23)
#define E_STEP_WIN9xSYSCODE                                      MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 24)
#define E_INTEROP_ORPC_INIT 										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 25)
#define E_CANNOT_DEBUG_WIN32										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 27)
#define E_CANNOT_DEBUG_WIN64										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 28)
#define E_MINIDUMP_READ_WIN9X                                    MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 29)
#define E_CROSS_TSSESSION_ATTACH 								MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 30)
#define E_STEP_BP_SET_FAILED										MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, 0x200 + 31)
#define E_REFERENCE_NOT_VALID									MAKE_HRESULT(1, FACILITY_ITF, 0x0501)
#define E_PROPERTY_NOT_VALID										MAKE_HRESULT(1, FACILITY_ITF, 0x0511)
#define E_SETVALUE_VALUE_CANNOT_BE_SET							MAKE_HRESULT(1, FACILITY_ITF, 0x0521)
#define E_SETVALUE_VALUE_IS_READONLY								MAKE_HRESULT(1, FACILITY_ITF, 0x0522)
#define E_SETVALUEASREFERENCE_NOTSUPPORTED						MAKE_HRESULT(1, FACILITY_ITF, 0x0523)
#define S_GETPARENT_NO_PARENT									MAKE_HRESULT(0, FACILITY_ITF, 0x0531)
#define S_GETDERIVEDMOST_NO_DERIVED_MOST							MAKE_HRESULT(0, FACILITY_ITF, 0x0541)
#define S_GETMEMORYBYTES_NO_MEMORY_BYTES							MAKE_HRESULT(0, FACILITY_ITF, 0x0551)
#define S_GETMEMORYCONTEXT_NO_MEMORY_CONTEXT						MAKE_HRESULT(0, FACILITY_ITF, 0x0561)
#define S_GETSIZE_NO_SIZE										MAKE_HRESULT(0, FACILITY_ITF, 0x0571)
#define E_GETREFERENCE_NO_REFERENCE								MAKE_HRESULT(1, FACILITY_ITF, 0x0581)
#define S_GETEXTENDEDINFO_NO_EXTENDEDINFO						MAKE_HRESULT(0, FACILITY_ITF, 0x0591)
#define E_CODE_CONTEXT_OUT_OF_SCOPE								MAKE_HRESULT(1, FACILITY_ITF, 0x05A1)
#define E_INVALID_SESSIONID										MAKE_HRESULT(1, FACILITY_ITF, 0x05A2)
#define E_SERVER_UNAVAILABLE_ON_CALLBACK							MAKE_HRESULT(1, FACILITY_ITF, 0x05A3)
#define E_ACCESS_DENIED_ON_CALLBACK								MAKE_HRESULT(1, FACILITY_ITF, 0x05A4)
#define E_UNKNOWN_AUTHN_SERVICE_ON_CALLBACK						MAKE_HRESULT(1, FACILITY_ITF, 0x05A5)
#define E_NO_SESSION_AVAILABLE									MAKE_HRESULT(1, FACILITY_ITF, 0x05A6)
#define E_CLIENT_NOT_LOGGED_ON                                   MAKE_HRESULT(1, FACILITY_ITF, 0x05A7)
#define E_OTHER_USERS_SESSION                                    MAKE_HRESULT(1, FACILITY_ITF, 0x05A8)
#define E_USER_LEVEL_ACCESS_CONTROL_REQUIRED                     MAKE_HRESULT(1, FACILITY_ITF, 0x05A9)
#define E_SCRIPT_CLR_EE_DISABLED                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x5B0)
#define E_HTTP_SERVERERROR										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x700)
#define E_HTTP_PERMISSION_DENIED									MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x701)
#define E_HTTP_SENDREQUEST_FAILED								MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x702)
#define E_HTTP_FORBIDDEN											MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x703)
#define E_HTTP_NOT_SUPPORTED										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x704)
#define E_HTTP_NO_CONTENT										MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x705)
#define E_FUNCTION_NOT_JITTED                                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x800)
#define E_NO_CODE_CONTEXT                                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x801)
#define E_AUTOATTACH_ACCESS_DENIED                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x900)
#define E_AUTOATTACH_WEBSERVER_NOT_FOUND                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x901)





















































extern GUID guidVBLang;
extern GUID guidVBScriptLang;
extern GUID guidJScriptLang;
extern GUID guidCLang;
extern GUID guidCPPLang;
extern GUID guidSQLLang;
extern GUID guidScriptLang;
extern GUID guidSafeCLang;
extern GUID guidManagedCLang;
extern GUID guidManagedCPPLang;
extern GUID guidScriptEng;
extern GUID guidSQLEng;
extern GUID guidCOMPlusNativeEng;
extern GUID guidCOMPlusOnlyEng;
extern GUID guidNativeOnlyEng;
extern GUID guidMsOrclEng;
extern GUID guidEmbeddedCLREng;
extern GUID guidMicrosoftVendor;
extern GUID guidLocalPortSupplier;
extern GUID guidNativePortSupplier;
extern GUID guidEmbeddedCLRPortSupplier;
extern GUID guidFilterLocals;
extern GUID guidFilterAllLocals;
extern GUID guidFilterArgs;
extern GUID guidFilterLocalsPlusArgs;
extern GUID guidFilterAllLocalsPlusArgs;
extern GUID guidFilterRegisters;
extern GUID guidFilterThis;
// GUIDs for GetExtendedInfo
extern GUID guidDocument;
extern GUID guidCodeContext;
extern GUID guidExtendedInfoSlot;
extern GUID guidExtendedInfoSignature;

enum __MIDL___MIDL_itf_msdbg_0000_0001
    {	GN_NAME	= 0,
	GN_FILENAME	= GN_NAME + 1,
	GN_BASENAME	= GN_FILENAME + 1,
	GN_MONIKERNAME	= GN_BASENAME + 1,
	GN_URL	= GN_MONIKERNAME + 1,
	GN_TITLE	= GN_URL + 1,
	GN_STARTPAGEURL	= GN_TITLE + 1
    } ;
typedef DWORD GETNAME_TYPE;


enum __MIDL___MIDL_itf_msdbg_0000_0002
    {	TEXT_POSITION_MAX_LINE	= 0xffffffff,
	TEXT_POSITION_MAX_COLUMN	= 0xffffffff
    } ;
typedef struct _tagTEXT_POSITION
    {
    DWORD dwLine;
    DWORD dwColumn;
    } 	TEXT_POSITION;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0000_v0_0_s_ifspec;

#ifndef __IDebugMachine2_INTERFACE_DEFINED__
#define __IDebugMachine2_INTERFACE_DEFINED__

/* interface IDebugMachine2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugMachine2_0003
    {	MCIFLAG_TERMINAL_SERVICES_AVAILABLE	= 0x1
    } ;
typedef DWORD MACHINE_INFO_FLAGS;


enum __MIDL_IDebugMachine2_0004
    {	MCIF_NAME	= 0x1,
	MCIF_FLAGS	= 0x2,
	MCIF_ALL	= 0x3
    } ;
typedef DWORD MACHINE_INFO_FIELDS;

typedef struct tagMACHINE_INFO
    {
    MACHINE_INFO_FIELDS Fields;
    BSTR bstrName;
    MACHINE_INFO_FLAGS Flags;
    } 	MACHINE_INFO;


EXTERN_C const IID IID_IDebugMachine2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17bf8fa3-4c5a-49a3-b2f8-5942e1ea287e")
    IDebugMachine2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ MACHINE_INFO_FIELDS Fields,
            /* [out] */ MACHINE_INFO *pMachineInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortSupplier( 
            /* [in] */ REFGUID guidPortSupplier,
            /* [out] */ IDebugPortSupplier2 **ppPortSupplier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPorts( 
            /* [out] */ IEnumDebugPorts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortSuppliers( 
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMachineUtilities( 
            /* [out] */ IDebugMDMUtil2 **ppUtil) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMachine2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMachine2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMachine2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMachine2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugMachine2 * This,
            /* [in] */ MACHINE_INFO_FIELDS Fields,
            /* [out] */ MACHINE_INFO *pMachineInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugMachine2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortSupplier )( 
            IDebugMachine2 * This,
            /* [in] */ REFGUID guidPortSupplier,
            /* [out] */ IDebugPortSupplier2 **ppPortSupplier);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IDebugMachine2 * This,
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPorts )( 
            IDebugMachine2 * This,
            /* [out] */ IEnumDebugPorts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortSuppliers )( 
            IDebugMachine2 * This,
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineUtilities )( 
            IDebugMachine2 * This,
            /* [out] */ IDebugMDMUtil2 **ppUtil);
        
        END_INTERFACE
    } IDebugMachine2Vtbl;

    interface IDebugMachine2
    {
        CONST_VTBL struct IDebugMachine2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMachine2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMachine2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMachine2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMachine2_GetInfo(This,Fields,pMachineInfo)	\
    (This)->lpVtbl -> GetInfo(This,Fields,pMachineInfo)

#define IDebugMachine2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugMachine2_GetPortSupplier(This,guidPortSupplier,ppPortSupplier)	\
    (This)->lpVtbl -> GetPortSupplier(This,guidPortSupplier,ppPortSupplier)

#define IDebugMachine2_GetPort(This,guidPort,ppPort)	\
    (This)->lpVtbl -> GetPort(This,guidPort,ppPort)

#define IDebugMachine2_EnumPorts(This,ppEnum)	\
    (This)->lpVtbl -> EnumPorts(This,ppEnum)

#define IDebugMachine2_EnumPortSuppliers(This,ppEnum)	\
    (This)->lpVtbl -> EnumPortSuppliers(This,ppEnum)

#define IDebugMachine2_GetMachineUtilities(This,ppUtil)	\
    (This)->lpVtbl -> GetMachineUtilities(This,ppUtil)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMachine2_GetInfo_Proxy( 
    IDebugMachine2 * This,
    /* [in] */ MACHINE_INFO_FIELDS Fields,
    /* [out] */ MACHINE_INFO *pMachineInfo);


void __RPC_STUB IDebugMachine2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_GetName_Proxy( 
    IDebugMachine2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugMachine2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_GetPortSupplier_Proxy( 
    IDebugMachine2 * This,
    /* [in] */ REFGUID guidPortSupplier,
    /* [out] */ IDebugPortSupplier2 **ppPortSupplier);


void __RPC_STUB IDebugMachine2_GetPortSupplier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_GetPort_Proxy( 
    IDebugMachine2 * This,
    /* [in] */ REFGUID guidPort,
    /* [out] */ IDebugPort2 **ppPort);


void __RPC_STUB IDebugMachine2_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_EnumPorts_Proxy( 
    IDebugMachine2 * This,
    /* [out] */ IEnumDebugPorts2 **ppEnum);


void __RPC_STUB IDebugMachine2_EnumPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_EnumPortSuppliers_Proxy( 
    IDebugMachine2 * This,
    /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);


void __RPC_STUB IDebugMachine2_EnumPortSuppliers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachine2_GetMachineUtilities_Proxy( 
    IDebugMachine2 * This,
    /* [out] */ IDebugMDMUtil2 **ppUtil);


void __RPC_STUB IDebugMachine2_GetMachineUtilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMachine2_INTERFACE_DEFINED__ */


#ifndef __IDebugMachineEx2_INTERFACE_DEFINED__
#define __IDebugMachineEx2_INTERFACE_DEFINED__

/* interface IDebugMachineEx2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugMachineEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae27b230-a0bf-47ff-a2d1-22c29a178eac")
    IDebugMachineEx2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableAutoAttachOnProgramCreate( 
            /* [in] */ LPCWSTR pszProcessNames,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ LPCWSTR pszSessionId,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAutoAttachOnEvent( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortSupplierEx( 
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [in] */ REFGUID guidPortSupplier,
            /* [out] */ IDebugPortSupplier2 **ppPortSupplier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortEx( 
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortsEx( 
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [out] */ IEnumDebugPorts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPortSuppliersEx( 
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMachineEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMachineEx2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMachineEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMachineEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableAutoAttachOnProgramCreate )( 
            IDebugMachineEx2 * This,
            /* [in] */ LPCWSTR pszProcessNames,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ LPCWSTR pszSessionId,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *DisableAutoAttachOnEvent )( 
            IDebugMachineEx2 * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortSupplierEx )( 
            IDebugMachineEx2 * This,
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [in] */ REFGUID guidPortSupplier,
            /* [out] */ IDebugPortSupplier2 **ppPortSupplier);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortEx )( 
            IDebugMachineEx2 * This,
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortsEx )( 
            IDebugMachineEx2 * This,
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [out] */ IEnumDebugPorts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPortSuppliersEx )( 
            IDebugMachineEx2 * This,
            /* [in] */ LPCOLESTR wstrRegistryRoot,
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);
        
        END_INTERFACE
    } IDebugMachineEx2Vtbl;

    interface IDebugMachineEx2
    {
        CONST_VTBL struct IDebugMachineEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMachineEx2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMachineEx2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMachineEx2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMachineEx2_EnableAutoAttachOnProgramCreate(This,pszProcessNames,guidEngine,pszSessionId,pdwCookie)	\
    (This)->lpVtbl -> EnableAutoAttachOnProgramCreate(This,pszProcessNames,guidEngine,pszSessionId,pdwCookie)

#define IDebugMachineEx2_DisableAutoAttachOnEvent(This,dwCookie)	\
    (This)->lpVtbl -> DisableAutoAttachOnEvent(This,dwCookie)

#define IDebugMachineEx2_GetPortSupplierEx(This,wstrRegistryRoot,guidPortSupplier,ppPortSupplier)	\
    (This)->lpVtbl -> GetPortSupplierEx(This,wstrRegistryRoot,guidPortSupplier,ppPortSupplier)

#define IDebugMachineEx2_GetPortEx(This,wstrRegistryRoot,guidPort,ppPort)	\
    (This)->lpVtbl -> GetPortEx(This,wstrRegistryRoot,guidPort,ppPort)

#define IDebugMachineEx2_EnumPortsEx(This,wstrRegistryRoot,ppEnum)	\
    (This)->lpVtbl -> EnumPortsEx(This,wstrRegistryRoot,ppEnum)

#define IDebugMachineEx2_EnumPortSuppliersEx(This,wstrRegistryRoot,ppEnum)	\
    (This)->lpVtbl -> EnumPortSuppliersEx(This,wstrRegistryRoot,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMachineEx2_EnableAutoAttachOnProgramCreate_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ LPCWSTR pszProcessNames,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ LPCWSTR pszSessionId,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IDebugMachineEx2_EnableAutoAttachOnProgramCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachineEx2_DisableAutoAttachOnEvent_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IDebugMachineEx2_DisableAutoAttachOnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachineEx2_GetPortSupplierEx_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ LPCOLESTR wstrRegistryRoot,
    /* [in] */ REFGUID guidPortSupplier,
    /* [out] */ IDebugPortSupplier2 **ppPortSupplier);


void __RPC_STUB IDebugMachineEx2_GetPortSupplierEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachineEx2_GetPortEx_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ LPCOLESTR wstrRegistryRoot,
    /* [in] */ REFGUID guidPort,
    /* [out] */ IDebugPort2 **ppPort);


void __RPC_STUB IDebugMachineEx2_GetPortEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachineEx2_EnumPortsEx_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ LPCOLESTR wstrRegistryRoot,
    /* [out] */ IEnumDebugPorts2 **ppEnum);


void __RPC_STUB IDebugMachineEx2_EnumPortsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMachineEx2_EnumPortSuppliersEx_Proxy( 
    IDebugMachineEx2 * This,
    /* [in] */ LPCOLESTR wstrRegistryRoot,
    /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);


void __RPC_STUB IDebugMachineEx2_EnumPortSuppliersEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMachineEx2_INTERFACE_DEFINED__ */


#ifndef __IDebugPortSupplier2_INTERFACE_DEFINED__
#define __IDebugPortSupplier2_INTERFACE_DEFINED__

/* interface IDebugPortSupplier2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPortSupplier2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53f68191-7b2f-4f14-8e55-40b1b6e5df66")
    IDebugPortSupplier2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPortSupplierName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortSupplierId( 
            /* [out] */ GUID *pguidPortSupplier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPorts( 
            /* [out] */ IEnumDebugPorts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanAddPort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPort( 
            /* [in] */ IDebugPortRequest2 *pRequest,
            /* [out] */ IDebugPort2 **ppPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePort( 
            /* [in] */ IDebugPort2 *pPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPortSupplier2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPortSupplier2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPortSupplier2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPortSupplier2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortSupplierName )( 
            IDebugPortSupplier2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortSupplierId )( 
            IDebugPortSupplier2 * This,
            /* [out] */ GUID *pguidPortSupplier);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IDebugPortSupplier2 * This,
            /* [in] */ REFGUID guidPort,
            /* [out] */ IDebugPort2 **ppPort);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPorts )( 
            IDebugPortSupplier2 * This,
            /* [out] */ IEnumDebugPorts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CanAddPort )( 
            IDebugPortSupplier2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPort )( 
            IDebugPortSupplier2 * This,
            /* [in] */ IDebugPortRequest2 *pRequest,
            /* [out] */ IDebugPort2 **ppPort);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePort )( 
            IDebugPortSupplier2 * This,
            /* [in] */ IDebugPort2 *pPort);
        
        END_INTERFACE
    } IDebugPortSupplier2Vtbl;

    interface IDebugPortSupplier2
    {
        CONST_VTBL struct IDebugPortSupplier2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPortSupplier2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPortSupplier2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPortSupplier2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPortSupplier2_GetPortSupplierName(This,pbstrName)	\
    (This)->lpVtbl -> GetPortSupplierName(This,pbstrName)

#define IDebugPortSupplier2_GetPortSupplierId(This,pguidPortSupplier)	\
    (This)->lpVtbl -> GetPortSupplierId(This,pguidPortSupplier)

#define IDebugPortSupplier2_GetPort(This,guidPort,ppPort)	\
    (This)->lpVtbl -> GetPort(This,guidPort,ppPort)

#define IDebugPortSupplier2_EnumPorts(This,ppEnum)	\
    (This)->lpVtbl -> EnumPorts(This,ppEnum)

#define IDebugPortSupplier2_CanAddPort(This)	\
    (This)->lpVtbl -> CanAddPort(This)

#define IDebugPortSupplier2_AddPort(This,pRequest,ppPort)	\
    (This)->lpVtbl -> AddPort(This,pRequest,ppPort)

#define IDebugPortSupplier2_RemovePort(This,pPort)	\
    (This)->lpVtbl -> RemovePort(This,pPort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_GetPortSupplierName_Proxy( 
    IDebugPortSupplier2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugPortSupplier2_GetPortSupplierName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_GetPortSupplierId_Proxy( 
    IDebugPortSupplier2 * This,
    /* [out] */ GUID *pguidPortSupplier);


void __RPC_STUB IDebugPortSupplier2_GetPortSupplierId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_GetPort_Proxy( 
    IDebugPortSupplier2 * This,
    /* [in] */ REFGUID guidPort,
    /* [out] */ IDebugPort2 **ppPort);


void __RPC_STUB IDebugPortSupplier2_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_EnumPorts_Proxy( 
    IDebugPortSupplier2 * This,
    /* [out] */ IEnumDebugPorts2 **ppEnum);


void __RPC_STUB IDebugPortSupplier2_EnumPorts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_CanAddPort_Proxy( 
    IDebugPortSupplier2 * This);


void __RPC_STUB IDebugPortSupplier2_CanAddPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_AddPort_Proxy( 
    IDebugPortSupplier2 * This,
    /* [in] */ IDebugPortRequest2 *pRequest,
    /* [out] */ IDebugPort2 **ppPort);


void __RPC_STUB IDebugPortSupplier2_AddPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortSupplier2_RemovePort_Proxy( 
    IDebugPortSupplier2 * This,
    /* [in] */ IDebugPort2 *pPort);


void __RPC_STUB IDebugPortSupplier2_RemovePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPortSupplier2_INTERFACE_DEFINED__ */


#ifndef __IDebugPort2_INTERFACE_DEFINED__
#define __IDebugPort2_INTERFACE_DEFINED__

/* interface IDebugPort2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugPort2_0001
    {	AD_PROCESS_ID_SYSTEM	= 0,
	AD_PROCESS_ID_GUID	= AD_PROCESS_ID_SYSTEM + 1
    } ;
typedef DWORD AD_PROCESS_ID_TYPE;

typedef struct _AD_PROCESS_ID
    {
    AD_PROCESS_ID_TYPE ProcessIdType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IDebugPort2_0002
        {
        /* [case()] */ DWORD dwProcessId;
        /* [case()] */ GUID guidProcessId;
        /* [default] */ DWORD dwUnused;
        } 	ProcessId;
    } 	AD_PROCESS_ID;


EXTERN_C const IID IID_IDebugPort2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79293cc8-d9d9-43f5-97ad-0bcc5a688776")
    IDebugPort2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPortName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortId( 
            /* [out] */ GUID *pguidPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortRequest( 
            /* [out] */ IDebugPortRequest2 **ppRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPortSupplier( 
            /* [out] */ IDebugPortSupplier2 **ppSupplier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ AD_PROCESS_ID ProcessId,
            /* [out] */ IDebugProcess2 **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProcesses( 
            /* [out] */ IEnumDebugProcesses2 **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPort2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPort2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPort2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPort2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortName )( 
            IDebugPort2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortId )( 
            IDebugPort2 * This,
            /* [out] */ GUID *pguidPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortRequest )( 
            IDebugPort2 * This,
            /* [out] */ IDebugPortRequest2 **ppRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortSupplier )( 
            IDebugPort2 * This,
            /* [out] */ IDebugPortSupplier2 **ppSupplier);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IDebugPort2 * This,
            /* [in] */ AD_PROCESS_ID ProcessId,
            /* [out] */ IDebugProcess2 **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProcesses )( 
            IDebugPort2 * This,
            /* [out] */ IEnumDebugProcesses2 **ppEnum);
        
        END_INTERFACE
    } IDebugPort2Vtbl;

    interface IDebugPort2
    {
        CONST_VTBL struct IDebugPort2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPort2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPort2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPort2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPort2_GetPortName(This,pbstrName)	\
    (This)->lpVtbl -> GetPortName(This,pbstrName)

#define IDebugPort2_GetPortId(This,pguidPort)	\
    (This)->lpVtbl -> GetPortId(This,pguidPort)

#define IDebugPort2_GetPortRequest(This,ppRequest)	\
    (This)->lpVtbl -> GetPortRequest(This,ppRequest)

#define IDebugPort2_GetPortSupplier(This,ppSupplier)	\
    (This)->lpVtbl -> GetPortSupplier(This,ppSupplier)

#define IDebugPort2_GetProcess(This,ProcessId,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ProcessId,ppProcess)

#define IDebugPort2_EnumProcesses(This,ppEnum)	\
    (This)->lpVtbl -> EnumProcesses(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPort2_GetPortName_Proxy( 
    IDebugPort2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugPort2_GetPortName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPort2_GetPortId_Proxy( 
    IDebugPort2 * This,
    /* [out] */ GUID *pguidPort);


void __RPC_STUB IDebugPort2_GetPortId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPort2_GetPortRequest_Proxy( 
    IDebugPort2 * This,
    /* [out] */ IDebugPortRequest2 **ppRequest);


void __RPC_STUB IDebugPort2_GetPortRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPort2_GetPortSupplier_Proxy( 
    IDebugPort2 * This,
    /* [out] */ IDebugPortSupplier2 **ppSupplier);


void __RPC_STUB IDebugPort2_GetPortSupplier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPort2_GetProcess_Proxy( 
    IDebugPort2 * This,
    /* [in] */ AD_PROCESS_ID ProcessId,
    /* [out] */ IDebugProcess2 **ppProcess);


void __RPC_STUB IDebugPort2_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPort2_EnumProcesses_Proxy( 
    IDebugPort2 * This,
    /* [out] */ IEnumDebugProcesses2 **ppEnum);


void __RPC_STUB IDebugPort2_EnumProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPort2_INTERFACE_DEFINED__ */


#ifndef __IDebugPortRequest2_INTERFACE_DEFINED__
#define __IDebugPortRequest2_INTERFACE_DEFINED__

/* interface IDebugPortRequest2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPortRequest2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d36beb8-9bfe-47dd-a11b-7ba1de18e449")
    IDebugPortRequest2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPortName( 
            /* [out] */ BSTR *pbstrPortName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPortRequest2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPortRequest2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPortRequest2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPortRequest2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPortName )( 
            IDebugPortRequest2 * This,
            /* [out] */ BSTR *pbstrPortName);
        
        END_INTERFACE
    } IDebugPortRequest2Vtbl;

    interface IDebugPortRequest2
    {
        CONST_VTBL struct IDebugPortRequest2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPortRequest2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPortRequest2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPortRequest2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPortRequest2_GetPortName(This,pbstrPortName)	\
    (This)->lpVtbl -> GetPortName(This,pbstrPortName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPortRequest2_GetPortName_Proxy( 
    IDebugPortRequest2 * This,
    /* [out] */ BSTR *pbstrPortName);


void __RPC_STUB IDebugPortRequest2_GetPortName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPortRequest2_INTERFACE_DEFINED__ */


#ifndef __IDebugPortNotify2_INTERFACE_DEFINED__
#define __IDebugPortNotify2_INTERFACE_DEFINED__

/* interface IDebugPortNotify2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPortNotify2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb8d2032-2858-414c-83d9-f732664e0c7a")
    IDebugPortNotify2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProgramNode( 
            /* [in] */ IDebugProgramNode2 *pProgramNode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProgramNode( 
            /* [in] */ IDebugProgramNode2 *pProgramNode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPortNotify2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPortNotify2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPortNotify2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPortNotify2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddProgramNode )( 
            IDebugPortNotify2 * This,
            /* [in] */ IDebugProgramNode2 *pProgramNode);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProgramNode )( 
            IDebugPortNotify2 * This,
            /* [in] */ IDebugProgramNode2 *pProgramNode);
        
        END_INTERFACE
    } IDebugPortNotify2Vtbl;

    interface IDebugPortNotify2
    {
        CONST_VTBL struct IDebugPortNotify2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPortNotify2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPortNotify2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPortNotify2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPortNotify2_AddProgramNode(This,pProgramNode)	\
    (This)->lpVtbl -> AddProgramNode(This,pProgramNode)

#define IDebugPortNotify2_RemoveProgramNode(This,pProgramNode)	\
    (This)->lpVtbl -> RemoveProgramNode(This,pProgramNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPortNotify2_AddProgramNode_Proxy( 
    IDebugPortNotify2 * This,
    /* [in] */ IDebugProgramNode2 *pProgramNode);


void __RPC_STUB IDebugPortNotify2_AddProgramNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPortNotify2_RemoveProgramNode_Proxy( 
    IDebugPortNotify2 * This,
    /* [in] */ IDebugProgramNode2 *pProgramNode);


void __RPC_STUB IDebugPortNotify2_RemoveProgramNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPortNotify2_INTERFACE_DEFINED__ */


#ifndef __IDebugPortEvents2_INTERFACE_DEFINED__
#define __IDebugPortEvents2_INTERFACE_DEFINED__

/* interface IDebugPortEvents2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPortEvents2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("564fa275-12e1-4b5f-8316-4d79bcef7246")
    IDebugPortEvents2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Event( 
            /* [in] */ IDebugMachine2 *pMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [in] */ IDebugProcess2 *pProcess,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugEvent2 *pEvent,
            /* [in] */ REFIID riidEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPortEvents2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPortEvents2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPortEvents2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPortEvents2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Event )( 
            IDebugPortEvents2 * This,
            /* [in] */ IDebugMachine2 *pMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [in] */ IDebugProcess2 *pProcess,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugEvent2 *pEvent,
            /* [in] */ REFIID riidEvent);
        
        END_INTERFACE
    } IDebugPortEvents2Vtbl;

    interface IDebugPortEvents2
    {
        CONST_VTBL struct IDebugPortEvents2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPortEvents2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPortEvents2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPortEvents2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPortEvents2_Event(This,pMachine,pPort,pProcess,pProgram,pEvent,riidEvent)	\
    (This)->lpVtbl -> Event(This,pMachine,pPort,pProcess,pProgram,pEvent,riidEvent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPortEvents2_Event_Proxy( 
    IDebugPortEvents2 * This,
    /* [in] */ IDebugMachine2 *pMachine,
    /* [in] */ IDebugPort2 *pPort,
    /* [in] */ IDebugProcess2 *pProcess,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [in] */ IDebugEvent2 *pEvent,
    /* [in] */ REFIID riidEvent);


void __RPC_STUB IDebugPortEvents2_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPortEvents2_INTERFACE_DEFINED__ */


#ifndef __IDebugMDMUtil2_INTERFACE_DEFINED__
#define __IDebugMDMUtil2_INTERFACE_DEFINED__

/* interface IDebugMDMUtil2 */
/* [unique][uuid][object] */ 

typedef DWORD DYNDEBUGFLAGS;


enum __MIDL_IDebugMDMUtil2_0001
    {	DYNDEBUG_ATTACH	= 1,
	DYNDEBUG_JIT	= 2,
	DYNDEBUG_REMOTEJIT	= 4
    } ;
#define	S_UNKNOWN	( 0x3 )


EXTERN_C const IID IID_IDebugMDMUtil2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f3062547-43d8-4dc2-b18e-e1460ff2c422")
    IDebugMDMUtil2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPIDToIgnore( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePIDToIgnore( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPIDToDebug( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePIDToDebug( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDynamicDebuggingFlags( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DYNDEBUGFLAGS dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDynamicDebuggingFlags( 
            /* [in] */ REFGUID guidEngine,
            /* [out] */ DYNDEBUGFLAGS *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultJITServer( 
            /* [in] */ REFCLSID clsidJITServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultJITServer( 
            /* [out] */ CLSID *pClsidJITServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterJITDebugEngines( 
            /* [in] */ REFCLSID clsidJITServer,
            /* [size_is][in] */ GUID *arrguidEngines,
            /* [size_is][full][in] */ BOOL *arrRemoteFlags,
            /* [in] */ DWORD celtEngs,
            /* [in] */ BOOL fRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanDebugPID( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD pid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMDMUtil2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMDMUtil2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMDMUtil2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPIDToIgnore )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePIDToIgnore )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid);
        
        HRESULT ( STDMETHODCALLTYPE *AddPIDToDebug )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePIDToDebug )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD dwPid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDynamicDebuggingFlags )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DYNDEBUGFLAGS dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicDebuggingFlags )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [out] */ DYNDEBUGFLAGS *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultJITServer )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFCLSID clsidJITServer);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultJITServer )( 
            IDebugMDMUtil2 * This,
            /* [out] */ CLSID *pClsidJITServer);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterJITDebugEngines )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFCLSID clsidJITServer,
            /* [size_is][in] */ GUID *arrguidEngines,
            /* [size_is][full][in] */ BOOL *arrRemoteFlags,
            /* [in] */ DWORD celtEngs,
            /* [in] */ BOOL fRegister);
        
        HRESULT ( STDMETHODCALLTYPE *CanDebugPID )( 
            IDebugMDMUtil2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ DWORD pid);
        
        END_INTERFACE
    } IDebugMDMUtil2Vtbl;

    interface IDebugMDMUtil2
    {
        CONST_VTBL struct IDebugMDMUtil2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMDMUtil2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMDMUtil2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMDMUtil2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMDMUtil2_AddPIDToIgnore(This,guidEngine,dwPid)	\
    (This)->lpVtbl -> AddPIDToIgnore(This,guidEngine,dwPid)

#define IDebugMDMUtil2_RemovePIDToIgnore(This,guidEngine,dwPid)	\
    (This)->lpVtbl -> RemovePIDToIgnore(This,guidEngine,dwPid)

#define IDebugMDMUtil2_AddPIDToDebug(This,guidEngine,dwPid)	\
    (This)->lpVtbl -> AddPIDToDebug(This,guidEngine,dwPid)

#define IDebugMDMUtil2_RemovePIDToDebug(This,guidEngine,dwPid)	\
    (This)->lpVtbl -> RemovePIDToDebug(This,guidEngine,dwPid)

#define IDebugMDMUtil2_SetDynamicDebuggingFlags(This,guidEngine,dwFlags)	\
    (This)->lpVtbl -> SetDynamicDebuggingFlags(This,guidEngine,dwFlags)

#define IDebugMDMUtil2_GetDynamicDebuggingFlags(This,guidEngine,pdwFlags)	\
    (This)->lpVtbl -> GetDynamicDebuggingFlags(This,guidEngine,pdwFlags)

#define IDebugMDMUtil2_SetDefaultJITServer(This,clsidJITServer)	\
    (This)->lpVtbl -> SetDefaultJITServer(This,clsidJITServer)

#define IDebugMDMUtil2_GetDefaultJITServer(This,pClsidJITServer)	\
    (This)->lpVtbl -> GetDefaultJITServer(This,pClsidJITServer)

#define IDebugMDMUtil2_RegisterJITDebugEngines(This,clsidJITServer,arrguidEngines,arrRemoteFlags,celtEngs,fRegister)	\
    (This)->lpVtbl -> RegisterJITDebugEngines(This,clsidJITServer,arrguidEngines,arrRemoteFlags,celtEngs,fRegister)

#define IDebugMDMUtil2_CanDebugPID(This,guidEngine,pid)	\
    (This)->lpVtbl -> CanDebugPID(This,guidEngine,pid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_AddPIDToIgnore_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DWORD dwPid);


void __RPC_STUB IDebugMDMUtil2_AddPIDToIgnore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_RemovePIDToIgnore_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DWORD dwPid);


void __RPC_STUB IDebugMDMUtil2_RemovePIDToIgnore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_AddPIDToDebug_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DWORD dwPid);


void __RPC_STUB IDebugMDMUtil2_AddPIDToDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_RemovePIDToDebug_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DWORD dwPid);


void __RPC_STUB IDebugMDMUtil2_RemovePIDToDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_SetDynamicDebuggingFlags_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DYNDEBUGFLAGS dwFlags);


void __RPC_STUB IDebugMDMUtil2_SetDynamicDebuggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_GetDynamicDebuggingFlags_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [out] */ DYNDEBUGFLAGS *pdwFlags);


void __RPC_STUB IDebugMDMUtil2_GetDynamicDebuggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_SetDefaultJITServer_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFCLSID clsidJITServer);


void __RPC_STUB IDebugMDMUtil2_SetDefaultJITServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_GetDefaultJITServer_Proxy( 
    IDebugMDMUtil2 * This,
    /* [out] */ CLSID *pClsidJITServer);


void __RPC_STUB IDebugMDMUtil2_GetDefaultJITServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_RegisterJITDebugEngines_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFCLSID clsidJITServer,
    /* [size_is][in] */ GUID *arrguidEngines,
    /* [size_is][full][in] */ BOOL *arrRemoteFlags,
    /* [in] */ DWORD celtEngs,
    /* [in] */ BOOL fRegister);


void __RPC_STUB IDebugMDMUtil2_RegisterJITDebugEngines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMDMUtil2_CanDebugPID_Proxy( 
    IDebugMDMUtil2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ DWORD pid);


void __RPC_STUB IDebugMDMUtil2_CanDebugPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMDMUtil2_INTERFACE_DEFINED__ */


#ifndef __IDebugSession2_INTERFACE_DEFINED__
#define __IDebugSession2_INTERFACE_DEFINED__

/* interface IDebugSession2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugSession2_0001
    {	LAUNCH_DEBUG	= 0,
	LAUNCH_NODEBUG	= 0x1,
	LAUNCH_ENABLE_ENC	= 0x2
    } ;
typedef DWORD LAUNCH_FLAGS;


enum __MIDL_IDebugSession2_0002
    {	EXCEPTION_NONE	= 0,
	EXCEPTION_STOP_FIRST_CHANCE	= 0x1,
	EXCEPTION_STOP_SECOND_CHANCE	= 0x2,
	EXCEPTION_STOP_FIRST_CHANCE_USE_PARENT	= 0x4,
	EXCEPTION_STOP_SECOND_CHANCE_USE_PARENT	= 0x8
    } ;
typedef DWORD EXCEPTION_STATE;

typedef struct tagEXCEPTION_INFO
    {
    IDebugProgram2 *pProgram;
    BSTR bstrProgramName;
    BSTR bstrExceptionName;
    DWORD dwCode;
    EXCEPTION_STATE dwState;
    GUID guidType;
    } 	EXCEPTION_INFO;


enum __MIDL_IDebugSession2_0003
    {	STOPPING_MODEL_STOP_ALL	= 0x1,
	STOPPING_MODEL_STOP_ONE	= 0x2
    } ;
typedef DWORD STOPPING_MODEL;


EXTERN_C const IID IID_IDebugSession2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8948300f-8bd5-4728-a1d8-83d172295a9d")
    IDebugSession2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProcesses( 
            /* [out] */ IEnumDebugProcesses2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Launch( 
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [full][in] */ LPCOLESTR pszExe,
            /* [full][in] */ LPCOLESTR pszArgs,
            /* [full][in] */ LPCOLESTR pszDir,
            /* [full][in] */ BSTR bstrEnv,
            /* [full][in] */ LPCOLESTR pszOptions,
            /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
            /* [in] */ DWORD hStdInput,
            /* [in] */ DWORD hStdOutput,
            /* [in] */ DWORD hStdError,
            /* [in] */ REFGUID guidLaunchingEngine,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [out] */ IDebugProcess2 **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterJITServer( 
            /* [in] */ REFCLSID clsidJITServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ BOOL fForce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePendingBreakpoint( 
            /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPendingBreakpoints( 
            /* [in] */ IDebugProgram2 *pProgram,
            /* [full][in] */ LPCOLESTR pszProgram,
            /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnumBPs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMachines( 
            /* [out] */ IEnumDebugMachines2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMachine( 
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [out] */ IDebugMachine2 **ppMachine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMachine( 
            /* [in] */ IDebugMachine2 *pMachine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutdownSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts( 
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugDocumentPosition2 *pDocPos,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetException( 
            /* [in] */ EXCEPTION_INFO *pException) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSetExceptions( 
            /* [in] */ IDebugProgram2 *pProgram,
            /* [full][in] */ LPCOLESTR pszProgram,
            /* [in] */ REFGUID guidType,
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSetException( 
            /* [in] */ EXCEPTION_INFO *pException) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllSetExceptions( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDefaultExceptions( 
            /* [full][in] */ EXCEPTION_INFO *pParentException,
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetENCUpdate( 
            /* [in] */ IDebugProgram2 *pProgram,
            /* [out] */ IDebugENCUpdate **ppUpdate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ WORD wLangID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegistryRoot( 
            /* [full][in] */ LPCOLESTR pszRegistryRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAlive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearAllSessionThreadStackFrames( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionId( 
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [full][size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [full][in] */ LPCOLESTR pszStartPageUrl,
            /* [out] */ BSTR *pbstrSessionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEngineMetric( 
            /* [in] */ REFGUID guidEngine,
            /* [in] */ LPCOLESTR pszMetric,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStoppingModel( 
            /* [in] */ STOPPING_MODEL dwStoppingModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStoppingModel( 
            /* [out] */ STOPPING_MODEL *pdwStoppingModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterSessionWithServer( 
            /* [in] */ LPCOLESTR pwszServerName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugSession2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSession2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSession2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugSession2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IDebugSession2 * This,
            /* [in] */ LPOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProcesses )( 
            IDebugSession2 * This,
            /* [out] */ IEnumDebugProcesses2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Launch )( 
            IDebugSession2 * This,
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [full][in] */ LPCOLESTR pszExe,
            /* [full][in] */ LPCOLESTR pszArgs,
            /* [full][in] */ LPCOLESTR pszDir,
            /* [full][in] */ BSTR bstrEnv,
            /* [full][in] */ LPCOLESTR pszOptions,
            /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
            /* [in] */ DWORD hStdInput,
            /* [in] */ DWORD hStdOutput,
            /* [in] */ DWORD hStdError,
            /* [in] */ REFGUID guidLaunchingEngine,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [out] */ IDebugProcess2 **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterJITServer )( 
            IDebugSession2 * This,
            /* [in] */ REFCLSID clsidJITServer);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDebugSession2 * This,
            /* [in] */ BOOL fForce);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePendingBreakpoint )( 
            IDebugSession2 * This,
            /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPendingBreakpoints )( 
            IDebugSession2 * This,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [full][in] */ LPCOLESTR pszProgram,
            /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnumBPs);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMachines )( 
            IDebugSession2 * This,
            /* [out] */ IEnumDebugMachines2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *AddMachine )( 
            IDebugSession2 * This,
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [out] */ IDebugMachine2 **ppMachine);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMachine )( 
            IDebugSession2 * This,
            /* [in] */ IDebugMachine2 *pMachine);
        
        HRESULT ( STDMETHODCALLTYPE *ShutdownSession )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContexts )( 
            IDebugSession2 * This,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugDocumentPosition2 *pDocPos,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *SetException )( 
            IDebugSession2 * This,
            /* [in] */ EXCEPTION_INFO *pException);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSetExceptions )( 
            IDebugSession2 * This,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [full][in] */ LPCOLESTR pszProgram,
            /* [in] */ REFGUID guidType,
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSetException )( 
            IDebugSession2 * This,
            /* [in] */ EXCEPTION_INFO *pException);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllSetExceptions )( 
            IDebugSession2 * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDefaultExceptions )( 
            IDebugSession2 * This,
            /* [full][in] */ EXCEPTION_INFO *pParentException,
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetENCUpdate )( 
            IDebugSession2 * This,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [out] */ IDebugENCUpdate **ppUpdate);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocale )( 
            IDebugSession2 * This,
            /* [in] */ WORD wLangID);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegistryRoot )( 
            IDebugSession2 * This,
            /* [full][in] */ LPCOLESTR pszRegistryRoot);
        
        HRESULT ( STDMETHODCALLTYPE *IsAlive )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearAllSessionThreadStackFrames )( 
            IDebugSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionId )( 
            IDebugSession2 * This,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [full][size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [full][in] */ LPCOLESTR pszStartPageUrl,
            /* [out] */ BSTR *pbstrSessionId);
        
        HRESULT ( STDMETHODCALLTYPE *SetEngineMetric )( 
            IDebugSession2 * This,
            /* [in] */ REFGUID guidEngine,
            /* [in] */ LPCOLESTR pszMetric,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetStoppingModel )( 
            IDebugSession2 * This,
            /* [in] */ STOPPING_MODEL dwStoppingModel);
        
        HRESULT ( STDMETHODCALLTYPE *GetStoppingModel )( 
            IDebugSession2 * This,
            /* [out] */ STOPPING_MODEL *pdwStoppingModel);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterSessionWithServer )( 
            IDebugSession2 * This,
            /* [in] */ LPCOLESTR pwszServerName);
        
        END_INTERFACE
    } IDebugSession2Vtbl;

    interface IDebugSession2
    {
        CONST_VTBL struct IDebugSession2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSession2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugSession2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugSession2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugSession2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugSession2_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IDebugSession2_EnumProcesses(This,ppEnum)	\
    (This)->lpVtbl -> EnumProcesses(This,ppEnum)

#define IDebugSession2_Launch(This,pszMachine,pPort,pszExe,pszArgs,pszDir,bstrEnv,pszOptions,dwLaunchFlags,hStdInput,hStdOutput,hStdError,guidLaunchingEngine,pCallback,rgguidSpecificEngines,celtSpecificEngines,ppProcess)	\
    (This)->lpVtbl -> Launch(This,pszMachine,pPort,pszExe,pszArgs,pszDir,bstrEnv,pszOptions,dwLaunchFlags,hStdInput,hStdOutput,hStdError,guidLaunchingEngine,pCallback,rgguidSpecificEngines,celtSpecificEngines,ppProcess)

#define IDebugSession2_RegisterJITServer(This,clsidJITServer)	\
    (This)->lpVtbl -> RegisterJITServer(This,clsidJITServer)

#define IDebugSession2_Terminate(This,fForce)	\
    (This)->lpVtbl -> Terminate(This,fForce)

#define IDebugSession2_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IDebugSession2_CauseBreak(This)	\
    (This)->lpVtbl -> CauseBreak(This)

#define IDebugSession2_CreatePendingBreakpoint(This,pBPRequest,ppPendingBP)	\
    (This)->lpVtbl -> CreatePendingBreakpoint(This,pBPRequest,ppPendingBP)

#define IDebugSession2_EnumPendingBreakpoints(This,pProgram,pszProgram,ppEnumBPs)	\
    (This)->lpVtbl -> EnumPendingBreakpoints(This,pProgram,pszProgram,ppEnumBPs)

#define IDebugSession2_EnumMachines(This,ppEnum)	\
    (This)->lpVtbl -> EnumMachines(This,ppEnum)

#define IDebugSession2_AddMachine(This,pszMachine,ppMachine)	\
    (This)->lpVtbl -> AddMachine(This,pszMachine,ppMachine)

#define IDebugSession2_RemoveMachine(This,pMachine)	\
    (This)->lpVtbl -> RemoveMachine(This,pMachine)

#define IDebugSession2_ShutdownSession(This)	\
    (This)->lpVtbl -> ShutdownSession(This)

#define IDebugSession2_EnumCodeContexts(This,pProgram,pDocPos,ppEnum)	\
    (This)->lpVtbl -> EnumCodeContexts(This,pProgram,pDocPos,ppEnum)

#define IDebugSession2_SetException(This,pException)	\
    (This)->lpVtbl -> SetException(This,pException)

#define IDebugSession2_EnumSetExceptions(This,pProgram,pszProgram,guidType,ppEnum)	\
    (This)->lpVtbl -> EnumSetExceptions(This,pProgram,pszProgram,guidType,ppEnum)

#define IDebugSession2_RemoveSetException(This,pException)	\
    (This)->lpVtbl -> RemoveSetException(This,pException)

#define IDebugSession2_RemoveAllSetExceptions(This,guidType)	\
    (This)->lpVtbl -> RemoveAllSetExceptions(This,guidType)

#define IDebugSession2_EnumDefaultExceptions(This,pParentException,ppEnum)	\
    (This)->lpVtbl -> EnumDefaultExceptions(This,pParentException,ppEnum)

#define IDebugSession2_GetENCUpdate(This,pProgram,ppUpdate)	\
    (This)->lpVtbl -> GetENCUpdate(This,pProgram,ppUpdate)

#define IDebugSession2_SetLocale(This,wLangID)	\
    (This)->lpVtbl -> SetLocale(This,wLangID)

#define IDebugSession2_SetRegistryRoot(This,pszRegistryRoot)	\
    (This)->lpVtbl -> SetRegistryRoot(This,pszRegistryRoot)

#define IDebugSession2_IsAlive(This)	\
    (This)->lpVtbl -> IsAlive(This)

#define IDebugSession2_ClearAllSessionThreadStackFrames(This)	\
    (This)->lpVtbl -> ClearAllSessionThreadStackFrames(This)

#define IDebugSession2_GetSessionId(This,pCallback,rgguidSpecificEngines,celtSpecificEngines,pszStartPageUrl,pbstrSessionId)	\
    (This)->lpVtbl -> GetSessionId(This,pCallback,rgguidSpecificEngines,celtSpecificEngines,pszStartPageUrl,pbstrSessionId)

#define IDebugSession2_SetEngineMetric(This,guidEngine,pszMetric,varValue)	\
    (This)->lpVtbl -> SetEngineMetric(This,guidEngine,pszMetric,varValue)

#define IDebugSession2_SetStoppingModel(This,dwStoppingModel)	\
    (This)->lpVtbl -> SetStoppingModel(This,dwStoppingModel)

#define IDebugSession2_GetStoppingModel(This,pdwStoppingModel)	\
    (This)->lpVtbl -> GetStoppingModel(This,pdwStoppingModel)

#define IDebugSession2_RegisterSessionWithServer(This,pwszServerName)	\
    (This)->lpVtbl -> RegisterSessionWithServer(This,pwszServerName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugSession2_GetName_Proxy( 
    IDebugSession2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugSession2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetName_Proxy( 
    IDebugSession2 * This,
    /* [in] */ LPOLESTR pszName);


void __RPC_STUB IDebugSession2_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumProcesses_Proxy( 
    IDebugSession2 * This,
    /* [out] */ IEnumDebugProcesses2 **ppEnum);


void __RPC_STUB IDebugSession2_EnumProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_Launch_Proxy( 
    IDebugSession2 * This,
    /* [full][in] */ LPCOLESTR pszMachine,
    /* [in] */ IDebugPort2 *pPort,
    /* [full][in] */ LPCOLESTR pszExe,
    /* [full][in] */ LPCOLESTR pszArgs,
    /* [full][in] */ LPCOLESTR pszDir,
    /* [full][in] */ BSTR bstrEnv,
    /* [full][in] */ LPCOLESTR pszOptions,
    /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
    /* [in] */ DWORD hStdInput,
    /* [in] */ DWORD hStdOutput,
    /* [in] */ DWORD hStdError,
    /* [in] */ REFGUID guidLaunchingEngine,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [size_is][in] */ GUID *rgguidSpecificEngines,
    /* [in] */ DWORD celtSpecificEngines,
    /* [out] */ IDebugProcess2 **ppProcess);


void __RPC_STUB IDebugSession2_Launch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_RegisterJITServer_Proxy( 
    IDebugSession2 * This,
    /* [in] */ REFCLSID clsidJITServer);


void __RPC_STUB IDebugSession2_RegisterJITServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_Terminate_Proxy( 
    IDebugSession2 * This,
    /* [in] */ BOOL fForce);


void __RPC_STUB IDebugSession2_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_Detach_Proxy( 
    IDebugSession2 * This);


void __RPC_STUB IDebugSession2_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_CauseBreak_Proxy( 
    IDebugSession2 * This);


void __RPC_STUB IDebugSession2_CauseBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_CreatePendingBreakpoint_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
    /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);


void __RPC_STUB IDebugSession2_CreatePendingBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumPendingBreakpoints_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [full][in] */ LPCOLESTR pszProgram,
    /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnumBPs);


void __RPC_STUB IDebugSession2_EnumPendingBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumMachines_Proxy( 
    IDebugSession2 * This,
    /* [out] */ IEnumDebugMachines2 **ppEnum);


void __RPC_STUB IDebugSession2_EnumMachines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_AddMachine_Proxy( 
    IDebugSession2 * This,
    /* [full][in] */ LPCOLESTR pszMachine,
    /* [out] */ IDebugMachine2 **ppMachine);


void __RPC_STUB IDebugSession2_AddMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_RemoveMachine_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugMachine2 *pMachine);


void __RPC_STUB IDebugSession2_RemoveMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_ShutdownSession_Proxy( 
    IDebugSession2 * This);


void __RPC_STUB IDebugSession2_ShutdownSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumCodeContexts_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [in] */ IDebugDocumentPosition2 *pDocPos,
    /* [out] */ IEnumDebugCodeContexts2 **ppEnum);


void __RPC_STUB IDebugSession2_EnumCodeContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetException_Proxy( 
    IDebugSession2 * This,
    /* [in] */ EXCEPTION_INFO *pException);


void __RPC_STUB IDebugSession2_SetException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumSetExceptions_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [full][in] */ LPCOLESTR pszProgram,
    /* [in] */ REFGUID guidType,
    /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);


void __RPC_STUB IDebugSession2_EnumSetExceptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_RemoveSetException_Proxy( 
    IDebugSession2 * This,
    /* [in] */ EXCEPTION_INFO *pException);


void __RPC_STUB IDebugSession2_RemoveSetException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_RemoveAllSetExceptions_Proxy( 
    IDebugSession2 * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IDebugSession2_RemoveAllSetExceptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_EnumDefaultExceptions_Proxy( 
    IDebugSession2 * This,
    /* [full][in] */ EXCEPTION_INFO *pParentException,
    /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);


void __RPC_STUB IDebugSession2_EnumDefaultExceptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_GetENCUpdate_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [out] */ IDebugENCUpdate **ppUpdate);


void __RPC_STUB IDebugSession2_GetENCUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetLocale_Proxy( 
    IDebugSession2 * This,
    /* [in] */ WORD wLangID);


void __RPC_STUB IDebugSession2_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetRegistryRoot_Proxy( 
    IDebugSession2 * This,
    /* [full][in] */ LPCOLESTR pszRegistryRoot);


void __RPC_STUB IDebugSession2_SetRegistryRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_IsAlive_Proxy( 
    IDebugSession2 * This);


void __RPC_STUB IDebugSession2_IsAlive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_ClearAllSessionThreadStackFrames_Proxy( 
    IDebugSession2 * This);


void __RPC_STUB IDebugSession2_ClearAllSessionThreadStackFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_GetSessionId_Proxy( 
    IDebugSession2 * This,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [full][size_is][in] */ GUID *rgguidSpecificEngines,
    /* [in] */ DWORD celtSpecificEngines,
    /* [full][in] */ LPCOLESTR pszStartPageUrl,
    /* [out] */ BSTR *pbstrSessionId);


void __RPC_STUB IDebugSession2_GetSessionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetEngineMetric_Proxy( 
    IDebugSession2 * This,
    /* [in] */ REFGUID guidEngine,
    /* [in] */ LPCOLESTR pszMetric,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IDebugSession2_SetEngineMetric_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_SetStoppingModel_Proxy( 
    IDebugSession2 * This,
    /* [in] */ STOPPING_MODEL dwStoppingModel);


void __RPC_STUB IDebugSession2_SetStoppingModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_GetStoppingModel_Proxy( 
    IDebugSession2 * This,
    /* [out] */ STOPPING_MODEL *pdwStoppingModel);


void __RPC_STUB IDebugSession2_GetStoppingModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSession2_RegisterSessionWithServer_Proxy( 
    IDebugSession2 * This,
    /* [in] */ LPCOLESTR pwszServerName);


void __RPC_STUB IDebugSession2_RegisterSessionWithServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugSession2_INTERFACE_DEFINED__ */


#ifndef __IDebugEngine2_INTERFACE_DEFINED__
#define __IDebugEngine2_INTERFACE_DEFINED__

/* interface IDebugEngine2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugEngine2_0001
    {	ATTACH_REASON_LAUNCH	= 0x1,
	ATTACH_REASON_USER	= 0x2,
	ATTACH_REASON_AUTO	= 0x3
    } ;
typedef DWORD ATTACH_REASON;


EXTERN_C const IID IID_IDebugEngine2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba105b52-12f1-4038-ae64-d95785874c47")
    IDebugEngine2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumPrograms( 
            /* [out] */ IEnumDebugPrograms2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [length_is][size_is][in] */ IDebugProgram2 **rgpPrograms,
            /* [length_is][size_is][in] */ IDebugProgramNode2 **rgpProgramNodes,
            /* [in] */ DWORD celtPrograms,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [in] */ ATTACH_REASON dwReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePendingBreakpoint( 
            /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetException( 
            /* [in] */ EXCEPTION_INFO *pException) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSetException( 
            /* [in] */ EXCEPTION_INFO *pException) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllSetExceptions( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEngineId( 
            /* [out] */ GUID *pguidEngine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyProgram( 
            /* [in] */ IDebugProgram2 *pProgram) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ContinueFromSynchronousEvent( 
            /* [in] */ IDebugEvent2 *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ WORD wLangID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegistryRoot( 
            /* [full][in] */ LPCOLESTR pszRegistryRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMetric( 
            /* [in] */ LPCOLESTR pszMetric,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEngine2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEngine2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEngine2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEngine2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPrograms )( 
            IDebugEngine2 * This,
            /* [out] */ IEnumDebugPrograms2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugEngine2 * This,
            /* [length_is][size_is][in] */ IDebugProgram2 **rgpPrograms,
            /* [length_is][size_is][in] */ IDebugProgramNode2 **rgpProgramNodes,
            /* [in] */ DWORD celtPrograms,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [in] */ ATTACH_REASON dwReason);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePendingBreakpoint )( 
            IDebugEngine2 * This,
            /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);
        
        HRESULT ( STDMETHODCALLTYPE *SetException )( 
            IDebugEngine2 * This,
            /* [in] */ EXCEPTION_INFO *pException);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSetException )( 
            IDebugEngine2 * This,
            /* [in] */ EXCEPTION_INFO *pException);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllSetExceptions )( 
            IDebugEngine2 * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetEngineId )( 
            IDebugEngine2 * This,
            /* [out] */ GUID *pguidEngine);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyProgram )( 
            IDebugEngine2 * This,
            /* [in] */ IDebugProgram2 *pProgram);
        
        HRESULT ( STDMETHODCALLTYPE *ContinueFromSynchronousEvent )( 
            IDebugEngine2 * This,
            /* [in] */ IDebugEvent2 *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocale )( 
            IDebugEngine2 * This,
            /* [in] */ WORD wLangID);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegistryRoot )( 
            IDebugEngine2 * This,
            /* [full][in] */ LPCOLESTR pszRegistryRoot);
        
        HRESULT ( STDMETHODCALLTYPE *SetMetric )( 
            IDebugEngine2 * This,
            /* [in] */ LPCOLESTR pszMetric,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugEngine2 * This);
        
        END_INTERFACE
    } IDebugEngine2Vtbl;

    interface IDebugEngine2
    {
        CONST_VTBL struct IDebugEngine2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEngine2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEngine2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEngine2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEngine2_EnumPrograms(This,ppEnum)	\
    (This)->lpVtbl -> EnumPrograms(This,ppEnum)

#define IDebugEngine2_Attach(This,rgpPrograms,rgpProgramNodes,celtPrograms,pCallback,dwReason)	\
    (This)->lpVtbl -> Attach(This,rgpPrograms,rgpProgramNodes,celtPrograms,pCallback,dwReason)

#define IDebugEngine2_CreatePendingBreakpoint(This,pBPRequest,ppPendingBP)	\
    (This)->lpVtbl -> CreatePendingBreakpoint(This,pBPRequest,ppPendingBP)

#define IDebugEngine2_SetException(This,pException)	\
    (This)->lpVtbl -> SetException(This,pException)

#define IDebugEngine2_RemoveSetException(This,pException)	\
    (This)->lpVtbl -> RemoveSetException(This,pException)

#define IDebugEngine2_RemoveAllSetExceptions(This,guidType)	\
    (This)->lpVtbl -> RemoveAllSetExceptions(This,guidType)

#define IDebugEngine2_GetEngineId(This,pguidEngine)	\
    (This)->lpVtbl -> GetEngineId(This,pguidEngine)

#define IDebugEngine2_DestroyProgram(This,pProgram)	\
    (This)->lpVtbl -> DestroyProgram(This,pProgram)

#define IDebugEngine2_ContinueFromSynchronousEvent(This,pEvent)	\
    (This)->lpVtbl -> ContinueFromSynchronousEvent(This,pEvent)

#define IDebugEngine2_SetLocale(This,wLangID)	\
    (This)->lpVtbl -> SetLocale(This,wLangID)

#define IDebugEngine2_SetRegistryRoot(This,pszRegistryRoot)	\
    (This)->lpVtbl -> SetRegistryRoot(This,pszRegistryRoot)

#define IDebugEngine2_SetMetric(This,pszMetric,varValue)	\
    (This)->lpVtbl -> SetMetric(This,pszMetric,varValue)

#define IDebugEngine2_CauseBreak(This)	\
    (This)->lpVtbl -> CauseBreak(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEngine2_EnumPrograms_Proxy( 
    IDebugEngine2 * This,
    /* [out] */ IEnumDebugPrograms2 **ppEnum);


void __RPC_STUB IDebugEngine2_EnumPrograms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_Attach_Proxy( 
    IDebugEngine2 * This,
    /* [length_is][size_is][in] */ IDebugProgram2 **rgpPrograms,
    /* [length_is][size_is][in] */ IDebugProgramNode2 **rgpProgramNodes,
    /* [in] */ DWORD celtPrograms,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [in] */ ATTACH_REASON dwReason);


void __RPC_STUB IDebugEngine2_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_CreatePendingBreakpoint_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ IDebugBreakpointRequest2 *pBPRequest,
    /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);


void __RPC_STUB IDebugEngine2_CreatePendingBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_SetException_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ EXCEPTION_INFO *pException);


void __RPC_STUB IDebugEngine2_SetException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_RemoveSetException_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ EXCEPTION_INFO *pException);


void __RPC_STUB IDebugEngine2_RemoveSetException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_RemoveAllSetExceptions_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IDebugEngine2_RemoveAllSetExceptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_GetEngineId_Proxy( 
    IDebugEngine2 * This,
    /* [out] */ GUID *pguidEngine);


void __RPC_STUB IDebugEngine2_GetEngineId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_DestroyProgram_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ IDebugProgram2 *pProgram);


void __RPC_STUB IDebugEngine2_DestroyProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_ContinueFromSynchronousEvent_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ IDebugEvent2 *pEvent);


void __RPC_STUB IDebugEngine2_ContinueFromSynchronousEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_SetLocale_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ WORD wLangID);


void __RPC_STUB IDebugEngine2_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_SetRegistryRoot_Proxy( 
    IDebugEngine2 * This,
    /* [full][in] */ LPCOLESTR pszRegistryRoot);


void __RPC_STUB IDebugEngine2_SetRegistryRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_SetMetric_Proxy( 
    IDebugEngine2 * This,
    /* [in] */ LPCOLESTR pszMetric,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IDebugEngine2_SetMetric_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngine2_CauseBreak_Proxy( 
    IDebugEngine2 * This);


void __RPC_STUB IDebugEngine2_CauseBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEngine2_INTERFACE_DEFINED__ */


#ifndef __IDebugEngineLaunch2_INTERFACE_DEFINED__
#define __IDebugEngineLaunch2_INTERFACE_DEFINED__

/* interface IDebugEngineLaunch2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugEngineLaunch2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7c1462f-9736-466c-b2c1-b6b2dedbf4a7")
    IDebugEngineLaunch2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LaunchSuspended( 
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [full][in] */ LPCOLESTR pszExe,
            /* [full][in] */ LPCOLESTR pszArgs,
            /* [full][in] */ LPCOLESTR pszDir,
            /* [full][in] */ BSTR bstrEnv,
            /* [full][in] */ LPCOLESTR pszOptions,
            /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
            /* [in] */ DWORD hStdInput,
            /* [in] */ DWORD hStdOutput,
            /* [in] */ DWORD hStdError,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [out] */ IDebugProcess2 **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeProcess( 
            /* [in] */ IDebugProcess2 *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanTerminateProcess( 
            /* [in] */ IDebugProcess2 *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateProcess( 
            /* [in] */ IDebugProcess2 *pProcess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEngineLaunch2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEngineLaunch2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEngineLaunch2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEngineLaunch2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *LaunchSuspended )( 
            IDebugEngineLaunch2 * This,
            /* [full][in] */ LPCOLESTR pszMachine,
            /* [in] */ IDebugPort2 *pPort,
            /* [full][in] */ LPCOLESTR pszExe,
            /* [full][in] */ LPCOLESTR pszArgs,
            /* [full][in] */ LPCOLESTR pszDir,
            /* [full][in] */ BSTR bstrEnv,
            /* [full][in] */ LPCOLESTR pszOptions,
            /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
            /* [in] */ DWORD hStdInput,
            /* [in] */ DWORD hStdOutput,
            /* [in] */ DWORD hStdError,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [out] */ IDebugProcess2 **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeProcess )( 
            IDebugEngineLaunch2 * This,
            /* [in] */ IDebugProcess2 *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CanTerminateProcess )( 
            IDebugEngineLaunch2 * This,
            /* [in] */ IDebugProcess2 *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateProcess )( 
            IDebugEngineLaunch2 * This,
            /* [in] */ IDebugProcess2 *pProcess);
        
        END_INTERFACE
    } IDebugEngineLaunch2Vtbl;

    interface IDebugEngineLaunch2
    {
        CONST_VTBL struct IDebugEngineLaunch2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEngineLaunch2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEngineLaunch2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEngineLaunch2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEngineLaunch2_LaunchSuspended(This,pszMachine,pPort,pszExe,pszArgs,pszDir,bstrEnv,pszOptions,dwLaunchFlags,hStdInput,hStdOutput,hStdError,pCallback,ppProcess)	\
    (This)->lpVtbl -> LaunchSuspended(This,pszMachine,pPort,pszExe,pszArgs,pszDir,bstrEnv,pszOptions,dwLaunchFlags,hStdInput,hStdOutput,hStdError,pCallback,ppProcess)

#define IDebugEngineLaunch2_ResumeProcess(This,pProcess)	\
    (This)->lpVtbl -> ResumeProcess(This,pProcess)

#define IDebugEngineLaunch2_CanTerminateProcess(This,pProcess)	\
    (This)->lpVtbl -> CanTerminateProcess(This,pProcess)

#define IDebugEngineLaunch2_TerminateProcess(This,pProcess)	\
    (This)->lpVtbl -> TerminateProcess(This,pProcess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEngineLaunch2_LaunchSuspended_Proxy( 
    IDebugEngineLaunch2 * This,
    /* [full][in] */ LPCOLESTR pszMachine,
    /* [in] */ IDebugPort2 *pPort,
    /* [full][in] */ LPCOLESTR pszExe,
    /* [full][in] */ LPCOLESTR pszArgs,
    /* [full][in] */ LPCOLESTR pszDir,
    /* [full][in] */ BSTR bstrEnv,
    /* [full][in] */ LPCOLESTR pszOptions,
    /* [in] */ LAUNCH_FLAGS dwLaunchFlags,
    /* [in] */ DWORD hStdInput,
    /* [in] */ DWORD hStdOutput,
    /* [in] */ DWORD hStdError,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [out] */ IDebugProcess2 **ppProcess);


void __RPC_STUB IDebugEngineLaunch2_LaunchSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngineLaunch2_ResumeProcess_Proxy( 
    IDebugEngineLaunch2 * This,
    /* [in] */ IDebugProcess2 *pProcess);


void __RPC_STUB IDebugEngineLaunch2_ResumeProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngineLaunch2_CanTerminateProcess_Proxy( 
    IDebugEngineLaunch2 * This,
    /* [in] */ IDebugProcess2 *pProcess);


void __RPC_STUB IDebugEngineLaunch2_CanTerminateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngineLaunch2_TerminateProcess_Proxy( 
    IDebugEngineLaunch2 * This,
    /* [in] */ IDebugProcess2 *pProcess);


void __RPC_STUB IDebugEngineLaunch2_TerminateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEngineLaunch2_INTERFACE_DEFINED__ */


#ifndef __IDebugEventCallback2_INTERFACE_DEFINED__
#define __IDebugEventCallback2_INTERFACE_DEFINED__

/* interface IDebugEventCallback2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugEventCallback2_0001
    {	EVENT_ASYNCHRONOUS	= 0,
	EVENT_SYNCHRONOUS	= 0x1,
	EVENT_STOPPING	= 0x2,
	EVENT_ASYNC_STOP	= 0x2,
	EVENT_SYNC_STOP	= 0x3,
	EVENT_IMMEDIATE	= 0x4
    } ;
typedef DWORD EVENTATTRIBUTES;


EXTERN_C const IID IID_IDebugEventCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ade2eeb9-fc85-4f5b-b5d9-d431b4aac31a")
    IDebugEventCallback2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Event( 
            /* [in] */ IDebugEngine2 *pEngine,
            /* [in] */ IDebugProcess2 *pProcess,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugThread2 *pThread,
            /* [in] */ IDebugEvent2 *pEvent,
            /* [in] */ REFIID riidEvent,
            /* [in] */ DWORD dwAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEventCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEventCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEventCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEventCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Event )( 
            IDebugEventCallback2 * This,
            /* [in] */ IDebugEngine2 *pEngine,
            /* [in] */ IDebugProcess2 *pProcess,
            /* [in] */ IDebugProgram2 *pProgram,
            /* [in] */ IDebugThread2 *pThread,
            /* [in] */ IDebugEvent2 *pEvent,
            /* [in] */ REFIID riidEvent,
            /* [in] */ DWORD dwAttrib);
        
        END_INTERFACE
    } IDebugEventCallback2Vtbl;

    interface IDebugEventCallback2
    {
        CONST_VTBL struct IDebugEventCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEventCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEventCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEventCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEventCallback2_Event(This,pEngine,pProcess,pProgram,pThread,pEvent,riidEvent,dwAttrib)	\
    (This)->lpVtbl -> Event(This,pEngine,pProcess,pProgram,pThread,pEvent,riidEvent,dwAttrib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEventCallback2_Event_Proxy( 
    IDebugEventCallback2 * This,
    /* [in] */ IDebugEngine2 *pEngine,
    /* [in] */ IDebugProcess2 *pProcess,
    /* [in] */ IDebugProgram2 *pProgram,
    /* [in] */ IDebugThread2 *pThread,
    /* [in] */ IDebugEvent2 *pEvent,
    /* [in] */ REFIID riidEvent,
    /* [in] */ DWORD dwAttrib);


void __RPC_STUB IDebugEventCallback2_Event_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEventCallback2_INTERFACE_DEFINED__ */


#ifndef __IDebugEvent2_INTERFACE_DEFINED__
#define __IDebugEvent2_INTERFACE_DEFINED__

/* interface IDebugEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("423238d6-da42-4989-96fb-6bba26e72e09")
    IDebugEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ DWORD *pdwAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IDebugEvent2 * This,
            /* [out] */ DWORD *pdwAttrib);
        
        END_INTERFACE
    } IDebugEvent2Vtbl;

    interface IDebugEvent2
    {
        CONST_VTBL struct IDebugEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEvent2_GetAttributes(This,pdwAttrib)	\
    (This)->lpVtbl -> GetAttributes(This,pdwAttrib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEvent2_GetAttributes_Proxy( 
    IDebugEvent2 * This,
    /* [out] */ DWORD *pdwAttrib);


void __RPC_STUB IDebugEvent2_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugSessionCreateEvent2_INTERFACE_DEFINED__
#define __IDebugSessionCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugSessionCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugSessionCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c2b15b7-fc6d-45b3-9622-29665d964a76")
    IDebugSessionCreateEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugSessionCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSessionCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSessionCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSessionCreateEvent2 * This);
        
        END_INTERFACE
    } IDebugSessionCreateEvent2Vtbl;

    interface IDebugSessionCreateEvent2
    {
        CONST_VTBL struct IDebugSessionCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSessionCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugSessionCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugSessionCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSessionCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugSessionDestroyEvent2_INTERFACE_DEFINED__
#define __IDebugSessionDestroyEvent2_INTERFACE_DEFINED__

/* interface IDebugSessionDestroyEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugSessionDestroyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f199b2c2-88fe-4c5d-a0fd-aa046b0dc0dc")
    IDebugSessionDestroyEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugSessionDestroyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSessionDestroyEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSessionDestroyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSessionDestroyEvent2 * This);
        
        END_INTERFACE
    } IDebugSessionDestroyEvent2Vtbl;

    interface IDebugSessionDestroyEvent2
    {
        CONST_VTBL struct IDebugSessionDestroyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSessionDestroyEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugSessionDestroyEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugSessionDestroyEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSessionDestroyEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugEngineCreateEvent2_INTERFACE_DEFINED__
#define __IDebugEngineCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugEngineCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugEngineCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe5b734c-759d-4e59-ab04-f103343bdd06")
    IDebugEngineCreateEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEngine( 
            /* [out] */ IDebugEngine2 **pEngine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEngineCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEngineCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEngineCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEngineCreateEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEngine )( 
            IDebugEngineCreateEvent2 * This,
            /* [out] */ IDebugEngine2 **pEngine);
        
        END_INTERFACE
    } IDebugEngineCreateEvent2Vtbl;

    interface IDebugEngineCreateEvent2
    {
        CONST_VTBL struct IDebugEngineCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEngineCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEngineCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEngineCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEngineCreateEvent2_GetEngine(This,pEngine)	\
    (This)->lpVtbl -> GetEngine(This,pEngine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEngineCreateEvent2_GetEngine_Proxy( 
    IDebugEngineCreateEvent2 * This,
    /* [out] */ IDebugEngine2 **pEngine);


void __RPC_STUB IDebugEngineCreateEvent2_GetEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEngineCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProcessCreateEvent2_INTERFACE_DEFINED__
#define __IDebugProcessCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugProcessCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProcessCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bac3780f-04da-4726-901c-ba6a4633e1ca")
    IDebugProcessCreateEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugProcessCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProcessCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProcessCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProcessCreateEvent2 * This);
        
        END_INTERFACE
    } IDebugProcessCreateEvent2Vtbl;

    interface IDebugProcessCreateEvent2
    {
        CONST_VTBL struct IDebugProcessCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProcessCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProcessCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProcessCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugProcessCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProcessDestroyEvent2_INTERFACE_DEFINED__
#define __IDebugProcessDestroyEvent2_INTERFACE_DEFINED__

/* interface IDebugProcessDestroyEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProcessDestroyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e2a0832-17e1-4886-8c0e-204da242995f")
    IDebugProcessDestroyEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugProcessDestroyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProcessDestroyEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProcessDestroyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProcessDestroyEvent2 * This);
        
        END_INTERFACE
    } IDebugProcessDestroyEvent2Vtbl;

    interface IDebugProcessDestroyEvent2
    {
        CONST_VTBL struct IDebugProcessDestroyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProcessDestroyEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProcessDestroyEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProcessDestroyEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugProcessDestroyEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramCreateEvent2_INTERFACE_DEFINED__
#define __IDebugProgramCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugProgramCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProgramCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96cd11ee-ecd4-4e89-957e-b5d496fc4139")
    IDebugProgramCreateEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramCreateEvent2 * This);
        
        END_INTERFACE
    } IDebugProgramCreateEvent2Vtbl;

    interface IDebugProgramCreateEvent2
    {
        CONST_VTBL struct IDebugProgramCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugProgramCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramDestroyEvent2_INTERFACE_DEFINED__
#define __IDebugProgramDestroyEvent2_INTERFACE_DEFINED__

/* interface IDebugProgramDestroyEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProgramDestroyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e147e9e3-6440-4073-a7b7-a65592c714b5")
    IDebugProgramDestroyEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExitCode( 
            /* [out] */ DWORD *pdwExit) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramDestroyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramDestroyEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramDestroyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramDestroyEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExitCode )( 
            IDebugProgramDestroyEvent2 * This,
            /* [out] */ DWORD *pdwExit);
        
        END_INTERFACE
    } IDebugProgramDestroyEvent2Vtbl;

    interface IDebugProgramDestroyEvent2
    {
        CONST_VTBL struct IDebugProgramDestroyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramDestroyEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramDestroyEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramDestroyEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProgramDestroyEvent2_GetExitCode(This,pdwExit)	\
    (This)->lpVtbl -> GetExitCode(This,pdwExit)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProgramDestroyEvent2_GetExitCode_Proxy( 
    IDebugProgramDestroyEvent2 * This,
    /* [out] */ DWORD *pdwExit);


void __RPC_STUB IDebugProgramDestroyEvent2_GetExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProgramDestroyEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugThreadCreateEvent2_INTERFACE_DEFINED__
#define __IDebugThreadCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugThreadCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2090ccfc-70c5-491d-a5e8-bad2dd9ee3ea")
    IDebugThreadCreateEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugThreadCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThreadCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThreadCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThreadCreateEvent2 * This);
        
        END_INTERFACE
    } IDebugThreadCreateEvent2Vtbl;

    interface IDebugThreadCreateEvent2
    {
        CONST_VTBL struct IDebugThreadCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThreadCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugThreadCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugThreadCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugThreadDestroyEvent2_INTERFACE_DEFINED__
#define __IDebugThreadDestroyEvent2_INTERFACE_DEFINED__

/* interface IDebugThreadDestroyEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadDestroyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c3b7532-a36f-4a6e-9072-49be649b8541")
    IDebugThreadDestroyEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExitCode( 
            /* [out] */ DWORD *pdwExit) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugThreadDestroyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThreadDestroyEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThreadDestroyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThreadDestroyEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExitCode )( 
            IDebugThreadDestroyEvent2 * This,
            /* [out] */ DWORD *pdwExit);
        
        END_INTERFACE
    } IDebugThreadDestroyEvent2Vtbl;

    interface IDebugThreadDestroyEvent2
    {
        CONST_VTBL struct IDebugThreadDestroyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadDestroyEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThreadDestroyEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugThreadDestroyEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugThreadDestroyEvent2_GetExitCode(This,pdwExit)	\
    (This)->lpVtbl -> GetExitCode(This,pdwExit)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugThreadDestroyEvent2_GetExitCode_Proxy( 
    IDebugThreadDestroyEvent2 * This,
    /* [out] */ DWORD *pdwExit);


void __RPC_STUB IDebugThreadDestroyEvent2_GetExitCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugThreadDestroyEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugLoadCompleteEvent2_INTERFACE_DEFINED__
#define __IDebugLoadCompleteEvent2_INTERFACE_DEFINED__

/* interface IDebugLoadCompleteEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugLoadCompleteEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b1844850-1349-45d4-9f12-495212f5eb0b")
    IDebugLoadCompleteEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugLoadCompleteEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugLoadCompleteEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugLoadCompleteEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugLoadCompleteEvent2 * This);
        
        END_INTERFACE
    } IDebugLoadCompleteEvent2Vtbl;

    interface IDebugLoadCompleteEvent2
    {
        CONST_VTBL struct IDebugLoadCompleteEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugLoadCompleteEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugLoadCompleteEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugLoadCompleteEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugLoadCompleteEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugEntryPointEvent2_INTERFACE_DEFINED__
#define __IDebugEntryPointEvent2_INTERFACE_DEFINED__

/* interface IDebugEntryPointEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugEntryPointEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8414a3e-1642-48ec-829e-5f4040e16da9")
    IDebugEntryPointEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugEntryPointEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEntryPointEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEntryPointEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEntryPointEvent2 * This);
        
        END_INTERFACE
    } IDebugEntryPointEvent2Vtbl;

    interface IDebugEntryPointEvent2
    {
        CONST_VTBL struct IDebugEntryPointEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEntryPointEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEntryPointEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEntryPointEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugEntryPointEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugStepCompleteEvent2_INTERFACE_DEFINED__
#define __IDebugStepCompleteEvent2_INTERFACE_DEFINED__

/* interface IDebugStepCompleteEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStepCompleteEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f7f24c1-74d9-4ea6-a3ea-7edb2d81441d")
    IDebugStepCompleteEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugStepCompleteEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStepCompleteEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStepCompleteEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStepCompleteEvent2 * This);
        
        END_INTERFACE
    } IDebugStepCompleteEvent2Vtbl;

    interface IDebugStepCompleteEvent2
    {
        CONST_VTBL struct IDebugStepCompleteEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStepCompleteEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStepCompleteEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugStepCompleteEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugStepCompleteEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugCanStopEvent2_INTERFACE_DEFINED__
#define __IDebugCanStopEvent2_INTERFACE_DEFINED__

/* interface IDebugCanStopEvent2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugCanStopEvent2_0001
    {	CANSTOP_ENTRYPOINT	= 0,
	CANSTOP_STEPIN	= 0x1
    } ;
typedef DWORD CANSTOP_REASON;


EXTERN_C const IID IID_IDebugCanStopEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5b0d747-d4d2-4e2d-872d-74da22037826")
    IDebugCanStopEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReason( 
            /* [out] */ CANSTOP_REASON *pcr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStop( 
            /* [in] */ BOOL fCanStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext2 **ppDocCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeContext( 
            /* [out] */ IDebugCodeContext2 **ppCodeContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugCanStopEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugCanStopEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugCanStopEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugCanStopEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReason )( 
            IDebugCanStopEvent2 * This,
            /* [out] */ CANSTOP_REASON *pcr);
        
        HRESULT ( STDMETHODCALLTYPE *CanStop )( 
            IDebugCanStopEvent2 * This,
            /* [in] */ BOOL fCanStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IDebugCanStopEvent2 * This,
            /* [out] */ IDebugDocumentContext2 **ppDocCxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeContext )( 
            IDebugCanStopEvent2 * This,
            /* [out] */ IDebugCodeContext2 **ppCodeContext);
        
        END_INTERFACE
    } IDebugCanStopEvent2Vtbl;

    interface IDebugCanStopEvent2
    {
        CONST_VTBL struct IDebugCanStopEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCanStopEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugCanStopEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugCanStopEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugCanStopEvent2_GetReason(This,pcr)	\
    (This)->lpVtbl -> GetReason(This,pcr)

#define IDebugCanStopEvent2_CanStop(This,fCanStop)	\
    (This)->lpVtbl -> CanStop(This,fCanStop)

#define IDebugCanStopEvent2_GetDocumentContext(This,ppDocCxt)	\
    (This)->lpVtbl -> GetDocumentContext(This,ppDocCxt)

#define IDebugCanStopEvent2_GetCodeContext(This,ppCodeContext)	\
    (This)->lpVtbl -> GetCodeContext(This,ppCodeContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugCanStopEvent2_GetReason_Proxy( 
    IDebugCanStopEvent2 * This,
    /* [out] */ CANSTOP_REASON *pcr);


void __RPC_STUB IDebugCanStopEvent2_GetReason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugCanStopEvent2_CanStop_Proxy( 
    IDebugCanStopEvent2 * This,
    /* [in] */ BOOL fCanStop);


void __RPC_STUB IDebugCanStopEvent2_CanStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugCanStopEvent2_GetDocumentContext_Proxy( 
    IDebugCanStopEvent2 * This,
    /* [out] */ IDebugDocumentContext2 **ppDocCxt);


void __RPC_STUB IDebugCanStopEvent2_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugCanStopEvent2_GetCodeContext_Proxy( 
    IDebugCanStopEvent2 * This,
    /* [out] */ IDebugCodeContext2 **ppCodeContext);


void __RPC_STUB IDebugCanStopEvent2_GetCodeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugCanStopEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugBreakEvent2_INTERFACE_DEFINED__
#define __IDebugBreakEvent2_INTERFACE_DEFINED__

/* interface IDebugBreakEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7405d1d-e24b-44e0-b707-d8a5a4e1641b")
    IDebugBreakEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakEvent2 * This);
        
        END_INTERFACE
    } IDebugBreakEvent2Vtbl;

    interface IDebugBreakEvent2
    {
        CONST_VTBL struct IDebugBreakEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugBreakEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugBreakpointEvent2_INTERFACE_DEFINED__
#define __IDebugBreakpointEvent2_INTERFACE_DEFINED__

/* interface IDebugBreakpointEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakpointEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("501c1e21-c557-48b8-ba30-a1eab0bc4a74")
    IDebugBreakpointEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumBreakpoints( 
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBreakpoints )( 
            IDebugBreakpointEvent2 * This,
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);
        
        END_INTERFACE
    } IDebugBreakpointEvent2Vtbl;

    interface IDebugBreakpointEvent2
    {
        CONST_VTBL struct IDebugBreakpointEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointEvent2_EnumBreakpoints(This,ppEnum)	\
    (This)->lpVtbl -> EnumBreakpoints(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointEvent2_EnumBreakpoints_Proxy( 
    IDebugBreakpointEvent2 * This,
    /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);


void __RPC_STUB IDebugBreakpointEvent2_EnumBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugExceptionEvent2_INTERFACE_DEFINED__
#define __IDebugExceptionEvent2_INTERFACE_DEFINED__

/* interface IDebugExceptionEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExceptionEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51a94113-8788-4a54-ae15-08b74ff922d0")
    IDebugExceptionEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetException( 
            /* [out] */ EXCEPTION_INFO *pExceptionInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExceptionDescription( 
            /* [out] */ BSTR *pbstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanPassToDebuggee( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PassToDebuggee( 
            /* [in] */ BOOL fPass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExceptionEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExceptionEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExceptionEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExceptionEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetException )( 
            IDebugExceptionEvent2 * This,
            /* [out] */ EXCEPTION_INFO *pExceptionInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetExceptionDescription )( 
            IDebugExceptionEvent2 * This,
            /* [out] */ BSTR *pbstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE *CanPassToDebuggee )( 
            IDebugExceptionEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *PassToDebuggee )( 
            IDebugExceptionEvent2 * This,
            /* [in] */ BOOL fPass);
        
        END_INTERFACE
    } IDebugExceptionEvent2Vtbl;

    interface IDebugExceptionEvent2
    {
        CONST_VTBL struct IDebugExceptionEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExceptionEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExceptionEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExceptionEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExceptionEvent2_GetException(This,pExceptionInfo)	\
    (This)->lpVtbl -> GetException(This,pExceptionInfo)

#define IDebugExceptionEvent2_GetExceptionDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> GetExceptionDescription(This,pbstrDescription)

#define IDebugExceptionEvent2_CanPassToDebuggee(This)	\
    (This)->lpVtbl -> CanPassToDebuggee(This)

#define IDebugExceptionEvent2_PassToDebuggee(This,fPass)	\
    (This)->lpVtbl -> PassToDebuggee(This,fPass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExceptionEvent2_GetException_Proxy( 
    IDebugExceptionEvent2 * This,
    /* [out] */ EXCEPTION_INFO *pExceptionInfo);


void __RPC_STUB IDebugExceptionEvent2_GetException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExceptionEvent2_GetExceptionDescription_Proxy( 
    IDebugExceptionEvent2 * This,
    /* [out] */ BSTR *pbstrDescription);


void __RPC_STUB IDebugExceptionEvent2_GetExceptionDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExceptionEvent2_CanPassToDebuggee_Proxy( 
    IDebugExceptionEvent2 * This);


void __RPC_STUB IDebugExceptionEvent2_CanPassToDebuggee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExceptionEvent2_PassToDebuggee_Proxy( 
    IDebugExceptionEvent2 * This,
    /* [in] */ BOOL fPass);


void __RPC_STUB IDebugExceptionEvent2_PassToDebuggee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExceptionEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugOutputStringEvent2_INTERFACE_DEFINED__
#define __IDebugOutputStringEvent2_INTERFACE_DEFINED__

/* interface IDebugOutputStringEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugOutputStringEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("569c4bb1-7b82-46fc-ae28-4536ddad753e")
    IDebugOutputStringEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [out] */ BSTR *pbstrString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugOutputStringEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugOutputStringEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugOutputStringEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugOutputStringEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IDebugOutputStringEvent2 * This,
            /* [out] */ BSTR *pbstrString);
        
        END_INTERFACE
    } IDebugOutputStringEvent2Vtbl;

    interface IDebugOutputStringEvent2
    {
        CONST_VTBL struct IDebugOutputStringEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugOutputStringEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugOutputStringEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugOutputStringEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugOutputStringEvent2_GetString(This,pbstrString)	\
    (This)->lpVtbl -> GetString(This,pbstrString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugOutputStringEvent2_GetString_Proxy( 
    IDebugOutputStringEvent2 * This,
    /* [out] */ BSTR *pbstrString);


void __RPC_STUB IDebugOutputStringEvent2_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugOutputStringEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugModuleLoadEvent2_INTERFACE_DEFINED__
#define __IDebugModuleLoadEvent2_INTERFACE_DEFINED__

/* interface IDebugModuleLoadEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugModuleLoadEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("989db083-0d7c-40d1-a9d9-921bf611a4b2")
    IDebugModuleLoadEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ IDebugModule2 **pModule,
            /* [out][in] */ BSTR *pbstrDebugMessage,
            /* [out][in] */ BOOL *pbLoad) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugModuleLoadEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugModuleLoadEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugModuleLoadEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugModuleLoadEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            IDebugModuleLoadEvent2 * This,
            /* [out] */ IDebugModule2 **pModule,
            /* [out][in] */ BSTR *pbstrDebugMessage,
            /* [out][in] */ BOOL *pbLoad);
        
        END_INTERFACE
    } IDebugModuleLoadEvent2Vtbl;

    interface IDebugModuleLoadEvent2
    {
        CONST_VTBL struct IDebugModuleLoadEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugModuleLoadEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugModuleLoadEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugModuleLoadEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugModuleLoadEvent2_GetModule(This,pModule,pbstrDebugMessage,pbLoad)	\
    (This)->lpVtbl -> GetModule(This,pModule,pbstrDebugMessage,pbLoad)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugModuleLoadEvent2_GetModule_Proxy( 
    IDebugModuleLoadEvent2 * This,
    /* [out] */ IDebugModule2 **pModule,
    /* [out][in] */ BSTR *pbstrDebugMessage,
    /* [out][in] */ BOOL *pbLoad);


void __RPC_STUB IDebugModuleLoadEvent2_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugModuleLoadEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyCreateEvent2_INTERFACE_DEFINED__
#define __IDebugPropertyCreateEvent2_INTERFACE_DEFINED__

/* interface IDebugPropertyCreateEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyCreateEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ded6d613-a3db-4e35-bb5b-a92391133f03")
    IDebugPropertyCreateEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ IDebugProperty2 **ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyCreateEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyCreateEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyCreateEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyCreateEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugProperty )( 
            IDebugPropertyCreateEvent2 * This,
            /* [out] */ IDebugProperty2 **ppProperty);
        
        END_INTERFACE
    } IDebugPropertyCreateEvent2Vtbl;

    interface IDebugPropertyCreateEvent2
    {
        CONST_VTBL struct IDebugPropertyCreateEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyCreateEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyCreateEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyCreateEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyCreateEvent2_GetDebugProperty(This,ppProperty)	\
    (This)->lpVtbl -> GetDebugProperty(This,ppProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyCreateEvent2_GetDebugProperty_Proxy( 
    IDebugPropertyCreateEvent2 * This,
    /* [out] */ IDebugProperty2 **ppProperty);


void __RPC_STUB IDebugPropertyCreateEvent2_GetDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyCreateEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyDestroyEvent2_INTERFACE_DEFINED__
#define __IDebugPropertyDestroyEvent2_INTERFACE_DEFINED__

/* interface IDebugPropertyDestroyEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyDestroyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f3765f18-f395-4b8c-8e95-dcb3fe8e7ec8")
    IDebugPropertyDestroyEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ IDebugProperty2 **ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyDestroyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPropertyDestroyEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPropertyDestroyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPropertyDestroyEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugProperty )( 
            IDebugPropertyDestroyEvent2 * This,
            /* [out] */ IDebugProperty2 **ppProperty);
        
        END_INTERFACE
    } IDebugPropertyDestroyEvent2Vtbl;

    interface IDebugPropertyDestroyEvent2
    {
        CONST_VTBL struct IDebugPropertyDestroyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyDestroyEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyDestroyEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyDestroyEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyDestroyEvent2_GetDebugProperty(This,ppProperty)	\
    (This)->lpVtbl -> GetDebugProperty(This,ppProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyDestroyEvent2_GetDebugProperty_Proxy( 
    IDebugPropertyDestroyEvent2 * This,
    /* [out] */ IDebugProperty2 **ppProperty);


void __RPC_STUB IDebugPropertyDestroyEvent2_GetDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyDestroyEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugBreakpointBoundEvent2_INTERFACE_DEFINED__
#define __IDebugBreakpointBoundEvent2_INTERFACE_DEFINED__

/* interface IDebugBreakpointBoundEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakpointBoundEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1dddb704-cf99-4b8a-b746-dabb01dd13a0")
    IDebugBreakpointBoundEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPendingBreakpoint( 
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBoundBreakpoints( 
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointBoundEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointBoundEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointBoundEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointBoundEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingBreakpoint )( 
            IDebugBreakpointBoundEvent2 * This,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBoundBreakpoints )( 
            IDebugBreakpointBoundEvent2 * This,
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);
        
        END_INTERFACE
    } IDebugBreakpointBoundEvent2Vtbl;

    interface IDebugBreakpointBoundEvent2
    {
        CONST_VTBL struct IDebugBreakpointBoundEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointBoundEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointBoundEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointBoundEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointBoundEvent2_GetPendingBreakpoint(This,ppPendingBP)	\
    (This)->lpVtbl -> GetPendingBreakpoint(This,ppPendingBP)

#define IDebugBreakpointBoundEvent2_EnumBoundBreakpoints(This,ppEnum)	\
    (This)->lpVtbl -> EnumBoundBreakpoints(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointBoundEvent2_GetPendingBreakpoint_Proxy( 
    IDebugBreakpointBoundEvent2 * This,
    /* [out] */ IDebugPendingBreakpoint2 **ppPendingBP);


void __RPC_STUB IDebugBreakpointBoundEvent2_GetPendingBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBreakpointBoundEvent2_EnumBoundBreakpoints_Proxy( 
    IDebugBreakpointBoundEvent2 * This,
    /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);


void __RPC_STUB IDebugBreakpointBoundEvent2_EnumBoundBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointBoundEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugBreakpointUnboundEvent2_INTERFACE_DEFINED__
#define __IDebugBreakpointUnboundEvent2_INTERFACE_DEFINED__

/* interface IDebugBreakpointUnboundEvent2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugBreakpointUnboundEvent2_0001
    {	BPUR_UNKNOWN	= 0x1,
	BPUR_CODE_UNLOADED	= 0x2,
	BPUR_BREAKPOINT_REBIND	= 0x3,
	BPUR_BREAKPOINT_ERROR	= 0x4
    } ;
typedef DWORD BP_UNBOUND_REASON;


EXTERN_C const IID IID_IDebugBreakpointUnboundEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78d1db4f-c557-4dc5-a2dd-5369d21b1c8c")
    IDebugBreakpointUnboundEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBreakpoint( 
            /* [out] */ IDebugBoundBreakpoint2 **ppBP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReason( 
            /* [out] */ BP_UNBOUND_REASON *pdwUnboundReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointUnboundEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointUnboundEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointUnboundEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointUnboundEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpoint )( 
            IDebugBreakpointUnboundEvent2 * This,
            /* [out] */ IDebugBoundBreakpoint2 **ppBP);
        
        HRESULT ( STDMETHODCALLTYPE *GetReason )( 
            IDebugBreakpointUnboundEvent2 * This,
            /* [out] */ BP_UNBOUND_REASON *pdwUnboundReason);
        
        END_INTERFACE
    } IDebugBreakpointUnboundEvent2Vtbl;

    interface IDebugBreakpointUnboundEvent2
    {
        CONST_VTBL struct IDebugBreakpointUnboundEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointUnboundEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointUnboundEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointUnboundEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointUnboundEvent2_GetBreakpoint(This,ppBP)	\
    (This)->lpVtbl -> GetBreakpoint(This,ppBP)

#define IDebugBreakpointUnboundEvent2_GetReason(This,pdwUnboundReason)	\
    (This)->lpVtbl -> GetReason(This,pdwUnboundReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointUnboundEvent2_GetBreakpoint_Proxy( 
    IDebugBreakpointUnboundEvent2 * This,
    /* [out] */ IDebugBoundBreakpoint2 **ppBP);


void __RPC_STUB IDebugBreakpointUnboundEvent2_GetBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBreakpointUnboundEvent2_GetReason_Proxy( 
    IDebugBreakpointUnboundEvent2 * This,
    /* [out] */ BP_UNBOUND_REASON *pdwUnboundReason);


void __RPC_STUB IDebugBreakpointUnboundEvent2_GetReason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointUnboundEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugBreakpointErrorEvent2_INTERFACE_DEFINED__
#define __IDebugBreakpointErrorEvent2_INTERFACE_DEFINED__

/* interface IDebugBreakpointErrorEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakpointErrorEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("abb0ca42-f82b-4622-84e4-6903ae90f210")
    IDebugBreakpointErrorEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorBreakpoint( 
            /* [out] */ IDebugErrorBreakpoint2 **ppErrorBP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointErrorEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointErrorEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointErrorEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointErrorEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorBreakpoint )( 
            IDebugBreakpointErrorEvent2 * This,
            /* [out] */ IDebugErrorBreakpoint2 **ppErrorBP);
        
        END_INTERFACE
    } IDebugBreakpointErrorEvent2Vtbl;

    interface IDebugBreakpointErrorEvent2
    {
        CONST_VTBL struct IDebugBreakpointErrorEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointErrorEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointErrorEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointErrorEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointErrorEvent2_GetErrorBreakpoint(This,ppErrorBP)	\
    (This)->lpVtbl -> GetErrorBreakpoint(This,ppErrorBP)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointErrorEvent2_GetErrorBreakpoint_Proxy( 
    IDebugBreakpointErrorEvent2 * This,
    /* [out] */ IDebugErrorBreakpoint2 **ppErrorBP);


void __RPC_STUB IDebugBreakpointErrorEvent2_GetErrorBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointErrorEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionEvaluationCompleteEvent2_INTERFACE_DEFINED__
#define __IDebugExpressionEvaluationCompleteEvent2_INTERFACE_DEFINED__

/* interface IDebugExpressionEvaluationCompleteEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpressionEvaluationCompleteEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0e13a85-238a-4800-8315-d947c960a843")
    IDebugExpressionEvaluationCompleteEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExpression( 
            /* [out] */ IDebugExpression2 **ppExpr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ IDebugProperty2 **ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpressionEvaluationCompleteEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpressionEvaluationCompleteEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpressionEvaluationCompleteEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpressionEvaluationCompleteEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpression )( 
            IDebugExpressionEvaluationCompleteEvent2 * This,
            /* [out] */ IDebugExpression2 **ppExpr);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IDebugExpressionEvaluationCompleteEvent2 * This,
            /* [out] */ IDebugProperty2 **ppResult);
        
        END_INTERFACE
    } IDebugExpressionEvaluationCompleteEvent2Vtbl;

    interface IDebugExpressionEvaluationCompleteEvent2
    {
        CONST_VTBL struct IDebugExpressionEvaluationCompleteEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionEvaluationCompleteEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpressionEvaluationCompleteEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpressionEvaluationCompleteEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExpressionEvaluationCompleteEvent2_GetExpression(This,ppExpr)	\
    (This)->lpVtbl -> GetExpression(This,ppExpr)

#define IDebugExpressionEvaluationCompleteEvent2_GetResult(This,ppResult)	\
    (This)->lpVtbl -> GetResult(This,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpressionEvaluationCompleteEvent2_GetExpression_Proxy( 
    IDebugExpressionEvaluationCompleteEvent2 * This,
    /* [out] */ IDebugExpression2 **ppExpr);


void __RPC_STUB IDebugExpressionEvaluationCompleteEvent2_GetExpression_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpressionEvaluationCompleteEvent2_GetResult_Proxy( 
    IDebugExpressionEvaluationCompleteEvent2 * This,
    /* [out] */ IDebugProperty2 **ppResult);


void __RPC_STUB IDebugExpressionEvaluationCompleteEvent2_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExpressionEvaluationCompleteEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugReturnValueEvent2_INTERFACE_DEFINED__
#define __IDebugReturnValueEvent2_INTERFACE_DEFINED__

/* interface IDebugReturnValueEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugReturnValueEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0da4d4cc-2d0b-410f-8d5d-b6b73a5d35d8")
    IDebugReturnValueEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReturnValue( 
            /* [out] */ IDebugProperty2 **ppReturnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugReturnValueEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugReturnValueEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugReturnValueEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugReturnValueEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnValue )( 
            IDebugReturnValueEvent2 * This,
            /* [out] */ IDebugProperty2 **ppReturnValue);
        
        END_INTERFACE
    } IDebugReturnValueEvent2Vtbl;

    interface IDebugReturnValueEvent2
    {
        CONST_VTBL struct IDebugReturnValueEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugReturnValueEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugReturnValueEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugReturnValueEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugReturnValueEvent2_GetReturnValue(This,ppReturnValue)	\
    (This)->lpVtbl -> GetReturnValue(This,ppReturnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugReturnValueEvent2_GetReturnValue_Proxy( 
    IDebugReturnValueEvent2 * This,
    /* [out] */ IDebugProperty2 **ppReturnValue);


void __RPC_STUB IDebugReturnValueEvent2_GetReturnValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugReturnValueEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugFindSymbolEvent2_INTERFACE_DEFINED__
#define __IDebugFindSymbolEvent2_INTERFACE_DEFINED__

/* interface IDebugFindSymbolEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugFindSymbolEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4072ae37-3739-43c9-ac88-ca2ea79ed32b")
    IDebugFindSymbolEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SearchWithPath( 
            /* [in] */ LPCOLESTR pszSymbolSearchURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugFindSymbolEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugFindSymbolEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugFindSymbolEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugFindSymbolEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SearchWithPath )( 
            IDebugFindSymbolEvent2 * This,
            /* [in] */ LPCOLESTR pszSymbolSearchURL);
        
        END_INTERFACE
    } IDebugFindSymbolEvent2Vtbl;

    interface IDebugFindSymbolEvent2
    {
        CONST_VTBL struct IDebugFindSymbolEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugFindSymbolEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugFindSymbolEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugFindSymbolEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugFindSymbolEvent2_SearchWithPath(This,pszSymbolSearchURL)	\
    (This)->lpVtbl -> SearchWithPath(This,pszSymbolSearchURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugFindSymbolEvent2_SearchWithPath_Proxy( 
    IDebugFindSymbolEvent2 * This,
    /* [in] */ LPCOLESTR pszSymbolSearchURL);


void __RPC_STUB IDebugFindSymbolEvent2_SearchWithPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugFindSymbolEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugNoSymbolsEvent2_INTERFACE_DEFINED__
#define __IDebugNoSymbolsEvent2_INTERFACE_DEFINED__

/* interface IDebugNoSymbolsEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugNoSymbolsEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ad4fb48-647e-4b03-9c1e-52754e80c880")
    IDebugNoSymbolsEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugNoSymbolsEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugNoSymbolsEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugNoSymbolsEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugNoSymbolsEvent2 * This);
        
        END_INTERFACE
    } IDebugNoSymbolsEvent2Vtbl;

    interface IDebugNoSymbolsEvent2
    {
        CONST_VTBL struct IDebugNoSymbolsEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugNoSymbolsEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugNoSymbolsEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugNoSymbolsEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugNoSymbolsEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramNameChangedEvent2_INTERFACE_DEFINED__
#define __IDebugProgramNameChangedEvent2_INTERFACE_DEFINED__

/* interface IDebugProgramNameChangedEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProgramNameChangedEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e05c2dfd-59d5-46d3-a71c-5d07665d85af")
    IDebugProgramNameChangedEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramNameChangedEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramNameChangedEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramNameChangedEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramNameChangedEvent2 * This);
        
        END_INTERFACE
    } IDebugProgramNameChangedEvent2Vtbl;

    interface IDebugProgramNameChangedEvent2
    {
        CONST_VTBL struct IDebugProgramNameChangedEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramNameChangedEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramNameChangedEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramNameChangedEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugProgramNameChangedEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugThreadNameChangedEvent2_INTERFACE_DEFINED__
#define __IDebugThreadNameChangedEvent2_INTERFACE_DEFINED__

/* interface IDebugThreadNameChangedEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadNameChangedEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ef4ef78-2c44-4b7a-8473-8f4357611729")
    IDebugThreadNameChangedEvent2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugThreadNameChangedEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThreadNameChangedEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThreadNameChangedEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThreadNameChangedEvent2 * This);
        
        END_INTERFACE
    } IDebugThreadNameChangedEvent2Vtbl;

    interface IDebugThreadNameChangedEvent2
    {
        CONST_VTBL struct IDebugThreadNameChangedEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadNameChangedEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThreadNameChangedEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugThreadNameChangedEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugThreadNameChangedEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugMessageEvent2_INTERFACE_DEFINED__
#define __IDebugMessageEvent2_INTERFACE_DEFINED__

/* interface IDebugMessageEvent2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugMessageEvent2_0001
    {	MT_OUTPUTSTRING	= 0x1,
	MT_MESSAGEBOX	= 0x2
    } ;
typedef DWORD MESSAGETYPE;


EXTERN_C const IID IID_IDebugMessageEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3bdb28cf-dbd2-4d24-af03-01072b67eb9e")
    IDebugMessageEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMessage( 
            /* [out] */ MESSAGETYPE *pMessageType,
            /* [out] */ BSTR *pbstrMessage,
            /* [out] */ DWORD *pdwType,
            /* [out] */ BSTR *pbstrHelpFileName,
            /* [out] */ DWORD *pdwHelpId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResponse( 
            /* [in] */ DWORD dwResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMessageEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMessageEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMessageEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMessageEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessage )( 
            IDebugMessageEvent2 * This,
            /* [out] */ MESSAGETYPE *pMessageType,
            /* [out] */ BSTR *pbstrMessage,
            /* [out] */ DWORD *pdwType,
            /* [out] */ BSTR *pbstrHelpFileName,
            /* [out] */ DWORD *pdwHelpId);
        
        HRESULT ( STDMETHODCALLTYPE *SetResponse )( 
            IDebugMessageEvent2 * This,
            /* [in] */ DWORD dwResponse);
        
        END_INTERFACE
    } IDebugMessageEvent2Vtbl;

    interface IDebugMessageEvent2
    {
        CONST_VTBL struct IDebugMessageEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMessageEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMessageEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMessageEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMessageEvent2_GetMessage(This,pMessageType,pbstrMessage,pdwType,pbstrHelpFileName,pdwHelpId)	\
    (This)->lpVtbl -> GetMessage(This,pMessageType,pbstrMessage,pdwType,pbstrHelpFileName,pdwHelpId)

#define IDebugMessageEvent2_SetResponse(This,dwResponse)	\
    (This)->lpVtbl -> SetResponse(This,dwResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMessageEvent2_GetMessage_Proxy( 
    IDebugMessageEvent2 * This,
    /* [out] */ MESSAGETYPE *pMessageType,
    /* [out] */ BSTR *pbstrMessage,
    /* [out] */ DWORD *pdwType,
    /* [out] */ BSTR *pbstrHelpFileName,
    /* [out] */ DWORD *pdwHelpId);


void __RPC_STUB IDebugMessageEvent2_GetMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMessageEvent2_SetResponse_Proxy( 
    IDebugMessageEvent2 * This,
    /* [in] */ DWORD dwResponse);


void __RPC_STUB IDebugMessageEvent2_SetResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMessageEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugActivateDocumentEvent2_INTERFACE_DEFINED__
#define __IDebugActivateDocumentEvent2_INTERFACE_DEFINED__

/* interface IDebugActivateDocumentEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugActivateDocumentEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58f36c3d-7d07-4eba-a041-62f63e188037")
    IDebugActivateDocumentEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IDebugDocument2 **ppDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext2 **ppDocContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugActivateDocumentEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugActivateDocumentEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugActivateDocumentEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugActivateDocumentEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugActivateDocumentEvent2 * This,
            /* [out] */ IDebugDocument2 **ppDoc);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IDebugActivateDocumentEvent2 * This,
            /* [out] */ IDebugDocumentContext2 **ppDocContext);
        
        END_INTERFACE
    } IDebugActivateDocumentEvent2Vtbl;

    interface IDebugActivateDocumentEvent2
    {
        CONST_VTBL struct IDebugActivateDocumentEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugActivateDocumentEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugActivateDocumentEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugActivateDocumentEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugActivateDocumentEvent2_GetDocument(This,ppDoc)	\
    (This)->lpVtbl -> GetDocument(This,ppDoc)

#define IDebugActivateDocumentEvent2_GetDocumentContext(This,ppDocContext)	\
    (This)->lpVtbl -> GetDocumentContext(This,ppDocContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugActivateDocumentEvent2_GetDocument_Proxy( 
    IDebugActivateDocumentEvent2 * This,
    /* [out] */ IDebugDocument2 **ppDoc);


void __RPC_STUB IDebugActivateDocumentEvent2_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugActivateDocumentEvent2_GetDocumentContext_Proxy( 
    IDebugActivateDocumentEvent2 * This,
    /* [out] */ IDebugDocumentContext2 **ppDocContext);


void __RPC_STUB IDebugActivateDocumentEvent2_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugActivateDocumentEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugProcess2_INTERFACE_DEFINED__
#define __IDebugProcess2_INTERFACE_DEFINED__

/* interface IDebugProcess2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugProcess2_0001
    {	PIFLAG_SYSTEM_PROCESS	= 0x1,
	PIFLAG_DEBUGGER_ATTACHED	= 0x2
    } ;
typedef DWORD PROCESS_INFO_FLAGS;


enum __MIDL_IDebugProcess2_0002
    {	PIF_FILE_NAME	= 0x1,
	PIF_BASE_NAME	= 0x2,
	PIF_TITLE	= 0x4,
	PIF_PROCESS_ID	= 0x8,
	PIF_SESSION_ID	= 0x10,
	PIF_ATTACHED_SESSION_NAME	= 0x20,
	PIF_CREATION_TIME	= 0x40,
	PIF_FLAGS	= 0x80,
	PIF_ALL	= 0xff
    } ;
typedef DWORD PROCESS_INFO_FIELDS;

typedef struct tagPROCESS_INFO
    {
    PROCESS_INFO_FIELDS Fields;
    BSTR bstrFileName;
    BSTR bstrBaseName;
    BSTR bstrTitle;
    AD_PROCESS_ID ProcessId;
    DWORD dwSessionId;
    BSTR bstrAttachedSessionName;
    FILETIME CreationTime;
    PROCESS_INFO_FLAGS Flags;
    } 	PROCESS_INFO;


EXTERN_C const IID IID_IDebugProcess2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43286fea-6997-4543-803e-60a20c473de5")
    IDebugProcess2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ PROCESS_INFO_FIELDS Fields,
            /* [out] */ PROCESS_INFO *pProcessInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPrograms( 
            /* [out] */ IEnumDebugPrograms2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMachine( 
            /* [out] */ IDebugMachine2 **ppMachine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [length_is][size_is][out] */ HRESULT *rghrEngineAttach) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPhysicalProcessId( 
            /* [out] */ AD_PROCESS_ID *pProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessId( 
            /* [out] */ GUID *pguidProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttachedSessionName( 
            /* [out] */ BSTR *pbstrSessionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumThreads( 
            /* [out] */ IEnumDebugThreads2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ IDebugPort2 **ppPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProcess2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProcess2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProcess2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugProcess2 * This,
            /* [in] */ PROCESS_INFO_FIELDS Fields,
            /* [out] */ PROCESS_INFO *pProcessInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPrograms )( 
            IDebugProcess2 * This,
            /* [out] */ IEnumDebugPrograms2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugProcess2 * This,
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachine )( 
            IDebugProcess2 * This,
            /* [out] */ IDebugMachine2 **ppMachine);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugProcess2 * This,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [size_is][in] */ GUID *rgguidSpecificEngines,
            /* [in] */ DWORD celtSpecificEngines,
            /* [length_is][size_is][out] */ HRESULT *rghrEngineAttach);
        
        HRESULT ( STDMETHODCALLTYPE *CanDetach )( 
            IDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhysicalProcessId )( 
            IDebugProcess2 * This,
            /* [out] */ AD_PROCESS_ID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessId )( 
            IDebugProcess2 * This,
            /* [out] */ GUID *pguidProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttachedSessionName )( 
            IDebugProcess2 * This,
            /* [out] */ BSTR *pbstrSessionName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumThreads )( 
            IDebugProcess2 * This,
            /* [out] */ IEnumDebugThreads2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IDebugProcess2 * This,
            /* [out] */ IDebugPort2 **ppPort);
        
        END_INTERFACE
    } IDebugProcess2Vtbl;

    interface IDebugProcess2
    {
        CONST_VTBL struct IDebugProcess2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProcess2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProcess2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProcess2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProcess2_GetInfo(This,Fields,pProcessInfo)	\
    (This)->lpVtbl -> GetInfo(This,Fields,pProcessInfo)

#define IDebugProcess2_EnumPrograms(This,ppEnum)	\
    (This)->lpVtbl -> EnumPrograms(This,ppEnum)

#define IDebugProcess2_GetName(This,gnType,pbstrName)	\
    (This)->lpVtbl -> GetName(This,gnType,pbstrName)

#define IDebugProcess2_GetMachine(This,ppMachine)	\
    (This)->lpVtbl -> GetMachine(This,ppMachine)

#define IDebugProcess2_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define IDebugProcess2_Attach(This,pCallback,rgguidSpecificEngines,celtSpecificEngines,rghrEngineAttach)	\
    (This)->lpVtbl -> Attach(This,pCallback,rgguidSpecificEngines,celtSpecificEngines,rghrEngineAttach)

#define IDebugProcess2_CanDetach(This)	\
    (This)->lpVtbl -> CanDetach(This)

#define IDebugProcess2_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IDebugProcess2_GetPhysicalProcessId(This,pProcessId)	\
    (This)->lpVtbl -> GetPhysicalProcessId(This,pProcessId)

#define IDebugProcess2_GetProcessId(This,pguidProcessId)	\
    (This)->lpVtbl -> GetProcessId(This,pguidProcessId)

#define IDebugProcess2_GetAttachedSessionName(This,pbstrSessionName)	\
    (This)->lpVtbl -> GetAttachedSessionName(This,pbstrSessionName)

#define IDebugProcess2_EnumThreads(This,ppEnum)	\
    (This)->lpVtbl -> EnumThreads(This,ppEnum)

#define IDebugProcess2_CauseBreak(This)	\
    (This)->lpVtbl -> CauseBreak(This)

#define IDebugProcess2_GetPort(This,ppPort)	\
    (This)->lpVtbl -> GetPort(This,ppPort)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProcess2_GetInfo_Proxy( 
    IDebugProcess2 * This,
    /* [in] */ PROCESS_INFO_FIELDS Fields,
    /* [out] */ PROCESS_INFO *pProcessInfo);


void __RPC_STUB IDebugProcess2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_EnumPrograms_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ IEnumDebugPrograms2 **ppEnum);


void __RPC_STUB IDebugProcess2_EnumPrograms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetName_Proxy( 
    IDebugProcess2 * This,
    /* [in] */ GETNAME_TYPE gnType,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugProcess2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetMachine_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ IDebugMachine2 **ppMachine);


void __RPC_STUB IDebugProcess2_GetMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_Terminate_Proxy( 
    IDebugProcess2 * This);


void __RPC_STUB IDebugProcess2_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_Attach_Proxy( 
    IDebugProcess2 * This,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [size_is][in] */ GUID *rgguidSpecificEngines,
    /* [in] */ DWORD celtSpecificEngines,
    /* [length_is][size_is][out] */ HRESULT *rghrEngineAttach);


void __RPC_STUB IDebugProcess2_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_CanDetach_Proxy( 
    IDebugProcess2 * This);


void __RPC_STUB IDebugProcess2_CanDetach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_Detach_Proxy( 
    IDebugProcess2 * This);


void __RPC_STUB IDebugProcess2_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetPhysicalProcessId_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ AD_PROCESS_ID *pProcessId);


void __RPC_STUB IDebugProcess2_GetPhysicalProcessId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetProcessId_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ GUID *pguidProcessId);


void __RPC_STUB IDebugProcess2_GetProcessId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetAttachedSessionName_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ BSTR *pbstrSessionName);


void __RPC_STUB IDebugProcess2_GetAttachedSessionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_EnumThreads_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ IEnumDebugThreads2 **ppEnum);


void __RPC_STUB IDebugProcess2_EnumThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_CauseBreak_Proxy( 
    IDebugProcess2 * This);


void __RPC_STUB IDebugProcess2_CauseBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProcess2_GetPort_Proxy( 
    IDebugProcess2 * This,
    /* [out] */ IDebugPort2 **ppPort);


void __RPC_STUB IDebugProcess2_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProcess2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgram2_INTERFACE_DEFINED__
#define __IDebugProgram2_INTERFACE_DEFINED__

/* interface IDebugProgram2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugProgram2_0001
    {	STEP_INTO	= 0,
	STEP_OVER	= STEP_INTO + 1,
	STEP_OUT	= STEP_OVER + 1,
	STEP_BACKWARDS	= STEP_OUT + 1
    } ;
typedef DWORD STEPKIND;


enum __MIDL_IDebugProgram2_0002
    {	STEP_STATEMENT	= 0,
	STEP_LINE	= STEP_STATEMENT + 1,
	STEP_INSTRUCTION	= STEP_LINE + 1
    } ;
typedef DWORD STEPUNIT;


enum __MIDL_IDebugProgram2_0003
    {	DSS_HUGE	= 0x10000000,
	DSS_FUNCTION	= 0x1,
	DSS_MODULE	= DSS_HUGE | 0x2,
	DSS_ALL	= DSS_HUGE | 0x3
    } ;
typedef DWORD DISASSEMBLY_STREAM_SCOPE;

typedef struct tagCODE_PATH
    {
    BSTR bstrName;
    IDebugCodeContext2 *pCode;
    } 	CODE_PATH;


enum __MIDL_IDebugProgram2_0004
    {	DUMP_MINIDUMP	= 0,
	DUMP_FULLDUMP	= DUMP_MINIDUMP + 1
    } ;
typedef DWORD DUMPTYPE;


EXTERN_C const IID IID_IDebugProgram2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d172ef-f2c4-44e1-89f7-c86231e706e9")
    IDebugProgram2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumThreads( 
            /* [out] */ IEnumDebugThreads2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ IDebugProcess2 **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugEventCallback2 *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgramId( 
            /* [out] */ GUID *pguidProgramId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ IDebugProperty2 **ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ IDebugThread2 *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( 
            /* [in] */ IDebugThread2 *pThread,
            /* [in] */ STEPKIND sk,
            /* [in] */ STEPUNIT step) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEngineInfo( 
            /* [out] */ BSTR *pbstrEngine,
            /* [out] */ GUID *pguidEngine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts( 
            /* [in] */ IDebugDocumentPosition2 *pDocPos,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryBytes( 
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisassemblyStream( 
            /* [in] */ DISASSEMBLY_STREAM_SCOPE dwScope,
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [out] */ IDebugDisassemblyStream2 **ppDisassemblyStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumModules( 
            /* [out] */ IEnumDebugModules2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetENCUpdate( 
            /* [out] */ IDebugENCUpdate **ppUpdate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodePaths( 
            /* [full][in] */ LPCOLESTR pszHint,
            /* [in] */ IDebugCodeContext2 *pStart,
            /* [in] */ IDebugStackFrame2 *pFrame,
            /* [in] */ BOOL fSource,
            /* [out] */ IEnumCodePaths2 **ppEnum,
            /* [out] */ IDebugCodeContext2 **ppSafety) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDump( 
            /* [in] */ DUMPTYPE DumpType,
            /* [in] */ LPCOLESTR pszDumpUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgram2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgram2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgram2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumThreads )( 
            IDebugProgram2 * This,
            /* [out] */ IEnumDebugThreads2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugProgram2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            IDebugProgram2 * This,
            /* [out] */ IDebugProcess2 **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugProgram2 * This,
            /* [in] */ IDebugEventCallback2 *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CanDetach )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgramId )( 
            IDebugProgram2 * This,
            /* [out] */ GUID *pguidProgramId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugProperty )( 
            IDebugProgram2 * This,
            /* [out] */ IDebugProperty2 **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IDebugProgram2 * This,
            /* [in] */ IDebugThread2 *pThread);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            IDebugProgram2 * This,
            /* [in] */ IDebugThread2 *pThread,
            /* [in] */ STEPKIND sk,
            /* [in] */ STEPUNIT step);
        
        HRESULT ( STDMETHODCALLTYPE *CauseBreak )( 
            IDebugProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEngineInfo )( 
            IDebugProgram2 * This,
            /* [out] */ BSTR *pbstrEngine,
            /* [out] */ GUID *pguidEngine);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContexts )( 
            IDebugProgram2 * This,
            /* [in] */ IDebugDocumentPosition2 *pDocPos,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryBytes )( 
            IDebugProgram2 * This,
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisassemblyStream )( 
            IDebugProgram2 * This,
            /* [in] */ DISASSEMBLY_STREAM_SCOPE dwScope,
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [out] */ IDebugDisassemblyStream2 **ppDisassemblyStream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumModules )( 
            IDebugProgram2 * This,
            /* [out] */ IEnumDebugModules2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetENCUpdate )( 
            IDebugProgram2 * This,
            /* [out] */ IDebugENCUpdate **ppUpdate);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodePaths )( 
            IDebugProgram2 * This,
            /* [full][in] */ LPCOLESTR pszHint,
            /* [in] */ IDebugCodeContext2 *pStart,
            /* [in] */ IDebugStackFrame2 *pFrame,
            /* [in] */ BOOL fSource,
            /* [out] */ IEnumCodePaths2 **ppEnum,
            /* [out] */ IDebugCodeContext2 **ppSafety);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDump )( 
            IDebugProgram2 * This,
            /* [in] */ DUMPTYPE DumpType,
            /* [in] */ LPCOLESTR pszDumpUrl);
        
        END_INTERFACE
    } IDebugProgram2Vtbl;

    interface IDebugProgram2
    {
        CONST_VTBL struct IDebugProgram2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgram2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgram2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgram2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProgram2_EnumThreads(This,ppEnum)	\
    (This)->lpVtbl -> EnumThreads(This,ppEnum)

#define IDebugProgram2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugProgram2_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define IDebugProgram2_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define IDebugProgram2_Attach(This,pCallback)	\
    (This)->lpVtbl -> Attach(This,pCallback)

#define IDebugProgram2_CanDetach(This)	\
    (This)->lpVtbl -> CanDetach(This)

#define IDebugProgram2_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IDebugProgram2_GetProgramId(This,pguidProgramId)	\
    (This)->lpVtbl -> GetProgramId(This,pguidProgramId)

#define IDebugProgram2_GetDebugProperty(This,ppProperty)	\
    (This)->lpVtbl -> GetDebugProperty(This,ppProperty)

#define IDebugProgram2_Execute(This)	\
    (This)->lpVtbl -> Execute(This)

#define IDebugProgram2_Continue(This,pThread)	\
    (This)->lpVtbl -> Continue(This,pThread)

#define IDebugProgram2_Step(This,pThread,sk,step)	\
    (This)->lpVtbl -> Step(This,pThread,sk,step)

#define IDebugProgram2_CauseBreak(This)	\
    (This)->lpVtbl -> CauseBreak(This)

#define IDebugProgram2_GetEngineInfo(This,pbstrEngine,pguidEngine)	\
    (This)->lpVtbl -> GetEngineInfo(This,pbstrEngine,pguidEngine)

#define IDebugProgram2_EnumCodeContexts(This,pDocPos,ppEnum)	\
    (This)->lpVtbl -> EnumCodeContexts(This,pDocPos,ppEnum)

#define IDebugProgram2_GetMemoryBytes(This,ppMemoryBytes)	\
    (This)->lpVtbl -> GetMemoryBytes(This,ppMemoryBytes)

#define IDebugProgram2_GetDisassemblyStream(This,dwScope,pCodeContext,ppDisassemblyStream)	\
    (This)->lpVtbl -> GetDisassemblyStream(This,dwScope,pCodeContext,ppDisassemblyStream)

#define IDebugProgram2_EnumModules(This,ppEnum)	\
    (This)->lpVtbl -> EnumModules(This,ppEnum)

#define IDebugProgram2_GetENCUpdate(This,ppUpdate)	\
    (This)->lpVtbl -> GetENCUpdate(This,ppUpdate)

#define IDebugProgram2_EnumCodePaths(This,pszHint,pStart,pFrame,fSource,ppEnum,ppSafety)	\
    (This)->lpVtbl -> EnumCodePaths(This,pszHint,pStart,pFrame,fSource,ppEnum,ppSafety)

#define IDebugProgram2_WriteDump(This,DumpType,pszDumpUrl)	\
    (This)->lpVtbl -> WriteDump(This,DumpType,pszDumpUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProgram2_EnumThreads_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IEnumDebugThreads2 **ppEnum);


void __RPC_STUB IDebugProgram2_EnumThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetName_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugProgram2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetProcess_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IDebugProcess2 **ppProcess);


void __RPC_STUB IDebugProgram2_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Terminate_Proxy( 
    IDebugProgram2 * This);


void __RPC_STUB IDebugProgram2_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Attach_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ IDebugEventCallback2 *pCallback);


void __RPC_STUB IDebugProgram2_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_CanDetach_Proxy( 
    IDebugProgram2 * This);


void __RPC_STUB IDebugProgram2_CanDetach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Detach_Proxy( 
    IDebugProgram2 * This);


void __RPC_STUB IDebugProgram2_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetProgramId_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ GUID *pguidProgramId);


void __RPC_STUB IDebugProgram2_GetProgramId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetDebugProperty_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IDebugProperty2 **ppProperty);


void __RPC_STUB IDebugProgram2_GetDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Execute_Proxy( 
    IDebugProgram2 * This);


void __RPC_STUB IDebugProgram2_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Continue_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ IDebugThread2 *pThread);


void __RPC_STUB IDebugProgram2_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_Step_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ IDebugThread2 *pThread,
    /* [in] */ STEPKIND sk,
    /* [in] */ STEPUNIT step);


void __RPC_STUB IDebugProgram2_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_CauseBreak_Proxy( 
    IDebugProgram2 * This);


void __RPC_STUB IDebugProgram2_CauseBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetEngineInfo_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ BSTR *pbstrEngine,
    /* [out] */ GUID *pguidEngine);


void __RPC_STUB IDebugProgram2_GetEngineInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_EnumCodeContexts_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ IDebugDocumentPosition2 *pDocPos,
    /* [out] */ IEnumDebugCodeContexts2 **ppEnum);


void __RPC_STUB IDebugProgram2_EnumCodeContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetMemoryBytes_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);


void __RPC_STUB IDebugProgram2_GetMemoryBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetDisassemblyStream_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ DISASSEMBLY_STREAM_SCOPE dwScope,
    /* [in] */ IDebugCodeContext2 *pCodeContext,
    /* [out] */ IDebugDisassemblyStream2 **ppDisassemblyStream);


void __RPC_STUB IDebugProgram2_GetDisassemblyStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_EnumModules_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IEnumDebugModules2 **ppEnum);


void __RPC_STUB IDebugProgram2_EnumModules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_GetENCUpdate_Proxy( 
    IDebugProgram2 * This,
    /* [out] */ IDebugENCUpdate **ppUpdate);


void __RPC_STUB IDebugProgram2_GetENCUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_EnumCodePaths_Proxy( 
    IDebugProgram2 * This,
    /* [full][in] */ LPCOLESTR pszHint,
    /* [in] */ IDebugCodeContext2 *pStart,
    /* [in] */ IDebugStackFrame2 *pFrame,
    /* [in] */ BOOL fSource,
    /* [out] */ IEnumCodePaths2 **ppEnum,
    /* [out] */ IDebugCodeContext2 **ppSafety);


void __RPC_STUB IDebugProgram2_EnumCodePaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgram2_WriteDump_Proxy( 
    IDebugProgram2 * This,
    /* [in] */ DUMPTYPE DumpType,
    /* [in] */ LPCOLESTR pszDumpUrl);


void __RPC_STUB IDebugProgram2_WriteDump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProgram2_INTERFACE_DEFINED__ */


#ifndef __IDebugEngineProgram2_INTERFACE_DEFINED__
#define __IDebugEngineProgram2_INTERFACE_DEFINED__

/* interface IDebugEngineProgram2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugEngineProgram2_0001
    {	WATCHFOREVAL_LEAF_PROGRAM	= 0x10000000
    } ;

EXTERN_C const IID IID_IDebugEngineProgram2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7ce3e768-654d-4ba7-8d95-cdaac642b141")
    IDebugEngineProgram2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WatchForThreadStep( 
            /* [in] */ IDebugProgram2 *pOriginatingProgram,
            /* [in] */ DWORD dwTid,
            /* [in] */ BOOL fWatch,
            /* [in] */ DWORD dwFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WatchForExpressionEvaluationOnThread( 
            /* [in] */ IDebugProgram2 *pOriginatingProgram,
            /* [in] */ DWORD dwTid,
            /* [in] */ DWORD dwEvalFlags,
            /* [in] */ IDebugEventCallback2 *pExprCallback,
            /* [in] */ BOOL fWatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugEngineProgram2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugEngineProgram2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugEngineProgram2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugEngineProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDebugEngineProgram2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *WatchForThreadStep )( 
            IDebugEngineProgram2 * This,
            /* [in] */ IDebugProgram2 *pOriginatingProgram,
            /* [in] */ DWORD dwTid,
            /* [in] */ BOOL fWatch,
            /* [in] */ DWORD dwFrame);
        
        HRESULT ( STDMETHODCALLTYPE *WatchForExpressionEvaluationOnThread )( 
            IDebugEngineProgram2 * This,
            /* [in] */ IDebugProgram2 *pOriginatingProgram,
            /* [in] */ DWORD dwTid,
            /* [in] */ DWORD dwEvalFlags,
            /* [in] */ IDebugEventCallback2 *pExprCallback,
            /* [in] */ BOOL fWatch);
        
        END_INTERFACE
    } IDebugEngineProgram2Vtbl;

    interface IDebugEngineProgram2
    {
        CONST_VTBL struct IDebugEngineProgram2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugEngineProgram2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugEngineProgram2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugEngineProgram2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugEngineProgram2_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IDebugEngineProgram2_WatchForThreadStep(This,pOriginatingProgram,dwTid,fWatch,dwFrame)	\
    (This)->lpVtbl -> WatchForThreadStep(This,pOriginatingProgram,dwTid,fWatch,dwFrame)

#define IDebugEngineProgram2_WatchForExpressionEvaluationOnThread(This,pOriginatingProgram,dwTid,dwEvalFlags,pExprCallback,fWatch)	\
    (This)->lpVtbl -> WatchForExpressionEvaluationOnThread(This,pOriginatingProgram,dwTid,dwEvalFlags,pExprCallback,fWatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugEngineProgram2_Stop_Proxy( 
    IDebugEngineProgram2 * This);


void __RPC_STUB IDebugEngineProgram2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngineProgram2_WatchForThreadStep_Proxy( 
    IDebugEngineProgram2 * This,
    /* [in] */ IDebugProgram2 *pOriginatingProgram,
    /* [in] */ DWORD dwTid,
    /* [in] */ BOOL fWatch,
    /* [in] */ DWORD dwFrame);


void __RPC_STUB IDebugEngineProgram2_WatchForThreadStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugEngineProgram2_WatchForExpressionEvaluationOnThread_Proxy( 
    IDebugEngineProgram2 * This,
    /* [in] */ IDebugProgram2 *pOriginatingProgram,
    /* [in] */ DWORD dwTid,
    /* [in] */ DWORD dwEvalFlags,
    /* [in] */ IDebugEventCallback2 *pExprCallback,
    /* [in] */ BOOL fWatch);


void __RPC_STUB IDebugEngineProgram2_WatchForExpressionEvaluationOnThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugEngineProgram2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramHost2_INTERFACE_DEFINED__
#define __IDebugProgramHost2_INTERFACE_DEFINED__

/* interface IDebugProgramHost2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProgramHost2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c99d588f-778c-44fe-8b2e-40124a738891")
    IDebugProgramHost2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHostName( 
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR *pbstrHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostId( 
            /* [out] */ AD_PROCESS_ID *pProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostMachineName( 
            /* [out] */ BSTR *pbstrHostMachineName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramHost2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramHost2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramHost2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramHost2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostName )( 
            IDebugProgramHost2 * This,
            /* [in] */ DWORD dwType,
            /* [out] */ BSTR *pbstrHostName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostId )( 
            IDebugProgramHost2 * This,
            /* [out] */ AD_PROCESS_ID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostMachineName )( 
            IDebugProgramHost2 * This,
            /* [out] */ BSTR *pbstrHostMachineName);
        
        END_INTERFACE
    } IDebugProgramHost2Vtbl;

    interface IDebugProgramHost2
    {
        CONST_VTBL struct IDebugProgramHost2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramHost2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramHost2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramHost2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProgramHost2_GetHostName(This,dwType,pbstrHostName)	\
    (This)->lpVtbl -> GetHostName(This,dwType,pbstrHostName)

#define IDebugProgramHost2_GetHostId(This,pProcessId)	\
    (This)->lpVtbl -> GetHostId(This,pProcessId)

#define IDebugProgramHost2_GetHostMachineName(This,pbstrHostMachineName)	\
    (This)->lpVtbl -> GetHostMachineName(This,pbstrHostMachineName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProgramHost2_GetHostName_Proxy( 
    IDebugProgramHost2 * This,
    /* [in] */ DWORD dwType,
    /* [out] */ BSTR *pbstrHostName);


void __RPC_STUB IDebugProgramHost2_GetHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramHost2_GetHostId_Proxy( 
    IDebugProgramHost2 * This,
    /* [out] */ AD_PROCESS_ID *pProcessId);


void __RPC_STUB IDebugProgramHost2_GetHostId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramHost2_GetHostMachineName_Proxy( 
    IDebugProgramHost2 * This,
    /* [out] */ BSTR *pbstrHostMachineName);


void __RPC_STUB IDebugProgramHost2_GetHostMachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProgramHost2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramNode2_INTERFACE_DEFINED__
#define __IDebugProgramNode2_INTERFACE_DEFINED__

/* interface IDebugProgramNode2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugProgramNode2_0001
    {	GHN_FRIENDLY_NAME	= 0,
	GHN_FILE_NAME	= GHN_FRIENDLY_NAME + 1
    } ;
typedef DWORD GETHOSTNAME_TYPE;


EXTERN_C const IID IID_IDebugProgramNode2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("426e255c-f1ce-4d02-a931-f9a254bf7f0f")
    IDebugProgramNode2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProgramName( 
            /* [out] */ BSTR *pbstrProgramName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostName( 
            /* [in] */ GETHOSTNAME_TYPE dwHostNameType,
            /* [out] */ BSTR *pbstrHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostPid( 
            /* [out] */ AD_PROCESS_ID *pHostProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostMachineName( 
            /* [out] */ BSTR *pbstrHostMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugProgram2 *pMDMProgram,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [in] */ DWORD dwReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEngineInfo( 
            /* [out] */ BSTR *pbstrEngine,
            /* [out] */ GUID *pguidEngine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetachDebugger( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramNode2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramNode2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramNode2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramNode2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgramName )( 
            IDebugProgramNode2 * This,
            /* [out] */ BSTR *pbstrProgramName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostName )( 
            IDebugProgramNode2 * This,
            /* [in] */ GETHOSTNAME_TYPE dwHostNameType,
            /* [out] */ BSTR *pbstrHostName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostPid )( 
            IDebugProgramNode2 * This,
            /* [out] */ AD_PROCESS_ID *pHostProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostMachineName )( 
            IDebugProgramNode2 * This,
            /* [out] */ BSTR *pbstrHostMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            IDebugProgramNode2 * This,
            /* [in] */ IDebugProgram2 *pMDMProgram,
            /* [in] */ IDebugEventCallback2 *pCallback,
            /* [in] */ DWORD dwReason);
        
        HRESULT ( STDMETHODCALLTYPE *GetEngineInfo )( 
            IDebugProgramNode2 * This,
            /* [out] */ BSTR *pbstrEngine,
            /* [out] */ GUID *pguidEngine);
        
        HRESULT ( STDMETHODCALLTYPE *DetachDebugger )( 
            IDebugProgramNode2 * This);
        
        END_INTERFACE
    } IDebugProgramNode2Vtbl;

    interface IDebugProgramNode2
    {
        CONST_VTBL struct IDebugProgramNode2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramNode2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramNode2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramNode2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProgramNode2_GetProgramName(This,pbstrProgramName)	\
    (This)->lpVtbl -> GetProgramName(This,pbstrProgramName)

#define IDebugProgramNode2_GetHostName(This,dwHostNameType,pbstrHostName)	\
    (This)->lpVtbl -> GetHostName(This,dwHostNameType,pbstrHostName)

#define IDebugProgramNode2_GetHostPid(This,pHostProcessId)	\
    (This)->lpVtbl -> GetHostPid(This,pHostProcessId)

#define IDebugProgramNode2_GetHostMachineName(This,pbstrHostMachineName)	\
    (This)->lpVtbl -> GetHostMachineName(This,pbstrHostMachineName)

#define IDebugProgramNode2_Attach(This,pMDMProgram,pCallback,dwReason)	\
    (This)->lpVtbl -> Attach(This,pMDMProgram,pCallback,dwReason)

#define IDebugProgramNode2_GetEngineInfo(This,pbstrEngine,pguidEngine)	\
    (This)->lpVtbl -> GetEngineInfo(This,pbstrEngine,pguidEngine)

#define IDebugProgramNode2_DetachDebugger(This)	\
    (This)->lpVtbl -> DetachDebugger(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProgramNode2_GetProgramName_Proxy( 
    IDebugProgramNode2 * This,
    /* [out] */ BSTR *pbstrProgramName);


void __RPC_STUB IDebugProgramNode2_GetProgramName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_GetHostName_Proxy( 
    IDebugProgramNode2 * This,
    /* [in] */ GETHOSTNAME_TYPE dwHostNameType,
    /* [out] */ BSTR *pbstrHostName);


void __RPC_STUB IDebugProgramNode2_GetHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_GetHostPid_Proxy( 
    IDebugProgramNode2 * This,
    /* [out] */ AD_PROCESS_ID *pHostProcessId);


void __RPC_STUB IDebugProgramNode2_GetHostPid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_GetHostMachineName_Proxy( 
    IDebugProgramNode2 * This,
    /* [out] */ BSTR *pbstrHostMachineName);


void __RPC_STUB IDebugProgramNode2_GetHostMachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_Attach_Proxy( 
    IDebugProgramNode2 * This,
    /* [in] */ IDebugProgram2 *pMDMProgram,
    /* [in] */ IDebugEventCallback2 *pCallback,
    /* [in] */ DWORD dwReason);


void __RPC_STUB IDebugProgramNode2_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_GetEngineInfo_Proxy( 
    IDebugProgramNode2 * This,
    /* [out] */ BSTR *pbstrEngine,
    /* [out] */ GUID *pguidEngine);


void __RPC_STUB IDebugProgramNode2_GetEngineInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramNode2_DetachDebugger_Proxy( 
    IDebugProgramNode2 * This);


void __RPC_STUB IDebugProgramNode2_DetachDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProgramNode2_INTERFACE_DEFINED__ */


#ifndef __IDebugProgramEngines2_INTERFACE_DEFINED__
#define __IDebugProgramEngines2_INTERFACE_DEFINED__

/* interface IDebugProgramEngines2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProgramEngines2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fda24a6b-b142-447d-bbbc-8654a3d84f80")
    IDebugProgramEngines2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumPossibleEngines( 
            /* [in] */ DWORD celtBuffer,
            /* [length_is][size_is][full][out][in] */ GUID *rgguidEngines,
            /* [out][in] */ DWORD *pceltEngines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEngine( 
            /* [in] */ REFGUID guidEngine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProgramEngines2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProgramEngines2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProgramEngines2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProgramEngines2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPossibleEngines )( 
            IDebugProgramEngines2 * This,
            /* [in] */ DWORD celtBuffer,
            /* [length_is][size_is][full][out][in] */ GUID *rgguidEngines,
            /* [out][in] */ DWORD *pceltEngines);
        
        HRESULT ( STDMETHODCALLTYPE *SetEngine )( 
            IDebugProgramEngines2 * This,
            /* [in] */ REFGUID guidEngine);
        
        END_INTERFACE
    } IDebugProgramEngines2Vtbl;

    interface IDebugProgramEngines2
    {
        CONST_VTBL struct IDebugProgramEngines2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProgramEngines2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProgramEngines2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProgramEngines2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProgramEngines2_EnumPossibleEngines(This,celtBuffer,rgguidEngines,pceltEngines)	\
    (This)->lpVtbl -> EnumPossibleEngines(This,celtBuffer,rgguidEngines,pceltEngines)

#define IDebugProgramEngines2_SetEngine(This,guidEngine)	\
    (This)->lpVtbl -> SetEngine(This,guidEngine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProgramEngines2_EnumPossibleEngines_Proxy( 
    IDebugProgramEngines2 * This,
    /* [in] */ DWORD celtBuffer,
    /* [length_is][size_is][full][out][in] */ GUID *rgguidEngines,
    /* [out][in] */ DWORD *pceltEngines);


void __RPC_STUB IDebugProgramEngines2_EnumPossibleEngines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProgramEngines2_SetEngine_Proxy( 
    IDebugProgramEngines2 * This,
    /* [in] */ REFGUID guidEngine);


void __RPC_STUB IDebugProgramEngines2_SetEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProgramEngines2_INTERFACE_DEFINED__ */


#ifndef __IDebugThread2_INTERFACE_DEFINED__
#define __IDebugThread2_INTERFACE_DEFINED__

/* interface IDebugThread2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugThread2_0001
    {	THREADSTATE_RUNNING	= 0x1,
	THREADSTATE_STOPPED	= 0x2,
	THREADSTATE_FRESH	= 0x3,
	THREADSTATE_DEAD	= 0x4,
	THREADSTATE_FROZEN	= 0x5
    } ;
typedef DWORD THREADSTATE;


enum __MIDL_IDebugThread2_0002
    {	TPF_ID	= 0x1,
	TPF_SUSPENDCOUNT	= 0x2,
	TPF_STATE	= 0x4,
	TPF_PRIORITY	= 0x8,
	TPF_NAME	= 0x10,
	TPF_LOCATION	= 0x20,
	TPF_ALLFIELDS	= 0xffffffff
    } ;
typedef DWORD THREADPROPERTY_FIELDS;

typedef struct _tagTHREADPROPERTIES
    {
    THREADPROPERTY_FIELDS dwFields;
    DWORD dwThreadId;
    DWORD dwSuspendCount;
    DWORD dwThreadState;
    BSTR bstrPriority;
    BSTR bstrName;
    BSTR bstrLocation;
    } 	THREADPROPERTIES;


enum __MIDL_IDebugThread2_0003
    {	FIF_FUNCNAME	= 0x1,
	FIF_RETURNTYPE	= 0x2,
	FIF_ARGS	= 0x4,
	FIF_LANGUAGE	= 0x8,
	FIF_MODULE	= 0x10,
	FIF_STACKRANGE	= 0x20,
	FIF_FRAME	= 0x40,
	FIF_DEBUGINFO	= 0x80,
	FIF_STALECODE	= 0x100,
	FIF_ANNOTATEDFRAME	= 0x200,
	FIF_DEBUG_MODULEP	= 0x400,
	FIF_FUNCNAME_FORMAT	= 0x1000,
	FIF_FUNCNAME_RETURNTYPE	= 0x2000,
	FIF_FUNCNAME_ARGS	= 0x4000,
	FIF_FUNCNAME_LANGUAGE	= 0x8000,
	FIF_FUNCNAME_MODULE	= 0x10000,
	FIF_FUNCNAME_LINES	= 0x20000,
	FIF_FUNCNAME_OFFSET	= 0x40000,
	FIF_FUNCNAME_ARGS_TYPES	= 0x100000,
	FIF_FUNCNAME_ARGS_NAMES	= 0x200000,
	FIF_FUNCNAME_ARGS_VALUES	= 0x400000,
	FIF_FUNCNAME_ARGS_ALL	= 0x700000,
	FIF_ARGS_TYPES	= 0x1000000,
	FIF_ARGS_NAMES	= 0x2000000,
	FIF_ARGS_VALUES	= 0x4000000,
	FIF_ARGS_ALL	= 0x7000000,
	FIF_ARGS_NOFORMAT	= 0x8000000
    } ;
typedef DWORD FRAMEINFO_FLAGS;

typedef struct tagFRAMEINFO
    {
    FRAMEINFO_FLAGS m_dwValidFields;
    BSTR m_bstrFuncName;
    BSTR m_bstrReturnType;
    BSTR m_bstrArgs;
    BSTR m_bstrLanguage;
    BSTR m_bstrModule;
    UINT64 m_addrMin;
    UINT64 m_addrMax;
    IDebugStackFrame2 *m_pFrame;
    IDebugModule2 *m_pModule;
    BOOL m_fHasDebugInfo;
    BOOL m_fStaleCode;
    BOOL m_fAnnotatedFrame;
    } 	FRAMEINFO;


EXTERN_C const IID IID_IDebugThread2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5168050-a57a-465c-bea9-974f405eba13")
    IDebugThread2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFrameInfo( 
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadName( 
            /* [in] */ LPCOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgram( 
            /* [out] */ IDebugProgram2 **ppProgram) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetNextStatement( 
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [in] */ IDebugCodeContext2 *pCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement( 
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [in] */ IDebugCodeContext2 *pCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadId( 
            /* [out] */ DWORD *pdwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( 
            /* [out] */ DWORD *pdwSuspendCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [out] */ DWORD *pdwSuspendCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadProperties( 
            /* [in] */ THREADPROPERTY_FIELDS dwFields,
            /* [out] */ THREADPROPERTIES *ptp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogicalThread( 
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [out] */ IDebugLogicalThread2 **ppLogicalThread) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugThread2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugThread2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugThread2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugThread2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFrameInfo )( 
            IDebugThread2 * This,
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugThread2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadName )( 
            IDebugThread2 * This,
            /* [in] */ LPCOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgram )( 
            IDebugThread2 * This,
            /* [out] */ IDebugProgram2 **ppProgram);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetNextStatement )( 
            IDebugThread2 * This,
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [in] */ IDebugCodeContext2 *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetNextStatement )( 
            IDebugThread2 * This,
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [in] */ IDebugCodeContext2 *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadId )( 
            IDebugThread2 * This,
            /* [out] */ DWORD *pdwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IDebugThread2 * This,
            /* [out] */ DWORD *pdwSuspendCount);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDebugThread2 * This,
            /* [out] */ DWORD *pdwSuspendCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadProperties )( 
            IDebugThread2 * This,
            /* [in] */ THREADPROPERTY_FIELDS dwFields,
            /* [out] */ THREADPROPERTIES *ptp);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogicalThread )( 
            IDebugThread2 * This,
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [out] */ IDebugLogicalThread2 **ppLogicalThread);
        
        END_INTERFACE
    } IDebugThread2Vtbl;

    interface IDebugThread2
    {
        CONST_VTBL struct IDebugThread2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThread2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThread2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugThread2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugThread2_EnumFrameInfo(This,dwFieldSpec,nRadix,ppEnum)	\
    (This)->lpVtbl -> EnumFrameInfo(This,dwFieldSpec,nRadix,ppEnum)

#define IDebugThread2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugThread2_SetThreadName(This,pszName)	\
    (This)->lpVtbl -> SetThreadName(This,pszName)

#define IDebugThread2_GetProgram(This,ppProgram)	\
    (This)->lpVtbl -> GetProgram(This,ppProgram)

#define IDebugThread2_CanSetNextStatement(This,pStackFrame,pCodeContext)	\
    (This)->lpVtbl -> CanSetNextStatement(This,pStackFrame,pCodeContext)

#define IDebugThread2_SetNextStatement(This,pStackFrame,pCodeContext)	\
    (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext)

#define IDebugThread2_GetThreadId(This,pdwThreadId)	\
    (This)->lpVtbl -> GetThreadId(This,pdwThreadId)

#define IDebugThread2_Suspend(This,pdwSuspendCount)	\
    (This)->lpVtbl -> Suspend(This,pdwSuspendCount)

#define IDebugThread2_Resume(This,pdwSuspendCount)	\
    (This)->lpVtbl -> Resume(This,pdwSuspendCount)

#define IDebugThread2_GetThreadProperties(This,dwFields,ptp)	\
    (This)->lpVtbl -> GetThreadProperties(This,dwFields,ptp)

#define IDebugThread2_GetLogicalThread(This,pStackFrame,ppLogicalThread)	\
    (This)->lpVtbl -> GetLogicalThread(This,pStackFrame,ppLogicalThread)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugThread2_EnumFrameInfo_Proxy( 
    IDebugThread2 * This,
    /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugFrameInfo2 **ppEnum);


void __RPC_STUB IDebugThread2_EnumFrameInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_GetName_Proxy( 
    IDebugThread2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugThread2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_SetThreadName_Proxy( 
    IDebugThread2 * This,
    /* [in] */ LPCOLESTR pszName);


void __RPC_STUB IDebugThread2_SetThreadName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_GetProgram_Proxy( 
    IDebugThread2 * This,
    /* [out] */ IDebugProgram2 **ppProgram);


void __RPC_STUB IDebugThread2_GetProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_CanSetNextStatement_Proxy( 
    IDebugThread2 * This,
    /* [in] */ IDebugStackFrame2 *pStackFrame,
    /* [in] */ IDebugCodeContext2 *pCodeContext);


void __RPC_STUB IDebugThread2_CanSetNextStatement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_SetNextStatement_Proxy( 
    IDebugThread2 * This,
    /* [in] */ IDebugStackFrame2 *pStackFrame,
    /* [in] */ IDebugCodeContext2 *pCodeContext);


void __RPC_STUB IDebugThread2_SetNextStatement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_GetThreadId_Proxy( 
    IDebugThread2 * This,
    /* [out] */ DWORD *pdwThreadId);


void __RPC_STUB IDebugThread2_GetThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_Suspend_Proxy( 
    IDebugThread2 * This,
    /* [out] */ DWORD *pdwSuspendCount);


void __RPC_STUB IDebugThread2_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_Resume_Proxy( 
    IDebugThread2 * This,
    /* [out] */ DWORD *pdwSuspendCount);


void __RPC_STUB IDebugThread2_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_GetThreadProperties_Proxy( 
    IDebugThread2 * This,
    /* [in] */ THREADPROPERTY_FIELDS dwFields,
    /* [out] */ THREADPROPERTIES *ptp);


void __RPC_STUB IDebugThread2_GetThreadProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugThread2_GetLogicalThread_Proxy( 
    IDebugThread2 * This,
    /* [in] */ IDebugStackFrame2 *pStackFrame,
    /* [out] */ IDebugLogicalThread2 **ppLogicalThread);


void __RPC_STUB IDebugThread2_GetLogicalThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugThread2_INTERFACE_DEFINED__ */


#ifndef __IDebugLogicalThread2_INTERFACE_DEFINED__
#define __IDebugLogicalThread2_INTERFACE_DEFINED__

/* interface IDebugLogicalThread2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugLogicalThread2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88d2f75b-d329-4e03-9b75-201f7782d8bd")
    IDebugLogicalThread2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFrameInfo( 
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugLogicalThread2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugLogicalThread2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugLogicalThread2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugLogicalThread2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFrameInfo )( 
            IDebugLogicalThread2 * This,
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum);
        
        END_INTERFACE
    } IDebugLogicalThread2Vtbl;

    interface IDebugLogicalThread2
    {
        CONST_VTBL struct IDebugLogicalThread2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugLogicalThread2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugLogicalThread2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugLogicalThread2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugLogicalThread2_EnumFrameInfo(This,dwFieldSpec,nRadix,ppEnum)	\
    (This)->lpVtbl -> EnumFrameInfo(This,dwFieldSpec,nRadix,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugLogicalThread2_EnumFrameInfo_Proxy( 
    IDebugLogicalThread2 * This,
    /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugFrameInfo2 **ppEnum);


void __RPC_STUB IDebugLogicalThread2_EnumFrameInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugLogicalThread2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdbg_0350 */
/* [local] */ 

#define DBG_ATTRIB_NONE					0x0000000000000000
#define DBG_ATTRIB_ALL					0xffffffffffffffff
#define DBG_ATTRIB_OBJ_IS_EXPANDABLE		0x0000000000000001
#define DBG_ATTRIB_VALUE_READONLY		0x0000000000000010
#define DBG_ATTRIB_VALUE_ERROR			0x0000000000000020
#define DBG_ATTRIB_VALUE_SIDE_EFFECT		0x0000000000000040
#define DBG_ATTRIB_OVERLOADED_CONTAINER	0x0000000000000080
#define DBG_ATTRIB_VALUE_BOOLEAN			0x0000000000000100
#define DBG_ATTRIB_VALUE_BOOLEAN_TRUE	0x0000000000000200
#define DBG_ATTRIB_VALUE_INVALID			0x0000000000000400
#define DBG_ATTRIB_VALUE_NAT				0x0000000000000800
#define DBG_ATTRIB_VALUE_AUTOEXPANDED	0x0000000000001000
#define DBG_ATTRIB_ACCESS_NONE			0x0000000000010000
#define DBG_ATTRIB_ACCESS_PUBLIC			0x0000000000020000
#define DBG_ATTRIB_ACCESS_PRIVATE		0x0000000000040000
#define DBG_ATTRIB_ACCESS_PROTECTED		0x0000000000080000
#define DBG_ATTRIB_ACCESS_FINAL			0x0000000000100000
#define DBG_ATTRIB_ACCESS_ALL			0x00000000001f0000
#define DBG_ATTRIB_STORAGE_NONE			0x0000000001000000
#define DBG_ATTRIB_STORAGE_GLOBAL		0x0000000002000000
#define DBG_ATTRIB_STORAGE_STATIC		0x0000000004000000
#define DBG_ATTRIB_STORAGE_REGISTER		0x0000000008000000
#define DBG_ATTRIB_STORAGE_ALL			0x000000000f000000
#define DBG_ATTRIB_TYPE_NONE				0x0000000100000000
#define DBG_ATTRIB_TYPE_VIRTUAL			0x0000000200000000
#define DBG_ATTRIB_TYPE_CONSTANT			0x0000000400000000
#define DBG_ATTRIB_TYPE_SYNCHRONIZED		0x0000000800000000
#define DBG_ATTRIB_TYPE_VOLATILE			0x0000001000000000
#define DBG_ATTRIB_TYPE_ALL				0x0000001f00000000
#define DBG_ATTRIB_DATA					0x0000010000000000
#define DBG_ATTRIB_METHOD				0x0000020000000000
#define DBG_ATTRIB_PROPERTY				0x0000040000000000
#define DBG_ATTRIB_CLASS					0x0000080000000000
#define DBG_ATTRIB_BASECLASS				0x0000100000000000
#define DBG_ATTRIB_INTERFACE				0x0000200000000000
#define DBG_ATTRIB_INNERCLASS			0x0000400000000000
#define DBG_ATTRIB_MOSTDERIVEDCLASS		0x0000800000000000
#define DBG_ATTRIB_CHILD_ALL				0x0000ff0000000000
typedef UINT64 DBG_ATTRIB_FLAGS;


enum __MIDL___MIDL_itf_msdbg_0350_0001
    {	DEBUGPROP_INFO_FULLNAME	= 0x1,
	DEBUGPROP_INFO_NAME	= 0x2,
	DEBUGPROP_INFO_TYPE	= 0x4,
	DEBUGPROP_INFO_VALUE	= 0x8,
	DEBUGPROP_INFO_ATTRIB	= 0x10,
	DEBUGPROP_INFO_PROP	= 0x20,
	DEBUGPROP_INFO_VALUE_AUTOEXPAND	= 0x10000,
	DEBUGPROP_INFO_NOFUNCEVAL	= 0x20000,
	DEBUGPROP_INFO_NONE	= 0,
	DEBUGPROP_INFO_STANDARD	= DEBUGPROP_INFO_ATTRIB | DEBUGPROP_INFO_NAME | DEBUGPROP_INFO_TYPE | DEBUGPROP_INFO_VALUE,
	DEBUGPROP_INFO_ALL	= 0xffffffff
    } ;
typedef DWORD DEBUGPROP_INFO_FLAGS;

typedef struct tagDEBUG_PROPERTY_INFO
    {
    DEBUGPROP_INFO_FLAGS dwFields;
    BSTR bstrFullName;
    BSTR bstrName;
    BSTR bstrType;
    BSTR bstrValue;
    IDebugProperty2 *pProperty;
    DBG_ATTRIB_FLAGS dwAttrib;
    } 	DEBUG_PROPERTY_INFO;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0350_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0350_v0_0_s_ifspec;

#ifndef __IDebugProperty2_INTERFACE_DEFINED__
#define __IDebugProperty2_INTERFACE_DEFINED__

/* interface IDebugProperty2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProperty2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7ee3e7e-2dd2-4ad7-9697-f4aae3427762")
    IDebugProperty2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout,
            /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [out] */ DEBUG_PROPERTY_INFO *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsReference( 
            /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [in] */ IDebugReference2 *pValue,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ REFGUID guidFilter,
            /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
            /* [full][in] */ LPCOLESTR pszNameFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty2 **ppParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDerivedMostProperty( 
            /* [out] */ IDebugProperty2 **ppDerivedMost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryBytes( 
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryContext( 
            /* [out] */ IDebugMemoryContext2 **ppMemory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ IDebugReference2 **ppReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ REFGUID guidExtendedInfo,
            /* [out] */ VARIANT *pExtendedInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugProperty2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugProperty2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugProperty2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugProperty2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInfo )( 
            IDebugProperty2 * This,
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout,
            /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [out] */ DEBUG_PROPERTY_INFO *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsString )( 
            IDebugProperty2 * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsReference )( 
            IDebugProperty2 * This,
            /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [in] */ IDebugReference2 *pValue,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *EnumChildren )( 
            IDebugProperty2 * This,
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ REFGUID guidFilter,
            /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
            /* [full][in] */ LPCOLESTR pszNameFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDebugProperty2 * This,
            /* [out] */ IDebugProperty2 **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDerivedMostProperty )( 
            IDebugProperty2 * This,
            /* [out] */ IDebugProperty2 **ppDerivedMost);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryBytes )( 
            IDebugProperty2 * This,
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryContext )( 
            IDebugProperty2 * This,
            /* [out] */ IDebugMemoryContext2 **ppMemory);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugProperty2 * This,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IDebugProperty2 * This,
            /* [out] */ IDebugReference2 **ppReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtendedInfo )( 
            IDebugProperty2 * This,
            /* [in] */ REFGUID guidExtendedInfo,
            /* [out] */ VARIANT *pExtendedInfo);
        
        END_INTERFACE
    } IDebugProperty2Vtbl;

    interface IDebugProperty2
    {
        CONST_VTBL struct IDebugProperty2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty2_GetPropertyInfo(This,dwFields,dwRadix,dwTimeout,rgpArgs,dwArgCount,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFields,dwRadix,dwTimeout,rgpArgs,dwArgCount,pPropertyInfo)

#define IDebugProperty2_SetValueAsString(This,pszValue,dwRadix,dwTimeout)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,dwRadix,dwTimeout)

#define IDebugProperty2_SetValueAsReference(This,rgpArgs,dwArgCount,pValue,dwTimeout)	\
    (This)->lpVtbl -> SetValueAsReference(This,rgpArgs,dwArgCount,pValue,dwTimeout)

#define IDebugProperty2_EnumChildren(This,dwFields,dwRadix,guidFilter,dwAttribFilter,pszNameFilter,dwTimeout,ppEnum)	\
    (This)->lpVtbl -> EnumChildren(This,dwFields,dwRadix,guidFilter,dwAttribFilter,pszNameFilter,dwTimeout,ppEnum)

#define IDebugProperty2_GetParent(This,ppParent)	\
    (This)->lpVtbl -> GetParent(This,ppParent)

#define IDebugProperty2_GetDerivedMostProperty(This,ppDerivedMost)	\
    (This)->lpVtbl -> GetDerivedMostProperty(This,ppDerivedMost)

#define IDebugProperty2_GetMemoryBytes(This,ppMemoryBytes)	\
    (This)->lpVtbl -> GetMemoryBytes(This,ppMemoryBytes)

#define IDebugProperty2_GetMemoryContext(This,ppMemory)	\
    (This)->lpVtbl -> GetMemoryContext(This,ppMemory)

#define IDebugProperty2_GetSize(This,pdwSize)	\
    (This)->lpVtbl -> GetSize(This,pdwSize)

#define IDebugProperty2_GetReference(This,ppReference)	\
    (This)->lpVtbl -> GetReference(This,ppReference)

#define IDebugProperty2_GetExtendedInfo(This,guidExtendedInfo,pExtendedInfo)	\
    (This)->lpVtbl -> GetExtendedInfo(This,guidExtendedInfo,pExtendedInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugProperty2_GetPropertyInfo_Proxy( 
    IDebugProperty2 * This,
    /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
    /* [in] */ DWORD dwRadix,
    /* [in] */ DWORD dwTimeout,
    /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
    /* [in] */ DWORD dwArgCount,
    /* [out] */ DEBUG_PROPERTY_INFO *pPropertyInfo);


void __RPC_STUB IDebugProperty2_GetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_SetValueAsString_Proxy( 
    IDebugProperty2 * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ DWORD dwRadix,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IDebugProperty2_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_SetValueAsReference_Proxy( 
    IDebugProperty2 * This,
    /* [length_is][size_is][full][in] */ IDebugReference2 **rgpArgs,
    /* [in] */ DWORD dwArgCount,
    /* [in] */ IDebugReference2 *pValue,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IDebugProperty2_SetValueAsReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_EnumChildren_Proxy( 
    IDebugProperty2 * This,
    /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
    /* [in] */ DWORD dwRadix,
    /* [in] */ REFGUID guidFilter,
    /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
    /* [full][in] */ LPCOLESTR pszNameFilter,
    /* [in] */ DWORD dwTimeout,
    /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);


void __RPC_STUB IDebugProperty2_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetParent_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ IDebugProperty2 **ppParent);


void __RPC_STUB IDebugProperty2_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetDerivedMostProperty_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ IDebugProperty2 **ppDerivedMost);


void __RPC_STUB IDebugProperty2_GetDerivedMostProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetMemoryBytes_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);


void __RPC_STUB IDebugProperty2_GetMemoryBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetMemoryContext_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ IDebugMemoryContext2 **ppMemory);


void __RPC_STUB IDebugProperty2_GetMemoryContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetSize_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IDebugProperty2_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetReference_Proxy( 
    IDebugProperty2 * This,
    /* [out] */ IDebugReference2 **ppReference);


void __RPC_STUB IDebugProperty2_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty2_GetExtendedInfo_Proxy( 
    IDebugProperty2 * This,
    /* [in] */ REFGUID guidExtendedInfo,
    /* [out] */ VARIANT *pExtendedInfo);


void __RPC_STUB IDebugProperty2_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdbg_0351 */
/* [local] */ 


enum __MIDL___MIDL_itf_msdbg_0351_0001
    {	REF_TYPE_WEAK	= 0x1,
	REF_TYPE_STRONG	= 0x2
    } ;
typedef DWORD REFERENCE_TYPE;


enum __MIDL___MIDL_itf_msdbg_0351_0002
    {	DEBUGREF_INFO_NAME	= 0x1,
	DEBUGREF_INFO_TYPE	= 0x2,
	DEBUGREF_INFO_VALUE	= 0x4,
	DEBUGREF_INFO_ATTRIB	= 0x8,
	DEBUGREF_INFO_REFTYPE	= 0x10,
	DEBUGREF_INFO_REF	= 0x20,
	DEBUGREF_INFO_VALUE_AUTOEXPAND	= 0x10000,
	DEBUGREF_INFO_NONE	= 0,
	DEBUGREF_INFO_ALL	= 0xffffffff
    } ;
typedef DWORD DEBUGREF_INFO_FLAGS;

typedef struct tagDEBUG_REFERENCE_INFO
    {
    DEBUGREF_INFO_FLAGS dwFields;
    BSTR bstrName;
    BSTR bstrType;
    BSTR bstrValue;
    DBG_ATTRIB_FLAGS dwAttrib;
    REFERENCE_TYPE dwRefType;
    IDebugReference2 *pReference;
    } 	DEBUG_REFERENCE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0351_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0351_v0_0_s_ifspec;

#ifndef __IDebugReference2_INTERFACE_DEFINED__
#define __IDebugReference2_INTERFACE_DEFINED__

/* interface IDebugReference2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugReference2_0003
    {	REF_COMPARE_EQUAL	= 0x1,
	REF_COMPARE_LESS_THAN	= 0x2,
	REF_COMPARE_GREATER_THAN	= 0x3
    } ;
typedef DWORD REFERENCE_COMPARE;


EXTERN_C const IID IID_IDebugReference2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10b793ac-0c47-4679-8454-adb36f29f802")
    IDebugReference2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReferenceInfo( 
            /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout,
            /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [out] */ DEBUG_REFERENCE_INFO *pReferenceInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsReference( 
            /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [in] */ IDebugReference2 *pValue,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
            /* [full][in] */ LPCOLESTR pszNameFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IEnumDebugReferenceInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugReference2 **ppParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDerivedMostReference( 
            /* [out] */ IDebugReference2 **ppDerivedMost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryBytes( 
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryContext( 
            /* [out] */ IDebugMemoryContext2 **ppMemory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReferenceType( 
            /* [in] */ REFERENCE_TYPE dwRefType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ REFERENCE_COMPARE dwCompare,
            /* [in] */ IDebugReference2 *pReference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugReference2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugReference2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugReference2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugReference2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceInfo )( 
            IDebugReference2 * This,
            /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout,
            /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [out] */ DEBUG_REFERENCE_INFO *pReferenceInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsString )( 
            IDebugReference2 * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAsReference )( 
            IDebugReference2 * This,
            /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
            /* [in] */ DWORD dwArgCount,
            /* [in] */ IDebugReference2 *pValue,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE *EnumChildren )( 
            IDebugReference2 * This,
            /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
            /* [in] */ DWORD dwRadix,
            /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
            /* [full][in] */ LPCOLESTR pszNameFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IEnumDebugReferenceInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDebugReference2 * This,
            /* [out] */ IDebugReference2 **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDerivedMostReference )( 
            IDebugReference2 * This,
            /* [out] */ IDebugReference2 **ppDerivedMost);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryBytes )( 
            IDebugReference2 * This,
            /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryContext )( 
            IDebugReference2 * This,
            /* [out] */ IDebugMemoryContext2 **ppMemory);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugReference2 * This,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetReferenceType )( 
            IDebugReference2 * This,
            /* [in] */ REFERENCE_TYPE dwRefType);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IDebugReference2 * This,
            /* [in] */ REFERENCE_COMPARE dwCompare,
            /* [in] */ IDebugReference2 *pReference);
        
        END_INTERFACE
    } IDebugReference2Vtbl;

    interface IDebugReference2
    {
        CONST_VTBL struct IDebugReference2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugReference2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugReference2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugReference2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugReference2_GetReferenceInfo(This,dwFields,dwRadix,dwTimeout,rgpArgs,dwArgCount,pReferenceInfo)	\
    (This)->lpVtbl -> GetReferenceInfo(This,dwFields,dwRadix,dwTimeout,rgpArgs,dwArgCount,pReferenceInfo)

#define IDebugReference2_SetValueAsString(This,pszValue,dwRadix,dwTimeout)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,dwRadix,dwTimeout)

#define IDebugReference2_SetValueAsReference(This,rgpArgs,dwArgCount,pValue,dwTimeout)	\
    (This)->lpVtbl -> SetValueAsReference(This,rgpArgs,dwArgCount,pValue,dwTimeout)

#define IDebugReference2_EnumChildren(This,dwFields,dwRadix,dwAttribFilter,pszNameFilter,dwTimeout,ppEnum)	\
    (This)->lpVtbl -> EnumChildren(This,dwFields,dwRadix,dwAttribFilter,pszNameFilter,dwTimeout,ppEnum)

#define IDebugReference2_GetParent(This,ppParent)	\
    (This)->lpVtbl -> GetParent(This,ppParent)

#define IDebugReference2_GetDerivedMostReference(This,ppDerivedMost)	\
    (This)->lpVtbl -> GetDerivedMostReference(This,ppDerivedMost)

#define IDebugReference2_GetMemoryBytes(This,ppMemoryBytes)	\
    (This)->lpVtbl -> GetMemoryBytes(This,ppMemoryBytes)

#define IDebugReference2_GetMemoryContext(This,ppMemory)	\
    (This)->lpVtbl -> GetMemoryContext(This,ppMemory)

#define IDebugReference2_GetSize(This,pdwSize)	\
    (This)->lpVtbl -> GetSize(This,pdwSize)

#define IDebugReference2_SetReferenceType(This,dwRefType)	\
    (This)->lpVtbl -> SetReferenceType(This,dwRefType)

#define IDebugReference2_Compare(This,dwCompare,pReference)	\
    (This)->lpVtbl -> Compare(This,dwCompare,pReference)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugReference2_GetReferenceInfo_Proxy( 
    IDebugReference2 * This,
    /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
    /* [in] */ DWORD dwRadix,
    /* [in] */ DWORD dwTimeout,
    /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
    /* [in] */ DWORD dwArgCount,
    /* [out] */ DEBUG_REFERENCE_INFO *pReferenceInfo);


void __RPC_STUB IDebugReference2_GetReferenceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_SetValueAsString_Proxy( 
    IDebugReference2 * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ DWORD dwRadix,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IDebugReference2_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_SetValueAsReference_Proxy( 
    IDebugReference2 * This,
    /* [length_is][size_is][in] */ IDebugReference2 **rgpArgs,
    /* [in] */ DWORD dwArgCount,
    /* [in] */ IDebugReference2 *pValue,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IDebugReference2_SetValueAsReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_EnumChildren_Proxy( 
    IDebugReference2 * This,
    /* [in] */ DEBUGREF_INFO_FLAGS dwFields,
    /* [in] */ DWORD dwRadix,
    /* [in] */ DBG_ATTRIB_FLAGS dwAttribFilter,
    /* [full][in] */ LPCOLESTR pszNameFilter,
    /* [in] */ DWORD dwTimeout,
    /* [out] */ IEnumDebugReferenceInfo2 **ppEnum);


void __RPC_STUB IDebugReference2_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_GetParent_Proxy( 
    IDebugReference2 * This,
    /* [out] */ IDebugReference2 **ppParent);


void __RPC_STUB IDebugReference2_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_GetDerivedMostReference_Proxy( 
    IDebugReference2 * This,
    /* [out] */ IDebugReference2 **ppDerivedMost);


void __RPC_STUB IDebugReference2_GetDerivedMostReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_GetMemoryBytes_Proxy( 
    IDebugReference2 * This,
    /* [out] */ IDebugMemoryBytes2 **ppMemoryBytes);


void __RPC_STUB IDebugReference2_GetMemoryBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_GetMemoryContext_Proxy( 
    IDebugReference2 * This,
    /* [out] */ IDebugMemoryContext2 **ppMemory);


void __RPC_STUB IDebugReference2_GetMemoryContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_GetSize_Proxy( 
    IDebugReference2 * This,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IDebugReference2_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_SetReferenceType_Proxy( 
    IDebugReference2 * This,
    /* [in] */ REFERENCE_TYPE dwRefType);


void __RPC_STUB IDebugReference2_SetReferenceType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugReference2_Compare_Proxy( 
    IDebugReference2 * This,
    /* [in] */ REFERENCE_COMPARE dwCompare,
    /* [in] */ IDebugReference2 *pReference);


void __RPC_STUB IDebugReference2_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugReference2_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrame2_INTERFACE_DEFINED__
#define __IDebugStackFrame2_INTERFACE_DEFINED__

/* interface IDebugStackFrame2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1412926f-5dd6-4e58-b648-e1c63e013d51")
    IDebugStackFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodeContext( 
            /* [out] */ IDebugCodeContext2 **ppCodeCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext2 **ppCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ FRAMEINFO *pFrameInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPhysicalStackRange( 
            /* [out] */ UINT64 *paddrMin,
            /* [out] */ UINT64 *paddrMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpressionContext( 
            /* [out] */ IDebugExpressionContext2 **ppExprCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageInfo( 
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ IDebugProperty2 **ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ UINT nRadix,
            /* [in] */ REFGUID guidFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ULONG *pcelt,
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ IDebugThread2 **ppThread) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugStackFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugStackFrame2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugStackFrame2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugStackFrame2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeContext )( 
            IDebugStackFrame2 * This,
            /* [out] */ IDebugCodeContext2 **ppCodeCxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IDebugStackFrame2 * This,
            /* [out] */ IDebugDocumentContext2 **ppCxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugStackFrame2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugStackFrame2 * This,
            /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ FRAMEINFO *pFrameInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhysicalStackRange )( 
            IDebugStackFrame2 * This,
            /* [out] */ UINT64 *paddrMin,
            /* [out] */ UINT64 *paddrMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpressionContext )( 
            IDebugStackFrame2 * This,
            /* [out] */ IDebugExpressionContext2 **ppExprCxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageInfo )( 
            IDebugStackFrame2 * This,
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugProperty )( 
            IDebugStackFrame2 * This,
            /* [out] */ IDebugProperty2 **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            IDebugStackFrame2 * This,
            /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
            /* [in] */ UINT nRadix,
            /* [in] */ REFGUID guidFilter,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ULONG *pcelt,
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            IDebugStackFrame2 * This,
            /* [out] */ IDebugThread2 **ppThread);
        
        END_INTERFACE
    } IDebugStackFrame2Vtbl;

    interface IDebugStackFrame2
    {
        CONST_VTBL struct IDebugStackFrame2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrame2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStackFrame2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugStackFrame2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugStackFrame2_GetCodeContext(This,ppCodeCxt)	\
    (This)->lpVtbl -> GetCodeContext(This,ppCodeCxt)

#define IDebugStackFrame2_GetDocumentContext(This,ppCxt)	\
    (This)->lpVtbl -> GetDocumentContext(This,ppCxt)

#define IDebugStackFrame2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugStackFrame2_GetInfo(This,dwFieldSpec,nRadix,pFrameInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwFieldSpec,nRadix,pFrameInfo)

#define IDebugStackFrame2_GetPhysicalStackRange(This,paddrMin,paddrMax)	\
    (This)->lpVtbl -> GetPhysicalStackRange(This,paddrMin,paddrMax)

#define IDebugStackFrame2_GetExpressionContext(This,ppExprCxt)	\
    (This)->lpVtbl -> GetExpressionContext(This,ppExprCxt)

#define IDebugStackFrame2_GetLanguageInfo(This,pbstrLanguage,pguidLanguage)	\
    (This)->lpVtbl -> GetLanguageInfo(This,pbstrLanguage,pguidLanguage)

#define IDebugStackFrame2_GetDebugProperty(This,ppProperty)	\
    (This)->lpVtbl -> GetDebugProperty(This,ppProperty)

#define IDebugStackFrame2_EnumProperties(This,dwFields,nRadix,guidFilter,dwTimeout,pcelt,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,dwFields,nRadix,guidFilter,dwTimeout,pcelt,ppEnum)

#define IDebugStackFrame2_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetCodeContext_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ IDebugCodeContext2 **ppCodeCxt);


void __RPC_STUB IDebugStackFrame2_GetCodeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetDocumentContext_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ IDebugDocumentContext2 **ppCxt);


void __RPC_STUB IDebugStackFrame2_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetName_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugStackFrame2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetInfo_Proxy( 
    IDebugStackFrame2 * This,
    /* [in] */ FRAMEINFO_FLAGS dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ FRAMEINFO *pFrameInfo);


void __RPC_STUB IDebugStackFrame2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetPhysicalStackRange_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ UINT64 *paddrMin,
    /* [out] */ UINT64 *paddrMax);


void __RPC_STUB IDebugStackFrame2_GetPhysicalStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetExpressionContext_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ IDebugExpressionContext2 **ppExprCxt);


void __RPC_STUB IDebugStackFrame2_GetExpressionContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetLanguageInfo_Proxy( 
    IDebugStackFrame2 * This,
    /* [full][out][in] */ BSTR *pbstrLanguage,
    /* [full][out][in] */ GUID *pguidLanguage);


void __RPC_STUB IDebugStackFrame2_GetLanguageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetDebugProperty_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ IDebugProperty2 **ppProperty);


void __RPC_STUB IDebugStackFrame2_GetDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_EnumProperties_Proxy( 
    IDebugStackFrame2 * This,
    /* [in] */ DEBUGPROP_INFO_FLAGS dwFields,
    /* [in] */ UINT nRadix,
    /* [in] */ REFGUID guidFilter,
    /* [in] */ DWORD dwTimeout,
    /* [out] */ ULONG *pcelt,
    /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);


void __RPC_STUB IDebugStackFrame2_EnumProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame2_GetThread_Proxy( 
    IDebugStackFrame2 * This,
    /* [out] */ IDebugThread2 **ppThread);


void __RPC_STUB IDebugStackFrame2_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugStackFrame2_INTERFACE_DEFINED__ */


#ifndef __IDebugMemoryContext2_INTERFACE_DEFINED__
#define __IDebugMemoryContext2_INTERFACE_DEFINED__

/* interface IDebugMemoryContext2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugMemoryContext2_0001
    {	CONTEXT_EQUAL	= 0x1,
	CONTEXT_LESS_THAN	= 0x2,
	CONTEXT_GREATER_THAN	= 0x3,
	CONTEXT_LESS_THAN_OR_EQUAL	= 0x4,
	CONTEXT_GREATER_THAN_OR_EQUAL	= 0x5,
	CONTEXT_SAME_SCOPE	= 0x6,
	CONTEXT_SAME_FUNCTION	= 0x7,
	CONTEXT_SAME_MODULE	= 0x8,
	CONTEXT_SAME_PROCESS	= 0x9
    } ;
typedef DWORD CONTEXT_COMPARE;


enum __MIDL_IDebugMemoryContext2_0002
    {	CIF_MODULEURL	= 0x1,
	CIF_FUNCTION	= 0x2,
	CIF_FUNCTIONOFFSET	= 0x4,
	CIF_ADDRESS	= 0x8,
	CIF_ADDRESSOFFSET	= 0x10,
	CIF_ADDRESSABSOLUTE	= 0x20,
	CIF_ALLFIELDS	= 0x3f
    } ;
typedef DWORD CONTEXT_INFO_FIELDS;

typedef struct _tagCONTEXT_INFO
    {
    CONTEXT_INFO_FIELDS dwFields;
    BSTR bstrModuleUrl;
    BSTR bstrFunction;
    TEXT_POSITION posFunctionOffset;
    BSTR bstrAddress;
    BSTR bstrAddressOffset;
    BSTR bstrAddressAbsolute;
    } 	CONTEXT_INFO;


EXTERN_C const IID IID_IDebugMemoryContext2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ab276dd-f27b-4445-825d-5df0b4a04a3a")
    IDebugMemoryContext2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ CONTEXT_INFO_FIELDS dwFields,
            /* [out] */ CONTEXT_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Subtract( 
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ CONTEXT_COMPARE compare,
            /* [length_is][size_is][in] */ IDebugMemoryContext2 **rgpMemoryContextSet,
            /* [in] */ DWORD dwMemoryContextSetLen,
            /* [out] */ DWORD *pdwMemoryContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMemoryContext2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMemoryContext2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMemoryContext2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMemoryContext2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugMemoryContext2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugMemoryContext2 * This,
            /* [in] */ CONTEXT_INFO_FIELDS dwFields,
            /* [out] */ CONTEXT_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDebugMemoryContext2 * This,
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt);
        
        HRESULT ( STDMETHODCALLTYPE *Subtract )( 
            IDebugMemoryContext2 * This,
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IDebugMemoryContext2 * This,
            /* [in] */ CONTEXT_COMPARE compare,
            /* [length_is][size_is][in] */ IDebugMemoryContext2 **rgpMemoryContextSet,
            /* [in] */ DWORD dwMemoryContextSetLen,
            /* [out] */ DWORD *pdwMemoryContext);
        
        END_INTERFACE
    } IDebugMemoryContext2Vtbl;

    interface IDebugMemoryContext2
    {
        CONST_VTBL struct IDebugMemoryContext2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMemoryContext2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMemoryContext2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMemoryContext2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMemoryContext2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugMemoryContext2_GetInfo(This,dwFields,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwFields,pInfo)

#define IDebugMemoryContext2_Add(This,dwCount,ppMemCxt)	\
    (This)->lpVtbl -> Add(This,dwCount,ppMemCxt)

#define IDebugMemoryContext2_Subtract(This,dwCount,ppMemCxt)	\
    (This)->lpVtbl -> Subtract(This,dwCount,ppMemCxt)

#define IDebugMemoryContext2_Compare(This,compare,rgpMemoryContextSet,dwMemoryContextSetLen,pdwMemoryContext)	\
    (This)->lpVtbl -> Compare(This,compare,rgpMemoryContextSet,dwMemoryContextSetLen,pdwMemoryContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMemoryContext2_GetName_Proxy( 
    IDebugMemoryContext2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugMemoryContext2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryContext2_GetInfo_Proxy( 
    IDebugMemoryContext2 * This,
    /* [in] */ CONTEXT_INFO_FIELDS dwFields,
    /* [out] */ CONTEXT_INFO *pInfo);


void __RPC_STUB IDebugMemoryContext2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryContext2_Add_Proxy( 
    IDebugMemoryContext2 * This,
    /* [in] */ UINT64 dwCount,
    /* [out] */ IDebugMemoryContext2 **ppMemCxt);


void __RPC_STUB IDebugMemoryContext2_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryContext2_Subtract_Proxy( 
    IDebugMemoryContext2 * This,
    /* [in] */ UINT64 dwCount,
    /* [out] */ IDebugMemoryContext2 **ppMemCxt);


void __RPC_STUB IDebugMemoryContext2_Subtract_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryContext2_Compare_Proxy( 
    IDebugMemoryContext2 * This,
    /* [in] */ CONTEXT_COMPARE compare,
    /* [length_is][size_is][in] */ IDebugMemoryContext2 **rgpMemoryContextSet,
    /* [in] */ DWORD dwMemoryContextSetLen,
    /* [out] */ DWORD *pdwMemoryContext);


void __RPC_STUB IDebugMemoryContext2_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMemoryContext2_INTERFACE_DEFINED__ */


#ifndef __IDebugCodeContext2_INTERFACE_DEFINED__
#define __IDebugCodeContext2_INTERFACE_DEFINED__

/* interface IDebugCodeContext2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugCodeContext2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac17b76b-2b09-419a-ad5f-7d7402da8875")
    IDebugCodeContext2 : public IDebugMemoryContext2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext2 **ppSrcCxt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageInfo( 
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugCodeContext2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugCodeContext2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugCodeContext2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugCodeContext2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugCodeContext2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugCodeContext2 * This,
            /* [in] */ CONTEXT_INFO_FIELDS dwFields,
            /* [out] */ CONTEXT_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDebugCodeContext2 * This,
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt);
        
        HRESULT ( STDMETHODCALLTYPE *Subtract )( 
            IDebugCodeContext2 * This,
            /* [in] */ UINT64 dwCount,
            /* [out] */ IDebugMemoryContext2 **ppMemCxt);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IDebugCodeContext2 * This,
            /* [in] */ CONTEXT_COMPARE compare,
            /* [length_is][size_is][in] */ IDebugMemoryContext2 **rgpMemoryContextSet,
            /* [in] */ DWORD dwMemoryContextSetLen,
            /* [out] */ DWORD *pdwMemoryContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentContext )( 
            IDebugCodeContext2 * This,
            /* [out] */ IDebugDocumentContext2 **ppSrcCxt);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageInfo )( 
            IDebugCodeContext2 * This,
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage);
        
        END_INTERFACE
    } IDebugCodeContext2Vtbl;

    interface IDebugCodeContext2
    {
        CONST_VTBL struct IDebugCodeContext2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCodeContext2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugCodeContext2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugCodeContext2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugCodeContext2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugCodeContext2_GetInfo(This,dwFields,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwFields,pInfo)

#define IDebugCodeContext2_Add(This,dwCount,ppMemCxt)	\
    (This)->lpVtbl -> Add(This,dwCount,ppMemCxt)

#define IDebugCodeContext2_Subtract(This,dwCount,ppMemCxt)	\
    (This)->lpVtbl -> Subtract(This,dwCount,ppMemCxt)

#define IDebugCodeContext2_Compare(This,compare,rgpMemoryContextSet,dwMemoryContextSetLen,pdwMemoryContext)	\
    (This)->lpVtbl -> Compare(This,compare,rgpMemoryContextSet,dwMemoryContextSetLen,pdwMemoryContext)


#define IDebugCodeContext2_GetDocumentContext(This,ppSrcCxt)	\
    (This)->lpVtbl -> GetDocumentContext(This,ppSrcCxt)

#define IDebugCodeContext2_GetLanguageInfo(This,pbstrLanguage,pguidLanguage)	\
    (This)->lpVtbl -> GetLanguageInfo(This,pbstrLanguage,pguidLanguage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugCodeContext2_GetDocumentContext_Proxy( 
    IDebugCodeContext2 * This,
    /* [out] */ IDebugDocumentContext2 **ppSrcCxt);


void __RPC_STUB IDebugCodeContext2_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugCodeContext2_GetLanguageInfo_Proxy( 
    IDebugCodeContext2 * This,
    /* [full][out][in] */ BSTR *pbstrLanguage,
    /* [full][out][in] */ GUID *pguidLanguage);


void __RPC_STUB IDebugCodeContext2_GetLanguageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugCodeContext2_INTERFACE_DEFINED__ */


#ifndef __IDebugMemoryBytes2_INTERFACE_DEFINED__
#define __IDebugMemoryBytes2_INTERFACE_DEFINED__

/* interface IDebugMemoryBytes2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugMemoryBytes2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("925837d1-3aa1-451a-b7fe-cc04bb42cfb8")
    IDebugMemoryBytes2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadAt( 
            /* [in] */ IDebugMemoryContext2 *pStartContext,
            /* [in] */ DWORD dwCount,
            /* [length_is][size_is][out] */ BYTE *rgbMemory,
            /* [out] */ DWORD *pdwRead,
            /* [full][out][in] */ DWORD *pdwUnreadable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAt( 
            /* [in] */ IDebugMemoryContext2 *pStartContext,
            /* [in] */ DWORD dwCount,
            /* [length_is][size_is][in] */ BYTE *rgbMemory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ UINT64 *pqwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMemoryBytes2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMemoryBytes2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMemoryBytes2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMemoryBytes2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadAt )( 
            IDebugMemoryBytes2 * This,
            /* [in] */ IDebugMemoryContext2 *pStartContext,
            /* [in] */ DWORD dwCount,
            /* [length_is][size_is][out] */ BYTE *rgbMemory,
            /* [out] */ DWORD *pdwRead,
            /* [full][out][in] */ DWORD *pdwUnreadable);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAt )( 
            IDebugMemoryBytes2 * This,
            /* [in] */ IDebugMemoryContext2 *pStartContext,
            /* [in] */ DWORD dwCount,
            /* [length_is][size_is][in] */ BYTE *rgbMemory);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugMemoryBytes2 * This,
            /* [out] */ UINT64 *pqwSize);
        
        END_INTERFACE
    } IDebugMemoryBytes2Vtbl;

    interface IDebugMemoryBytes2
    {
        CONST_VTBL struct IDebugMemoryBytes2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMemoryBytes2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMemoryBytes2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMemoryBytes2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMemoryBytes2_ReadAt(This,pStartContext,dwCount,rgbMemory,pdwRead,pdwUnreadable)	\
    (This)->lpVtbl -> ReadAt(This,pStartContext,dwCount,rgbMemory,pdwRead,pdwUnreadable)

#define IDebugMemoryBytes2_WriteAt(This,pStartContext,dwCount,rgbMemory)	\
    (This)->lpVtbl -> WriteAt(This,pStartContext,dwCount,rgbMemory)

#define IDebugMemoryBytes2_GetSize(This,pqwSize)	\
    (This)->lpVtbl -> GetSize(This,pqwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMemoryBytes2_ReadAt_Proxy( 
    IDebugMemoryBytes2 * This,
    /* [in] */ IDebugMemoryContext2 *pStartContext,
    /* [in] */ DWORD dwCount,
    /* [length_is][size_is][out] */ BYTE *rgbMemory,
    /* [out] */ DWORD *pdwRead,
    /* [full][out][in] */ DWORD *pdwUnreadable);


void __RPC_STUB IDebugMemoryBytes2_ReadAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryBytes2_WriteAt_Proxy( 
    IDebugMemoryBytes2 * This,
    /* [in] */ IDebugMemoryContext2 *pStartContext,
    /* [in] */ DWORD dwCount,
    /* [length_is][size_is][in] */ BYTE *rgbMemory);


void __RPC_STUB IDebugMemoryBytes2_WriteAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMemoryBytes2_GetSize_Proxy( 
    IDebugMemoryBytes2 * This,
    /* [out] */ UINT64 *pqwSize);


void __RPC_STUB IDebugMemoryBytes2_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMemoryBytes2_INTERFACE_DEFINED__ */


#ifndef __IDebugDisassemblyStream2_INTERFACE_DEFINED__
#define __IDebugDisassemblyStream2_INTERFACE_DEFINED__

/* interface IDebugDisassemblyStream2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugDisassemblyStream2_0001
    {	DSF_ADDRESS	= 0x1,
	DSF_ADDRESSOFFSET	= 0x2,
	DSF_CODEBYTES	= 0x4,
	DSF_OPCODE	= 0x8,
	DSF_OPERANDS	= 0x10,
	DSF_SYMBOL	= 0x20,
	DSF_CODELOCATIONID	= 0x40,
	DSF_POSITION	= 0x80,
	DSF_DOCUMENTURL	= 0x100,
	DSF_BYTEOFFSET	= 0x200,
	DSF_FLAGS	= 0x400,
	DSF_OPERANDS_SYMBOLS	= 0x10000,
	DSF_ALL	= 0x107ff
    } ;
typedef DWORD DISASSEMBLY_STREAM_FIELDS;


enum __MIDL_IDebugDisassemblyStream2_0002
    {	DF_DOCUMENTCHANGE	= 0x1,
	DF_DISABLED	= 0x2,
	DF_INSTRUCTION_ACTIVE	= 0x4,
	DF_DATA	= 0x8,
	DF_HASSOURCE	= 0x10
    } ;
typedef DWORD DISASSEMBLY_FLAGS;

typedef struct tagDisassemblyData
    {
    DISASSEMBLY_STREAM_FIELDS dwFields;
    BSTR bstrAddress;
    BSTR bstrAddressOffset;
    BSTR bstrCodeBytes;
    BSTR bstrOpcode;
    BSTR bstrOperands;
    BSTR bstrSymbol;
    UINT64 uCodeLocationId;
    TEXT_POSITION posBeg;
    TEXT_POSITION posEnd;
    BSTR bstrDocumentUrl;
    DWORD dwByteOffset;
    DISASSEMBLY_FLAGS dwFlags;
    } 	DisassemblyData;


enum __MIDL_IDebugDisassemblyStream2_0003
    {	SEEK_START_BEGIN	= 0x1,
	SEEK_START_END	= 0x2,
	SEEK_START_CURRENT	= 0x3,
	SEEK_START_CODECONTEXT	= 0x4,
	SEEK_START_CODELOCID	= 0x5
    } ;
typedef DWORD SEEK_START;


EXTERN_C const IID IID_IDebugDisassemblyStream2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e5b017fe-dfb0-411c-8266-7c64d6f519f8")
    IDebugDisassemblyStream2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ DWORD dwInstructions,
            /* [in] */ DISASSEMBLY_STREAM_FIELDS dwFields,
            /* [out] */ DWORD *pdwInstructionsRead,
            /* [length_is][size_is][out] */ DisassemblyData *prgDisassembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ SEEK_START dwSeekStart,
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [in] */ UINT64 uCodeLocationId,
            /* [in] */ INT64 iInstructions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeLocationId( 
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [out] */ UINT64 *puCodeLocationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeContext( 
            /* [in] */ UINT64 uCodeLocationId,
            /* [out] */ IDebugCodeContext2 **ppCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ UINT64 *puCodeLocationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [in] */ BSTR bstrDocumentUrl,
            /* [out] */ IDebugDocument2 **ppDocument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [out] */ DISASSEMBLY_STREAM_SCOPE *pdwScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ UINT64 *pnSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDisassemblyStream2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDisassemblyStream2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDisassemblyStream2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ DWORD dwInstructions,
            /* [in] */ DISASSEMBLY_STREAM_FIELDS dwFields,
            /* [out] */ DWORD *pdwInstructionsRead,
            /* [length_is][size_is][out] */ DisassemblyData *prgDisassembly);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ SEEK_START dwSeekStart,
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [in] */ UINT64 uCodeLocationId,
            /* [in] */ INT64 iInstructions);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeLocationId )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ IDebugCodeContext2 *pCodeContext,
            /* [out] */ UINT64 *puCodeLocationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeContext )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ UINT64 uCodeLocationId,
            /* [out] */ IDebugCodeContext2 **ppCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDebugDisassemblyStream2 * This,
            /* [out] */ UINT64 *puCodeLocationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugDisassemblyStream2 * This,
            /* [in] */ BSTR bstrDocumentUrl,
            /* [out] */ IDebugDocument2 **ppDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetScope )( 
            IDebugDisassemblyStream2 * This,
            /* [out] */ DISASSEMBLY_STREAM_SCOPE *pdwScope);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugDisassemblyStream2 * This,
            /* [out] */ UINT64 *pnSize);
        
        END_INTERFACE
    } IDebugDisassemblyStream2Vtbl;

    interface IDebugDisassemblyStream2
    {
        CONST_VTBL struct IDebugDisassemblyStream2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDisassemblyStream2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDisassemblyStream2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDisassemblyStream2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDisassemblyStream2_Read(This,dwInstructions,dwFields,pdwInstructionsRead,prgDisassembly)	\
    (This)->lpVtbl -> Read(This,dwInstructions,dwFields,pdwInstructionsRead,prgDisassembly)

#define IDebugDisassemblyStream2_Seek(This,dwSeekStart,pCodeContext,uCodeLocationId,iInstructions)	\
    (This)->lpVtbl -> Seek(This,dwSeekStart,pCodeContext,uCodeLocationId,iInstructions)

#define IDebugDisassemblyStream2_GetCodeLocationId(This,pCodeContext,puCodeLocationId)	\
    (This)->lpVtbl -> GetCodeLocationId(This,pCodeContext,puCodeLocationId)

#define IDebugDisassemblyStream2_GetCodeContext(This,uCodeLocationId,ppCodeContext)	\
    (This)->lpVtbl -> GetCodeContext(This,uCodeLocationId,ppCodeContext)

#define IDebugDisassemblyStream2_GetCurrentLocation(This,puCodeLocationId)	\
    (This)->lpVtbl -> GetCurrentLocation(This,puCodeLocationId)

#define IDebugDisassemblyStream2_GetDocument(This,bstrDocumentUrl,ppDocument)	\
    (This)->lpVtbl -> GetDocument(This,bstrDocumentUrl,ppDocument)

#define IDebugDisassemblyStream2_GetScope(This,pdwScope)	\
    (This)->lpVtbl -> GetScope(This,pdwScope)

#define IDebugDisassemblyStream2_GetSize(This,pnSize)	\
    (This)->lpVtbl -> GetSize(This,pnSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_Read_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [in] */ DWORD dwInstructions,
    /* [in] */ DISASSEMBLY_STREAM_FIELDS dwFields,
    /* [out] */ DWORD *pdwInstructionsRead,
    /* [length_is][size_is][out] */ DisassemblyData *prgDisassembly);


void __RPC_STUB IDebugDisassemblyStream2_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_Seek_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [in] */ SEEK_START dwSeekStart,
    /* [in] */ IDebugCodeContext2 *pCodeContext,
    /* [in] */ UINT64 uCodeLocationId,
    /* [in] */ INT64 iInstructions);


void __RPC_STUB IDebugDisassemblyStream2_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetCodeLocationId_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [in] */ IDebugCodeContext2 *pCodeContext,
    /* [out] */ UINT64 *puCodeLocationId);


void __RPC_STUB IDebugDisassemblyStream2_GetCodeLocationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetCodeContext_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [in] */ UINT64 uCodeLocationId,
    /* [out] */ IDebugCodeContext2 **ppCodeContext);


void __RPC_STUB IDebugDisassemblyStream2_GetCodeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetCurrentLocation_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [out] */ UINT64 *puCodeLocationId);


void __RPC_STUB IDebugDisassemblyStream2_GetCurrentLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetDocument_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [in] */ BSTR bstrDocumentUrl,
    /* [out] */ IDebugDocument2 **ppDocument);


void __RPC_STUB IDebugDisassemblyStream2_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetScope_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [out] */ DISASSEMBLY_STREAM_SCOPE *pdwScope);


void __RPC_STUB IDebugDisassemblyStream2_GetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDisassemblyStream2_GetSize_Proxy( 
    IDebugDisassemblyStream2 * This,
    /* [out] */ UINT64 *pnSize);


void __RPC_STUB IDebugDisassemblyStream2_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDisassemblyStream2_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentContext2_INTERFACE_DEFINED__
#define __IDebugDocumentContext2_INTERFACE_DEFINED__

/* interface IDebugDocumentContext2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugDocumentContext2_0001
    {	DOCCONTEXT_EQUAL	= 0x1,
	DOCCONTEXT_LESS_THAN	= 0x2,
	DOCCONTEXT_GREATER_THAN	= 0x3,
	DOCCONTEXT_SAME_DOCUMENT	= 0x4
    } ;
typedef DWORD DOCCONTEXT_COMPARE;


EXTERN_C const IID IID_IDebugDocumentContext2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("931516ad-b600-419c-88fc-dcf5183b5fa9")
    IDebugDocumentContext2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IDebugDocument2 **ppDocument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts( 
            /* [out] */ IEnumDebugCodeContexts2 **ppEnumCodeCxts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageInfo( 
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatementRange( 
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceRange( 
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ DOCCONTEXT_COMPARE compare,
            /* [length_is][size_is][in] */ IDebugDocumentContext2 **rgpDocContextSet,
            /* [in] */ DWORD dwDocContextSetLen,
            /* [out] */ DWORD *pdwDocContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ int nCount,
            /* [out] */ IDebugDocumentContext2 **ppDocContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentContext2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentContext2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentContext2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentContext2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugDocumentContext2 * This,
            /* [out] */ IDebugDocument2 **ppDocument);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentContext2 * This,
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeContexts )( 
            IDebugDocumentContext2 * This,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnumCodeCxts);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageInfo )( 
            IDebugDocumentContext2 * This,
            /* [full][out][in] */ BSTR *pbstrLanguage,
            /* [full][out][in] */ GUID *pguidLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatementRange )( 
            IDebugDocumentContext2 * This,
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceRange )( 
            IDebugDocumentContext2 * This,
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IDebugDocumentContext2 * This,
            /* [in] */ DOCCONTEXT_COMPARE compare,
            /* [length_is][size_is][in] */ IDebugDocumentContext2 **rgpDocContextSet,
            /* [in] */ DWORD dwDocContextSetLen,
            /* [out] */ DWORD *pdwDocContext);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IDebugDocumentContext2 * This,
            /* [in] */ int nCount,
            /* [out] */ IDebugDocumentContext2 **ppDocContext);
        
        END_INTERFACE
    } IDebugDocumentContext2Vtbl;

    interface IDebugDocumentContext2
    {
        CONST_VTBL struct IDebugDocumentContext2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentContext2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentContext2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentContext2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentContext2_GetDocument(This,ppDocument)	\
    (This)->lpVtbl -> GetDocument(This,ppDocument)

#define IDebugDocumentContext2_GetName(This,gnType,pbstrFileName)	\
    (This)->lpVtbl -> GetName(This,gnType,pbstrFileName)

#define IDebugDocumentContext2_EnumCodeContexts(This,ppEnumCodeCxts)	\
    (This)->lpVtbl -> EnumCodeContexts(This,ppEnumCodeCxts)

#define IDebugDocumentContext2_GetLanguageInfo(This,pbstrLanguage,pguidLanguage)	\
    (This)->lpVtbl -> GetLanguageInfo(This,pbstrLanguage,pguidLanguage)

#define IDebugDocumentContext2_GetStatementRange(This,pBegPosition,pEndPosition)	\
    (This)->lpVtbl -> GetStatementRange(This,pBegPosition,pEndPosition)

#define IDebugDocumentContext2_GetSourceRange(This,pBegPosition,pEndPosition)	\
    (This)->lpVtbl -> GetSourceRange(This,pBegPosition,pEndPosition)

#define IDebugDocumentContext2_Compare(This,compare,rgpDocContextSet,dwDocContextSetLen,pdwDocContext)	\
    (This)->lpVtbl -> Compare(This,compare,rgpDocContextSet,dwDocContextSetLen,pdwDocContext)

#define IDebugDocumentContext2_Seek(This,nCount,ppDocContext)	\
    (This)->lpVtbl -> Seek(This,nCount,ppDocContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_GetDocument_Proxy( 
    IDebugDocumentContext2 * This,
    /* [out] */ IDebugDocument2 **ppDocument);


void __RPC_STUB IDebugDocumentContext2_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_GetName_Proxy( 
    IDebugDocumentContext2 * This,
    /* [in] */ GETNAME_TYPE gnType,
    /* [out] */ BSTR *pbstrFileName);


void __RPC_STUB IDebugDocumentContext2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_EnumCodeContexts_Proxy( 
    IDebugDocumentContext2 * This,
    /* [out] */ IEnumDebugCodeContexts2 **ppEnumCodeCxts);


void __RPC_STUB IDebugDocumentContext2_EnumCodeContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_GetLanguageInfo_Proxy( 
    IDebugDocumentContext2 * This,
    /* [full][out][in] */ BSTR *pbstrLanguage,
    /* [full][out][in] */ GUID *pguidLanguage);


void __RPC_STUB IDebugDocumentContext2_GetLanguageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_GetStatementRange_Proxy( 
    IDebugDocumentContext2 * This,
    /* [full][out][in] */ TEXT_POSITION *pBegPosition,
    /* [full][out][in] */ TEXT_POSITION *pEndPosition);


void __RPC_STUB IDebugDocumentContext2_GetStatementRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_GetSourceRange_Proxy( 
    IDebugDocumentContext2 * This,
    /* [full][out][in] */ TEXT_POSITION *pBegPosition,
    /* [full][out][in] */ TEXT_POSITION *pEndPosition);


void __RPC_STUB IDebugDocumentContext2_GetSourceRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_Compare_Proxy( 
    IDebugDocumentContext2 * This,
    /* [in] */ DOCCONTEXT_COMPARE compare,
    /* [length_is][size_is][in] */ IDebugDocumentContext2 **rgpDocContextSet,
    /* [in] */ DWORD dwDocContextSetLen,
    /* [out] */ DWORD *pdwDocContext);


void __RPC_STUB IDebugDocumentContext2_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext2_Seek_Proxy( 
    IDebugDocumentContext2 * This,
    /* [in] */ int nCount,
    /* [out] */ IDebugDocumentContext2 **ppDocContext);


void __RPC_STUB IDebugDocumentContext2_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocumentContext2_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionContext2_INTERFACE_DEFINED__
#define __IDebugExpressionContext2_INTERFACE_DEFINED__

/* interface IDebugExpressionContext2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugExpressionContext2_0001
    {	PARSE_EXPRESSION	= 0x1,
	PARSE_FUNCTION_AS_ADDRESS	= 0x2
    } ;
typedef DWORD PARSEFLAGS;


EXTERN_C const IID IID_IDebugExpressionContext2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37a44580-d5fc-473e-a048-21702ebfc466")
    IDebugExpressionContext2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseText( 
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ PARSEFLAGS dwFlags,
            /* [in] */ UINT nRadix,
            /* [out] */ IDebugExpression2 **ppExpr,
            /* [out] */ BSTR *pbstrError,
            /* [out] */ UINT *pichError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpressionContext2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpressionContext2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpressionContext2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpressionContext2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugExpressionContext2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *ParseText )( 
            IDebugExpressionContext2 * This,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ PARSEFLAGS dwFlags,
            /* [in] */ UINT nRadix,
            /* [out] */ IDebugExpression2 **ppExpr,
            /* [out] */ BSTR *pbstrError,
            /* [out] */ UINT *pichError);
        
        END_INTERFACE
    } IDebugExpressionContext2Vtbl;

    interface IDebugExpressionContext2
    {
        CONST_VTBL struct IDebugExpressionContext2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionContext2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpressionContext2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpressionContext2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExpressionContext2_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugExpressionContext2_ParseText(This,pszCode,dwFlags,nRadix,ppExpr,pbstrError,pichError)	\
    (This)->lpVtbl -> ParseText(This,pszCode,dwFlags,nRadix,ppExpr,pbstrError,pichError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpressionContext2_GetName_Proxy( 
    IDebugExpressionContext2 * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB IDebugExpressionContext2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpressionContext2_ParseText_Proxy( 
    IDebugExpressionContext2 * This,
    /* [in] */ LPCOLESTR pszCode,
    /* [in] */ PARSEFLAGS dwFlags,
    /* [in] */ UINT nRadix,
    /* [out] */ IDebugExpression2 **ppExpr,
    /* [out] */ BSTR *pbstrError,
    /* [out] */ UINT *pichError);


void __RPC_STUB IDebugExpressionContext2_ParseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExpressionContext2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdbg_0359 */
/* [local] */ 


enum __MIDL___MIDL_itf_msdbg_0359_0001
    {	BPT_NONE	= 0,
	BPT_CODE	= 0x1,
	BPT_DATA	= 0x2,
	BPT_SPECIAL	= 0x3
    } ;
typedef DWORD BP_TYPE;


enum __MIDL___MIDL_itf_msdbg_0359_0002
    {	BPLT_NONE	= 0,
	BPLT_FILE_LINE	= 0x10000,
	BPLT_FUNC_OFFSET	= 0x20000,
	BPLT_CONTEXT	= 0x30000,
	BPLT_STRING	= 0x40000,
	BPLT_ADDRESS	= 0x50000,
	BPLT_RESOLUTION	= 0x60000,
	BPLT_CODE_FILE_LINE	= BPT_CODE | BPLT_FILE_LINE,
	BPLT_CODE_FUNC_OFFSET	= BPT_CODE | BPLT_FUNC_OFFSET,
	BPLT_CODE_CONTEXT	= BPT_CODE | BPLT_CONTEXT,
	BPLT_CODE_STRING	= BPT_CODE | BPLT_STRING,
	BPLT_CODE_ADDRESS	= BPT_CODE | BPLT_ADDRESS,
	BPLT_DATA_STRING	= BPT_DATA | BPLT_STRING,
	BPLT_TYPE_MASK	= 0xffff,
	BPLT_LOCATION_TYPE_MASK	= 0xffff0000
    } ;
typedef DWORD BP_LOCATION_TYPE;

typedef struct _BP_LOCATION_CODE_FILE_LINE
    {
    BSTR bstrContext;
    IDebugDocumentPosition2 *pDocPos;
    } 	BP_LOCATION_CODE_FILE_LINE;

typedef struct _BP_LOCATION_CODE_FUNC_OFFSET
    {
    BSTR bstrContext;
    IDebugFunctionPosition2 *pFuncPos;
    } 	BP_LOCATION_CODE_FUNC_OFFSET;

typedef struct _BP_LOCATION_CODE_CONTEXT
    {
    IDebugCodeContext2 *pCodeContext;
    } 	BP_LOCATION_CODE_CONTEXT;

typedef struct _BP_LOCATION_CODE_STRING
    {
    BSTR bstrContext;
    BSTR bstrCodeExpr;
    } 	BP_LOCATION_CODE_STRING;

typedef struct _BP_LOCATION_CODE_ADDRESS
    {
    BSTR bstrContext;
    BSTR bstrModuleUrl;
    BSTR bstrFunction;
    BSTR bstrAddress;
    } 	BP_LOCATION_CODE_ADDRESS;

typedef struct _BP_LOCATION_DATA_STRING
    {
    IDebugThread2 *pThread;
    BSTR bstrContext;
    BSTR bstrDataExpr;
    DWORD dwNumElements;
    } 	BP_LOCATION_DATA_STRING;

typedef struct _BP_LOCATION_RESOLUTION
    {
    IDebugBreakpointResolution2 *pResolution;
    } 	BP_LOCATION_RESOLUTION;

typedef struct _BP_LOCATION
    {
    BP_LOCATION_TYPE bpLocationType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_msdbg_0359_0003
        {
        /* [case()] */ BP_LOCATION_CODE_FILE_LINE bplocCodeFileLine;
        /* [case()] */ BP_LOCATION_CODE_FUNC_OFFSET bplocCodeFuncOffset;
        /* [case()] */ BP_LOCATION_CODE_CONTEXT bplocCodeContext;
        /* [case()] */ BP_LOCATION_CODE_STRING bplocCodeString;
        /* [case()] */ BP_LOCATION_CODE_ADDRESS bplocCodeAddress;
        /* [case()] */ BP_LOCATION_DATA_STRING bplocDataString;
        /* [case()] */ BP_LOCATION_RESOLUTION bplocResolution;
        /* [default] */ DWORD unused;
        } 	bpLocation;
    } 	BP_LOCATION;


enum __MIDL___MIDL_itf_msdbg_0359_0004
    {	BP_PASSCOUNT_NONE	= 0,
	BP_PASSCOUNT_EQUAL	= 0x1,
	BP_PASSCOUNT_EQUAL_OR_GREATER	= 0x2,
	BP_PASSCOUNT_MOD	= 0x3
    } ;
typedef DWORD BP_PASSCOUNT_STYLE;

typedef struct _BP_PASSCOUNT
    {
    DWORD dwPassCount;
    BP_PASSCOUNT_STYLE stylePassCount;
    } 	BP_PASSCOUNT;


enum __MIDL___MIDL_itf_msdbg_0359_0005
    {	BP_COND_NONE	= 0,
	BP_COND_WHEN_TRUE	= 0x1,
	BP_COND_WHEN_CHANGED	= 0x2
    } ;
typedef DWORD BP_COND_STYLE;

typedef struct _BP_CONDITION
    {
    IDebugThread2 *pThread;
    BP_COND_STYLE styleCondition;
    BSTR bstrContext;
    BSTR bstrCondition;
    UINT nRadix;
    } 	BP_CONDITION;


enum __MIDL___MIDL_itf_msdbg_0359_0006
    {	BP_FLAG_NONE	= 0,
	BP_FLAG_MAP_DOCPOSITION	= 0x1
    } ;
typedef DWORD BP_FLAGS;


enum __MIDL___MIDL_itf_msdbg_0359_0007
    {	BPREQI_BPLOCATION	= 0x1,
	BPREQI_LANGUAGE	= 0x2,
	BPREQI_PROGRAM	= 0x4,
	BPREQI_PROGRAMNAME	= 0x8,
	BPREQI_THREAD	= 0x10,
	BPREQI_THREADNAME	= 0x20,
	BPREQI_PASSCOUNT	= 0x40,
	BPREQI_CONDITION	= 0x80,
	BPREQI_FLAGS	= 0x100,
	BPREQI_ALLFIELDS	= 0xffffffff
    } ;
typedef DWORD BPREQI_FIELDS;

typedef struct _BP_REQUEST_INFO
    {
    BPREQI_FIELDS dwFields;
    GUID guidLanguage;
    BP_LOCATION bpLocation;
    IDebugProgram2 *pProgram;
    BSTR bstrProgramName;
    IDebugThread2 *pThread;
    BSTR bstrThreadName;
    BP_CONDITION bpCondition;
    BP_PASSCOUNT bpPassCount;
    BP_FLAGS dwFlags;
    } 	BP_REQUEST_INFO;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0359_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0359_v0_0_s_ifspec;

#ifndef __IDebugBreakpointRequest2_INTERFACE_DEFINED__
#define __IDebugBreakpointRequest2_INTERFACE_DEFINED__

/* interface IDebugBreakpointRequest2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakpointRequest2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6015fd18-8257-4df3-ac42-f074dedd4cbd")
    IDebugBreakpointRequest2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLocationType( 
            /* [out] */ BP_LOCATION_TYPE *pBPLocationType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestInfo( 
            /* [in] */ BPREQI_FIELDS dwFields,
            /* [out] */ BP_REQUEST_INFO *pBPRequestInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointRequest2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointRequest2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointRequest2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointRequest2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocationType )( 
            IDebugBreakpointRequest2 * This,
            /* [out] */ BP_LOCATION_TYPE *pBPLocationType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestInfo )( 
            IDebugBreakpointRequest2 * This,
            /* [in] */ BPREQI_FIELDS dwFields,
            /* [out] */ BP_REQUEST_INFO *pBPRequestInfo);
        
        END_INTERFACE
    } IDebugBreakpointRequest2Vtbl;

    interface IDebugBreakpointRequest2
    {
        CONST_VTBL struct IDebugBreakpointRequest2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointRequest2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointRequest2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointRequest2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointRequest2_GetLocationType(This,pBPLocationType)	\
    (This)->lpVtbl -> GetLocationType(This,pBPLocationType)

#define IDebugBreakpointRequest2_GetRequestInfo(This,dwFields,pBPRequestInfo)	\
    (This)->lpVtbl -> GetRequestInfo(This,dwFields,pBPRequestInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointRequest2_GetLocationType_Proxy( 
    IDebugBreakpointRequest2 * This,
    /* [out] */ BP_LOCATION_TYPE *pBPLocationType);


void __RPC_STUB IDebugBreakpointRequest2_GetLocationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBreakpointRequest2_GetRequestInfo_Proxy( 
    IDebugBreakpointRequest2 * This,
    /* [in] */ BPREQI_FIELDS dwFields,
    /* [out] */ BP_REQUEST_INFO *pBPRequestInfo);


void __RPC_STUB IDebugBreakpointRequest2_GetRequestInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointRequest2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdbg_0360 */
/* [local] */ 

typedef struct _BP_RESOLUTION_CODE
    {
    IDebugCodeContext2 *pCodeContext;
    } 	BP_RESOLUTION_CODE;


enum __MIDL___MIDL_itf_msdbg_0360_0001
    {	BP_RES_DATA_EMULATED	= 0x1
    } ;
typedef DWORD BP_RES_DATA_FLAGS;

typedef struct _BP_RESOLUTION_DATA
    {
    BSTR bstrDataExpr;
    BSTR bstrFunc;
    BSTR bstrImage;
    BP_RES_DATA_FLAGS dwFlags;
    } 	BP_RESOLUTION_DATA;

typedef struct _BP_RESOLUTION_LOCATION
    {
    BP_TYPE bpType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_msdbg_0360_0002
        {
        /* [case()] */ BP_RESOLUTION_CODE bpresCode;
        /* [case()] */ BP_RESOLUTION_DATA bpresData;
        /* [default] */ int unused;
        } 	bpResLocation;
    } 	BP_RESOLUTION_LOCATION;


enum __MIDL___MIDL_itf_msdbg_0360_0003
    {	BPRESI_BPRESLOCATION	= 0x1,
	BPRESI_PROGRAM	= 0x2,
	BPRESI_THREAD	= 0x4,
	BPRESI_ALLFIELDS	= 0xffffffff
    } ;
typedef DWORD BPRESI_FIELDS;

typedef struct _BP_RESOLUTION_INFO
    {
    BPRESI_FIELDS dwFields;
    BP_RESOLUTION_LOCATION bpResLocation;
    IDebugProgram2 *pProgram;
    IDebugThread2 *pThread;
    } 	BP_RESOLUTION_INFO;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0360_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0360_v0_0_s_ifspec;

#ifndef __IDebugBreakpointResolution2_INTERFACE_DEFINED__
#define __IDebugBreakpointResolution2_INTERFACE_DEFINED__

/* interface IDebugBreakpointResolution2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugBreakpointResolution2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7e66f28-035a-401a-afc7-2e300bd29711")
    IDebugBreakpointResolution2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBreakpointType( 
            /* [out] */ BP_TYPE *pBPType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolutionInfo( 
            /* [in] */ BPRESI_FIELDS dwFields,
            /* [out] */ BP_RESOLUTION_INFO *pBPResolutionInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBreakpointResolution2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBreakpointResolution2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBreakpointResolution2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBreakpointResolution2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpointType )( 
            IDebugBreakpointResolution2 * This,
            /* [out] */ BP_TYPE *pBPType);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolutionInfo )( 
            IDebugBreakpointResolution2 * This,
            /* [in] */ BPRESI_FIELDS dwFields,
            /* [out] */ BP_RESOLUTION_INFO *pBPResolutionInfo);
        
        END_INTERFACE
    } IDebugBreakpointResolution2Vtbl;

    interface IDebugBreakpointResolution2
    {
        CONST_VTBL struct IDebugBreakpointResolution2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBreakpointResolution2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBreakpointResolution2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBreakpointResolution2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBreakpointResolution2_GetBreakpointType(This,pBPType)	\
    (This)->lpVtbl -> GetBreakpointType(This,pBPType)

#define IDebugBreakpointResolution2_GetResolutionInfo(This,dwFields,pBPResolutionInfo)	\
    (This)->lpVtbl -> GetResolutionInfo(This,dwFields,pBPResolutionInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBreakpointResolution2_GetBreakpointType_Proxy( 
    IDebugBreakpointResolution2 * This,
    /* [out] */ BP_TYPE *pBPType);


void __RPC_STUB IDebugBreakpointResolution2_GetBreakpointType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBreakpointResolution2_GetResolutionInfo_Proxy( 
    IDebugBreakpointResolution2 * This,
    /* [in] */ BPRESI_FIELDS dwFields,
    /* [out] */ BP_RESOLUTION_INFO *pBPResolutionInfo);


void __RPC_STUB IDebugBreakpointResolution2_GetResolutionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBreakpointResolution2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msdbg_0361 */
/* [local] */ 


enum __MIDL___MIDL_itf_msdbg_0361_0001
    {	BPET_NONE	= 0,
	BPET_TYPE_WARNING	= 0x1,
	BPET_TYPE_ERROR	= 0x2,
	BPET_SEV_HIGH	= 0xf000000,
	BPET_SEV_GENERAL	= 0x7000000,
	BPET_SEV_LOW	= 0x1000000,
	BPET_TYPE_MASK	= 0xffff,
	BPET_SEV_MASK	= 0xffff0000,
	BPET_GENERAL_WARNING	= BPET_SEV_GENERAL | BPET_TYPE_WARNING,
	BPET_GENERAL_ERROR	= BPET_SEV_GENERAL | BPET_TYPE_ERROR,
	BPET_ALL	= 0xffffffff
    } ;
typedef DWORD BP_ERROR_TYPE;


enum __MIDL___MIDL_itf_msdbg_0361_0002
    {	BPERESI_BPRESLOCATION	= 0x1,
	BPERESI_PROGRAM	= 0x2,
	BPERESI_THREAD	= 0x4,
	BPERESI_MESSAGE	= 0x8,
	BPERESI_TYPE	= 0x10,
	BPERESI_ALLFIELDS	= 0xffffffff
    } ;
typedef DWORD BPERESI_FIELDS;

typedef struct _BP_ERROR_RESOLUTION_INFO
    {
    BPERESI_FIELDS dwFields;
    BP_RESOLUTION_LOCATION bpResLocation;
    IDebugProgram2 *pProgram;
    IDebugThread2 *pThread;
    BSTR bstrMessage;
    BP_ERROR_TYPE dwType;
    } 	BP_ERROR_RESOLUTION_INFO;



extern RPC_IF_HANDLE __MIDL_itf_msdbg_0361_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msdbg_0361_v0_0_s_ifspec;

#ifndef __IDebugErrorBreakpointResolution2_INTERFACE_DEFINED__
#define __IDebugErrorBreakpointResolution2_INTERFACE_DEFINED__

/* interface IDebugErrorBreakpointResolution2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugErrorBreakpointResolution2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("603aedf8-9575-4d30-b8ca-124d1c98ebd8")
    IDebugErrorBreakpointResolution2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBreakpointType( 
            /* [out] */ BP_TYPE *pBPType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolutionInfo( 
            /* [in] */ BPERESI_FIELDS dwFields,
            /* [out] */ BP_ERROR_RESOLUTION_INFO *pErrorResolutionInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugErrorBreakpointResolution2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugErrorBreakpointResolution2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugErrorBreakpointResolution2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugErrorBreakpointResolution2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpointType )( 
            IDebugErrorBreakpointResolution2 * This,
            /* [out] */ BP_TYPE *pBPType);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolutionInfo )( 
            IDebugErrorBreakpointResolution2 * This,
            /* [in] */ BPERESI_FIELDS dwFields,
            /* [out] */ BP_ERROR_RESOLUTION_INFO *pErrorResolutionInfo);
        
        END_INTERFACE
    } IDebugErrorBreakpointResolution2Vtbl;

    interface IDebugErrorBreakpointResolution2
    {
        CONST_VTBL struct IDebugErrorBreakpointResolution2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugErrorBreakpointResolution2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugErrorBreakpointResolution2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugErrorBreakpointResolution2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugErrorBreakpointResolution2_GetBreakpointType(This,pBPType)	\
    (This)->lpVtbl -> GetBreakpointType(This,pBPType)

#define IDebugErrorBreakpointResolution2_GetResolutionInfo(This,dwFields,pErrorResolutionInfo)	\
    (This)->lpVtbl -> GetResolutionInfo(This,dwFields,pErrorResolutionInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugErrorBreakpointResolution2_GetBreakpointType_Proxy( 
    IDebugErrorBreakpointResolution2 * This,
    /* [out] */ BP_TYPE *pBPType);


void __RPC_STUB IDebugErrorBreakpointResolution2_GetBreakpointType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugErrorBreakpointResolution2_GetResolutionInfo_Proxy( 
    IDebugErrorBreakpointResolution2 * This,
    /* [in] */ BPERESI_FIELDS dwFields,
    /* [out] */ BP_ERROR_RESOLUTION_INFO *pErrorResolutionInfo);


void __RPC_STUB IDebugErrorBreakpointResolution2_GetResolutionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugErrorBreakpointResolution2_INTERFACE_DEFINED__ */


#ifndef __IDebugBoundBreakpoint2_INTERFACE_DEFINED__
#define __IDebugBoundBreakpoint2_INTERFACE_DEFINED__

/* interface IDebugBoundBreakpoint2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugBoundBreakpoint2_0001
    {	BPS_NONE	= 0,
	BPS_DELETED	= 0x1,
	BPS_DISABLED	= 0x2,
	BPS_ENABLED	= 0x3
    } ;
typedef DWORD BP_STATE;


EXTERN_C const IID IID_IDebugBoundBreakpoint2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d533d975-3f32-4876-abd0-6d37fda563e7")
    IDebugBoundBreakpoint2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPendingBreakpoint( 
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ BP_STATE *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHitCount( 
            /* [out] */ DWORD *pdwHitCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakpointResolution( 
            /* [out] */ IDebugBreakpointResolution2 **ppBPResolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHitCount( 
            /* [in] */ DWORD dwHitCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCondition( 
            /* [in] */ BP_CONDITION bpCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPassCount( 
            /* [in] */ BP_PASSCOUNT bpPassCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugBoundBreakpoint2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugBoundBreakpoint2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugBoundBreakpoint2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugBoundBreakpoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingBreakpoint )( 
            IDebugBoundBreakpoint2 * This,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDebugBoundBreakpoint2 * This,
            /* [out] */ BP_STATE *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetHitCount )( 
            IDebugBoundBreakpoint2 * This,
            /* [out] */ DWORD *pdwHitCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpointResolution )( 
            IDebugBoundBreakpoint2 * This,
            /* [out] */ IDebugBreakpointResolution2 **ppBPResolution);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IDebugBoundBreakpoint2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *SetHitCount )( 
            IDebugBoundBreakpoint2 * This,
            /* [in] */ DWORD dwHitCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetCondition )( 
            IDebugBoundBreakpoint2 * This,
            /* [in] */ BP_CONDITION bpCondition);
        
        HRESULT ( STDMETHODCALLTYPE *SetPassCount )( 
            IDebugBoundBreakpoint2 * This,
            /* [in] */ BP_PASSCOUNT bpPassCount);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IDebugBoundBreakpoint2 * This);
        
        END_INTERFACE
    } IDebugBoundBreakpoint2Vtbl;

    interface IDebugBoundBreakpoint2
    {
        CONST_VTBL struct IDebugBoundBreakpoint2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugBoundBreakpoint2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugBoundBreakpoint2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugBoundBreakpoint2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugBoundBreakpoint2_GetPendingBreakpoint(This,ppPendingBreakpoint)	\
    (This)->lpVtbl -> GetPendingBreakpoint(This,ppPendingBreakpoint)

#define IDebugBoundBreakpoint2_GetState(This,pState)	\
    (This)->lpVtbl -> GetState(This,pState)

#define IDebugBoundBreakpoint2_GetHitCount(This,pdwHitCount)	\
    (This)->lpVtbl -> GetHitCount(This,pdwHitCount)

#define IDebugBoundBreakpoint2_GetBreakpointResolution(This,ppBPResolution)	\
    (This)->lpVtbl -> GetBreakpointResolution(This,ppBPResolution)

#define IDebugBoundBreakpoint2_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#define IDebugBoundBreakpoint2_SetHitCount(This,dwHitCount)	\
    (This)->lpVtbl -> SetHitCount(This,dwHitCount)

#define IDebugBoundBreakpoint2_SetCondition(This,bpCondition)	\
    (This)->lpVtbl -> SetCondition(This,bpCondition)

#define IDebugBoundBreakpoint2_SetPassCount(This,bpPassCount)	\
    (This)->lpVtbl -> SetPassCount(This,bpPassCount)

#define IDebugBoundBreakpoint2_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_GetPendingBreakpoint_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint);


void __RPC_STUB IDebugBoundBreakpoint2_GetPendingBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_GetState_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [out] */ BP_STATE *pState);


void __RPC_STUB IDebugBoundBreakpoint2_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_GetHitCount_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [out] */ DWORD *pdwHitCount);


void __RPC_STUB IDebugBoundBreakpoint2_GetHitCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_GetBreakpointResolution_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [out] */ IDebugBreakpointResolution2 **ppBPResolution);


void __RPC_STUB IDebugBoundBreakpoint2_GetBreakpointResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_Enable_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IDebugBoundBreakpoint2_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_SetHitCount_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [in] */ DWORD dwHitCount);


void __RPC_STUB IDebugBoundBreakpoint2_SetHitCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_SetCondition_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [in] */ BP_CONDITION bpCondition);


void __RPC_STUB IDebugBoundBreakpoint2_SetCondition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_SetPassCount_Proxy( 
    IDebugBoundBreakpoint2 * This,
    /* [in] */ BP_PASSCOUNT bpPassCount);


void __RPC_STUB IDebugBoundBreakpoint2_SetPassCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugBoundBreakpoint2_Delete_Proxy( 
    IDebugBoundBreakpoint2 * This);


void __RPC_STUB IDebugBoundBreakpoint2_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugBoundBreakpoint2_INTERFACE_DEFINED__ */


#ifndef __IDebugPendingBreakpoint2_INTERFACE_DEFINED__
#define __IDebugPendingBreakpoint2_INTERFACE_DEFINED__

/* interface IDebugPendingBreakpoint2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugPendingBreakpoint2_0001
    {	PBPS_NONE	= 0,
	PBPS_DELETED	= 0x1,
	PBPS_DISABLED	= 0x2,
	PBPS_ENABLED	= 0x3
    } ;
typedef DWORD PENDING_BP_STATE;


enum __MIDL_IDebugPendingBreakpoint2_0002
    {	PBPSF_NONE	= 0,
	PBPSF_VIRTUALIZED	= 0x1
    } ;
typedef DWORD PENDING_BP_STATE_FLAGS;

typedef struct _tagPENDING_BP_STATE_INFO
    {
    PENDING_BP_STATE state;
    PENDING_BP_STATE_FLAGS flags;
    } 	PENDING_BP_STATE_INFO;


EXTERN_C const IID IID_IDebugPendingBreakpoint2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e215ef3-e44c-44d1-b7ba-b2401f7dc23d")
    IDebugPendingBreakpoint2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanBind( 
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppErrorEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Bind( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ PENDING_BP_STATE_INFO *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakpointRequest( 
            /* [out] */ IDebugBreakpointRequest2 **ppBPRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Virtualize( 
            /* [in] */ BOOL fVirtualize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCondition( 
            /* [in] */ BP_CONDITION bpCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPassCount( 
            /* [in] */ BP_PASSCOUNT bpPassCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBoundBreakpoints( 
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumErrorBreakpoints( 
            /* [in] */ BP_ERROR_TYPE bpErrorType,
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPendingBreakpoint2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugPendingBreakpoint2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugPendingBreakpoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CanBind )( 
            IDebugPendingBreakpoint2 * This,
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppErrorEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Bind )( 
            IDebugPendingBreakpoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDebugPendingBreakpoint2 * This,
            /* [out] */ PENDING_BP_STATE_INFO *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpointRequest )( 
            IDebugPendingBreakpoint2 * This,
            /* [out] */ IDebugBreakpointRequest2 **ppBPRequest);
        
        HRESULT ( STDMETHODCALLTYPE *Virtualize )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ BOOL fVirtualize);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *SetCondition )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ BP_CONDITION bpCondition);
        
        HRESULT ( STDMETHODCALLTYPE *SetPassCount )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ BP_PASSCOUNT bpPassCount);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBoundBreakpoints )( 
            IDebugPendingBreakpoint2 * This,
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumErrorBreakpoints )( 
            IDebugPendingBreakpoint2 * This,
            /* [in] */ BP_ERROR_TYPE bpErrorType,
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IDebugPendingBreakpoint2 * This);
        
        END_INTERFACE
    } IDebugPendingBreakpoint2Vtbl;

    interface IDebugPendingBreakpoint2
    {
        CONST_VTBL struct IDebugPendingBreakpoint2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPendingBreakpoint2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPendingBreakpoint2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPendingBreakpoint2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPendingBreakpoint2_CanBind(This,ppErrorEnum)	\
    (This)->lpVtbl -> CanBind(This,ppErrorEnum)

#define IDebugPendingBreakpoint2_Bind(This)	\
    (This)->lpVtbl -> Bind(This)

#define IDebugPendingBreakpoint2_GetState(This,pState)	\
    (This)->lpVtbl -> GetState(This,pState)

#define IDebugPendingBreakpoint2_GetBreakpointRequest(This,ppBPRequest)	\
    (This)->lpVtbl -> GetBreakpointRequest(This,ppBPRequest)

#define IDebugPendingBreakpoint2_Virtualize(This,fVirtualize)	\
    (This)->lpVtbl -> Virtualize(This,fVirtualize)

#define IDebugPendingBreakpoint2_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#define IDebugPendingBreakpoint2_SetCondition(This,bpCondition)	\
    (This)->lpVtbl -> SetCondition(This,bpCondition)

#define IDebugPendingBreakpoint2_SetPassCount(This,bpPassCount)	\
    (This)->lpVtbl -> SetPassCount(This,bpPassCount)

#define IDebugPendingBreakpoint2_EnumBoundBreakpoints(This,ppEnum)	\
    (This)->lpVtbl -> EnumBoundBreakpoints(This,ppEnum)

#define IDebugPendingBreakpoint2_EnumErrorBreakpoints(This,bpErrorType,ppEnum)	\
    (This)->lpVtbl -> EnumErrorBreakpoints(This,bpErrorType,ppEnum)

#define IDebugPendingBreakpoint2_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_CanBind_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [out] */ IEnumDebugErrorBreakpoints2 **ppErrorEnum);


void __RPC_STUB IDebugPendingBreakpoint2_CanBind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_Bind_Proxy( 
    IDebugPendingBreakpoint2 * This);


void __RPC_STUB IDebugPendingBreakpoint2_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_GetState_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [out] */ PENDING_BP_STATE_INFO *pState);


void __RPC_STUB IDebugPendingBreakpoint2_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_GetBreakpointRequest_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [out] */ IDebugBreakpointRequest2 **ppBPRequest);


void __RPC_STUB IDebugPendingBreakpoint2_GetBreakpointRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_Virtualize_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [in] */ BOOL fVirtualize);


void __RPC_STUB IDebugPendingBreakpoint2_Virtualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_Enable_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IDebugPendingBreakpoint2_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_SetCondition_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [in] */ BP_CONDITION bpCondition);


void __RPC_STUB IDebugPendingBreakpoint2_SetCondition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_SetPassCount_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [in] */ BP_PASSCOUNT bpPassCount);


void __RPC_STUB IDebugPendingBreakpoint2_SetPassCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_EnumBoundBreakpoints_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);


void __RPC_STUB IDebugPendingBreakpoint2_EnumBoundBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_EnumErrorBreakpoints_Proxy( 
    IDebugPendingBreakpoint2 * This,
    /* [in] */ BP_ERROR_TYPE bpErrorType,
    /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum);


void __RPC_STUB IDebugPendingBreakpoint2_EnumErrorBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugPendingBreakpoint2_Delete_Proxy( 
    IDebugPendingBreakpoint2 * This);


void __RPC_STUB IDebugPendingBreakpoint2_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPendingBreakpoint2_INTERFACE_DEFINED__ */


#ifndef __IDebugErrorBreakpoint2_INTERFACE_DEFINED__
#define __IDebugErrorBreakpoint2_INTERFACE_DEFINED__

/* interface IDebugErrorBreakpoint2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugErrorBreakpoint2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74570ef7-2486-4089-800c-56e3829b5ca4")
    IDebugErrorBreakpoint2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPendingBreakpoint( 
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakpointResolution( 
            /* [out] */ IDebugErrorBreakpointResolution2 **ppErrorResolution) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugErrorBreakpoint2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugErrorBreakpoint2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugErrorBreakpoint2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugErrorBreakpoint2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingBreakpoint )( 
            IDebugErrorBreakpoint2 * This,
            /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetBreakpointResolution )( 
            IDebugErrorBreakpoint2 * This,
            /* [out] */ IDebugErrorBreakpointResolution2 **ppErrorResolution);
        
        END_INTERFACE
    } IDebugErrorBreakpoint2Vtbl;

    interface IDebugErrorBreakpoint2
    {
        CONST_VTBL struct IDebugErrorBreakpoint2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugErrorBreakpoint2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugErrorBreakpoint2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugErrorBreakpoint2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugErrorBreakpoint2_GetPendingBreakpoint(This,ppPendingBreakpoint)	\
    (This)->lpVtbl -> GetPendingBreakpoint(This,ppPendingBreakpoint)

#define IDebugErrorBreakpoint2_GetBreakpointResolution(This,ppErrorResolution)	\
    (This)->lpVtbl -> GetBreakpointResolution(This,ppErrorResolution)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugErrorBreakpoint2_GetPendingBreakpoint_Proxy( 
    IDebugErrorBreakpoint2 * This,
    /* [out] */ IDebugPendingBreakpoint2 **ppPendingBreakpoint);


void __RPC_STUB IDebugErrorBreakpoint2_GetPendingBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugErrorBreakpoint2_GetBreakpointResolution_Proxy( 
    IDebugErrorBreakpoint2 * This,
    /* [out] */ IDebugErrorBreakpointResolution2 **ppErrorResolution);


void __RPC_STUB IDebugErrorBreakpoint2_GetBreakpointResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugErrorBreakpoint2_INTERFACE_DEFINED__ */


#ifndef __IDebugExpression2_INTERFACE_DEFINED__
#define __IDebugExpression2_INTERFACE_DEFINED__

/* interface IDebugExpression2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugExpression2_0001
    {	EVAL_RETURNVALUE	= 0x2,
	EVAL_NOSIDEEFFECTS	= 0x4,
	EVAL_ALLOWBPS	= 0x8,
	EVAL_ALLOWERRORREPORT	= 0x10,
	EVAL_FUNCTION_AS_ADDRESS	= 0x40,
	EVAL_NOFUNCEVAL	= 0x80,
	EVAL_NOEVENTS	= 0x1000
    } ;
typedef DWORD EVALFLAGS;


EXTERN_C const IID IID_IDebugExpression2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7473fd0-7f75-478d-8d85-a485204e7a2d")
    IDebugExpression2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EvaluateAsync( 
            /* [in] */ EVALFLAGS dwFlags,
            /* [in] */ IDebugEventCallback2 *pExprCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvaluateSync( 
            /* [in] */ EVALFLAGS dwFlags,
            /* [in] */ DWORD dwTimeout,
            /* [in] */ IDebugEventCallback2 *pExprCallback,
            /* [out] */ IDebugProperty2 **ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExpression2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugExpression2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugExpression2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugExpression2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EvaluateAsync )( 
            IDebugExpression2 * This,
            /* [in] */ EVALFLAGS dwFlags,
            /* [in] */ IDebugEventCallback2 *pExprCallback);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IDebugExpression2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *EvaluateSync )( 
            IDebugExpression2 * This,
            /* [in] */ EVALFLAGS dwFlags,
            /* [in] */ DWORD dwTimeout,
            /* [in] */ IDebugEventCallback2 *pExprCallback,
            /* [out] */ IDebugProperty2 **ppResult);
        
        END_INTERFACE
    } IDebugExpression2Vtbl;

    interface IDebugExpression2
    {
        CONST_VTBL struct IDebugExpression2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpression2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpression2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpression2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExpression2_EvaluateAsync(This,dwFlags,pExprCallback)	\
    (This)->lpVtbl -> EvaluateAsync(This,dwFlags,pExprCallback)

#define IDebugExpression2_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IDebugExpression2_EvaluateSync(This,dwFlags,dwTimeout,pExprCallback,ppResult)	\
    (This)->lpVtbl -> EvaluateSync(This,dwFlags,dwTimeout,pExprCallback,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpression2_EvaluateAsync_Proxy( 
    IDebugExpression2 * This,
    /* [in] */ EVALFLAGS dwFlags,
    /* [in] */ IDebugEventCallback2 *pExprCallback);


void __RPC_STUB IDebugExpression2_EvaluateAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression2_Abort_Proxy( 
    IDebugExpression2 * This);


void __RPC_STUB IDebugExpression2_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression2_EvaluateSync_Proxy( 
    IDebugExpression2 * This,
    /* [in] */ EVALFLAGS dwFlags,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ IDebugEventCallback2 *pExprCallback,
    /* [out] */ IDebugProperty2 **ppResult);


void __RPC_STUB IDebugExpression2_EvaluateSync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExpression2_INTERFACE_DEFINED__ */


#ifndef __IDebugModule2_INTERFACE_DEFINED__
#define __IDebugModule2_INTERFACE_DEFINED__

/* interface IDebugModule2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugModule2_0001
    {	MODULE_FLAG_NONE	= 0,
	MODULE_FLAG_SYSTEM	= 0x1,
	MODULE_FLAG_SYMBOLS	= 0x2,
	MODULE_FLAG_64BIT	= 0x4
    } ;
typedef DWORD MODULE_FLAGS;


enum __MIDL_IDebugModule2_0002
    {	MIF_NONE	= 0,
	MIF_NAME	= 0x1,
	MIF_URL	= 0x2,
	MIF_VERSION	= 0x4,
	MIF_DEBUGMESSAGE	= 0x8,
	MIF_LOADADDRESS	= 0x10,
	MIF_PREFFEREDADDRESS	= 0x20,
	MIF_SIZE	= 0x40,
	MIF_LOADORDER	= 0x80,
	MIF_TIMESTAMP	= 0x100,
	MIF_URLSYMBOLLOCATION	= 0x200,
	MIF_FLAGS	= 0x400,
	MIF_ALLFIELDS	= 0x7ff
    } ;
typedef DWORD MODULE_INFO_FIELDS;

typedef struct _tagMODULE_INFO
    {
    MODULE_INFO_FIELDS dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrUrl;
    BSTR m_bstrVersion;
    BSTR m_bstrDebugMessage;
    UINT64 m_addrLoadAddress;
    UINT64 m_addrPreferredLoadAddress;
    DWORD m_dwSize;
    DWORD m_dwLoadOrder;
    FILETIME m_TimeStamp;
    BSTR m_bstrUrlSymbolLocation;
    MODULE_FLAGS m_dwModuleFlags;
    } 	MODULE_INFO;


EXTERN_C const IID IID_IDebugModule2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fc1cd9a-b912-405c-a04c-43ce02cd7df2")
    IDebugModule2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ MODULE_INFO_FIELDS dwFields,
            /* [out] */ MODULE_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReloadSymbols( 
            /* [full][in] */ LPCOLESTR pszUrlToSymbols,
            /* [out] */ BSTR *pbstrDebugMessage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugModule2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugModule2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugModule2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugModule2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugModule2 * This,
            /* [in] */ MODULE_INFO_FIELDS dwFields,
            /* [out] */ MODULE_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ReloadSymbols )( 
            IDebugModule2 * This,
            /* [full][in] */ LPCOLESTR pszUrlToSymbols,
            /* [out] */ BSTR *pbstrDebugMessage);
        
        END_INTERFACE
    } IDebugModule2Vtbl;

    interface IDebugModule2
    {
        CONST_VTBL struct IDebugModule2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugModule2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugModule2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugModule2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugModule2_GetInfo(This,dwFields,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,dwFields,pInfo)

#define IDebugModule2_ReloadSymbols(This,pszUrlToSymbols,pbstrDebugMessage)	\
    (This)->lpVtbl -> ReloadSymbols(This,pszUrlToSymbols,pbstrDebugMessage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugModule2_GetInfo_Proxy( 
    IDebugModule2 * This,
    /* [in] */ MODULE_INFO_FIELDS dwFields,
    /* [out] */ MODULE_INFO *pInfo);


void __RPC_STUB IDebugModule2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugModule2_ReloadSymbols_Proxy( 
    IDebugModule2 * This,
    /* [full][in] */ LPCOLESTR pszUrlToSymbols,
    /* [out] */ BSTR *pbstrDebugMessage);


void __RPC_STUB IDebugModule2_ReloadSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugModule2_INTERFACE_DEFINED__ */


#ifndef __IDebugModuleManaged_INTERFACE_DEFINED__
#define __IDebugModuleManaged_INTERFACE_DEFINED__

/* interface IDebugModuleManaged */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugModuleManaged;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("232397F8-B232-479d-B1BB-2F044C70A0F9")
    IDebugModuleManaged : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMvid( 
            /* [out] */ GUID *mvid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugModuleManagedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugModuleManaged * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugModuleManaged * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugModuleManaged * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMvid )( 
            IDebugModuleManaged * This,
            /* [out] */ GUID *mvid);
        
        END_INTERFACE
    } IDebugModuleManagedVtbl;

    interface IDebugModuleManaged
    {
        CONST_VTBL struct IDebugModuleManagedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugModuleManaged_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugModuleManaged_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugModuleManaged_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugModuleManaged_GetMvid(This,mvid)	\
    (This)->lpVtbl -> GetMvid(This,mvid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugModuleManaged_GetMvid_Proxy( 
    IDebugModuleManaged * This,
    /* [out] */ GUID *mvid);


void __RPC_STUB IDebugModuleManaged_GetMvid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugModuleManaged_INTERFACE_DEFINED__ */


#ifndef __IDebugDocument2_INTERFACE_DEFINED__
#define __IDebugDocument2_INTERFACE_DEFINED__

/* interface IDebugDocument2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1606dd73-5d5f-405c-b4f4-ce32baba2501")
    IDebugDocument2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentClassId( 
            /* [out] */ CLSID *pclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocument2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocument2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocument2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocument2 * This,
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocument2 * This,
            /* [out] */ CLSID *pclsid);
        
        END_INTERFACE
    } IDebugDocument2Vtbl;

    interface IDebugDocument2
    {
        CONST_VTBL struct IDebugDocument2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocument2_GetName(This,gnType,pbstrFileName)	\
    (This)->lpVtbl -> GetName(This,gnType,pbstrFileName)

#define IDebugDocument2_GetDocumentClassId(This,pclsid)	\
    (This)->lpVtbl -> GetDocumentClassId(This,pclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocument2_GetName_Proxy( 
    IDebugDocument2 * This,
    /* [in] */ GETNAME_TYPE gnType,
    /* [out] */ BSTR *pbstrFileName);


void __RPC_STUB IDebugDocument2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocument2_GetDocumentClassId_Proxy( 
    IDebugDocument2 * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB IDebugDocument2_GetDocumentClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocument2_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentText2_INTERFACE_DEFINED__
#define __IDebugDocumentText2_INTERFACE_DEFINED__

/* interface IDebugDocumentText2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentText2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4b0645aa-08ef-4cb9-adb9-0395d6edad35")
    IDebugDocumentText2 : public IDebugDocument2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [full][out][in] */ ULONG *pcNumLines,
            /* [full][out][in] */ ULONG *pcNumChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ ULONG cMaxChars,
            /* [size_is][length_is][out] */ WCHAR *pText,
            /* [out] */ ULONG *pcNumChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentText2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentText2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentText2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentText2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IDebugDocumentText2 * This,
            /* [in] */ GETNAME_TYPE gnType,
            /* [out] */ BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentClassId )( 
            IDebugDocumentText2 * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IDebugDocumentText2 * This,
            /* [full][out][in] */ ULONG *pcNumLines,
            /* [full][out][in] */ ULONG *pcNumChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IDebugDocumentText2 * This,
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ ULONG cMaxChars,
            /* [size_is][length_is][out] */ WCHAR *pText,
            /* [out] */ ULONG *pcNumChars);
        
        END_INTERFACE
    } IDebugDocumentText2Vtbl;

    interface IDebugDocumentText2
    {
        CONST_VTBL struct IDebugDocumentText2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentText2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentText2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentText2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentText2_GetName(This,gnType,pbstrFileName)	\
    (This)->lpVtbl -> GetName(This,gnType,pbstrFileName)

#define IDebugDocumentText2_GetDocumentClassId(This,pclsid)	\
    (This)->lpVtbl -> GetDocumentClassId(This,pclsid)


#define IDebugDocumentText2_GetSize(This,pcNumLines,pcNumChars)	\
    (This)->lpVtbl -> GetSize(This,pcNumLines,pcNumChars)

#define IDebugDocumentText2_GetText(This,pos,cMaxChars,pText,pcNumChars)	\
    (This)->lpVtbl -> GetText(This,pos,cMaxChars,pText,pcNumChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentText2_GetSize_Proxy( 
    IDebugDocumentText2 * This,
    /* [full][out][in] */ ULONG *pcNumLines,
    /* [full][out][in] */ ULONG *pcNumChars);


void __RPC_STUB IDebugDocumentText2_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText2_GetText_Proxy( 
    IDebugDocumentText2 * This,
    /* [in] */ TEXT_POSITION pos,
    /* [in] */ ULONG cMaxChars,
    /* [size_is][length_is][out] */ WCHAR *pText,
    /* [out] */ ULONG *pcNumChars);


void __RPC_STUB IDebugDocumentText2_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocumentText2_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentPosition2_INTERFACE_DEFINED__
#define __IDebugDocumentPosition2_INTERFACE_DEFINED__

/* interface IDebugDocumentPosition2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentPosition2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bdde0eee-3b8d-4c82-b529-33f16b42832e")
    IDebugDocumentPosition2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ BSTR *pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IDebugDocument2 **ppDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPositionInDocument( 
            /* [in] */ IDebugDocument2 *pDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentPosition2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentPosition2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentPosition2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentPosition2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IDebugDocumentPosition2 * This,
            /* [out] */ BSTR *pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            IDebugDocumentPosition2 * This,
            /* [out] */ IDebugDocument2 **ppDoc);
        
        HRESULT ( STDMETHODCALLTYPE *IsPositionInDocument )( 
            IDebugDocumentPosition2 * This,
            /* [in] */ IDebugDocument2 *pDoc);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IDebugDocumentPosition2 * This,
            /* [full][out][in] */ TEXT_POSITION *pBegPosition,
            /* [full][out][in] */ TEXT_POSITION *pEndPosition);
        
        END_INTERFACE
    } IDebugDocumentPosition2Vtbl;

    interface IDebugDocumentPosition2
    {
        CONST_VTBL struct IDebugDocumentPosition2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentPosition2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentPosition2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentPosition2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentPosition2_GetFileName(This,pbstrFileName)	\
    (This)->lpVtbl -> GetFileName(This,pbstrFileName)

#define IDebugDocumentPosition2_GetDocument(This,ppDoc)	\
    (This)->lpVtbl -> GetDocument(This,ppDoc)

#define IDebugDocumentPosition2_IsPositionInDocument(This,pDoc)	\
    (This)->lpVtbl -> IsPositionInDocument(This,pDoc)

#define IDebugDocumentPosition2_GetRange(This,pBegPosition,pEndPosition)	\
    (This)->lpVtbl -> GetRange(This,pBegPosition,pEndPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentPosition2_GetFileName_Proxy( 
    IDebugDocumentPosition2 * This,
    /* [out] */ BSTR *pbstrFileName);


void __RPC_STUB IDebugDocumentPosition2_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentPosition2_GetDocument_Proxy( 
    IDebugDocumentPosition2 * This,
    /* [out] */ IDebugDocument2 **ppDoc);


void __RPC_STUB IDebugDocumentPosition2_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentPosition2_IsPositionInDocument_Proxy( 
    IDebugDocumentPosition2 * This,
    /* [in] */ IDebugDocument2 *pDoc);


void __RPC_STUB IDebugDocumentPosition2_IsPositionInDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentPosition2_GetRange_Proxy( 
    IDebugDocumentPosition2 * This,
    /* [full][out][in] */ TEXT_POSITION *pBegPosition,
    /* [full][out][in] */ TEXT_POSITION *pEndPosition);


void __RPC_STUB IDebugDocumentPosition2_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocumentPosition2_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentPositionOffset2_INTERFACE_DEFINED__
#define __IDebugDocumentPositionOffset2_INTERFACE_DEFINED__

/* interface IDebugDocumentPositionOffset2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentPositionOffset2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("037edd0f-8551-4f7f-8ca0-04d9e29f532d")
    IDebugDocumentPositionOffset2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [full][out][in] */ DWORD *pdwBegOffset,
            /* [full][out][in] */ DWORD *pdwEndOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentPositionOffset2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentPositionOffset2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentPositionOffset2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentPositionOffset2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            IDebugDocumentPositionOffset2 * This,
            /* [full][out][in] */ DWORD *pdwBegOffset,
            /* [full][out][in] */ DWORD *pdwEndOffset);
        
        END_INTERFACE
    } IDebugDocumentPositionOffset2Vtbl;

    interface IDebugDocumentPositionOffset2
    {
        CONST_VTBL struct IDebugDocumentPositionOffset2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentPositionOffset2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentPositionOffset2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentPositionOffset2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentPositionOffset2_GetRange(This,pdwBegOffset,pdwEndOffset)	\
    (This)->lpVtbl -> GetRange(This,pdwBegOffset,pdwEndOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentPositionOffset2_GetRange_Proxy( 
    IDebugDocumentPositionOffset2 * This,
    /* [full][out][in] */ DWORD *pdwBegOffset,
    /* [full][out][in] */ DWORD *pdwEndOffset);


void __RPC_STUB IDebugDocumentPositionOffset2_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocumentPositionOffset2_INTERFACE_DEFINED__ */


#ifndef __IDebugFunctionPosition2_INTERFACE_DEFINED__
#define __IDebugFunctionPosition2_INTERFACE_DEFINED__

/* interface IDebugFunctionPosition2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugFunctionPosition2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ede3b4b-35e7-4b97-8133-02845d600174")
    IDebugFunctionPosition2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFunctionName( 
            /* [out] */ BSTR *pbstrFunctionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [full][out][in] */ TEXT_POSITION *pPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugFunctionPosition2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugFunctionPosition2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugFunctionPosition2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugFunctionPosition2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionName )( 
            IDebugFunctionPosition2 * This,
            /* [out] */ BSTR *pbstrFunctionName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            IDebugFunctionPosition2 * This,
            /* [full][out][in] */ TEXT_POSITION *pPosition);
        
        END_INTERFACE
    } IDebugFunctionPosition2Vtbl;

    interface IDebugFunctionPosition2
    {
        CONST_VTBL struct IDebugFunctionPosition2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugFunctionPosition2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugFunctionPosition2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugFunctionPosition2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugFunctionPosition2_GetFunctionName(This,pbstrFunctionName)	\
    (This)->lpVtbl -> GetFunctionName(This,pbstrFunctionName)

#define IDebugFunctionPosition2_GetOffset(This,pPosition)	\
    (This)->lpVtbl -> GetOffset(This,pPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugFunctionPosition2_GetFunctionName_Proxy( 
    IDebugFunctionPosition2 * This,
    /* [out] */ BSTR *pbstrFunctionName);


void __RPC_STUB IDebugFunctionPosition2_GetFunctionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugFunctionPosition2_GetOffset_Proxy( 
    IDebugFunctionPosition2 * This,
    /* [full][out][in] */ TEXT_POSITION *pPosition);


void __RPC_STUB IDebugFunctionPosition2_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugFunctionPosition2_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentTextEvents2_INTERFACE_DEFINED__
#define __IDebugDocumentTextEvents2_INTERFACE_DEFINED__

/* interface IDebugDocumentTextEvents2 */
/* [unique][uuid][object] */ 

typedef DWORD TEXT_DOC_ATTR_2;

#define	TEXT_DOC_ATTR_READONLY_2	( 0x1 )


EXTERN_C const IID IID_IDebugDocumentTextEvents2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33ec72e3-002f-4966-b91c-5ce2f7ba5124")
    IDebugDocumentTextEvents2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onDestroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onInsertText( 
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToInsert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveText( 
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onReplaceText( 
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToReplace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateTextAttributes( 
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToUpdate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateDocumentAttributes( 
            /* [in] */ TEXT_DOC_ATTR_2 textdocattr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentTextEvents2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentTextEvents2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentTextEvents2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *onDestroy )( 
            IDebugDocumentTextEvents2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *onInsertText )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToInsert);
        
        HRESULT ( STDMETHODCALLTYPE *onRemoveText )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToRemove);
        
        HRESULT ( STDMETHODCALLTYPE *onReplaceText )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToReplace);
        
        HRESULT ( STDMETHODCALLTYPE *onUpdateTextAttributes )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ TEXT_POSITION pos,
            /* [in] */ DWORD dwNumToUpdate);
        
        HRESULT ( STDMETHODCALLTYPE *onUpdateDocumentAttributes )( 
            IDebugDocumentTextEvents2 * This,
            /* [in] */ TEXT_DOC_ATTR_2 textdocattr);
        
        END_INTERFACE
    } IDebugDocumentTextEvents2Vtbl;

    interface IDebugDocumentTextEvents2
    {
        CONST_VTBL struct IDebugDocumentTextEvents2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextEvents2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentTextEvents2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentTextEvents2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentTextEvents2_onDestroy(This)	\
    (This)->lpVtbl -> onDestroy(This)

#define IDebugDocumentTextEvents2_onInsertText(This,pos,dwNumToInsert)	\
    (This)->lpVtbl -> onInsertText(This,pos,dwNumToInsert)

#define IDebugDocumentTextEvents2_onRemoveText(This,pos,dwNumToRemove)	\
    (This)->lpVtbl -> onRemoveText(This,pos,dwNumToRemove)

#define IDebugDocumentTextEvents2_onReplaceText(This,pos,dwNumToReplace)	\
    (This)->lpVtbl -> onReplaceText(This,pos,dwNumToReplace)

#define IDebugDocumentTextEvents2_onUpdateTextAttributes(This,pos,dwNumToUpdate)	\
    (This)->lpVtbl -> onUpdateTextAttributes(This,pos,dwNumToUpdate)

#define IDebugDocumentTextEvents2_onUpdateDocumentAttributes(This,textdocattr)	\
    (This)->lpVtbl -> onUpdateDocumentAttributes(This,textdocattr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onDestroy_Proxy( 
    IDebugDocumentTextEvents2 * This);


void __RPC_STUB IDebugDocumentTextEvents2_onDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onInsertText_Proxy( 
    IDebugDocumentTextEvents2 * This,
    /* [in] */ TEXT_POSITION pos,
    /* [in] */ DWORD dwNumToInsert);


void __RPC_STUB IDebugDocumentTextEvents2_onInsertText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onRemoveText_Proxy( 
    IDebugDocumentTextEvents2 * This,
    /* [in] */ TEXT_POSITION pos,
    /* [in] */ DWORD dwNumToRemove);


void __RPC_STUB IDebugDocumentTextEvents2_onRemoveText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onReplaceText_Proxy( 
    IDebugDocumentTextEvents2 * This,
    /* [in] */ TEXT_POSITION pos,
    /* [in] */ DWORD dwNumToReplace);


void __RPC_STUB IDebugDocumentTextEvents2_onReplaceText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onUpdateTextAttributes_Proxy( 
    IDebugDocumentTextEvents2 * This,
    /* [in] */ TEXT_POSITION pos,
    /* [in] */ DWORD dwNumToUpdate);


void __RPC_STUB IDebugDocumentTextEvents2_onUpdateTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents2_onUpdateDocumentAttributes_Proxy( 
    IDebugDocumentTextEvents2 * This,
    /* [in] */ TEXT_DOC_ATTR_2 textdocattr);


void __RPC_STUB IDebugDocumentTextEvents2_onUpdateDocumentAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugDocumentTextEvents2_INTERFACE_DEFINED__ */


#ifndef __IDebugQueryEngine2_INTERFACE_DEFINED__
#define __IDebugQueryEngine2_INTERFACE_DEFINED__

/* interface IDebugQueryEngine2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugQueryEngine2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c989adc9-f305-4ef5-8ca2-20898e8d0e28")
    IDebugQueryEngine2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEngineInterface( 
            /* [out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugQueryEngine2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugQueryEngine2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugQueryEngine2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugQueryEngine2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEngineInterface )( 
            IDebugQueryEngine2 * This,
            /* [out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IDebugQueryEngine2Vtbl;

    interface IDebugQueryEngine2
    {
        CONST_VTBL struct IDebugQueryEngine2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugQueryEngine2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugQueryEngine2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugQueryEngine2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugQueryEngine2_GetEngineInterface(This,ppUnk)	\
    (This)->lpVtbl -> GetEngineInterface(This,ppUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugQueryEngine2_GetEngineInterface_Proxy( 
    IDebugQueryEngine2 * This,
    /* [out] */ IUnknown **ppUnk);


void __RPC_STUB IDebugQueryEngine2_GetEngineInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugQueryEngine2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugProcesses2_INTERFACE_DEFINED__
#define __IEnumDebugProcesses2_INTERFACE_DEFINED__

/* interface IEnumDebugProcesses2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugProcesses2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96c74ef4-185d-4f9a-8a43-4d2723758e0a")
    IEnumDebugProcesses2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugProcess2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugProcesses2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugProcesses2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugProcesses2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugProcesses2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugProcesses2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugProcesses2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugProcess2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugProcesses2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugProcesses2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugProcesses2 * This,
            /* [out] */ IEnumDebugProcesses2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugProcesses2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugProcesses2Vtbl;

    interface IEnumDebugProcesses2
    {
        CONST_VTBL struct IEnumDebugProcesses2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugProcesses2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugProcesses2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugProcesses2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugProcesses2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugProcesses2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugProcesses2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugProcesses2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugProcesses2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugProcesses2_Next_Proxy( 
    IEnumDebugProcesses2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugProcess2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugProcesses2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugProcesses2_Skip_Proxy( 
    IEnumDebugProcesses2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugProcesses2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugProcesses2_Reset_Proxy( 
    IEnumDebugProcesses2 * This);


void __RPC_STUB IEnumDebugProcesses2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugProcesses2_Clone_Proxy( 
    IEnumDebugProcesses2 * This,
    /* [out] */ IEnumDebugProcesses2 **ppEnum);


void __RPC_STUB IEnumDebugProcesses2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugProcesses2_GetCount_Proxy( 
    IEnumDebugProcesses2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugProcesses2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugProcesses2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPrograms2_INTERFACE_DEFINED__
#define __IEnumDebugPrograms2_INTERFACE_DEFINED__

/* interface IEnumDebugPrograms2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPrograms2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d14bca6-34ce-4efe-ac7e-0abc61dadb20")
    IEnumDebugPrograms2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugProgram2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPrograms2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPrograms2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPrograms2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPrograms2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPrograms2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPrograms2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugProgram2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPrograms2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPrograms2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPrograms2 * This,
            /* [out] */ IEnumDebugPrograms2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPrograms2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPrograms2Vtbl;

    interface IEnumDebugPrograms2
    {
        CONST_VTBL struct IEnumDebugPrograms2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPrograms2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPrograms2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPrograms2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPrograms2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugPrograms2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPrograms2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPrograms2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugPrograms2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugPrograms2_Next_Proxy( 
    IEnumDebugPrograms2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugProgram2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugPrograms2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPrograms2_Skip_Proxy( 
    IEnumDebugPrograms2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPrograms2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPrograms2_Reset_Proxy( 
    IEnumDebugPrograms2 * This);


void __RPC_STUB IEnumDebugPrograms2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPrograms2_Clone_Proxy( 
    IEnumDebugPrograms2 * This,
    /* [out] */ IEnumDebugPrograms2 **ppEnum);


void __RPC_STUB IEnumDebugPrograms2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPrograms2_GetCount_Proxy( 
    IEnumDebugPrograms2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugPrograms2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPrograms2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugThreads2_INTERFACE_DEFINED__
#define __IEnumDebugThreads2_INTERFACE_DEFINED__

/* interface IEnumDebugThreads2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugThreads2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d30dc12-c4f8-433d-9fcc-9ff117e5e5f4")
    IEnumDebugThreads2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugThread2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugThreads2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugThreads2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugThreads2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugThreads2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugThreads2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugThreads2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugThread2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugThreads2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugThreads2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugThreads2 * This,
            /* [out] */ IEnumDebugThreads2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugThreads2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugThreads2Vtbl;

    interface IEnumDebugThreads2
    {
        CONST_VTBL struct IEnumDebugThreads2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugThreads2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugThreads2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugThreads2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugThreads2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugThreads2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugThreads2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugThreads2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugThreads2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugThreads2_Next_Proxy( 
    IEnumDebugThreads2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugThread2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugThreads2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugThreads2_Skip_Proxy( 
    IEnumDebugThreads2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugThreads2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugThreads2_Reset_Proxy( 
    IEnumDebugThreads2 * This);


void __RPC_STUB IEnumDebugThreads2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugThreads2_Clone_Proxy( 
    IEnumDebugThreads2 * This,
    /* [out] */ IEnumDebugThreads2 **ppEnum);


void __RPC_STUB IEnumDebugThreads2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugThreads2_GetCount_Proxy( 
    IEnumDebugThreads2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugThreads2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugThreads2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugStackFrames2_INTERFACE_DEFINED__
#define __IEnumDebugStackFrames2_INTERFACE_DEFINED__

/* interface IEnumDebugStackFrames2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugStackFrames2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cd39102b-4b69-4495-8f29-e0b25c4a8855")
    IEnumDebugStackFrames2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugStackFrame2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugStackFrames2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [out][in] */ ULONG *pIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugStackFrames2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugStackFrames2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugStackFrames2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugStackFrames2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugStackFrames2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugStackFrame2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugStackFrames2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugStackFrames2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugStackFrames2 * This,
            /* [out] */ IEnumDebugStackFrames2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugStackFrames2 * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            IEnumDebugStackFrames2 * This,
            /* [in] */ IDebugStackFrame2 *pStackFrame,
            /* [out][in] */ ULONG *pIndex);
        
        END_INTERFACE
    } IEnumDebugStackFrames2Vtbl;

    interface IEnumDebugStackFrames2
    {
        CONST_VTBL struct IEnumDebugStackFrames2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugStackFrames2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugStackFrames2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugStackFrames2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugStackFrames2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugStackFrames2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugStackFrames2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugStackFrames2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugStackFrames2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define IEnumDebugStackFrames2_GetIndex(This,pStackFrame,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,pStackFrame,pIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_Next_Proxy( 
    IEnumDebugStackFrames2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugStackFrame2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugStackFrames2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_Skip_Proxy( 
    IEnumDebugStackFrames2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugStackFrames2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_Reset_Proxy( 
    IEnumDebugStackFrames2 * This);


void __RPC_STUB IEnumDebugStackFrames2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_Clone_Proxy( 
    IEnumDebugStackFrames2 * This,
    /* [out] */ IEnumDebugStackFrames2 **ppEnum);


void __RPC_STUB IEnumDebugStackFrames2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_GetCount_Proxy( 
    IEnumDebugStackFrames2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugStackFrames2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames2_GetIndex_Proxy( 
    IEnumDebugStackFrames2 * This,
    /* [in] */ IDebugStackFrame2 *pStackFrame,
    /* [out][in] */ ULONG *pIndex);


void __RPC_STUB IEnumDebugStackFrames2_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugStackFrames2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugCodeContexts2_INTERFACE_DEFINED__
#define __IEnumDebugCodeContexts2_INTERFACE_DEFINED__

/* interface IEnumDebugCodeContexts2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugCodeContexts2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad47a80b-eda7-459e-af82-647cc9fbaa50")
    IEnumDebugCodeContexts2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugCodeContext2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugCodeContexts2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugCodeContexts2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugCodeContexts2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugCodeContexts2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugCodeContexts2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugCodeContext2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugCodeContexts2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugCodeContexts2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugCodeContexts2 * This,
            /* [out] */ IEnumDebugCodeContexts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugCodeContexts2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugCodeContexts2Vtbl;

    interface IEnumDebugCodeContexts2
    {
        CONST_VTBL struct IEnumDebugCodeContexts2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugCodeContexts2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugCodeContexts2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugCodeContexts2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugCodeContexts2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugCodeContexts2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugCodeContexts2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugCodeContexts2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugCodeContexts2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts2_Next_Proxy( 
    IEnumDebugCodeContexts2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugCodeContext2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugCodeContexts2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts2_Skip_Proxy( 
    IEnumDebugCodeContexts2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugCodeContexts2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts2_Reset_Proxy( 
    IEnumDebugCodeContexts2 * This);


void __RPC_STUB IEnumDebugCodeContexts2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts2_Clone_Proxy( 
    IEnumDebugCodeContexts2 * This,
    /* [out] */ IEnumDebugCodeContexts2 **ppEnum);


void __RPC_STUB IEnumDebugCodeContexts2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts2_GetCount_Proxy( 
    IEnumDebugCodeContexts2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugCodeContexts2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugCodeContexts2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugBoundBreakpoints2_INTERFACE_DEFINED__
#define __IEnumDebugBoundBreakpoints2_INTERFACE_DEFINED__

/* interface IEnumDebugBoundBreakpoints2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugBoundBreakpoints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0f6b37e0-fcfe-44d9-9112-394ca9b92114")
    IEnumDebugBoundBreakpoints2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugBoundBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugBoundBreakpoints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugBoundBreakpoints2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugBoundBreakpoints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugBoundBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugBoundBreakpoints2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugBoundBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugBoundBreakpoints2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugBoundBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugBoundBreakpoints2 * This,
            /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugBoundBreakpoints2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugBoundBreakpoints2Vtbl;

    interface IEnumDebugBoundBreakpoints2
    {
        CONST_VTBL struct IEnumDebugBoundBreakpoints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugBoundBreakpoints2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugBoundBreakpoints2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugBoundBreakpoints2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugBoundBreakpoints2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugBoundBreakpoints2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugBoundBreakpoints2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugBoundBreakpoints2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugBoundBreakpoints2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugBoundBreakpoints2_Next_Proxy( 
    IEnumDebugBoundBreakpoints2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugBoundBreakpoint2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugBoundBreakpoints2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugBoundBreakpoints2_Skip_Proxy( 
    IEnumDebugBoundBreakpoints2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugBoundBreakpoints2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugBoundBreakpoints2_Reset_Proxy( 
    IEnumDebugBoundBreakpoints2 * This);


void __RPC_STUB IEnumDebugBoundBreakpoints2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugBoundBreakpoints2_Clone_Proxy( 
    IEnumDebugBoundBreakpoints2 * This,
    /* [out] */ IEnumDebugBoundBreakpoints2 **ppEnum);


void __RPC_STUB IEnumDebugBoundBreakpoints2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugBoundBreakpoints2_GetCount_Proxy( 
    IEnumDebugBoundBreakpoints2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugBoundBreakpoints2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugBoundBreakpoints2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPendingBreakpoints2_INTERFACE_DEFINED__
#define __IEnumDebugPendingBreakpoints2_INTERFACE_DEFINED__

/* interface IEnumDebugPendingBreakpoints2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPendingBreakpoints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70d2dc1e-4dcc-4786-a072-9a3b600c216b")
    IEnumDebugPendingBreakpoints2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPendingBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPendingBreakpoints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPendingBreakpoints2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPendingBreakpoints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPendingBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPendingBreakpoints2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPendingBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPendingBreakpoints2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPendingBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPendingBreakpoints2 * This,
            /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPendingBreakpoints2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPendingBreakpoints2Vtbl;

    interface IEnumDebugPendingBreakpoints2
    {
        CONST_VTBL struct IEnumDebugPendingBreakpoints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPendingBreakpoints2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPendingBreakpoints2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPendingBreakpoints2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPendingBreakpoints2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugPendingBreakpoints2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPendingBreakpoints2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPendingBreakpoints2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugPendingBreakpoints2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugPendingBreakpoints2_Next_Proxy( 
    IEnumDebugPendingBreakpoints2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugPendingBreakpoint2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugPendingBreakpoints2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPendingBreakpoints2_Skip_Proxy( 
    IEnumDebugPendingBreakpoints2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPendingBreakpoints2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPendingBreakpoints2_Reset_Proxy( 
    IEnumDebugPendingBreakpoints2 * This);


void __RPC_STUB IEnumDebugPendingBreakpoints2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPendingBreakpoints2_Clone_Proxy( 
    IEnumDebugPendingBreakpoints2 * This,
    /* [out] */ IEnumDebugPendingBreakpoints2 **ppEnum);


void __RPC_STUB IEnumDebugPendingBreakpoints2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPendingBreakpoints2_GetCount_Proxy( 
    IEnumDebugPendingBreakpoints2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugPendingBreakpoints2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPendingBreakpoints2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugErrorBreakpoints2_INTERFACE_DEFINED__
#define __IEnumDebugErrorBreakpoints2_INTERFACE_DEFINED__

/* interface IEnumDebugErrorBreakpoints2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugErrorBreakpoints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e158f5aa-31fe-491b-a9f6-cff934b03a01")
    IEnumDebugErrorBreakpoints2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugErrorBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugErrorBreakpoints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugErrorBreakpoints2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugErrorBreakpoints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugErrorBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugErrorBreakpoints2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugErrorBreakpoint2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugErrorBreakpoints2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugErrorBreakpoints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugErrorBreakpoints2 * This,
            /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugErrorBreakpoints2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugErrorBreakpoints2Vtbl;

    interface IEnumDebugErrorBreakpoints2
    {
        CONST_VTBL struct IEnumDebugErrorBreakpoints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugErrorBreakpoints2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugErrorBreakpoints2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugErrorBreakpoints2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugErrorBreakpoints2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugErrorBreakpoints2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugErrorBreakpoints2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugErrorBreakpoints2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugErrorBreakpoints2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugErrorBreakpoints2_Next_Proxy( 
    IEnumDebugErrorBreakpoints2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugErrorBreakpoint2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugErrorBreakpoints2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorBreakpoints2_Skip_Proxy( 
    IEnumDebugErrorBreakpoints2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugErrorBreakpoints2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorBreakpoints2_Reset_Proxy( 
    IEnumDebugErrorBreakpoints2 * This);


void __RPC_STUB IEnumDebugErrorBreakpoints2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorBreakpoints2_Clone_Proxy( 
    IEnumDebugErrorBreakpoints2 * This,
    /* [out] */ IEnumDebugErrorBreakpoints2 **ppEnum);


void __RPC_STUB IEnumDebugErrorBreakpoints2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorBreakpoints2_GetCount_Proxy( 
    IEnumDebugErrorBreakpoints2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugErrorBreakpoints2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugErrorBreakpoints2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugMachines2_INTERFACE_DEFINED__
#define __IEnumDebugMachines2_INTERFACE_DEFINED__

/* interface IEnumDebugMachines2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugMachines2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61d986ec-1eac-46b6-90ff-402a008f15d1")
    IEnumDebugMachines2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugMachine2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugMachines2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugMachines2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugMachines2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugMachines2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugMachines2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugMachines2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugMachine2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugMachines2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugMachines2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugMachines2 * This,
            /* [out] */ IEnumDebugMachines2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugMachines2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugMachines2Vtbl;

    interface IEnumDebugMachines2
    {
        CONST_VTBL struct IEnumDebugMachines2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugMachines2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugMachines2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugMachines2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugMachines2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugMachines2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugMachines2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugMachines2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugMachines2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugMachines2_Next_Proxy( 
    IEnumDebugMachines2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugMachine2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugMachines2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugMachines2_Skip_Proxy( 
    IEnumDebugMachines2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugMachines2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugMachines2_Reset_Proxy( 
    IEnumDebugMachines2 * This);


void __RPC_STUB IEnumDebugMachines2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugMachines2_Clone_Proxy( 
    IEnumDebugMachines2 * This,
    /* [out] */ IEnumDebugMachines2 **ppEnum);


void __RPC_STUB IEnumDebugMachines2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugMachines2_GetCount_Proxy( 
    IEnumDebugMachines2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugMachines2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugMachines2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExceptionInfo2_INTERFACE_DEFINED__
#define __IEnumDebugExceptionInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugExceptionInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugExceptionInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8e4bbd34-a2f4-41ef-87b5-c563b4ad6ee7")
    IEnumDebugExceptionInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ EXCEPTION_INFO *rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExceptionInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugExceptionInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugExceptionInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugExceptionInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugExceptionInfo2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ EXCEPTION_INFO *rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugExceptionInfo2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugExceptionInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugExceptionInfo2 * This,
            /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugExceptionInfo2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugExceptionInfo2Vtbl;

    interface IEnumDebugExceptionInfo2
    {
        CONST_VTBL struct IEnumDebugExceptionInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExceptionInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExceptionInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExceptionInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExceptionInfo2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugExceptionInfo2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExceptionInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExceptionInfo2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugExceptionInfo2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExceptionInfo2_Next_Proxy( 
    IEnumDebugExceptionInfo2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ EXCEPTION_INFO *rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugExceptionInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExceptionInfo2_Skip_Proxy( 
    IEnumDebugExceptionInfo2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExceptionInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExceptionInfo2_Reset_Proxy( 
    IEnumDebugExceptionInfo2 * This);


void __RPC_STUB IEnumDebugExceptionInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExceptionInfo2_Clone_Proxy( 
    IEnumDebugExceptionInfo2 * This,
    /* [out] */ IEnumDebugExceptionInfo2 **ppEnum);


void __RPC_STUB IEnumDebugExceptionInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExceptionInfo2_GetCount_Proxy( 
    IEnumDebugExceptionInfo2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugExceptionInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExceptionInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugFrameInfo2_INTERFACE_DEFINED__
#define __IEnumDebugFrameInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugFrameInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugFrameInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98bbba48-4c4d-4fff-8340-6097bec9c894")
    IEnumDebugFrameInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ FRAMEINFO *rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugFrameInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugFrameInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugFrameInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugFrameInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugFrameInfo2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ FRAMEINFO *rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugFrameInfo2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugFrameInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugFrameInfo2 * This,
            /* [out] */ IEnumDebugFrameInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugFrameInfo2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugFrameInfo2Vtbl;

    interface IEnumDebugFrameInfo2
    {
        CONST_VTBL struct IEnumDebugFrameInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugFrameInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugFrameInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugFrameInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugFrameInfo2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugFrameInfo2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugFrameInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugFrameInfo2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugFrameInfo2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugFrameInfo2_Next_Proxy( 
    IEnumDebugFrameInfo2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ FRAMEINFO *rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugFrameInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugFrameInfo2_Skip_Proxy( 
    IEnumDebugFrameInfo2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugFrameInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugFrameInfo2_Reset_Proxy( 
    IEnumDebugFrameInfo2 * This);


void __RPC_STUB IEnumDebugFrameInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugFrameInfo2_Clone_Proxy( 
    IEnumDebugFrameInfo2 * This,
    /* [out] */ IEnumDebugFrameInfo2 **ppEnum);


void __RPC_STUB IEnumDebugFrameInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugFrameInfo2_GetCount_Proxy( 
    IEnumDebugFrameInfo2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugFrameInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugFrameInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumCodePaths2_INTERFACE_DEFINED__
#define __IEnumCodePaths2_INTERFACE_DEFINED__

/* interface IEnumCodePaths2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumCodePaths2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b13f80d-cfc6-4b78-81ef-1f7cc33f7639")
    IEnumCodePaths2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CODE_PATH *rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCodePaths2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCodePaths2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCodePaths2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCodePaths2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCodePaths2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCodePaths2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CODE_PATH *rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCodePaths2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCodePaths2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCodePaths2 * This,
            /* [out] */ IEnumCodePaths2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumCodePaths2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumCodePaths2Vtbl;

    interface IEnumCodePaths2
    {
        CONST_VTBL struct IEnumCodePaths2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCodePaths2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCodePaths2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCodePaths2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCodePaths2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCodePaths2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCodePaths2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCodePaths2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumCodePaths2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCodePaths2_Next_Proxy( 
    IEnumCodePaths2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CODE_PATH *rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumCodePaths2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePaths2_Skip_Proxy( 
    IEnumCodePaths2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCodePaths2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePaths2_Reset_Proxy( 
    IEnumCodePaths2 * This);


void __RPC_STUB IEnumCodePaths2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePaths2_Clone_Proxy( 
    IEnumCodePaths2 * This,
    /* [out] */ IEnumCodePaths2 **ppEnum);


void __RPC_STUB IEnumCodePaths2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePaths2_GetCount_Proxy( 
    IEnumCodePaths2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumCodePaths2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCodePaths2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugModules2_INTERFACE_DEFINED__
#define __IEnumDebugModules2_INTERFACE_DEFINED__

/* interface IEnumDebugModules2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugModules2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4c4a2835-682e-4ce1-aebc-1e6b3a165b44")
    IEnumDebugModules2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugModule2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugModules2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugModules2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugModules2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugModules2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugModules2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugModules2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugModule2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugModules2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugModules2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugModules2 * This,
            /* [out] */ IEnumDebugModules2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugModules2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugModules2Vtbl;

    interface IEnumDebugModules2
    {
        CONST_VTBL struct IEnumDebugModules2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugModules2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugModules2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugModules2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugModules2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugModules2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugModules2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugModules2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugModules2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugModules2_Next_Proxy( 
    IEnumDebugModules2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugModule2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugModules2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugModules2_Skip_Proxy( 
    IEnumDebugModules2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugModules2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugModules2_Reset_Proxy( 
    IEnumDebugModules2 * This);


void __RPC_STUB IEnumDebugModules2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugModules2_Clone_Proxy( 
    IEnumDebugModules2 * This,
    /* [out] */ IEnumDebugModules2 **ppEnum);


void __RPC_STUB IEnumDebugModules2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugModules2_GetCount_Proxy( 
    IEnumDebugModules2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugModules2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugModules2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPortSuppliers2_INTERFACE_DEFINED__
#define __IEnumDebugPortSuppliers2_INTERFACE_DEFINED__

/* interface IEnumDebugPortSuppliers2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPortSuppliers2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59c9dc99-3eff-4ff3-b201-98acd01b0d87")
    IEnumDebugPortSuppliers2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPortSupplier2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPortSuppliers2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPortSuppliers2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPortSuppliers2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPortSuppliers2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPortSuppliers2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPortSupplier2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPortSuppliers2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPortSuppliers2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPortSuppliers2 * This,
            /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPortSuppliers2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPortSuppliers2Vtbl;

    interface IEnumDebugPortSuppliers2
    {
        CONST_VTBL struct IEnumDebugPortSuppliers2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPortSuppliers2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPortSuppliers2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPortSuppliers2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPortSuppliers2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugPortSuppliers2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPortSuppliers2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPortSuppliers2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugPortSuppliers2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugPortSuppliers2_Next_Proxy( 
    IEnumDebugPortSuppliers2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugPortSupplier2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugPortSuppliers2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPortSuppliers2_Skip_Proxy( 
    IEnumDebugPortSuppliers2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPortSuppliers2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPortSuppliers2_Reset_Proxy( 
    IEnumDebugPortSuppliers2 * This);


void __RPC_STUB IEnumDebugPortSuppliers2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPortSuppliers2_Clone_Proxy( 
    IEnumDebugPortSuppliers2 * This,
    /* [out] */ IEnumDebugPortSuppliers2 **ppEnum);


void __RPC_STUB IEnumDebugPortSuppliers2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPortSuppliers2_GetCount_Proxy( 
    IEnumDebugPortSuppliers2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugPortSuppliers2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPortSuppliers2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPorts2_INTERFACE_DEFINED__
#define __IEnumDebugPorts2_INTERFACE_DEFINED__

/* interface IEnumDebugPorts2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPorts2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc827c5e-99ae-4ac8-83ad-2ea5c2034333")
    IEnumDebugPorts2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPort2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPorts2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPorts2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPorts2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPorts2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPorts2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPorts2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugPort2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPorts2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPorts2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPorts2 * This,
            /* [out] */ IEnumDebugPorts2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPorts2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPorts2Vtbl;

    interface IEnumDebugPorts2
    {
        CONST_VTBL struct IEnumDebugPorts2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPorts2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPorts2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPorts2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPorts2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugPorts2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPorts2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPorts2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugPorts2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugPorts2_Next_Proxy( 
    IEnumDebugPorts2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugPort2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugPorts2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPorts2_Skip_Proxy( 
    IEnumDebugPorts2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPorts2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPorts2_Reset_Proxy( 
    IEnumDebugPorts2 * This);


void __RPC_STUB IEnumDebugPorts2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPorts2_Clone_Proxy( 
    IEnumDebugPorts2 * This,
    /* [out] */ IEnumDebugPorts2 **ppEnum);


void __RPC_STUB IEnumDebugPorts2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPorts2_GetCount_Proxy( 
    IEnumDebugPorts2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugPorts2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPorts2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo2_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugPropertyInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPropertyInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c7072c3-3ac4-408f-a680-fc5a2f96903e")
    IEnumDebugPropertyInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ DEBUG_PROPERTY_INFO *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugPropertyInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugPropertyInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugPropertyInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugPropertyInfo2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ DEBUG_PROPERTY_INFO *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugPropertyInfo2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugPropertyInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugPropertyInfo2 * This,
            /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugPropertyInfo2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfo2Vtbl;

    interface IEnumDebugPropertyInfo2
    {
        CONST_VTBL struct IEnumDebugPropertyInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugPropertyInfo2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugPropertyInfo2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo2_Next_Proxy( 
    IEnumDebugPropertyInfo2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DEBUG_PROPERTY_INFO *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugPropertyInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo2_Skip_Proxy( 
    IEnumDebugPropertyInfo2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo2_Reset_Proxy( 
    IEnumDebugPropertyInfo2 * This);


void __RPC_STUB IEnumDebugPropertyInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo2_Clone_Proxy( 
    IEnumDebugPropertyInfo2 * This,
    /* [out] */ IEnumDebugPropertyInfo2 **ppEnum);


void __RPC_STUB IEnumDebugPropertyInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo2_GetCount_Proxy( 
    IEnumDebugPropertyInfo2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugReferenceInfo2_INTERFACE_DEFINED__
#define __IEnumDebugReferenceInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugReferenceInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugReferenceInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e459dd12-864f-4aaa-abc1-dcecbc267f04")
    IEnumDebugReferenceInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ DEBUG_REFERENCE_INFO *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugReferenceInfo2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugReferenceInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugReferenceInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugReferenceInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugReferenceInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugReferenceInfo2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ DEBUG_REFERENCE_INFO *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugReferenceInfo2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugReferenceInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugReferenceInfo2 * This,
            /* [out] */ IEnumDebugReferenceInfo2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugReferenceInfo2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugReferenceInfo2Vtbl;

    interface IEnumDebugReferenceInfo2
    {
        CONST_VTBL struct IEnumDebugReferenceInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugReferenceInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugReferenceInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugReferenceInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugReferenceInfo2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugReferenceInfo2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugReferenceInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugReferenceInfo2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugReferenceInfo2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugReferenceInfo2_Next_Proxy( 
    IEnumDebugReferenceInfo2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DEBUG_REFERENCE_INFO *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugReferenceInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugReferenceInfo2_Skip_Proxy( 
    IEnumDebugReferenceInfo2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugReferenceInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugReferenceInfo2_Reset_Proxy( 
    IEnumDebugReferenceInfo2 * This);


void __RPC_STUB IEnumDebugReferenceInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugReferenceInfo2_Clone_Proxy( 
    IEnumDebugReferenceInfo2 * This,
    /* [out] */ IEnumDebugReferenceInfo2 **ppEnum);


void __RPC_STUB IEnumDebugReferenceInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugReferenceInfo2_GetCount_Proxy( 
    IEnumDebugReferenceInfo2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugReferenceInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugReferenceInfo2_INTERFACE_DEFINED__ */



#ifndef __AD2Lib_LIBRARY_DEFINED__
#define __AD2Lib_LIBRARY_DEFINED__

/* library AD2Lib */
/* [uuid] */ 


EXTERN_C const IID LIBID_AD2Lib;

EXTERN_C const CLSID CLSID_SDMServer;

#ifdef __cplusplus

class DECLSPEC_UUID("5eb7d9f7-af21-400e-a2c4-7fd6396f8641")
SDMServer;
#endif

EXTERN_C const CLSID CLSID_MsMachineDebugManager;

#ifdef __cplusplus

class DECLSPEC_UUID("05e1b201-493d-4678-bbcb-18d9caf5c0a9")
MsMachineDebugManager;
#endif

EXTERN_C const CLSID CLSID_MDMUtilServer;

#ifdef __cplusplus

class DECLSPEC_UUID("89370a13-3977-4e7d-aea0-0a9751ae596b")
MDMUtilServer;
#endif
#endif /* __AD2Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\enc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Sat Jan 05 01:23:50 2002
 */
/* Compiler settings for enc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __enc_h__
#define __enc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDebugENC_FWD_DEFINED__
#define __IDebugENC_FWD_DEFINED__
typedef interface IDebugENC IDebugENC;
#endif 	/* __IDebugENC_FWD_DEFINED__ */


#ifndef __IDebugENCLineMap_FWD_DEFINED__
#define __IDebugENCLineMap_FWD_DEFINED__
typedef interface IDebugENCLineMap IDebugENCLineMap;
#endif 	/* __IDebugENCLineMap_FWD_DEFINED__ */


#ifndef __IDebugENCInfo2_FWD_DEFINED__
#define __IDebugENCInfo2_FWD_DEFINED__
typedef interface IDebugENCInfo2 IDebugENCInfo2;
#endif 	/* __IDebugENCInfo2_FWD_DEFINED__ */


#ifndef __IEnumDebugENCInfo2_FWD_DEFINED__
#define __IEnumDebugENCInfo2_FWD_DEFINED__
typedef interface IEnumDebugENCInfo2 IEnumDebugENCInfo2;
#endif 	/* __IEnumDebugENCInfo2_FWD_DEFINED__ */


#ifndef __IDebugENCRelinkInfo2_FWD_DEFINED__
#define __IDebugENCRelinkInfo2_FWD_DEFINED__
typedef interface IDebugENCRelinkInfo2 IDebugENCRelinkInfo2;
#endif 	/* __IDebugENCRelinkInfo2_FWD_DEFINED__ */


#ifndef __IEnumDebugENCRelinkInfo2_FWD_DEFINED__
#define __IEnumDebugENCRelinkInfo2_FWD_DEFINED__
typedef interface IEnumDebugENCRelinkInfo2 IEnumDebugENCRelinkInfo2;
#endif 	/* __IEnumDebugENCRelinkInfo2_FWD_DEFINED__ */


#ifndef __IDebugIDBInfo2_FWD_DEFINED__
#define __IDebugIDBInfo2_FWD_DEFINED__
typedef interface IDebugIDBInfo2 IDebugIDBInfo2;
#endif 	/* __IDebugIDBInfo2_FWD_DEFINED__ */


#ifndef __IEnumDebugIDBInfo2_FWD_DEFINED__
#define __IEnumDebugIDBInfo2_FWD_DEFINED__
typedef interface IEnumDebugIDBInfo2 IEnumDebugIDBInfo2;
#endif 	/* __IEnumDebugIDBInfo2_FWD_DEFINED__ */


#ifndef __IDebugENCBuildInfo2_FWD_DEFINED__
#define __IDebugENCBuildInfo2_FWD_DEFINED__
typedef interface IDebugENCBuildInfo2 IDebugENCBuildInfo2;
#endif 	/* __IDebugENCBuildInfo2_FWD_DEFINED__ */


#ifndef __IDebugENCUpdateOnRelinkEvent2_FWD_DEFINED__
#define __IDebugENCUpdateOnRelinkEvent2_FWD_DEFINED__
typedef interface IDebugENCUpdateOnRelinkEvent2 IDebugENCUpdateOnRelinkEvent2;
#endif 	/* __IDebugENCUpdateOnRelinkEvent2_FWD_DEFINED__ */


#ifndef __IDebugENCUpdateOnStaleCodeEvent2_FWD_DEFINED__
#define __IDebugENCUpdateOnStaleCodeEvent2_FWD_DEFINED__
typedef interface IDebugENCUpdateOnStaleCodeEvent2 IDebugENCUpdateOnStaleCodeEvent2;
#endif 	/* __IDebugENCUpdateOnStaleCodeEvent2_FWD_DEFINED__ */


#ifndef __IDebugENCUpdate_FWD_DEFINED__
#define __IDebugENCUpdate_FWD_DEFINED__
typedef interface IDebugENCUpdate IDebugENCUpdate;
#endif 	/* __IDebugENCUpdate_FWD_DEFINED__ */


#ifndef __IDebugENCSnapshot2_FWD_DEFINED__
#define __IDebugENCSnapshot2_FWD_DEFINED__
typedef interface IDebugENCSnapshot2 IDebugENCSnapshot2;
#endif 	/* __IDebugENCSnapshot2_FWD_DEFINED__ */


#ifndef __IEnumDebugENCSnapshots2_FWD_DEFINED__
#define __IEnumDebugENCSnapshots2_FWD_DEFINED__
typedef interface IEnumDebugENCSnapshots2 IEnumDebugENCSnapshots2;
#endif 	/* __IEnumDebugENCSnapshots2_FWD_DEFINED__ */


#ifndef __IEnumDebugErrorInfos2_FWD_DEFINED__
#define __IEnumDebugErrorInfos2_FWD_DEFINED__
typedef interface IEnumDebugErrorInfos2 IEnumDebugErrorInfos2;
#endif 	/* __IEnumDebugErrorInfos2_FWD_DEFINED__ */


#ifndef __IDebugComPlusSnapshot2_FWD_DEFINED__
#define __IDebugComPlusSnapshot2_FWD_DEFINED__
typedef interface IDebugComPlusSnapshot2 IDebugComPlusSnapshot2;
#endif 	/* __IDebugComPlusSnapshot2_FWD_DEFINED__ */


#ifndef __IDebugNativeSnapshot2_FWD_DEFINED__
#define __IDebugNativeSnapshot2_FWD_DEFINED__
typedef interface IDebugNativeSnapshot2 IDebugNativeSnapshot2;
#endif 	/* __IDebugNativeSnapshot2_FWD_DEFINED__ */


#ifndef __IDebugENCStackFrame2_FWD_DEFINED__
#define __IDebugENCStackFrame2_FWD_DEFINED__
typedef interface IDebugENCStackFrame2 IDebugENCStackFrame2;
#endif 	/* __IDebugENCStackFrame2_FWD_DEFINED__ */


#ifndef __IDebugMetaDataEmit2_FWD_DEFINED__
#define __IDebugMetaDataEmit2_FWD_DEFINED__
typedef interface IDebugMetaDataEmit2 IDebugMetaDataEmit2;
#endif 	/* __IDebugMetaDataEmit2_FWD_DEFINED__ */


#ifndef __IDebugMetaDataDebugEmit2_FWD_DEFINED__
#define __IDebugMetaDataDebugEmit2_FWD_DEFINED__
typedef interface IDebugMetaDataDebugEmit2 IDebugMetaDataDebugEmit2;
#endif 	/* __IDebugMetaDataDebugEmit2_FWD_DEFINED__ */


#ifndef __IDebugENCStateEvents_FWD_DEFINED__
#define __IDebugENCStateEvents_FWD_DEFINED__
typedef interface IDebugENCStateEvents IDebugENCStateEvents;
#endif 	/* __IDebugENCStateEvents_FWD_DEFINED__ */


#ifndef __EncMgr_FWD_DEFINED__
#define __EncMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class EncMgr EncMgr;
#else
typedef struct EncMgr EncMgr;
#endif /* __cplusplus */

#endif 	/* __EncMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "msdbg.h"
#include "sh.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_enc_0000 */
/* [local] */ 





















static const int E_ENC_REBUILD_FAIL = MAKE_HRESULT(1, FACILITY_ITF, 0x0001);
static const int E_VB_ENC_REBUILD_FAIL = MAKE_HRESULT(1, FACILITY_ITF, 0x0011);
static const int E_ENC_REBUILD_FAIL_MODULE_NOT_LOADED = MAKE_HRESULT(1, FACILITY_ITF, 0x0101);
static const int E_ENC_COMMIT_FAIL = MAKE_HRESULT(1, FACILITY_ITF, 0x0002);

enum tagENCSTATE
    {	ENCSTATE_DISABLED	= 0,
	ENCSTATE_ENABLED	= ENCSTATE_DISABLED + 1,
	ENCSTATE_MANAGED_ENC_NOT_SUPPORTED	= ENCSTATE_ENABLED + 1
    } ;
typedef enum tagENCSTATE ENCSTATE;


enum tagApplyCodeChangesResult
    {	ACCR_SUCCESS	= 0,
	ACCR_BUILDERROR	= ACCR_SUCCESS + 1,
	ACCR_CANCOMMITERROR	= ACCR_BUILDERROR + 1,
	ACCR_COMMITERROR	= ACCR_CANCOMMITERROR + 1
    } ;
typedef enum tagApplyCodeChangesResult ApplyCodeChangesResult;



extern RPC_IF_HANDLE __MIDL_itf_enc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_enc_0000_v0_0_s_ifspec;

#ifndef __IDebugENC_INTERFACE_DEFINED__
#define __IDebugENC_INTERFACE_DEFINED__

/* interface IDebugENC */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B104D8B7-AF19-11d2-922C-00A02448799A")
    IDebugENC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRegistryRoot( 
            /* [in] */ LPCOLESTR in_szRegistryRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterDebuggingSession( 
            /* [in] */ IServiceProvider *in_pServiceProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetENCProjectBuildOption( 
            /* [in] */ REFGUID in_guidOption,
            /* [in] */ LPCOLESTR in_szOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InquireENCState( 
            /* [in] */ ENCSTATE *in_pENCSTATE,
            /* [in] */ BOOL fOnContinue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InquireENCRelinkState( 
            /* [in] */ BOOL *in_pbENCRelinking) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapToEdited( 
            /* [in] */ LPCOLESTR in_szFile,
            /* [in] */ ULONG in_LineNo,
            /* [in] */ ULONG in_ColumnNo,
            /* [out] */ ULONG *out_pLineNo,
            /* [out] */ ULONG *out_pColumnNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapToSuperceded( 
            /* [in] */ LPCOLESTR in_szFile,
            /* [in] */ ULONG in_LineNo,
            /* [in] */ ULONG in_ColumnNo,
            /* [out] */ ULONG *out_pLineNo,
            /* [out] */ ULONG *out_pColumnNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyCodeChanges( 
            /* [in] */ IDebugSession2 *in_pSession,
            /* [in] */ BOOL in_fOnContinue,
            /* [out] */ ApplyCodeChangesResult *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelApplyCodeChanges( 
            /* [in] */ IDebugProgram2 *in_pProgram) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveDebuggingSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseENCStateEvents( 
            /* [in] */ IDebugENCStateEvents *in_pENCStateEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseENCStateEvents( 
            /* [in] */ IDebugENCStateEvents *in_pENCStateEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [in] */ LPCOLESTR in_szURL,
            /* [out] */ BSTR *out_pbstrFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDisplayName( 
            /* [in] */ LPCOLESTR in_szURL,
            /* [out] */ BSTR *out_pbstrDisplayFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearENCState( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENC * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegistryRoot )( 
            IDebugENC * This,
            /* [in] */ LPCOLESTR in_szRegistryRoot);
        
        HRESULT ( STDMETHODCALLTYPE *EnterDebuggingSession )( 
            IDebugENC * This,
            /* [in] */ IServiceProvider *in_pServiceProvider);
        
        HRESULT ( STDMETHODCALLTYPE *SetENCProjectBuildOption )( 
            IDebugENC * This,
            /* [in] */ REFGUID in_guidOption,
            /* [in] */ LPCOLESTR in_szOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *InquireENCState )( 
            IDebugENC * This,
            /* [in] */ ENCSTATE *in_pENCSTATE,
            /* [in] */ BOOL fOnContinue);
        
        HRESULT ( STDMETHODCALLTYPE *InquireENCRelinkState )( 
            IDebugENC * This,
            /* [in] */ BOOL *in_pbENCRelinking);
        
        HRESULT ( STDMETHODCALLTYPE *MapToEdited )( 
            IDebugENC * This,
            /* [in] */ LPCOLESTR in_szFile,
            /* [in] */ ULONG in_LineNo,
            /* [in] */ ULONG in_ColumnNo,
            /* [out] */ ULONG *out_pLineNo,
            /* [out] */ ULONG *out_pColumnNo);
        
        HRESULT ( STDMETHODCALLTYPE *MapToSuperceded )( 
            IDebugENC * This,
            /* [in] */ LPCOLESTR in_szFile,
            /* [in] */ ULONG in_LineNo,
            /* [in] */ ULONG in_ColumnNo,
            /* [out] */ ULONG *out_pLineNo,
            /* [out] */ ULONG *out_pColumnNo);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyCodeChanges )( 
            IDebugENC * This,
            /* [in] */ IDebugSession2 *in_pSession,
            /* [in] */ BOOL in_fOnContinue,
            /* [out] */ ApplyCodeChangesResult *result);
        
        HRESULT ( STDMETHODCALLTYPE *CancelApplyCodeChanges )( 
            IDebugENC * This,
            /* [in] */ IDebugProgram2 *in_pProgram);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveDebuggingSession )( 
            IDebugENC * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseENCStateEvents )( 
            IDebugENC * This,
            /* [in] */ IDebugENCStateEvents *in_pENCStateEvents);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseENCStateEvents )( 
            IDebugENC * This,
            /* [in] */ IDebugENCStateEvents *in_pENCStateEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileName )( 
            IDebugENC * This,
            /* [in] */ LPCOLESTR in_szURL,
            /* [out] */ BSTR *out_pbstrFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileDisplayName )( 
            IDebugENC * This,
            /* [in] */ LPCOLESTR in_szURL,
            /* [out] */ BSTR *out_pbstrDisplayFileName);
        
        HRESULT ( STDMETHODCALLTYPE *ClearENCState )( 
            IDebugENC * This);
        
        END_INTERFACE
    } IDebugENCVtbl;

    interface IDebugENC
    {
        CONST_VTBL struct IDebugENCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENC_SetRegistryRoot(This,in_szRegistryRoot)	\
    (This)->lpVtbl -> SetRegistryRoot(This,in_szRegistryRoot)

#define IDebugENC_EnterDebuggingSession(This,in_pServiceProvider)	\
    (This)->lpVtbl -> EnterDebuggingSession(This,in_pServiceProvider)

#define IDebugENC_SetENCProjectBuildOption(This,in_guidOption,in_szOptionValue)	\
    (This)->lpVtbl -> SetENCProjectBuildOption(This,in_guidOption,in_szOptionValue)

#define IDebugENC_InquireENCState(This,in_pENCSTATE,fOnContinue)	\
    (This)->lpVtbl -> InquireENCState(This,in_pENCSTATE,fOnContinue)

#define IDebugENC_InquireENCRelinkState(This,in_pbENCRelinking)	\
    (This)->lpVtbl -> InquireENCRelinkState(This,in_pbENCRelinking)

#define IDebugENC_MapToEdited(This,in_szFile,in_LineNo,in_ColumnNo,out_pLineNo,out_pColumnNo)	\
    (This)->lpVtbl -> MapToEdited(This,in_szFile,in_LineNo,in_ColumnNo,out_pLineNo,out_pColumnNo)

#define IDebugENC_MapToSuperceded(This,in_szFile,in_LineNo,in_ColumnNo,out_pLineNo,out_pColumnNo)	\
    (This)->lpVtbl -> MapToSuperceded(This,in_szFile,in_LineNo,in_ColumnNo,out_pLineNo,out_pColumnNo)

#define IDebugENC_ApplyCodeChanges(This,in_pSession,in_fOnContinue,result)	\
    (This)->lpVtbl -> ApplyCodeChanges(This,in_pSession,in_fOnContinue,result)

#define IDebugENC_CancelApplyCodeChanges(This,in_pProgram)	\
    (This)->lpVtbl -> CancelApplyCodeChanges(This,in_pProgram)

#define IDebugENC_LeaveDebuggingSession(This)	\
    (This)->lpVtbl -> LeaveDebuggingSession(This)

#define IDebugENC_AdviseENCStateEvents(This,in_pENCStateEvents)	\
    (This)->lpVtbl -> AdviseENCStateEvents(This,in_pENCStateEvents)

#define IDebugENC_UnadviseENCStateEvents(This,in_pENCStateEvents)	\
    (This)->lpVtbl -> UnadviseENCStateEvents(This,in_pENCStateEvents)

#define IDebugENC_GetFileName(This,in_szURL,out_pbstrFileName)	\
    (This)->lpVtbl -> GetFileName(This,in_szURL,out_pbstrFileName)

#define IDebugENC_GetFileDisplayName(This,in_szURL,out_pbstrDisplayFileName)	\
    (This)->lpVtbl -> GetFileDisplayName(This,in_szURL,out_pbstrDisplayFileName)

#define IDebugENC_ClearENCState(This)	\
    (This)->lpVtbl -> ClearENCState(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENC_SetRegistryRoot_Proxy( 
    IDebugENC * This,
    /* [in] */ LPCOLESTR in_szRegistryRoot);


void __RPC_STUB IDebugENC_SetRegistryRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_EnterDebuggingSession_Proxy( 
    IDebugENC * This,
    /* [in] */ IServiceProvider *in_pServiceProvider);


void __RPC_STUB IDebugENC_EnterDebuggingSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_SetENCProjectBuildOption_Proxy( 
    IDebugENC * This,
    /* [in] */ REFGUID in_guidOption,
    /* [in] */ LPCOLESTR in_szOptionValue);


void __RPC_STUB IDebugENC_SetENCProjectBuildOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_InquireENCState_Proxy( 
    IDebugENC * This,
    /* [in] */ ENCSTATE *in_pENCSTATE,
    /* [in] */ BOOL fOnContinue);


void __RPC_STUB IDebugENC_InquireENCState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_InquireENCRelinkState_Proxy( 
    IDebugENC * This,
    /* [in] */ BOOL *in_pbENCRelinking);


void __RPC_STUB IDebugENC_InquireENCRelinkState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_MapToEdited_Proxy( 
    IDebugENC * This,
    /* [in] */ LPCOLESTR in_szFile,
    /* [in] */ ULONG in_LineNo,
    /* [in] */ ULONG in_ColumnNo,
    /* [out] */ ULONG *out_pLineNo,
    /* [out] */ ULONG *out_pColumnNo);


void __RPC_STUB IDebugENC_MapToEdited_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_MapToSuperceded_Proxy( 
    IDebugENC * This,
    /* [in] */ LPCOLESTR in_szFile,
    /* [in] */ ULONG in_LineNo,
    /* [in] */ ULONG in_ColumnNo,
    /* [out] */ ULONG *out_pLineNo,
    /* [out] */ ULONG *out_pColumnNo);


void __RPC_STUB IDebugENC_MapToSuperceded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_ApplyCodeChanges_Proxy( 
    IDebugENC * This,
    /* [in] */ IDebugSession2 *in_pSession,
    /* [in] */ BOOL in_fOnContinue,
    /* [out] */ ApplyCodeChangesResult *result);


void __RPC_STUB IDebugENC_ApplyCodeChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_CancelApplyCodeChanges_Proxy( 
    IDebugENC * This,
    /* [in] */ IDebugProgram2 *in_pProgram);


void __RPC_STUB IDebugENC_CancelApplyCodeChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_LeaveDebuggingSession_Proxy( 
    IDebugENC * This);


void __RPC_STUB IDebugENC_LeaveDebuggingSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_AdviseENCStateEvents_Proxy( 
    IDebugENC * This,
    /* [in] */ IDebugENCStateEvents *in_pENCStateEvents);


void __RPC_STUB IDebugENC_AdviseENCStateEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_UnadviseENCStateEvents_Proxy( 
    IDebugENC * This,
    /* [in] */ IDebugENCStateEvents *in_pENCStateEvents);


void __RPC_STUB IDebugENC_UnadviseENCStateEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_GetFileName_Proxy( 
    IDebugENC * This,
    /* [in] */ LPCOLESTR in_szURL,
    /* [out] */ BSTR *out_pbstrFileName);


void __RPC_STUB IDebugENC_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_GetFileDisplayName_Proxy( 
    IDebugENC * This,
    /* [in] */ LPCOLESTR in_szURL,
    /* [out] */ BSTR *out_pbstrDisplayFileName);


void __RPC_STUB IDebugENC_GetFileDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENC_ClearENCState_Proxy( 
    IDebugENC * This);


void __RPC_STUB IDebugENC_ClearENCState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENC_INTERFACE_DEFINED__ */


#ifndef __IDebugENCLineMap_INTERFACE_DEFINED__
#define __IDebugENCLineMap_INTERFACE_DEFINED__

/* interface IDebugENCLineMap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCLineMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8706233B-BD4C-11d2-9238-00A02448799A")
    IDebugENCLineMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEditedSource( 
            /* [out] */ BSTR *out_pbstrEditedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupercededSource( 
            /* [out] */ BSTR *out_pbstrSupercededSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLineModified( 
            /* [in] */ ULONG in_LineNoFromSupercededSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LineMap( 
            /* [in] */ ULONG in_LineNoFromSupercededSource,
            /* [out] */ ULONG *out_pLineNoFromEditedSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReverseLineMap( 
            /* [in] */ ULONG in_LineNoFromEditedSource,
            /* [out] */ ULONG *out_pLineNoFromSupercededSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCLineMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCLineMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCLineMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCLineMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditedSource )( 
            IDebugENCLineMap * This,
            /* [out] */ BSTR *out_pbstrEditedSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupercededSource )( 
            IDebugENCLineMap * This,
            /* [out] */ BSTR *out_pbstrSupercededSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsLineModified )( 
            IDebugENCLineMap * This,
            /* [in] */ ULONG in_LineNoFromSupercededSource);
        
        HRESULT ( STDMETHODCALLTYPE *LineMap )( 
            IDebugENCLineMap * This,
            /* [in] */ ULONG in_LineNoFromSupercededSource,
            /* [out] */ ULONG *out_pLineNoFromEditedSource);
        
        HRESULT ( STDMETHODCALLTYPE *ReverseLineMap )( 
            IDebugENCLineMap * This,
            /* [in] */ ULONG in_LineNoFromEditedSource,
            /* [out] */ ULONG *out_pLineNoFromSupercededSource);
        
        END_INTERFACE
    } IDebugENCLineMapVtbl;

    interface IDebugENCLineMap
    {
        CONST_VTBL struct IDebugENCLineMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCLineMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCLineMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCLineMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCLineMap_GetEditedSource(This,out_pbstrEditedSource)	\
    (This)->lpVtbl -> GetEditedSource(This,out_pbstrEditedSource)

#define IDebugENCLineMap_GetSupercededSource(This,out_pbstrSupercededSource)	\
    (This)->lpVtbl -> GetSupercededSource(This,out_pbstrSupercededSource)

#define IDebugENCLineMap_IsLineModified(This,in_LineNoFromSupercededSource)	\
    (This)->lpVtbl -> IsLineModified(This,in_LineNoFromSupercededSource)

#define IDebugENCLineMap_LineMap(This,in_LineNoFromSupercededSource,out_pLineNoFromEditedSource)	\
    (This)->lpVtbl -> LineMap(This,in_LineNoFromSupercededSource,out_pLineNoFromEditedSource)

#define IDebugENCLineMap_ReverseLineMap(This,in_LineNoFromEditedSource,out_pLineNoFromSupercededSource)	\
    (This)->lpVtbl -> ReverseLineMap(This,in_LineNoFromEditedSource,out_pLineNoFromSupercededSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCLineMap_GetEditedSource_Proxy( 
    IDebugENCLineMap * This,
    /* [out] */ BSTR *out_pbstrEditedSource);


void __RPC_STUB IDebugENCLineMap_GetEditedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCLineMap_GetSupercededSource_Proxy( 
    IDebugENCLineMap * This,
    /* [out] */ BSTR *out_pbstrSupercededSource);


void __RPC_STUB IDebugENCLineMap_GetSupercededSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCLineMap_IsLineModified_Proxy( 
    IDebugENCLineMap * This,
    /* [in] */ ULONG in_LineNoFromSupercededSource);


void __RPC_STUB IDebugENCLineMap_IsLineModified_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCLineMap_LineMap_Proxy( 
    IDebugENCLineMap * This,
    /* [in] */ ULONG in_LineNoFromSupercededSource,
    /* [out] */ ULONG *out_pLineNoFromEditedSource);


void __RPC_STUB IDebugENCLineMap_LineMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCLineMap_ReverseLineMap_Proxy( 
    IDebugENCLineMap * This,
    /* [in] */ ULONG in_LineNoFromEditedSource,
    /* [out] */ ULONG *out_pLineNoFromSupercededSource);


void __RPC_STUB IDebugENCLineMap_ReverseLineMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCLineMap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_enc_0373 */
/* [local] */ 


enum __MIDL___MIDL_itf_enc_0373_0001
    {	ENCINFO_STACKFRAME	= 0x1,
	ENCINFO_HRESULT_FROM_DE	= 0x2,
	ENCINFO_ERROR_NO	= 0x4,
	ENCINFO_ERROR_BSTR	= 0x8,
	ENCINFO_CODE_CONTEXT	= 0x10,
	ENCINFO_EXTENDED_INFO	= 0x20
    } ;
typedef DWORD ENCINFO_FLAGS;

typedef struct tagENCINFO
    {
    ENCINFO_FLAGS m_dwValidFields;
    IDebugStackFrame2 *m_pStackFrame;
    HRESULT m_HRFromDE;
    DWORD m_dwErrorNo;
    BSTR m_bstrError;
    IDebugCodeContext2 *m_pCodeContext;
    IUnknown *m_pExtendedInfo;
    } 	ENCINFO;



extern RPC_IF_HANDLE __MIDL_itf_enc_0373_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_enc_0373_v0_0_s_ifspec;

#ifndef __IDebugENCInfo2_INTERFACE_DEFINED__
#define __IDebugENCInfo2_INTERFACE_DEFINED__

/* interface IDebugENCInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B56106F-BD51-11d2-9238-00A02448799A")
    IDebugENCInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ ENCINFO *out_pENCINFO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugENCInfo2 * This,
            /* [out] */ ENCINFO *out_pENCINFO);
        
        END_INTERFACE
    } IDebugENCInfo2Vtbl;

    interface IDebugENCInfo2
    {
        CONST_VTBL struct IDebugENCInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCInfo2_GetInfo(This,out_pENCINFO)	\
    (This)->lpVtbl -> GetInfo(This,out_pENCINFO)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCInfo2_GetInfo_Proxy( 
    IDebugENCInfo2 * This,
    /* [out] */ ENCINFO *out_pENCINFO);


void __RPC_STUB IDebugENCInfo2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugENCInfo2_INTERFACE_DEFINED__
#define __IEnumDebugENCInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugENCInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugENCInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B076AD1-BD51-11d2-9238-00A02448799A")
    IEnumDebugENCInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugENCInfo2 **out_ArrayOfpENCInfo,
            /* [out] */ ULONG *out_pNoOfElementsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG in_NoOfElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *out_pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugENCInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugENCInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugENCInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugENCInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugENCInfo2 * This,
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugENCInfo2 **out_ArrayOfpENCInfo,
            /* [out] */ ULONG *out_pNoOfElementsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugENCInfo2 * This,
            /* [in] */ ULONG in_NoOfElements);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugENCInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugENCInfo2 * This,
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugENCInfo2 * This,
            /* [out] */ ULONG *out_pCount);
        
        END_INTERFACE
    } IEnumDebugENCInfo2Vtbl;

    interface IEnumDebugENCInfo2
    {
        CONST_VTBL struct IEnumDebugENCInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugENCInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugENCInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugENCInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugENCInfo2_Next(This,in_NoOfElementsRequested,out_ArrayOfpENCInfo,out_pNoOfElementsFetched)	\
    (This)->lpVtbl -> Next(This,in_NoOfElementsRequested,out_ArrayOfpENCInfo,out_pNoOfElementsFetched)

#define IEnumDebugENCInfo2_Skip(This,in_NoOfElements)	\
    (This)->lpVtbl -> Skip(This,in_NoOfElements)

#define IEnumDebugENCInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugENCInfo2_Clone(This,out_ppEnumENCInfo)	\
    (This)->lpVtbl -> Clone(This,out_ppEnumENCInfo)

#define IEnumDebugENCInfo2_GetCount(This,out_pCount)	\
    (This)->lpVtbl -> GetCount(This,out_pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugENCInfo2_Next_Proxy( 
    IEnumDebugENCInfo2 * This,
    /* [in] */ ULONG in_NoOfElementsRequested,
    /* [length_is][size_is][out] */ IDebugENCInfo2 **out_ArrayOfpENCInfo,
    /* [out] */ ULONG *out_pNoOfElementsFetched);


void __RPC_STUB IEnumDebugENCInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCInfo2_Skip_Proxy( 
    IEnumDebugENCInfo2 * This,
    /* [in] */ ULONG in_NoOfElements);


void __RPC_STUB IEnumDebugENCInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCInfo2_Reset_Proxy( 
    IEnumDebugENCInfo2 * This);


void __RPC_STUB IEnumDebugENCInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCInfo2_Clone_Proxy( 
    IEnumDebugENCInfo2 * This,
    /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);


void __RPC_STUB IEnumDebugENCInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCInfo2_GetCount_Proxy( 
    IEnumDebugENCInfo2 * This,
    /* [out] */ ULONG *out_pCount);


void __RPC_STUB IEnumDebugENCInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugENCInfo2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCRelinkInfo2_INTERFACE_DEFINED__
#define __IDebugENCRelinkInfo2_INTERFACE_DEFINED__

/* interface IDebugENCRelinkInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCRelinkInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CBB63A8D-BD57-11d2-9238-00A02448799A")
    IDebugENCRelinkInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ BSTR *out_pbstrWorkingDir,
            /* [out] */ BSTR *out_pbstrCommand,
            /* [out] */ BSTR *out_pbstrOutFile,
            /* [out] */ BSTR *out_pbstrDebugFile,
            /* [out] */ BOOL *out_pbEditFromLib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCRelinkInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCRelinkInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCRelinkInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCRelinkInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugENCRelinkInfo2 * This,
            /* [out] */ BSTR *out_pbstrWorkingDir,
            /* [out] */ BSTR *out_pbstrCommand,
            /* [out] */ BSTR *out_pbstrOutFile,
            /* [out] */ BSTR *out_pbstrDebugFile,
            /* [out] */ BOOL *out_pbEditFromLib);
        
        END_INTERFACE
    } IDebugENCRelinkInfo2Vtbl;

    interface IDebugENCRelinkInfo2
    {
        CONST_VTBL struct IDebugENCRelinkInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCRelinkInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCRelinkInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCRelinkInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCRelinkInfo2_GetInfo(This,out_pbstrWorkingDir,out_pbstrCommand,out_pbstrOutFile,out_pbstrDebugFile,out_pbEditFromLib)	\
    (This)->lpVtbl -> GetInfo(This,out_pbstrWorkingDir,out_pbstrCommand,out_pbstrOutFile,out_pbstrDebugFile,out_pbEditFromLib)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCRelinkInfo2_GetInfo_Proxy( 
    IDebugENCRelinkInfo2 * This,
    /* [out] */ BSTR *out_pbstrWorkingDir,
    /* [out] */ BSTR *out_pbstrCommand,
    /* [out] */ BSTR *out_pbstrOutFile,
    /* [out] */ BSTR *out_pbstrDebugFile,
    /* [out] */ BOOL *out_pbEditFromLib);


void __RPC_STUB IDebugENCRelinkInfo2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCRelinkInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugENCRelinkInfo2_INTERFACE_DEFINED__
#define __IEnumDebugENCRelinkInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugENCRelinkInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugENCRelinkInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E51BE743-BD57-11d2-9238-00A02448799A")
    IEnumDebugENCRelinkInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugENCRelinkInfo2 **out_ArrayOfpENCInfo,
            /* [out] */ ULONG *out_pNoOfElementsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG in_NoOfElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *out_pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugENCRelinkInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugENCRelinkInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugENCRelinkInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugENCRelinkInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugENCRelinkInfo2 * This,
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugENCRelinkInfo2 **out_ArrayOfpENCInfo,
            /* [out] */ ULONG *out_pNoOfElementsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugENCRelinkInfo2 * This,
            /* [in] */ ULONG in_NoOfElements);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugENCRelinkInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugENCRelinkInfo2 * This,
            /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugENCRelinkInfo2 * This,
            /* [out] */ ULONG *out_pCount);
        
        END_INTERFACE
    } IEnumDebugENCRelinkInfo2Vtbl;

    interface IEnumDebugENCRelinkInfo2
    {
        CONST_VTBL struct IEnumDebugENCRelinkInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugENCRelinkInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugENCRelinkInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugENCRelinkInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugENCRelinkInfo2_Next(This,in_NoOfElementsRequested,out_ArrayOfpENCInfo,out_pNoOfElementsFetched)	\
    (This)->lpVtbl -> Next(This,in_NoOfElementsRequested,out_ArrayOfpENCInfo,out_pNoOfElementsFetched)

#define IEnumDebugENCRelinkInfo2_Skip(This,in_NoOfElements)	\
    (This)->lpVtbl -> Skip(This,in_NoOfElements)

#define IEnumDebugENCRelinkInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugENCRelinkInfo2_Clone(This,out_ppEnumENCRelinkInfo)	\
    (This)->lpVtbl -> Clone(This,out_ppEnumENCRelinkInfo)

#define IEnumDebugENCRelinkInfo2_GetCount(This,out_pCount)	\
    (This)->lpVtbl -> GetCount(This,out_pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugENCRelinkInfo2_Next_Proxy( 
    IEnumDebugENCRelinkInfo2 * This,
    /* [in] */ ULONG in_NoOfElementsRequested,
    /* [length_is][size_is][out] */ IDebugENCRelinkInfo2 **out_ArrayOfpENCInfo,
    /* [out] */ ULONG *out_pNoOfElementsFetched);


void __RPC_STUB IEnumDebugENCRelinkInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCRelinkInfo2_Skip_Proxy( 
    IEnumDebugENCRelinkInfo2 * This,
    /* [in] */ ULONG in_NoOfElements);


void __RPC_STUB IEnumDebugENCRelinkInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCRelinkInfo2_Reset_Proxy( 
    IEnumDebugENCRelinkInfo2 * This);


void __RPC_STUB IEnumDebugENCRelinkInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCRelinkInfo2_Clone_Proxy( 
    IEnumDebugENCRelinkInfo2 * This,
    /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo);


void __RPC_STUB IEnumDebugENCRelinkInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCRelinkInfo2_GetCount_Proxy( 
    IEnumDebugENCRelinkInfo2 * This,
    /* [out] */ ULONG *out_pCount);


void __RPC_STUB IEnumDebugENCRelinkInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugENCRelinkInfo2_INTERFACE_DEFINED__ */


#ifndef __IDebugIDBInfo2_INTERFACE_DEFINED__
#define __IDebugIDBInfo2_INTERFACE_DEFINED__

/* interface IDebugIDBInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugIDBInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B7DE9A9-BD59-11d2-9238-00A02448799A")
    IDebugIDBInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ BSTR *out_pbstrIDBFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugIDBInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugIDBInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugIDBInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugIDBInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugIDBInfo2 * This,
            /* [out] */ BSTR *out_pbstrIDBFile);
        
        END_INTERFACE
    } IDebugIDBInfo2Vtbl;

    interface IDebugIDBInfo2
    {
        CONST_VTBL struct IDebugIDBInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugIDBInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugIDBInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugIDBInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugIDBInfo2_GetInfo(This,out_pbstrIDBFile)	\
    (This)->lpVtbl -> GetInfo(This,out_pbstrIDBFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugIDBInfo2_GetInfo_Proxy( 
    IDebugIDBInfo2 * This,
    /* [out] */ BSTR *out_pbstrIDBFile);


void __RPC_STUB IDebugIDBInfo2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugIDBInfo2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugIDBInfo2_INTERFACE_DEFINED__
#define __IEnumDebugIDBInfo2_INTERFACE_DEFINED__

/* interface IEnumDebugIDBInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugIDBInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B34E469B-BD59-11d2-9238-00A02448799A")
    IEnumDebugIDBInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugIDBInfo2 **out_ArrayOfpIDBInfo2,
            /* [out] */ ULONG *out_pNoOfElementsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG in_NoOfElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *out_pCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugIDBInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugIDBInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugIDBInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugIDBInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugIDBInfo2 * This,
            /* [in] */ ULONG in_NoOfElementsRequested,
            /* [length_is][size_is][out] */ IDebugIDBInfo2 **out_ArrayOfpIDBInfo2,
            /* [out] */ ULONG *out_pNoOfElementsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugIDBInfo2 * This,
            /* [in] */ ULONG in_NoOfElements);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugIDBInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugIDBInfo2 * This,
            /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo2);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugIDBInfo2 * This,
            /* [out] */ ULONG *out_pCount);
        
        END_INTERFACE
    } IEnumDebugIDBInfo2Vtbl;

    interface IEnumDebugIDBInfo2
    {
        CONST_VTBL struct IEnumDebugIDBInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugIDBInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugIDBInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugIDBInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugIDBInfo2_Next(This,in_NoOfElementsRequested,out_ArrayOfpIDBInfo2,out_pNoOfElementsFetched)	\
    (This)->lpVtbl -> Next(This,in_NoOfElementsRequested,out_ArrayOfpIDBInfo2,out_pNoOfElementsFetched)

#define IEnumDebugIDBInfo2_Skip(This,in_NoOfElements)	\
    (This)->lpVtbl -> Skip(This,in_NoOfElements)

#define IEnumDebugIDBInfo2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugIDBInfo2_Clone(This,out_ppEnumIDBInfo2)	\
    (This)->lpVtbl -> Clone(This,out_ppEnumIDBInfo2)

#define IEnumDebugIDBInfo2_GetCount(This,out_pCount)	\
    (This)->lpVtbl -> GetCount(This,out_pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugIDBInfo2_Next_Proxy( 
    IEnumDebugIDBInfo2 * This,
    /* [in] */ ULONG in_NoOfElementsRequested,
    /* [length_is][size_is][out] */ IDebugIDBInfo2 **out_ArrayOfpIDBInfo2,
    /* [out] */ ULONG *out_pNoOfElementsFetched);


void __RPC_STUB IEnumDebugIDBInfo2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugIDBInfo2_Skip_Proxy( 
    IEnumDebugIDBInfo2 * This,
    /* [in] */ ULONG in_NoOfElements);


void __RPC_STUB IEnumDebugIDBInfo2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugIDBInfo2_Reset_Proxy( 
    IEnumDebugIDBInfo2 * This);


void __RPC_STUB IEnumDebugIDBInfo2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugIDBInfo2_Clone_Proxy( 
    IEnumDebugIDBInfo2 * This,
    /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo2);


void __RPC_STUB IEnumDebugIDBInfo2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugIDBInfo2_GetCount_Proxy( 
    IEnumDebugIDBInfo2 * This,
    /* [out] */ ULONG *out_pCount);


void __RPC_STUB IEnumDebugIDBInfo2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugIDBInfo2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCBuildInfo2_INTERFACE_DEFINED__
#define __IDebugENCBuildInfo2_INTERFACE_DEFINED__

/* interface IDebugENCBuildInfo2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCBuildInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EA70281B-BD58-11d2-9238-00A02448799A")
    IDebugENCBuildInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetBuildInfo( 
            /* [in] */ LPCOLESTR in_szTargetPath,
            /* [out] */ BSTR *out_pbstrSourcePath,
            /* [out] */ BSTR *out_pbstrCommand,
            /* [out] */ BSTR *out_pbstrCurrentdir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTargetEligible( 
            /* [in] */ LPCOLESTR in_szTargetPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDebugIDBInfo( 
            /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCBuildInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCBuildInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCBuildInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCBuildInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetBuildInfo )( 
            IDebugENCBuildInfo2 * This,
            /* [in] */ LPCOLESTR in_szTargetPath,
            /* [out] */ BSTR *out_pbstrSourcePath,
            /* [out] */ BSTR *out_pbstrCommand,
            /* [out] */ BSTR *out_pbstrCurrentdir);
        
        HRESULT ( STDMETHODCALLTYPE *IsTargetEligible )( 
            IDebugENCBuildInfo2 * This,
            /* [in] */ LPCOLESTR in_szTargetPath);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDebugIDBInfo )( 
            IDebugENCBuildInfo2 * This,
            /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo);
        
        END_INTERFACE
    } IDebugENCBuildInfo2Vtbl;

    interface IDebugENCBuildInfo2
    {
        CONST_VTBL struct IDebugENCBuildInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCBuildInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCBuildInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCBuildInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCBuildInfo2_GetTargetBuildInfo(This,in_szTargetPath,out_pbstrSourcePath,out_pbstrCommand,out_pbstrCurrentdir)	\
    (This)->lpVtbl -> GetTargetBuildInfo(This,in_szTargetPath,out_pbstrSourcePath,out_pbstrCommand,out_pbstrCurrentdir)

#define IDebugENCBuildInfo2_IsTargetEligible(This,in_szTargetPath)	\
    (This)->lpVtbl -> IsTargetEligible(This,in_szTargetPath)

#define IDebugENCBuildInfo2_EnumDebugIDBInfo(This,out_ppEnumIDBInfo)	\
    (This)->lpVtbl -> EnumDebugIDBInfo(This,out_ppEnumIDBInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCBuildInfo2_GetTargetBuildInfo_Proxy( 
    IDebugENCBuildInfo2 * This,
    /* [in] */ LPCOLESTR in_szTargetPath,
    /* [out] */ BSTR *out_pbstrSourcePath,
    /* [out] */ BSTR *out_pbstrCommand,
    /* [out] */ BSTR *out_pbstrCurrentdir);


void __RPC_STUB IDebugENCBuildInfo2_GetTargetBuildInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCBuildInfo2_IsTargetEligible_Proxy( 
    IDebugENCBuildInfo2 * This,
    /* [in] */ LPCOLESTR in_szTargetPath);


void __RPC_STUB IDebugENCBuildInfo2_IsTargetEligible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCBuildInfo2_EnumDebugIDBInfo_Proxy( 
    IDebugENCBuildInfo2 * This,
    /* [out] */ IEnumDebugIDBInfo2 **out_ppEnumIDBInfo);


void __RPC_STUB IDebugENCBuildInfo2_EnumDebugIDBInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCBuildInfo2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCUpdateOnRelinkEvent2_INTERFACE_DEFINED__
#define __IDebugENCUpdateOnRelinkEvent2_INTERFACE_DEFINED__

/* interface IDebugENCUpdateOnRelinkEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCUpdateOnRelinkEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EBF1959-BD57-11d2-9238-00A02448799A")
    IDebugENCUpdateOnRelinkEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCUpdateOnRelinkEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCUpdateOnRelinkEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCUpdateOnRelinkEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCUpdateOnRelinkEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugENCUpdateOnRelinkEvent2 * This,
            /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo);
        
        END_INTERFACE
    } IDebugENCUpdateOnRelinkEvent2Vtbl;

    interface IDebugENCUpdateOnRelinkEvent2
    {
        CONST_VTBL struct IDebugENCUpdateOnRelinkEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCUpdateOnRelinkEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCUpdateOnRelinkEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCUpdateOnRelinkEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCUpdateOnRelinkEvent2_GetInfo(This,out_ppEnumENCRelinkInfo)	\
    (This)->lpVtbl -> GetInfo(This,out_ppEnumENCRelinkInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCUpdateOnRelinkEvent2_GetInfo_Proxy( 
    IDebugENCUpdateOnRelinkEvent2 * This,
    /* [out] */ IEnumDebugENCRelinkInfo2 **out_ppEnumENCRelinkInfo);


void __RPC_STUB IDebugENCUpdateOnRelinkEvent2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCUpdateOnRelinkEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCUpdateOnStaleCodeEvent2_INTERFACE_DEFINED__
#define __IDebugENCUpdateOnStaleCodeEvent2_INTERFACE_DEFINED__

/* interface IDebugENCUpdateOnStaleCodeEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCUpdateOnStaleCodeEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2F01EB29-BD57-11d2-9238-00A02448799A")
    IDebugENCUpdateOnStaleCodeEvent2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHResult( 
            /* [out] */ HRESULT *out_pHResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCUpdateOnStaleCodeEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCUpdateOnStaleCodeEvent2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCUpdateOnStaleCodeEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCUpdateOnStaleCodeEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDebugENCUpdateOnStaleCodeEvent2 * This,
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetHResult )( 
            IDebugENCUpdateOnStaleCodeEvent2 * This,
            /* [out] */ HRESULT *out_pHResult);
        
        END_INTERFACE
    } IDebugENCUpdateOnStaleCodeEvent2Vtbl;

    interface IDebugENCUpdateOnStaleCodeEvent2
    {
        CONST_VTBL struct IDebugENCUpdateOnStaleCodeEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCUpdateOnStaleCodeEvent2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCUpdateOnStaleCodeEvent2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCUpdateOnStaleCodeEvent2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCUpdateOnStaleCodeEvent2_GetInfo(This,out_ppEnumENCInfo)	\
    (This)->lpVtbl -> GetInfo(This,out_ppEnumENCInfo)

#define IDebugENCUpdateOnStaleCodeEvent2_GetHResult(This,out_pHResult)	\
    (This)->lpVtbl -> GetHResult(This,out_pHResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCUpdateOnStaleCodeEvent2_GetInfo_Proxy( 
    IDebugENCUpdateOnStaleCodeEvent2 * This,
    /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);


void __RPC_STUB IDebugENCUpdateOnStaleCodeEvent2_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCUpdateOnStaleCodeEvent2_GetHResult_Proxy( 
    IDebugENCUpdateOnStaleCodeEvent2 * This,
    /* [out] */ HRESULT *out_pHResult);


void __RPC_STUB IDebugENCUpdateOnStaleCodeEvent2_GetHResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCUpdateOnStaleCodeEvent2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCUpdate_INTERFACE_DEFINED__
#define __IDebugENCUpdate_INTERFACE_DEFINED__

/* interface IDebugENCUpdate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("978BAEE7-BD4C-11d2-9238-00A02448799A")
    IDebugENCUpdate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumENCSnapshots( 
            /* [in] */ LPCOLESTR pszModule,
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumENCSnapshotsByGuid( 
            /* [in] */ REFGUID guidModule,
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelENC( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnENCAttemptComplete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCUpdate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumENCSnapshots )( 
            IDebugENCUpdate * This,
            /* [in] */ LPCOLESTR pszModule,
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumENCSnapshotsByGuid )( 
            IDebugENCUpdate * This,
            /* [in] */ REFGUID guidModule,
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CancelENC )( 
            IDebugENCUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnENCAttemptComplete )( 
            IDebugENCUpdate * This);
        
        END_INTERFACE
    } IDebugENCUpdateVtbl;

    interface IDebugENCUpdate
    {
        CONST_VTBL struct IDebugENCUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCUpdate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCUpdate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCUpdate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCUpdate_EnumENCSnapshots(This,pszModule,ppEnum)	\
    (This)->lpVtbl -> EnumENCSnapshots(This,pszModule,ppEnum)

#define IDebugENCUpdate_EnumENCSnapshotsByGuid(This,guidModule,ppEnum)	\
    (This)->lpVtbl -> EnumENCSnapshotsByGuid(This,guidModule,ppEnum)

#define IDebugENCUpdate_CancelENC(This)	\
    (This)->lpVtbl -> CancelENC(This)

#define IDebugENCUpdate_OnENCAttemptComplete(This)	\
    (This)->lpVtbl -> OnENCAttemptComplete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCUpdate_EnumENCSnapshots_Proxy( 
    IDebugENCUpdate * This,
    /* [in] */ LPCOLESTR pszModule,
    /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);


void __RPC_STUB IDebugENCUpdate_EnumENCSnapshots_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCUpdate_EnumENCSnapshotsByGuid_Proxy( 
    IDebugENCUpdate * This,
    /* [in] */ REFGUID guidModule,
    /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);


void __RPC_STUB IDebugENCUpdate_EnumENCSnapshotsByGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCUpdate_CancelENC_Proxy( 
    IDebugENCUpdate * This);


void __RPC_STUB IDebugENCUpdate_CancelENC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCUpdate_OnENCAttemptComplete_Proxy( 
    IDebugENCUpdate * This);


void __RPC_STUB IDebugENCUpdate_OnENCAttemptComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCUpdate_INTERFACE_DEFINED__ */


#ifndef __IDebugENCSnapshot2_INTERFACE_DEFINED__
#define __IDebugENCSnapshot2_INTERFACE_DEFINED__

/* interface IDebugENCSnapshot2 */
/* [unique][uuid][object] */ 


enum __MIDL_IDebugENCSnapshot2_0001
    {	ENC_SNAPSHOT_TYPE_COMPLUS	= 0x1,
	ENC_SNAPSHOT_TYPE_CPP	= 0x2
    } ;
typedef DWORD ENC_SNAPSHOT_TYPE;

typedef struct _ENC_SNAPSHOT_COMPLUS
    {
    IDebugComPlusSnapshot2 *pcpSnapshot;
    } 	ENC_SNAPSHOT_COMPLUS;

typedef struct _ENC_SNAPSHOT_CPP
    {
    DWORD dwNYI;
    } 	ENC_SNAPSHOT_CPP;

typedef struct _ENC_SNAPSHOT
    {
    ENC_SNAPSHOT_TYPE ssType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IDebugENCSnapshot2_0002
        {
        /* [case()] */ ENC_SNAPSHOT_COMPLUS encComPlus;
        /* [case()] */ ENC_SNAPSHOT_CPP encCpp;
        /* [default] */ DWORD unused;
        } 	encSnapshot;
    } 	ENC_SNAPSHOT;

typedef struct _ENC_SNAPSHOT_INFO
    {
    IDebugProgram2 *pProgram;
    ENC_SNAPSHOT encSnapshot;
    } 	ENC_SNAPSHOT_INFO;


EXTERN_C const IID IID_IDebugENCSnapshot2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d0e-78c2-11d2-8ffe-00c04fa38314")
    IDebugENCSnapshot2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetENCSnapshotInfo( 
            /* [out] */ ENC_SNAPSHOT_INFO *pSnapshotInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyCodeChange( 
            /* [in] */ ULONG in_NoOfLineMaps,
            /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps,
            /* [in] */ IServiceProvider *in_pServiceProvider,
            /* [in] */ BOOL in_fOnContinue,
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChange( 
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCSnapshot2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCSnapshot2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCSnapshot2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCSnapshot2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetENCSnapshotInfo )( 
            IDebugENCSnapshot2 * This,
            /* [out] */ ENC_SNAPSHOT_INFO *pSnapshotInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyCodeChange )( 
            IDebugENCSnapshot2 * This,
            /* [in] */ ULONG in_NoOfLineMaps,
            /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps,
            /* [in] */ IServiceProvider *in_pServiceProvider,
            /* [in] */ BOOL in_fOnContinue,
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChange )( 
            IDebugENCSnapshot2 * This,
            /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);
        
        END_INTERFACE
    } IDebugENCSnapshot2Vtbl;

    interface IDebugENCSnapshot2
    {
        CONST_VTBL struct IDebugENCSnapshot2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCSnapshot2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCSnapshot2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCSnapshot2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCSnapshot2_GetENCSnapshotInfo(This,pSnapshotInfo)	\
    (This)->lpVtbl -> GetENCSnapshotInfo(This,pSnapshotInfo)

#define IDebugENCSnapshot2_ApplyCodeChange(This,in_NoOfLineMaps,in_ArrayOfLineMaps,in_pServiceProvider,in_fOnContinue,out_ppEnumENCInfo)	\
    (This)->lpVtbl -> ApplyCodeChange(This,in_NoOfLineMaps,in_ArrayOfLineMaps,in_pServiceProvider,in_fOnContinue,out_ppEnumENCInfo)

#define IDebugENCSnapshot2_CommitChange(This,out_ppEnumENCInfo)	\
    (This)->lpVtbl -> CommitChange(This,out_ppEnumENCInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCSnapshot2_GetENCSnapshotInfo_Proxy( 
    IDebugENCSnapshot2 * This,
    /* [out] */ ENC_SNAPSHOT_INFO *pSnapshotInfo);


void __RPC_STUB IDebugENCSnapshot2_GetENCSnapshotInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCSnapshot2_ApplyCodeChange_Proxy( 
    IDebugENCSnapshot2 * This,
    /* [in] */ ULONG in_NoOfLineMaps,
    /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps,
    /* [in] */ IServiceProvider *in_pServiceProvider,
    /* [in] */ BOOL in_fOnContinue,
    /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);


void __RPC_STUB IDebugENCSnapshot2_ApplyCodeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugENCSnapshot2_CommitChange_Proxy( 
    IDebugENCSnapshot2 * This,
    /* [out] */ IEnumDebugENCInfo2 **out_ppEnumENCInfo);


void __RPC_STUB IDebugENCSnapshot2_CommitChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCSnapshot2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugENCSnapshots2_INTERFACE_DEFINED__
#define __IEnumDebugENCSnapshots2_INTERFACE_DEFINED__

/* interface IEnumDebugENCSnapshots2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugENCSnapshots2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d1a-78c2-11d2-8ffe-00c04fa38314")
    IEnumDebugENCSnapshots2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugENCSnapshot2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugENCSnapshots2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugENCSnapshots2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugENCSnapshots2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugENCSnapshots2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugENCSnapshots2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDebugENCSnapshot2 **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugENCSnapshots2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugENCSnapshots2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugENCSnapshots2 * This,
            /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugENCSnapshots2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugENCSnapshots2Vtbl;

    interface IEnumDebugENCSnapshots2
    {
        CONST_VTBL struct IEnumDebugENCSnapshots2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugENCSnapshots2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugENCSnapshots2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugENCSnapshots2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugENCSnapshots2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugENCSnapshots2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugENCSnapshots2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugENCSnapshots2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugENCSnapshots2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugENCSnapshots2_Next_Proxy( 
    IEnumDebugENCSnapshots2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugENCSnapshot2 **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugENCSnapshots2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCSnapshots2_Skip_Proxy( 
    IEnumDebugENCSnapshots2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugENCSnapshots2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCSnapshots2_Reset_Proxy( 
    IEnumDebugENCSnapshots2 * This);


void __RPC_STUB IEnumDebugENCSnapshots2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCSnapshots2_Clone_Proxy( 
    IEnumDebugENCSnapshots2 * This,
    /* [out] */ IEnumDebugENCSnapshots2 **ppEnum);


void __RPC_STUB IEnumDebugENCSnapshots2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugENCSnapshots2_GetCount_Proxy( 
    IEnumDebugENCSnapshots2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugENCSnapshots2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugENCSnapshots2_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugErrorInfos2_INTERFACE_DEFINED__
#define __IEnumDebugErrorInfos2_INTERFACE_DEFINED__

/* interface IEnumDebugErrorInfos2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugErrorInfos2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d23-78c2-11d2-8ffe-00c04fa38314")
    IEnumDebugErrorInfos2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IErrorInfo **rgelt,
            /* [out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugErrorInfos2 **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugErrorInfos2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDebugErrorInfos2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDebugErrorInfos2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDebugErrorInfos2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDebugErrorInfos2 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IErrorInfo **rgelt,
            /* [out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDebugErrorInfos2 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDebugErrorInfos2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDebugErrorInfos2 * This,
            /* [out] */ IEnumDebugErrorInfos2 **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumDebugErrorInfos2 * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } IEnumDebugErrorInfos2Vtbl;

    interface IEnumDebugErrorInfos2
    {
        CONST_VTBL struct IEnumDebugErrorInfos2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugErrorInfos2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugErrorInfos2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugErrorInfos2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugErrorInfos2_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumDebugErrorInfos2_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugErrorInfos2_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugErrorInfos2_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDebugErrorInfos2_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugErrorInfos2_Next_Proxy( 
    IEnumDebugErrorInfos2 * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IErrorInfo **rgelt,
    /* [out][in] */ ULONG *pceltFetched);


void __RPC_STUB IEnumDebugErrorInfos2_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorInfos2_Skip_Proxy( 
    IEnumDebugErrorInfos2 * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugErrorInfos2_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorInfos2_Reset_Proxy( 
    IEnumDebugErrorInfos2 * This);


void __RPC_STUB IEnumDebugErrorInfos2_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorInfos2_Clone_Proxy( 
    IEnumDebugErrorInfos2 * This,
    /* [out] */ IEnumDebugErrorInfos2 **ppEnum);


void __RPC_STUB IEnumDebugErrorInfos2_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugErrorInfos2_GetCount_Proxy( 
    IEnumDebugErrorInfos2 * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB IEnumDebugErrorInfos2_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugErrorInfos2_INTERFACE_DEFINED__ */


#ifndef __IDebugComPlusSnapshot2_INTERFACE_DEFINED__
#define __IDebugComPlusSnapshot2_INTERFACE_DEFINED__

/* interface IDebugComPlusSnapshot2 */
/* [unique][uuid][object] */ 

typedef struct _IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	IL_MAP;


EXTERN_C const IID IID_IDebugComPlusSnapshot2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d20-78c2-11d2-8ffe-00c04fa38314")
    IDebugComPlusSnapshot2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CopyMetaData( 
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMvid( 
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoDataRVA( 
            /* [out] */ ULONG32 *pRoDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRwDataRVA( 
            /* [out] */ ULONG32 *pRwDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPEBytes( 
            /* [length_is][size_is][in] */ BYTE *pBytes,
            /* [in] */ DWORD dwBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILMap( 
            /* [in] */ DWORD mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ IL_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSymbolBytes( 
            /* [length_is][size_is][in] */ BYTE *pBytes,
            /* [in] */ DWORD dwBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolProvider( 
            /* [out] */ IDebugComPlusSymbolProvider **ppSym) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainAndModuleIDs( 
            /* [out] */ ULONG32 *pulAppDomainID,
            /* [out] */ GUID *pguidModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestILMap( 
            /* [in] */ DWORD mdFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateILMaps( 
            /* [in] */ ULONG in_NoOfLineMaps,
            /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugComPlusSnapshot2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugComPlusSnapshot2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugComPlusSnapshot2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugComPlusSnapshot2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CopyMetaData )( 
            IDebugComPlusSnapshot2 * This,
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMvid )( 
            IDebugComPlusSnapshot2 * This,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoDataRVA )( 
            IDebugComPlusSnapshot2 * This,
            /* [out] */ ULONG32 *pRoDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *GetRwDataRVA )( 
            IDebugComPlusSnapshot2 * This,
            /* [out] */ ULONG32 *pRwDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *SetPEBytes )( 
            IDebugComPlusSnapshot2 * This,
            /* [length_is][size_is][in] */ BYTE *pBytes,
            /* [in] */ DWORD dwBytes);
        
        HRESULT ( STDMETHODCALLTYPE *SetILMap )( 
            IDebugComPlusSnapshot2 * This,
            /* [in] */ DWORD mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ IL_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymbolBytes )( 
            IDebugComPlusSnapshot2 * This,
            /* [length_is][size_is][in] */ BYTE *pBytes,
            /* [in] */ DWORD dwBytes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolProvider )( 
            IDebugComPlusSnapshot2 * This,
            /* [out] */ IDebugComPlusSymbolProvider **ppSym);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainAndModuleIDs )( 
            IDebugComPlusSnapshot2 * This,
            /* [out] */ ULONG32 *pulAppDomainID,
            /* [out] */ GUID *pguidModule);
        
        HRESULT ( STDMETHODCALLTYPE *RequestILMap )( 
            IDebugComPlusSnapshot2 * This,
            /* [in] */ DWORD mdFunction);
        
        HRESULT ( STDMETHODCALLTYPE *CreateILMaps )( 
            IDebugComPlusSnapshot2 * This,
            /* [in] */ ULONG in_NoOfLineMaps,
            /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps);
        
        END_INTERFACE
    } IDebugComPlusSnapshot2Vtbl;

    interface IDebugComPlusSnapshot2
    {
        CONST_VTBL struct IDebugComPlusSnapshot2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugComPlusSnapshot2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugComPlusSnapshot2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugComPlusSnapshot2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugComPlusSnapshot2_CopyMetaData(This,pIStream,pMvid)	\
    (This)->lpVtbl -> CopyMetaData(This,pIStream,pMvid)

#define IDebugComPlusSnapshot2_GetMvid(This,pMvid)	\
    (This)->lpVtbl -> GetMvid(This,pMvid)

#define IDebugComPlusSnapshot2_GetRoDataRVA(This,pRoDataRVA)	\
    (This)->lpVtbl -> GetRoDataRVA(This,pRoDataRVA)

#define IDebugComPlusSnapshot2_GetRwDataRVA(This,pRwDataRVA)	\
    (This)->lpVtbl -> GetRwDataRVA(This,pRwDataRVA)

#define IDebugComPlusSnapshot2_SetPEBytes(This,pBytes,dwBytes)	\
    (This)->lpVtbl -> SetPEBytes(This,pBytes,dwBytes)

#define IDebugComPlusSnapshot2_SetILMap(This,mdFunction,cMapSize,map)	\
    (This)->lpVtbl -> SetILMap(This,mdFunction,cMapSize,map)

#define IDebugComPlusSnapshot2_SetSymbolBytes(This,pBytes,dwBytes)	\
    (This)->lpVtbl -> SetSymbolBytes(This,pBytes,dwBytes)

#define IDebugComPlusSnapshot2_GetSymbolProvider(This,ppSym)	\
    (This)->lpVtbl -> GetSymbolProvider(This,ppSym)

#define IDebugComPlusSnapshot2_GetAppDomainAndModuleIDs(This,pulAppDomainID,pguidModule)	\
    (This)->lpVtbl -> GetAppDomainAndModuleIDs(This,pulAppDomainID,pguidModule)

#define IDebugComPlusSnapshot2_RequestILMap(This,mdFunction)	\
    (This)->lpVtbl -> RequestILMap(This,mdFunction)

#define IDebugComPlusSnapshot2_CreateILMaps(This,in_NoOfLineMaps,in_ArrayOfLineMaps)	\
    (This)->lpVtbl -> CreateILMaps(This,in_NoOfLineMaps,in_ArrayOfLineMaps)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_CopyMetaData_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [in] */ IStream *pIStream,
    /* [out] */ GUID *pMvid);


void __RPC_STUB IDebugComPlusSnapshot2_CopyMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_GetMvid_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [out] */ GUID *pMvid);


void __RPC_STUB IDebugComPlusSnapshot2_GetMvid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_GetRoDataRVA_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [out] */ ULONG32 *pRoDataRVA);


void __RPC_STUB IDebugComPlusSnapshot2_GetRoDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_GetRwDataRVA_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [out] */ ULONG32 *pRwDataRVA);


void __RPC_STUB IDebugComPlusSnapshot2_GetRwDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_SetPEBytes_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [length_is][size_is][in] */ BYTE *pBytes,
    /* [in] */ DWORD dwBytes);


void __RPC_STUB IDebugComPlusSnapshot2_SetPEBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_SetILMap_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [in] */ DWORD mdFunction,
    /* [in] */ ULONG cMapSize,
    /* [size_is][in] */ IL_MAP map[  ]);


void __RPC_STUB IDebugComPlusSnapshot2_SetILMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_SetSymbolBytes_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [length_is][size_is][in] */ BYTE *pBytes,
    /* [in] */ DWORD dwBytes);


void __RPC_STUB IDebugComPlusSnapshot2_SetSymbolBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_GetSymbolProvider_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [out] */ IDebugComPlusSymbolProvider **ppSym);


void __RPC_STUB IDebugComPlusSnapshot2_GetSymbolProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_GetAppDomainAndModuleIDs_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [out] */ ULONG32 *pulAppDomainID,
    /* [out] */ GUID *pguidModule);


void __RPC_STUB IDebugComPlusSnapshot2_GetAppDomainAndModuleIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_RequestILMap_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [in] */ DWORD mdFunction);


void __RPC_STUB IDebugComPlusSnapshot2_RequestILMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugComPlusSnapshot2_CreateILMaps_Proxy( 
    IDebugComPlusSnapshot2 * This,
    /* [in] */ ULONG in_NoOfLineMaps,
    /* [size_is][in] */ IDebugENCLineMap **in_ArrayOfLineMaps);


void __RPC_STUB IDebugComPlusSnapshot2_CreateILMaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugComPlusSnapshot2_INTERFACE_DEFINED__ */


#ifndef __IDebugNativeSnapshot2_INTERFACE_DEFINED__
#define __IDebugNativeSnapshot2_INTERFACE_DEFINED__

/* interface IDebugNativeSnapshot2 */
/* [unique][uuid][object] */ 

typedef 
enum _ENC_NOTIFY
    {	ENC_NOTIFY_COMPILE_START	= 0,
	ENC_NOTIFY_COMPILE_END	= ENC_NOTIFY_COMPILE_START + 1
    } 	ENC_NOTIFY;


EXTERN_C const IID IID_IDebugNativeSnapshot2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("461fda3e-bba5-11d2-b10f-00c04f72dc32")
    IDebugNativeSnapshot2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HasDependentTargets( 
            /* [in] */ LPCOLESTR pszSourcePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDependentImages( 
            /* [in] */ LPCOLESTR pszSourcePath,
            /* [out] */ IEnumString **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDependentTargets( 
            /* [in] */ ULONG cSrc,
            /* [size_is][in] */ LPCOLESTR pszSourcePath[  ],
            /* [out] */ IEnumString **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetBuildInfo( 
            /* [in] */ LPCOLESTR pszTargetPath,
            /* [out] */ BSTR *pbstrSourcePath,
            /* [out] */ BSTR *pbstrCommand,
            /* [out] */ BSTR *pbstrCommandArgs,
            /* [out] */ BSTR *pbstrCurrentDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ ENC_NOTIFY encnotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTargetEligible( 
            /* [in] */ LPCOLESTR pszTargetPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRecompiledTarget( 
            /* [in] */ LPCOLESTR in_szTargetPath,
            /* [in] */ LPCOLESTR in_szSavedTargetPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugNativeSnapshot2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugNativeSnapshot2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugNativeSnapshot2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *HasDependentTargets )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ LPCOLESTR pszSourcePath);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDependentImages )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ LPCOLESTR pszSourcePath,
            /* [out] */ IEnumString **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDependentTargets )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ ULONG cSrc,
            /* [size_is][in] */ LPCOLESTR pszSourcePath[  ],
            /* [out] */ IEnumString **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetBuildInfo )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ LPCOLESTR pszTargetPath,
            /* [out] */ BSTR *pbstrSourcePath,
            /* [out] */ BSTR *pbstrCommand,
            /* [out] */ BSTR *pbstrCommandArgs,
            /* [out] */ BSTR *pbstrCurrentDir);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ ENC_NOTIFY encnotify);
        
        HRESULT ( STDMETHODCALLTYPE *IsTargetEligible )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ LPCOLESTR pszTargetPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddRecompiledTarget )( 
            IDebugNativeSnapshot2 * This,
            /* [in] */ LPCOLESTR in_szTargetPath,
            /* [in] */ LPCOLESTR in_szSavedTargetPath);
        
        END_INTERFACE
    } IDebugNativeSnapshot2Vtbl;

    interface IDebugNativeSnapshot2
    {
        CONST_VTBL struct IDebugNativeSnapshot2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugNativeSnapshot2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugNativeSnapshot2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugNativeSnapshot2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugNativeSnapshot2_HasDependentTargets(This,pszSourcePath)	\
    (This)->lpVtbl -> HasDependentTargets(This,pszSourcePath)

#define IDebugNativeSnapshot2_EnumDependentImages(This,pszSourcePath,ppEnum)	\
    (This)->lpVtbl -> EnumDependentImages(This,pszSourcePath,ppEnum)

#define IDebugNativeSnapshot2_EnumDependentTargets(This,cSrc,pszSourcePath,ppEnum)	\
    (This)->lpVtbl -> EnumDependentTargets(This,cSrc,pszSourcePath,ppEnum)

#define IDebugNativeSnapshot2_GetTargetBuildInfo(This,pszTargetPath,pbstrSourcePath,pbstrCommand,pbstrCommandArgs,pbstrCurrentDir)	\
    (This)->lpVtbl -> GetTargetBuildInfo(This,pszTargetPath,pbstrSourcePath,pbstrCommand,pbstrCommandArgs,pbstrCurrentDir)

#define IDebugNativeSnapshot2_Notify(This,encnotify)	\
    (This)->lpVtbl -> Notify(This,encnotify)

#define IDebugNativeSnapshot2_IsTargetEligible(This,pszTargetPath)	\
    (This)->lpVtbl -> IsTargetEligible(This,pszTargetPath)

#define IDebugNativeSnapshot2_AddRecompiledTarget(This,in_szTargetPath,in_szSavedTargetPath)	\
    (This)->lpVtbl -> AddRecompiledTarget(This,in_szTargetPath,in_szSavedTargetPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_HasDependentTargets_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ LPCOLESTR pszSourcePath);


void __RPC_STUB IDebugNativeSnapshot2_HasDependentTargets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_EnumDependentImages_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ LPCOLESTR pszSourcePath,
    /* [out] */ IEnumString **ppEnum);


void __RPC_STUB IDebugNativeSnapshot2_EnumDependentImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_EnumDependentTargets_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ ULONG cSrc,
    /* [size_is][in] */ LPCOLESTR pszSourcePath[  ],
    /* [out] */ IEnumString **ppEnum);


void __RPC_STUB IDebugNativeSnapshot2_EnumDependentTargets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_GetTargetBuildInfo_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ LPCOLESTR pszTargetPath,
    /* [out] */ BSTR *pbstrSourcePath,
    /* [out] */ BSTR *pbstrCommand,
    /* [out] */ BSTR *pbstrCommandArgs,
    /* [out] */ BSTR *pbstrCurrentDir);


void __RPC_STUB IDebugNativeSnapshot2_GetTargetBuildInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_Notify_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ ENC_NOTIFY encnotify);


void __RPC_STUB IDebugNativeSnapshot2_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_IsTargetEligible_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ LPCOLESTR pszTargetPath);


void __RPC_STUB IDebugNativeSnapshot2_IsTargetEligible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugNativeSnapshot2_AddRecompiledTarget_Proxy( 
    IDebugNativeSnapshot2 * This,
    /* [in] */ LPCOLESTR in_szTargetPath,
    /* [in] */ LPCOLESTR in_szSavedTargetPath);


void __RPC_STUB IDebugNativeSnapshot2_AddRecompiledTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugNativeSnapshot2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCStackFrame2_INTERFACE_DEFINED__
#define __IDebugENCStackFrame2_INTERFACE_DEFINED__

/* interface IDebugENCStackFrame2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCStackFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B3C64D7F-DB9D-47c7-B479-C579C7F07103")
    IDebugENCStackFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAllLocalsProperty( 
            /* [out] */ IDebugProperty2 **ppProperty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCStackFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCStackFrame2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCStackFrame2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCStackFrame2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllLocalsProperty )( 
            IDebugENCStackFrame2 * This,
            /* [out] */ IDebugProperty2 **ppProperty);
        
        END_INTERFACE
    } IDebugENCStackFrame2Vtbl;

    interface IDebugENCStackFrame2
    {
        CONST_VTBL struct IDebugENCStackFrame2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCStackFrame2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCStackFrame2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCStackFrame2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCStackFrame2_GetAllLocalsProperty(This,ppProperty)	\
    (This)->lpVtbl -> GetAllLocalsProperty(This,ppProperty)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCStackFrame2_GetAllLocalsProperty_Proxy( 
    IDebugENCStackFrame2 * This,
    /* [out] */ IDebugProperty2 **ppProperty);


void __RPC_STUB IDebugENCStackFrame2_GetAllLocalsProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCStackFrame2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_enc_0389 */
/* [local] */ 

typedef INT32 _mdToken;



extern RPC_IF_HANDLE __MIDL_itf_enc_0389_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_enc_0389_v0_0_s_ifspec;

#ifndef __IDebugMetaDataEmit2_INTERFACE_DEFINED__
#define __IDebugMetaDataEmit2_INTERFACE_DEFINED__

/* interface IDebugMetaDataEmit2 */
/* [unique][uuid][object] */ 

typedef struct _FIELD_OFFSET
    {
    _mdToken ridOfField;
    ULONG ulOffset;
    } 	FIELD_OFFSET;

typedef struct _IMAGE_FIXUPENTRY
    {
    ULONG ulRVA;
    ULONG Count;
    } 	IMAGE_FIXUPENTRY;


EXTERN_C const IID IID_IDebugMetaDataEmit2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d21-78c2-11d2-8ffe-00c04fa38314")
    IDebugMetaDataEmit2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetModuleProps( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ GUID *ppid,
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ LPOLESTR szFile,
            /* [in] */ DWORD dwSaveFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveToStream( 
            /* [in] */ IStream *pIStream,
            /* [in] */ DWORD dwSaveFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveSize( 
            /* [in] */ DWORD fSave,
            /* [out] */ DWORD *pdwSaveSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineCustomValueAsBlob( 
            /* [in] */ _mdToken tkObj,
            /* [in] */ LPOLESTR szName,
            /* [size_is][in] */ BYTE *pCustomValue,
            /* [in] */ ULONG cbCustomValue,
            /* [in] */ _mdToken *pcv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineTypeDef( 
            /* [in] */ LPOLESTR szNamespace,
            /* [in] */ LPOLESTR szTypeDef,
            /* [in] */ GUID *pguid,
            /* [in] */ INT64 *pVer,
            /* [in] */ DWORD dwTypeDefFlags,
            /* [in] */ _mdToken tkExtends,
            /* [in] */ DWORD dwExtendsFlags,
            /* [in] */ DWORD dwImplements,
            /* [length_is][size_is][out][in] */ _mdToken rtkImplements[  ],
            /* [in] */ DWORD dwEvents,
            /* [length_is][size_is][out][in] */ _mdToken rtkEvents[  ],
            /* [out] */ _mdToken *ptd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypeDefProps( 
            /* [in] */ _mdToken td,
            /* [in] */ INT64 *pVer,
            /* [in] */ DWORD dwTypeDefFlags,
            /* [in] */ _mdToken tkExtends,
            /* [in] */ DWORD dwExtendsFlags,
            /* [in] */ DWORD dwImplements,
            /* [length_is][size_is][in] */ _mdToken rtkImplements[  ],
            /* [in] */ DWORD dwEvents,
            /* [length_is][size_is][in] */ _mdToken rtkEvents[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassSvcsContext( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwClassActivateAttr,
            /* [in] */ DWORD dwClassThreadAttr,
            /* [in] */ DWORD dwXactionAttr,
            /* [in] */ DWORD dwSynchAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineTypeRefByGUID( 
            /* [in] */ GUID *pguid,
            /* [out] */ _mdToken *ptr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetModuleReg( 
            /* [in] */ DWORD dwModuleRegAttr,
            /* [in] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassReg( 
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szProgID,
            /* [in] */ LPOLESTR szVIProgID,
            /* [in] */ LPOLESTR szIconURL,
            /* [in] */ ULONG ulIconResource,
            /* [in] */ LPOLESTR szSmallIconURL,
            /* [in] */ ULONG ulSmallIconResource,
            /* [in] */ LPOLESTR szDefaultDispName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIfaceReg( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwIfaceSvcs,
            /* [in] */ GUID *proxyStub) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategoryImpl( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwImpl,
            /* [length_is][size_is][in] */ GUID rGuidCoCatImpl[  ],
            /* [in] */ DWORD dwReqd,
            /* [length_is][size_is][in] */ GUID rGuidCoCatReqd[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRedirectProgID( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwProgIds,
            /* [length_is][size_is][in] */ LPOLESTR rszRedirectProgID[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMimeTypeImpl( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwTypes,
            /* [length_is][size_is][in] */ LPOLESTR rszMimeType[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormatImpl( 
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwSupported,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatSupported[  ],
            /* [in] */ DWORD dwFrom,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsFrom[  ],
            /* [in] */ DWORD dwTo,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsTo[  ],
            /* [in] */ DWORD dwDefault,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatDefault[  ],
            /* [in] */ DWORD dwExt,
            /* [length_is][size_is][in] */ LPOLESTR rszFileExt[  ],
            /* [in] */ DWORD dwType,
            /* [length_is][size_is][in] */ LPOLESTR rszFileType[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoleCheck( 
            /* [in] */ _mdToken tk,
            /* [in] */ DWORD dwNames,
            /* [length_is][size_is][in] */ LPOLESTR rszName[  ],
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][in] */ DWORD rdwRoleFlags[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineMethod( 
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwMethodFlags,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ ULONG ulSlot,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags,
            /* [out] */ _mdToken *pmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineField( 
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwFieldFlags,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [out] */ _mdToken *pmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParamProps( 
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulParamSeq,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwParamFlags,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [out] */ _mdToken *ppd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineMethodImpl( 
            /* [in] */ _mdToken td,
            /* [in] */ _mdToken tk,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags,
            /* [out] */ _mdToken *pmi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRVA( 
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineTypeRefByName( 
            /* [in] */ LPOLESTR szNamespace,
            /* [in] */ LPOLESTR szType,
            /* [out] */ _mdToken *ptr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypeRefBind( 
            /* [in] */ _mdToken tr,
            /* [in] */ DWORD dwBindFlags,
            /* [in] */ DWORD dwMinVersion,
            /* [in] */ DWORD dwMaxVersion,
            /* [in] */ LPOLESTR szCodebase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineMemberRef( 
            /* [in] */ _mdToken tkImport,
            /* [in] */ LPOLESTR szName,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [out] */ _mdToken *pmr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineException( 
            /* [in] */ _mdToken mb,
            /* [in] */ _mdToken tk,
            /* [out] */ _mdToken *pex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineProperty( 
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szProperty,
            /* [in] */ DWORD dwPropFlags,
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [in] */ _mdToken mdSetter,
            /* [in] */ _mdToken mdGetter,
            /* [in] */ _mdToken mdReset,
            /* [in] */ _mdToken mdTestDefault,
            /* [in] */ DWORD dwOthers,
            /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
            /* [in] */ _mdToken evNotifyChanging,
            /* [in] */ _mdToken evNotifyChanged,
            /* [in] */ _mdToken fdBackingField,
            /* [out] */ _mdToken *pmdProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineEvent( 
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szEvent,
            /* [in] */ DWORD dwEventFlags,
            /* [in] */ _mdToken tkEventType,
            /* [in] */ _mdToken mdAddOn,
            /* [in] */ _mdToken mdRemoveOn,
            /* [in] */ _mdToken mdFire,
            /* [in] */ DWORD dwOthers,
            /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
            /* [out] */ _mdToken *pmdEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFieldMarshal( 
            /* [in] */ _mdToken tk,
            /* [size_is][in] */ BYTE *pvNativeType,
            /* [in] */ ULONG cbNativeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinePermissionSet( 
            /* [in] */ _mdToken tk,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pvPermission,
            /* [in] */ ULONG cbPermission,
            /* [out] */ _mdToken *ppm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMemberIndex( 
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTokenFromSig( 
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [in] */ _mdToken *pmsig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineModuleRef( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ GUID *pguid,
            /* [in] */ GUID *pmvid,
            /* [out] */ _mdToken *pmur) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParent( 
            /* [in] */ _mdToken mr,
            /* [in] */ _mdToken tk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTokenFromArraySpec( 
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [out] */ _mdToken *parrspec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMetaDataEmit2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMetaDataEmit2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMetaDataEmit2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetModuleProps )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ GUID *ppid,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ LPOLESTR szFile,
            /* [in] */ DWORD dwSaveFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SaveToStream )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ IStream *pIStream,
            /* [in] */ DWORD dwSaveFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaveSize )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ DWORD fSave,
            /* [out] */ DWORD *pdwSaveSize);
        
        HRESULT ( STDMETHODCALLTYPE *DefineCustomValueAsBlob )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tkObj,
            /* [in] */ LPOLESTR szName,
            /* [size_is][in] */ BYTE *pCustomValue,
            /* [in] */ ULONG cbCustomValue,
            /* [in] */ _mdToken *pcv);
        
        HRESULT ( STDMETHODCALLTYPE *DefineTypeDef )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ LPOLESTR szNamespace,
            /* [in] */ LPOLESTR szTypeDef,
            /* [in] */ GUID *pguid,
            /* [in] */ INT64 *pVer,
            /* [in] */ DWORD dwTypeDefFlags,
            /* [in] */ _mdToken tkExtends,
            /* [in] */ DWORD dwExtendsFlags,
            /* [in] */ DWORD dwImplements,
            /* [length_is][size_is][out][in] */ _mdToken rtkImplements[  ],
            /* [in] */ DWORD dwEvents,
            /* [length_is][size_is][out][in] */ _mdToken rtkEvents[  ],
            /* [out] */ _mdToken *ptd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTypeDefProps )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ INT64 *pVer,
            /* [in] */ DWORD dwTypeDefFlags,
            /* [in] */ _mdToken tkExtends,
            /* [in] */ DWORD dwExtendsFlags,
            /* [in] */ DWORD dwImplements,
            /* [length_is][size_is][in] */ _mdToken rtkImplements[  ],
            /* [in] */ DWORD dwEvents,
            /* [length_is][size_is][in] */ _mdToken rtkEvents[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassSvcsContext )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwClassActivateAttr,
            /* [in] */ DWORD dwClassThreadAttr,
            /* [in] */ DWORD dwXactionAttr,
            /* [in] */ DWORD dwSynchAttr);
        
        HRESULT ( STDMETHODCALLTYPE *DefineTypeRefByGUID )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ GUID *pguid,
            /* [out] */ _mdToken *ptr);
        
        HRESULT ( STDMETHODCALLTYPE *SetModuleReg )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ DWORD dwModuleRegAttr,
            /* [in] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassReg )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szProgID,
            /* [in] */ LPOLESTR szVIProgID,
            /* [in] */ LPOLESTR szIconURL,
            /* [in] */ ULONG ulIconResource,
            /* [in] */ LPOLESTR szSmallIconURL,
            /* [in] */ ULONG ulSmallIconResource,
            /* [in] */ LPOLESTR szDefaultDispName);
        
        HRESULT ( STDMETHODCALLTYPE *SetIfaceReg )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwIfaceSvcs,
            /* [in] */ GUID *proxyStub);
        
        HRESULT ( STDMETHODCALLTYPE *SetCategoryImpl )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwImpl,
            /* [length_is][size_is][in] */ GUID rGuidCoCatImpl[  ],
            /* [in] */ DWORD dwReqd,
            /* [length_is][size_is][in] */ GUID rGuidCoCatReqd[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRedirectProgID )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwProgIds,
            /* [length_is][size_is][in] */ LPOLESTR rszRedirectProgID[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetMimeTypeImpl )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwTypes,
            /* [length_is][size_is][in] */ LPOLESTR rszMimeType[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormatImpl )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ DWORD dwSupported,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatSupported[  ],
            /* [in] */ DWORD dwFrom,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsFrom[  ],
            /* [in] */ DWORD dwTo,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsTo[  ],
            /* [in] */ DWORD dwDefault,
            /* [length_is][size_is][in] */ LPOLESTR rszFormatDefault[  ],
            /* [in] */ DWORD dwExt,
            /* [length_is][size_is][in] */ LPOLESTR rszFileExt[  ],
            /* [in] */ DWORD dwType,
            /* [length_is][size_is][in] */ LPOLESTR rszFileType[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoleCheck )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tk,
            /* [in] */ DWORD dwNames,
            /* [length_is][size_is][in] */ LPOLESTR rszName[  ],
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][in] */ DWORD rdwRoleFlags[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineMethod )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwMethodFlags,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ ULONG ulSlot,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags,
            /* [out] */ _mdToken *pmd);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwFieldFlags,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [out] */ _mdToken *pmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetParamProps )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulParamSeq,
            /* [in] */ LPOLESTR szName,
            /* [in] */ DWORD dwParamFlags,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [out] */ _mdToken *ppd);
        
        HRESULT ( STDMETHODCALLTYPE *DefineMethodImpl )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ _mdToken tk,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags,
            /* [out] */ _mdToken *pmi);
        
        HRESULT ( STDMETHODCALLTYPE *SetRVA )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulCodeRVA,
            /* [in] */ DWORD dwImplFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DefineTypeRefByName )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ LPOLESTR szNamespace,
            /* [in] */ LPOLESTR szType,
            /* [out] */ _mdToken *ptr);
        
        HRESULT ( STDMETHODCALLTYPE *SetTypeRefBind )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tr,
            /* [in] */ DWORD dwBindFlags,
            /* [in] */ DWORD dwMinVersion,
            /* [in] */ DWORD dwMaxVersion,
            /* [in] */ LPOLESTR szCodebase);
        
        HRESULT ( STDMETHODCALLTYPE *DefineMemberRef )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tkImport,
            /* [in] */ LPOLESTR szName,
            /* [size_is][in] */ BYTE *pvSigBlob,
            /* [in] */ ULONG cbSigBlob,
            /* [out] */ _mdToken *pmr);
        
        HRESULT ( STDMETHODCALLTYPE *DefineException )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken mb,
            /* [in] */ _mdToken tk,
            /* [out] */ _mdToken *pex);
        
        HRESULT ( STDMETHODCALLTYPE *DefineProperty )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szProperty,
            /* [in] */ DWORD dwPropFlags,
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [in] */ DWORD dwCPlusTypeFlag,
            /* [size_is][in] */ BYTE *pValue,
            /* [in] */ ULONG cbValue,
            /* [in] */ _mdToken mdSetter,
            /* [in] */ _mdToken mdGetter,
            /* [in] */ _mdToken mdReset,
            /* [in] */ _mdToken mdTestDefault,
            /* [in] */ DWORD dwOthers,
            /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
            /* [in] */ _mdToken evNotifyChanging,
            /* [in] */ _mdToken evNotifyChanged,
            /* [in] */ _mdToken fdBackingField,
            /* [out] */ _mdToken *pmdProp);
        
        HRESULT ( STDMETHODCALLTYPE *DefineEvent )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken td,
            /* [in] */ LPOLESTR szEvent,
            /* [in] */ DWORD dwEventFlags,
            /* [in] */ _mdToken tkEventType,
            /* [in] */ _mdToken mdAddOn,
            /* [in] */ _mdToken mdRemoveOn,
            /* [in] */ _mdToken mdFire,
            /* [in] */ DWORD dwOthers,
            /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
            /* [out] */ _mdToken *pmdEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetFieldMarshal )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tk,
            /* [size_is][in] */ BYTE *pvNativeType,
            /* [in] */ ULONG cbNativeType);
        
        HRESULT ( STDMETHODCALLTYPE *DefinePermissionSet )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken tk,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pvPermission,
            /* [in] */ ULONG cbPermission,
            /* [out] */ _mdToken *ppm);
        
        HRESULT ( STDMETHODCALLTYPE *SetMemberIndex )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken md,
            /* [in] */ ULONG ulIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenFromSig )( 
            IDebugMetaDataEmit2 * This,
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [in] */ _mdToken *pmsig);
        
        HRESULT ( STDMETHODCALLTYPE *DefineModuleRef )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ GUID *pguid,
            /* [in] */ GUID *pmvid,
            /* [out] */ _mdToken *pmur);
        
        HRESULT ( STDMETHODCALLTYPE *SetParent )( 
            IDebugMetaDataEmit2 * This,
            /* [in] */ _mdToken mr,
            /* [in] */ _mdToken tk);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenFromArraySpec )( 
            IDebugMetaDataEmit2 * This,
            /* [size_is][in] */ BYTE *pvSig,
            /* [in] */ ULONG cbSig,
            /* [out] */ _mdToken *parrspec);
        
        END_INTERFACE
    } IDebugMetaDataEmit2Vtbl;

    interface IDebugMetaDataEmit2
    {
        CONST_VTBL struct IDebugMetaDataEmit2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMetaDataEmit2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMetaDataEmit2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMetaDataEmit2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMetaDataEmit2_SetModuleProps(This,szName,ppid,lcid)	\
    (This)->lpVtbl -> SetModuleProps(This,szName,ppid,lcid)

#define IDebugMetaDataEmit2_Save(This,szFile,dwSaveFlags)	\
    (This)->lpVtbl -> Save(This,szFile,dwSaveFlags)

#define IDebugMetaDataEmit2_SaveToStream(This,pIStream,dwSaveFlags)	\
    (This)->lpVtbl -> SaveToStream(This,pIStream,dwSaveFlags)

#define IDebugMetaDataEmit2_GetSaveSize(This,fSave,pdwSaveSize)	\
    (This)->lpVtbl -> GetSaveSize(This,fSave,pdwSaveSize)

#define IDebugMetaDataEmit2_DefineCustomValueAsBlob(This,tkObj,szName,pCustomValue,cbCustomValue,pcv)	\
    (This)->lpVtbl -> DefineCustomValueAsBlob(This,tkObj,szName,pCustomValue,cbCustomValue,pcv)

#define IDebugMetaDataEmit2_DefineTypeDef(This,szNamespace,szTypeDef,pguid,pVer,dwTypeDefFlags,tkExtends,dwExtendsFlags,dwImplements,rtkImplements,dwEvents,rtkEvents,ptd)	\
    (This)->lpVtbl -> DefineTypeDef(This,szNamespace,szTypeDef,pguid,pVer,dwTypeDefFlags,tkExtends,dwExtendsFlags,dwImplements,rtkImplements,dwEvents,rtkEvents,ptd)

#define IDebugMetaDataEmit2_SetTypeDefProps(This,td,pVer,dwTypeDefFlags,tkExtends,dwExtendsFlags,dwImplements,rtkImplements,dwEvents,rtkEvents)	\
    (This)->lpVtbl -> SetTypeDefProps(This,td,pVer,dwTypeDefFlags,tkExtends,dwExtendsFlags,dwImplements,rtkImplements,dwEvents,rtkEvents)

#define IDebugMetaDataEmit2_SetClassSvcsContext(This,td,dwClassActivateAttr,dwClassThreadAttr,dwXactionAttr,dwSynchAttr)	\
    (This)->lpVtbl -> SetClassSvcsContext(This,td,dwClassActivateAttr,dwClassThreadAttr,dwXactionAttr,dwSynchAttr)

#define IDebugMetaDataEmit2_DefineTypeRefByGUID(This,pguid,ptr)	\
    (This)->lpVtbl -> DefineTypeRefByGUID(This,pguid,ptr)

#define IDebugMetaDataEmit2_SetModuleReg(This,dwModuleRegAttr,pguid)	\
    (This)->lpVtbl -> SetModuleReg(This,dwModuleRegAttr,pguid)

#define IDebugMetaDataEmit2_SetClassReg(This,td,szProgID,szVIProgID,szIconURL,ulIconResource,szSmallIconURL,ulSmallIconResource,szDefaultDispName)	\
    (This)->lpVtbl -> SetClassReg(This,td,szProgID,szVIProgID,szIconURL,ulIconResource,szSmallIconURL,ulSmallIconResource,szDefaultDispName)

#define IDebugMetaDataEmit2_SetIfaceReg(This,td,dwIfaceSvcs,proxyStub)	\
    (This)->lpVtbl -> SetIfaceReg(This,td,dwIfaceSvcs,proxyStub)

#define IDebugMetaDataEmit2_SetCategoryImpl(This,td,dwImpl,rGuidCoCatImpl,dwReqd,rGuidCoCatReqd)	\
    (This)->lpVtbl -> SetCategoryImpl(This,td,dwImpl,rGuidCoCatImpl,dwReqd,rGuidCoCatReqd)

#define IDebugMetaDataEmit2_SetRedirectProgID(This,td,dwProgIds,rszRedirectProgID)	\
    (This)->lpVtbl -> SetRedirectProgID(This,td,dwProgIds,rszRedirectProgID)

#define IDebugMetaDataEmit2_SetMimeTypeImpl(This,td,dwTypes,rszMimeType)	\
    (This)->lpVtbl -> SetMimeTypeImpl(This,td,dwTypes,rszMimeType)

#define IDebugMetaDataEmit2_SetFormatImpl(This,td,dwSupported,rszFormatSupported,dwFrom,rszFormatConvertsFrom,dwTo,rszFormatConvertsTo,dwDefault,rszFormatDefault,dwExt,rszFileExt,dwType,rszFileType)	\
    (This)->lpVtbl -> SetFormatImpl(This,td,dwSupported,rszFormatSupported,dwFrom,rszFormatConvertsFrom,dwTo,rszFormatConvertsTo,dwDefault,rszFormatDefault,dwExt,rszFileExt,dwType,rszFileType)

#define IDebugMetaDataEmit2_SetRoleCheck(This,tk,dwNames,rszName,dwFlags,rdwRoleFlags)	\
    (This)->lpVtbl -> SetRoleCheck(This,tk,dwNames,rszName,dwFlags,rdwRoleFlags)

#define IDebugMetaDataEmit2_DefineMethod(This,td,szName,dwMethodFlags,pvSigBlob,cbSigBlob,ulSlot,ulCodeRVA,dwImplFlags,pmd)	\
    (This)->lpVtbl -> DefineMethod(This,td,szName,dwMethodFlags,pvSigBlob,cbSigBlob,ulSlot,ulCodeRVA,dwImplFlags,pmd)

#define IDebugMetaDataEmit2_DefineField(This,td,szName,dwFieldFlags,pvSigBlob,cbSigBlob,dwCPlusTypeFlag,pValue,cbValue,pmd)	\
    (This)->lpVtbl -> DefineField(This,td,szName,dwFieldFlags,pvSigBlob,cbSigBlob,dwCPlusTypeFlag,pValue,cbValue,pmd)

#define IDebugMetaDataEmit2_SetParamProps(This,md,ulParamSeq,szName,dwParamFlags,dwCPlusTypeFlag,pValue,cbValue,ppd)	\
    (This)->lpVtbl -> SetParamProps(This,md,ulParamSeq,szName,dwParamFlags,dwCPlusTypeFlag,pValue,cbValue,ppd)

#define IDebugMetaDataEmit2_DefineMethodImpl(This,td,tk,ulCodeRVA,dwImplFlags,pmi)	\
    (This)->lpVtbl -> DefineMethodImpl(This,td,tk,ulCodeRVA,dwImplFlags,pmi)

#define IDebugMetaDataEmit2_SetRVA(This,md,ulCodeRVA,dwImplFlags)	\
    (This)->lpVtbl -> SetRVA(This,md,ulCodeRVA,dwImplFlags)

#define IDebugMetaDataEmit2_DefineTypeRefByName(This,szNamespace,szType,ptr)	\
    (This)->lpVtbl -> DefineTypeRefByName(This,szNamespace,szType,ptr)

#define IDebugMetaDataEmit2_SetTypeRefBind(This,tr,dwBindFlags,dwMinVersion,dwMaxVersion,szCodebase)	\
    (This)->lpVtbl -> SetTypeRefBind(This,tr,dwBindFlags,dwMinVersion,dwMaxVersion,szCodebase)

#define IDebugMetaDataEmit2_DefineMemberRef(This,tkImport,szName,pvSigBlob,cbSigBlob,pmr)	\
    (This)->lpVtbl -> DefineMemberRef(This,tkImport,szName,pvSigBlob,cbSigBlob,pmr)

#define IDebugMetaDataEmit2_DefineException(This,mb,tk,pex)	\
    (This)->lpVtbl -> DefineException(This,mb,tk,pex)

#define IDebugMetaDataEmit2_DefineProperty(This,td,szProperty,dwPropFlags,pvSig,cbSig,dwCPlusTypeFlag,pValue,cbValue,mdSetter,mdGetter,mdReset,mdTestDefault,dwOthers,rmdOtherMethods,evNotifyChanging,evNotifyChanged,fdBackingField,pmdProp)	\
    (This)->lpVtbl -> DefineProperty(This,td,szProperty,dwPropFlags,pvSig,cbSig,dwCPlusTypeFlag,pValue,cbValue,mdSetter,mdGetter,mdReset,mdTestDefault,dwOthers,rmdOtherMethods,evNotifyChanging,evNotifyChanged,fdBackingField,pmdProp)

#define IDebugMetaDataEmit2_DefineEvent(This,td,szEvent,dwEventFlags,tkEventType,mdAddOn,mdRemoveOn,mdFire,dwOthers,rmdOtherMethods,pmdEvent)	\
    (This)->lpVtbl -> DefineEvent(This,td,szEvent,dwEventFlags,tkEventType,mdAddOn,mdRemoveOn,mdFire,dwOthers,rmdOtherMethods,pmdEvent)

#define IDebugMetaDataEmit2_SetFieldMarshal(This,tk,pvNativeType,cbNativeType)	\
    (This)->lpVtbl -> SetFieldMarshal(This,tk,pvNativeType,cbNativeType)

#define IDebugMetaDataEmit2_DefinePermissionSet(This,tk,dwAction,pvPermission,cbPermission,ppm)	\
    (This)->lpVtbl -> DefinePermissionSet(This,tk,dwAction,pvPermission,cbPermission,ppm)

#define IDebugMetaDataEmit2_SetMemberIndex(This,md,ulIndex)	\
    (This)->lpVtbl -> SetMemberIndex(This,md,ulIndex)

#define IDebugMetaDataEmit2_GetTokenFromSig(This,pvSig,cbSig,pmsig)	\
    (This)->lpVtbl -> GetTokenFromSig(This,pvSig,cbSig,pmsig)

#define IDebugMetaDataEmit2_DefineModuleRef(This,szName,pguid,pmvid,pmur)	\
    (This)->lpVtbl -> DefineModuleRef(This,szName,pguid,pmvid,pmur)

#define IDebugMetaDataEmit2_SetParent(This,mr,tk)	\
    (This)->lpVtbl -> SetParent(This,mr,tk)

#define IDebugMetaDataEmit2_GetTokenFromArraySpec(This,pvSig,cbSig,parrspec)	\
    (This)->lpVtbl -> GetTokenFromArraySpec(This,pvSig,cbSig,parrspec)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetModuleProps_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ GUID *ppid,
    /* [in] */ LCID lcid);


void __RPC_STUB IDebugMetaDataEmit2_SetModuleProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_Save_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ LPOLESTR szFile,
    /* [in] */ DWORD dwSaveFlags);


void __RPC_STUB IDebugMetaDataEmit2_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SaveToStream_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ IStream *pIStream,
    /* [in] */ DWORD dwSaveFlags);


void __RPC_STUB IDebugMetaDataEmit2_SaveToStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_GetSaveSize_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ DWORD fSave,
    /* [out] */ DWORD *pdwSaveSize);


void __RPC_STUB IDebugMetaDataEmit2_GetSaveSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineCustomValueAsBlob_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tkObj,
    /* [in] */ LPOLESTR szName,
    /* [size_is][in] */ BYTE *pCustomValue,
    /* [in] */ ULONG cbCustomValue,
    /* [in] */ _mdToken *pcv);


void __RPC_STUB IDebugMetaDataEmit2_DefineCustomValueAsBlob_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineTypeDef_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ LPOLESTR szNamespace,
    /* [in] */ LPOLESTR szTypeDef,
    /* [in] */ GUID *pguid,
    /* [in] */ INT64 *pVer,
    /* [in] */ DWORD dwTypeDefFlags,
    /* [in] */ _mdToken tkExtends,
    /* [in] */ DWORD dwExtendsFlags,
    /* [in] */ DWORD dwImplements,
    /* [length_is][size_is][out][in] */ _mdToken rtkImplements[  ],
    /* [in] */ DWORD dwEvents,
    /* [length_is][size_is][out][in] */ _mdToken rtkEvents[  ],
    /* [out] */ _mdToken *ptd);


void __RPC_STUB IDebugMetaDataEmit2_DefineTypeDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetTypeDefProps_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ INT64 *pVer,
    /* [in] */ DWORD dwTypeDefFlags,
    /* [in] */ _mdToken tkExtends,
    /* [in] */ DWORD dwExtendsFlags,
    /* [in] */ DWORD dwImplements,
    /* [length_is][size_is][in] */ _mdToken rtkImplements[  ],
    /* [in] */ DWORD dwEvents,
    /* [length_is][size_is][in] */ _mdToken rtkEvents[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetTypeDefProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetClassSvcsContext_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwClassActivateAttr,
    /* [in] */ DWORD dwClassThreadAttr,
    /* [in] */ DWORD dwXactionAttr,
    /* [in] */ DWORD dwSynchAttr);


void __RPC_STUB IDebugMetaDataEmit2_SetClassSvcsContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineTypeRefByGUID_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ GUID *pguid,
    /* [out] */ _mdToken *ptr);


void __RPC_STUB IDebugMetaDataEmit2_DefineTypeRefByGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetModuleReg_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ DWORD dwModuleRegAttr,
    /* [in] */ GUID *pguid);


void __RPC_STUB IDebugMetaDataEmit2_SetModuleReg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetClassReg_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ LPOLESTR szProgID,
    /* [in] */ LPOLESTR szVIProgID,
    /* [in] */ LPOLESTR szIconURL,
    /* [in] */ ULONG ulIconResource,
    /* [in] */ LPOLESTR szSmallIconURL,
    /* [in] */ ULONG ulSmallIconResource,
    /* [in] */ LPOLESTR szDefaultDispName);


void __RPC_STUB IDebugMetaDataEmit2_SetClassReg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetIfaceReg_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwIfaceSvcs,
    /* [in] */ GUID *proxyStub);


void __RPC_STUB IDebugMetaDataEmit2_SetIfaceReg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetCategoryImpl_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwImpl,
    /* [length_is][size_is][in] */ GUID rGuidCoCatImpl[  ],
    /* [in] */ DWORD dwReqd,
    /* [length_is][size_is][in] */ GUID rGuidCoCatReqd[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetCategoryImpl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetRedirectProgID_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwProgIds,
    /* [length_is][size_is][in] */ LPOLESTR rszRedirectProgID[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetRedirectProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetMimeTypeImpl_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwTypes,
    /* [length_is][size_is][in] */ LPOLESTR rszMimeType[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetMimeTypeImpl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetFormatImpl_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ DWORD dwSupported,
    /* [length_is][size_is][in] */ LPOLESTR rszFormatSupported[  ],
    /* [in] */ DWORD dwFrom,
    /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsFrom[  ],
    /* [in] */ DWORD dwTo,
    /* [length_is][size_is][in] */ LPOLESTR rszFormatConvertsTo[  ],
    /* [in] */ DWORD dwDefault,
    /* [length_is][size_is][in] */ LPOLESTR rszFormatDefault[  ],
    /* [in] */ DWORD dwExt,
    /* [length_is][size_is][in] */ LPOLESTR rszFileExt[  ],
    /* [in] */ DWORD dwType,
    /* [length_is][size_is][in] */ LPOLESTR rszFileType[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetFormatImpl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetRoleCheck_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tk,
    /* [in] */ DWORD dwNames,
    /* [length_is][size_is][in] */ LPOLESTR rszName[  ],
    /* [in] */ DWORD dwFlags,
    /* [length_is][size_is][in] */ DWORD rdwRoleFlags[  ]);


void __RPC_STUB IDebugMetaDataEmit2_SetRoleCheck_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineMethod_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ LPOLESTR szName,
    /* [in] */ DWORD dwMethodFlags,
    /* [size_is][in] */ BYTE *pvSigBlob,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ ULONG ulSlot,
    /* [in] */ ULONG ulCodeRVA,
    /* [in] */ DWORD dwImplFlags,
    /* [out] */ _mdToken *pmd);


void __RPC_STUB IDebugMetaDataEmit2_DefineMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineField_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ LPOLESTR szName,
    /* [in] */ DWORD dwFieldFlags,
    /* [size_is][in] */ BYTE *pvSigBlob,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ DWORD dwCPlusTypeFlag,
    /* [size_is][in] */ BYTE *pValue,
    /* [in] */ ULONG cbValue,
    /* [out] */ _mdToken *pmd);


void __RPC_STUB IDebugMetaDataEmit2_DefineField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetParamProps_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken md,
    /* [in] */ ULONG ulParamSeq,
    /* [in] */ LPOLESTR szName,
    /* [in] */ DWORD dwParamFlags,
    /* [in] */ DWORD dwCPlusTypeFlag,
    /* [size_is][in] */ BYTE *pValue,
    /* [in] */ ULONG cbValue,
    /* [out] */ _mdToken *ppd);


void __RPC_STUB IDebugMetaDataEmit2_SetParamProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineMethodImpl_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ _mdToken tk,
    /* [in] */ ULONG ulCodeRVA,
    /* [in] */ DWORD dwImplFlags,
    /* [out] */ _mdToken *pmi);


void __RPC_STUB IDebugMetaDataEmit2_DefineMethodImpl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetRVA_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken md,
    /* [in] */ ULONG ulCodeRVA,
    /* [in] */ DWORD dwImplFlags);


void __RPC_STUB IDebugMetaDataEmit2_SetRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineTypeRefByName_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ LPOLESTR szNamespace,
    /* [in] */ LPOLESTR szType,
    /* [out] */ _mdToken *ptr);


void __RPC_STUB IDebugMetaDataEmit2_DefineTypeRefByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetTypeRefBind_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tr,
    /* [in] */ DWORD dwBindFlags,
    /* [in] */ DWORD dwMinVersion,
    /* [in] */ DWORD dwMaxVersion,
    /* [in] */ LPOLESTR szCodebase);


void __RPC_STUB IDebugMetaDataEmit2_SetTypeRefBind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineMemberRef_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tkImport,
    /* [in] */ LPOLESTR szName,
    /* [size_is][in] */ BYTE *pvSigBlob,
    /* [in] */ ULONG cbSigBlob,
    /* [out] */ _mdToken *pmr);


void __RPC_STUB IDebugMetaDataEmit2_DefineMemberRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineException_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken mb,
    /* [in] */ _mdToken tk,
    /* [out] */ _mdToken *pex);


void __RPC_STUB IDebugMetaDataEmit2_DefineException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineProperty_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ LPOLESTR szProperty,
    /* [in] */ DWORD dwPropFlags,
    /* [size_is][in] */ BYTE *pvSig,
    /* [in] */ ULONG cbSig,
    /* [in] */ DWORD dwCPlusTypeFlag,
    /* [size_is][in] */ BYTE *pValue,
    /* [in] */ ULONG cbValue,
    /* [in] */ _mdToken mdSetter,
    /* [in] */ _mdToken mdGetter,
    /* [in] */ _mdToken mdReset,
    /* [in] */ _mdToken mdTestDefault,
    /* [in] */ DWORD dwOthers,
    /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
    /* [in] */ _mdToken evNotifyChanging,
    /* [in] */ _mdToken evNotifyChanged,
    /* [in] */ _mdToken fdBackingField,
    /* [out] */ _mdToken *pmdProp);


void __RPC_STUB IDebugMetaDataEmit2_DefineProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineEvent_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken td,
    /* [in] */ LPOLESTR szEvent,
    /* [in] */ DWORD dwEventFlags,
    /* [in] */ _mdToken tkEventType,
    /* [in] */ _mdToken mdAddOn,
    /* [in] */ _mdToken mdRemoveOn,
    /* [in] */ _mdToken mdFire,
    /* [in] */ DWORD dwOthers,
    /* [length_is][size_is][in] */ _mdToken rmdOtherMethods[  ],
    /* [out] */ _mdToken *pmdEvent);


void __RPC_STUB IDebugMetaDataEmit2_DefineEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetFieldMarshal_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tk,
    /* [size_is][in] */ BYTE *pvNativeType,
    /* [in] */ ULONG cbNativeType);


void __RPC_STUB IDebugMetaDataEmit2_SetFieldMarshal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefinePermissionSet_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken tk,
    /* [in] */ DWORD dwAction,
    /* [size_is][in] */ BYTE *pvPermission,
    /* [in] */ ULONG cbPermission,
    /* [out] */ _mdToken *ppm);


void __RPC_STUB IDebugMetaDataEmit2_DefinePermissionSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetMemberIndex_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken md,
    /* [in] */ ULONG ulIndex);


void __RPC_STUB IDebugMetaDataEmit2_SetMemberIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_GetTokenFromSig_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [size_is][in] */ BYTE *pvSig,
    /* [in] */ ULONG cbSig,
    /* [in] */ _mdToken *pmsig);


void __RPC_STUB IDebugMetaDataEmit2_GetTokenFromSig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_DefineModuleRef_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ GUID *pguid,
    /* [in] */ GUID *pmvid,
    /* [out] */ _mdToken *pmur);


void __RPC_STUB IDebugMetaDataEmit2_DefineModuleRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_SetParent_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [in] */ _mdToken mr,
    /* [in] */ _mdToken tk);


void __RPC_STUB IDebugMetaDataEmit2_SetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataEmit2_GetTokenFromArraySpec_Proxy( 
    IDebugMetaDataEmit2 * This,
    /* [size_is][in] */ BYTE *pvSig,
    /* [in] */ ULONG cbSig,
    /* [out] */ _mdToken *parrspec);


void __RPC_STUB IDebugMetaDataEmit2_GetTokenFromArraySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMetaDataEmit2_INTERFACE_DEFINED__ */


#ifndef __IDebugMetaDataDebugEmit2_INTERFACE_DEFINED__
#define __IDebugMetaDataDebugEmit2_INTERFACE_DEFINED__

/* interface IDebugMetaDataDebugEmit2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugMetaDataDebugEmit2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6f94d22-78c2-11d2-8ffe-00c04fa38314")
    IDebugMetaDataDebugEmit2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DefineSourceFile( 
            /* [in] */ LPOLESTR szFileName,
            /* [out] */ _mdToken *psourcefile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineBlock( 
            /* [in] */ _mdToken member,
            /* [in] */ _mdToken sourcefile,
            /* [in] */ BYTE *pAttr,
            /* [in] */ ULONG cbAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineLocalVarScope( 
            /* [in] */ _mdToken scopeParent,
            /* [in] */ ULONG ulStartLine,
            /* [in] */ ULONG ulEndLine,
            /* [in] */ _mdToken member,
            /* [out] */ _mdToken *plocalvarscope) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugMetaDataDebugEmit2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugMetaDataDebugEmit2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugMetaDataDebugEmit2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugMetaDataDebugEmit2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSourceFile )( 
            IDebugMetaDataDebugEmit2 * This,
            /* [in] */ LPOLESTR szFileName,
            /* [out] */ _mdToken *psourcefile);
        
        HRESULT ( STDMETHODCALLTYPE *DefineBlock )( 
            IDebugMetaDataDebugEmit2 * This,
            /* [in] */ _mdToken member,
            /* [in] */ _mdToken sourcefile,
            /* [in] */ BYTE *pAttr,
            /* [in] */ ULONG cbAttr);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVarScope )( 
            IDebugMetaDataDebugEmit2 * This,
            /* [in] */ _mdToken scopeParent,
            /* [in] */ ULONG ulStartLine,
            /* [in] */ ULONG ulEndLine,
            /* [in] */ _mdToken member,
            /* [out] */ _mdToken *plocalvarscope);
        
        END_INTERFACE
    } IDebugMetaDataDebugEmit2Vtbl;

    interface IDebugMetaDataDebugEmit2
    {
        CONST_VTBL struct IDebugMetaDataDebugEmit2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugMetaDataDebugEmit2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugMetaDataDebugEmit2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugMetaDataDebugEmit2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugMetaDataDebugEmit2_DefineSourceFile(This,szFileName,psourcefile)	\
    (This)->lpVtbl -> DefineSourceFile(This,szFileName,psourcefile)

#define IDebugMetaDataDebugEmit2_DefineBlock(This,member,sourcefile,pAttr,cbAttr)	\
    (This)->lpVtbl -> DefineBlock(This,member,sourcefile,pAttr,cbAttr)

#define IDebugMetaDataDebugEmit2_DefineLocalVarScope(This,scopeParent,ulStartLine,ulEndLine,member,plocalvarscope)	\
    (This)->lpVtbl -> DefineLocalVarScope(This,scopeParent,ulStartLine,ulEndLine,member,plocalvarscope)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugMetaDataDebugEmit2_DefineSourceFile_Proxy( 
    IDebugMetaDataDebugEmit2 * This,
    /* [in] */ LPOLESTR szFileName,
    /* [out] */ _mdToken *psourcefile);


void __RPC_STUB IDebugMetaDataDebugEmit2_DefineSourceFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataDebugEmit2_DefineBlock_Proxy( 
    IDebugMetaDataDebugEmit2 * This,
    /* [in] */ _mdToken member,
    /* [in] */ _mdToken sourcefile,
    /* [in] */ BYTE *pAttr,
    /* [in] */ ULONG cbAttr);


void __RPC_STUB IDebugMetaDataDebugEmit2_DefineBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugMetaDataDebugEmit2_DefineLocalVarScope_Proxy( 
    IDebugMetaDataDebugEmit2 * This,
    /* [in] */ _mdToken scopeParent,
    /* [in] */ ULONG ulStartLine,
    /* [in] */ ULONG ulEndLine,
    /* [in] */ _mdToken member,
    /* [out] */ _mdToken *plocalvarscope);


void __RPC_STUB IDebugMetaDataDebugEmit2_DefineLocalVarScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugMetaDataDebugEmit2_INTERFACE_DEFINED__ */


#ifndef __IDebugENCStateEvents_INTERFACE_DEFINED__
#define __IDebugENCStateEvents_INTERFACE_DEFINED__

/* interface IDebugENCStateEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugENCStateEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec80d064-102e-435f-aafb-d37e2a4ef654")
    IDebugENCStateEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ ENCSTATE *in_pENCSTATE,
            /* [in] */ BOOL in_fReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugENCStateEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugENCStateEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugENCStateEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugENCStateEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            IDebugENCStateEvents * This,
            /* [in] */ ENCSTATE *in_pENCSTATE,
            /* [in] */ BOOL in_fReserved);
        
        END_INTERFACE
    } IDebugENCStateEventsVtbl;

    interface IDebugENCStateEvents
    {
        CONST_VTBL struct IDebugENCStateEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugENCStateEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugENCStateEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugENCStateEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugENCStateEvents_OnStateChange(This,in_pENCSTATE,in_fReserved)	\
    (This)->lpVtbl -> OnStateChange(This,in_pENCSTATE,in_fReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugENCStateEvents_OnStateChange_Proxy( 
    IDebugENCStateEvents * This,
    /* [in] */ ENCSTATE *in_pENCSTATE,
    /* [in] */ BOOL in_fReserved);


void __RPC_STUB IDebugENCStateEvents_OnStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugENCStateEvents_INTERFACE_DEFINED__ */



#ifndef __EncLib_LIBRARY_DEFINED__
#define __EncLib_LIBRARY_DEFINED__

/* library EncLib */
/* [uuid] */ 


EXTERN_C const IID LIBID_EncLib;

EXTERN_C const CLSID CLSID_EncMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("99A426F1-AF1D-11d2-922C-00A02448799A")
EncMgr;
#endif
#endif /* __EncLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vsbuilt\debug\inc\i386\dteinternal.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Tue Jan 08 04:19:09 2002
 */
/* Compiler settings for dte.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dteinternal_h__
#define __dteinternal_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef ___DTE_FWD_DEFINED__
#define ___DTE_FWD_DEFINED__
typedef interface _DTE _DTE;
#endif 	/* ___DTE_FWD_DEFINED__ */


#ifndef ___Solution_FWD_DEFINED__
#define ___Solution_FWD_DEFINED__
typedef interface _Solution _Solution;
#endif 	/* ___Solution_FWD_DEFINED__ */


#ifndef __Projects_FWD_DEFINED__
#define __Projects_FWD_DEFINED__
typedef interface Projects Projects;
#endif 	/* __Projects_FWD_DEFINED__ */


#ifndef __Project_FWD_DEFINED__
#define __Project_FWD_DEFINED__
typedef interface Project Project;
#endif 	/* __Project_FWD_DEFINED__ */


#ifndef __ProjectItems_FWD_DEFINED__
#define __ProjectItems_FWD_DEFINED__
typedef interface ProjectItems ProjectItems;
#endif 	/* __ProjectItems_FWD_DEFINED__ */


#ifndef __ProjectItem_FWD_DEFINED__
#define __ProjectItem_FWD_DEFINED__
typedef interface ProjectItem ProjectItem;
#endif 	/* __ProjectItem_FWD_DEFINED__ */


#ifndef __Commands_FWD_DEFINED__
#define __Commands_FWD_DEFINED__
typedef interface Commands Commands;
#endif 	/* __Commands_FWD_DEFINED__ */


#ifndef __TextBuffer_FWD_DEFINED__
#define __TextBuffer_FWD_DEFINED__
typedef interface TextBuffer TextBuffer;
#endif 	/* __TextBuffer_FWD_DEFINED__ */


#ifndef __AddIns_FWD_DEFINED__
#define __AddIns_FWD_DEFINED__
typedef interface AddIns AddIns;
#endif 	/* __AddIns_FWD_DEFINED__ */


#ifndef __AddIn_FWD_DEFINED__
#define __AddIn_FWD_DEFINED__
typedef interface AddIn AddIn;
#endif 	/* __AddIn_FWD_DEFINED__ */


#ifndef __Properties_FWD_DEFINED__
#define __Properties_FWD_DEFINED__
typedef interface Properties Properties;
#endif 	/* __Properties_FWD_DEFINED__ */


#ifndef __Property_FWD_DEFINED__
#define __Property_FWD_DEFINED__
typedef interface Property Property;
#endif 	/* __Property_FWD_DEFINED__ */


#ifndef __ISupportVSProperties_FWD_DEFINED__
#define __ISupportVSProperties_FWD_DEFINED__
typedef interface ISupportVSProperties ISupportVSProperties;
#endif 	/* __ISupportVSProperties_FWD_DEFINED__ */


#ifndef __SelectedItems_FWD_DEFINED__
#define __SelectedItems_FWD_DEFINED__
typedef interface SelectedItems SelectedItems;
#endif 	/* __SelectedItems_FWD_DEFINED__ */


#ifndef __SelectedItem_FWD_DEFINED__
#define __SelectedItem_FWD_DEFINED__
typedef interface SelectedItem SelectedItem;
#endif 	/* __SelectedItem_FWD_DEFINED__ */


#ifndef __SelectionContainer_FWD_DEFINED__
#define __SelectionContainer_FWD_DEFINED__
typedef interface SelectionContainer SelectionContainer;
#endif 	/* __SelectionContainer_FWD_DEFINED__ */


#ifndef __Windows_FWD_DEFINED__
#define __Windows_FWD_DEFINED__
typedef interface Windows Windows;
#endif 	/* __Windows_FWD_DEFINED__ */


#ifndef __Window_FWD_DEFINED__
#define __Window_FWD_DEFINED__
typedef interface Window Window;
#endif 	/* __Window_FWD_DEFINED__ */


#ifndef __LinkedWindows_FWD_DEFINED__
#define __LinkedWindows_FWD_DEFINED__
typedef interface LinkedWindows LinkedWindows;
#endif 	/* __LinkedWindows_FWD_DEFINED__ */


#ifndef __Events_FWD_DEFINED__
#define __Events_FWD_DEFINED__
typedef interface Events Events;
#endif 	/* __Events_FWD_DEFINED__ */


#ifndef __TaskList_FWD_DEFINED__
#define __TaskList_FWD_DEFINED__
typedef interface TaskList TaskList;
#endif 	/* __TaskList_FWD_DEFINED__ */


#ifndef __TaskItems_FWD_DEFINED__
#define __TaskItems_FWD_DEFINED__
typedef interface TaskItems TaskItems;
#endif 	/* __TaskItems_FWD_DEFINED__ */


#ifndef __TaskItem_FWD_DEFINED__
#define __TaskItem_FWD_DEFINED__
typedef interface TaskItem TaskItem;
#endif 	/* __TaskItem_FWD_DEFINED__ */


#ifndef __ToolBox_FWD_DEFINED__
#define __ToolBox_FWD_DEFINED__
typedef interface ToolBox ToolBox;
#endif 	/* __ToolBox_FWD_DEFINED__ */


#ifndef __ToolBoxTabs_FWD_DEFINED__
#define __ToolBoxTabs_FWD_DEFINED__
typedef interface ToolBoxTabs ToolBoxTabs;
#endif 	/* __ToolBoxTabs_FWD_DEFINED__ */


#ifndef __ToolBoxTab_FWD_DEFINED__
#define __ToolBoxTab_FWD_DEFINED__
typedef interface ToolBoxTab ToolBoxTab;
#endif 	/* __ToolBoxTab_FWD_DEFINED__ */


#ifndef __ToolBoxItem_FWD_DEFINED__
#define __ToolBoxItem_FWD_DEFINED__
typedef interface ToolBoxItem ToolBoxItem;
#endif 	/* __ToolBoxItem_FWD_DEFINED__ */


#ifndef __ToolBoxItems_FWD_DEFINED__
#define __ToolBoxItems_FWD_DEFINED__
typedef interface ToolBoxItems ToolBoxItems;
#endif 	/* __ToolBoxItems_FWD_DEFINED__ */


#ifndef __OutputWindow_FWD_DEFINED__
#define __OutputWindow_FWD_DEFINED__
typedef interface OutputWindow OutputWindow;
#endif 	/* __OutputWindow_FWD_DEFINED__ */


#ifndef __OutputWindowPanes_FWD_DEFINED__
#define __OutputWindowPanes_FWD_DEFINED__
typedef interface OutputWindowPanes OutputWindowPanes;
#endif 	/* __OutputWindowPanes_FWD_DEFINED__ */


#ifndef __OutputWindowPane_FWD_DEFINED__
#define __OutputWindowPane_FWD_DEFINED__
typedef interface OutputWindowPane OutputWindowPane;
#endif 	/* __OutputWindowPane_FWD_DEFINED__ */


#ifndef __IExtensibleObjectSite_FWD_DEFINED__
#define __IExtensibleObjectSite_FWD_DEFINED__
typedef interface IExtensibleObjectSite IExtensibleObjectSite;
#endif 	/* __IExtensibleObjectSite_FWD_DEFINED__ */


#ifndef __Document_FWD_DEFINED__
#define __Document_FWD_DEFINED__
typedef interface Document Document;
#endif 	/* __Document_FWD_DEFINED__ */


#ifndef __Documents_FWD_DEFINED__
#define __Documents_FWD_DEFINED__
typedef interface Documents Documents;
#endif 	/* __Documents_FWD_DEFINED__ */


#ifndef __WindowConfigurations_FWD_DEFINED__
#define __WindowConfigurations_FWD_DEFINED__
typedef interface WindowConfigurations WindowConfigurations;
#endif 	/* __WindowConfigurations_FWD_DEFINED__ */


#ifndef __WindowConfiguration_FWD_DEFINED__
#define __WindowConfiguration_FWD_DEFINED__
typedef interface WindowConfiguration WindowConfiguration;
#endif 	/* __WindowConfiguration_FWD_DEFINED__ */


#ifndef __Command_FWD_DEFINED__
#define __Command_FWD_DEFINED__
typedef interface Command Command;
#endif 	/* __Command_FWD_DEFINED__ */


#ifndef __Globals_FWD_DEFINED__
#define __Globals_FWD_DEFINED__
typedef interface Globals Globals;
#endif 	/* __Globals_FWD_DEFINED__ */


#ifndef __StatusBar_FWD_DEFINED__
#define __StatusBar_FWD_DEFINED__
typedef interface StatusBar StatusBar;
#endif 	/* __StatusBar_FWD_DEFINED__ */


#ifndef __Find_FWD_DEFINED__
#define __Find_FWD_DEFINED__
typedef interface Find Find;
#endif 	/* __Find_FWD_DEFINED__ */


#ifndef __ItemOperations_FWD_DEFINED__
#define __ItemOperations_FWD_DEFINED__
typedef interface ItemOperations ItemOperations;
#endif 	/* __ItemOperations_FWD_DEFINED__ */


#ifndef __IVsProfferCommands_FWD_DEFINED__
#define __IVsProfferCommands_FWD_DEFINED__
typedef interface IVsProfferCommands IVsProfferCommands;
#endif 	/* __IVsProfferCommands_FWD_DEFINED__ */


#ifndef __ObjectExtenders_FWD_DEFINED__
#define __ObjectExtenders_FWD_DEFINED__
typedef interface ObjectExtenders ObjectExtenders;
#endif 	/* __ObjectExtenders_FWD_DEFINED__ */


#ifndef __IExtenderSite_FWD_DEFINED__
#define __IExtenderSite_FWD_DEFINED__
typedef interface IExtenderSite IExtenderSite;
#endif 	/* __IExtenderSite_FWD_DEFINED__ */


#ifndef __IExtenderProvider_FWD_DEFINED__
#define __IExtenderProvider_FWD_DEFINED__
typedef interface IExtenderProvider IExtenderProvider;
#endif 	/* __IExtenderProvider_FWD_DEFINED__ */


#ifndef __IExtenderProviderUnk_FWD_DEFINED__
#define __IExtenderProviderUnk_FWD_DEFINED__
typedef interface IExtenderProviderUnk IExtenderProviderUnk;
#endif 	/* __IExtenderProviderUnk_FWD_DEFINED__ */


#ifndef __IFilterProperties_FWD_DEFINED__
#define __IFilterProperties_FWD_DEFINED__
typedef interface IFilterProperties IFilterProperties;
#endif 	/* __IFilterProperties_FWD_DEFINED__ */


#ifndef ___dispDTEEvents_FWD_DEFINED__
#define ___dispDTEEvents_FWD_DEFINED__
typedef interface _dispDTEEvents _dispDTEEvents;
#endif 	/* ___dispDTEEvents_FWD_DEFINED__ */


#ifndef __BuildDependencies_FWD_DEFINED__
#define __BuildDependencies_FWD_DEFINED__
typedef interface BuildDependencies BuildDependencies;
#endif 	/* __BuildDependencies_FWD_DEFINED__ */


#ifndef __BuildDependency_FWD_DEFINED__
#define __BuildDependency_FWD_DEFINED__
typedef interface BuildDependency BuildDependency;
#endif 	/* __BuildDependency_FWD_DEFINED__ */


#ifndef __SolutionConfigurations_FWD_DEFINED__
#define __SolutionConfigurations_FWD_DEFINED__
typedef interface SolutionConfigurations SolutionConfigurations;
#endif 	/* __SolutionConfigurations_FWD_DEFINED__ */


#ifndef __SolutionConfiguration_FWD_DEFINED__
#define __SolutionConfiguration_FWD_DEFINED__
typedef interface SolutionConfiguration SolutionConfiguration;
#endif 	/* __SolutionConfiguration_FWD_DEFINED__ */


#ifndef __SolutionContext_FWD_DEFINED__
#define __SolutionContext_FWD_DEFINED__
typedef interface SolutionContext SolutionContext;
#endif 	/* __SolutionContext_FWD_DEFINED__ */


#ifndef __SolutionBuild_FWD_DEFINED__
#define __SolutionBuild_FWD_DEFINED__
typedef interface SolutionBuild SolutionBuild;
#endif 	/* __SolutionBuild_FWD_DEFINED__ */


#ifndef __UIHierarchyItem_FWD_DEFINED__
#define __UIHierarchyItem_FWD_DEFINED__
typedef interface UIHierarchyItem UIHierarchyItem;
#endif 	/* __UIHierarchyItem_FWD_DEFINED__ */


#ifndef __UIHierarchyItems_FWD_DEFINED__
#define __UIHierarchyItems_FWD_DEFINED__
typedef interface UIHierarchyItems UIHierarchyItems;
#endif 	/* __UIHierarchyItems_FWD_DEFINED__ */


#ifndef __UIHierarchy_FWD_DEFINED__
#define __UIHierarchy_FWD_DEFINED__
typedef interface UIHierarchy UIHierarchy;
#endif 	/* __UIHierarchy_FWD_DEFINED__ */


#ifndef __UndoContext_FWD_DEFINED__
#define __UndoContext_FWD_DEFINED__
typedef interface UndoContext UndoContext;
#endif 	/* __UndoContext_FWD_DEFINED__ */


#ifndef __Configuration_FWD_DEFINED__
#define __Configuration_FWD_DEFINED__
typedef interface Configuration Configuration;
#endif 	/* __Configuration_FWD_DEFINED__ */


#ifndef __SolutionContexts_FWD_DEFINED__
#define __SolutionContexts_FWD_DEFINED__
typedef interface SolutionContexts SolutionContexts;
#endif 	/* __SolutionContexts_FWD_DEFINED__ */


#ifndef __Configurations_FWD_DEFINED__
#define __Configurations_FWD_DEFINED__
typedef interface Configurations Configurations;
#endif 	/* __Configurations_FWD_DEFINED__ */


#ifndef __ConfigurationManager_FWD_DEFINED__
#define __ConfigurationManager_FWD_DEFINED__
typedef interface ConfigurationManager ConfigurationManager;
#endif 	/* __ConfigurationManager_FWD_DEFINED__ */


#ifndef __Macros_FWD_DEFINED__
#define __Macros_FWD_DEFINED__
typedef interface Macros Macros;
#endif 	/* __Macros_FWD_DEFINED__ */


#ifndef __OutputGroups_FWD_DEFINED__
#define __OutputGroups_FWD_DEFINED__
typedef interface OutputGroups OutputGroups;
#endif 	/* __OutputGroups_FWD_DEFINED__ */


#ifndef __OutputGroup_FWD_DEFINED__
#define __OutputGroup_FWD_DEFINED__
typedef interface OutputGroup OutputGroup;
#endif 	/* __OutputGroup_FWD_DEFINED__ */


#ifndef __ContextAttributes_FWD_DEFINED__
#define __ContextAttributes_FWD_DEFINED__
typedef interface ContextAttributes ContextAttributes;
#endif 	/* __ContextAttributes_FWD_DEFINED__ */


#ifndef __SourceControl_FWD_DEFINED__
#define __SourceControl_FWD_DEFINED__
typedef interface SourceControl SourceControl;
#endif 	/* __SourceControl_FWD_DEFINED__ */


#ifndef __TextPoint_FWD_DEFINED__
#define __TextPoint_FWD_DEFINED__
typedef interface TextPoint TextPoint;
#endif 	/* __TextPoint_FWD_DEFINED__ */


#ifndef __EditPoint_FWD_DEFINED__
#define __EditPoint_FWD_DEFINED__
typedef interface EditPoint EditPoint;
#endif 	/* __EditPoint_FWD_DEFINED__ */


#ifndef __TextSelection_FWD_DEFINED__
#define __TextSelection_FWD_DEFINED__
typedef interface TextSelection TextSelection;
#endif 	/* __TextSelection_FWD_DEFINED__ */


#ifndef __TextRanges_FWD_DEFINED__
#define __TextRanges_FWD_DEFINED__
typedef interface TextRanges TextRanges;
#endif 	/* __TextRanges_FWD_DEFINED__ */


#ifndef __TextRange_FWD_DEFINED__
#define __TextRange_FWD_DEFINED__
typedef interface TextRange TextRange;
#endif 	/* __TextRange_FWD_DEFINED__ */


#ifndef __TextDocument_FWD_DEFINED__
#define __TextDocument_FWD_DEFINED__
typedef interface TextDocument TextDocument;
#endif 	/* __TextDocument_FWD_DEFINED__ */


#ifndef __VirtualPoint_FWD_DEFINED__
#define __VirtualPoint_FWD_DEFINED__
typedef interface VirtualPoint VirtualPoint;
#endif 	/* __VirtualPoint_FWD_DEFINED__ */


#ifndef __TextPane_FWD_DEFINED__
#define __TextPane_FWD_DEFINED__
typedef interface TextPane TextPane;
#endif 	/* __TextPane_FWD_DEFINED__ */


#ifndef __TextWindow_FWD_DEFINED__
#define __TextWindow_FWD_DEFINED__
typedef interface TextWindow TextWindow;
#endif 	/* __TextWindow_FWD_DEFINED__ */


#ifndef __TextPanes_FWD_DEFINED__
#define __TextPanes_FWD_DEFINED__
typedef interface TextPanes TextPanes;
#endif 	/* __TextPanes_FWD_DEFINED__ */


#ifndef __TextEditor_FWD_DEFINED__
#define __TextEditor_FWD_DEFINED__
typedef interface TextEditor TextEditor;
#endif 	/* __TextEditor_FWD_DEFINED__ */


#ifndef __CodeModel_FWD_DEFINED__
#define __CodeModel_FWD_DEFINED__
typedef interface CodeModel CodeModel;
#endif 	/* __CodeModel_FWD_DEFINED__ */


#ifndef __CodeElements_FWD_DEFINED__
#define __CodeElements_FWD_DEFINED__
typedef interface CodeElements CodeElements;
#endif 	/* __CodeElements_FWD_DEFINED__ */


#ifndef __CodeElement_FWD_DEFINED__
#define __CodeElement_FWD_DEFINED__
typedef interface CodeElement CodeElement;
#endif 	/* __CodeElement_FWD_DEFINED__ */


#ifndef __CodeType_FWD_DEFINED__
#define __CodeType_FWD_DEFINED__
typedef interface CodeType CodeType;
#endif 	/* __CodeType_FWD_DEFINED__ */


#ifndef __CodeNamespace_FWD_DEFINED__
#define __CodeNamespace_FWD_DEFINED__
typedef interface CodeNamespace CodeNamespace;
#endif 	/* __CodeNamespace_FWD_DEFINED__ */


#ifndef __CodeFunction_FWD_DEFINED__
#define __CodeFunction_FWD_DEFINED__
typedef interface CodeFunction CodeFunction;
#endif 	/* __CodeFunction_FWD_DEFINED__ */


#ifndef __CodeVariable_FWD_DEFINED__
#define __CodeVariable_FWD_DEFINED__
typedef interface CodeVariable CodeVariable;
#endif 	/* __CodeVariable_FWD_DEFINED__ */


#ifndef __CodeProperty_FWD_DEFINED__
#define __CodeProperty_FWD_DEFINED__
typedef interface CodeProperty CodeProperty;
#endif 	/* __CodeProperty_FWD_DEFINED__ */


#ifndef __CodeParameter_FWD_DEFINED__
#define __CodeParameter_FWD_DEFINED__
typedef interface CodeParameter CodeParameter;
#endif 	/* __CodeParameter_FWD_DEFINED__ */


#ifndef __CodeAttribute_FWD_DEFINED__
#define __CodeAttribute_FWD_DEFINED__
typedef interface CodeAttribute CodeAttribute;
#endif 	/* __CodeAttribute_FWD_DEFINED__ */


#ifndef __CodeInterface_FWD_DEFINED__
#define __CodeInterface_FWD_DEFINED__
typedef interface CodeInterface CodeInterface;
#endif 	/* __CodeInterface_FWD_DEFINED__ */


#ifndef __CodeStruct_FWD_DEFINED__
#define __CodeStruct_FWD_DEFINED__
typedef interface CodeStruct CodeStruct;
#endif 	/* __CodeStruct_FWD_DEFINED__ */


#ifndef __CodeEnum_FWD_DEFINED__
#define __CodeEnum_FWD_DEFINED__
typedef interface CodeEnum CodeEnum;
#endif 	/* __CodeEnum_FWD_DEFINED__ */


#ifndef __CodeDelegate_FWD_DEFINED__
#define __CodeDelegate_FWD_DEFINED__
typedef interface CodeDelegate CodeDelegate;
#endif 	/* __CodeDelegate_FWD_DEFINED__ */


#ifndef __CodeTypeRef_FWD_DEFINED__
#define __CodeTypeRef_FWD_DEFINED__
typedef interface CodeTypeRef CodeTypeRef;
#endif 	/* __CodeTypeRef_FWD_DEFINED__ */


#ifndef __CodeClass_FWD_DEFINED__
#define __CodeClass_FWD_DEFINED__
typedef interface CodeClass CodeClass;
#endif 	/* __CodeClass_FWD_DEFINED__ */


#ifndef __FileCodeModel_FWD_DEFINED__
#define __FileCodeModel_FWD_DEFINED__
typedef interface FileCodeModel FileCodeModel;
#endif 	/* __FileCodeModel_FWD_DEFINED__ */


#ifndef __Breakpoint_FWD_DEFINED__
#define __Breakpoint_FWD_DEFINED__
typedef interface Breakpoint Breakpoint;
#endif 	/* __Breakpoint_FWD_DEFINED__ */


#ifndef __Breakpoints_FWD_DEFINED__
#define __Breakpoints_FWD_DEFINED__
typedef interface Breakpoints Breakpoints;
#endif 	/* __Breakpoints_FWD_DEFINED__ */


#ifndef __Debugger_FWD_DEFINED__
#define __Debugger_FWD_DEFINED__
typedef interface Debugger Debugger;
#endif 	/* __Debugger_FWD_DEFINED__ */


#ifndef __Expression_FWD_DEFINED__
#define __Expression_FWD_DEFINED__
typedef interface Expression Expression;
#endif 	/* __Expression_FWD_DEFINED__ */


#ifndef __Expressions_FWD_DEFINED__
#define __Expressions_FWD_DEFINED__
typedef interface Expressions Expressions;
#endif 	/* __Expressions_FWD_DEFINED__ */


#ifndef __Language_FWD_DEFINED__
#define __Language_FWD_DEFINED__
typedef interface Language Language;
#endif 	/* __Language_FWD_DEFINED__ */


#ifndef __Languages_FWD_DEFINED__
#define __Languages_FWD_DEFINED__
typedef interface Languages Languages;
#endif 	/* __Languages_FWD_DEFINED__ */


#ifndef __Process_FWD_DEFINED__
#define __Process_FWD_DEFINED__
typedef interface Process Process;
#endif 	/* __Process_FWD_DEFINED__ */


#ifndef __Processes_FWD_DEFINED__
#define __Processes_FWD_DEFINED__
typedef interface Processes Processes;
#endif 	/* __Processes_FWD_DEFINED__ */


#ifndef __Program_FWD_DEFINED__
#define __Program_FWD_DEFINED__
typedef interface Program Program;
#endif 	/* __Program_FWD_DEFINED__ */


#ifndef __Programs_FWD_DEFINED__
#define __Programs_FWD_DEFINED__
typedef interface Programs Programs;
#endif 	/* __Programs_FWD_DEFINED__ */


#ifndef __StackFrame_FWD_DEFINED__
#define __StackFrame_FWD_DEFINED__
typedef interface StackFrame StackFrame;
#endif 	/* __StackFrame_FWD_DEFINED__ */


#ifndef __StackFrames_FWD_DEFINED__
#define __StackFrames_FWD_DEFINED__
typedef interface StackFrames StackFrames;
#endif 	/* __StackFrames_FWD_DEFINED__ */


#ifndef __Thread_FWD_DEFINED__
#define __Thread_FWD_DEFINED__
typedef interface Thread Thread;
#endif 	/* __Thread_FWD_DEFINED__ */


#ifndef __Threads_FWD_DEFINED__
#define __Threads_FWD_DEFINED__
typedef interface Threads Threads;
#endif 	/* __Threads_FWD_DEFINED__ */


#ifndef ___dispDebuggerEvents_FWD_DEFINED__
#define ___dispDebuggerEvents_FWD_DEFINED__
typedef interface _dispDebuggerEvents _dispDebuggerEvents;
#endif 	/* ___dispDebuggerEvents_FWD_DEFINED__ */


#ifndef ___DebuggerEventsRoot_FWD_DEFINED__
#define ___DebuggerEventsRoot_FWD_DEFINED__
typedef interface _DebuggerEventsRoot _DebuggerEventsRoot;
#endif 	/* ___DebuggerEventsRoot_FWD_DEFINED__ */


#ifndef ___DebuggerEvents_FWD_DEFINED__
#define ___DebuggerEvents_FWD_DEFINED__
typedef interface _DebuggerEvents _DebuggerEvents;
#endif 	/* ___DebuggerEvents_FWD_DEFINED__ */


#ifndef __DebuggerEvents_FWD_DEFINED__
#define __DebuggerEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class DebuggerEvents DebuggerEvents;
#else
typedef struct DebuggerEvents DebuggerEvents;
#endif /* __cplusplus */

#endif 	/* __DebuggerEvents_FWD_DEFINED__ */


#ifndef __IDTWizard_FWD_DEFINED__
#define __IDTWizard_FWD_DEFINED__
typedef interface IDTWizard IDTWizard;
#endif 	/* __IDTWizard_FWD_DEFINED__ */


#ifndef __IVsExtensibility_FWD_DEFINED__
#define __IVsExtensibility_FWD_DEFINED__
typedef interface IVsExtensibility IVsExtensibility;
#endif 	/* __IVsExtensibility_FWD_DEFINED__ */


#ifndef __IVsGlobalsCallback_FWD_DEFINED__
#define __IVsGlobalsCallback_FWD_DEFINED__
typedef interface IVsGlobalsCallback IVsGlobalsCallback;
#endif 	/* __IVsGlobalsCallback_FWD_DEFINED__ */


#ifndef __IVsGlobals_FWD_DEFINED__
#define __IVsGlobals_FWD_DEFINED__
typedef interface IVsGlobals IVsGlobals;
#endif 	/* __IVsGlobals_FWD_DEFINED__ */


#ifndef __IDTCommandTarget_FWD_DEFINED__
#define __IDTCommandTarget_FWD_DEFINED__
typedef interface IDTCommandTarget IDTCommandTarget;
#endif 	/* __IDTCommandTarget_FWD_DEFINED__ */


#ifndef __CommandWindow_FWD_DEFINED__
#define __CommandWindow_FWD_DEFINED__
typedef interface CommandWindow CommandWindow;
#endif 	/* __CommandWindow_FWD_DEFINED__ */


#ifndef __DTE_FWD_DEFINED__
#define __DTE_FWD_DEFINED__

#ifdef __cplusplus
typedef class DTE DTE;
#else
typedef struct DTE DTE;
#endif /* __cplusplus */

#endif 	/* __DTE_FWD_DEFINED__ */


#ifndef __Solution_FWD_DEFINED__
#define __Solution_FWD_DEFINED__

#ifdef __cplusplus
typedef class Solution Solution;
#else
typedef struct Solution Solution;
#endif /* __cplusplus */

#endif 	/* __Solution_FWD_DEFINED__ */


#ifndef __DTEEvents_FWD_DEFINED__
#define __DTEEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class DTEEvents DTEEvents;
#else
typedef struct DTEEvents DTEEvents;
#endif /* __cplusplus */

#endif 	/* __DTEEvents_FWD_DEFINED__ */


#ifndef ___DTEEvents_FWD_DEFINED__
#define ___DTEEvents_FWD_DEFINED__
typedef interface _DTEEvents _DTEEvents;
#endif 	/* ___DTEEvents_FWD_DEFINED__ */


#ifndef ___ProjectItemsEvents_FWD_DEFINED__
#define ___ProjectItemsEvents_FWD_DEFINED__
typedef interface _ProjectItemsEvents _ProjectItemsEvents;
#endif 	/* ___ProjectItemsEvents_FWD_DEFINED__ */


#ifndef ___dispProjectItemsEvents_FWD_DEFINED__
#define ___dispProjectItemsEvents_FWD_DEFINED__
typedef interface _dispProjectItemsEvents _dispProjectItemsEvents;
#endif 	/* ___dispProjectItemsEvents_FWD_DEFINED__ */


#ifndef __ProjectItemsEvents_FWD_DEFINED__
#define __ProjectItemsEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProjectItemsEvents ProjectItemsEvents;
#else
typedef struct ProjectItemsEvents ProjectItemsEvents;
#endif /* __cplusplus */

#endif 	/* __ProjectItemsEvents_FWD_DEFINED__ */


#ifndef ___ProjectsEvents_FWD_DEFINED__
#define ___ProjectsEvents_FWD_DEFINED__
typedef interface _ProjectsEvents _ProjectsEvents;
#endif 	/* ___ProjectsEvents_FWD_DEFINED__ */


#ifndef ___dispProjectsEvents_FWD_DEFINED__
#define ___dispProjectsEvents_FWD_DEFINED__
typedef interface _dispProjectsEvents _dispProjectsEvents;
#endif 	/* ___dispProjectsEvents_FWD_DEFINED__ */


#ifndef __ProjectsEvents_FWD_DEFINED__
#define __ProjectsEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProjectsEvents ProjectsEvents;
#else
typedef struct ProjectsEvents ProjectsEvents;
#endif /* __cplusplus */

#endif 	/* __ProjectsEvents_FWD_DEFINED__ */


#ifndef ___MiscSlnFilesEventsRoot_FWD_DEFINED__
#define ___MiscSlnFilesEventsRoot_FWD_DEFINED__
typedef interface _MiscSlnFilesEventsRoot _MiscSlnFilesEventsRoot;
#endif 	/* ___MiscSlnFilesEventsRoot_FWD_DEFINED__ */


#ifndef ___CommandBarControlEvents_FWD_DEFINED__
#define ___CommandBarControlEvents_FWD_DEFINED__
typedef interface _CommandBarControlEvents _CommandBarControlEvents;
#endif 	/* ___CommandBarControlEvents_FWD_DEFINED__ */


#ifndef ___dispCommandBarControlEvents_FWD_DEFINED__
#define ___dispCommandBarControlEvents_FWD_DEFINED__
typedef interface _dispCommandBarControlEvents _dispCommandBarControlEvents;
#endif 	/* ___dispCommandBarControlEvents_FWD_DEFINED__ */


#ifndef __CommandBarEvents_FWD_DEFINED__
#define __CommandBarEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class CommandBarEvents CommandBarEvents;
#else
typedef struct CommandBarEvents CommandBarEvents;
#endif /* __cplusplus */

#endif 	/* __CommandBarEvents_FWD_DEFINED__ */


#ifndef ___CommandEvents_FWD_DEFINED__
#define ___CommandEvents_FWD_DEFINED__
typedef interface _CommandEvents _CommandEvents;
#endif 	/* ___CommandEvents_FWD_DEFINED__ */


#ifndef ___dispCommandEvents_FWD_DEFINED__
#define ___dispCommandEvents_FWD_DEFINED__
typedef interface _dispCommandEvents _dispCommandEvents;
#endif 	/* ___dispCommandEvents_FWD_DEFINED__ */


#ifndef __CommandEvents_FWD_DEFINED__
#define __CommandEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class CommandEvents CommandEvents;
#else
typedef struct CommandEvents CommandEvents;
#endif /* __cplusplus */

#endif 	/* __CommandEvents_FWD_DEFINED__ */


#ifndef ___SelectionEvents_FWD_DEFINED__
#define ___SelectionEvents_FWD_DEFINED__
typedef interface _SelectionEvents _SelectionEvents;
#endif 	/* ___SelectionEvents_FWD_DEFINED__ */


#ifndef ___dispSelectionEvents_FWD_DEFINED__
#define ___dispSelectionEvents_FWD_DEFINED__
typedef interface _dispSelectionEvents _dispSelectionEvents;
#endif 	/* ___dispSelectionEvents_FWD_DEFINED__ */


#ifndef __SelectionEvents_FWD_DEFINED__
#define __SelectionEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class SelectionEvents SelectionEvents;
#else
typedef struct SelectionEvents SelectionEvents;
#endif /* __cplusplus */

#endif 	/* __SelectionEvents_FWD_DEFINED__ */


#ifndef ___BuildEvents_FWD_DEFINED__
#define ___BuildEvents_FWD_DEFINED__
typedef interface _BuildEvents _BuildEvents;
#endif 	/* ___BuildEvents_FWD_DEFINED__ */


#ifndef ___dispBuildEvents_FWD_DEFINED__
#define ___dispBuildEvents_FWD_DEFINED__
typedef interface _dispBuildEvents _dispBuildEvents;
#endif 	/* ___dispBuildEvents_FWD_DEFINED__ */


#ifndef __BuildEvents_FWD_DEFINED__
#define __BuildEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class BuildEvents BuildEvents;
#else
typedef struct BuildEvents BuildEvents;
#endif /* __cplusplus */

#endif 	/* __BuildEvents_FWD_DEFINED__ */


#ifndef ___SolutionEvents_FWD_DEFINED__
#define ___SolutionEvents_FWD_DEFINED__
typedef interface _SolutionEvents _SolutionEvents;
#endif 	/* ___SolutionEvents_FWD_DEFINED__ */


#ifndef ___dispSolutionEvents_FWD_DEFINED__
#define ___dispSolutionEvents_FWD_DEFINED__
typedef interface _dispSolutionEvents _dispSolutionEvents;
#endif 	/* ___dispSolutionEvents_FWD_DEFINED__ */


#ifndef __SolutionEvents_FWD_DEFINED__
#define __SolutionEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class SolutionEvents SolutionEvents;
#else
typedef struct SolutionEvents SolutionEvents;
#endif /* __cplusplus */

#endif 	/* __SolutionEvents_FWD_DEFINED__ */


#ifndef __ContextAttribute_FWD_DEFINED__
#define __ContextAttribute_FWD_DEFINED__
typedef interface ContextAttribute ContextAttribute;
#endif 	/* __ContextAttribute_FWD_DEFINED__ */


#ifndef ___DocumentEventsRoot_FWD_DEFINED__
#define ___DocumentEventsRoot_FWD_DEFINED__
typedef interface _DocumentEventsRoot _DocumentEventsRoot;
#endif 	/* ___DocumentEventsRoot_FWD_DEFINED__ */


#ifndef ___DocumentEvents_FWD_DEFINED__
#define ___DocumentEvents_FWD_DEFINED__
typedef interface _DocumentEvents _DocumentEvents;
#endif 	/* ___DocumentEvents_FWD_DEFINED__ */


#ifndef ___dispDocumentEvents_FWD_DEFINED__
#define ___dispDocumentEvents_FWD_DEFINED__
typedef interface _dispDocumentEvents _dispDocumentEvents;
#endif 	/* ___dispDocumentEvents_FWD_DEFINED__ */


#ifndef __DocumentEvents_FWD_DEFINED__
#define __DocumentEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class DocumentEvents DocumentEvents;
#else
typedef struct DocumentEvents DocumentEvents;
#endif /* __cplusplus */

#endif 	/* __DocumentEvents_FWD_DEFINED__ */


#ifndef ___TextEditorEventsRoot_FWD_DEFINED__
#define ___TextEditorEventsRoot_FWD_DEFINED__
typedef interface _TextEditorEventsRoot _TextEditorEventsRoot;
#endif 	/* ___TextEditorEventsRoot_FWD_DEFINED__ */


#ifndef ___TextEditorEvents_FWD_DEFINED__
#define ___TextEditorEvents_FWD_DEFINED__
typedef interface _TextEditorEvents _TextEditorEvents;
#endif 	/* ___TextEditorEvents_FWD_DEFINED__ */


#ifndef ___dispTextEditorEvents_FWD_DEFINED__
#define ___dispTextEditorEvents_FWD_DEFINED__
typedef interface _dispTextEditorEvents _dispTextEditorEvents;
#endif 	/* ___dispTextEditorEvents_FWD_DEFINED__ */


#ifndef __TextEditorEvents_FWD_DEFINED__
#define __TextEditorEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class TextEditorEvents TextEditorEvents;
#else
typedef struct TextEditorEvents TextEditorEvents;
#endif /* __cplusplus */

#endif 	/* __TextEditorEvents_FWD_DEFINED__ */


#ifndef ___WindowEventsRoot_FWD_DEFINED__
#define ___WindowEventsRoot_FWD_DEFINED__
typedef interface _WindowEventsRoot _WindowEventsRoot;
#endif 	/* ___WindowEventsRoot_FWD_DEFINED__ */


#ifndef ___WindowEvents_FWD_DEFINED__
#define ___WindowEvents_FWD_DEFINED__
typedef interface _WindowEvents _WindowEvents;
#endif 	/* ___WindowEvents_FWD_DEFINED__ */


#ifndef ___dispWindowEvents_FWD_DEFINED__
#define ___dispWindowEvents_FWD_DEFINED__
typedef interface _dispWindowEvents _dispWindowEvents;
#endif 	/* ___dispWindowEvents_FWD_DEFINED__ */


#ifndef __WindowEvents_FWD_DEFINED__
#define __WindowEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class WindowEvents WindowEvents;
#else
typedef struct WindowEvents WindowEvents;
#endif /* __cplusplus */

#endif 	/* __WindowEvents_FWD_DEFINED__ */


#ifndef ___OutputWindowEventsRoot_FWD_DEFINED__
#define ___OutputWindowEventsRoot_FWD_DEFINED__
typedef interface _OutputWindowEventsRoot _OutputWindowEventsRoot;
#endif 	/* ___OutputWindowEventsRoot_FWD_DEFINED__ */


#ifndef ___OutputWindowEvents_FWD_DEFINED__
#define ___OutputWindowEvents_FWD_DEFINED__
typedef interface _OutputWindowEvents _OutputWindowEvents;
#endif 	/* ___OutputWindowEvents_FWD_DEFINED__ */


#ifndef ___dispOutputWindowEvents_FWD_DEFINED__
#define ___dispOutputWindowEvents_FWD_DEFINED__
typedef interface _dispOutputWindowEvents _dispOutputWindowEvents;
#endif 	/* ___dispOutputWindowEvents_FWD_DEFINED__ */


#ifndef __OutputWindowEvents_FWD_DEFINED__
#define __OutputWindowEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class OutputWindowEvents OutputWindowEvents;
#else
typedef struct OutputWindowEvents OutputWindowEvents;
#endif /* __cplusplus */

#endif 	/* __OutputWindowEvents_FWD_DEFINED__ */


#ifndef ___TaskListEventsRoot_FWD_DEFINED__
#define ___TaskListEventsRoot_FWD_DEFINED__
typedef interface _TaskListEventsRoot _TaskListEventsRoot;
#endif 	/* ___TaskListEventsRoot_FWD_DEFINED__ */


#ifndef ___TaskListEvents_FWD_DEFINED__
#define ___TaskListEvents_FWD_DEFINED__
typedef interface _TaskListEvents _TaskListEvents;
#endif 	/* ___TaskListEvents_FWD_DEFINED__ */


#ifndef ___dispTaskListEvents_FWD_DEFINED__
#define ___dispTaskListEvents_FWD_DEFINED__
typedef interface _dispTaskListEvents _dispTaskListEvents;
#endif 	/* ___dispTaskListEvents_FWD_DEFINED__ */


#ifndef __TaskListEvents_FWD_DEFINED__
#define __TaskListEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class TaskListEvents TaskListEvents;
#else
typedef struct TaskListEvents TaskListEvents;
#endif /* __cplusplus */

#endif 	/* __TaskListEvents_FWD_DEFINED__ */


#ifndef __IDTToolsOptionsPage_FWD_DEFINED__
#define __IDTToolsOptionsPage_FWD_DEFINED__
typedef interface IDTToolsOptionsPage IDTToolsOptionsPage;
#endif 	/* __IDTToolsOptionsPage_FWD_DEFINED__ */


#ifndef ___EnvironmentWebBrowser_FWD_DEFINED__
#define ___EnvironmentWebBrowser_FWD_DEFINED__
typedef interface _EnvironmentWebBrowser _EnvironmentWebBrowser;
#endif 	/* ___EnvironmentWebBrowser_FWD_DEFINED__ */


#ifndef ___EnvironmentHelp_FWD_DEFINED__
#define ___EnvironmentHelp_FWD_DEFINED__
typedef interface _EnvironmentHelp _EnvironmentHelp;
#endif 	/* ___EnvironmentHelp_FWD_DEFINED__ */


#ifndef __ColorableItems_FWD_DEFINED__
#define __ColorableItems_FWD_DEFINED__
typedef interface ColorableItems ColorableItems;
#endif 	/* __ColorableItems_FWD_DEFINED__ */


#ifndef __FontsAndColorsItems_FWD_DEFINED__
#define __FontsAndColorsItems_FWD_DEFINED__
typedef interface FontsAndColorsItems FontsAndColorsItems;
#endif 	/* __FontsAndColorsItems_FWD_DEFINED__ */


#ifndef ___FontsAndColors_FWD_DEFINED__
#define ___FontsAndColors_FWD_DEFINED__
typedef interface _FontsAndColors _FontsAndColors;
#endif 	/* ___FontsAndColors_FWD_DEFINED__ */


#ifndef ___EnvironmentGeneral_FWD_DEFINED__
#define ___EnvironmentGeneral_FWD_DEFINED__
typedef interface _EnvironmentGeneral _EnvironmentGeneral;
#endif 	/* ___EnvironmentGeneral_FWD_DEFINED__ */


#ifndef ___EnvironmentFontsAndColors_FWD_DEFINED__
#define ___EnvironmentFontsAndColors_FWD_DEFINED__
typedef interface _EnvironmentFontsAndColors _EnvironmentFontsAndColors;
#endif 	/* ___EnvironmentFontsAndColors_FWD_DEFINED__ */


#ifndef ___EnvironmentProjectsAndSolution_FWD_DEFINED__
#define ___EnvironmentProjectsAndSolution_FWD_DEFINED__
typedef interface _EnvironmentProjectsAndSolution _EnvironmentProjectsAndSolution;
#endif 	/* ___EnvironmentProjectsAndSolution_FWD_DEFINED__ */


#ifndef ___EnvironmentDocuments_FWD_DEFINED__
#define ___EnvironmentDocuments_FWD_DEFINED__
typedef interface _EnvironmentDocuments _EnvironmentDocuments;
#endif 	/* ___EnvironmentDocuments_FWD_DEFINED__ */


#ifndef ___EnvironmentTaskList_FWD_DEFINED__
#define ___EnvironmentTaskList_FWD_DEFINED__
typedef interface _EnvironmentTaskList _EnvironmentTaskList;
#endif 	/* ___EnvironmentTaskList_FWD_DEFINED__ */


#ifndef ___EnvironmentKeyboard_FWD_DEFINED__
#define ___EnvironmentKeyboard_FWD_DEFINED__
typedef interface _EnvironmentKeyboard _EnvironmentKeyboard;
#endif 	/* ___EnvironmentKeyboard_FWD_DEFINED__ */


#ifndef __IExtensibleObject_FWD_DEFINED__
#define __IExtensibleObject_FWD_DEFINED__
typedef interface IExtensibleObject IExtensibleObject;
#endif 	/* __IExtensibleObject_FWD_DEFINED__ */


#ifndef ___FindEvents_FWD_DEFINED__
#define ___FindEvents_FWD_DEFINED__
typedef interface _FindEvents _FindEvents;
#endif 	/* ___FindEvents_FWD_DEFINED__ */


#ifndef ___dispFindEvents_FWD_DEFINED__
#define ___dispFindEvents_FWD_DEFINED__
typedef interface _dispFindEvents _dispFindEvents;
#endif 	/* ___dispFindEvents_FWD_DEFINED__ */


#ifndef __FindEvents_FWD_DEFINED__
#define __FindEvents_FWD_DEFINED__

#ifdef __cplusplus
typedef class FindEvents FindEvents;
#else
typedef struct FindEvents FindEvents;
#endif /* __cplusplus */

#endif 	/* __FindEvents_FWD_DEFINED__ */


#ifndef __IVsTextEditGeneral_FWD_DEFINED__
#define __IVsTextEditGeneral_FWD_DEFINED__
typedef interface IVsTextEditGeneral IVsTextEditGeneral;
#endif 	/* __IVsTextEditGeneral_FWD_DEFINED__ */


#ifndef __IVsTextEditPerLanguage_FWD_DEFINED__
#define __IVsTextEditPerLanguage_FWD_DEFINED__
typedef interface IVsTextEditPerLanguage IVsTextEditPerLanguage;
#endif 	/* __IVsTextEditPerLanguage_FWD_DEFINED__ */


#ifndef __IVsTextEditFonts_FWD_DEFINED__
#define __IVsTextEditFonts_FWD_DEFINED__
typedef interface IVsTextEditFonts IVsTextEditFonts;
#endif 	/* __IVsTextEditFonts_FWD_DEFINED__ */


#ifndef __HTMLWindow_FWD_DEFINED__
#define __HTMLWindow_FWD_DEFINED__
typedef interface HTMLWindow HTMLWindow;
#endif 	/* __HTMLWindow_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dte_0000 */
/* [local] */ 

#ifdef Delete
#define Delete_defined
#undef Delete
#endif
#ifdef ReplaceText
#define ReplaceText_defined
#undef ReplaceText
#endif
#define DTEIDL_REVISION 8
#define SID_SVsExtensibility IID_IVsExtensibility
//The following are defined for backward source compatibility
// They were needed when the transition from a coclass to interface
// object model was made.
#define IID__Projects IID_Projects
#define _Projects Projects
#define IID__Project IID_Project
#define _Project Project
#define IID__ProjectItems IID_ProjectItems
#define _ProjectItems ProjectItems
#define IID__ProjectItem IID_ProjectItem
#define _ProjectItem ProjectItem
#define IID__Commands IID_Commands
#define _Commands Commands
#define IID__AddIns IID_AddIns
#define _AddIns AddIns
#define IID__AddIn IID_AddIn
#define _AddIn AddIn
#define IID__Windows IID_Windows
#define _Windows Windows
#define IID__LinkedWindows IID_LinkedWindows
#define _LinkedWindows LinkedWindows
#define IID__SelectedItems IID_SelectedItems
#define _SelectedItems SelectedItems
#define IID__SelectedItem IID_SelectedItem
#define _SelectedItem SelectedItem
#define IID__Properties IID_Properties
#define _Properties Properties
#define IID__SelectionContainer IID_SelectionContainer
#define _SelectionContainer SelectionContainer
#define IID__TextBuffer IID_TextBuffer
#define _TextBuffer TextBuffer
#define SID_SVsProfferCommands IID_IVsProfferCommands
#ifndef __INDENTSTYLE__
#define __INDENTSTYLE__
typedef /* [uuid] */  DECLSPEC_UUID("BCCEBE05-D29C-11D2-AABD-00C04F688DDE") 
enum vsIndentStyle
    {	vsIndentStyleNone	= 0,
	vsIndentStyleDefault	= vsIndentStyleNone + 1,
	vsIndentStyleSmart	= vsIndentStyleDefault + 1
    } 	vsIndentStyle;

#endif // __INDENTSTYLE__
const GUID GUID_Addins = { 0x1e58696e, 0xc90f, 0x11D2, { 0xaa, 0xb2, 0x0, 0xc0, 0x4f, 0x68, 0x8d, 0xde } };
#define LIBID_DTE LIBID_EnvDTE


extern RPC_IF_HANDLE __MIDL_itf_dte_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dte_0000_v0_0_s_ifspec;


#ifndef __EnvDTE_LIBRARY_DEFINED__
#define __EnvDTE_LIBRARY_DEFINED__

/* library EnvDTE */
/* [version][helpstring][helpfile][uuid] */ 




















































































































typedef /* [uuid] */  DECLSPEC_UUID("494815FD-49D0-41e0-912F-D9C673DD068A") 
enum vsCMPart
    {	vsCMPartName	= 1,
	vsCMPartAttributes	= 2,
	vsCMPartHeader	= 4,
	vsCMPartWhole	= 8,
	vsCMPartBody	= 16,
	vsCMPartNavigate	= 32,
	vsCMPartAttributesWithDelimiter	= 68,
	vsCMPartBodyWithDelimiter	= 80,
	vsCMPartHeaderWithAttributes	= 6,
	vsCMPartWholeWithAttributes	= 10
    } 	vsCMPart;

typedef /* [uuid] */  DECLSPEC_UUID("0CFBC2CD-0D4E-11D3-8997-00C04F688DDE") 
enum vsCMElement
    {	vsCMElementOther	= 0,
	vsCMElementClass	= 1,
	vsCMElementFunction	= 2,
	vsCMElementVariable	= 3,
	vsCMElementProperty	= 4,
	vsCMElementNamespace	= 5,
	vsCMElementParameter	= 6,
	vsCMElementAttribute	= 7,
	vsCMElementInterface	= 8,
	vsCMElementDelegate	= 9,
	vsCMElementEnum	= 10,
	vsCMElementStruct	= 11,
	vsCMElementUnion	= 12,
	vsCMElementLocalDeclStmt	= 13,
	vsCMElementFunctionInvokeStmt	= 14,
	vsCMElementPropertySetStmt	= 15,
	vsCMElementAssignmentStmt	= 16,
	vsCMElementInheritsStmt	= 17,
	vsCMElementImplementsStmt	= 18,
	vsCMElementOptionStmt	= 19,
	vsCMElementVBAttributeStmt	= 20,
	vsCMElementVBAttributeGroup	= 21,
	vsCMElementEventsDeclaration	= 22,
	vsCMElementUDTDecl	= 23,
	vsCMElementDeclareDecl	= 24,
	vsCMElementDefineStmt	= 25,
	vsCMElementTypeDef	= 26,
	vsCMElementIncludeStmt	= 27,
	vsCMElementUsingStmt	= 28,
	vsCMElementMacro	= 29,
	vsCMElementMap	= 30,
	vsCMElementIDLImport	= 31,
	vsCMElementIDLImportLib	= 32,
	vsCMElementIDLCoClass	= 33,
	vsCMElementIDLLibrary	= 34,
	vsCMElementImportStmt	= 35,
	vsCMElementMapEntry	= 36,
	vsCMElementVCBase	= 37,
	vsCMElementEvent	= 38,
	vsCMElementModule	= 39
    } 	vsCMElement;

typedef /* [uuid] */  DECLSPEC_UUID("0CFBC2CE-0D4E-11D3-8997-00C04F688DDE") 
enum vsCMFunction
    {	vsCMFunctionOther	= 0,
	vsCMFunctionConstructor	= 1,
	vsCMFunctionPropertyGet	= 2,
	vsCMFunctionPropertyLet	= 4,
	vsCMFunctionPropertySet	= 8,
	vsCMFunctionPutRef	= 16,
	vsCMFunctionPropertyAssign	= 32,
	vsCMFunctionSub	= 64,
	vsCMFunctionFunction	= 128,
	vsCMFunctionTopLevel	= 256,
	vsCMFunctionDestructor	= 512,
	vsCMFunctionOperator	= 1024,
	vsCMFunctionVirtual	= 2048,
	vsCMFunctionPure	= 4096,
	vsCMFunctionConstant	= 8192,
	vsCMFunctionShared	= 16384,
	vsCMFunctionInline	= 32768,
	vsCMFunctionComMethod	= 65536
    } 	vsCMFunction;

typedef /* [uuid] */  DECLSPEC_UUID("ED1A3F96-4477-11d3-89BF-00C04F688DDE") 
enum vsCMAccess
    {	vsCMAccessPublic	= 1,
	vsCMAccessPrivate	= 2,
	vsCMAccessProject	= 4,
	vsCMAccessProtected	= 8,
	vsCMAccessDefault	= 32,
	vsCMAccessAssemblyOrFamily	= 64,
	vsCMAccessWithEvents	= 128,
	vsCMAccessProjectOrProtected	= 12
    } 	vsCMAccess;

typedef /* [uuid] */  DECLSPEC_UUID("ED1A3F97-4477-11d3-89BF-00C04F688DDE") 
enum vsCMInfoLocation
    {	vsCMInfoLocationProject	= 1,
	vsCMInfoLocationExternal	= 2,
	vsCMInfoLocationNone	= 4,
	vsCMInfoLocationVirtual	= 8
    } 	vsCMInfoLocation;

typedef /* [uuid] */  DECLSPEC_UUID("ED1A3F98-4477-11d3-89BF-00C04F688DDE") 
enum vsCMPrototype
    {	vsCMPrototypeFullname	= 1,
	vsCMPrototypeNoName	= 2,
	vsCMPrototypeClassName	= 4,
	vsCMPrototypeParamTypes	= 8,
	vsCMPrototypeParamNames	= 16,
	vsCMPrototypeParamDefaultValues	= 32,
	vsCMPrototypeUniqueSignature	= 64,
	vsCMPrototypeType	= 128,
	vsCMPrototypeInitExpression	= 256
    } 	vsCMPrototype;

typedef /* [uuid] */  DECLSPEC_UUID("C58839C3-7435-4944-8277-EA97B8EB2FA2") 
enum vsCMTypeRef
    {	vsCMTypeRefOther	= 0,
	vsCMTypeRefCodeType	= 1,
	vsCMTypeRefArray	= 2,
	vsCMTypeRefVoid	= 3,
	vsCMTypeRefPointer	= 4,
	vsCMTypeRefString	= 5,
	vsCMTypeRefObject	= 6,
	vsCMTypeRefByte	= 7,
	vsCMTypeRefChar	= 8,
	vsCMTypeRefShort	= 9,
	vsCMTypeRefInt	= 10,
	vsCMTypeRefLong	= 11,
	vsCMTypeRefFloat	= 12,
	vsCMTypeRefDouble	= 13,
	vsCMTypeRefDecimal	= 14,
	vsCMTypeRefBool	= 15,
	vsCMTypeRefVariant	= 16
    } 	vsCMTypeRef;

















typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("75607DDE-2B43-11d3-B88B-00C04F79E479") 
enum dbgBreakpointType
    {	dbgBreakpointTypePending	= 1,
	dbgBreakpointTypeBound	= dbgBreakpointTypePending + 1
    } 	dbgBreakpointType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("229C054C-C146-11d2-8AD1-00C04F79E479") 
enum dbgBreakpointLocationType
    {	dbgBreakpointLocationTypeNone	= 1,
	dbgBreakpointLocationTypeFunction	= dbgBreakpointLocationTypeNone + 1,
	dbgBreakpointLocationTypeFile	= dbgBreakpointLocationTypeFunction + 1,
	dbgBreakpointLocationTypeData	= dbgBreakpointLocationTypeFile + 1,
	dbgBreakpointLocationTypeAddress	= dbgBreakpointLocationTypeData + 1
    } 	dbgBreakpointLocationType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("2A594772-C146-11d2-8AD1-00C04F79E479") 
enum dbgBreakpointConditionType
    {	dbgBreakpointConditionTypeWhenTrue	= 1,
	dbgBreakpointConditionTypeWhenChanged	= dbgBreakpointConditionTypeWhenTrue + 1
    } 	dbgBreakpointConditionType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("ED2FBDD2-1EB1-11d3-B888-00C04F79E479") 
enum dbgExceptionAction
    {	dbgExceptionActionDefault	= 1,
	dbgExceptionActionIgnore	= dbgExceptionActionDefault + 1,
	dbgExceptionActionBreak	= dbgExceptionActionIgnore + 1,
	dbgExceptionActionContinue	= dbgExceptionActionBreak + 1
    } 	dbgExceptionAction;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("3A3329CE-C146-11d2-8AD1-00C04F79E479") 
enum dbgHitCountType
    {	dbgHitCountTypeNone	= 1,
	dbgHitCountTypeEqual	= dbgHitCountTypeNone + 1,
	dbgHitCountTypeGreaterOrEqual	= dbgHitCountTypeEqual + 1,
	dbgHitCountTypeMultiple	= dbgHitCountTypeGreaterOrEqual + 1
    } 	dbgHitCountType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("E940C60A-C68F-11d2-8AD6-00C04F79E479") 
enum dbgDebugMode
    {	dbgDesignMode	= 1,
	dbgBreakMode	= dbgDesignMode + 1,
	dbgRunMode	= dbgBreakMode + 1
    } 	dbgDebugMode;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("4106C580-C146-11d2-8AD1-00C04F79E479") 
enum dbgEventReason
    {	dbgEventReasonNone	= 1,
	dbgEventReasonGo	= dbgEventReasonNone + 1,
	dbgEventReasonAttachProgram	= dbgEventReasonGo + 1,
	dbgEventReasonDetachProgram	= dbgEventReasonAttachProgram + 1,
	dbgEventReasonLaunchProgram	= dbgEventReasonDetachProgram + 1,
	dbgEventReasonEndProgram	= dbgEventReasonLaunchProgram + 1,
	dbgEventReasonStopDebugging	= dbgEventReasonEndProgram + 1,
	dbgEventReasonStep	= dbgEventReasonStopDebugging + 1,
	dbgEventReasonBreakpoint	= dbgEventReasonStep + 1,
	dbgEventReasonExceptionThrown	= dbgEventReasonBreakpoint + 1,
	dbgEventReasonExceptionNotHandled	= dbgEventReasonExceptionThrown + 1,
	dbgEventReasonUserBreak	= dbgEventReasonExceptionNotHandled + 1,
	dbgEventReasonContextSwitch	= dbgEventReasonUserBreak + 1
    } 	dbgEventReason;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("77940E85-BCE0-443d-8B77-F5BD841A211E") 
enum dbgExecutionAction
    {	dbgExecutionActionDefault	= 1,
	dbgExecutionActionGo	= dbgExecutionActionDefault + 1,
	dbgExecutionActionStopDebugging	= dbgExecutionActionGo + 1,
	dbgExecutionActionStepInto	= dbgExecutionActionStopDebugging + 1,
	dbgExecutionActionStepOut	= dbgExecutionActionStepInto + 1,
	dbgExecutionActionStepOver	= dbgExecutionActionStepOut + 1,
	dbgExecutionActionRunToCursor	= dbgExecutionActionStepOver + 1
    } 	dbgExecutionAction;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("178c767a-1963-4bc5-b3f2-e70f3eb441a8") 
enum vsNavigateBrowser
    {	vsNavigateBrowserDefault	= 0,
	vsNavigateBrowserHelp	= 1,
	vsNavigateBrowserNewWindow	= 2
    } 	vsNavigateBrowser;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("947978f5-185b-4366-921e-a14c0ed46702") 
enum vsCommandDisabledFlags
    {	vsCommandDisabledFlagsEnabled	= 0,
	vsCommandDisabledFlagsGrey	= 0x10,
	vsCommandDisabledFlagsHidden	= 0x20
    } 	vsCommandDisabledFlags;

typedef /* [uuid] */  DECLSPEC_UUID("9e3c8489-ae44-4fcf-9697-cd3f312ba08c") 
enum vsInitializeMode
    {	vsInitializeModeStartup	= 0,
	vsInitializeModeReset	= 1
    } 	vsInitializeMode;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("79946991-1ae2-4d2d-9768-fd7801be7daa") 
enum vsCommandBarType
    {	vsCommandBarTypePopup	= 10,
	vsCommandBarTypeToolbar	= 23,
	vsCommandBarTypeMenu	= 24
    } 	vsCommandBarType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("b638b3e3-c98b-4f59-9d05-105a620529f9") 
enum vsIDEMode
    {	vsIDEModeDesign	= 1,
	vsIDEModeDebug	= 2
    } 	vsIDEMode;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("d920605a-11dd-4a12-a8dc-10578bb08606") 
enum wizardResult
    {	wizardResultSuccess	= -1,
	wizardResultFailure	= 0,
	wizardResultCancel	= 1,
	wizardResultBackOut	= 2
    } 	wizardResult;

#define ext_cm_Solution 4
#define ext_cm_UISetup 5
#define ext_dm_UISetupComplete 2
#define ext_dm_SolutionClosed 3
typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("ca3ee5d0-6305-422f-a425-99737956088f") 
enum vsPromptResult
    {	vsPromptResultYes	= 1,
	vsPromptResultNo	= 2,
	vsPromptResultCancelled	= 3
    } 	vsPromptResult;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("d9e97957-b425-4cd6-bb74-9e6f232a342a") 
enum vsCommandStatusTextWanted
    {	vsCommandStatusTextWantedNone	= 0,
	vsCommandStatusTextWantedName	= 1,
	vsCommandStatusTextWantedStatus	= 2
    } 	vsCommandStatusTextWanted;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("e0ace2e3-49c1-4aa3-ac03-a2877a93d77f") 
enum vsCommandStatus
    {	vsCommandStatusUnsupported	= 0,
	vsCommandStatusSupported	= 1,
	vsCommandStatusEnabled	= 2,
	vsCommandStatusLatched	= 4,
	vsCommandStatusNinched	= 8,
	vsCommandStatusInvisible	= 16
    } 	vsCommandStatus;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("3c537e1a-39b8-4fda-9f22-93d8c030865d") 
enum vsCommandExecOption
    {	vsCommandExecOptionDoDefault	= 0,
	vsCommandExecOptionPromptUser	= 1,
	vsCommandExecOptionDoPromptUser	= 2,
	vsCommandExecOptionShowHelp	= 3
    } 	vsCommandExecOption;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("e0e643c3-5410-487a-b64e-2664a5c4ab50") 
enum vsDisplay
    {	vsDisplayMDI	= 1,
	vsDisplayMDITabs	= 2
    } 	vsDisplay;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("AAE3FAE8-8AFC-11D2-ADEE-00C04F7971C3") 
enum vsSaveChanges
    {	vsSaveChangesYes	= 1,
	vsSaveChangesNo	= 2,
	vsSaveChangesPrompt	= 3
    } 	vsSaveChanges;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("8901ff7a-e6e8-4154-a505-135ee434817e") 
enum vsSaveStatus
    {	vsSaveCancelled	= 2,
	vsSaveSucceeded	= 1
    } 	vsSaveStatus;

#define SID_SVsSourceControl IID_SourceControl
typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("3982FA28-7BCC-4f14-817C-93EEECE8BEEE") 
enum vsBuildKind
    {	vsBuildKindSolution	= 0,
	vsBuildKindProject	= 1,
	vsBuildKindProjectItem	= 2
    } 	vsBuildKind;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("FA7FA701-EFAD-4895-A95A-D4ECB383BF7D") 
enum vsBuildScope
    {	vsBuildScopeSolution	= 1,
	vsBuildScopeBatch	= 2,
	vsBuildScopeProject	= 3
    } 	vsBuildScope;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("FA7FA702-EFAD-4895-A95A-D4ECB383BF7D") 
enum vsBuildAction
    {	vsBuildActionBuild	= 1,
	vsBuildActionRebuildAll	= 2,
	vsBuildActionClean	= 3,
	vsBuildActionDeploy	= 4
    } 	vsBuildAction;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("705CD8A9-D29B-11D2-AABD-00C04F688DDE") 
enum vsWindowType
    {	vsWindowTypeCodeWindow	= 0,
	vsWindowTypeDesigner	= 1,
	vsWindowTypeBrowser	= 2,
	vsWindowTypeWatch	= 3,
	vsWindowTypeLocals	= 4,
	vsWindowTypeImmediate	= 5,
	vsWindowTypeSolutionExplorer	= 6,
	vsWindowTypeProperties	= 7,
	vsWindowTypeFind	= 8,
	vsWindowTypeFindReplace	= 9,
	vsWindowTypeToolbox	= 10,
	vsWindowTypeLinkedWindowFrame	= 11,
	vsWindowTypeMainWindow	= 12,
	vsWindowTypePreview	= 13,
	vsWindowTypeColorPalette	= 14,
	vsWindowTypeToolWindow	= 15,
	vsWindowTypeDocument	= 16,
	vsWindowTypeOutput	= 17,
	vsWindowTypeTaskList	= 18,
	vsWindowTypeAutos	= 19,
	vsWindowTypeCallStack	= 20,
	vsWindowTypeThreads	= 21,
	vsWindowTypeDocumentOutline	= 22,
	vsWindowTypeRunningDocuments	= 23
    } 	vsWindowType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("cd678662-7939-48a0-bf1d-fa1bed56c130") 
enum vsWindowState
    {	vsWindowStateNormal	= 0,
	vsWindowStateMinimize	= 1,
	vsWindowStateMaximize	= 2
    } 	vsWindowState;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("539f9c17-db5f-421d-b02b-07bcf9faa92f") 
enum vsLinkedWindowType
    {	vsLinkedWindowTypeDocked	= 0,
	vsLinkedWindowTypeVertical	= 2,
	vsLinkedWindowTypeHorizontal	= 3,
	vsLinkedWindowTypeTabbed	= 1
    } 	vsLinkedWindowType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("59286edc-d580-4e22-96c9-44d15b6148cc") 
enum vsContextAttributes
    {	vsContextAttributesGlobal	= 1,
	vsContextAttributesWindow	= 2,
	vsContextAttributesHighPriority	= 3
    } 	vsContextAttributes;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("410202e1-b83a-41dd-aab0-8c0029fe9435") 
enum vsContextAttributeType
    {	vsContextAttributeFilter	= 1,
	vsContextAttributeLookup	= 2,
	vsContextAttributeLookupF1	= 3
    } 	vsContextAttributeType;

typedef /* [uuid] */  DECLSPEC_UUID("11f0cb7f-4f63-4e09-b99c-92a6cc5f84ce") 
enum vsTextChanged
    {	vsTextChangedMultiLine	= 1,
	vsTextChangedSave	= 2,
	vsTextChangedCaretMoved	= 4,
	vsTextChangedReplaceAll	= 8,
	vsTextChangedNewline	= 16,
	vsTextChangedFindStarting	= 32
    } 	vsTextChanged;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("36B56DE8-5A17-11D1-B2B6-00C04FB6C6FF") 
enum vsTaskPriority
    {	vsTaskPriorityLow	= 1,
	vsTaskPriorityMedium	= 2,
	vsTaskPriorityHigh	= 3
    } 	vsTaskPriority;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("195DAB2E-4854-11D2-8820-00C04FB6C6FF") 
enum vsTaskIcon
    {	vsTaskIconNone	= 0,
	vsTaskIconCompile	= 1,
	vsTaskIconSquiggle	= 2,
	vsTaskIconComment	= 3,
	vsTaskIconShortcut	= 4,
	vsTaskIconUser	= 5
    } 	vsTaskIcon;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("9848C17E-6AA5-11D2-97C3-00C04FB6C6FF") 
enum vsTaskListColumn
    {	vsTaskListColumnPriority	= 1,
	vsTaskListColumnGlyph	= 2,
	vsTaskListColumnCheck	= 4,
	vsTaskListColumnDescription	= 8,
	vsTaskListColumnFile	= 16,
	vsTaskListColumnLine	= 32
    } 	vsTaskListColumn;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("f40a5d39-fd39-4f03-8358-4df3c338b448") 
enum vsStatusAnimation
    {	vsStatusAnimationGeneral	= 0,
	vsStatusAnimationPrint	= 1,
	vsStatusAnimationSave	= 2,
	vsStatusAnimationDeploy	= 3,
	vsStatusAnimationSync	= 4,
	vsStatusAnimationBuild	= 5,
	vsStatusAnimationFind	= 6
    } 	vsStatusAnimation;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("44DF8FDC-7378-11D2-97CA-00C04FB6C6FF") 
enum vsToolBoxItemFormat
    {	vsToolBoxItemFormatText	= 1,
	vsToolBoxItemFormatHTML	= 2,
	vsToolBoxItemFormatGUID	= 4,
	vsToolBoxItemFormatDotNETComponent	= 8
    } 	vsToolBoxItemFormat;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("705CD8AC-D29B-11D2-AABD-00C04F688DDE") 
enum vsStartUp
    {	vsStartUpShowHomePage	= 0,
	vsStartUpLoadLastSolution	= 1,
	vsStartUpOpenProjectDialog	= 2,
	vsStartUpNewProjectDialog	= 3,
	vsStartUpEmptyEnvironment	= 4
    } 	vsStartUp;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("705CD8A4-D29B-11D2-AABD-00C04F688DDE") 
enum vsFontCharSet
    {	vsFontCharSetANSI	= 0,
	vsFontCharSetDefault	= 1,
	vsFontCharSetSymbol	= 2,
	vsFontCharSetShiftJIS	= 128,
	vsFontCharSetHangeul	= 129,
	vsFontCharSetGB2312	= 134,
	vsFontCharSetChineseBig5	= 136,
	vsFontCharSetOEM	= 255,
	vsFontCharSetJohab	= 130,
	vsFontCharSetHebrew	= 177,
	vsFontCharSetArabic	= 178,
	vsFontCharSetGreek	= 161,
	vsFontCharSetTurkish	= 162,
	vsFontCharSetVietnamese	= 163,
	vsFontCharSetThai	= 222,
	vsFontCharSetEastEurope	= 238,
	vsFontCharSetRussian	= 204,
	vsFontCharSetMac	= 77,
	vsFontCharSetBaltic	= 186
    } 	vsFontCharSet;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("947FFC03-8314-4288-BDD7-DFD282DA40D5") 
enum vsBrowserViewSource
    {	vsBrowserViewSourceSource	= 1,
	vsBrowserViewSourceDesign	= 2,
	vsBrowserViewSourceExternal	= 3
    } 	vsBrowserViewSource;

// Standard Shell Automation Extender CATIDs
// These are the intrinsic extender CATIDs for the automation and the property
// browser IDispatch objects implemented by the shell that suppport Automation
// Extenders. For other implementation specific extender CATIDs (for eg. VB, VC)
// look in those specific headers
//
// Also note that the object (IDispatch) used for automation is typically
// different than the one used for Property Browsing. For instance, the
// DTE.Solution automation object is different than the object used to populate
// the property browser when the solution node is selected in the project
// explorer. Hence, the two objects used DIFFERENT intrinsic CATIDs
// (guidCATIDSolution for the Solution automation object and
// guidCATIDSolutionBrowseObject for the Solution's property browse object)
// Solution Automation object CATID {52AEFF70-BBD8-11d2-8598-006097C68E81}
DEFINE_GUID(guidCATIDSolution,						0x52aeff70, 0xbbd8, 0x11d2, 0x85, 0x98, 0x0, 0x60, 0x97, 0xc6, 0x8e, 0x81);
// Solution Browse Object CATID {A2392464-7C22-11d3-BDCA-00C04F688E50}
DEFINE_GUID(guidCATIDSolutionBrowseObject, 0xa2392464, 0x7c22, 0x11d3, 0xbd, 0xca, 0x0, 0xc0, 0x4f, 0x68, 0x8e, 0x50);
// Misc Files Project Automation Object CATID {610d4612-d0d5-11d2-8599-006097c68e81}
DEFINE_GUID(guidCATIDMiscFilesProject,		0x610d4612, 0xd0d5, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xc6, 0x8e, 0x81);
// Misc Files Project Item Automation Object CATID {610d4613-d0d5-11d2-8599-006097c68e81
DEFINE_GUID(guidCATIDMiscFilesProjectItem, 0x610d4613, 0xd0d5, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xc6, 0x8e, 0x81);
// Generic Project Automation Object CATID {610d4616-d0d5-11d2-8599-006097c68e81}
DEFINE_GUID(guidCATIDGenericProject,			0x610d4616, 0xd0d5, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xc6, 0x8e, 0x81);
// (Generic) Document Automation Object CATID {610d4611-d0d5-11d2-8599-006097c68e81}
DEFINE_GUID(guidCATIDDocument,						0x610d4611, 0xd0d5, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xc6, 0x8e, 0x81);
typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("28362492-b1e3-4998-94c6-0a2cdb5484ed") 
enum vsUISelectionType
    {	vsUISelectionTypeSelect	= 1,
	vsUISelectionTypeToggle	= 2,
	vsUISelectionTypeExtend	= 3,
	vsUISelectionTypeSetCaret	= 4
    } 	vsUISelectionType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("16386f0e-4ad2-41b8-8d6f-7ff230ae1d17") 
enum vsBuildState
    {	vsBuildStateNotStarted	= 1,
	vsBuildStateInProgress	= 2,
	vsBuildStateDone	= 3
    } 	vsBuildState;

#ifdef Debug
#define Debug_defined
#undef Debug
#endif
typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("612256bd-7ba2-45c4-b60f-7b2ae42f96c3") 
enum vsConfigurationType
    {	vsConfigurationTypeProject	= 1,
	vsConfigurationTypeProjectItem	= 2
    } 	vsConfigurationType;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("9fb64132-726a-4262-829e-051c6ec7b24f") 
enum vsFindAction
    {	vsFindActionFind	= 1,
	vsFindActionFindAll	= 2,
	vsFindActionReplace	= 3,
	vsFindActionReplaceAll	= 4,
	vsFindActionBookmarkAll	= 5
    } 	vsFindAction;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("6fa137be-32a8-4f54-8099-60bb955097a3") 
enum vsFindResult
    {	vsFindResultNotFound	= 0,
	vsFindResultFound	= 1,
	vsFindResultReplaceAndNotFound	= 2,
	vsFindResultReplaceAndFound	= 3,
	vsFindResultReplaced	= 4,
	vsFindResultPending	= 5,
	vsFindResultError	= 6
    } 	vsFindResult;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("530f2d0e-a5f9-4b7a-a379-0a3b99b5e66d") 
enum vsFindPatternSyntax
    {	vsFindPatternSyntaxLiteral	= 0,
	vsFindPatternSyntaxRegExpr	= 1,
	vsFindPatternSyntaxWildcards	= 2
    } 	vsFindPatternSyntax;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("481899fb-b657-4e45-8c00-0e051052bb13") 
enum vsFindTarget
    {	vsFindTargetCurrentDocument	= 1,
	vsFindTargetCurrentDocumentSelection	= 2,
	vsFindTargetCurrentDocumentFunction	= 3,
	vsFindTargetOpenDocuments	= 4,
	vsFindTargetCurrentProject	= 5,
	vsFindTargetSolution	= 6,
	vsFindTargetFiles	= 7
    } 	vsFindTarget;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("ea9142bf-b2af-48a7-b256-93ccd3350bd8") 
enum vsFindResultsLocation
    {	vsFindResultsNone	= 0,
	vsFindResults1	= 1,
	vsFindResults2	= 2
    } 	vsFindResultsLocation;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("a457303f-d058-4415-a2b4-a81b148c7689") 
enum vsFindOptions
    {	vsFindOptionsNone	= 0,
	vsFindOptionsMatchWholeWord	= 0x2,
	vsFindOptionsMatchCase	= 0x4,
	vsFindOptionsRegularExpression	= 0x8,
	vsFindOptionsBackwards	= 0x80,
	vsFindOptionsFromStart	= 0x100,
	vsFindOptionsMatchInHiddenText	= 0x200,
	vsFindOptionsWildcards	= 0x400,
	vsFindOptionsSearchSubfolders	= 0x1000,
	vsFindOptionsKeepModifiedDocumentsOpen	= 0x2000
    } 	vsFindOptions;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("b4cc3e73-0038-47e5-ba52-d1183f8fdbf0") 
enum vsNavigateOptions
    {	vsNavigateOptionsDefault	= 0,
	vsNavigateOptionsNewWindow	= 0x1
    } 	vsNavigateOptions;

#define SID_SExtensionManager	IID_ObjectExtenders
typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("221ab797-408b-4d69-9dd1-c6f329189414") 
enum vsFilterProperties
    {	vsFilterPropertiesNone	= 0,
	vsFilterPropertiesAll	= 1,
	vsFilterPropertiesSet	= 2
    } 	vsFilterProperties;

typedef /* [uuid] */  DECLSPEC_UUID("bbdfcfe4-4c68-4736-b991-f85fa955d585") 
enum vsWhitespaceOptions
    {	vsWhitespaceOptionsHorizontal	= 0,
	vsWhitespaceOptionsVertical	= 1
    } 	vsWhitespaceOptions;

typedef /* [uuid] */  DECLSPEC_UUID("98a2f403-007b-41f8-9a18-87addef1760f") 
enum vsCaseOptions
    {	vsCaseOptionsLowercase	= 1,
	vsCaseOptionsUppercase	= 2,
	vsCaseOptionsCapitalize	= 3
    } 	vsCaseOptions;

typedef /* [uuid] */  DECLSPEC_UUID("29182bd4-48a8-4e4b-81dd-1b742a3a5203") 
enum vsMovementOptions
    {	vsMovementOptionsMove	= 0,
	vsMovementOptionsExtend	= 1
    } 	vsMovementOptions;

typedef /* [uuid] */  DECLSPEC_UUID("f05ea427-01ba-46dc-8392-fb4aa7e5eb3a") 
enum vsStartOfLineOptions
    {	vsStartOfLineOptionsFirstColumn	= 0,
	vsStartOfLineOptionsFirstText	= 1
    } 	vsStartOfLineOptions;

typedef /* [uuid] */  DECLSPEC_UUID("11b63a24-6200-48cd-9b8d-fc6a6fb9eff0") 
enum vsGoToLineOptions
    {	vsGoToLineOptionsLast	= -1,
	vsGoToLineOptionsFirst	= -2
    } 	vsGoToLineOptions;

typedef /* [uuid] */  DECLSPEC_UUID("c512dde3-a220-4373-8950-e6636f8cc546") 
enum vsSmartFormatOptions
    {	vsSmartFormatOptionsNone	= 0,
	vsSmartFormatOptionsBlock	= 1,
	vsSmartFormatOptionsSmart	= 2
    } 	vsSmartFormatOptions;

typedef /* [uuid] */  DECLSPEC_UUID("f3128012-b41f-46ec-8794-f716db9697d0") 
enum vsSelectionMode
    {	vsSelectionModeStream	= 0,
	vsSelectionModeBox	= 1
    } 	vsSelectionMode;

typedef /* [uuid] */  DECLSPEC_UUID("79515b53-8294-4f96-aa96-dd16bf126703") 
enum vsInsertFlags
    {	vsInsertFlagsCollapseToEnd	= 1,
	vsInsertFlagsCollapseToStart	= 2,
	vsInsertFlagsContainNewText	= 4,
	vsInsertFlagsInsertAtEnd	= 8,
	vsInsertFlagsInsertAtStart	= 16
    } 	vsInsertFlags;

typedef /* [uuid] */  DECLSPEC_UUID("b26ac3c2-3981-4a2e-9d6f-559b41cd1cd2") 
enum vsPaneShowHow
    {	vsPaneShowCentered	= 0,
	vsPaneShowTop	= 1,
	vsPaneShowAsIs	= 2
    } 	vsPaneShowHow;

typedef /* [uuid] */  DECLSPEC_UUID("4eb2c04f-8a83-4363-81db-dbb76cd76812") 
enum vsMoveToColumnLine
    {	vsMoveToColumnLineFirst	= 0,
	vsMoveToColumnLineLast	= 1
    } 	vsMoveToColumnLine;

typedef /* [uuid] */  DECLSPEC_UUID("3740dcf8-b8b2-49a9-a1ab-944c84876c3c") 
enum vsEPReplaceTextOptions
    {	vsEPReplaceTextKeepMarkers	= 1,
	vsEPReplaceTextNormalizeNewlines	= 2,
	vsEPReplaceTextTabsSpaces	= 4,
	vsEPReplaceTextAutoformat	= 8
    } 	vsEPReplaceTextOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("C106C8DC-6D0C-11D1-B2C9-00C04FB6C6FF") 
enum vsext_FontCharSet
    {	vsext_fontcs_ANSI	= 0,
	vsext_fontcs_DEFAULT	= 1,
	vsext_fontcs_SYMBOL	= 2,
	vsext_fontcs_SHIFTJIS	= 128,
	vsext_fontcs_HANGEUL	= 129,
	vsext_fontcs_GB2312	= 134,
	vsext_fontcs_CHINESEBIG5	= 136,
	vsext_fontcs_OEM	= 255,
	vsext_fontcs_JOHAB	= 130,
	vsext_fontcs_HEBREW	= 177,
	vsext_fontcs_ARABIC	= 178,
	vsext_fontcs_GREEK	= 161,
	vsext_fontcs_TURKISH	= 162,
	vsext_fontcs_VIETNAMESE	= 163,
	vsext_fontcs_THAI	= 222,
	vsext_fontcs_EASTEUROPE	= 238,
	vsext_fontcs_RUSSIAN	= 204,
	vsext_fontcs_MAC	= 77,
	vsext_fontcs_BALTIC	= 186
    } 	vsext_FontCharSet;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("cb0066fc-c052-4b24-84e7-045f33e4d6af") 
enum VSEXECRESULT
    {	RESULT_Success	= -1,
	RESULT_Failure	= 0,
	RESULT_Cancel	= 1
    } 	vs_exec_Result;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("91aab9c3-da83-473a-8bc9-1a2730865995") 
enum vsext_DisplayMode
    {	vsext_dm_SDI	= 0,
	vsext_dm_MDI	= 1
    } 	vsext_DisplayMode;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("E4B9E990-FD59-11D0-BBC6-00A0C90F2744") 
enum vsext_WindowType
    {	vsext_wt_CodeWindow	= 0,
	vsext_wt_Designer	= 1,
	vsext_wt_Browser	= 2,
	vsext_wt_Watch	= 3,
	vsext_wt_Locals	= 4,
	vsext_wt_Immediate	= 5,
	vsext_wt_ProjectWindow	= 6,
	vsext_wt_PropertyWindow	= 7,
	vsext_wt_Find	= 8,
	vsext_wt_FindReplace	= 9,
	vsext_wt_Toolbox	= 10,
	vsext_wt_LinkedWindowFrame	= 11,
	vsext_wt_MainWindow	= 12,
	vsext_wt_Preview	= 13,
	vsext_wt_ColorPalette	= 14,
	vsext_wt_ToolWindow	= 15,
	vsext_wt_Document	= 16,
	vsext_wt_OutPutWindow	= 17,
	vsext_wt_TaskList	= 18,
	vsext_wt_Autos	= 19,
	vsext_wt_CallStack	= 20,
	vsext_wt_Threads	= 21,
	vsext_wt_DocumentOutline	= 22,
	vsext_wt_RunningDocuments	= 23
    } 	vsext_WindowType;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("e0c72e51-6b99-489b-aca6-90cedce888e7") 
enum vsext_WindowState
    {	vsext_ws_Normal	= 0,
	vsext_ws_Minimize	= 1,
	vsext_ws_Maximize	= 2
    } 	vsext_WindowState;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("97653acf-d869-4ec0-b450-e9842457c729") 
enum vsext_LinkedWindowType
    {	vsext_lwt_Docked	= 0,
	vsext_lwt_Tabbed	= 1
    } 	vsext_LinkedWindowType;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("A5578594-18E0-11D1-BBDB-00A0C90F2744") 
enum vsext_StartUp
    {	vsext_su_EMPTY_ENVIRONMENT	= 0,
	vsext_su_NEW_SOLUTION_DIALOG	= 1,
	vsext_su_LOAD_LAST_SOLUTION	= 2
    } 	vsext_StartUp;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("47046891-19F7-11D1-BCAF-000000000000") 
enum vsext_Build
    {	vsext_bld_SAVE_CHANGES	= 0,
	vsext_bld_CONFIRM_SAVE	= 1,
	vsext_bld_NO_SAVE	= 2
    } 	vsext_Build;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("bdbe10aa-74d3-498a-a464-8074cd5e99cb") 
enum DsTextSearchOptions
    {	dsMatchWord	= 2,
	dsMatchCase	= 4,
	dsMatchNoRegExp	= 0,
	dsMatchRegExp	= 8,
	dsMatchRegExpB	= 16,
	dsMatchRegExpE	= 32,
	dsMatchRegExpCur	= 64,
	dsMatchForward	= 0,
	dsMatchBackward	= 128,
	dsMatchFromStart	= 256
    } 	DsTextSearchOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("99744EC4-7A72-11D2-ADC9-00C04F7971C3") 
enum DsSaveChanges
    {	dsSaveChangesYes	= 1,
	dsSaveChangesNo	= 2,
	dsSaveChangesPrompt	= 3
    } 	DsSaveChanges;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("6269c78d-5591-40d6-a095-5bac8ba07478") 
enum DsGoToLineOptions
    {	dsLastLine	= -1
    } 	DsGoToLineOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("95751137-ac07-4c76-a219-4be5d381985d") 
enum DsStartOfLineOptions
    {	dsFirstColumn	= 0,
	dsFirstText	= 1
    } 	DsStartOfLineOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("4b58f807-6f08-4b41-abaf-b5bca4869d2c") 
enum DsMovementOptions
    {	dsMove	= 0,
	dsExtend	= 1
    } 	DsMovementOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("31445615-bcae-4ba0-a99c-246bc660cfe8") 
enum DsWhitespaceOptions
    {	dsHorizontal	= 0,
	dsVertical	= 1
    } 	DsWhitespaceOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("f7d38518-e803-4462-8fa2-e481642d42fb") 
enum DsCaseOptions
    {	dsLowercase	= 1,
	dsUppercase	= 2,
	dsCapitalize	= 3
    } 	DsCaseOptions;

typedef /* [hidden][uuid] */  DECLSPEC_UUID("8d78b9a9-a3be-49d0-aa97-bf7fa46d8ea2") 
enum dsSaveStatus
    {	dsSaveCancelled	= 2,
	dsSaveSucceeded	= 1
    } 	dsSaveStatus;

typedef /* [helpstringcontext][helpstring][helpcontext][uuid] */  DECLSPEC_UUID("44160df5-e305-4d85-b7fe-6b5a1b81b9b0") 
enum vsHTMLTabs
    {	vsHTMLTabsSource	= 0,
	vsHTMLTabsDesign	= 1
    } 	vsHTMLTabs;


EXTERN_C const IID LIBID_EnvDTE;

#ifndef ___DTE_INTERFACE_DEFINED__
#define ___DTE_INTERFACE_DEFINED__

/* interface _DTE */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID__DTE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04a72314-32e9-48e2-9b87-a63603454f3e")
    _DTE : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_CommandBars( 
            /* [retval][out] */ /* external definition not present */ CommandBars **ppcbs) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ Windows **ppwnsVBWindows) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Events( 
            /* [retval][out] */ Events **ppevtEvents) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_AddIns( 
            /* [retval][out] */ AddIns **lpppAddIns) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_MainWindow( 
            /* [retval][out] */ Window **ppwin) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveWindow( 
            /* [retval][out] */ Window **ppwinActive) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Quit( void) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayMode( 
            /* [retval][out] */ vsDisplay *lpDispMode) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayMode( 
            /* [in] */ vsDisplay DispMode) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Solution( 
            /* [retval][out] */ Solution	**ppSolution) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Commands( 
            /* [retval][out] */ Commands **ppCommands) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR Name,
            /* [retval][out] */ IDispatch **ppObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            BSTR Category,
            BSTR Page,
            /* [retval][out] */ Properties **ppObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectedItems( 
            /* [retval][out] */ SelectedItems **ppSelectedItems) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_CommandLineArguments( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ BSTR ViewKind,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ Window **ppwin) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsOpenFile( 
            /* [in] */ BSTR ViewKind,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_LocaleID( 
            /* [retval][out] */ long *lpReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_WindowConfigurations( 
            /* [retval][out] */ WindowConfigurations **WindowConfigurationsObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Documents( 
            /* [retval][out] */ Documents **ppDocuments) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveDocument( 
            /* [retval][out] */ Document **ppDocument) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ExecuteCommand( 
            /* [in] */ BSTR CommandName,
            /* [defaultvalue][in] */ BSTR CommandArgs = L"") = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Globals( 
            /* [retval][out] */ Globals **ppGlobals) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_StatusBar( 
            /* [retval][out] */ StatusBar **ppStatusBar) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserControl( 
            /* [retval][out] */ VARIANT_BOOL *UserControl) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_UserControl( 
            /* [in] */ VARIANT_BOOL HasControl) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ObjectExtenders( 
            /* [retval][out] */ ObjectExtenders **ppObjectExtenders) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Find( 
            /* [retval][out] */ Find **ppFind) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ vsIDEMode *pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE LaunchWizard( 
            /* [in] */ BSTR VSZFile,
            /* [in] */ SAFEARRAY * *ContextParams,
            /* [retval][out] */ wizardResult *pResult) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ItemOperations( 
            /* [retval][out] */ ItemOperations **ppItemOperations) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_UndoContext( 
            /* [retval][out] */ UndoContext **ppUndoContext) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Macros( 
            /* [retval][out] */ Macros **ppMacros) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveSolutionProjects( 
            /* [retval][out] */ VARIANT *pProjects) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_MacrosIDE( 
            /* [retval][out] */ DTE	**pDTE) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegistryRoot( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [propget][hidden][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ DTE	**pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContextAttributes( 
            /* [retval][out] */ ContextAttributes **ppVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceControl( 
            /* [retval][out] */ SourceControl **ppVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SuppressUI( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_SuppressUI( 
            /* [in] */ VARIANT_BOOL Suppress) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Debugger( 
            /* [retval][out] */ Debugger **ppDebugger) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SatelliteDLLPath( 
            BSTR Path,
            BSTR Name,
            /* [retval][out] */ BSTR *pFullPath) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Edition( 
            /* [retval][out] */ BSTR *ProductEdition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _DTEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _DTE * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _DTE * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _DTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _DTE * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _DTE * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _DTE * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _DTE * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            _DTE * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            _DTE * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            _DTE * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CommandBars )( 
            _DTE * This,
            /* [retval][out] */ /* external definition not present */ CommandBars **ppcbs);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Windows )( 
            _DTE * This,
            /* [retval][out] */ Windows **ppwnsVBWindows);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Events )( 
            _DTE * This,
            /* [retval][out] */ Events **ppevtEvents);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AddIns )( 
            _DTE * This,
            /* [retval][out] */ AddIns **lpppAddIns);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MainWindow )( 
            _DTE * This,
            /* [retval][out] */ Window **ppwin);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveWindow )( 
            _DTE * This,
            /* [retval][out] */ Window **ppwinActive);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Quit )( 
            _DTE * This);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            _DTE * This,
            /* [retval][out] */ vsDisplay *lpDispMode);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            _DTE * This,
            /* [in] */ vsDisplay DispMode);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Solution )( 
            _DTE * This,
            /* [retval][out] */ Solution	**ppSolution);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Commands )( 
            _DTE * This,
            /* [retval][out] */ Commands **ppCommands);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            _DTE * This,
            /* [in] */ BSTR Name,
            /* [retval][out] */ IDispatch **ppObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            _DTE * This,
            BSTR Category,
            BSTR Page,
            /* [retval][out] */ Properties **ppObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedItems )( 
            _DTE * This,
            /* [retval][out] */ SelectedItems **ppSelectedItems);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CommandLineArguments )( 
            _DTE * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *OpenFile )( 
            _DTE * This,
            /* [in] */ BSTR ViewKind,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ Window **ppwin);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpenFile )( 
            _DTE * This,
            /* [in] */ BSTR ViewKind,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            _DTE * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocaleID )( 
            _DTE * This,
            /* [retval][out] */ long *lpReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WindowConfigurations )( 
            _DTE * This,
            /* [retval][out] */ WindowConfigurations **WindowConfigurationsObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Documents )( 
            _DTE * This,
            /* [retval][out] */ Documents **ppDocuments);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveDocument )( 
            _DTE * This,
            /* [retval][out] */ Document **ppDocument);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteCommand )( 
            _DTE * This,
            /* [in] */ BSTR CommandName,
            /* [defaultvalue][in] */ BSTR CommandArgs);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Globals )( 
            _DTE * This,
            /* [retval][out] */ Globals **ppGlobals);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_StatusBar )( 
            _DTE * This,
            /* [retval][out] */ StatusBar **ppStatusBar);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullName )( 
            _DTE * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserControl )( 
            _DTE * This,
            /* [retval][out] */ VARIANT_BOOL *UserControl);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserControl )( 
            _DTE * This,
            /* [in] */ VARIANT_BOOL HasControl);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectExtenders )( 
            _DTE * This,
            /* [retval][out] */ ObjectExtenders **ppObjectExtenders);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Find )( 
            _DTE * This,
            /* [retval][out] */ Find **ppFind);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            _DTE * This,
            /* [retval][out] */ vsIDEMode *pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *LaunchWizard )( 
            _DTE * This,
            /* [in] */ BSTR VSZFile,
            /* [in] */ SAFEARRAY * *ContextParams,
            /* [retval][out] */ wizardResult *pResult);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ItemOperations )( 
            _DTE * This,
            /* [retval][out] */ ItemOperations **ppItemOperations);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UndoContext )( 
            _DTE * This,
            /* [retval][out] */ UndoContext **ppUndoContext);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Macros )( 
            _DTE * This,
            /* [retval][out] */ Macros **ppMacros);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveSolutionProjects )( 
            _DTE * This,
            /* [retval][out] */ VARIANT *pProjects);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MacrosIDE )( 
            _DTE * This,
            /* [retval][out] */ DTE	**pDTE);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RegistryRoot )( 
            _DTE * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [propget][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            _DTE * This,
            /* [retval][out] */ DTE	**pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContextAttributes )( 
            _DTE * This,
            /* [retval][out] */ ContextAttributes **ppVal);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceControl )( 
            _DTE * This,
            /* [retval][out] */ SourceControl **ppVal);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SuppressUI )( 
            _DTE * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SuppressUI )( 
            _DTE * This,
            /* [in] */ VARIANT_BOOL Suppress);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Debugger )( 
            _DTE * This,
            /* [retval][out] */ Debugger **ppDebugger);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SatelliteDLLPath )( 
            _DTE * This,
            BSTR Path,
            BSTR Name,
            /* [retval][out] */ BSTR *pFullPath);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Edition )( 
            _DTE * This,
            /* [retval][out] */ BSTR *ProductEdition);
        
        END_INTERFACE
    } _DTEVtbl;

    interface _DTE
    {
        CONST_VTBL struct _DTEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _DTE_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _DTE_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _DTE_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _DTE_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _DTE_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _DTE_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _DTE_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define _DTE_get_Name(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_Name(This,lpbstrReturn)

#define _DTE_get_FileName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FileName(This,lpbstrReturn)

#define _DTE_get_Version(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_Version(This,lpbstrReturn)

#define _DTE_get_CommandBars(This,ppcbs)	\
    (This)->lpVtbl -> get_CommandBars(This,ppcbs)

#define _DTE_get_Windows(This,ppwnsVBWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppwnsVBWindows)

#define _DTE_get_Events(This,ppevtEvents)	\
    (This)->lpVtbl -> get_Events(This,ppevtEvents)

#define _DTE_get_AddIns(This,lpppAddIns)	\
    (This)->lpVtbl -> get_AddIns(This,lpppAddIns)

#define _DTE_get_MainWindow(This,ppwin)	\
    (This)->lpVtbl -> get_MainWindow(This,ppwin)

#define _DTE_get_ActiveWindow(This,ppwinActive)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppwinActive)

#define _DTE_Quit(This)	\
    (This)->lpVtbl -> Quit(This)

#define _DTE_get_DisplayMode(This,lpDispMode)	\
    (This)->lpVtbl -> get_DisplayMode(This,lpDispMode)

#define _DTE_put_DisplayMode(This,DispMode)	\
    (This)->lpVtbl -> put_DisplayMode(This,DispMode)

#define _DTE_get_Solution(This,ppSolution)	\
    (This)->lpVtbl -> get_Solution(This,ppSolution)

#define _DTE_get_Commands(This,ppCommands)	\
    (This)->lpVtbl -> get_Commands(This,ppCommands)

#define _DTE_GetObject(This,Name,ppObject)	\
    (This)->lpVtbl -> GetObject(This,Name,ppObject)

#define _DTE_get_Properties(This,Category,Page,ppObject)	\
    (This)->lpVtbl -> get_Properties(This,Category,Page,ppObject)

#define _DTE_get_SelectedItems(This,ppSelectedItems)	\
    (This)->lpVtbl -> get_SelectedItems(This,ppSelectedItems)

#define _DTE_get_CommandLineArguments(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_CommandLineArguments(This,lpbstrReturn)

#define _DTE_OpenFile(This,ViewKind,FileName,ppwin)	\
    (This)->lpVtbl -> OpenFile(This,ViewKind,FileName,ppwin)

#define _DTE_get_IsOpenFile(This,ViewKind,FileName,lpfReturn)	\
    (This)->lpVtbl -> get_IsOpenFile(This,ViewKind,FileName,lpfReturn)

#define _DTE_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define _DTE_get_LocaleID(This,lpReturn)	\
    (This)->lpVtbl -> get_LocaleID(This,lpReturn)

#define _DTE_get_WindowConfigurations(This,WindowConfigurationsObject)	\
    (This)->lpVtbl -> get_WindowConfigurations(This,WindowConfigurationsObject)

#define _DTE_get_Documents(This,ppDocuments)	\
    (This)->lpVtbl -> get_Documents(This,ppDocuments)

#define _DTE_get_ActiveDocument(This,ppDocument)	\
    (This)->lpVtbl -> get_ActiveDocument(This,ppDocument)

#define _DTE_ExecuteCommand(This,CommandName,CommandArgs)	\
    (This)->lpVtbl -> ExecuteCommand(This,CommandName,CommandArgs)

#define _DTE_get_Globals(This,ppGlobals)	\
    (This)->lpVtbl -> get_Globals(This,ppGlobals)

#define _DTE_get_StatusBar(This,ppStatusBar)	\
    (This)->lpVtbl -> get_StatusBar(This,ppStatusBar)

#define _DTE_get_FullName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FullName(This,lpbstrReturn)

#define _DTE_get_UserControl(This,UserControl)	\
    (This)->lpVtbl -> get_UserControl(This,UserControl)

#define _DTE_put_UserControl(This,HasControl)	\
    (This)->lpVtbl -> put_UserControl(This,HasControl)

#define _DTE_get_ObjectExtenders(This,ppObjectExtenders)	\
    (This)->lpVtbl -> get_ObjectExtenders(This,ppObjectExtenders)

#define _DTE_get_Find(This,ppFind)	\
    (This)->lpVtbl -> get_Find(This,ppFind)

#define _DTE_get_Mode(This,pVal)	\
    (This)->lpVtbl -> get_Mode(This,pVal)

#define _DTE_LaunchWizard(This,VSZFile,ContextParams,pResult)	\
    (This)->lpVtbl -> LaunchWizard(This,VSZFile,ContextParams,pResult)

#define _DTE_get_ItemOperations(This,ppItemOperations)	\
    (This)->lpVtbl -> get_ItemOperations(This,ppItemOperations)

#define _DTE_get_UndoContext(This,ppUndoContext)	\
    (This)->lpVtbl -> get_UndoContext(This,ppUndoContext)

#define _DTE_get_Macros(This,ppMacros)	\
    (This)->lpVtbl -> get_Macros(This,ppMacros)

#define _DTE_get_ActiveSolutionProjects(This,pProjects)	\
    (This)->lpVtbl -> get_ActiveSolutionProjects(This,pProjects)

#define _DTE_get_MacrosIDE(This,pDTE)	\
    (This)->lpVtbl -> get_MacrosIDE(This,pDTE)

#define _DTE_get_RegistryRoot(This,pVal)	\
    (This)->lpVtbl -> get_RegistryRoot(This,pVal)

#define _DTE_get_Application(This,pVal)	\
    (This)->lpVtbl -> get_Application(This,pVal)

#define _DTE_get_ContextAttributes(This,ppVal)	\
    (This)->lpVtbl -> get_ContextAttributes(This,ppVal)

#define _DTE_get_SourceControl(This,ppVal)	\
    (This)->lpVtbl -> get_SourceControl(This,ppVal)

#define _DTE_get_SuppressUI(This,pVal)	\
    (This)->lpVtbl -> get_SuppressUI(This,pVal)

#define _DTE_put_SuppressUI(This,Suppress)	\
    (This)->lpVtbl -> put_SuppressUI(This,Suppress)

#define _DTE_get_Debugger(This,ppDebugger)	\
    (This)->lpVtbl -> get_Debugger(This,ppDebugger)

#define _DTE_SatelliteDLLPath(This,Path,Name,pFullPath)	\
    (This)->lpVtbl -> SatelliteDLLPath(This,Path,Name,pFullPath)

#define _DTE_get_Edition(This,ProductEdition)	\
    (This)->lpVtbl -> get_Edition(This,ProductEdition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Name_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _DTE_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_FileName_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _DTE_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Version_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _DTE_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_CommandBars_Proxy( 
    _DTE * This,
    /* [retval][out] */ /* external definition not present */ CommandBars **ppcbs);


void __RPC_STUB _DTE_get_CommandBars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Windows_Proxy( 
    _DTE * This,
    /* [retval][out] */ Windows **ppwnsVBWindows);


void __RPC_STUB _DTE_get_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Events_Proxy( 
    _DTE * This,
    /* [retval][out] */ Events **ppevtEvents);


void __RPC_STUB _DTE_get_Events_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_AddIns_Proxy( 
    _DTE * This,
    /* [retval][out] */ AddIns **lpppAddIns);


void __RPC_STUB _DTE_get_AddIns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_MainWindow_Proxy( 
    _DTE * This,
    /* [retval][out] */ Window **ppwin);


void __RPC_STUB _DTE_get_MainWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ActiveWindow_Proxy( 
    _DTE * This,
    /* [retval][out] */ Window **ppwinActive);


void __RPC_STUB _DTE_get_ActiveWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_Quit_Proxy( 
    _DTE * This);


void __RPC_STUB _DTE_Quit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_DisplayMode_Proxy( 
    _DTE * This,
    /* [retval][out] */ vsDisplay *lpDispMode);


void __RPC_STUB _DTE_get_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE _DTE_put_DisplayMode_Proxy( 
    _DTE * This,
    /* [in] */ vsDisplay DispMode);


void __RPC_STUB _DTE_put_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Solution_Proxy( 
    _DTE * This,
    /* [retval][out] */ Solution	**ppSolution);


void __RPC_STUB _DTE_get_Solution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Commands_Proxy( 
    _DTE * This,
    /* [retval][out] */ Commands **ppCommands);


void __RPC_STUB _DTE_get_Commands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_GetObject_Proxy( 
    _DTE * This,
    /* [in] */ BSTR Name,
    /* [retval][out] */ IDispatch **ppObject);


void __RPC_STUB _DTE_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Properties_Proxy( 
    _DTE * This,
    BSTR Category,
    BSTR Page,
    /* [retval][out] */ Properties **ppObject);


void __RPC_STUB _DTE_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_SelectedItems_Proxy( 
    _DTE * This,
    /* [retval][out] */ SelectedItems **ppSelectedItems);


void __RPC_STUB _DTE_get_SelectedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_CommandLineArguments_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _DTE_get_CommandLineArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_OpenFile_Proxy( 
    _DTE * This,
    /* [in] */ BSTR ViewKind,
    /* [in] */ BSTR FileName,
    /* [retval][out] */ Window **ppwin);


void __RPC_STUB _DTE_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_IsOpenFile_Proxy( 
    _DTE * This,
    /* [in] */ BSTR ViewKind,
    /* [in] */ BSTR FileName,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB _DTE_get_IsOpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_DTE_Proxy( 
    _DTE * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB _DTE_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_LocaleID_Proxy( 
    _DTE * This,
    /* [retval][out] */ long *lpReturn);


void __RPC_STUB _DTE_get_LocaleID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_WindowConfigurations_Proxy( 
    _DTE * This,
    /* [retval][out] */ WindowConfigurations **WindowConfigurationsObject);


void __RPC_STUB _DTE_get_WindowConfigurations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Documents_Proxy( 
    _DTE * This,
    /* [retval][out] */ Documents **ppDocuments);


void __RPC_STUB _DTE_get_Documents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ActiveDocument_Proxy( 
    _DTE * This,
    /* [retval][out] */ Document **ppDocument);


void __RPC_STUB _DTE_get_ActiveDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_ExecuteCommand_Proxy( 
    _DTE * This,
    /* [in] */ BSTR CommandName,
    /* [defaultvalue][in] */ BSTR CommandArgs);


void __RPC_STUB _DTE_ExecuteCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Globals_Proxy( 
    _DTE * This,
    /* [retval][out] */ Globals **ppGlobals);


void __RPC_STUB _DTE_get_Globals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_StatusBar_Proxy( 
    _DTE * This,
    /* [retval][out] */ StatusBar **ppStatusBar);


void __RPC_STUB _DTE_get_StatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_FullName_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _DTE_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_UserControl_Proxy( 
    _DTE * This,
    /* [retval][out] */ VARIANT_BOOL *UserControl);


void __RPC_STUB _DTE_get_UserControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE _DTE_put_UserControl_Proxy( 
    _DTE * This,
    /* [in] */ VARIANT_BOOL HasControl);


void __RPC_STUB _DTE_put_UserControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ObjectExtenders_Proxy( 
    _DTE * This,
    /* [retval][out] */ ObjectExtenders **ppObjectExtenders);


void __RPC_STUB _DTE_get_ObjectExtenders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Find_Proxy( 
    _DTE * This,
    /* [retval][out] */ Find **ppFind);


void __RPC_STUB _DTE_get_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Mode_Proxy( 
    _DTE * This,
    /* [retval][out] */ vsIDEMode *pVal);


void __RPC_STUB _DTE_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_LaunchWizard_Proxy( 
    _DTE * This,
    /* [in] */ BSTR VSZFile,
    /* [in] */ SAFEARRAY * *ContextParams,
    /* [retval][out] */ wizardResult *pResult);


void __RPC_STUB _DTE_LaunchWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ItemOperations_Proxy( 
    _DTE * This,
    /* [retval][out] */ ItemOperations **ppItemOperations);


void __RPC_STUB _DTE_get_ItemOperations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_UndoContext_Proxy( 
    _DTE * This,
    /* [retval][out] */ UndoContext **ppUndoContext);


void __RPC_STUB _DTE_get_UndoContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Macros_Proxy( 
    _DTE * This,
    /* [retval][out] */ Macros **ppMacros);


void __RPC_STUB _DTE_get_Macros_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ActiveSolutionProjects_Proxy( 
    _DTE * This,
    /* [retval][out] */ VARIANT *pProjects);


void __RPC_STUB _DTE_get_ActiveSolutionProjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_MacrosIDE_Proxy( 
    _DTE * This,
    /* [retval][out] */ DTE	**pDTE);


void __RPC_STUB _DTE_get_MacrosIDE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_RegistryRoot_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB _DTE_get_RegistryRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][hidden][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Application_Proxy( 
    _DTE * This,
    /* [retval][out] */ DTE	**pVal);


void __RPC_STUB _DTE_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_ContextAttributes_Proxy( 
    _DTE * This,
    /* [retval][out] */ ContextAttributes **ppVal);


void __RPC_STUB _DTE_get_ContextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_SourceControl_Proxy( 
    _DTE * This,
    /* [retval][out] */ SourceControl **ppVal);


void __RPC_STUB _DTE_get_SourceControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_SuppressUI_Proxy( 
    _DTE * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB _DTE_get_SuppressUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE _DTE_put_SuppressUI_Proxy( 
    _DTE * This,
    /* [in] */ VARIANT_BOOL Suppress);


void __RPC_STUB _DTE_put_SuppressUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Debugger_Proxy( 
    _DTE * This,
    /* [retval][out] */ Debugger **ppDebugger);


void __RPC_STUB _DTE_get_Debugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _DTE_SatelliteDLLPath_Proxy( 
    _DTE * This,
    BSTR Path,
    BSTR Name,
    /* [retval][out] */ BSTR *pFullPath);


void __RPC_STUB _DTE_SatelliteDLLPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE _DTE_get_Edition_Proxy( 
    _DTE * This,
    /* [retval][out] */ BSTR *ProductEdition);


void __RPC_STUB _DTE_get_Edition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___DTE_INTERFACE_DEFINED__ */


#ifndef ___Solution_INTERFACE_DEFINED__
#define ___Solution_INTERFACE_DEFINED__

/* interface _Solution */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID__Solution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26f6cc4b-7a48-4e4d-8af5-9e960232e05f")
    _Solution : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ Project **lppcReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            /* [in] */ BSTR FileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromTemplate( 
            /* [in] */ BSTR FileName,
            /* [in] */ BSTR Destination,
            /* [in] */ BSTR ProjectName,
            /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
            /* [retval][out] */ Project **IppptReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromFile( 
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
            /* [retval][out] */ Project **IppptReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR FileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [defaultvalue][in] */ VARIANT_BOOL SaveFirst = 0) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ Properties **ppObject) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsDirty( 
            /* [in] */ VARIANT_BOOL fDirty) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ Project *proj) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_TemplatePath( 
            /* [in] */ BSTR ProjectType,
            /* [retval][out] */ BSTR *lpbstrPath) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Saved( 
            /* [in] */ VARIANT_BOOL fDirty) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Globals( 
            /* [retval][out] */ Globals **ppGlobals) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_AddIns( 
            /* [retval][out] */ AddIns **ppAddIns) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Extender( 
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderNames( 
            /* [retval][out] */ VARIANT *ExtenderNames) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderCATID( 
            /* [retval][out] */ BSTR *pRetval) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SolutionBuild( 
            /* [retval][out] */ SolutionBuild **ppSolutionBuild) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Create( 
            BSTR Destination,
            BSTR Name) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Projects( 
            /* [retval][out] */ Projects **ppProjects) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE FindProjectItem( 
            BSTR FileName,
            /* [retval][out] */ ProjectItem **ppProjectItem) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItemsTemplatePath( 
            BSTR ProjectKind,
            /* [retval][out] */ BSTR *pFullPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _SolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _Solution * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _Solution * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _Solution * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _Solution * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _Solution * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _Solution * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _Solution * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            _Solution * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ Project **lppcReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            _Solution * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            _Solution * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            _Solution * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            _Solution * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            _Solution * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            _Solution * This,
            /* [in] */ BSTR FileName);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromTemplate )( 
            _Solution * This,
            /* [in] */ BSTR FileName,
            /* [in] */ BSTR Destination,
            /* [in] */ BSTR ProjectName,
            /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
            /* [retval][out] */ Project **IppptReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromFile )( 
            _Solution * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
            /* [retval][out] */ Project **IppptReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            _Solution * This,
            /* [in] */ BSTR FileName);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            _Solution * This,
            /* [defaultvalue][in] */ VARIANT_BOOL SaveFirst);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            _Solution * This,
            /* [retval][out] */ Properties **ppObject);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDirty )( 
            _Solution * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsDirty )( 
            _Solution * This,
            /* [in] */ VARIANT_BOOL fDirty);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            _Solution * This,
            /* [in] */ Project *proj);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TemplatePath )( 
            _Solution * This,
            /* [in] */ BSTR ProjectType,
            /* [retval][out] */ BSTR *lpbstrPath);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullName )( 
            _Solution * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Saved )( 
            _Solution * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Saved )( 
            _Solution * This,
            /* [in] */ VARIANT_BOOL fDirty);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Globals )( 
            _Solution * This,
            /* [retval][out] */ Globals **ppGlobals);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AddIns )( 
            _Solution * This,
            /* [retval][out] */ AddIns **ppAddIns);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Extender )( 
            _Solution * This,
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderNames )( 
            _Solution * This,
            /* [retval][out] */ VARIANT *ExtenderNames);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderCATID )( 
            _Solution * This,
            /* [retval][out] */ BSTR *pRetval);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            _Solution * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SolutionBuild )( 
            _Solution * This,
            /* [retval][out] */ SolutionBuild **ppSolutionBuild);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Create )( 
            _Solution * This,
            BSTR Destination,
            BSTR Name);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Projects )( 
            _Solution * This,
            /* [retval][out] */ Projects **ppProjects);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *FindProjectItem )( 
            _Solution * This,
            BSTR FileName,
            /* [retval][out] */ ProjectItem **ppProjectItem);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *ProjectItemsTemplatePath )( 
            _Solution * This,
            BSTR ProjectKind,
            /* [retval][out] */ BSTR *pFullPath);
        
        END_INTERFACE
    } _SolutionVtbl;

    interface _Solution
    {
        CONST_VTBL struct _SolutionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _Solution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _Solution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _Solution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _Solution_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _Solution_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _Solution_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _Solution_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define _Solution_Item(This,index,lppcReturn)	\
    (This)->lpVtbl -> Item(This,index,lppcReturn)

#define _Solution__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define _Solution_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define _Solution_get_Parent(This,lppaReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppaReturn)

#define _Solution_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define _Solution_get_FileName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FileName(This,lpbstrReturn)

#define _Solution_SaveAs(This,FileName)	\
    (This)->lpVtbl -> SaveAs(This,FileName)

#define _Solution_AddFromTemplate(This,FileName,Destination,ProjectName,Exclusive,IppptReturn)	\
    (This)->lpVtbl -> AddFromTemplate(This,FileName,Destination,ProjectName,Exclusive,IppptReturn)

#define _Solution_AddFromFile(This,FileName,Exclusive,IppptReturn)	\
    (This)->lpVtbl -> AddFromFile(This,FileName,Exclusive,IppptReturn)

#define _Solution_Open(This,FileName)	\
    (This)->lpVtbl -> Open(This,FileName)

#define _Solution_Close(This,SaveFirst)	\
    (This)->lpVtbl -> Close(This,SaveFirst)

#define _Solution_get_Properties(This,ppObject)	\
    (This)->lpVtbl -> get_Properties(This,ppObject)

#define _Solution_get_IsDirty(This,lpfReturn)	\
    (This)->lpVtbl -> get_IsDirty(This,lpfReturn)

#define _Solution_put_IsDirty(This,fDirty)	\
    (This)->lpVtbl -> put_IsDirty(This,fDirty)

#define _Solution_Remove(This,proj)	\
    (This)->lpVtbl -> Remove(This,proj)

#define _Solution_get_TemplatePath(This,ProjectType,lpbstrPath)	\
    (This)->lpVtbl -> get_TemplatePath(This,ProjectType,lpbstrPath)

#define _Solution_get_FullName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FullName(This,lpbstrReturn)

#define _Solution_get_Saved(This,lpfReturn)	\
    (This)->lpVtbl -> get_Saved(This,lpfReturn)

#define _Solution_put_Saved(This,fDirty)	\
    (This)->lpVtbl -> put_Saved(This,fDirty)

#define _Solution_get_Globals(This,ppGlobals)	\
    (This)->lpVtbl -> get_Globals(This,ppGlobals)

#define _Solution_get_AddIns(This,ppAddIns)	\
    (This)->lpVtbl -> get_AddIns(This,ppAddIns)

#define _Solution_get_Extender(This,ExtenderName,Extender)	\
    (This)->lpVtbl -> get_Extender(This,ExtenderName,Extender)

#define _Solution_get_ExtenderNames(This,ExtenderNames)	\
    (This)->lpVtbl -> get_ExtenderNames(This,ExtenderNames)

#define _Solution_get_ExtenderCATID(This,pRetval)	\
    (This)->lpVtbl -> get_ExtenderCATID(This,pRetval)

#define _Solution_get_IsOpen(This,pVal)	\
    (This)->lpVtbl -> get_IsOpen(This,pVal)

#define _Solution_get_SolutionBuild(This,ppSolutionBuild)	\
    (This)->lpVtbl -> get_SolutionBuild(This,ppSolutionBuild)

#define _Solution_Create(This,Destination,Name)	\
    (This)->lpVtbl -> Create(This,Destination,Name)

#define _Solution_get_Projects(This,ppProjects)	\
    (This)->lpVtbl -> get_Projects(This,ppProjects)

#define _Solution_FindProjectItem(This,FileName,ppProjectItem)	\
    (This)->lpVtbl -> FindProjectItem(This,FileName,ppProjectItem)

#define _Solution_ProjectItemsTemplatePath(This,ProjectKind,pFullPath)	\
    (This)->lpVtbl -> ProjectItemsTemplatePath(This,ProjectKind,pFullPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_Item_Proxy( 
    _Solution * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ Project **lppcReturn);


void __RPC_STUB _Solution_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE _Solution__NewEnum_Proxy( 
    _Solution * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB _Solution__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_DTE_Proxy( 
    _Solution * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB _Solution_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Parent_Proxy( 
    _Solution * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB _Solution_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Count_Proxy( 
    _Solution * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB _Solution_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_FileName_Proxy( 
    _Solution * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _Solution_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_SaveAs_Proxy( 
    _Solution * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB _Solution_SaveAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_AddFromTemplate_Proxy( 
    _Solution * This,
    /* [in] */ BSTR FileName,
    /* [in] */ BSTR Destination,
    /* [in] */ BSTR ProjectName,
    /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
    /* [retval][out] */ Project **IppptReturn);


void __RPC_STUB _Solution_AddFromTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_AddFromFile_Proxy( 
    _Solution * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ VARIANT_BOOL Exclusive,
    /* [retval][out] */ Project **IppptReturn);


void __RPC_STUB _Solution_AddFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_Open_Proxy( 
    _Solution * This,
    /* [in] */ BSTR FileName);


void __RPC_STUB _Solution_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_Close_Proxy( 
    _Solution * This,
    /* [defaultvalue][in] */ VARIANT_BOOL SaveFirst);


void __RPC_STUB _Solution_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Properties_Proxy( 
    _Solution * This,
    /* [retval][out] */ Properties **ppObject);


void __RPC_STUB _Solution_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_IsDirty_Proxy( 
    _Solution * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB _Solution_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE _Solution_put_IsDirty_Proxy( 
    _Solution * This,
    /* [in] */ VARIANT_BOOL fDirty);


void __RPC_STUB _Solution_put_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_Remove_Proxy( 
    _Solution * This,
    /* [in] */ Project *proj);


void __RPC_STUB _Solution_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_TemplatePath_Proxy( 
    _Solution * This,
    /* [in] */ BSTR ProjectType,
    /* [retval][out] */ BSTR *lpbstrPath);


void __RPC_STUB _Solution_get_TemplatePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_FullName_Proxy( 
    _Solution * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB _Solution_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Saved_Proxy( 
    _Solution * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB _Solution_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE _Solution_put_Saved_Proxy( 
    _Solution * This,
    /* [in] */ VARIANT_BOOL fDirty);


void __RPC_STUB _Solution_put_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Globals_Proxy( 
    _Solution * This,
    /* [retval][out] */ Globals **ppGlobals);


void __RPC_STUB _Solution_get_Globals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_AddIns_Proxy( 
    _Solution * This,
    /* [retval][out] */ AddIns **ppAddIns);


void __RPC_STUB _Solution_get_AddIns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Extender_Proxy( 
    _Solution * This,
    /* [in] */ BSTR ExtenderName,
    /* [retval][out] */ IDispatch **Extender);


void __RPC_STUB _Solution_get_Extender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_ExtenderNames_Proxy( 
    _Solution * This,
    /* [retval][out] */ VARIANT *ExtenderNames);


void __RPC_STUB _Solution_get_ExtenderNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_ExtenderCATID_Proxy( 
    _Solution * This,
    /* [retval][out] */ BSTR *pRetval);


void __RPC_STUB _Solution_get_ExtenderCATID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_IsOpen_Proxy( 
    _Solution * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB _Solution_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_SolutionBuild_Proxy( 
    _Solution * This,
    /* [retval][out] */ SolutionBuild **ppSolutionBuild);


void __RPC_STUB _Solution_get_SolutionBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_Create_Proxy( 
    _Solution * This,
    BSTR Destination,
    BSTR Name);


void __RPC_STUB _Solution_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Solution_get_Projects_Proxy( 
    _Solution * This,
    /* [retval][out] */ Projects **ppProjects);


void __RPC_STUB _Solution_get_Projects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_FindProjectItem_Proxy( 
    _Solution * This,
    BSTR FileName,
    /* [retval][out] */ ProjectItem **ppProjectItem);


void __RPC_STUB _Solution_FindProjectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Solution_ProjectItemsTemplatePath_Proxy( 
    _Solution * This,
    BSTR ProjectKind,
    /* [retval][out] */ BSTR *pFullPath);


void __RPC_STUB _Solution_ProjectItemsTemplatePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* ___Solution_INTERFACE_DEFINED__ */


#ifndef __Projects_INTERFACE_DEFINED__
#define __Projects_INTERFACE_DEFINED__

/* interface Projects */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Projects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e3ec0add-31b3-461f-8303-8a5e6931257a")
    Projects : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ Project **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ Properties **ppObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Kind( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ProjectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Projects * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Projects * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Projects * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Projects * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Projects * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Projects * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Projects * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            Projects * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ Project **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Projects * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            Projects * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            Projects * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            Projects * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            Projects * This,
            /* [retval][out] */ Properties **ppObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Kind )( 
            Projects * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        END_INTERFACE
    } ProjectsVtbl;

    interface Projects
    {
        CONST_VTBL struct ProjectsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Projects_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Projects_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Projects_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Projects_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Projects_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Projects_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Projects_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Projects_Item(This,index,lppcReturn)	\
    (This)->lpVtbl -> Item(This,index,lppcReturn)

#define Projects_get_Parent(This,lppaReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppaReturn)

#define Projects_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define Projects__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define Projects_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define Projects_get_Properties(This,ppObject)	\
    (This)->lpVtbl -> get_Properties(This,ppObject)

#define Projects_get_Kind(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_Kind(This,lpbstrReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Projects_Item_Proxy( 
    Projects * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ Project **lppcReturn);


void __RPC_STUB Projects_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Projects_get_Parent_Proxy( 
    Projects * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Projects_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Projects_get_Count_Proxy( 
    Projects * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB Projects_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE Projects__NewEnum_Proxy( 
    Projects * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB Projects__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Projects_get_DTE_Proxy( 
    Projects * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Projects_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Projects_get_Properties_Proxy( 
    Projects * This,
    /* [retval][out] */ Properties **ppObject);


void __RPC_STUB Projects_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Projects_get_Kind_Proxy( 
    Projects * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB Projects_get_Kind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Projects_INTERFACE_DEFINED__ */


#ifndef __Project_INTERFACE_DEFINED__
#define __Project_INTERFACE_DEFINED__

/* interface Project */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Project;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("866311e6-c887-4143-9833-645f5b93f6f1")
    Project : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *lpbstrName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsDirty( 
            /* [in] */ VARIANT_BOOL Dirty) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ Projects **lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            /* [in] */ BSTR NewFileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Kind( 
            /* [retval][out] */ BSTR *lpbstrFileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProjectItems( 
            /* [retval][out] */ ProjectItems **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ Properties **ppObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_UniqueName( 
            /* [retval][out] */ BSTR *lpbstrFileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Object( 
            /* [retval][out] */ IDispatch **ProjectModel) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Extender( 
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderNames( 
            /* [retval][out] */ VARIANT *ExtenderNames) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderCATID( 
            /* [retval][out] */ BSTR *pRetval) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Saved( 
            /* [in] */ VARIANT_BOOL SavedFlag) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ConfigurationManager( 
            /* [retval][out] */ ConfigurationManager **ppConfigurationManager) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Globals( 
            /* [retval][out] */ Globals **ppGlobals) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [defaultvalue] */ BSTR FileName = L"") = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ParentProjectItem( 
            /* [retval][out] */ ProjectItem **ppParentProjectItem) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_CodeModel( 
            /* [retval][out] */ CodeModel **ppCodeModel) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Project * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Project * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Project * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Project * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Project * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Project * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Project * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            Project * This,
            /* [retval][out] */ BSTR *lpbstrName);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            Project * This,
            /* [in] */ BSTR bstrName);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            Project * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDirty )( 
            Project * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsDirty )( 
            Project * This,
            /* [in] */ VARIANT_BOOL Dirty);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Collection )( 
            Project * This,
            /* [retval][out] */ Projects **lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            Project * This,
            /* [in] */ BSTR NewFileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            Project * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Kind )( 
            Project * This,
            /* [retval][out] */ BSTR *lpbstrFileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ProjectItems )( 
            Project * This,
            /* [retval][out] */ ProjectItems **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            Project * This,
            /* [retval][out] */ Properties **ppObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueName )( 
            Project * This,
            /* [retval][out] */ BSTR *lpbstrFileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Object )( 
            Project * This,
            /* [retval][out] */ IDispatch **ProjectModel);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Extender )( 
            Project * This,
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderNames )( 
            Project * This,
            /* [retval][out] */ VARIANT *ExtenderNames);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderCATID )( 
            Project * This,
            /* [retval][out] */ BSTR *pRetval);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullName )( 
            Project * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Saved )( 
            Project * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Saved )( 
            Project * This,
            /* [in] */ VARIANT_BOOL SavedFlag);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ConfigurationManager )( 
            Project * This,
            /* [retval][out] */ ConfigurationManager **ppConfigurationManager);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Globals )( 
            Project * This,
            /* [retval][out] */ Globals **ppGlobals);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            Project * This,
            /* [defaultvalue] */ BSTR FileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentProjectItem )( 
            Project * This,
            /* [retval][out] */ ProjectItem **ppParentProjectItem);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CodeModel )( 
            Project * This,
            /* [retval][out] */ CodeModel **ppCodeModel);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            Project * This);
        
        END_INTERFACE
    } ProjectVtbl;

    interface Project
    {
        CONST_VTBL struct ProjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Project_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Project_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Project_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Project_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Project_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Project_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Project_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Project_get_Name(This,lpbstrName)	\
    (This)->lpVtbl -> get_Name(This,lpbstrName)

#define Project_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define Project_get_FileName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FileName(This,lpbstrReturn)

#define Project_get_IsDirty(This,lpfReturn)	\
    (This)->lpVtbl -> get_IsDirty(This,lpfReturn)

#define Project_put_IsDirty(This,Dirty)	\
    (This)->lpVtbl -> put_IsDirty(This,Dirty)

#define Project_get_Collection(This,lppaReturn)	\
    (This)->lpVtbl -> get_Collection(This,lppaReturn)

#define Project_SaveAs(This,NewFileName)	\
    (This)->lpVtbl -> SaveAs(This,NewFileName)

#define Project_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define Project_get_Kind(This,lpbstrFileName)	\
    (This)->lpVtbl -> get_Kind(This,lpbstrFileName)

#define Project_get_ProjectItems(This,lppcReturn)	\
    (This)->lpVtbl -> get_ProjectItems(This,lppcReturn)

#define Project_get_Properties(This,ppObject)	\
    (This)->lpVtbl -> get_Properties(This,ppObject)

#define Project_get_UniqueName(This,lpbstrFileName)	\
    (This)->lpVtbl -> get_UniqueName(This,lpbstrFileName)

#define Project_get_Object(This,ProjectModel)	\
    (This)->lpVtbl -> get_Object(This,ProjectModel)

#define Project_get_Extender(This,ExtenderName,Extender)	\
    (This)->lpVtbl -> get_Extender(This,ExtenderName,Extender)

#define Project_get_ExtenderNames(This,ExtenderNames)	\
    (This)->lpVtbl -> get_ExtenderNames(This,ExtenderNames)

#define Project_get_ExtenderCATID(This,pRetval)	\
    (This)->lpVtbl -> get_ExtenderCATID(This,pRetval)

#define Project_get_FullName(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_FullName(This,lpbstrReturn)

#define Project_get_Saved(This,lpfReturn)	\
    (This)->lpVtbl -> get_Saved(This,lpfReturn)

#define Project_put_Saved(This,SavedFlag)	\
    (This)->lpVtbl -> put_Saved(This,SavedFlag)

#define Project_get_ConfigurationManager(This,ppConfigurationManager)	\
    (This)->lpVtbl -> get_ConfigurationManager(This,ppConfigurationManager)

#define Project_get_Globals(This,ppGlobals)	\
    (This)->lpVtbl -> get_Globals(This,ppGlobals)

#define Project_Save(This,FileName)	\
    (This)->lpVtbl -> Save(This,FileName)

#define Project_get_ParentProjectItem(This,ppParentProjectItem)	\
    (This)->lpVtbl -> get_ParentProjectItem(This,ppParentProjectItem)

#define Project_get_CodeModel(This,ppCodeModel)	\
    (This)->lpVtbl -> get_CodeModel(This,ppCodeModel)

#define Project_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Name_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *lpbstrName);


void __RPC_STUB Project_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE Project_put_Name_Proxy( 
    Project * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB Project_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_FileName_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB Project_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_IsDirty_Proxy( 
    Project * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB Project_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE Project_put_IsDirty_Proxy( 
    Project * This,
    /* [in] */ VARIANT_BOOL Dirty);


void __RPC_STUB Project_put_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Collection_Proxy( 
    Project * This,
    /* [retval][out] */ Projects **lppaReturn);


void __RPC_STUB Project_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Project_SaveAs_Proxy( 
    Project * This,
    /* [in] */ BSTR NewFileName);


void __RPC_STUB Project_SaveAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_DTE_Proxy( 
    Project * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Project_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Kind_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *lpbstrFileName);


void __RPC_STUB Project_get_Kind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_ProjectItems_Proxy( 
    Project * This,
    /* [retval][out] */ ProjectItems **lppcReturn);


void __RPC_STUB Project_get_ProjectItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Properties_Proxy( 
    Project * This,
    /* [retval][out] */ Properties **ppObject);


void __RPC_STUB Project_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_UniqueName_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *lpbstrFileName);


void __RPC_STUB Project_get_UniqueName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Object_Proxy( 
    Project * This,
    /* [retval][out] */ IDispatch **ProjectModel);


void __RPC_STUB Project_get_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Extender_Proxy( 
    Project * This,
    /* [in] */ BSTR ExtenderName,
    /* [retval][out] */ IDispatch **Extender);


void __RPC_STUB Project_get_Extender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_ExtenderNames_Proxy( 
    Project * This,
    /* [retval][out] */ VARIANT *ExtenderNames);


void __RPC_STUB Project_get_ExtenderNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_ExtenderCATID_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *pRetval);


void __RPC_STUB Project_get_ExtenderCATID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_FullName_Proxy( 
    Project * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB Project_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Saved_Proxy( 
    Project * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB Project_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE Project_put_Saved_Proxy( 
    Project * This,
    /* [in] */ VARIANT_BOOL SavedFlag);


void __RPC_STUB Project_put_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_ConfigurationManager_Proxy( 
    Project * This,
    /* [retval][out] */ ConfigurationManager **ppConfigurationManager);


void __RPC_STUB Project_get_ConfigurationManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_Globals_Proxy( 
    Project * This,
    /* [retval][out] */ Globals **ppGlobals);


void __RPC_STUB Project_get_Globals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Project_Save_Proxy( 
    Project * This,
    /* [defaultvalue] */ BSTR FileName);


void __RPC_STUB Project_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_ParentProjectItem_Proxy( 
    Project * This,
    /* [retval][out] */ ProjectItem **ppParentProjectItem);


void __RPC_STUB Project_get_ParentProjectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Project_get_CodeModel_Proxy( 
    Project * This,
    /* [retval][out] */ CodeModel **ppCodeModel);


void __RPC_STUB Project_get_CodeModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Project_Delete_Proxy( 
    Project * This);


void __RPC_STUB Project_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Project_INTERFACE_DEFINED__ */


#ifndef __ProjectItems_INTERFACE_DEFINED__
#define __ProjectItems_INTERFACE_DEFINED__

/* interface ProjectItems */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_ProjectItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8e2f1269-185e-43c7-8899-950ad2769ccf")
    ProjectItems : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ ProjectItem **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch **lppptReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Kind( 
            /* [retval][out] */ BSTR *lpbstrFileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromFile( 
            /* [in] */ BSTR FileName,
            /* [retval][out] */ ProjectItem **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromTemplate( 
            /* [in] */ BSTR FileName,
            /* [in] */ BSTR Name,
            /* [retval][out] */ ProjectItem **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromDirectory( 
            /* [in] */ BSTR Directory,
            /* [retval][out] */ ProjectItem **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContainingProject( 
            /* [retval][out] */ Project **ppProject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFolder( 
            BSTR Name,
            /* [defaultvalue] */ BSTR Kind,
            /* [retval][out] */ ProjectItem **pProjectItem) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromFileCopy( 
            BSTR FilePath,
            /* [retval][out] */ ProjectItem **pProjectItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ProjectItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ProjectItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ProjectItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ProjectItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ProjectItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ProjectItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ProjectItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ProjectItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            ProjectItems * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ ProjectItem **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            ProjectItems * This,
            /* [retval][out] */ IDispatch **lppptReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ProjectItems * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            ProjectItems * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            ProjectItems * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Kind )( 
            ProjectItems * This,
            /* [retval][out] */ BSTR *lpbstrFileName);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromFile )( 
            ProjectItems * This,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ ProjectItem **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromTemplate )( 
            ProjectItems * This,
            /* [in] */ BSTR FileName,
            /* [in] */ BSTR Name,
            /* [retval][out] */ ProjectItem **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromDirectory )( 
            ProjectItems * This,
            /* [in] */ BSTR Directory,
            /* [retval][out] */ ProjectItem **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContainingProject )( 
            ProjectItems * This,
            /* [retval][out] */ Project **ppProject);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFolder )( 
            ProjectItems * This,
            BSTR Name,
            /* [defaultvalue] */ BSTR Kind,
            /* [retval][out] */ ProjectItem **pProjectItem);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromFileCopy )( 
            ProjectItems * This,
            BSTR FilePath,
            /* [retval][out] */ ProjectItem **pProjectItem);
        
        END_INTERFACE
    } ProjectItemsVtbl;

    interface ProjectItems
    {
        CONST_VTBL struct ProjectItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ProjectItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ProjectItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ProjectItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ProjectItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ProjectItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ProjectItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ProjectItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ProjectItems_Item(This,index,lppcReturn)	\
    (This)->lpVtbl -> Item(This,index,lppcReturn)

#define ProjectItems_get_Parent(This,lppptReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppptReturn)

#define ProjectItems_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define ProjectItems__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define ProjectItems_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define ProjectItems_get_Kind(This,lpbstrFileName)	\
    (This)->lpVtbl -> get_Kind(This,lpbstrFileName)

#define ProjectItems_AddFromFile(This,FileName,lppcReturn)	\
    (This)->lpVtbl -> AddFromFile(This,FileName,lppcReturn)

#define ProjectItems_AddFromTemplate(This,FileName,Name,lppcReturn)	\
    (This)->lpVtbl -> AddFromTemplate(This,FileName,Name,lppcReturn)

#define ProjectItems_AddFromDirectory(This,Directory,lppcReturn)	\
    (This)->lpVtbl -> AddFromDirectory(This,Directory,lppcReturn)

#define ProjectItems_get_ContainingProject(This,ppProject)	\
    (This)->lpVtbl -> get_ContainingProject(This,ppProject)

#define ProjectItems_AddFolder(This,Name,Kind,pProjectItem)	\
    (This)->lpVtbl -> AddFolder(This,Name,Kind,pProjectItem)

#define ProjectItems_AddFromFileCopy(This,FilePath,pProjectItem)	\
    (This)->lpVtbl -> AddFromFileCopy(This,FilePath,pProjectItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_Item_Proxy( 
    ProjectItems * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ ProjectItem **lppcReturn);


void __RPC_STUB ProjectItems_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_get_Parent_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ IDispatch **lppptReturn);


void __RPC_STUB ProjectItems_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_get_Count_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB ProjectItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE ProjectItems__NewEnum_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB ProjectItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_get_DTE_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB ProjectItems_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_get_Kind_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ BSTR *lpbstrFileName);


void __RPC_STUB ProjectItems_get_Kind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_AddFromFile_Proxy( 
    ProjectItems * This,
    /* [in] */ BSTR FileName,
    /* [retval][out] */ ProjectItem **lppcReturn);


void __RPC_STUB ProjectItems_AddFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_AddFromTemplate_Proxy( 
    ProjectItems * This,
    /* [in] */ BSTR FileName,
    /* [in] */ BSTR Name,
    /* [retval][out] */ ProjectItem **lppcReturn);


void __RPC_STUB ProjectItems_AddFromTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_AddFromDirectory_Proxy( 
    ProjectItems * This,
    /* [in] */ BSTR Directory,
    /* [retval][out] */ ProjectItem **lppcReturn);


void __RPC_STUB ProjectItems_AddFromDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_get_ContainingProject_Proxy( 
    ProjectItems * This,
    /* [retval][out] */ Project **ppProject);


void __RPC_STUB ProjectItems_get_ContainingProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_AddFolder_Proxy( 
    ProjectItems * This,
    BSTR Name,
    /* [defaultvalue] */ BSTR Kind,
    /* [retval][out] */ ProjectItem **pProjectItem);


void __RPC_STUB ProjectItems_AddFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItems_AddFromFileCopy_Proxy( 
    ProjectItems * This,
    BSTR FilePath,
    /* [retval][out] */ ProjectItem **pProjectItem);


void __RPC_STUB ProjectItems_AddFromFileCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ProjectItems_INTERFACE_DEFINED__ */


#ifndef __ProjectItem_INTERFACE_DEFINED__
#define __ProjectItem_INTERFACE_DEFINED__

/* interface ProjectItem */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_ProjectItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0b48100a-473e-433c-ab8f-66b9739ab620")
    ProjectItem : public IDispatch
    {
    public:
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDirty( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_IsDirty( 
            /* [in] */ VARIANT_BOOL DirtyFlag) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileNames( 
            /* [in] */ short Index,
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            /* [in] */ BSTR NewFileName,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileCount( 
            /* [retval][out] */ short *lpsReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ ProjectItems **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ Properties **ppObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Kind( 
            /* [retval][out] */ BSTR *lpbstrFileName) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProjectItems( 
            /* [retval][out] */ ProjectItems **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsOpen( 
            /* [defaultvalue][in] */ BSTR ViewKind,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [defaultvalue][in] */ BSTR ViewKind,
            /* [retval][out] */ Window **lppfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ExpandView( void) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Object( 
            /* [retval][out] */ IDispatch **ProjectItemModel) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Extender( 
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderNames( 
            /* [retval][out] */ VARIANT *ExtenderNames) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExtenderCATID( 
            /* [retval][out] */ BSTR *pRetval) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ VARIANT_BOOL *lpfReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Saved( 
            /* [in] */ VARIANT_BOOL SavedFlag) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ConfigurationManager( 
            /* [retval][out] */ ConfigurationManager **ppConfigurationManager) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileCodeModel( 
            /* [retval][out] */ FileCodeModel **ppFileCodeModel) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [defaultvalue] */ BSTR FileName = L"") = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Document( 
            /* [retval][out] */ Document **ppDocument) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SubProject( 
            /* [retval][out] */ Project **ppProject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContainingProject( 
            /* [retval][out] */ Project **ppProject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ProjectItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ProjectItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ProjectItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ProjectItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ProjectItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ProjectItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ProjectItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ProjectItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDirty )( 
            ProjectItem * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsDirty )( 
            ProjectItem * This,
            /* [in] */ VARIANT_BOOL DirtyFlag);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileNames )( 
            ProjectItem * This,
            /* [in] */ short Index,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            ProjectItem * This,
            /* [in] */ BSTR NewFileName,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileCount )( 
            ProjectItem * This,
            /* [retval][out] */ short *lpsReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ProjectItem * This,
            /* [retval][out] */ BSTR *pbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            ProjectItem * This,
            /* [in] */ BSTR bstrName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Collection )( 
            ProjectItem * This,
            /* [retval][out] */ ProjectItems **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            ProjectItem * This,
            /* [retval][out] */ Properties **ppObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            ProjectItem * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Kind )( 
            ProjectItem * This,
            /* [retval][out] */ BSTR *lpbstrFileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ProjectItems )( 
            ProjectItem * This,
            /* [retval][out] */ ProjectItems **lppcReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsOpen )( 
            ProjectItem * This,
            /* [defaultvalue][in] */ BSTR ViewKind,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            ProjectItem * This,
            /* [defaultvalue][in] */ BSTR ViewKind,
            /* [retval][out] */ Window **lppfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ProjectItem * This);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *ExpandView )( 
            ProjectItem * This);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Object )( 
            ProjectItem * This,
            /* [retval][out] */ IDispatch **ProjectItemModel);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Extender )( 
            ProjectItem * This,
            /* [in] */ BSTR ExtenderName,
            /* [retval][out] */ IDispatch **Extender);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderNames )( 
            ProjectItem * This,
            /* [retval][out] */ VARIANT *ExtenderNames);
        
        /* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExtenderCATID )( 
            ProjectItem * This,
            /* [retval][out] */ BSTR *pRetval);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Saved )( 
            ProjectItem * This,
            /* [retval][out] */ VARIANT_BOOL *lpfReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Saved )( 
            ProjectItem * This,
            /* [in] */ VARIANT_BOOL SavedFlag);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ConfigurationManager )( 
            ProjectItem * This,
            /* [retval][out] */ ConfigurationManager **ppConfigurationManager);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileCodeModel )( 
            ProjectItem * This,
            /* [retval][out] */ FileCodeModel **ppFileCodeModel);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Save )( 
            ProjectItem * This,
            /* [defaultvalue] */ BSTR FileName);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Document )( 
            ProjectItem * This,
            /* [retval][out] */ Document **ppDocument);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SubProject )( 
            ProjectItem * This,
            /* [retval][out] */ Project **ppProject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContainingProject )( 
            ProjectItem * This,
            /* [retval][out] */ Project **ppProject);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            ProjectItem * This);
        
        END_INTERFACE
    } ProjectItemVtbl;

    interface ProjectItem
    {
        CONST_VTBL struct ProjectItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ProjectItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ProjectItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ProjectItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ProjectItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ProjectItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ProjectItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ProjectItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ProjectItem_get_IsDirty(This,lpfReturn)	\
    (This)->lpVtbl -> get_IsDirty(This,lpfReturn)

#define ProjectItem_put_IsDirty(This,DirtyFlag)	\
    (This)->lpVtbl -> put_IsDirty(This,DirtyFlag)

#define ProjectItem_get_FileNames(This,Index,lpbstrReturn)	\
    (This)->lpVtbl -> get_FileNames(This,Index,lpbstrReturn)

#define ProjectItem_SaveAs(This,NewFileName,lpfReturn)	\
    (This)->lpVtbl -> SaveAs(This,NewFileName,lpfReturn)

#define ProjectItem_get_FileCount(This,lpsReturn)	\
    (This)->lpVtbl -> get_FileCount(This,lpsReturn)

#define ProjectItem_get_Name(This,pbstrReturn)	\
    (This)->lpVtbl -> get_Name(This,pbstrReturn)

#define ProjectItem_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)

#define ProjectItem_get_Collection(This,lppcReturn)	\
    (This)->lpVtbl -> get_Collection(This,lppcReturn)

#define ProjectItem_get_Properties(This,ppObject)	\
    (This)->lpVtbl -> get_Properties(This,ppObject)

#define ProjectItem_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define ProjectItem_get_Kind(This,lpbstrFileName)	\
    (This)->lpVtbl -> get_Kind(This,lpbstrFileName)

#define ProjectItem_get_ProjectItems(This,lppcReturn)	\
    (This)->lpVtbl -> get_ProjectItems(This,lppcReturn)

#define ProjectItem_get_IsOpen(This,ViewKind,lpfReturn)	\
    (This)->lpVtbl -> get_IsOpen(This,ViewKind,lpfReturn)

#define ProjectItem_Open(This,ViewKind,lppfReturn)	\
    (This)->lpVtbl -> Open(This,ViewKind,lppfReturn)

#define ProjectItem_Remove(This)	\
    (This)->lpVtbl -> Remove(This)

#define ProjectItem_ExpandView(This)	\
    (This)->lpVtbl -> ExpandView(This)

#define ProjectItem_get_Object(This,ProjectItemModel)	\
    (This)->lpVtbl -> get_Object(This,ProjectItemModel)

#define ProjectItem_get_Extender(This,ExtenderName,Extender)	\
    (This)->lpVtbl -> get_Extender(This,ExtenderName,Extender)

#define ProjectItem_get_ExtenderNames(This,ExtenderNames)	\
    (This)->lpVtbl -> get_ExtenderNames(This,ExtenderNames)

#define ProjectItem_get_ExtenderCATID(This,pRetval)	\
    (This)->lpVtbl -> get_ExtenderCATID(This,pRetval)

#define ProjectItem_get_Saved(This,lpfReturn)	\
    (This)->lpVtbl -> get_Saved(This,lpfReturn)

#define ProjectItem_put_Saved(This,SavedFlag)	\
    (This)->lpVtbl -> put_Saved(This,SavedFlag)

#define ProjectItem_get_ConfigurationManager(This,ppConfigurationManager)	\
    (This)->lpVtbl -> get_ConfigurationManager(This,ppConfigurationManager)

#define ProjectItem_get_FileCodeModel(This,ppFileCodeModel)	\
    (This)->lpVtbl -> get_FileCodeModel(This,ppFileCodeModel)

#define ProjectItem_Save(This,FileName)	\
    (This)->lpVtbl -> Save(This,FileName)

#define ProjectItem_get_Document(This,ppDocument)	\
    (This)->lpVtbl -> get_Document(This,ppDocument)

#define ProjectItem_get_SubProject(This,ppProject)	\
    (This)->lpVtbl -> get_SubProject(This,ppProject)

#define ProjectItem_get_ContainingProject(This,ppProject)	\
    (This)->lpVtbl -> get_ContainingProject(This,ppProject)

#define ProjectItem_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_IsDirty_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB ProjectItem_get_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_put_IsDirty_Proxy( 
    ProjectItem * This,
    /* [in] */ VARIANT_BOOL DirtyFlag);


void __RPC_STUB ProjectItem_put_IsDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_FileNames_Proxy( 
    ProjectItem * This,
    /* [in] */ short Index,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB ProjectItem_get_FileNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_SaveAs_Proxy( 
    ProjectItem * This,
    /* [in] */ BSTR NewFileName,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB ProjectItem_SaveAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_FileCount_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ short *lpsReturn);


void __RPC_STUB ProjectItem_get_FileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Name_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ BSTR *pbstrReturn);


void __RPC_STUB ProjectItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_put_Name_Proxy( 
    ProjectItem * This,
    /* [in] */ BSTR bstrName);


void __RPC_STUB ProjectItem_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Collection_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ ProjectItems **lppcReturn);


void __RPC_STUB ProjectItem_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Properties_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ Properties **ppObject);


void __RPC_STUB ProjectItem_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_DTE_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB ProjectItem_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Kind_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ BSTR *lpbstrFileName);


void __RPC_STUB ProjectItem_get_Kind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_ProjectItems_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ ProjectItems **lppcReturn);


void __RPC_STUB ProjectItem_get_ProjectItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_IsOpen_Proxy( 
    ProjectItem * This,
    /* [defaultvalue][in] */ BSTR ViewKind,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB ProjectItem_get_IsOpen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_Open_Proxy( 
    ProjectItem * This,
    /* [defaultvalue][in] */ BSTR ViewKind,
    /* [retval][out] */ Window **lppfReturn);


void __RPC_STUB ProjectItem_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_Remove_Proxy( 
    ProjectItem * This);


void __RPC_STUB ProjectItem_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_ExpandView_Proxy( 
    ProjectItem * This);


void __RPC_STUB ProjectItem_ExpandView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Object_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ IDispatch **ProjectItemModel);


void __RPC_STUB ProjectItem_get_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Extender_Proxy( 
    ProjectItem * This,
    /* [in] */ BSTR ExtenderName,
    /* [retval][out] */ IDispatch **Extender);


void __RPC_STUB ProjectItem_get_Extender_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_ExtenderNames_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ VARIANT *ExtenderNames);


void __RPC_STUB ProjectItem_get_ExtenderNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][nonbrowsable][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_ExtenderCATID_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ BSTR *pRetval);


void __RPC_STUB ProjectItem_get_ExtenderCATID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Saved_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ VARIANT_BOOL *lpfReturn);


void __RPC_STUB ProjectItem_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_put_Saved_Proxy( 
    ProjectItem * This,
    /* [in] */ VARIANT_BOOL SavedFlag);


void __RPC_STUB ProjectItem_put_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_ConfigurationManager_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ ConfigurationManager **ppConfigurationManager);


void __RPC_STUB ProjectItem_get_ConfigurationManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_FileCodeModel_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ FileCodeModel **ppFileCodeModel);


void __RPC_STUB ProjectItem_get_FileCodeModel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_Save_Proxy( 
    ProjectItem * This,
    /* [defaultvalue] */ BSTR FileName);


void __RPC_STUB ProjectItem_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_Document_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ Document **ppDocument);


void __RPC_STUB ProjectItem_get_Document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_SubProject_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ Project **ppProject);


void __RPC_STUB ProjectItem_get_SubProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_get_ContainingProject_Proxy( 
    ProjectItem * This,
    /* [retval][out] */ Project **ppProject);


void __RPC_STUB ProjectItem_get_ContainingProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE ProjectItem_Delete_Proxy( 
    ProjectItem * This);


void __RPC_STUB ProjectItem_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ProjectItem_INTERFACE_DEFINED__ */


#ifndef __Commands_INTERFACE_DEFINED__
#define __Commands_INTERFACE_DEFINED__

/* interface Commands */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Commands;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6b96cac-b8c7-40ae-b705-5c81878c4a9e")
    Commands : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Guid,
            /* [in] */ long ID,
            /* [in] */ VARIANT *Control) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Raise( 
            /* [in] */ BSTR Guid,
            /* [in] */ long ID,
            /* [out][in] */ VARIANT *CustomIn,
            /* [out][in] */ VARIANT *CustomOut) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CommandInfo( 
            /* [in] */ IDispatch *CommandBarControl,
            /* [out] */ BSTR *Guid,
            /* [out] */ long *ID) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [defaultvalue][in] */ long ID,
            /* [retval][out] */ Command **lppcReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddNamedCommand( 
            /* [in] */ AddIn *AddInInstance,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ButtonText,
            /* [in] */ BSTR Tooltip,
            /* [in] */ VARIANT_BOOL MSOButton,
            /* [defaultvalue][in] */ long Bitmap,
            /* [optional][in] */ SAFEARRAY * *ContextUIGUIDs,
            /* [defaultvalue][in] */ long vsCommandDisabledFlagsValue,
            /* [retval][out] */ Command **pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddCommandBar( 
            /* [in] */ BSTR Name,
            /* [in] */ vsCommandBarType Type,
            /* [defaultvalue][in] */ /* external definition not present */ CommandBar *CommandBarParent,
            /* [defaultvalue][in] */ long Position,
            /* [retval][out] */ IDispatch **pVal) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE RemoveCommandBar( 
            /* [in] */ /* external definition not present */ CommandBar *CommandBar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct CommandsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Commands * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Commands * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Commands * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Commands * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Commands * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Commands * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Commands * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            Commands * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Commands * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            Commands * This,
            /* [in] */ BSTR Guid,
            /* [in] */ long ID,
            /* [in] */ VARIANT *Control);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Raise )( 
            Commands * This,
            /* [in] */ BSTR Guid,
            /* [in] */ long ID,
            /* [out][in] */ VARIANT *CustomIn,
            /* [out][in] */ VARIANT *CustomOut);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *CommandInfo )( 
            Commands * This,
            /* [in] */ IDispatch *CommandBarControl,
            /* [out] */ BSTR *Guid,
            /* [out] */ long *ID);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            Commands * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            Commands * This,
            /* [in] */ VARIANT Index,
            /* [defaultvalue][in] */ long ID,
            /* [retval][out] */ Command **lppcReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            Commands * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddNamedCommand )( 
            Commands * This,
            /* [in] */ AddIn *AddInInstance,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ButtonText,
            /* [in] */ BSTR Tooltip,
            /* [in] */ VARIANT_BOOL MSOButton,
            /* [defaultvalue][in] */ long Bitmap,
            /* [optional][in] */ SAFEARRAY * *ContextUIGUIDs,
            /* [defaultvalue][in] */ long vsCommandDisabledFlagsValue,
            /* [retval][out] */ Command **pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddCommandBar )( 
            Commands * This,
            /* [in] */ BSTR Name,
            /* [in] */ vsCommandBarType Type,
            /* [defaultvalue][in] */ /* external definition not present */ CommandBar *CommandBarParent,
            /* [defaultvalue][in] */ long Position,
            /* [retval][out] */ IDispatch **pVal);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveCommandBar )( 
            Commands * This,
            /* [in] */ /* external definition not present */ CommandBar *CommandBar);
        
        END_INTERFACE
    } CommandsVtbl;

    interface Commands
    {
        CONST_VTBL struct CommandsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Commands_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Commands_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Commands_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Commands_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Commands_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Commands_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Commands_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Commands_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define Commands_get_Parent(This,lppaReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppaReturn)

#define Commands_Add(This,Guid,ID,Control)	\
    (This)->lpVtbl -> Add(This,Guid,ID,Control)

#define Commands_Raise(This,Guid,ID,CustomIn,CustomOut)	\
    (This)->lpVtbl -> Raise(This,Guid,ID,CustomIn,CustomOut)

#define Commands_CommandInfo(This,CommandBarControl,Guid,ID)	\
    (This)->lpVtbl -> CommandInfo(This,CommandBarControl,Guid,ID)

#define Commands_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define Commands_Item(This,Index,ID,lppcReturn)	\
    (This)->lpVtbl -> Item(This,Index,ID,lppcReturn)

#define Commands__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define Commands_AddNamedCommand(This,AddInInstance,Name,ButtonText,Tooltip,MSOButton,Bitmap,ContextUIGUIDs,vsCommandDisabledFlagsValue,pVal)	\
    (This)->lpVtbl -> AddNamedCommand(This,AddInInstance,Name,ButtonText,Tooltip,MSOButton,Bitmap,ContextUIGUIDs,vsCommandDisabledFlagsValue,pVal)

#define Commands_AddCommandBar(This,Name,Type,CommandBarParent,Position,pVal)	\
    (This)->lpVtbl -> AddCommandBar(This,Name,Type,CommandBarParent,Position,pVal)

#define Commands_RemoveCommandBar(This,CommandBar)	\
    (This)->lpVtbl -> RemoveCommandBar(This,CommandBar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Commands_get_DTE_Proxy( 
    Commands * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Commands_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Commands_get_Parent_Proxy( 
    Commands * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Commands_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_Add_Proxy( 
    Commands * This,
    /* [in] */ BSTR Guid,
    /* [in] */ long ID,
    /* [in] */ VARIANT *Control);


void __RPC_STUB Commands_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_Raise_Proxy( 
    Commands * This,
    /* [in] */ BSTR Guid,
    /* [in] */ long ID,
    /* [out][in] */ VARIANT *CustomIn,
    /* [out][in] */ VARIANT *CustomOut);


void __RPC_STUB Commands_Raise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_CommandInfo_Proxy( 
    Commands * This,
    /* [in] */ IDispatch *CommandBarControl,
    /* [out] */ BSTR *Guid,
    /* [out] */ long *ID);


void __RPC_STUB Commands_CommandInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Commands_get_Count_Proxy( 
    Commands * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB Commands_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_Item_Proxy( 
    Commands * This,
    /* [in] */ VARIANT Index,
    /* [defaultvalue][in] */ long ID,
    /* [retval][out] */ Command **lppcReturn);


void __RPC_STUB Commands_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE Commands__NewEnum_Proxy( 
    Commands * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB Commands__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_AddNamedCommand_Proxy( 
    Commands * This,
    /* [in] */ AddIn *AddInInstance,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR ButtonText,
    /* [in] */ BSTR Tooltip,
    /* [in] */ VARIANT_BOOL MSOButton,
    /* [defaultvalue][in] */ long Bitmap,
    /* [optional][in] */ SAFEARRAY * *ContextUIGUIDs,
    /* [defaultvalue][in] */ long vsCommandDisabledFlagsValue,
    /* [retval][out] */ Command **pVal);


void __RPC_STUB Commands_AddNamedCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_AddCommandBar_Proxy( 
    Commands * This,
    /* [in] */ BSTR Name,
    /* [in] */ vsCommandBarType Type,
    /* [defaultvalue][in] */ /* external definition not present */ CommandBar *CommandBarParent,
    /* [defaultvalue][in] */ long Position,
    /* [retval][out] */ IDispatch **pVal);


void __RPC_STUB Commands_AddCommandBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Commands_RemoveCommandBar_Proxy( 
    Commands * This,
    /* [in] */ /* external definition not present */ CommandBar *CommandBar);


void __RPC_STUB Commands_RemoveCommandBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Commands_INTERFACE_DEFINED__ */


#ifndef __TextBuffer_INTERFACE_DEFINED__
#define __TextBuffer_INTERFACE_DEFINED__

/* interface TextBuffer */
/* [hidden][helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_TextBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f47dc7e7-84b6-474f-bb91-631640aa0560")
    TextBuffer : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ Window **retval) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromString( 
            /* [in] */ BSTR String,
            /* [defaultvalue][in] */ long StartLine = 1) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddFromFile( 
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ long StartLine = 1) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Lines( 
            /* [in] */ long StartLine,
            /* [in] */ long Count,
            /* [retval][out] */ BSTR *String) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_CountOfLines( 
            /* [retval][out] */ long *CountOfLines) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE DeleteLines( 
            /* [in] */ long StartLine,
            /* [defaultvalue][in] */ long Count = 1) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ BSTR Target,
            /* [out][in] */ long *StartLine,
            /* [out][in] */ long *StartColumn,
            /* [out][in] */ long *EndLine,
            /* [out][in] */ long *EndColumn,
            /* [defaultvalue][in] */ VARIANT_BOOL WholeWord,
            /* [defaultvalue][in] */ VARIANT_BOOL MatchCase,
            /* [defaultvalue][in] */ VARIANT_BOOL PatternSearch,
            /* [retval][out] */ VARIANT_BOOL *pfFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct TextBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            TextBuffer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            TextBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            TextBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            TextBuffer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            TextBuffer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            TextBuffer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            TextBuffer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            TextBuffer * This,
            /* [retval][out] */ Window **retval);
        
        /* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            TextBuffer * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromString )( 
            TextBuffer * This,
            /* [in] */ BSTR String,
            /* [defaultvalue][in] */ long StartLine);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *AddFromFile )( 
            TextBuffer * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ long StartLine);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Lines )( 
            TextBuffer * This,
            /* [in] */ long StartLine,
            /* [in] */ long Count,
            /* [retval][out] */ BSTR *String);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CountOfLines )( 
            TextBuffer * This,
            /* [retval][out] */ long *CountOfLines);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteLines )( 
            TextBuffer * This,
            /* [in] */ long StartLine,
            /* [defaultvalue][in] */ long Count);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Find )( 
            TextBuffer * This,
            /* [in] */ BSTR Target,
            /* [out][in] */ long *StartLine,
            /* [out][in] */ long *StartColumn,
            /* [out][in] */ long *EndLine,
            /* [out][in] */ long *EndColumn,
            /* [defaultvalue][in] */ VARIANT_BOOL WholeWord,
            /* [defaultvalue][in] */ VARIANT_BOOL MatchCase,
            /* [defaultvalue][in] */ VARIANT_BOOL PatternSearch,
            /* [retval][out] */ VARIANT_BOOL *pfFound);
        
        END_INTERFACE
    } TextBufferVtbl;

    interface TextBuffer
    {
        CONST_VTBL struct TextBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define TextBuffer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define TextBuffer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define TextBuffer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define TextBuffer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define TextBuffer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define TextBuffer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define TextBuffer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define TextBuffer_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define TextBuffer_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define TextBuffer_AddFromString(This,String,StartLine)	\
    (This)->lpVtbl -> AddFromString(This,String,StartLine)

#define TextBuffer_AddFromFile(This,FileName,StartLine)	\
    (This)->lpVtbl -> AddFromFile(This,FileName,StartLine)

#define TextBuffer_get_Lines(This,StartLine,Count,String)	\
    (This)->lpVtbl -> get_Lines(This,StartLine,Count,String)

#define TextBuffer_get_CountOfLines(This,CountOfLines)	\
    (This)->lpVtbl -> get_CountOfLines(This,CountOfLines)

#define TextBuffer_DeleteLines(This,StartLine,Count)	\
    (This)->lpVtbl -> DeleteLines(This,StartLine,Count)

#define TextBuffer_Find(This,Target,StartLine,StartColumn,EndLine,EndColumn,WholeWord,MatchCase,PatternSearch,pfFound)	\
    (This)->lpVtbl -> Find(This,Target,StartLine,StartColumn,EndLine,EndColumn,WholeWord,MatchCase,PatternSearch,pfFound)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE TextBuffer_get_Parent_Proxy( 
    TextBuffer * This,
    /* [retval][out] */ Window **retval);


void __RPC_STUB TextBuffer_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE TextBuffer_get_DTE_Proxy( 
    TextBuffer * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB TextBuffer_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_AddFromString_Proxy( 
    TextBuffer * This,
    /* [in] */ BSTR String,
    /* [defaultvalue][in] */ long StartLine);


void __RPC_STUB TextBuffer_AddFromString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_AddFromFile_Proxy( 
    TextBuffer * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ long StartLine);


void __RPC_STUB TextBuffer_AddFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_get_Lines_Proxy( 
    TextBuffer * This,
    /* [in] */ long StartLine,
    /* [in] */ long Count,
    /* [retval][out] */ BSTR *String);


void __RPC_STUB TextBuffer_get_Lines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_get_CountOfLines_Proxy( 
    TextBuffer * This,
    /* [retval][out] */ long *CountOfLines);


void __RPC_STUB TextBuffer_get_CountOfLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_DeleteLines_Proxy( 
    TextBuffer * This,
    /* [in] */ long StartLine,
    /* [defaultvalue][in] */ long Count);


void __RPC_STUB TextBuffer_DeleteLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE TextBuffer_Find_Proxy( 
    TextBuffer * This,
    /* [in] */ BSTR Target,
    /* [out][in] */ long *StartLine,
    /* [out][in] */ long *StartColumn,
    /* [out][in] */ long *EndLine,
    /* [out][in] */ long *EndColumn,
    /* [defaultvalue][in] */ VARIANT_BOOL WholeWord,
    /* [defaultvalue][in] */ VARIANT_BOOL MatchCase,
    /* [defaultvalue][in] */ VARIANT_BOOL PatternSearch,
    /* [retval][out] */ VARIANT_BOOL *pfFound);


void __RPC_STUB TextBuffer_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __TextBuffer_INTERFACE_DEFINED__ */


#ifndef __AddIns_INTERFACE_DEFINED__
#define __AddIns_INTERFACE_DEFINED__

/* interface AddIns */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_AddIns;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50590801-d13e-4404-80c2-5ca30a4d0ee8")
    AddIns : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ AddIn **lppaddin) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch **lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Update( void) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Add( 
            BSTR ProgID,
            BSTR Description,
            BSTR Name,
            VARIANT_BOOL Connected,
            /* [retval][out] */ AddIn **__MIDL_0011) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AddInsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AddIns * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AddIns * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AddIns * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            AddIns * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            AddIns * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            AddIns * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            AddIns * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            AddIns * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ AddIn **lppaddin);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            AddIns * This,
            /* [retval][out] */ IDispatch **lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            AddIns * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            AddIns * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            AddIns * This);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            AddIns * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            AddIns * This,
            BSTR ProgID,
            BSTR Description,
            BSTR Name,
            VARIANT_BOOL Connected,
            /* [retval][out] */ AddIn **__MIDL_0011);
        
        END_INTERFACE
    } AddInsVtbl;

    interface AddIns
    {
        CONST_VTBL struct AddInsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AddIns_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AddIns_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AddIns_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AddIns_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define AddIns_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define AddIns_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define AddIns_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define AddIns_Item(This,Index,lppaddin)	\
    (This)->lpVtbl -> Item(This,Index,lppaddin)

#define AddIns_get_Parent(This,lppaReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppaReturn)

#define AddIns_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define AddIns__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define AddIns_Update(This)	\
    (This)->lpVtbl -> Update(This)

#define AddIns_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define AddIns_Add(This,ProgID,Description,Name,Connected,__MIDL_0011)	\
    (This)->lpVtbl -> Add(This,ProgID,Description,Name,Connected,__MIDL_0011)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddIns_Item_Proxy( 
    AddIns * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ AddIn **lppaddin);


void __RPC_STUB AddIns_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIns_get_Parent_Proxy( 
    AddIns * This,
    /* [retval][out] */ IDispatch **lppaReturn);


void __RPC_STUB AddIns_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE AddIns_get_Count_Proxy( 
    AddIns * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB AddIns_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE AddIns__NewEnum_Proxy( 
    AddIns * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB AddIns__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddIns_Update_Proxy( 
    AddIns * This);


void __RPC_STUB AddIns_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIns_get_DTE_Proxy( 
    AddIns * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB AddIns_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddIns_Add_Proxy( 
    AddIns * This,
    BSTR ProgID,
    BSTR Description,
    BSTR Name,
    VARIANT_BOOL Connected,
    /* [retval][out] */ AddIn **__MIDL_0011);


void __RPC_STUB AddIns_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __AddIns_INTERFACE_DEFINED__ */


#ifndef __AddIn_INTERFACE_DEFINED__
#define __AddIn_INTERFACE_DEFINED__

/* interface AddIn */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_AddIn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53a87fa1-ce93-48bf-958b-c6da793c5028")
    AddIn : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *lpbstr) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ AddIns **lppaddins) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProgID( 
            /* [retval][out] */ BSTR *lpbstr) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ BSTR *lpbstr) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Connected( 
            /* [retval][out] */ VARIANT_BOOL *lpfConnect) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE put_Connected( 
            /* [in] */ VARIANT_BOOL fConnect) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Object( 
            /* [retval][out] */ IDispatch **lppdisp) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE put_Object( 
            /* [in] */ IDispatch *_lpdispObject) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *lpbstr) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual /* [propget][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE get_SatelliteDllPath( 
            /* [retval][out] */ BSTR *pbstrPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AddInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AddIn * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AddIn * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AddIn * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            AddIn * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            AddIn * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            AddIn * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            AddIn * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            AddIn * This,
            /* [retval][out] */ BSTR *lpbstr);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            AddIn * This,
            /* [in] */ BSTR bstr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Collection )( 
            AddIn * This,
            /* [retval][out] */ AddIns **lppaddins);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgID )( 
            AddIn * This,
            /* [retval][out] */ BSTR *lpbstr);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            AddIn * This,
            /* [retval][out] */ BSTR *lpbstr);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Connected )( 
            AddIn * This,
            /* [retval][out] */ VARIANT_BOOL *lpfConnect);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Connected )( 
            AddIn * This,
            /* [in] */ VARIANT_BOOL fConnect);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Object )( 
            AddIn * This,
            /* [retval][out] */ IDispatch **lppdisp);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Object )( 
            AddIn * This,
            /* [in] */ IDispatch *_lpdispObject);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            AddIn * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            AddIn * This,
            /* [retval][out] */ BSTR *lpbstr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            AddIn * This);
        
        /* [propget][helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *get_SatelliteDllPath )( 
            AddIn * This,
            /* [retval][out] */ BSTR *pbstrPath);
        
        END_INTERFACE
    } AddInVtbl;

    interface AddIn
    {
        CONST_VTBL struct AddInVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AddIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define AddIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define AddIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define AddIn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define AddIn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define AddIn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define AddIn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define AddIn_get_Description(This,lpbstr)	\
    (This)->lpVtbl -> get_Description(This,lpbstr)

#define AddIn_put_Description(This,bstr)	\
    (This)->lpVtbl -> put_Description(This,bstr)

#define AddIn_get_Collection(This,lppaddins)	\
    (This)->lpVtbl -> get_Collection(This,lppaddins)

#define AddIn_get_ProgID(This,lpbstr)	\
    (This)->lpVtbl -> get_ProgID(This,lpbstr)

#define AddIn_get_Guid(This,lpbstr)	\
    (This)->lpVtbl -> get_Guid(This,lpbstr)

#define AddIn_get_Connected(This,lpfConnect)	\
    (This)->lpVtbl -> get_Connected(This,lpfConnect)

#define AddIn_put_Connected(This,fConnect)	\
    (This)->lpVtbl -> put_Connected(This,fConnect)

#define AddIn_get_Object(This,lppdisp)	\
    (This)->lpVtbl -> get_Object(This,lppdisp)

#define AddIn_put_Object(This,_lpdispObject)	\
    (This)->lpVtbl -> put_Object(This,_lpdispObject)

#define AddIn_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define AddIn_get_Name(This,lpbstr)	\
    (This)->lpVtbl -> get_Name(This,lpbstr)

#define AddIn_Remove(This)	\
    (This)->lpVtbl -> Remove(This)

#define AddIn_get_SatelliteDllPath(This,pbstrPath)	\
    (This)->lpVtbl -> get_SatelliteDllPath(This,pbstrPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIn_get_Description_Proxy( 
    AddIn * This,
    /* [retval][out] */ BSTR *lpbstr);


void __RPC_STUB AddIn_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE AddIn_put_Description_Proxy( 
    AddIn * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB AddIn_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIn_get_Collection_Proxy( 
    AddIn * This,
    /* [retval][out] */ AddIns **lppaddins);


void __RPC_STUB AddIn_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE AddIn_get_ProgID_Proxy( 
    AddIn * This,
    /* [retval][out] */ BSTR *lpbstr);


void __RPC_STUB AddIn_get_ProgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE AddIn_get_Guid_Proxy( 
    AddIn * This,
    /* [retval][out] */ BSTR *lpbstr);


void __RPC_STUB AddIn_get_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE AddIn_get_Connected_Proxy( 
    AddIn * This,
    /* [retval][out] */ VARIANT_BOOL *lpfConnect);


void __RPC_STUB AddIn_get_Connected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE AddIn_put_Connected_Proxy( 
    AddIn * This,
    /* [in] */ VARIANT_BOOL fConnect);


void __RPC_STUB AddIn_put_Connected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE AddIn_get_Object_Proxy( 
    AddIn * This,
    /* [retval][out] */ IDispatch **lppdisp);


void __RPC_STUB AddIn_get_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE AddIn_put_Object_Proxy( 
    AddIn * This,
    /* [in] */ IDispatch *_lpdispObject);


void __RPC_STUB AddIn_put_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIn_get_DTE_Proxy( 
    AddIn * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB AddIn_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE AddIn_get_Name_Proxy( 
    AddIn * This,
    /* [retval][out] */ BSTR *lpbstr);


void __RPC_STUB AddIn_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddIn_Remove_Proxy( 
    AddIn * This);


void __RPC_STUB AddIn_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AddIn_get_SatelliteDllPath_Proxy( 
    AddIn * This,
    /* [retval][out] */ BSTR *pbstrPath);


void __RPC_STUB AddIn_get_SatelliteDllPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __AddIn_INTERFACE_DEFINED__ */


#ifndef __Properties_INTERFACE_DEFINED__
#define __Properties_INTERFACE_DEFINED__

/* interface Properties */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Properties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4cc8ccf5-a926-4646-b17f-b4940caed472")
    Properties : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ Property **lplppReturn) = 0;
        
        virtual /* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch **lppidReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch **lppidReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct PropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Properties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Properties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Properties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Properties * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Properties * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Properties * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Properties * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            Properties * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ Property **lplppReturn);
        
        /* [restricted][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            Properties * This,
            /* [retval][out] */ IDispatch **lppidReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Properties * This,
            /* [retval][out] */ IDispatch **lppidReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            Properties * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            Properties * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            Properties * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        END_INTERFACE
    } PropertiesVtbl;

    interface Properties
    {
        CONST_VTBL struct PropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Properties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Properties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Properties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Properties_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Properties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Properties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Properties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Properties_Item(This,index,lplppReturn)	\
    (This)->lpVtbl -> Item(This,index,lplppReturn)

#define Properties_get_Application(This,lppidReturn)	\
    (This)->lpVtbl -> get_Application(This,lppidReturn)

#define Properties_get_Parent(This,lppidReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppidReturn)

#define Properties_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define Properties__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define Properties_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Properties_Item_Proxy( 
    Properties * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ Property **lplppReturn);


void __RPC_STUB Properties_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE Properties_get_Application_Proxy( 
    Properties * This,
    /* [retval][out] */ IDispatch **lppidReturn);


void __RPC_STUB Properties_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Properties_get_Parent_Proxy( 
    Properties * This,
    /* [retval][out] */ IDispatch **lppidReturn);


void __RPC_STUB Properties_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE Properties_get_Count_Proxy( 
    Properties * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB Properties_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE Properties__NewEnum_Proxy( 
    Properties * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB Properties__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Properties_get_DTE_Proxy( 
    Properties * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Properties_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Properties_INTERFACE_DEFINED__ */


#ifndef __Property_INTERFACE_DEFINED__
#define __Property_INTERFACE_DEFINED__

/* interface Property */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Property;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b988e06-2581-485e-9322-04881e0600d0")
    Property : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT *lppvReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT NewValue) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ VARIANT NewValue) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_IndexedValue( 
            /* [in] */ VARIANT Index1,
            /* [optional][in] */ VARIANT Index2,
            /* [optional][in] */ VARIANT Index3,
            /* [optional][in] */ VARIANT Index4,
            /* [retval][out] */ VARIANT *Val) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE put_IndexedValue( 
            /* [in] */ VARIANT Index1,
            /* [optional][in] */ VARIANT Index2,
            /* [optional][in] */ VARIANT Index3,
            /* [optional][in] */ VARIANT Index4,
            /* [in] */ VARIANT NewValue) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_NumIndices( 
            /* [retval][out] */ short *lpiRetVal) = 0;
        
        virtual /* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch **lppidReturn) = 0;
        
        virtual /* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ Properties **lpppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ Properties **lpppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Object( 
            /* [retval][out] */ IDispatch **lppunk) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Object( 
            /* [in] */ IUnknown *lpunk) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct PropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Property * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Property * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Property * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Property * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Property * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            Property * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            Property * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            Property * This,
            /* [retval][out] */ VARIANT *lppvReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            Property * This,
            /* [in] */ VARIANT NewValue);
        
        /* [helpstringcontext][helpstring][helpcontext][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Value )( 
            Property * This,
            /* [in] */ VARIANT NewValue);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IndexedValue )( 
            Property * This,
            /* [in] */ VARIANT Index1,
            /* [optional][in] */ VARIANT Index2,
            /* [optional][in] */ VARIANT Index3,
            /* [optional][in] */ VARIANT Index4,
            /* [retval][out] */ VARIANT *Val);
        
        /* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IndexedValue )( 
            Property * This,
            /* [in] */ VARIANT Index1,
            /* [optional][in] */ VARIANT Index2,
            /* [optional][in] */ VARIANT Index3,
            /* [optional][in] */ VARIANT Index4,
            /* [in] */ VARIANT NewValue);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NumIndices )( 
            Property * This,
            /* [retval][out] */ short *lpiRetVal);
        
        /* [restricted][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            Property * This,
            /* [retval][out] */ IDispatch **lppidReturn);
        
        /* [restricted][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            Property * This,
            /* [retval][out] */ Properties **lpppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            Property * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Collection )( 
            Property * This,
            /* [retval][out] */ Properties **lpppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Object )( 
            Property * This,
            /* [retval][out] */ IDispatch **lppunk);
        
        /* [helpstringcontext][helpstring][helpcontext][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_Object )( 
            Property * This,
            /* [in] */ IUnknown *lpunk);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            Property * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        END_INTERFACE
    } PropertyVtbl;

    interface Property
    {
        CONST_VTBL struct PropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Property_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Property_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Property_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Property_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Property_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Property_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Property_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Property_get_Value(This,lppvReturn)	\
    (This)->lpVtbl -> get_Value(This,lppvReturn)

#define Property_put_Value(This,NewValue)	\
    (This)->lpVtbl -> put_Value(This,NewValue)

#define Property_putref_Value(This,NewValue)	\
    (This)->lpVtbl -> putref_Value(This,NewValue)

#define Property_get_IndexedValue(This,Index1,Index2,Index3,Index4,Val)	\
    (This)->lpVtbl -> get_IndexedValue(This,Index1,Index2,Index3,Index4,Val)

#define Property_put_IndexedValue(This,Index1,Index2,Index3,Index4,NewValue)	\
    (This)->lpVtbl -> put_IndexedValue(This,Index1,Index2,Index3,Index4,NewValue)

#define Property_get_NumIndices(This,lpiRetVal)	\
    (This)->lpVtbl -> get_NumIndices(This,lpiRetVal)

#define Property_get_Application(This,lppidReturn)	\
    (This)->lpVtbl -> get_Application(This,lppidReturn)

#define Property_get_Parent(This,lpppReturn)	\
    (This)->lpVtbl -> get_Parent(This,lpppReturn)

#define Property_get_Name(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_Name(This,lpbstrReturn)

#define Property_get_Collection(This,lpppReturn)	\
    (This)->lpVtbl -> get_Collection(This,lpppReturn)

#define Property_get_Object(This,lppunk)	\
    (This)->lpVtbl -> get_Object(This,lppunk)

#define Property_putref_Object(This,lpunk)	\
    (This)->lpVtbl -> putref_Object(This,lpunk)

#define Property_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_Value_Proxy( 
    Property * This,
    /* [retval][out] */ VARIANT *lppvReturn);


void __RPC_STUB Property_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE Property_put_Value_Proxy( 
    Property * This,
    /* [in] */ VARIANT NewValue);


void __RPC_STUB Property_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propputref][id] */ HRESULT STDMETHODCALLTYPE Property_putref_Value_Proxy( 
    Property * This,
    /* [in] */ VARIANT NewValue);


void __RPC_STUB Property_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_IndexedValue_Proxy( 
    Property * This,
    /* [in] */ VARIANT Index1,
    /* [optional][in] */ VARIANT Index2,
    /* [optional][in] */ VARIANT Index3,
    /* [optional][in] */ VARIANT Index4,
    /* [retval][out] */ VARIANT *Val);


void __RPC_STUB Property_get_IndexedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propput][id] */ HRESULT STDMETHODCALLTYPE Property_put_IndexedValue_Proxy( 
    Property * This,
    /* [in] */ VARIANT Index1,
    /* [optional][in] */ VARIANT Index2,
    /* [optional][in] */ VARIANT Index3,
    /* [optional][in] */ VARIANT Index4,
    /* [in] */ VARIANT NewValue);


void __RPC_STUB Property_put_IndexedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_NumIndices_Proxy( 
    Property * This,
    /* [retval][out] */ short *lpiRetVal);


void __RPC_STUB Property_get_NumIndices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_Application_Proxy( 
    Property * This,
    /* [retval][out] */ IDispatch **lppidReturn);


void __RPC_STUB Property_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_Parent_Proxy( 
    Property * This,
    /* [retval][out] */ Properties **lpppReturn);


void __RPC_STUB Property_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE Property_get_Name_Proxy( 
    Property * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB Property_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE Property_get_Collection_Proxy( 
    Property * This,
    /* [retval][out] */ Properties **lpppReturn);


void __RPC_STUB Property_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE Property_get_Object_Proxy( 
    Property * This,
    /* [retval][out] */ IDispatch **lppunk);


void __RPC_STUB Property_get_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][id][propputref] */ HRESULT STDMETHODCALLTYPE Property_putref_Object_Proxy( 
    Property * This,
    /* [in] */ IUnknown *lpunk);


void __RPC_STUB Property_putref_Object_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Property_get_DTE_Proxy( 
    Property * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB Property_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Property_INTERFACE_DEFINED__ */


#ifndef __ISupportVSProperties_INTERFACE_DEFINED__
#define __ISupportVSProperties_INTERFACE_DEFINED__

/* interface ISupportVSProperties */
/* [object][hidden][uuid][oleautomation] */ 


EXTERN_C const IID IID_ISupportVSProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6659ed14-2ab6-47f3-a890-00c8aba43b84")
    ISupportVSProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyPropertiesDelete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportVSPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISupportVSProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISupportVSProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISupportVSProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyPropertiesDelete )( 
            ISupportVSProperties * This);
        
        END_INTERFACE
    } ISupportVSPropertiesVtbl;

    interface ISupportVSProperties
    {
        CONST_VTBL struct ISupportVSPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportVSProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISupportVSProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISupportVSProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISupportVSProperties_NotifyPropertiesDelete(This)	\
    (This)->lpVtbl -> NotifyPropertiesDelete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISupportVSProperties_NotifyPropertiesDelete_Proxy( 
    ISupportVSProperties * This);


void __RPC_STUB ISupportVSProperties_NotifyPropertiesDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISupportVSProperties_INTERFACE_DEFINED__ */


#ifndef __SelectedItems_INTERFACE_DEFINED__
#define __SelectedItems_INTERFACE_DEFINED__

/* interface SelectedItems */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_SelectedItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6caa67cf-43ae-4184-aaab-0200ddf6b240")
    SelectedItems : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ SelectedItem **lplppReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_MultiSelect( 
            /* [retval][out] */ VARIANT_BOOL *pfMultiSelect) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionContainer( 
            /* [retval][out] */ SelectionContainer **lppdispSelContainer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct SelectedItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SelectedItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SelectedItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SelectedItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            SelectedItems * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            SelectedItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            SelectedItems * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            SelectedItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            SelectedItems * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ SelectedItem **lplppReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            SelectedItems * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            SelectedItems * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            SelectedItems * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            SelectedItems * This,
            /* [retval][out] */ DTE	**lppaReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MultiSelect )( 
            SelectedItems * This,
            /* [retval][out] */ VARIANT_BOOL *pfMultiSelect);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionContainer )( 
            SelectedItems * This,
            /* [retval][out] */ SelectionContainer **lppdispSelContainer);
        
        END_INTERFACE
    } SelectedItemsVtbl;

    interface SelectedItems
    {
        CONST_VTBL struct SelectedItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SelectedItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define SelectedItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define SelectedItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define SelectedItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define SelectedItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define SelectedItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define SelectedItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define SelectedItems_Item(This,index,lplppReturn)	\
    (This)->lpVtbl -> Item(This,index,lplppReturn)

#define SelectedItems__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define SelectedItems_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define SelectedItems_get_Parent(This,lppaReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppaReturn)

#define SelectedItems_get_DTE(This,lppaReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppaReturn)

#define SelectedItems_get_MultiSelect(This,pfMultiSelect)	\
    (This)->lpVtbl -> get_MultiSelect(This,pfMultiSelect)

#define SelectedItems_get_SelectionContainer(This,lppdispSelContainer)	\
    (This)->lpVtbl -> get_SelectionContainer(This,lppdispSelContainer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_Item_Proxy( 
    SelectedItems * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ SelectedItem **lplppReturn);


void __RPC_STUB SelectedItems_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE SelectedItems__NewEnum_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB SelectedItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_get_Count_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB SelectedItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_get_Parent_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB SelectedItems_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_get_DTE_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ DTE	**lppaReturn);


void __RPC_STUB SelectedItems_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_get_MultiSelect_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ VARIANT_BOOL *pfMultiSelect);


void __RPC_STUB SelectedItems_get_MultiSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItems_get_SelectionContainer_Proxy( 
    SelectedItems * This,
    /* [retval][out] */ SelectionContainer **lppdispSelContainer);


void __RPC_STUB SelectedItems_get_SelectionContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __SelectedItems_INTERFACE_DEFINED__ */


#ifndef __SelectedItem_INTERFACE_DEFINED__
#define __SelectedItem_INTERFACE_DEFINED__

/* interface SelectedItem */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_SelectedItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("049d2cdf-3731-4cb6-a233-be97bce922d3")
    SelectedItem : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Collection( 
            /* [retval][out] */ SelectedItems **lppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Project( 
            /* [retval][out] */ Project **lppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProjectItem( 
            /* [retval][out] */ ProjectItem **lppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *lpbstrReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE get_InfoCount( 
            /* [retval][out] */ short *lpnCount) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE get_Info( 
            /* [in] */ short Index,
            /* [retval][out] */ VARIANT *lpbstrReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct SelectedItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SelectedItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SelectedItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SelectedItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            SelectedItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            SelectedItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            SelectedItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            SelectedItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Collection )( 
            SelectedItem * This,
            /* [retval][out] */ SelectedItems **lppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            SelectedItem * This,
            /* [retval][out] */ DTE	**lppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Project )( 
            SelectedItem * This,
            /* [retval][out] */ Project **lppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ProjectItem )( 
            SelectedItem * This,
            /* [retval][out] */ ProjectItem **lppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            SelectedItem * This,
            /* [retval][out] */ BSTR *lpbstrReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *get_InfoCount )( 
            SelectedItem * This,
            /* [retval][out] */ short *lpnCount);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            SelectedItem * This,
            /* [in] */ short Index,
            /* [retval][out] */ VARIANT *lpbstrReturn);
        
        END_INTERFACE
    } SelectedItemVtbl;

    interface SelectedItem
    {
        CONST_VTBL struct SelectedItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SelectedItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define SelectedItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define SelectedItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define SelectedItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define SelectedItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define SelectedItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define SelectedItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define SelectedItem_get_Collection(This,lppReturn)	\
    (This)->lpVtbl -> get_Collection(This,lppReturn)

#define SelectedItem_get_DTE(This,lppReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppReturn)

#define SelectedItem_get_Project(This,lppReturn)	\
    (This)->lpVtbl -> get_Project(This,lppReturn)

#define SelectedItem_get_ProjectItem(This,lppReturn)	\
    (This)->lpVtbl -> get_ProjectItem(This,lppReturn)

#define SelectedItem_get_Name(This,lpbstrReturn)	\
    (This)->lpVtbl -> get_Name(This,lpbstrReturn)

#define SelectedItem_get_InfoCount(This,lpnCount)	\
    (This)->lpVtbl -> get_InfoCount(This,lpnCount)

#define SelectedItem_get_Info(This,Index,lpbstrReturn)	\
    (This)->lpVtbl -> get_Info(This,Index,lpbstrReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_Collection_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ SelectedItems **lppReturn);


void __RPC_STUB SelectedItem_get_Collection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_DTE_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ DTE	**lppReturn);


void __RPC_STUB SelectedItem_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_Project_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ Project **lppReturn);


void __RPC_STUB SelectedItem_get_Project_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_ProjectItem_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ ProjectItem **lppReturn);


void __RPC_STUB SelectedItem_get_ProjectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_Name_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ BSTR *lpbstrReturn);


void __RPC_STUB SelectedItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_InfoCount_Proxy( 
    SelectedItem * This,
    /* [retval][out] */ short *lpnCount);


void __RPC_STUB SelectedItem_get_InfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE SelectedItem_get_Info_Proxy( 
    SelectedItem * This,
    /* [in] */ short Index,
    /* [retval][out] */ VARIANT *lpbstrReturn);


void __RPC_STUB SelectedItem_get_Info_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __SelectedItem_INTERFACE_DEFINED__ */


#ifndef __SelectionContainer_INTERFACE_DEFINED__
#define __SelectionContainer_INTERFACE_DEFINED__

/* interface SelectionContainer */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_SelectionContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02273422-8dd4-4a9f-8a8b-d70443d510f4")
    SelectionContainer : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch **lplppReturn) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ SelectedItems **lppReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct SelectionContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            SelectionContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            SelectionContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            SelectionContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            SelectionContainer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            SelectionContainer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            SelectionContainer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            SelectionContainer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            SelectionContainer * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch **lplppReturn);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            SelectionContainer * This,
            /* [retval][out] */ IUnknown **lppiuReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            SelectionContainer * This,
            /* [retval][out] */ long *lplReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Parent )( 
            SelectionContainer * This,
            /* [retval][out] */ SelectedItems **lppReturn);
        
        /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DTE )( 
            SelectionContainer * This,
            /* [retval][out] */ DTE	**lppReturn);
        
        END_INTERFACE
    } SelectionContainerVtbl;

    interface SelectionContainer
    {
        CONST_VTBL struct SelectionContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define SelectionContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define SelectionContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define SelectionContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define SelectionContainer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define SelectionContainer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define SelectionContainer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define SelectionContainer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define SelectionContainer_Item(This,index,lplppReturn)	\
    (This)->lpVtbl -> Item(This,index,lplppReturn)

#define SelectionContainer__NewEnum(This,lppiuReturn)	\
    (This)->lpVtbl -> _NewEnum(This,lppiuReturn)

#define SelectionContainer_get_Count(This,lplReturn)	\
    (This)->lpVtbl -> get_Count(This,lplReturn)

#define SelectionContainer_get_Parent(This,lppReturn)	\
    (This)->lpVtbl -> get_Parent(This,lppReturn)

#define SelectionContainer_get_DTE(This,lppReturn)	\
    (This)->lpVtbl -> get_DTE(This,lppReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE SelectionContainer_Item_Proxy( 
    SelectionContainer * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDispatch **lplppReturn);


void __RPC_STUB SelectionContainer_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE SelectionContainer__NewEnum_Proxy( 
    SelectionContainer * This,
    /* [retval][out] */ IUnknown **lppiuReturn);


void __RPC_STUB SelectionContainer__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectionContainer_get_Count_Proxy( 
    SelectionContainer * This,
    /* [retval][out] */ long *lplReturn);


void __RPC_STUB SelectionContainer_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectionContainer_get_Parent_Proxy( 
    SelectionContainer * This,
    /* [retval][out] */ SelectedItems **lppReturn);


void __RPC_STUB SelectionContainer_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE SelectionContainer_get_DTE_Proxy( 
    SelectionContainer * This,
    /* [retval][out] */ DTE	**lppReturn);


void __RPC_STUB SelectionContainer_get_DTE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __SelectionContainer_INTERFACE_DEFINED__ */


#ifndef __Windows_INTERFACE_DEFINED__
#define __Windows_INTERFACE_DEFINED__

/* interface Windows */
/* [helpstringcontext][helpstring][helpcontext][uuid][object][oleautomation][dual] */ 


EXTERN_C const IID IID_Windows;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2294311A-B7BC-4789-B365-1C15FF2CD17C")
    Windows : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ Window **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *lplReturn) = 0;
        
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **lppiuReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateToolWindow( 
            /* [in] */ AddIn *AddInInst,
            /* [in] */ BSTR ProgId,
            /* [in] */ BSTR Caption,
            /* [in] */ BSTR GuidPosition,
            /* [out][in] */ IDispatch **DocObj,
            /* [retval][out] */ Window **lppcReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_DTE( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ DTE	**lppaReturn) = 0;
        
        virtual /* [helpstringcontext][helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CreateLinkedWindowFrame( 
            /* [in] */ Window *Window1,
            /* [in] */ Window *Window2,
            /* [in] */ vsLinkedWindowType Link,
            /* [retval][out] */ Window **LinkedWindowFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct WindowsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            Windows * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            Windows * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            Windows * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            Windows * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            Windows * This,
            /* [in] */ UINT iTInfo,
  