6);
    CRTC_WR(0x16, 0xb9);
    CRTC_WR(0x17, 0xa3);
    CRTC_WR(0x18, 0xff);

    //**************************************************************************
    // GDC Regs
    //**************************************************************************

    REG_WR08(NV_PRMVIO_GRX,   0x0);                 // 3ce
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x1);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x2);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x3);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x4);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x5);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x10);            

    REG_WR08(NV_PRMVIO_GRX,   0x6);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0e);            

    REG_WR08(NV_PRMVIO_GRX,   0x7);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x8);            
    REG_WR08(NV_PRMVIO_GX_SR, 0xff);            

    //**************************************************************************
    // Full Cpu ON
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue |=0x20;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue  );       // 3c5

    //**************************************************************************
    // OEMSetRegs
    //**************************************************************************

    CRTC_WR(0x19, 0x0);

    CRTC_RD(0x1a,byteValue);
    byteValue &=0xc0;
    byteValue |=0x38;
    byteValue |=1;
    byteValue |=4;
    CRTC_WR(0x1a, byteValue);

    CRTC_WR(0x1b, 0x3);
    CRTC_WR(0x1c, 0x18);
    CRTC_WR(0x1d, 0x0);
    CRTC_WR(0x1e, 0x0);

    CRTC_WR(0x20, 0x20);
    CRTC_WR(0x25, 0x0);

    CRTC_RD(0x28,byteValue);
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);


    CRTC_WR(0x2d, 0x0);
    CRTC_WR(0x29, 0x0);
    CRTC_WR(0x2a, 0x0);
    CRTC_WR(0x30, 0x0);
    CRTC_WR(0x31, 0x0);
    CRTC_WR(0x32, 0x0);

    CRTC_RD(0x33,byteValue);
    byteValue &= 0x7f;
    CRTC_WR(0x33, byteValue);

    CRTC_WR(0x39, 0xff);


    dwordValue = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    dwordValue &=0xeffffdfe;
    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        dwordValue |= 0x00000200;
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT,dwordValue);

    dwordValue = REG_RD32(NV_PRAMDAC_GENERAL_CONTROL);
    dwordValue &= 0xffefeeef;
    dwordValue |= 0x00000100;
    dwordValue |= 0x00000010;
    REG_WR32(NV_PRAMDAC_GENERAL_CONTROL,dwordValue);

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x18);                    

    //**************************************************************************
    // Skip Load Palette and LoadSysfont
    //**************************************************************************

    //**************************************************************************
    // Skip OemFixupSetMode/ FPEndSetMode for now    (Flat panel only)
    //**************************************************************************

//    FPEndSetMode();

    //**************************************************************************
    // SetDPMSOff
    // Turn off DPMS on CRT only
    //**************************************************************************

    if ((!(HwDeviceExtension->FlatPanelIsPresent)) &&   // Flat panel not present
        (!(HwDeviceExtension->TvIsPresent)) )           // TV not present
        {    
        CRTC_RD(0x1a, byteValue);
        byteValue&=0x3f;
        CRTC_WR(0x1a, byteValue);

        //**********************************************************************
        // Full CPU Off
        //**********************************************************************
    
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
        byteValue &=0xdf;
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5
    
        //**********************************************************************
        // ATCON
        //**********************************************************************
// cli    
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
        REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
// sti
        }
            
    //**************************************************************************
    // Full CPU Off
    //**************************************************************************

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue &=0xdf;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5

    //**************************************************************************
    // ATCON
    //**************************************************************************

//cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
//sti

    //**************************************************************************
    // Skip OEMPostSetMode  (TV only)
    //**************************************************************************

    //**************************************************************************
    // Restore / Lock extended registers if necessary
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;                                // remove bit 0
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c

    if (initialLockValue == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (initialLockValue == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (initialLockValue == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }

    //**************************************************************************
    // Restore the original CRTC index register
    //**************************************************************************

    REG_WR08(NV_PRMCIO_CRX__COLOR, savedCrtcIndex); // 3d4

    }



#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
// Function:    NV_VBE_DPMS_GetPowerState()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOLEAN NV_VBE_DPMS_GetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG *CurrentPowerState)

    {
    UCHAR lock;
    UCHAR cr1a;
    UCHAR result;

    //**************************************************************************
    // Save off original lock value, then unlock extended registers
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);

    //**************************************************************************
    // Read CR1A
    //
    //   Bit 7 Hsync Toggle disable.  When set to a 1, this bit forces the Hsync to
    //            inactive state (high or low as programmed in the bit-6 of the
    //            Miscellaneous output register).
    //
    //   Bit 6 Vsync Toggle disable.  When set to a 1, this bit forces the Vsync to
    //            inactive state (high or low as programmed in the bit-7 of the
    //            Miscellaneous output register).
    //
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, cr1a);

    //**************************************************************************
    // Isolate DPMS bits (CR1A bits 7 & 6)
    //**************************************************************************

    cr1a >>=14;
    *CurrentPowerState = tblDPMSStates[cr1a];

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    if (lock == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (lock == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (lock == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }


    return(TRUE);
    }


//******************************************************************************
//
// Function:    NV_VBE_DPMS_SetPowerState()
//
// Routine Description:
//
//       VBE Function 10h
//       VBE_DPMS - Display Power Management Signaling functions (DPMS).
//
//       Entry:  AX = 4F10h
//               BL = Subfunction
//               ES:DI = Null pointer
//               DS = Seg0
//
//               Other registers dependent on subfunction
//               Subfunction 0:
//                       None
//               Subfunction 1:
//                       BH = Requested power state
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//               Subfunction 2:
//                       None
//
//       Exit:   AX = VBE return status
//               Other registers dependent on subfunction:
//               Subfunction 0:
//                       BH = States supported:
//                            bit 0      Stand by
//                            bit 1      Suspend
//                            bit 2      Off
//                            bit 3      Reduced on
//                            bits 4-7   Reserved
//                       BL = VBE/PM Version number:
//                            bits 0-3   Minor version number (0)
//                            bits 4-7   Major version number (1)
//               Subfunction 1:
//                       None
//               Subfunction 2:
//                       BH = Power state currently requested by controller
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//
//       The VESA committee defined a method of signalling a monitor
//       to shutdown or to go into standby mode. The sync signals are
//       used in the following manner:
//
//       H Sync  V Sync  Result
//       ======  ======  ======
//       Pulses  Pulses  Monitor is active
//       None    Pulses  Monitor is in "stand-by" mode
//       Pulses  None    Monitor is in "suspend" mode
//       None    None    Monitor is in "shut down" mode
//
//       Note: ES, DS, SI have been pushed on the stack already
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
BOOLEAN NV_VBE_DPMS_SetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PowerState)
{
    BOOLEAN bRet = 0;
    ULONG i;

    for(i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        
        switch (PowerState)
        {

            case VideoPowerOn:
            case VideoPowerHibernate:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        TRUE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = FALSE;
                break;

            case VideoPowerStandBy:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerSuspend:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerOff:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        FALSE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = TRUE;
                break;
        }
    }    

    return(bRet);

}

//******************************************************************************
//
// Function:    GetCurrentDPMSState(HwDeviceExtension)
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U032 GetCurrentDPMSState(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    U032 Value;
    
    
    Value = hwDeviceExtension->CurrentDPMSState;
    return(Value);
    }


//******************************************************************************
//
// Function:    NV_ATCOff()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);        // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x0);

    }


//******************************************************************************
//
// Function:    NV_ATCOn()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOn(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);    // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x20);

    NV_ResetATCFlipFlop(HwDeviceExtension);    // For compatibility with DOS EDIT

    }


//******************************************************************************
//
// Function:    NV_ResetATCFlipFlop()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    volatile U008 value;

    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR);
    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__MONO);

    }


#endif // WINN32_WINNT >= 0x0500 NT5 only



//******************************************************************************
//
//  Function: NVGetTimingForDac()
//
//  Routine Description:
//
//      This routine get timing values for dac at giving mode.
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//
//  Return Value:
//      TRUE - successful; FALSE - failed
//
//******************************************************************************
BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{
    GetTimingDacCommonModesetCode(hwDeviceExtension, pResolution, pTimingInfo);
    return (TRUE);
}

//
// Read in the monitor restriction mode list per head from the registry.
//
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    U016 *ValidModePtr;
    U016 *RegDataPtr;
    ULONG NumRegistryModes;
    U016  *BaseOfValidModeTable;
    ULONG i;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    
    // init the Monitor restriction mode tables.
    MonitorRestrictionModeList0_registry_data[0]     = 0xFFFF ;
    MonitorRestrictionModeList1_registry_data[0]     = 0xFFFF ;
    HwDeviceExtension->NumRestrictionModes0 = 0;
    HwDeviceExtension->NumRestrictionModes1 = 0;
    // copy the monitor restriction modelists for both heads.
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList0",      &(MonitorRestrictionModeList0_registry_data[0] ));
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList1",      &(MonitorRestrictionModeList1_registry_data[0] ));

    for (i=0; i < NV_NO_DACS; i++)
    {
        RegDataPtr = (i ? (U016 *)&MonitorRestrictionModeList1_registry_data[0] : (U016 *)&MonitorRestrictionModeList0_registry_data[0]);
        ValidModePtr = (i ? (U016 *)&HwDeviceExtension->RestrictionModeTable1[0] : (U016 *)&HwDeviceExtension->RestrictionModeTable0[0]);
        BaseOfValidModeTable = ValidModePtr;
        NumRegistryModes = 0;
    
        //**************************************************************************
        // Parse each line from the registry.
        // For each refresh rate (of each mode), check if the refresh is present in the
        // vesa data table.  If so, then it's a valid mode. 
        // Registry data is terminated with 0xffff
        //**************************************************************************

        while (*RegDataPtr != 0xffff)
            {
            RegDepth   = *(RegDataPtr);             // Get Depth from registry
            RegWidth   = *(RegDataPtr+1);           // Get Width from registry
            RegHeight  = *(RegDataPtr+2);           // Get Height from registry

            //**********************************************************************
            // Advance to the registry refresh rates for this particular mode
            //**********************************************************************

            RegDataPtr+=3;

            //**********************************************************************
            // Each mode entry in the registry data is NULL terminated.
            // Parse all refresh rates for this mode
            //**********************************************************************

            while (*RegDataPtr !=0)
            {        
                RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

                //**********************************************************
                // Generate 8bpp entry for this refresh rate
                //**********************************************************

                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = RegWidth;          // Width
                *(ValidModePtr+2)  = RegHeight;         // Height
                *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode

                //**********************************************************
                // Keep track of how many modes have currently been specified
                //**********************************************************

                NumRegistryModes++;

                //**********************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**********************************************************

                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                }
            } // while (*RegDataPtr !=0)...

            //**********************************************************************
            // Skip past null terminator
            //**********************************************************************

            RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

        //
        // Save the number of restriction modes for each head
        //
        if (i == 0) 
        {
            HwDeviceExtension->NumRestrictionModes0 = NumRegistryModes;
        }
        else
        {
            HwDeviceExtension->NumRestrictionModes1 = NumRegistryModes;
        }
    } // for each head
}

#if (_WIN32_WINNT >= 0x0500)
//
// Gets called while shutting down.
// Disables interrupts as they are left on by the ResMan to make full screen DOS VGA mode
// work correctly.
//
BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    HwDeviceExtension = (PHW_DEVICE_EXTENSION)hwDeviceExtension;

    // Disable the interrupts.
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);

    // Since we are not setting the VGA mode, return FALSE so that the HAL can do the
    // equivalent of Int10, mode 3.
    return(FALSE);
}
#endif (_WIN32_WINNT >= 0x0500)


//
// DetectDevice is called from DetectNextDevice and checks whether in psnSlot is a nvidia device and if so it will claim
//              it's resources (if bClaimResources is TRUE). It also checks whether the device is a primary VGA device.
//  NOTE :      This is the place to add new board IDs (and it should remain the only place in the miniport)
//

VP_STATUS DetectDevice(PHW_DEVICE_EXTENSION   pHDE,                             // our devices 'global' data struct
                        PCI_SLOT_NUMBER       psnSlot,                          // the slot to check
                        ULONG                 ulNumAccessRanges,                // is needed the to claim the resources, for now it's always 2
                        PVIDEO_ACCESS_RANGE   pAccessRanges,                    // if bClaimResources == TRUE this exports the device's mapping
                        USHORT                *pusVendorID,
                        USHORT                *pusDeviceID,
                        BOOLEAN               *pbIsPrimaryDevice,
                        BOOLEAN               bClaimResources)
{
    VP_STATUS         status = ERROR_DEV_NOT_EXIST;
    PCI_COMMON_CONFIG pcc;
    ULONG             ulBytes;
    ULONG             ulVendorID;
    ULONG             ulDeviceID;
    PVOID             pvVendorID;
    PVOID             pvDeviceID;
    ULONG             ulSlot;
#if (_WIN32_WINNT >= 0x0500)
    ULONG             VgaStatus;
#endif

    ASSERT(pHDE);
    ASSERT(ulNumAccessRanges);
    ASSERT(pAccessRanges);
    ASSERT(pusVendorID);
    ASSERT(pusDeviceID);
    ASSERT(pbIsPrimaryDevice);

    VideoPortZeroMemory(&pcc, sizeof(PCI_COMMON_CONFIG));

    ulBytes = VideoPortGetBusData(pHDE, 
                                    PCIConfiguration,
                                    psnSlot.u.AsULONG,             // assuming that function = 0 , W2K ignores this 
                                    &pcc,
                                    0,
                                    PCI_COMMON_HDR_LENGTH);

    if (PCI_COMMON_HDR_LENGTH == ulBytes)
    {
        if (NV4_VENDOR_ID == pcc.VendorID) // most trivial check
        {
            //
            // list of boards supported now
            //
            switch (pcc.DeviceID)
            {
            case NV20_DEVICE_NV20_ID:
            case NV20_DEVICE_NV20_1_ID:
            case NV20_DEVICE_NV20_2_ID:
            case NV20_DEVICE_NV20_3_ID:
                ulNumAccessRanges++;            // NV20 needs one more access ranges
            case NV4_DEVICE_NV4_ID:
            case NV5_DEVICE_NV5_ID:
            case NV5ULTRA_DEVICE_NV5ULTRA_ID:
            case NV5VANTA_DEVICE_NV5VANTA_ID:
            case NV5MODEL64_DEVICE_NV5MODEL64_ID:
            case NV0A_DEVICE_NV0A_ID:
            case NV10_DEVICE_NV10_ID:
            case NV10DDR_DEVICE_NV10DDR_ID:
            case NV10GL_DEVICE_NV10GL_ID:
            case NV11_DEVICE_NV11_ID:
            case NV11DDR_DEVICE_NV11DDR_ID:
            case NV11M_DEVICE_NV11M_ID:
            case NV11GL_DEVICE_NV11GL_ID:
            case NV11_DEVICE_CRUSH11_ID:
            case NV15_DEVICE_NV15_ID:
            case NV15DDR_DEVICE_NV15DDR_ID:
            case NV15BR_DEVICE_NV15BR_ID:
            case NV15GL_DEVICE_NV15GL_ID:
                *pusVendorID = pcc.VendorID;
                *pusDeviceID = pcc.DeviceID;

#if (_WIN32_WINNT >= 0x0500)
                //
                // On IA64 it isn't save to rely on PCI_ENABLE_IO_SPACE to detect the
                // primary device. Since Win2K it is possible to query the VGA status:
                //
                if (NO_ERROR == VideoPortGetVgaStatus(pHDE, &VgaStatus))
                {
                    // VgaStatus (0) indicates that VGA is not enabled -> secondary device
                    // VgaStatus (1) indicates that VGA is enabled -> primary device
                    *pbIsPrimaryDevice = (1 == VgaStatus); 
                }
                else
#endif
                {
                    //
                    //  if the PCI io space is enabled we are on the primary VGA device
                    //
                    *pbIsPrimaryDevice = pcc.Command & PCI_ENABLE_IO_SPACE ? TRUE : FALSE;
                }

                //
                // if were not the primary device well have to enable MMIO and BUS MASTER
                //
                if (! *pbIsPrimaryDevice)
                {
                    //
                    // if NT4_MULTI_DEV is not defined, behave like original driver did -> don't recognize disabled board
                    //
#if (defined (NT4_MULTI_DEV) || (_WIN32_WINNT >= 0x0500))
                    // just prepare common config that VPGetAccessRanges can read the physical aperture
                    pcc.Command |=  PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER;

                    ulBytes = VideoPortSetBusData(pHDE, 
                                                PCIConfiguration,
                                                psnSlot.u.AsULONG,             
                                                &pcc.Command,
                                                offsetof(PCI_COMMON_CONFIG, Command),
                                                sizeof(ULONG));
                    if (sizeof(ULONG) != ulBytes)
#endif
                    {
                        status = ERROR_DEV_NOT_EXIST;
                        goto EXIT;
                    }
                }

#if (_WIN32_WINNT < 0x0500)
                ulSlot      = psnSlot.u.AsULONG;                // start looking at this slot
                ulVendorID  = (ULONG)(pcc.VendorID) & 0xffff;
                ulDeviceID  = (ULONG)(pcc.DeviceID) & 0xffff;
                pvVendorID  = (PVOID)&ulVendorID;
                pvDeviceID  = (PVOID)&ulDeviceID;
#else
                // W2K automatically uses the right slot, so all slot information is useless or invalid here
                ulSlot      = 0;                                // has to be 0 on W2K and above
                pvVendorID  = NULL;
                pvDeviceID  = NULL;
#endif
                //
                // VideoPortGetAccessRanges fills pAccessRanges (and pvVendor/DeviceID which obviously should match the ones we
                //                          found using VideoPortGetBusData 8-) )
                //
                if (bClaimResources)
                {
                    status = VideoPortGetAccessRanges(pHDE, 
                                                      0,
                                                      NULL,
                                                      ulNumAccessRanges,
                                                      pAccessRanges,
                                                      pvVendorID,
                                                      pvDeviceID, 
                                                      &ulSlot);
                    if (NO_ERROR == status)
                    {
                        //
                        // check data consistency for NT 4 only as in W2K ulSlot is alwas 0 
                        //
#if (_WIN32_WINNT < 0x0500) 
                        if (ulSlot != psnSlot.u.AsULONG ||
                          (USHORT)ulVendorID != *pusVendorID ||
                          (USHORT)ulDeviceID != *pusDeviceID)
                        {
                            //
                            // the last VideoPortGetAccessRanges has claimed resources but obviously
                            // for the wrong slot, so we unclaim everything with NumAccessRanges = 0
                            //
                            status = VideoPortGetAccessRanges(pHDE, 
                                                              0,
                                                              NULL,
                                                              0,
                                                              pAccessRanges,
                                                              pvVendorID,
                                                              pvDeviceID, 
                                                              &ulSlot);
                            ASSERT(NO_ERROR == status);
                            status = ERROR_DEV_NOT_EXIST;
                            goto EXIT;
                        }
#endif

                        //
                        // for some reason VideoPortGetAccessRanges enables PortIO in our command register
                        // so we have to reset this for non primary devices
                        //
                        if (! *pbIsPrimaryDevice)
                        {
                            ulBytes = VideoPortGetBusData(pHDE, 
                                                            PCIConfiguration,
                                                            psnSlot.u.AsULONG,             // assuming that function = 0
                                                            &pcc,
                                                            0,
                                                            PCI_COMMON_HDR_LENGTH);
                            if (ulBytes == PCI_COMMON_HDR_LENGTH)
                            {
                                // just prepare common config that VPGetAccessRanges can read the physical aperture
                                pcc.Command &=  ~PCI_ENABLE_IO_SPACE;

                                ulBytes = VideoPortSetBusData(pHDE, 
                                                            PCIConfiguration,
                                                            psnSlot.u.AsULONG,             // assuming that function = 0
                                                            &pcc,
                                                            0,
                                                            PCI_COMMON_HDR_LENGTH);
                                ASSERT(ulBytes == PCI_COMMON_HDR_LENGTH);
                            }
                        }
                    }
                }
                else
                {
                    status = NO_ERROR;
                }
                break;

                // no need for default branch
            }
        }
    }
EXIT:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\cr11_ref.h ===
/* NVidia Corporation */ 
/* basis: crush11 manuals 
built on Thu Feb 22 04:10:06 PST 2001*/

#ifndef _CR_REF_H_
#define _CR_REF_H_

#define CR_DRF_DEF(d,r,f,c)  ((CR ## d ## r ## f ## c)<<DRF_SHIFT(CR ## d ## r ## f))
#define CR_DRF_NUM(d,r,f,n)  (((n)&DRF_MASK(CR ## d ## r ## f))<<DRF_SHIFT(CR ## d ## r ## f))
#define CR_DRF_VAL(d,r,f,v)  (((v)>>DRF_SHIFT(CR ## d ## r ## f))&DRF_MASK(CR ## d ## r ## f))

/* dev_cr.ref */

#define CR_CMC_CFG0                                      0x8000017c /* RW-4R */
#define CR_CMC_CFG0_TOP_OF_FB				       10:6 /* RWIVF */
#define CR_CMC_CFG0_TOP_OF_FB_1MB                        0x00000000 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_2MB                        0x00000001 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_3MB                        0x00000002 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_4MB                        0x00000003 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_5MB                        0x00000004 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_6MB                        0x00000005 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_7MB                        0x00000006 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_8MB                        0x00000007 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_9MB                        0x00000008 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_10MB                       0x00000009 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_11MB                       0x0000000A /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_12MB                       0x0000000B /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_13MB                       0x0000000C /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_14MB                       0x0000000D /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_15MB                       0x0000000E /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_16MB                       0x0000000F /* RWI-V */
#define CR_CMC_CFG0_TOP_OF_FB_17MB                       0x00000010 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_18MB                       0x00000011 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_19MB                       0x00000012 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_20MB                       0x00000013 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_21MB                       0x00000014 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_22MB                       0x00000015 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_23MB                       0x00000016 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_24MB                       0x00000017 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_25MB                       0x00000018 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_26MB                       0x00000019 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_27MB                       0x0000001A /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_28MB                       0x0000001B /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_29MB                       0x0000001C /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_30MB                       0x0000001D /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_31MB                       0x0000001E /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_32MB                       0x0000001F /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB__PROD                      0x0000001F /* RW--V */

#endif /* _CR_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\dspioctl.h ===
#ifndef _DSPIOCTL_H
#define _DSPIOCTL_H
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     dspioctl.h
//
// Abstract:
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "nvMultiMon.h"
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// Private IOCTL info - Used by all components of the display driver
//******************************************************************************

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_RESTORE_DISPLAY_PATCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2052, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2053, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_VBLANK_FLAG    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2055, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_WRITE_COMBINING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2056, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2057, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT \
        CTL_CODE (FILE_DEVICE_VIDEO, 2058, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_SHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2059, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2060, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOCK_DOWN_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2061, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNLOCK_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2062, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_TO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2063, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_FROM_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2064, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COMMON_DEVICE_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2065, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ALLOC_AGP_MEM \
        CTL_CODE (FILE_DEVICE_VIDEO, 2066, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_FREE_AGP_MEM  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2067, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_PIXMIX_INDEX \
        CTL_CODE (FILE_DEVICE_VIDEO, 2068, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_VPE_COMMAND \
        CTL_CODE (FILE_DEVICE_VIDEO, 2069, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_REGISTRY_PATH  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2070, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2071, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_REGISTRY_VALUE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2072, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2073, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2075, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2076, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_DEVICE_MODE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2077, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2078, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_GAMMA_CLUT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2079, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_MAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2080, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2081, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2083, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2084, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2085, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_DESKTOP_INFO_MODE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2086, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TIMING_DAC \
        CTL_CODE (FILE_DEVICE_VIDEO, 2087, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_PREMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2088, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_POSTMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2089, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2091, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_NUMBER_DACS \
        CTL_CODE (FILE_DEVICE_VIDEO, 2092, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2093, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SAVE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2094, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2095, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PCI_SLOT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2096, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2097, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_CLEAR_FRAMEBUFFER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2098, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TV_ENCODER_TYPE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2099, METHOD_BUFFERED, FILE_ANY_ACCESS)
// handle calls for stereo glasses
#define IOCTL_VIDEO_STEREO_GLASSES_SWITCH \
        CTL_CODE (FILE_DEVICE_VIDEO, 2100, METHOD_BUFFERED, FILE_ANY_ACCESS)
// handle calls for multi device support for NT 4
#define IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DEVICE_OBJECTS  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3001, METHOD_BUFFERED, FILE_ANY_ACCESS)


#define IOCTL_VIDEO_ZW_CREATE_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3002, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_READ_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3003, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_WRITE_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_CLOSE_HANDLE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS \
        CTL_CODE (FILE_DEVICE_VIDEO, 3006, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_CONTROL_DEVICE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3007, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_UNIQUENESS_VGA \
        CTL_CODE (FILE_DEVICE_VIDEO, 3008, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT \
        CTL_CODE (FILE_DEVICE_VIDEO, 3010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_NVSVC_STATUS \
        CTL_CODE (FILE_DEVICE_VIDEO, 3011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK \
        CTL_CODE (FILE_DEVICE_VIDEO, 3012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT \
        CTL_CODE (FILE_DEVICE_VIDEO, 3013, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CONVERT_RING3_HANDLE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3014, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PBUS_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3015, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_NV_PBUS_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3016, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED \
        CTL_CODE (FILE_DEVICE_VIDEO, 3017, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef struct _GET_NUMBER_DACS
{
    ULONG ulNumberDacsOnBoard;          // Number of heads on the board.
    ULONG ulNumberDacsConnected;        // Number of heads connected to any device.
    ULONG ulAllDeviceMask;              // Bitmask for all connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceDisplay[NV_NO_DACS];  // 0,1 or 1,0 depending on the primary head being used in std/span modes.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulHeadDeviceOptions[NV_NO_DACS]; // A matrix of possible device options for each head.
    //
    // Following are the registry keys that get sent back upto the display driver
    //
    ULONG Mobile;                       // 0: desktop system; 1: Dell laptop; 2: Toshiba laptop
    ULONG UseHWSelectedDevice;          // BIOS devices take precedence over windows devices.
    ULONG UseHotKeySameMode;            // On hot key switches, keeps the same desktop mode (resolution,depth).
                                        // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                        // This field is obsolete now since no OEM is using this feature curently.
    ULONG PanScanSelection;             // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                        // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                        // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG GDIModePruning;
    ULONG ulDFPSupports1400x1050;       // If the builtin DFP of the laptop supports 1400x1050 or not.
                                        // Toshiba wants us to export this mode only if natively supported by DFP.
    ULONG ulHotKeyPending;              // 1 if miniport has a hotkey pending to be done by the display driver.
                                        // Then the display will ignore the BOOT_HEADS.
    ULONG ulUniquenessVGA;              // The unique integer ID for the ppdev
                                        // for which the last IOCTL_RESET_DEVICE 
                                        // was performed.
    ULONG ACPISystem;                   // TRUE if we are on a ACPI system (such as laptops).

    

} GET_NUMBER_DACS;

typedef struct _HEAD_MODE_LIST_INFO
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    ULONG ulDeviceMask;
    ULONG ulDeviceType;
    ULONG ulTVType;
    ULONG ulNumVirtualModes;
    MODE_ENTRY *pVirtualModeList;
    MODE_ENTRY *pPhysicalModeList;    // Caller should have allocated this memory. It is assumed that this
                                      // PhysicalModeList is atleast as big as the VirtualModeList.
} HEAD_MODE_LIST_INFO;

typedef struct _NV_DESKTOP_INFO
{
    ULONG ulDesktopMode;                // 0x0000 -> Single Monitor
    ULONG ulDesktopModeIndex;           // Display driver set the requested mode index  
    ULONG ulDesktopWidth;               // Miniport driver return the width based on the mode index
    ULONG ulDesktopHeight;              // Miniport driver return the height based on the mode index
    ULONG ulDisplayWidth[NV_NO_DACS];   // Display driver set these values; 
    ULONG ulDisplayHeight[NV_NO_DACS];  // control panel should give it to display driver
    ULONG ulDisplayRefresh[NV_NO_DACS]; // refresh rate 
    ULONG ulDisplayPixelDepth[NV_NO_DACS]; // Color Depth
    ULONG ulNumberDacsOnBoard;          // Number of DACs on the board
    ULONG ulNumberDacsConnected;        // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG ulNumberDacsActive;           // Number of DACs which are currently active. For example, in the Normal
                                        // mode, this value will be 1.
    ULONG ulAllDeviceMask;              // Bitmask of all output connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulDeviceDisplay[NV_NO_DACS];  // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.
    ULONG ulTwinView_State;             // standard, clone or span.

} NV_DESKTOP_INFO;

typedef struct _NV_CURSOR_INFO
{
    LONG    lCursorX;
    LONG    lCursorY;
    LONG    lCursorWidth;
    LONG    lCursorHeight;
    LONG    lScreenStride;
    LONG    lScreenPixelDepth;
    ULONG   ulHwCursorWidth;
    ULONG   ulOriginalImageMemOffset;
    ULONG   ulCursorMemOffset;
} NV_CURSOR_INFO;

typedef struct _NV_SYSMEM_SHARE_MEMORY
    {
    PVOID pSystemMdl;           // MDL for locked down memory
    PVOID userVirtualAddress;   // user virtual address
    PVOID ddVirtualAddress;     // display driver virtual address
    ULONG physicalAddress;      // physical address of memory
    ULONG byteLength;           // byte length of data to lock down
    ULONG bDontModifyMDL;       // if TRUE, MDL will not be allocated nor freed
    } NV_SYSMEM_SHARE_MEMORY;


typedef struct _NV_LOCK_DOWN_MEMORY
    {
    PVOID virtualAddress; // display driver virtual address
    ULONG byteLength;     // byte length of data to lock down
    PVOID pMdl;           // MDL for locked down memory
    } NV_LOCK_DOWN_MEMORY;

typedef struct _NV_UNLOCK_MEMORY
    {
    PVOID pMdl;           // MDL for memory to unlock
    } NV_UNLOCK_MEMORY;

//
// AGP memory block node structure.
//
typedef struct _AGP_MEM
    {
    ULONG   hContext;       // Addr context of process
    ULONG   cb;             // Size of memory region in bytes
    PVOID   VirtualAddress; // Based address of Virtual AGP buffer
    } *PAGP_MEM, AGP_MEM;

//
// Registry set structure
//
typedef struct _NV_REGISTRY_STRUCT
    {
    PWSTR keyName;          // Name of key in unicode string format
    PVOID keyVal;           // pointer to key value
    ULONG keyValSize;       // Size of Key Value;
    } *PNV_REGISTRY_STRUCT, NV_REGISTRY_STRUCT;


//
// Zw File I/O support
// We don't want to export the use of Zw functions for release builds
// define NV_ZW_FILE_IO_ENABLED to get the Zw functions enabled.
// 

//#define NV_ZW_FILE_IO_ENABLED

typedef struct _NV_ZW_IO_FILE_OUT
    {
    PVOID pvFileHandle;
    PVOID pvIoStatusBlock;
    PVOID pvBuffer;
    } *PNV_ZW_IO_FILE_OUT, NV_ZW_IO_FILE_OUT;

typedef struct _ZW_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
    } ZW_UNICODE_STRING, *PZW_UNICODE_STRING;

typedef struct _ZW_OBJECT_ATTRIBUTES
    {
    ULONG              Length;
    PVOID              RootDirectory;             // Handle
    PZW_UNICODE_STRING ObjectName;
    ULONG              Attributes;
    PVOID              SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID              SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
    } ZW_OBJECT_ATTRIBUTES, *PZW_OBJECT_ATTRIBUTES;

typedef struct _NV_ZW_CREATE_FILE_IN
    {
    ULONG                ulDesiredAccess;
    ZW_OBJECT_ATTRIBUTES ObjectAttributes;
    LARGE_INTEGER        liAllocationSize;
    ULONG                ulFileAttributes;
    ULONG                ulShareAccess;
    ULONG                ulCreateDisposition;
    ULONG                ulCreateOptions;
    PVOID                pvEaBuffer;
    ULONG                ulEaLength;

    ZW_UNICODE_STRING uiObjectName;
    WCHAR pwcObjectBuffer[257];
    } *PNV_ZW_CREATE_FILE_IN, NV_ZW_CREATE_FILE_IN;

typedef struct _NV_ZW_RW_FILE_IN
    {
    PVOID         pvFileHandle;
    PVOID         pvEvent;
    PVOID         pvApcRoutine;
    PVOID         pvApcContext;
    PVOID         pvBuffer;
    ULONG         ulLength;
    LARGE_INTEGER liByteOffset;
    PVOID         pvKey;
    } *PNV_ZW_RW_FILE_IN, NV_ZW_RW_FILE_IN;

typedef struct _NV_ZW_DEVICE_IO_CONTROL_FILE
    {
    PVOID hDevice;
    ULONG ulIoControlCode;
    PVOID pvInputBuffer;
    ULONG ulInputBufferSize;
    } *PNV_ZW_DEVICE_IO_CONTROL_FILE, NV_ZW_DEVICE_IO_CONTROL_FILE;

typedef ULONG (*LPNVZWCREATEFILEFUNCTION) ( PVOID FileHandle,
                                            ULONG DesiredAccess,
                                            PVOID ObjectAttributes,
                                            PVOID IoStatusBlock,
                                            PVOID AllocationSize,
                                            ULONG FileAttributes,
                                            ULONG ShareAccess,
                                            ULONG CreateDisposition,
                                            ULONG CreateOptions,
                                            PVOID EaBuffer,
                                            ULONG EaLength );


typedef ULONG (*LPNVZWWRITEFILEFUNCTION) ( PVOID  FileHandle,
                                           PVOID  Event,
                                           PVOID  ApcRoutine,
                                           PVOID  ApcContext,
                                           PVOID  IoStatusBlock,
                                           PVOID  Buffer,
                                           ULONG  Length,
                                           PVOID  ByteOffset,
                                           PVOID  Key );

typedef ULONG (*LPNVZWREADFILEFUNCTION)  ( PVOID  FileHandle,
                                           PVOID  Event,
                                           PVOID  ApcRoutine,
                                           PVOID  ApcContext,
                                           PVOID  IoStatusBlock,
                                           PVOID  Buffer,
                                           ULONG  Length,
                                           PVOID  ByteOffset,
                                           PVOID  Key );

typedef ULONG (*LPNVZWCLOSEFUNCTION) ( PVOID Handle );

typedef ULONG (*LPNVZWDEVICEIOCONTROLFILEFUNCTION) ( PVOID  FileHandle,
                                                     PVOID  Event,
                                                     PVOID  ApcRoutine,
                                                     PVOID  ApcContext,
                                                     PVOID  IoStatusBlock,
                                                     ULONG  IoControlCode,
                                                     PVOID  InputBuffer,
                                                     ULONG  InputBufferLength,
                                                     PVOID  OutputBuffer,
                                                     ULONG  OutputBufferLength );

typedef struct _NV_ZW_FILE_IO_FUNCS
    {
    LPNVZWCREATEFILEFUNCTION pvZwCreateFile;
    LPNVZWWRITEFILEFUNCTION pvZwWriteFile;
    LPNVZWREADFILEFUNCTION pvZwReadFile;
    LPNVZWCLOSEFUNCTION pvZwClose;
    LPNVZWDEVICEIOCONTROLFILEFUNCTION pvZwDeviceIoControlFile;
    } *PNV_ZW_FILE_IO_FUNCS, NV_ZW_FILE_IO_FUNCS;

//
// OS Version Information Support
// (Some header information stolen from NTDDK.H)
//

typedef struct _NV_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} NV_UNICODE_STRING;
typedef NV_UNICODE_STRING *PNV_UNICODE_STRING;

typedef struct _NV_OS_VERSION_INFO
    {
    ULONG  dwMajorVersion;
    ULONG  dwMinorVersion;
    ULONG  dwBuildNumber;
    ULONG  dwBuildType;
    } *PNV_OS_VERSION_INFO, NV_OS_VERSION_INFO;

#if (_WIN32_WINNT >= 0x0500)
//
// System Memory Information structure
//
typedef struct _NV_SYSMEM_INFO
    {
    ULONGLONG SystemMemorySize;      // Physical memory size in bytes
    ULONGLONG AgpAllocationLimit;    // Max recommended size in bytes for committed AGP meme
    } *PNV_SYSMEM_INFO, NV_SYSMEM_INFO;
#endif // #if (_WIN32_WINNT >= 0x0500)


typedef struct _NV_COMMON_DEVICE_INFO
    {
    ULONG  ulDeviceReference;
    ULONG  ulEnableDualView;
    ULONG  ulDualViewSecondary;

    NV_OS_VERSION_INFO OsVersionInfo;
#if (_WIN32_WINNT >= 0x0500)
    NV_SYSMEM_INFO     SysMemInfo;
#endif
    } *PNV_COMMON_DEVICE_INFO, NV_COMMON_DEVICE_INFO;

typedef struct _RESOLUTION_INFO
{
    ULONG ulDisplayWidth;           // width  
    ULONG ulDisplayHeight;          // Height
    ULONG ulDisplayRefresh;         // refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
} RESOLUTION_INFO;

//
// Possible values for ulOption in the HEAD_RESOLUTION_INFO structure
// Currently only one flag is being used.
//
#define HEAD_RESOLUTION_OPTION_DONT_BACKOFF 1

typedef struct _HEAD_RESOLUTION_INFO
{
    ULONG ulDisplayWidth;           // width  
    ULONG ulDisplayHeight;          // Height
    ULONG ulDisplayRefresh;         // refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
    ULONG ulHead;                     // Whether 0 or 1. This is the physical head number
    ULONG ulDeviceMask;             // Bitmask of Device.
    ULONG ulDeviceType;             // Device type of the head.
    ULONG ulTVFormat;
    ULONG ulOption;                 // if DONT_BACKOFF is set, then if the requested mode is not supported in
                                    // the EDID, ignores the EDID and returns the timing without backing off.
} HEAD_RESOLUTION_INFO;


typedef struct _dac_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} DAC_TIMING_VALUES;

//
// Possible values for the registry entry "GDIModePruning".
//
// Absent or 0: Driver always provides EDID mode pruning protection.
// 1:   For desktop or laptop systems, for CRT, for the
//      standard mode device and the primary device in clone mode and
//      both devices in XP DualView mode, lets the GDI handle EDID 
//      mode pruning via "Hide Modes" monitor checkbox.
// 2:   For desktop systems only, for CRT or DFP, for the
//      standard mode device and the primary device in clone mode and
//      both devices in XP DualView mode, lets the GDI handle EDID 
//      mode pruning via "Hide Modes" monitor checkbox.
//
#define GDI_MODE_PRUNING_NONE                       0
#define GDI_MODE_PRUNING_DESKTOP_LAPTOP_CRT         1
#define GDI_MODE_PRUNING_DESKTOP_CRT_DFP            2



//
// structures used forr NT4 multi device layer
//
typedef struct _QUERY_NUM_OF_DEVICE_OBJECTS
{
    union
    {
        IN  HANDLE hDriver;
        IN  PVOID  pvDevObj;
        OUT ULONG  ulNumDevObj;
    };
} QUERY_NUM_OF_DEVICE_OBJECTS;

typedef struct _GET_DEVICE_OBJECTS
{
    union
    {
        IN  HANDLE hDriver;
        IN  PVOID  pvDevObj;
    };
    IN  ULONG  ulNumDevObj;
    union
    {
        OUT  HANDLE ahDriver[1];
        OUT  PVOID  apvDevObj[1];
    };
    
} GET_DEVICE_OBJECTS;

#endif // _DSPIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\minii2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * minii2c.c
 *
 *  I2C functionality for the miniport
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef NVPE

//#define INITGUID     // Instantiate GUID_I2C_INTERFACE

#include <ntstatus.h>
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
typedef unsigned int    UINT;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command functions
ULONG nvVPECommand(PHW_DEVICE_EXTENSION pHwDevExt, ULONG cmd, PVOID pData);
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

DECLSPEC_IMPORT
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

extern ULONG i2cAccess(PVOID, U032, NVRM_I2C_ACCESS_CONTROL *);

/*----------------------------------------------------------------------------*/
/*
 * globals
 *
 */

extern PHWINFO NvDBPtr_Table[];

/*
 * AcquireI2C() - Acquire I2C routine (Common)
 */
NTSTATUS AcquireI2C (
    PDEVICE_OBJECT          pDev,
    PHW_DEVICE_EXTENSION    pHwDevExt,
    PHWINFO                 pNvInfo,
    ULONG                   port,
    ULONG                   head )
{
    NTSTATUS                result;

    // Build command to acquire the I2C port

    pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_ACQUIRE;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

    // Try to acquire the desired I2C port

    if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
    {
        // I2C port acquired, update I2C structure (Including time)

        pHwDevExt->I2C_Ports[port].ulStatus = I2C_PORT_ACQUIRED;
        pHwDevExt->I2C_Ports[port].ulOwner = (ULONG) pDev;
        KeQuerySystemTime(&pHwDevExt->I2C_Ports[port].lTimeStamp);

        // Set the result status value

        result = STATUS_SUCCESS;
    }
    else    // Could not acquire the I2C port
    {
        // Set the result status value

        result = STATUS_OPEN_FAILED;
    }
    // Return result to the caller

    return(result);
}

/*
 * ReleaseI2C() - Release I2C routine (Common)
 */
NTSTATUS ReleaseI2C (
    PDEVICE_OBJECT          pDev,
    PHW_DEVICE_EXTENSION    pHwDevExt,
    PHWINFO                 pNvInfo,
    ULONG                   port,
    ULONG                   head )
{
    NTSTATUS                result;

    // Build command to release the I2C port

    pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_RELEASE;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

    // Try to free the I2C port

    if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
    {
        // I2C port is now release, update I2C structure

        pHwDevExt->I2C_Ports[port].ulStatus = I2C_PORT_FREE;
        pHwDevExt->I2C_Ports[port].ulOwner = 0;
        pHwDevExt->I2C_Ports[port].lTimeStamp.QuadPart = 0;

        // Set the result status value

        result = STATUS_SUCCESS;
    }
    else    // Error releasing the I2C port
    {
        // Set the result status value

        result = STATUS_OPEN_FAILED;
    }
    // Return result to the caller

    return(result);
}

/*
 * miniI2COpen() - Miniport I2C Open routine (Common)
 */

NTSTATUS miniI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl,
    ULONG           port,
    ULONG           head )
{
    PHW_DEVICE_EXTENSION    pHwDevExt;
    PHWINFO                 pNvInfo;
    NTSTATUS                result;
    LARGE_INTEGER           time, elapsed;

    // Get hardware device extension and information based on the device object

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    // Check for WDM backdoor to VPE request  (This is allow WDM drivers to set
    // some VPE parameters that aren't or can't be set by WDM's overlay mixer.)

    if ((pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK)
    {
        // Call routine to process the VPE command

        pI2CCtrl->Status = nvVPECommand(pHwDevExt, (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl);

        // Set result to status of VPE command

        result = pI2CCtrl->Status;
    }
    else    // This is a normal I2C open command
    {
        // Check to see if this is an acquire/release request

        if (acquire == TRUE)
        {
            // This is an acquire request, check for I2c port free

            if (pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_FREE)
            {
                // I2C port is free, try to acquire the desired I2C port

                if (AcquireI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                {
                    // I2C port acquired, set the I2C and result status values

                    pI2CCtrl->dwCookie = (ULONG) pDev;
                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Could not acquire the I2C port
                {
                    // Set the I2C and result status values

                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                }
            }
            else    // This port is already acquired
            {
                // Compute the amount of time since last I2C access

                KeQuerySystemTime(&time);
                elapsed.QuadPart = time.QuadPart - pHwDevExt->I2C_Ports[port].lTimeStamp.QuadPart;

                // Check to see if port timeout has occurred

                if ((elapsed.HighPart != 0) || (elapsed.LowPart > I2C_PORT_TIMEOUT))
                {
                    // Port timeout has occurred, try to release current owner

                    if (ReleaseI2C((PDEVICE_OBJECT) pHwDevExt->I2C_Ports[port].ulOwner, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                    {
                        // Current owner released, try new owner acquire

                        if (AcquireI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                        {
                            // I2C port acquired, set I2C and result status values

                            pI2CCtrl->dwCookie = (ULONG) pDev;
                            pI2CCtrl->Status = I2C_STATUS_NOERROR;
                            result = STATUS_SUCCESS;
                        }
                        else    // Unable to acquire for new owner
                        {
                            // Set the I2C and result status values

                            pI2CCtrl->dwCookie = 0;
                            pI2CCtrl->Status = I2C_STATUS_BUSY;
                            result = STATUS_OPEN_FAILED;
                        }
                    }
                    else    // Unable to release current owner
                    {
                        // Set the I2C and result status values

                        pI2CCtrl->dwCookie = 0;
                        pI2CCtrl->Status = I2C_STATUS_BUSY;
                        result = STATUS_OPEN_FAILED;
                    }
                }
                else    // Port access has not timed out
                {
                    // Set the I2C and result status values

                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_BUSY;
                    result = STATUS_OPEN_FAILED;
                }
            }
        }
        else    // This is a release request
        {
            // Check to make sure port is acquired and the correct owner

            if ((pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_ACQUIRED)  &&
                (pHwDevExt->I2C_Ports[port].ulOwner == (ULONG) pDev)        &&
                (pI2CCtrl->dwCookie == (ULONG) pDev))
            {
                // Valid release request, try to release the I2C port

                if (ReleaseI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                {
                    // I2C port released, set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error releasing the I2C port
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                }
            }
            else    // Port not acquired or incorrect owner
            {
                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_INVALID_HANDLE;
            }
        }
    }
    // Return result to the caller

    return(result);
}

/*
 * miniI2CAccess - Miniport I2C Access routine (Common)
 */

NTSTATUS miniI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl,
    ULONG           port,
    ULONG           head )
{
    PHW_DEVICE_EXTENSION    pHwDevExt;
    PHWINFO                 pNvInfo;
    NTSTATUS                result;

    // Get hardware device extension and information based on the device object

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    // Check to make sure port is acquired and the correct owner

    if ((pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_ACQUIRED)  &&
        (pHwDevExt->I2C_Ports[port].ulOwner == (ULONG) pDev)        &&
        (pI2CCtrl->dwCookie == (ULONG) pDev))
    {
        // I2C port is owned, update the I2C port access time stamp

        KeQuerySystemTime(&pHwDevExt->I2C_Ports[port].lTimeStamp);

        // Start building the I2C command (Common flags and port)

        pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
        pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

        if (pI2CCtrl->Flags & I2C_FLAGS_START)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_START;
        if (pI2CCtrl->Flags & I2C_FLAGS_STOP)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_STOP;
        if (pI2CCtrl->Flags & I2C_FLAGS_ACK)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_ACK;

        // Switch on the requested I2C command        

        switch(pI2CCtrl->Command)
        {
            case I2C_COMMAND_WRITE:     // I2c write byte command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_WRITE_BYTE;
                pHwDevExt->I2C_Ports[port].rmI2CCtrl.data = pI2CCtrl->Data;

                // Try to perform the requested write command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing write command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_READ:      // I2C read byte command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_READ_BYTE;

                // Try to perform the requested read command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Save the I2C read data (Complete DWORD)

                    pI2CCtrl->Data        = (BYTE) (pHwDevExt->I2C_Ports[port].rmI2CCtrl.data & 0xFF);
                    pI2CCtrl->Reserved[0] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >>  8) & 0xFF);
                    pI2CCtrl->Reserved[1] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >> 16) & 0xFF);
                    pI2CCtrl->Reserved[2] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >> 24) & 0xFF);

                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing read command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Data = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_NULL:      // I2C null command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;

                // Try to perform the requested null command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing null command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_STATUS:    // I2C status command

                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                result = STATUS_SUCCESS;

                break;

            case I2C_COMMAND_RESET:     // I2C reset command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;

                // Try to perform the requested reset command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing reset command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            default:                    // Unknown I2C command

                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_INVALID_PARAMETER;

                break;
        }
    }
    else    // Port not acquired or incorrect owner
    {
        // Check for an I2C port status command (Only valid non-owner command)

        if (pI2CCtrl->Command == I2C_COMMAND_STATUS)
        {
            // Get the status of the request I2C port (Free/Acquired)

            if (pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_FREE)
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
            else
                pI2CCtrl->Status = I2C_STATUS_BUSY;

            // Setup the result status value

            result = STATUS_SUCCESS;
        }
        else    // Invalid I2C access command
        {
            // Set the I2C and result status values

            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_INVALID_HANDLE;
        }
    }
    // Return result to the caller

    return(result);
}

/*
 * NVGetI2CPort(HwID) - Get I2C port based on hardware ID
 */

ULONG
NVGetI2CPort(
    IN ULONG HwID)
{
    ULONG I2CPort;

    // Switch on the hardware ID value

    switch(HwID)
    {
        case 0:

            // Special value indicating dynamic I2C port (Based on real ID)

            I2CPort = I2C_ACCESS_DYNAMIC_PORT;
            break;

        case QUERY_MONITOR_ID:
        case QUERY_MONITOR_ID2:
        case QUERY_NONDDC_MONITOR_ID:
        case QUERY_NONDDC_MONITOR_ID2:
        case QUERY_ACPI_CRT_ID:
        case QUERY_ACPI_DFP_ID:

            // This is a monitor, setup for primary port

            I2CPort = I2C_ACCESS_PRIMARY_PORT;
            break;

        case NVCAP_I2C_DEVICE_ID:
        case NVXBAR_I2C_DEVICE_ID:
        case NVTUNER_I2C_DEVICE_ID:
        case NVTVSND_I2C_DEVICE_ID:

            // This is an external device, setup for secondary port

            I2CPort = I2C_ACCESS_SECONDARY_PORT;
            break;

        default:

            // Unknown hardware device ID, default to secondary port

            VideoDebugPrint((1, "NVGetI2CPort: Unknown hardware ID!\n"));
            I2CPort = I2C_ACCESS_SECONDARY_PORT;
            break;
    }
    return I2CPort;
}

/*
 * NVGetI2CHead(HwID) - Get I2C head based on hardware ID
 */

ULONG
NVGetI2CHead(
    IN ULONG HwID)
{
    ULONG I2CHead;

    // Switch on the hardware ID value

    switch(HwID)
    {
        case QUERY_MONITOR_ID:
        case QUERY_NONDDC_MONITOR_ID:
        case QUERY_ACPI_CRT_ID:
        case QUERY_ACPI_DFP_ID:

            // This is the primary monitor, use head number 0

            I2CHead = 0;
            break;

        case QUERY_MONITOR_ID2:
        case QUERY_NONDDC_MONITOR_ID2:

            // This is the secondary monitor, use head number 1

            I2CHead = 1;
            break;

        case NVCAP_I2C_DEVICE_ID:
        case NVXBAR_I2C_DEVICE_ID:
        case NVTUNER_I2C_DEVICE_ID:
        case NVTVSND_I2C_DEVICE_ID:

            // This is an external device, use head number 0

            I2CHead = 0;
            break;

        default:

            // Unknown hardware device ID, default to head number 0

            VideoDebugPrint((1, "NVGetI2CHead: Unknown hardware ID!\n"));
            I2CHead = 0;
            break;
    }
    // Return the I2C head number

    return I2CHead;
}

/*
 * dynI2COpen() - Dynamic I2C port version of I2COpen()
 */

NTSTATUS dynI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS result = STATUS_SUCCESS;
    ULONG Port;
    ULONG Head;
    ULONG HwID;

    // Get the hardware device extension for this device

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    // Check to make sure we can convert PDO to hardware ID

    if (pHwDevExt->pfnVideoPortGetAssociatedDeviceID)
    {
        // Convert the PDO value to a hardware ID

        HwID = (*pHwDevExt->pfnVideoPortGetAssociatedDeviceID)(pDev);

        // Get the requested I2C port and head values

        Port = NVGetI2CPort(HwID);
        Head = NVGetI2CHead(HwID);

        // Try to perform the requested I2C open operation

        result = miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
    }
    else    // Unable to convert PDO, invalid dynamic I2C open
        result = STATUS_INVALID_PARAMETER;

    return(result);
}

/*
 * dynI2CAccess - Dynamic I2C port version of I2CAccess()
 */

NTSTATUS dynI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS result = STATUS_SUCCESS;
    ULONG Port;
    ULONG Head;
    ULONG HwID;

    // Get the hardware device extension for this device

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    // Check to make sure we can convert PDO to hardware ID

    if (pHwDevExt->pfnVideoPortGetAssociatedDeviceID)
    {
        // Convert the PDO value to a hardware ID

        HwID = (*pHwDevExt->pfnVideoPortGetAssociatedDeviceID)(pDev);

        // Get the requested I2C port and head values

        Port = NVGetI2CPort(HwID);
        Head = NVGetI2CHead(HwID);

        // Try to perform the requested I2C access operation

        result = miniI2CAccess(pDev, pI2CCtrl, Port, Head);
    }
    else    // Unable to convert PDO, invalid dynamic I2C access
        result = STATUS_INVALID_PARAMETER;

    return(result);
}

/*
 * priI2COpen() - Primary I2C port version of I2COpen()
 */

NTSTATUS priI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_PRIMARY;
    ULONG Head = 0;

    // Try to perform the requested I2C open operation

    return miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
}

/*
 * priI2CAccess - Primary I2C port version of I2CAccess()
 */

NTSTATUS priI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_PRIMARY;
    ULONG Head = 0;
    ULONG HwID;

    // Try to perform the requested I2C access operation

    return miniI2CAccess(pDev, pI2CCtrl, Port, Head);
}

/*
 * secI2COpen() - Secondary I2C port version of I2COpen()
 */

NTSTATUS secI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_SECONDARY;
    ULONG Head = 0;

    // Try to perform the requested I2C open operation

    return miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
}

/*
 * secI2CAccess - Secondary I2C port version of I2CAccess()
 */

NTSTATUS secI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_SECONDARY;
    ULONG Head = 0;

    // Try to perform the requested I2C access operation

    return miniI2CAccess(pDev, pI2CCtrl, Port, Head);
}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(pHwDevExt,
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(pHwDevExt,
                                    ((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(pHwDevExt,
                                    0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit(PHW_DEVICE_EXTENSION pHwDevExt)
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(pHwDevExt,
                        1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode 
                        0,      //set default VP surf type = overlay 
                        0xf);   //use all values

}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
    PNVP_CONTEXT pVPEContext;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    if(ulFlag & 0x8){
        pVPEContext->ulVPECapturePrescaleXFactor=ulX;
    }

    if(ulFlag & 0x4){
        pVPEContext->ulVPECapturePrescaleYFactor=ulY;
    }

    if(ulFlag & 0x2){
        pVPEContext->ulVPECaptureFlag=ulCap;
    }

    if(ulFlag & 0x1){
        pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
    }


    return 0;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modedata.c ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000




VGATBL   vga_tbl[] =
{
    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
     0x05, 0x0F, 0xFF}
    },

    // Basic CRTC Table for Planar Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};

EXTREGS eregs[] =    // Extended Register Tables
{
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes      00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101    01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103    03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104    04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105    05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106    06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78        0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E        0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F        0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20        15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21        19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22        1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20        1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20        1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20        20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20        21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72        22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72        23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105    24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20        28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20        29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        32:

    // JJV - New Modes (I think this starts at 0x33 ??)
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156},  // 3A: 1920X1200X32
    // JJV - New Modes

    // VEL - New Dell Modes
    {0x0C, 0x40, 0x05, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_136_36},  // 3B: 1600x1024x8      
    {0x0C, 0x41, 0x05, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_136_36},  // 3C: 1600x1024x16     
    {0x0C, 0x43, 0x05, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_136_36}   // 3D: 1600x1024x32     
    // VEL - New Dell Modes

};

TVREGS tvregs[] =    // TV Timing Tables
{
    {0x60, 0x00, 0x67, 0x5B, 0x31, 0x2E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 0 - VGA Mode 3
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xA9, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 1 - VGA Mode 11/12
    {0x60, 0x00, 0x68, 0x5B, 0x23, 0x3E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x38, 0x8F, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0xA1, 0xBA, 0x30, 0x4F, 0x50, 0x00, 0x85, 0x05, 0x7F, 0xE0, 0x0D },   // TV Mode 2 - VGA Mode 13
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xD0, 0xFF, 0x0D,
     0x06, 0x82, 0x70, 0x81, 0xF8, 0x30, 0x63, 0x63, 0x8B, 0x85, 0x05, 0x00, 0xE0, 0x0D },   // TV Mode 3 - VGA Modes > 640x480
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0x90, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 4 - 640x400 Extended Modes
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D }   // TV Mode 5 - 640x480 Extended Modes
};

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,      // 1F: 219.566
    17280,      // 20: 172.798
    19316,      // 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    13636       // 23: 136.36
};

U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7, 0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x027,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //17:
    // Settings for 1600x1024:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

};

//  this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
    // depths: 4 (planar modes), 8, 16, 24/32
    //0:
    // 1600 x 1200
    0xff, 0x145, 0x146, 0x14E,
    //1:
    // 1280 x 1024
    0x106, 0x107, 0x11a, 0x14D,
    //2:
    // 1152 x 864
    0xff, 0x141, 0x142, 0x143,
    //3:
    // 1024 x 768
    0x104, 0x105, 0x117, 0x118,
    //4:
    // 960 x 720
    0xff, 0x14a, 0x14b, 0x14c,
    //5:
    // 800 x 600
    0x102, 0x103, 0x114, 0x115,
    //6:
    // 640 x 480
    0xff, 0x101, 0x111, 0x112,
    //7:
    // 640 x 400
    0xff, 0x100, 0x13d, 0x13e,
    //8:
    // 512 x 384
    0xff, 0x13a, 0x13b, 0x13c,
    //9:
    // 480 x 360
    0xff, 0x147, 0x148, 0x149,
    //10:
    // 400 x 300
    0xff, 0x137, 0x138, 0x139,
    //11:
    // 320 x 400
    0xff, 0x131, 0x132, 0x133,
    //12:
    // 320 x 240
    0xff, 0x134, 0x135, 0x136,
    //13:
    // 320 x 200
    0xff, 0x130, 0x10e, 0x10f,

    //14:
    // 1920 x 1200
    0xff, 0x154, 0x155, 0x156,
    //15:
    // 1920 x 1080
    0xff, 0x151, 0x152, 0x153,
    //16:
    // 1800 x 1440
    0xff, 0x14f, 0x150, 0xff,

    //17:
    // 1600 x 1024
    0xff, 0x157, 0x158, 0x159


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\memstruc.h ===
//****************************Module*Header***********************************
//
// Module Name: memstruc.h
//
//****************************************************************************

/*****************************************************************************
 *                                                                           *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.             *
 *                                                                           *
 ****************************************************************************/

//----------------------------------------------------------------------------
// WARNING:  For now, make sure this structure agrees with the one defined in MCD.H
//           We'll eventually move over to exclusively using THIS file,
//           so that the display driver can also use the memory_t structure.
//----------------------------------------------------------------------------

typedef struct _memory_t
{
    struct _memory_t    *prev;
    struct _memory_t    *next;
    struct _memory_t    *nextEmpty;
    ULONG               blkSize;
    ULONG               memBase;
} memory_t;

#define EMPTY               0x1
#define ALIGN_SIZE          64

#define IS_EMPTY(pBlk)      (((ULONG_PTR)(pBlk)->prev) & EMPTY )
#define SET_EMPTY(pBlk)     (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) + EMPTY)
#define SET_BUSY(pBlk)      (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) - EMPTY)
#define EMPTY_VALUE(pBlk)   ((memory_t *) (((BYTE *)(pBlk)) + EMPTY))
#define BUSY_VALUE(pBlk)    ((memory_t *) (((BYTE *)(pBlk)) - EMPTY))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\ddminint.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 *  Files:
 *           ddmini16.c
 *           ddddrv16.c
 *           ddmode.c
 *
 *           dddrv32.c
 *           blt832.c
 *           blt1632.c
 *           blt3232.c
 *
 ***************************************************************************/
#ifndef _DDMININT_H_
#define _DDMININT_H_

// Turn this off to disable the use of the VPP code for the winnt4
// display driver. @mjl@
#define MJL_USE_VPP


// Note:

// From NT4 DDK (Graphics System Overview)
//    The display driver is in the same privileged kernel-mode address space as the 
//    rest of the Windows NT Executive. Faults in the display driver will cause GDI 
//    and the rest of the system to fault.

#include "nvPusher.h"
#include "nvVPP.h"
#include "nvUtil.h"
#include "CompileControl.h"

#ifndef NVD3D
#include "nvFourCC.h"
#undef NV_MAX_FOURCC
#define NV_MAX_FOURCC 7
#endif

#define NV_MAX_EXTRA_FS_SURFACES 4
#define NV_MAX_EXTRA_SURFACES    6

//  Remove double-defintion warning
#ifdef  DIRECTDRAW_DLLNAME
#undef  DIRECTDRAW_DLLNAME
#endif
#define DIRECTDRAW_DLLNAME "NV3DD32.DLL"

#ifndef _WIN32
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
#include <ddrawi.h>
#endif

#define FAST register

//  Remove double-definition warning
#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

// Probably should move these up to a more general level -@mjl@

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */


//************************************************************************************
// Entry/exit macros used by the ddraw driver to acquire the rendering semaphore from the
// This notifies the OGL ICD that we need to touch the fifo
//************************************************************************************
#define START_DMA_PUSH_SYNC()           \
{ \
    ppdev->pfnAcquireOglMutex(ppdev); \
    ppdev->NVFreeCount = 0; \
    releaseOpenglSemaphore = TRUE; \
}

#define ENTER_DMA_PUSH_SYNC()           \
    if (OglIsEnabled(ppdev))       \
        {                               \
        START_DMA_PUSH_SYNC(); \
        }

#define END_DMA_PUSH_SYNC() \
    if (releaseOpenglSemaphore == TRUE) \
        {                               \
        ppdev->pfnReleaseOglMutex(ppdev); \
        }

#define EXIT_DMA_PUSH_SYNC(exitcode)    \
{ \
    END_DMA_PUSH_SYNC();            \
    return(exitcode); \
}


/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

//  Remove double-definition warning
#ifdef  DDMINI_VERSION
#undef  DDMINI_VERSION
#endif
#define DDMINI_VERSION  0x0300



#ifndef NVD3D
typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    short   y;
    short   x;
} NVYX;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;

typedef struct {
    unsigned short h;
    unsigned short w;
} NVHW;

typedef union {
    long xy;
    long yx;
    unsigned long wh;
    unsigned long hw;
    NVXY xy16;
    NVYX yx16;
    NVWH wh16;
    NVHW hw16;
} NVCOORD;

// Not sure this is the best approach to accessing this object methods. -@mjl@
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters
// 
// Used to allow sharing of several objects (ROP, 2D SURFACE, ...?)
//  by multiple users within the same context (may not need in NT4) -@mjl@

typedef struct BltData_s {
    NvU32               dwStatusReferenceCount;
    NvU32               dwSystemSurfaceContextDMAIndex;
    NvU32               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    NvU32               dwLastRop;
    NvU32               dwLastColourKey;
    NvU32               dwLastColourFormat;
    NvU32               dwLastCombinedPitch;
    NvU32               dwLastSrcOffset;
    NvU32               dwLastDstOffset;
    NvU32               dwSystemBltFallback;
    NvU32               dwLetItThrash;
    NvU32               dwQueuedPrimaryBlitCount;
} BltData_t;

typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
} FLIPRECORD;


// I think these are mocomp... why are they used in VPP? -@mjl@
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;


typedef struct _PDEV PDEV;      // Handy forward declaration

typedef struct _GLOBALDATA
{
    // lpPDevice *must* be first (DIBLINK.ASM) uses it.
#ifdef _WIN32
    DWORD                       lpPDevice;
#else
    DIBENGINE FAR *             lpPDevice;
#endif


    DWORD                       dwVersion;
    DWORD                       fIsDisplay;

    // flags
    DWORD                       DDrawVideoSurfaceCount; // *MUST* start at 0xC offset from beginning of struct (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;   // *MUST* start at 0x10 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fFullScreenDosOccurred; // *MUST* start at 0x12 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
    WORD                        OverlayBufferIndex;

    // info about the current mode
    DWORD                       ModeNumber;
    DWORD                       TotalVRAM;          // total VRAM on card
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
    DWORD                       BaseAddress;        // base addess of accessable video memory.(set to zero on NT)
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    WORD                        OverlaySrcX;        // overlay source starting point
    WORD                        OverlaySrcY;

    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    PDEV *                      ppdev;  // A pointer back to the physical device
    // NV stuff
//    DWORD                       lpNvDev;
//    DWORD                       lpNvDmaBuffer;
//    DWORD                       NvDevFlat;
    DWORD                       NvDevFlatVPE; // Vpe channel (used in NV3 -- maybe)
//    DWORD                       NvDmaBufferFlat;
//    DWORD                       NvDummyNotifierFlat;
//    DWORD                       NvFlipPrimaryNotifierFlat;
//    DWORD                       NvFlipOverlayNotifierFlat;
//    DWORD                       NvFlipVportNotifierFlat;
//    DWORD                       NvDmaToMemNotifierFlat;
//    DWORD                       NvDmaFromMemNotifierFlat;
//    DWORD                       NvDmaFromMemBaseAddress;
//    DWORD                       NvDmaFromMemSurfaceMem;
//    DWORD                       NvPusherSyncNotifierFlat;
//    DWORD                       NvScanlineBufferFlat;
//    DWORD                       NvFloating0UYVYSurfaceMem;
//    DWORD                       NvFloating1UYVYSurfaceMem;
//    DWORD                       NvFloating0YUYVSurfaceMem;
//    DWORD                       NvFloating1YUYVSurfaceMem;
//    DWORD                       NvFloatingMem2MemFormatBaseAddress;
//    DWORD                       NvYUY2Surface0Mem;
//    DWORD                       NvYUY2Surface1Mem;
//    DWORD                       NvFloatingMem2MemFormatMemoryHandle;
//    DWORD                       NvWinDmaPusherNotifierFlat;
//    DWORD                       dwVideoPortsAvailable;
//    DWORD                       NvFloatingTexture;
//    DWORD                       CurrentVisibleSurfaceAddress;
//    DWORD                       lpLast3DSurfaceRendered;
    NvU32                       NvBaseFlat;                        // Base Address of NV IoSpace
//    DWORD                       dwOverlaySurfaces;
//    DWORD                       dwOverlayOwner;

//    DWORD                       dwOverlaySrcHeight;
//    DWORD                       dwOverlayDstHeight;
//    DWORD                       dwModeIndex;
//    DWORD                       dwUseRefreshRate;
//    DWORD                       NvFloatingMem2MemFormatNextAddress;
//    DWORD                       NvYUY2Surface2Mem;
    DWORD                       physicalColorMask; // (accessed in NV3 -- but used?)
    WORD                        flatSelector; // NV3 only -- used?
    WORD                        NvFreeCount;
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    BYTE                        ThreeDRenderingOccurred;// NV3 only -- used?
    BYTE                        unused_01;

//    DWORD                       fourCC[16];    // leave some empty locations so we can add more without rereleasing 16 bit portion of driver

    //*********************************************************************************
    // Stuff added for compatibility with NT5/Win9x Build
    //*********************************************************************************
    // TBD: make sure ALL of these are initialized properly -@mjl@
    LPPROCESSINFO               lpProcessInfoHead;
    PROCESSINFO                 procInfo;           // statically created for WinNT4/Win2k
    NvU16                       NvDeviceVersion;
    NvU8                        TwoDRenderingOccurred;       // Used trivially by VPP, but not otherwise
    NvU8                        unused_02;
    NvU32                       dwRootHandle;       
    NvU32                       dwDeviceHandle;
    NvU32                       dwSurfaceAlignPad;
    NvU32                       dwMostRecent3dUser;
    NvU32                      *pCurrentChannelID;
    NvU32                       regPBLocale;
    NvU32                       blitCalled;

    NvU32                       dDrawSpareSubchannelObject;  // This is referenced DIRECTLY by the VPP code.  Fix @mjl@
    NvU32                       ddClipUpdate;                // Used trivially by VPP, but not otherwise
    NvU32                       dwDXVAFlags;                 // Used trivially by VPP, but not otherwise
    NvU32                       dwSharedClipChangeCount;     // TBD: vpp makes global ref to these! -@mjl@
    NvU32                       dwDDMostRecentClipChangeCount;//Ditto

    CPushBuffer                 nvPusher;   // Used exclusively by the ported VPP code

    NV_SystemInfo_t             sysInfo;
    BltData_t                   bltData;
    FLIPRECORD                  flipPrimaryRecord;
    FLIPRECORD                  flipOverlayRecord;

    NvU32                       dwTVTunerFlipCount;
    NvU32                       dwOverlayFlipCount;
    NvU32                       dwHeads;            // number of heads (DACs) on this device
    NvU32                       dwDesktopState;
    NvV32                      *pCommonNotifierBuffer;
    NvNotification             *pPioFlipOverlayNotifierFlat; // To be changed! @mjl@

    //*********************************************************************************
    // Video & Overlay Stuff
    //*********************************************************************************
    Vpp_t                       vpp;

#if 0
    // D3D stuff
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwCurrentContextPtr;
    DWORD                       dwCurrentTextureHandle;
    DWORD                       dwCurrentTexturePtr;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTriangleContextHandle;
    DWORD                       dwTriangleContextAddr;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       hPipelines_gbl;
    DWORD                       hMaterials_gbl;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regDmaMinPushCount;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;

    // DirectDraw stuff
    DWORD                       fReset;
    DD_HALINFO                  HALInfo;    // This is unreferenced... check to see if we need it @mjl@
    DD_CALLBACKS                DDCallbacks;
    DD_SURFACECALLBACKS         DDSurfaceCallbacks;
    DD_PALETTECALLBACKS         DDPaletteCallbacks;
#endif
} GLOBALDATA;
#endif // #ifndef NVD3D

/***************************************************************************
 ***************************************************************************/
#ifdef _WIN32

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

extern GLOBALDATA           DriverData;     // in ddmini16.c

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void FAR PASCAL HWBeginAccess(DIBENGINE FAR *,short,short,DWORD,DWORD);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* Escape functions */
#define MOUSETRAILS         39
#define DCICOMMAND          3075
#define GETSURFINFO         0x6979
#define GETNVCHANNELPTR     0x6980
#define RECONFIGNVOFFSCREEN 0x6981
#define NVSETDDRAWMODE      0x6982


#ifndef DX7   // For DX7, this is defined in ddmini.h.
/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF
#endif

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines. NV3 and NV4 surface alignments have
   been changed since NV10 video scaler only supports 64 byte aligned
   surfaces. Note that changing these #defines causes ALL vidmem surfaces
   to be 64 byte aligned.
 */
#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV3_BIT_ALIGNMENT        128
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV4_BIT_ALIGNMENT        256
#define NV10_BYTE_ALIGNMENT_PAD  63L
#define NV10_BIT_ALIGNMENT       512

#define NV10_INITIAL_PITCH    64
#define NV4_INITIAL_PITCH     32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#ifndef NVD3D

#if _WIN32_WINNT < 0x0500
//*************************************************************************
// Misc stuff which changed between dx3 and dx5, Win95 and WinNT
//*************************************************************************
#define DDSCAPS_LOCALVIDMEM DDSCAPS_VIDEOMEMORY
#ifndef NV_AGP
// BUGBUG need to undefine this when AGP support arrives
#define DDSCAPS_NONLOCALVIDMEM DDSCAPS_SYSTEMMEMORY
#endif
#endif // #if _WIN32_WINNT < 0x0500
#endif  // #ifndef NVD3D

/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
#ifdef DEBUG
#if defined(_WIN32_WINNT)
//#define DPF(a) DISPDBG((0, (a))
#define BREAK() EngDebugBreak();
#else
    extern void __cdecl DPF(LPSTR szFormat, ...);
    #define BREAK() DebugBreak();
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif

#define DDRAW_SET_PRIMARY(ppdev, Offset, Stride)        \
       if (Stride < 32)                                 \
           ppdev->DdCurrentDestPitch = 32;              \
       else                                             \
           {                                            \
           ppdev->DdCurrentDestPitch = ((Stride + ppdev->ulSurfaceAlign ) & ~ppdev->ulSurfaceAlign);          \
           }                                            \
                                                        \
       ppdev->DdCurrentDestOffset = Offset;             \
       while (freeCount < 3*4)                          \
           freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
       freeCount -= 3*4;                                \
                                                        \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch << 16) | (ppdev->DdCurrentSourcePitch));  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = ppdev->DdCurrentSourceOffset;  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = Offset

#define DDRAW_SET_SOURCE(ppdev, Offset, Stride)         \
    if (Stride < 32)                                    \
        ppdev->DdCurrentSourcePitch = 32;               \
    else                                                \
        {                                               \
        ppdev->DdCurrentSourcePitch = ((Stride + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);          \
        }                                               \
    ppdev->DdCurrentSourceOffset = Offset;              \
    while (freeCount < 3*4)                             \
        freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
    freeCount -= 3*4;                                   \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch <<16) | (ppdev->DdCurrentSourcePitch));    \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = Offset;  \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = ppdev->DdCurrentDestOffset

#if (_WIN32_WINNT >= 0x0500) && defined(NV3) && !defined(DISPDRV)
#ifdef RM_HEAPMGR
#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9

extern BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV *);

// TBD: create a better way of allocating and freeing memory - huge macro!  Baaaadddd. -@mjl@
#define NVHEAP_ALLOC(sts,pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (!PDEV_PTR()->DDrawVideoSurfaceCount)     \
    {                                       \
        PDEV_PTR()->cbGdiHeap = PDEV_PTR()->VideoHeapTotal -   \
        PDEV_PTR()->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = PDEV_PTR()->hClient;  \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    (sts) = HeapParams.status; \ 
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(PDEV_PTR());    \
        HeapParams.hRoot = PDEV_PTR()->hClient;  \
        HeapParams.hObjectParent = PDEV_PTR()->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            PDEV_PTR()->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = PDEV_PTR()->hClient;      \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PDEV_PTR()->VideoHeapFree = HeapParams.free;              \
}
#else // !RM_HEAPMGR
#define NVHEAP_INIT(strt, end, heap)  \
    heap_init((strt), (end), heap)
#define NVHEAP_INFO()
#define NVHEAP_CLEAR(heap)  \
    heap_clear(heap)
#define NVHEAP_ALLOC(pvm,sz,tp)             \
    (pvm) = heap_alloc(sz, (memory_t *) (ppdev)->heap.heap_2d_ptr);
// TBD: where do we get sts in this case?
#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), (memory_t *) (ppdev)->heap.heap_2d_ptr);
#endif // !RM_HEAPMGR
#endif // NV3

//**************************************************************************************
// Common ddraw fct prototypes.
//**************************************************************************************
EXTERN_C BOOL __stdcall nvDeterminePerformanceStrategy_NT4(GLOBALDATA *pDriverData, NV_SystemInfo_t *pSysInfo);
EXTERN_C DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface );
EXTERN_C DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey);
EXTERN_C DWORD DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface);
EXTERN_C DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
EXTERN_C DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
EXTERN_C DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
EXTERN_C DWORD GetScanLine32(PDD_GETSCANLINEDATA lpGetScanLine );
DWORD Nv3Blt(PDD_BLTDATA pbd);
DWORD Nv4Blt(PDD_BLTDATA pbd);
DWORD __stdcall Nv3DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv3Flip(PDD_FLIPDATA pfd);
DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd);
DWORD Nv3GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD Nv4GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *lpData);
DWORD Nv3Lock(PDD_LOCKDATA lpLockData);
DWORD Nv4Lock(PDD_LOCKDATA lpLockData);
DWORD __stdcall DdSetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv3Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv3UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
#ifdef NVD3D
DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd);
#endif
HRESULT Nv3UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
unsigned long Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
DWORD __stdcall Nv3UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
BOOLEAN bCreateNV4DDPatchPio(PDEV *ppdev);
BOOLEAN bDestroyNV4DDPatchPio(PDEV *ppdev);
DWORD Nv3GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv4GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD __stdcall Nv3SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
extern DWORD __stdcall Nv3Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt32( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd );

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modedefs.h ===
//******************************************************************************
//
// Copyright (c) 1998  NVidia Corporation
//
// Module Name:
//
//     modedefs.h
//
// Abstract:
//
// Environment:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1998 NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define NUMBER_OF_MODES 18
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  7
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\multidev.h ===
#ifndef _INCLUDE_MULTIDEV
#define _INCLUDE_MULTIDEV


ULONG	ulQueryNumDevices(PVOID pvDeviceObject);
BOOLEAN bGetDevices(PVOID pvDeviceObject, PVOID *ppvDevObjs);

#endif // _INCLUDE_MULTIDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modes.h ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//
//

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28    /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE     12    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE      4    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */
#endif // DOS_COMPILE


#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016    horiz_total;
    U016    horiz_start;
    U016    horiz_end;
    U016    vertical_total;
    U016    vertical_start;
    U016    vertical_end;
    U008    flags;
    U032    dot_clock;
    U016    refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08


// Standard VGA Mode Table Structure
typedef struct _seq_
{
    U008 ClockMode;
    U008 MapMask;
    U008 FontAddr;
    U008 MemMode;
} SEQ;

typedef struct  _crtc_
{
    U008   HTotal;
    U008   HDispEnd;
    U008   HBlankS;
    U008   HBlankE;
    U008   HSyncS;
    U008   HSyncE;
    U008   VTotal;
    U008   Overflow;
    U008   PresetRowScan;
    U008   CellHeight;
    U008   CursorS;
    U008   CursorE;
    U008   RegenSHigh;
    U008   RegenSLow;
    U008   CursorPosHigh;
    U008   CursorPosLow;
    U008   VSyncS;
    U008   VSyncE;
    U008   VDispE;
    U008   RowOffset;
    U008   ULineRow;
    U008   VBlankS;
    U008   VBlandE;
    U008   Mode;
    U008   LineCompare;
} CRTC;

typedef struct  _gr_
{
    U008   SetReset;
    U008   EnableSetReset;
    U008   ColorCmp;
    U008   ROP;
    U008   ReadMap;
    U008   Mode;
    U008   Misc;
    U008   CDC;
    U008   BitMask;
} GR;

// Standard VGA Mode Table format.
typedef struct _vga_mode_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U016  RegenLenght;
    SEQ     seq_regs;              // SR1-4
    U008   PT_Misc;               // Misc Register
    CRTC    crtc_regs;             // CR0-18
    U008   PT_ATC[20];            // Attribute Controller
    GR      gr_regs;               // GR0-8
} VGATBL;

// Indexes into the clock table
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz

#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E
#define    CLKID_219_566   0x1F
#define    CLKID_172_798   0x20
#define    CLKID_193_156   0x21
#define    CLKID_229_5     0x22
#define    CLKID_136_36    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK

} MODEDESC;


typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210

                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV
                            // 7654 3210

    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select

} EXTREGS;

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)

} TVREGS;

// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16

}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus

} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
U032 ReadPriv32(U032 );
U016 ReadIndexed(U032 , U008 );
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These Win NT specific routines access the NV3 through a series of NV
// engine pointers contained in the global HwDeviceExtension and frame
// buffer pointer, fbAddr.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv3a_ref.h"

#include "modes.h"

PHW_DEVICE_EXTENSION HwDeviceExtension;
PHWREG fbAddr;

//******************************************************************************
// External function declarations
//******************************************************************************

// write a dword value to a fb address
VOID WriteFb32(U032 datum, U032 addr)
{
    MEM_WR32(addr, datum);
}


// read a dword value from a fb address
U032 ReadFb32(U032 addr)
{
    return MEM_RD32(addr);
}


// write a dword value to an NV register
// assume extended CRTC registers are unlocked
#pragma warning(disable: 4296)

VOID WritePriv32(U032 datum, U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR32(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR32(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        PRAMDAC_REG_WR32(PRAMDAC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        PFB_REG_WR32(PFB_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        PMC_REG_WR32(PMC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        PEXTDEV_REG_WR32(PEXTDEV_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        PBUS_REG_WR32(PBUS_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DebugBreakPoint();
}


// read a dword value from an NV register
U032 ReadPriv32(U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        return PRMVIO_REG_RD32(PRMVIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        return PRMCIO_REG_RD32(PRMCIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        return PRAMDAC_REG_RD32(PRAMDAC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        return PFB_REG_RD32(PFB_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        return PMC_REG_RD32(PMC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        return PEXTDEV_REG_RD32(PEXTDEV_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        return PBUS_REG_RD32(PBUS_Base, addr);
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}

#pragma warning(default: 4296)

// write a data word to Priveledged IO
VOID WriteIndexed(U032 addr, U016 datum)
{
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum & 0xFF);
        PRMVIO_REG_WR08(PRMVIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum & 0xFF);
        PRMCIO_REG_WR08(PRMCIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}


// write a data byte to Priveledged IO
VOID WritePriv08(U032 addr, U008 datum)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_USER_DAC) && addr < DEVICE_BASE(NV_USER_DAC) + DEVICE_EXTENT(NV_USER_DAC))
    {
        USERDAC_REG_WR08(USERDAC_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}

// read a data word from Priveledged IO
U016 ReadIndexed(U032 addr, U008 reg)
{
    U016   datum;

    //
    // Return the data in the upper byte, index in the lower
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, reg);
        datum = (PRMVIO_REG_RD08(PRMVIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, reg);
        datum = (PRMCIO_REG_RD08(PRMCIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}


// end of modehw.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modesetNT.c ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifndef NTMINIPORT

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#endif // DOS_COMPILE

#include    "modes.h"
#include    "modedata.c"
#include    "modehw.h"
#include "nvhw.h"

#else

//*****************************************************************************
//
// NV1/NV3/NV4 conventions...
//
//       This modeset code was originally designed to be compiled for each
//       version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//       to work with ALL versions of the chip.  That is, the original modeset
//       code had to be compiled for each chip.  But since this miniport
//       determines which chip it's running on at RUN time (i.e. we don't
//       compile several versions of the miniport) we need to use the following
//       convention:
//
//          THIS MODULE SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//          (OR CODE THAT HAS NOT CHANGED ACROSS CHIPS) !!
//
//       Mainly because NV_REF.H already includes NV3_REF.H.
//       For code which is different from NV3, that code
//       should exist separately in NV4.C/NV5.C/...etc...
//
//       We'll follow the convention that the Miniport decides at runtime
//       which chip it's running on (i.e. only ONE miniport instead of
//       compiling several versions for each type of chip).
//
//*****************************************************************************

//*****************************************************************************
//
// ModeSet Code differences between chips:
//
//       NV3:   - CRTC registers are locked using NV_PRMVIO_SR_LOCK
//                (See OEMEnableExtension/OEMDisableExtension)
//
//              - 565 mode is set with PRAMDAC_GENERAL_CONTROL_565_MODE
//                (See OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV4
//
//              - FixLowWaterMark is different than NV4 version
//
//              - OEMGetMemSize
//
//       NV4:   - CRTC registers are locked using NV_CIO_SR_LOCK_INDEX.
//                (See NV4_OEMEnableExtenions/NV4_OEMDisableExtension)
//
//              - 565 mode is set with NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE
//                (See NV4_OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV3
//
//              - TV functionality has changed
//
//              - FixLowWaterMark is different than NV3 version
//
//              - NV4_OEMGetMemSize
//
//*****************************************************************************


#include <miniport.h>
#include <nv_ref.h>
#include <ntddvdeo.h>
#include <video.h>
#include "nv.h"
#include "modes.h"
#include "modedata.c"
#include "modehw.h"

// Debug level values and output macro
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For debug warning info
#define DEBUGLEVEL_ERRORS       4     // For debug error info
#define DBG_PRINT_STRING_VALUE(l, s, v) VideoDebugPrint(((l), s ## " 0x%x\n", (v)))

#endif // NTMINIPORT

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID ProgramTV( U008 tvmode );
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);

//******************************************************************************
// External variables
//******************************************************************************

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern CRTC_OVERRIDE crt_override[];
extern MODEDESC mib[];            // Our Mode List

//******************************************************************************
// External functions
//******************************************************************************

extern VOID NV_OEMSetRegs(MODEDESC *);
extern VOID NV_FixLowWaterMark(U016);
extern U016 NV_OEMGetMemSize(VOID);
extern VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION);
extern VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION);

U016 VBESetModeEx(PHW_DEVICE_EXTENSION pHwDevExt, U016 vbeMode, PGTF_TIMINGS pVbeTimings, PDMT_OVERRIDES pDMTOverrides, U016 UseDMTFlag)
{
    HwDeviceExtension = pHwDevExt;
    return VBESetMode(vbeMode, pVbeTimings, pDMTOverrides, UseDMTFlag);
}

VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt)
{
    HwDeviceExtension = pHwDevExt;
}



//******************************************************************************
//
// Function: WakeUpCard
//
// Description:
//
//           NV4 or better:
//
//           When RmInitNvDevice() is called during NVInitialize(),
//           it tries to detect if a monitor, flat panel, or TV is connected.
//           It does this when InitDac() calls dacMonitorConnectStatus(). 
//
//           However, dacMonitorConnectStatus() seems to fail on some cards
//           if the card is secondary and the monitor is not 'alive'
//           The end result is that dacMonitorConnectStatus() incorrectly identifies
//           the secondary card. This results in the secondary monitor coming up blank.
//
//           This does NOT happen on Win9x, since by that time, the secondary monitor
//           is already 'alive' and in text mode.  But under WinNT, the secondary
//           monitor has not yet been initialized.
//          
//           Aos, this does NOT happen on all cards (ie...my TNT2 works without this workaround)
//           but DOES happen on my NV4.    
//
//           So, under NT, to make sure that dacMonitorConnectStatus correctly identifies 
//           the monitor and that the 'monitor' is awake, we'll touch just enough registers
//           on the card to make sure it's alive.
//                   
//*****************************************************************************


VOID WakeUpCard(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    MODEDESC    *minfo;             

    //*************************************************************************
    // Mib[1] is the entry for 640x480
    //*************************************************************************

    minfo = &mib[1];

    //*************************************************************************
    // NV3 still uses the OLD style modeset code, and does NOT go thru
    // the RM to set the mode.  Only do this for NV4 or better.
    //*************************************************************************

    if  (HwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
        {
        //**********************************************************************
        // Make sure card is 'active'.  This code doesn't completely set a mode,
        // but it touches enough registers to make sure that dacMonitorConnectStatus()
        // in the RM will succeed, and correctly detect the monitor.
        //**********************************************************************

        SetGlobalHwDev(HwDeviceExtension);
        NV_OEMEnableExtensions(HwDeviceExtension);        
        SetRegs(minfo);             
        }
        
    }



//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//


U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U032        data32;
    U016        data,shadow;    


    NV_OEMEnableExtensions(HwDeviceExtension);          // Unlock the registers

    //**************************************************************************
    // Do this for flat panel only
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */

        // de-couple vertical sync from flat panel while setting mode
        data32 = ReadPriv32(NV_PRAMDAC_FP_DEBUG_0); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        WritePriv32(data32, NV_PRAMDAC_FP_DEBUG_0 );
        }



    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
    
        shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

        data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
        WriteIndexed(NV_PRMCIO_CRX__COLOR, data);


        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
        }    


    if ((minfo = ValidateMode((U016) (mode & 0x1FF))) != (MODEDESC *) NULL)
    {
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.

        // Set the mode
        // SetBIOSVariables(minfo); // Set low memory variables from parms.
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.

        SetRegs(minfo);             // Set the VGA Registers
        FullCpuOn();

        NV_OEMSetRegs(minfo);          // Set the OEM Registers
        LoadPalette(minfo);

        // Not in VESA modes...
        /*
        LoadSysFont(minfo);      // Not in these VESA modes...

        if (!(mode & 0x8000))     // Save the screen?
          OEMClearScreen();       // Clear the buffer

        if (mode & 0x4000)
          VBESetLinearFB();
        */

        // Use DMT override values instead of GTF timings
        if (UseDmtFlag)
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);
            }

        else
            {

            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings)  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }


        FullCpuOff();
        ATCOn();

        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // if (isTV())
        //    fixup_tv();          // Only required on Mode 13h

        rc &= 0x00FF;               // Clear error status
    }
    NV_OEMDisableExtensions(HwDeviceExtension);         // Unlock the registers

    return(rc);                     // Mode Not Supported
}

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    //
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;

    /*
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;

    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((val16 << 8) & 0xFF00));

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));

    /*
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));

    /*
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);

    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));

    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));

    /*
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));

    /*
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;

    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;

    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;

    /*
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {

        /*
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;

        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */

        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        }
        else
        {
            val16 <<= 1;
            val16++;
        }
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));

        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));

    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    //
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    //
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));

    /*
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));

    /*
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}


//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016    DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)

{

    U032 val32;
    U016 val16;
    U016  wv;

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(pDMTOverrides->DotClock));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //

    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    }

#define COMBINE_INDEX_DATA(i, d) ((U016)((((U016)(d)) << 8 & 0xff00) + (i)))
#define EXTRACT_DATA(x) (x) >> 8 & 0x00ff
VOID ProgramTV
(
    U008    tvmode
)
{
    U016    data;

    // 11-07-97 wk. Note that either the commented out tvreg table for CRTC[12] is
    //              wrong or the BIOS CRTC[12] programming code is wrong. The BIOS doesn't
    //              have tvreg tables for TV modes 4 and 5. The C code will use the tvreg
    //              table, so if the bug is in the table then make the correction there.

    WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_ILACE__INDEX, tvregs[tvmode].tvIntlace));        // CRTC[39]

    // Un-write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));

    // Check for NTSC or PAL.
    data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CRE_PIXEL_INDEX));
    if(( data & 0xc0 ) == 0x80 )
    {
        // NTSC
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_NTSC ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_NTSC       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_NTSC      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_NTSC       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_NTSC       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_NTSC      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_NTSC      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_NTSC      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_NTSC      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_NTSC      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_NTSC      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_NTSC      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_NTSC      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_NTSC      ));      // CR[16]
    }
    else
    {
        // PAL
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_PAL ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_PAL       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_PAL      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_PAL       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_PAL       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_PAL      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_PAL      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_PAL      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_PAL      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_PAL      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_PAL      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_PAL      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_PAL      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_PAL      ));      // CR[16]

        // PAL Fix up.

        // 11-07-97 wk. mighty suspect bios code (or documentation)!
        //
        // mov     al,1                    ; Look at value in CR01
        // SIM_GET_INDEX_REGISTER_NV       ; Read CR01
        // cmp     ah,4Fh                  ; Is it > 4Fh? (800 s/b 63h)
        //
        // jbe     @low_pal                ; it's a 640x480 or less mode... jump!

        //CRTC_RD( NV_CIO_CR_HDE_INDEX, data );      // CRTC[01]
        data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_HDE_INDEX));
        if( data > 0x4f )
        {
            // PAL timings for modes 800x600 or more.

            // set VPLL to SOURCE
            WritePriv32(0x00010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00035A09, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsHi
            WritePriv32(0x0000004F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x0000005F, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x000003FF, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000438, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x00000027, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x000001CA, NV_PRAMDAC_HSERR_WIDTH      );
        }
        else
        {
            // PAL timings for modes less then 800x600.

            // set VPLL to SOURCE
            WritePriv32(0x02010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00034709, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsLo
            WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH      );
        }
    }

    // write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));
}



//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!

    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);

    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;

    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;

    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }
}

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
// These tables are defined in Resman code in DACMODE.C
//
extern U008 CompatColors[];

//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];

//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];

//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];

VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);

    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }

    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //

    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {

        // I know these could probably be a function, but for now...
        // (this is getting tedious).

        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red++;
        } while (red < blue);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue--;
        } while (blue);

        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green++;
        } while (green < red);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red--;
        } while (red);


        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue++;
        } while (blue < green);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green--;
        } while (green);
    }

    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write

    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component

        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;

        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}

//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    for (i = 0; i < 256; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;

    //clock = tblClockFreq[csel];         // Get selected clock value
    NV_FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency

    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM

//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}



//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;

    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;

    vclk = (U032)(*clock * 10);     // Make KHz

    deltaOld = 0xFFFF;

    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;

    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 8;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 7;
        bx = 13;
    }

    lowM = cx;
    highM = bx;
    crystalFreq = dx;

    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n

    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {
        // M Loop
        for (m = lowM; m <= highM; m++)
        {
            lwv = vclk << powerP;   // vclk * P

            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 256000))
            {
                lwv *= (U032)m;    // vclk * P * M

                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);

                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);

                lwv *= crystalFreq; // N * crystal

                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2

                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P

                i = m;
                j = m;

                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M


//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//
//                   mov     edx, eax        ; Save a copy

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta

                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);

                if (lwvs < vclks)
                {
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }

                lwvs -= vclks;      // ABS(Freq-Vclk);

                // lwvs is ax
                // vclks is bx

                if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;

                    bestP = powerP;
                    bestM = m;
                    bestN = n;

                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al

                    edx /= 10;

                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }

  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));


    // mov     bx, vclkClosest
    *clock = vclkClosest;

    return(lwv);
}

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset

    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);

    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));

    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset

    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7

    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));

    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;

    // Program SR1-4
    for (i = 0; i < count; i++)
    {
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }
}

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{
    U016  rc;

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;

    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);
            break;      // Out of the for - report error
        }
    }
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;

    // Are we running tv mode? If so, we need an additional filter

    // For now, NV5 or better only supports Flat Panel
    // We don't support TV yet 

    if  ( (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID) &&
          (isTV()) )       

    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }

    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks

    // memory now has the 64K blocks necessary for this mode.

    if (((U016)memory) > NV_OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// Returns 1 if the TV is active
//
U008 isTV(VOID)
{
    U016   rc;

    // WARNING: This code was ONLY valid on NV3.
    //          It's no longer adequate for NV5 or better !!

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}





/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{
    U008   rc;

    U016  wval;
    U032   dval;

/*
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38

    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;

    // Output the MSW of the address
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));

    // and the LSW of the address
    outpw(0x3D0, (U016)(dval & 0xFFFF));

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable

    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data

    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));

    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/

}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));

    outpw(0x3D0, as->data_low);     // LSW of address

    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //

    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);

    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);

    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);

    //
    // Program memory timings based on framebuffer size
    //
    //

    //
    // Determine how wide/deep is the framebuffer
    //
    /*
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.

           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */

    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width

    //
    // Poke the framebuffer based on bus width
    //
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8

        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

    } else {

        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg

        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);

    }

    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);

    //
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    }

    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);

    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000));

    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000));

    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300));

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200));

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH);
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {

        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }

}

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//
#ifdef DOS_COMPILE
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code

    printf("NVIDIA MODESET V1.00\n\n");

    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }

    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }

    printf("Setting Mode 0x%02X\n", mode);
    getchar();

    rc = VBESetMode(mode);

    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }

    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value

    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);

    while (i--)
    {
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }
        sus *= 16;                  // Shift by 4
        sus += val;
        str++;
    }
    return(sus);
}
#endif // DOS_COMPILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\monitor.h ===
//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation
// 
// Module Name:
// 
//     monitor.h
// 
// Environment:
// 
// Revision History:
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

#define NV_MONITOR_VGA  0
#define NV_MONITOR_NTSC 2
#define NV_MONITOR_PAL  3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\ntnvreg.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

//******************************************************************************
// Type of REGISTRY entry
//******************************************************************************

#define IS_BINARY       0
#define IS_STRING       1
#define IS_DWORD        2

//******************************************************************************
// REGISTRY data length max values
//******************************************************************************

#define REG_STRING_DATA_MAX 30

//******************************************************************************
// Maximum number of NV registry switches
//******************************************************************************

#define MAX_NV_REGISTRY_SWITCHES   100

//******************************************************************************
// Dword value used to IGNORE the presence of the registry switch
//******************************************************************************

#define IGNORE_REGISTRY_SWITCH     0x99999999

//******************************************************************************
// NT Registry Switches:
// ====================
//
// The implementation of NT registry keys are different than Win9x,
// since NT is more restricted when it comes to setting values in its registry.
// Essentially, for NT, we only use a 'flat' registry structure, as opposed to 
// several different keys (directory structure) in Win9x.
//  
// For Win9x, the registy keys and values are stored under 
//          \HKEY_LOCAL_MACHINE\SOFTWARE\NVIDIA Corporation\Riva TNT\
// 
// For WinNT, the registry values are all stored under 
//          \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nv\DeviceXX
//
// Even though the implementation is different on NT, we'll attempt to keep the
// registry functionality as close to Win9x as possible.
//
//
// NOTE: Since OPENGL is NOT part of the NT display driver (it'a separate DLL),
//       it can read the registry by itself, and does NOT have its registry
//       switches in the same location as all the switches.
//       It's switches are still located in .\Software\NVIDIA Corporation\Riva TNT\
//
//
//      Please Refer to NVREG.H in the \drivers\common\inc directory to
//              see how this structure was obtained
//
//******************************************************************************

typedef struct _NT_NV_REGISTRY_SWITCH_OFFSET
    {
    U032    RegType;
    U008    RegName[REG_STRING_DATA_MAX];
    U032    Offset;
    } NT_NV_REGISTRY_SWITCH_OFFSET;


typedef struct _NT_NV_REGISTRY_DISPLAY
    {
    U008    LastDisplayDevice[REG_STRING_DATA_MAX];     // String
    U008    LastCRTMode[REG_STRING_DATA_MAX];           // String
    U008    LastDFPMode[REG_STRING_DATA_MAX];           // String
    U008    LastNTSCMode[REG_STRING_DATA_MAX];          // String
    U008    LastPALMode[REG_STRING_DATA_MAX];           // String
    U008    CRTMode[REG_STRING_DATA_MAX];               // String
    U008    DFPMode[REG_STRING_DATA_MAX];               // String
    U008    NTSCMode[REG_STRING_DATA_MAX];              // String
    U008    PALMode[REG_STRING_DATA_MAX];               // String
    U008    DefaultCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DefaultDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DisplayDeviceType[REG_STRING_DATA_MAX];     // String
    U008    MonitorTiming[REG_STRING_DATA_MAX];         // String
    U032    DisplayType;                                // Dword
    U032    TVType;                                     // Dword
    U032    CursorAlpha;                                // Dword
    } NT_NV_REGISTRY_DISPLAY;

typedef struct _NT_NV_REGISTRY_DIRECTDRAW
    {
    U032    VPENABLE;                                   // Dword
    U032    OverlayMode;                                // Dword
    U032    OverlayColorControlEnable;                  // Dword
    U032    OverlayBrightness;                          // Dword
    U032    OverlayContrast;                            // Dword
    U032    OverlayHue;                                 // Dword
    U032    OverlaySaturation;                          // Dword
    U032    OverlayGamma;                               // Dword
    U032    OverlaySharpness;                           // Dword
    } NT_NV_REGISTRY_DIRECTDRAW;


typedef struct _NT_NV_REGISTRY_DIRECT3D
    {
    U032    ANTIALIASENABLE;                            // Dword
    U032    COLORKEYCOMPATABILITYENABLE;                // Dword
    U032    CONTROLTRAFFIC;                             // Dword
    U032    DIRECTMAPENABLE;                            // Dword
    U032    FOGTABLENABLE;                              // Dword
    U032    LOGOENABLE;                                 // Dword
    U032    SCENESYNCENABLE;                            // Dword
    U032    TILINGENABLE;                               // Dword
    U032    USERMIPMAPENABLE;                           // Dword
    U032    VIDEOTEXTUREENABLEENABLE;                   // Dword
    U032    VSYNCENABLE;                                // Dword
    U032    WENABLE;                                    // Dword
    U032    Z24ENABLE;                                  // Dword        
    U032    AAMETHOD;                                   // Dword
    U032    AUTOMIPMAPMETHOD;                           // Dword
    U032    CKREF;                                      // Dword
    U032    DX6ENABLE;                                  // Dword
    U032    ANISOTOPIC4TAP;                             // Dword
    U032    PAL8TEXTURECONVERT;                         // Dword
    U032    PMTRIGGER;                                  // Dword
    U032    TEXELALIGNMENT;                             // Dword
    U032    VALIDATEZMETHOD;                            // Dword
    U032    W16FORMAT;                                  // Dword
    U032    W32FORMAT;                                  // Dword
    U032    AGPTEXCUTOFF;                               // Dword       
    U032    D3DCONTEXTMAX;                              // Dword
    U032    D3DTEXTUREMAX;                              // Dword
    U032    DMAMINPUSHCOUNT;                            // Dword
    U032    LODBIASADJUST;                              // Dword     
    U032    MINVIDEOTEXSIZE;                            // Dword
    U032    MIPMAPLEVELS;                               // Dword       
    U032    PERFSTRATEGY;                               // Dword
    U032    NOVSYNCPREREDNERLIMIT;                      // Dword
    U032    DMAPUSHBUFFERSIZEMAX;                       // Dword
    U032    TEXHEAP;                                    // Dword
    U032    WSCALE16;                                   // Dword
    U032    WSCALE24;                                   // Dword
    
    
    } NT_NV_REGISTRY_DIRECT3D;


typedef struct _NT_NV_REGISTRY_SYSTEM
    {
    U032    Super7Compat;                               // Dword  
    U032    FlipOnHSync;                                // Dword                     
    U032    FilterOverride;                             // Dword                  
    U032    NoNT4AGP;                                   // Dword
    U032    George;                                     // Dword
    U032    Gracie;                                     // Dword
    U032    TVOutOnPrimary;                             // Dword
    U032    Enable256Burst;                             // Dword
    U032    DisableMPCDetect;                           // Dword
    U032    MemoryOverride;                             // Dword
    U032    RTLOverride;                                // Dword
    } NT_NV_REGISTRY_SYSTEM;


typedef struct _NT_NV_REGISTRY_NVTWEAK
    {
    U032    test;                                       // Dword
    } NT_NV_REGISTRY_NVTWEAK;
                     



    //**************************************************************************
    // Complete Registry Structure
    //**************************************************************************


typedef struct _NT_NV_REGISTRY
    {
    //**************************************************************************
    // DISPLAY Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DISPLAY Display;
            
    //**************************************************************************
    // DIRECTDRAW Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECTDRAW DirectDraw;

    //**************************************************************************
    // DIRECT3D Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECT3D Direct3D;

    //**************************************************************************
    // RESMAN Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_SYSTEM System;

    //**************************************************************************
    // NVTWEAK Control Panel Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_NVTWEAK NVTweak;


    } NT_NV_REGISTRY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//
//
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\multidev.c ===
// this module is compiled in DDK environment cause we need to deal with ddk.h only structs to walk 
// thru the list of devices!!!
// for this all routines have standard windows parameters like pvoid, ulong etc.

#include <ntddk.h>
#include <windef.h>
#undef WIN32
#include <nvos.h>
#include <nvntioctl.h>


// 
// ulQueryNumDevices walks thru the linked list of device objects and counts all devices which belong to one driver
// NOTE : a DeviceObject is the same than a hDriver in the Display driver
//
ULONG ulQueryNumDevices(PVOID pvDeviceObject)
{
	ULONG			ulNumDevices = 1;  // default is one device
	DEVICE_OBJECT   *pDevObj;
	DEVICE_OBJECT   *pRootDevObj;
	DRIVER_OBJECT   *pDrvObj;

	pDevObj =(DEVICE_OBJECT *)pvDeviceObject;
	if (pDevObj)
	{
		pDrvObj = pDevObj->DriverObject;
		if (pDrvObj)
		{
			pRootDevObj = pDrvObj->DeviceObject;
			pDevObj = pRootDevObj;
			while (pDevObj && pDevObj->NextDevice)
			{
				pDevObj = pDevObj->NextDevice;
				ulNumDevices++;
			}
		}
	}
	return ulNumDevices;
}

//
// bGetDevices walks thru the list of device objects and exports them thru ppvDevObjs
//
BOOLEAN bGetDevices(PVOID pvDeviceObject, PVOID *ppvDevObjs)
{
	BOOLEAN			bRet = FALSE;
	int				i = 0;
	DEVICE_OBJECT *pDevObj;
	DEVICE_OBJECT *pRootDevObj;
	DRIVER_OBJECT *pDrvObj;

	pDevObj =(DEVICE_OBJECT *)pvDeviceObject;
	if (pDevObj)
	{
		pDrvObj = pDevObj->DriverObject;
		if (pDrvObj)
		{
			bRet = TRUE;

			pRootDevObj = pDrvObj->DeviceObject;
			pDevObj = pRootDevObj;

			ppvDevObjs[i++] = (PVOID)pDevObj;

			while (pDevObj && pDevObj->NextDevice)
			{
				pDevObj = pDevObj->NextDevice;
				ppvDevObjs[i++] = (PVOID)pDevObj;
			}
		}
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1_32.h ===
#ifndef NV32_INCLUDED
#define NV32_INCLUDED
/***************************************************************************

  Copyright (C) 1995 NVidia Corporation.

  <nv32.h> defines a 32-bit wide naming convention for the functionality
  of NVidia's Unified Media Architecture (TM).

  Other header files:
     <nvwin32.h>  Contains the function prototypes for the few client
                  functions implemented by the Windows Resource Manager.
     <nvmacros.h> Defines macros that assemble 32-bit quantities for
                  assigning to the hardware from 16-bit coordinates,
                  24-bit RGB triples, etc.  Use of this is optional.
     <nvutypes.h> Declares structures that expose elements smaller than
                  32 bits wide ("NVidia unpacked types").  Use of this
                  is optional.
    Copyright 1995,1996 NVidia Corporation. All Rights Reserved.

 ***************************************************************************/

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** Miscellaneous Sizes *****/
#define NV_GUARANTEED_FIFO_SIZE    0x007C
#define NV_NVIDIA_NAME_LIMIT       0x00000FFF

/***** Notification Styles *****/
/* This simply fills the NvNotification structure */
#define NV_NOTIFY_WONT_SLEEP       0x00000000
/* Other notification styles are operating-system dependent */

/***** Notification Reports *****/
#define NV_BUFFER_GAP              0x00000001

/***** Well-known Objects (besides classes) *****/
#define NV_NULL_OBJECT             0
#define NV_THE_CHIP_ID             0x0FFE
#define NV_ERROR_NOTIFIER          0x0FFD

/***** Errors *****/
#define NV_ERROR_TYPE_CONFLICT           1
#define NV_ERROR_OUT_OF_RANGE            2
#define NV_ERROR_NO_CONNECTION           3
#define NV_ERROR_NO_SUCH_OBJECT          4
#define NV_ERROR_NAME_IN_USE             5
#define NV_ERROR_OUT_OF_RESOURCES        6
#define NV_ERROR_TRANSLATION_VIOLATION   7
#define NV_ERROR_PROTECTION_VIOLATION    8
#define NV_ERROR_BUFFER_BUSY             9
#define NV_ERROR_ILLEGAL_ACCESS          10
#define NV_ERROR_BAD_COLORMAP_FORMAT     11
#define NV_ERROR_BAD_COLOR_FORMAT        12
#define NV_ERROR_BAD_MONOCHROME_FORMAT   13
#define NV_ERROR_BAD_PATTERN_SHAPE       14
#define NV_ERROR_BAD_SUBDIVIDE           15
#define NV_ERROR_NO_CURRENT_POINT        16
#define NV_ERROR_BAD_AUDIO_FORMAT        17
#define NV_ERROR_NO_DMA_TRANSLATION      18
#define NV_ERROR_INCOMPLETE_METHOD       19
#define NV_ERROR_RESERVED_ADDRESS        20
#define NV_ERROR_UNIMPLEMENTED_PATCH     21
#define NV_ERROR_OS_NAME_ERROR           22
#define NV_ERROR_INCOMPLETE_PATCH        23
#define NV_ERROR_BAD_GAME_PORT_FORMAT    24

/***** SetMonochromeFormat values *****/
#define NV_MONO_LE_M1_P32          0x00000000
#define NV_MONO_CGA6_M1_P32        0x00000001

/***** SetColorFormat values ******/
/*
 The format names precisely specify how the bits are arranged
 in a 32-bit write of a color or colors in that format in a
 little-endian system.  For example NV_COLOR_FORMAT_LE_X17R5G5B5
 means the upper 17 bits are ignored, then 5 bits each of
 Red, Green, and Blue intensity:

   3                             1 1
   1                             6 5                             0
  |X X X X X X X X X X X X X X X X X R R R R R G G G G G B B B B B|

 */
/* Unpacked color formats */
#define NV_COLOR_FORMAT_LE_X17R5G5B5       0x00000000
#define NV_COLOR_FORMAT_LE_X16A1R5G5B5     0x00100000
#define NV_COLOR_FORMAT_LE_X24Y8           0x00010000
/* Packed color formats -- more than one value per 32-bit write */
#define NV_COLOR_FORMAT_LE_X1R5G5B5_P2     0x01000000
#define NV_COLOR_FORMAT_LE_A1R5G5B5_P2     0x01100000
#define NV_COLOR_FORMAT_LE_Y8_P4           0x01010000
/* No difference between packed and unpacked */
#define NV_COLOR_FORMAT_LE_X8R8G8B8        0x00000001
#define NV_COLOR_FORMAT_LE_A8R8G8B8        0x00100001
#define NV_COLOR_FORMAT_LE_X2R10G10B10     0x00000002
#define NV_COLOR_FORMAT_LE_A2R10G10B10     0x00100002
#define NV_COLOR_FORMAT_LE_X16A8Y8         0x00110000
#define NV_COLOR_FORMAT_LE_X16Y16          0x00010001
#define NV_COLOR_FORMAT_LE_A16Y16          0x00110001


/***************************************************************************
 *                          Typedefs                                       *
 ***************************************************************************/

/* The initial typedefs declare the C type information for
 * the NV structures later in the file.
 */

/***** The fundamental types *****/
#undef U008
#undef V008
#undef U016
#undef V016
#undef S032
#undef U032
#undef V032

typedef unsigned char    U008;
typedef unsigned char    V008;
typedef unsigned short   U016;
typedef unsigned short   V016; /* "void": more than one value or sign N/A */
typedef long             S032;
typedef unsigned long    U032;
typedef unsigned long    V032; /* "void": more than one value or sign N/A */

/*
 * NV objects return information to applications via notification
 * structures in main memory.
 */
typedef volatile struct {
 struct
  tagNvTimeStamp {
  U032 nanoseconds[2];           /* Nanoseconds since Jan. 1, 1970 */
 } timeStamp;                  /*                                 0000-0007*/
 V032 otherInfo;               /* info reported depends on method 0008-000b*/
 V016 errorCode;               /* Zero means no error             000c-000d*/
 V008 reserved01[0x001];
 V008 inProgress;              /* Application sets, NV zeroes     000f-000f*/
} NvNotification;

/*
 *  The first 256 bytes of each subchannel.
 */
typedef volatile struct {
 V032 object;                  /* current object register         0000-0003*/
 V032 reserved01[0x003];
 U016 free;                    /* free count, only readable reg.  0010-0011*/
 U016 reserved02[0x001];
 U032 reserved03[0x003];
 struct
  tagNvPassword {
  V032 token[4];               /* Any value written here must "unlock" the */
 } password;                   /* chip, matching its ChipToken.   0020-002f*/
 V032 push;                    /* Any write saves channel state   0030-0033*/
 V032 pop;                     /* Any write restores channel state0034-0037*/
 V032 reserved04[0x032];
} NvControl;

/***************************************************************************
 *                           Classes                                       *
 ***************************************************************************/

/*
 * These structures indicate the precise offsets of hardware
 * registers corresponding to the methods of each class.  Since the
 * first 256 bytes of each subchannel is the NvControl registers,
 * the hexadecimal offsets in comments start at 0x100.
 */

/* General and Utility Classes */

/* class NV_CLASS */
#define NV_CLASS  1
typedef volatile struct tagNvClass {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Create;                  /* 32-bit name of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit name of object           0304-0307*/
 V032 SetNameCtxDma;           /* NV_CONTEXT_DMA_FROM_MEMORY      0308-030b*/
 U032 SetNameStart;            /* offset within ctxdma in bytes   030c-030f*/
 U032 SetNameLength;           /* ASCII O/S name length in bytes  0310-0313*/
 V032 SetEnumerateCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY        0314-0317*/
 U032 SetEnumerateStart;       /* offset within ctxdma in bytes   0318-031b*/
 U032 SetEnumerateLength;      /* in bytes                        031c-031f*/
 U032 Enumerate;               /* index into instance list        0320-0323*/
 V032 reserved02[0x737];
} NvClass;

/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define NV_CONTEXT_DMA_FROM_MEMORY  2
typedef volatile struct
 tagNvContextDmaFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetDmaFromSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1 */
 } SetDmaSpecifier;            /* memory region NV will read      0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaFromMemory;

/* class NV_CONTEXT_DMA_TO_MEMORY */
#define NV_CONTEXT_DMA_TO_MEMORY  3
typedef volatile struct
 tagNvContextDmaToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetDmaToSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1   */
 } SetDmaSpecifier;            /* memory region NV will write     0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaToMemory;

/* class NV_TIMER */
#define NV_TIMER  4
typedef volatile struct
 tagNvTimer {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetAlarmTime {
  U032 nanoseconds[2];
 } SetAlarmTime;               /* nanoseconds since Jan. 1, 1970  0300-0307*/
 V032 SetAlarmNotifyCtxDma;    /* NV_CONTEXT_DMA_TO_MEMORY        0308-030b*/
 V032 SetAlarmNotify;          /* notification style, varies w/OS 030c-030f*/
 V032 reserved02[0x73c];
} NvTimer;

/* class NV_CHIP_ID */
#define NV_CHIP_ID  5
typedef volatile struct
 tagNvChipId {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 SetChipTokenCtxDma;      /* DMA to memory for 64-bit token  0300-0303*/
 V032 reserved02[0x001];
 V032 GetChipToken;            /* any write triggers transfer     0308-030b*/
 V032 reserved03[0x73d];
} NvChipId;

/* class NV_CONTEXT_ORDINAL */
#define NV_CONTEXT_ORDINAL  6
typedef volatile struct
 tagNvContextOrdinal {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 U032 SetOrdinal;              /* zero or positive number         0300-0303*/
 V032 reserved02[0x73f];
} NvContextOrdinal;

/* class NV_NULL_CLASS */
#define NV_NULL_CLASS  48
typedef volatile struct
 tagNvNullClass {
 V032 reserved01[0x7c0];       /* has no methods */
} NvNullClass;

/***** Game Port Classes *****/

/* class NV_PATCHCORD_GAME_PORT */
#define NV_PATCHCORD_GAME_PORT  7
typedef volatile struct
 tagNvPatchcordGamePort {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordGamePort;

/* class NV_GAME_PORT_SOURCE */
#define NV_GAME_PORT_SOURCE  8
typedef volatile struct
 tagNvGamePortSource {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetGamePortOutput;       /* NV_PATCHCORD_GAME_PORT          0200-0203*/
 V032 reserved02[0x77f];
} NvGamePortSource;

/* class NV_GAME_PORT_TO_MEMORY */
#define NV_GAME_PORT_TO_MEMORY  9
typedef volatile struct
 tagNvGamePortToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetGamePortInput[56];    /* NV_GAME_PORT_PATCHCORD per chan 0200-02df*/
 V032 reserved02[0x008];
 struct
  tagNvSetStartTime {
  U032 nanoseconds[2];           /* nanoseconds since Jan. 1, 1970 */
 } SetStartTime;               /* 0 means immediate transfer      0300-0307*/
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetGamePortFormat;       /* only valid is _LE_U016_LINEAR   030c-030f*/
 U032 SetNumberChannels;       /* 1 to 8 for NV game port on PC   0310-0313*/
 V032 reserved03[0x03b];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved04[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved05[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved06[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved07[0x006];
 V032 SetBufferNotify[2];      /* indicates buff is ready to fill 0480-0487*/
 V032 reserved08[0x6de];
} NvGamePortToMemory;
/* values for SetGamePortFormat() */
#define NV_GAME_PORT_FORMAT_LE_U016_LINEAR 0x00000004

/***** Video Classes *****/

/* class NV_PATCHCORD_VIDEO */
#define NV_PATCHCORD_VIDEO  10
typedef volatile struct
 tagNvPatchcordVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordVideo;

/* class NV_VIDEO_SINK */
#define NV_VIDEO_SINK  11
typedef volatile struct
 tagNvVideoSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoInput[56];       /* NV_PATCHCORD_VIDEO              0200-02df*/
// V032 SetVideoInputNotifyCtxDma;/*
 V032 reserved02[0x748];
} NvVideoSink;

/* class NV_VIDEO_SWITCH */
#define NV_VIDEO_SWITCH  12
typedef volatile struct
 tagNvVideoSwitch {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput[56];       /* P_V's from I2V's or COLORMAPs   0204-02e3*/
 V032 reserved02[0x007];
 V032 SetCtxOrdinal;           /* NV_CONTEXT_ORDINAL              0300-0303*/
 V032 SetSwitchNotifyCtxDma[56];/* NvNotification for each switch 0304-03e3*/
 V032 reserved03[0x008];
 V032 SetSwitchNotify[56];      /* notifies when it switches away 0404-04e3*/
 V032 reserved04[0x6c7];
} NvVideoSwitch;

/* class NV_VIDEO_COLORMAP */
#define NV_VIDEO_COLORMAP  13
typedef volatile struct
 tagNvVideoColormap {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY      0300-0303*/
 V032 SetColormapFormat;       /*                                 0304-0307*/
 U032 SetColormapStart;        /* offset in ctxdma in bytes       0308-030b*/
 U032 SetColormapLength;       /* in bytes                        030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update       0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, triggers asynch. xfer 0314-0317*/
 V032 reserved03[0x73a];
} NvVideoColormap;
/* values for NV_VIDEO_COLORMAP SetColormapFormat() */
#define NV_COLORMAP_X8R8G8B8       0x00000000
#define NV_COLORMAP_X2R10G10B10    0x00000001


/***** Image Classes *****/

/* class NV_PATCHCORD_IMAGE */
#define NV_PATCHCORD_IMAGE  14
typedef volatile struct
 tagNvPatchcordImage {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* validate connections downstream 0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordImage;

/* class NV_IMAGE_TO_VIDEO */
#define NV_IMAGE_TO_VIDEO  15
typedef volatile struct
 tagNvImageToVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE to ROP/blend 0200-0203*/
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 SetImageInput[56];       /* NV_PATCHCORD_IMAGEs             0208-02e7*/
 V032 reserved02[0x746];
} NvImageToVideo;

/* class NV_IMAGE_STENCIL */
#define NV_IMAGE_STENCIL  16
typedef volatile struct
 tagNvImageStencil {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 is ImageBlackRectangle   0204-020b*/
 V032 reserved02[0x77d];
} NvImageStencil;

/* class NV_PATCHCORD_BETA */
#define NV_PATCHCORD_BETA  49
typedef volatile struct
 tagNvPatchcordBeta {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordBeta;

/* class NV_IMAGE_BLEND_AND */
#define NV_IMAGE_BLEND_AND  17
typedef volatile struct
 tagNvImageBlendAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaInput;            /* NV_PATCHCORD_BETA of Solid/QTMB 0204-0207*/
 V032 SetImageInput[2];        /* P_I, 1 is pattern or I2V        0208-020f*/
 V032 reserved02[0x77c];
} NvImageBlendAnd;

/* class NV_BETA_SOLID */
#define NV_BETA_SOLID  18
typedef volatile struct
 tagNvBetaSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetBetaOutput;           /* NV_PATCHCORD_BETA               0200-0203*/
 V032 reserved02[0x03f];
 V032 SetBeta1d31;             /* S1.31 beta value                0300-0303*/
 V032 reserved03[0x73f];
} NvBetaSolid;

/* class NV_BETA_MAXIMUM */
#define NV_BETA_MAXIMUM  50
typedef volatile struct
 tagNvBetaMaximum {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetBetaOutput;           /* NV_PATCHCORD_BETA to blender    0200-0203*/
 V032 SetBetaInput[2];         /* NV_PATCHCORD_BETA, 1 from solid 0204-020b*/
 V032 reserved02[0x77d];
} NvBetaMaximum;

/* class NV_PATCHCORD_ROP */
#define NV_PATCHCORD_ROP  51
typedef volatile struct
 tagNvPatchcordRop {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordRop;

/* class NV_IMAGE_ROP_AND */
#define NV_IMAGE_ROP_AND  19
typedef volatile struct
 tagNvImageRopAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetRopInput;             /* NV_PATCHCORD_ROP                0204-0207*/
 V032 SetImageInput[3];        /* 0 is I2V ImageOut, 2 is pattern 0208-0213*/
 V032 reserved02[0x77b];
} NvImageRopAnd;

/* class NV_ROP_SOLID */
#define NV_ROP_SOLID  20
typedef volatile struct
 tagRopSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetRopOutput;            /* NV_PATCHCORD_ROP                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetRop;                  /* 8-bit index to std. MS Win ROPs 0300-0303*/
 V032 reserved03[0x73f];
} NvRopSolid;

/* class NV_IMAGE_COLOR_KEY */
#define NV_IMAGE_COLOR_KEY  21
typedef volatile struct
 tagNvImageColorKey {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 from ImageSolidColor     0204-020b*/
 V032 reserved02[0x77d];
} NvImageColorKey;

/* class NV_IMAGE_PLANE_SWITCH */
#define NV_IMAGE_PLANE_SWITCH  22
typedef volatile struct
 tagNvImagePlaneSwitch {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[3];        /* PI, 1 from NV_IMAGE_SOLID ??    0204-020f*/
 V032 reserved02[0x77c];
} NvImagePlaneSwitch;

/***** Static Image Classes *****/

/* class NV_IMAGE_SOLID */
#define NV_IMAGE_SOLID  23
typedef volatile struct
 tagNvImageSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetColor;                /* color to fill the image         0304-0307*/
 V032 reserved03[0x73e];
} NvImageSolid;

/* class NV_IMAGE_PATTERN */
#define NV_IMAGE_PATTERN  24
typedef volatile struct
 tagNvImagePattern {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetMonochromeFormat;     /* NV_MONO_{LE_M1_P32, CGA6_M1_P32}0304-0307*/
 V032 SetPatternShape;         /* NV_PATTERN_SHAPE_{8X8,64X1,1X64}0308-030b*/
 V032 reserved03[0x001];
 V032 SetColor0;               /* "background" color where pat=0  0310-0313*/
 V032 SetColor1;               /* "foreground" color where pat=1  0314-0317*/
 struct
  tagNvSetPattern {
  V032 monochrome[2];
 } SetPattern;                 /* 64 bits of pattern data         0318-031f*/
 V032 reserved04[0x738];
} NvImagePattern;
/* values for NV_IMAGE_PATTERN SetPatternShape() */
#define NV_PATTERN_SHAPE_8X8   0x00000000
#define NV_PATTERN_SHAPE_64X1  0x00000001
#define NV_PATTERN_SHAPE_1X64  0x00000002

/* class NV_IMAGE_BLACK_RECTANGLE */
#define NV_IMAGE_BLACK_RECTANGLE  25
typedef volatile struct
 tagNvImageBlackRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* P_I usually to NV_IMAGE_STENCIL 0200-0203*/
 V032 reserved02[0x03f];
 struct
  tagNvSetRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-04*/
  V032 height_width;             /* U16_U16 in pixels                05-07*/
 } SetRectangle;               /* region in image where alpha=1   0300-0307*/
 V032 reserved03[0x73e];
} NvImageBlackRectangle;

/***** Solid Rendering Classes *****/

/* class NV_RENDER_SOLID_POINT */
#define NV_RENDER_SOLID_POINT  26
typedef volatile struct
 tagNvRenderSolidPoint {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 V032 Point[32];               /* y_x S16_S16 in pixels           0400-047f*/
 struct
  tagNvPoint32 {
  S032 x;                        /* in pixels, 0 at left             00-03*/
  S032 y;                        /* in pixels, 0 at top              04-07*/
 } Point32[16];                /*                                 0480-04ff*/
 struct
  tagNvColorPoint {
  V032 color;                    /*                                  00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPoint[16];             /*                                 0500-057f*/
 V032 reserved04[0x6a0];
} NvRenderSolidPoint;

/* class NV_RENDER_SOLID_LINE */
#define NV_RENDER_SOLID_LINE  27
typedef volatile struct
 tagNvRenderSolidLine {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvLine {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Line[16];                   /*                                 0400-047f*/
 struct
  tagNvLine32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Line32[8];                  /*                                 0480-04ff*/
 V032 PolyLine[32];            /*                                 0500-057f*/
 struct
  tagNvPolyLine32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLine32[16];             /*                                 0580-05ff*/
 struct
  tagNvColorPolyLine {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLine[16];          /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLine;

/* class NV_RENDER_SOLID_LIN */
#define NV_RENDER_SOLID_LIN  28
typedef volatile struct
 tagNvRenderSolidLin {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvLin {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Lin[16];                    /*                                 0400-047f*/
 struct
  tagNvLin32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Lin32[8];                   /*                                 0480-04ff*/
 V032 PolyLin[32];             /*                                 0500-057f*/
 struct
  tagNvPolyLin32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLin32[16];              /*                                 0580-05ff*/
 struct
  tagNvColorPolyLin {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLin[16];           /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLin;

/* class NV_RENDER_SOLID_TRIANGLE */
#define NV_RENDER_SOLID_TRIANGLE  29
typedef volatile struct
 tagNvRenderSolidTriangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvTriangle {
  V032 y0_x0;                  /* S16_S16 in pixels, 0 = top left 0310-0313*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 = top left 0314-0317*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 = top left 0318-031b*/
 } Triangle;
 V032 reserved04[0x001];
 struct
  tagNvTriangle32 {
  S032 x0;                     /*                                 0320-0323*/
  S032 y0;                     /*                                 0324-0327*/
  S032 x1;                     /*                                 0328-032b*/
  S032 y1;                     /*                                 032c-032f*/
  S032 x2;                     /*                                 0330-0333*/
  S032 y2;                     /*                                 0334-0337*/
 } Triangle32;
 V032 reserved05[0x032];
 V032 Trimesh[32];             /*                                 0400-047f*/
 struct
  tagNvTrimesh32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } Trimesh32[16];              /*                                 0480-04ff*/
 struct
  tagNvColorTriangle {
  V032 color;                    /*                                  00-03*/
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 04-07*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 08-0b*/
  V032 y2_x2;                    /* S16_S16 in pixels, 0 at top left 0c-0f*/
 } ColorTriangle[8];           /* Specify color and coordinates  0500-057f*/
 struct
  tagNvColorTrimesh {
  V032 color;                    /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorTrimesh[16];           /* Specify color and next coordinate 0580-05ff*/
 V032 reserved06[0x680];
} NvRenderSolidTriangle;

/* class NV_RENDER_SOLID_RECTANGLE */
#define NV_RENDER_SOLID_RECTANGLE  30
typedef volatile struct
 tagNvRenderSolidRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } Rectangle[16];              /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvRenderSolidRectangle;

/***** Image Rendering Classes *****/

/* class NV_IMAGE_BLIT */
#define NV_IMAGE_BLIT  31
typedef volatile struct
 tagNvImageBlit {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0204-0207*/
 V032 reserved02[0x03e];
 V032 ControlPointIn;          /* S16_S16 in pixels, u.r. of src  300-0303*/
 V032 ControlPointOut;         /* S16_16 in pixels, u.r. of dest  0304-0307*/
 V032 Size;                    /* U16_U16 in pixels               0308-030b*/
 V032 reserved03[0x73d];
} NvImageBlit;

/* class NV_IMAGE_FROM_MEMORY */
#define NV_IMAGE_FROM_MEMORY  32
typedef volatile struct
 tagNvImageFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* cannot be an unpacked format    0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY      0304-0307*/
 V032 Point;                   /* y_x S16_S16 in pixels           0308-030b*/
 V032 Size;                    /* height_width U16_U16 in pixels  030c-030f*/
 S032 ImagePitch;              /* gap in bytes between scan lines 0310-0313*/
 U032 ImageStart;              /* byte offset of top-left pixel   0314-0317*/
 V032 reserved03[0x73a];
} NvImageFromMemory;

/* class NV_IMAGE_FROM_CPU */
#define NV_IMAGE_FROM_CPU  33
typedef volatile struct
 tagNvImageFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels           0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels  0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16 in pixels  030c-030f*/
 V032 reserved03[0x03c];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageFromCpu;

/* class NV_IMAGE_MONOCHROME_FROM_CPU */
#define NV_IMAGE_MONOCHROME_FROM_CPU  34
typedef volatile struct
 tagNvImageMonochromeFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SetMonochromeFormat;     /*                                 0304-0307*/
 V032 Color0;                  /*                                 0308-030b*/
 V032 Color1;                  /*                                 030c-030f*/
 V032 Point;                   /*                                 0310-0313*/
 V032 Size;                    /*                                 0314-0317*/
 V032 SizeIn;                  /*                                 0318-031b*/
 V032 reserved03[0x039];
 V032 Monochrome[32];          /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageMonochromeFromCpu;

/***** Texture Mapping Classes *****/

/* class NV_RENDER_TEXTURE_BILINEAR */
#define NV_RENDER_TEXTURE_BILINEAR  35
typedef volatile struct
 tagNvRenderTextureBilinear {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvBiControlPointOut {
  V032 y0_x0;                  /* S16_S16 in pixels, 0 = top left 0310-0313*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 = top left 0314-0317*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 = top left 0318-031b*/
  V032 y3_x3;                  /* S16_S16 in pixels, 0 = top left 031c-031f*/
 } ControlPointOut;
 V032 reserved04[0x00c];
 struct
  tagNvBiControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S1.d4 in pixels           0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4 in pixels           0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4 in pixels           0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4 in pixels           035c-035f*/
 } ControlPointOut12d4;
 V032 reserved05[0x028];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved06[0x6e0];
} NvRenderTextureBilinear;
/*
 * Bit values for NV_RENDER_TEXTURE_BILINEAR and
 * NV_RENDER_TEXTURE_BILINEAR_BETA SubdivideIn()
 */
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_4    0x00000002
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_8    0x00000003
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_16   0x00000004
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_32   0x00000005
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_64   0x00000006
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_128  0x00000007
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_256  0x00000008
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_4     0x00000020
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_8     0x00000030
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_16    0x00000040
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_32    0x00000050
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_64    0x00000060
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_128   0x00000070
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_256   0x00000080
#define NV_BTM_SUBDIVIDE_EDGE_01_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_01_2         0x00010000
#define NV_BTM_SUBDIVIDE_EDGE_01_4         0x00020000
#define NV_BTM_SUBDIVIDE_EDGE_01_8         0x00030000
#define NV_BTM_SUBDIVIDE_EDGE_01_16        0x00040000
#define NV_BTM_SUBDIVIDE_EDGE_01_32        0x00050000
#define NV_BTM_SUBDIVIDE_EDGE_01_64        0x00060000
#define NV_BTM_SUBDIVIDE_EDGE_01_128       0x00070000
#define NV_BTM_SUBDIVIDE_EDGE_01_256       0x00080000
#define NV_BTM_SUBDIVIDE_EDGE_23_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_23_2         0x00100000
#define NV_BTM_SUBDIVIDE_EDGE_23_4         0x00200000
#define NV_BTM_SUBDIVIDE_EDGE_23_8         0x00300000
#define NV_BTM_SUBDIVIDE_EDGE_23_16        0x00400000
#define NV_BTM_SUBDIVIDE_EDGE_23_32        0x00500000
#define NV_BTM_SUBDIVIDE_EDGE_23_64        0x00600000
#define NV_BTM_SUBDIVIDE_EDGE_23_128       0x00700000
#define NV_BTM_SUBDIVIDE_EDGE_23_256       0x00800000
#define NV_BTM_SUBDIVIDE_EDGE_02_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_02_2         0x01000000
#define NV_BTM_SUBDIVIDE_EDGE_02_4         0x02000000
#define NV_BTM_SUBDIVIDE_EDGE_02_8         0x03000000
#define NV_BTM_SUBDIVIDE_EDGE_02_16        0x04000000
#define NV_BTM_SUBDIVIDE_EDGE_02_32        0x05000000
#define NV_BTM_SUBDIVIDE_EDGE_02_64        0x06000000
#define NV_BTM_SUBDIVIDE_EDGE_02_128       0x07000000
#define NV_BTM_SUBDIVIDE_EDGE_02_256       0x08000000
#define NV_BTM_SUBDIVIDE_EDGE_13_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_13_2         0x10000000
#define NV_BTM_SUBDIVIDE_EDGE_13_4         0x20000000
#define NV_BTM_SUBDIVIDE_EDGE_13_8         0x30000000
#define NV_BTM_SUBDIVIDE_EDGE_13_16        0x40000000
#define NV_BTM_SUBDIVIDE_EDGE_13_32        0x50000000
#define NV_BTM_SUBDIVIDE_EDGE_13_64        0x60000000
#define NV_BTM_SUBDIVIDE_EDGE_13_128       0x70000000
#define NV_BTM_SUBDIVIDE_EDGE_13_256       0x80000000

/* class NV_RENDER_TEXTURE_QUADRATIC */
#define NV_RENDER_TEXTURE_QUADRATIC  36
typedef volatile struct
 tagNvRenderTextureQuadratic {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvQuadControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
  V032 y4_x4;                  /*                                 0320-0323*/
  V032 y5_x5;                  /*                                 0324-0327*/
  V032 y6_x6;                  /*                                 0328-032b*/
  V032 y7_x7;                  /*                                 032c-032f*/
  V032 y8_x8;                  /*                                 0330-0333*/
 } ControlPointOut;
 V032 reserved04[0x007];
 struct
  tagNvQuadControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4                     0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4                     0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4                     0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4                     035c-035f*/
  V032 y4_x4;                  /* S12.4_S12.4                     0360-0363*/
  V032 y5_x5;                  /* S12.4_S12.4                     0364-0367*/
  V032 y6_x6;                  /* S12.4_S12.4                     0368-036b*/
  V032 y7_x7;                  /* S12.4_S12.4                     036c-036f*/
  V032 y8_x8;                  /* S12.4_S12.4                     0370-0373*/
 } ControlPointOut12d4;
 V032 reserved05[0x023];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved06[0x6e0];
} NvRenderTextureQuadratic;
/*
 * Bit values for NV_RENDER_TEXTURE_QUADRATIC and
 * NV_RENDER_TEXTURE_QUADRATIC_BETA SubdivideIn()
 */
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_4    0x00000002
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_8    0x00000003
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_16   0x00000004
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_32   0x00000005
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_64   0x00000006
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_128  0x00000007
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_256  0x00000008
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_4     0x00000020
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_8     0x00000030
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_16    0x00000040
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_32    0x00000050
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_64    0x00000060
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_128   0x00000070
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_256   0x00000080
#define NV_QTM_SUBDIVIDE_EDGE_02_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_02_2         0x00010000
#define NV_QTM_SUBDIVIDE_EDGE_02_4         0x00020000
#define NV_QTM_SUBDIVIDE_EDGE_02_8         0x00030000
#define NV_QTM_SUBDIVIDE_EDGE_02_16        0x00040000
#define NV_QTM_SUBDIVIDE_EDGE_02_32        0x00050000
#define NV_QTM_SUBDIVIDE_EDGE_02_64        0x00060000
#define NV_QTM_SUBDIVIDE_EDGE_02_128       0x00070000
#define NV_QTM_SUBDIVIDE_EDGE_02_256       0x00080000
#define NV_QTM_SUBDIVIDE_EDGE_68_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_68_2         0x00100000
#define NV_QTM_SUBDIVIDE_EDGE_68_4         0x00200000
#define NV_QTM_SUBDIVIDE_EDGE_68_8         0x00300000
#define NV_QTM_SUBDIVIDE_EDGE_68_16        0x00400000
#define NV_QTM_SUBDIVIDE_EDGE_68_32        0x00500000
#define NV_QTM_SUBDIVIDE_EDGE_68_64        0x00600000
#define NV_QTM_SUBDIVIDE_EDGE_68_128       0x00700000
#define NV_QTM_SUBDIVIDE_EDGE_68_256       0x00800000
#define NV_QTM_SUBDIVIDE_EDGE_06_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_06_2         0x01000000
#define NV_QTM_SUBDIVIDE_EDGE_06_4         0x02000000
#define NV_QTM_SUBDIVIDE_EDGE_06_8         0x03000000
#define NV_QTM_SUBDIVIDE_EDGE_06_16        0x04000000
#define NV_QTM_SUBDIVIDE_EDGE_06_32        0x05000000
#define NV_QTM_SUBDIVIDE_EDGE_06_64        0x06000000
#define NV_QTM_SUBDIVIDE_EDGE_06_128       0x07000000
#define NV_QTM_SUBDIVIDE_EDGE_06_256       0x08000000
#define NV_QTM_SUBDIVIDE_EDGE_28_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_28_2         0x10000000
#define NV_QTM_SUBDIVIDE_EDGE_28_4         0x20000000
#define NV_QTM_SUBDIVIDE_EDGE_28_8         0x30000000
#define NV_QTM_SUBDIVIDE_EDGE_28_16        0x40000000
#define NV_QTM_SUBDIVIDE_EDGE_28_32        0x50000000
#define NV_QTM_SUBDIVIDE_EDGE_28_64        0x60000000
#define NV_QTM_SUBDIVIDE_EDGE_28_128       0x70000000
#define NV_QTM_SUBDIVIDE_EDGE_28_256       0x80000000

/* class NV_RENDER_TEXTURE_BILINEAR_BETA */
#define NV_RENDER_TEXTURE_BILINEAR_BETA  52
typedef volatile struct
 tagNvRenderTextureBilinearBeta {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaOutput;           /* P_B to BetaMax or BlendAnd      0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvBiBControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
 } ControlPointOut;
 V032 reserved04[0x00c];
 struct
  tagNvBiBControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4                     0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4                     0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4                     0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4                     035c-035f*/
 } ControlPointOut12d4;
 V032 reserved05[0x008];
 struct
  tagNvBiBControlBetaOut {
  V032 beta1_beta0;            /* S1.15_S1.15 beta at CP1 and CP0 0380-0383*/
  V032 beta3_beta2;            /* S1.15_S1.15 beta at CP3 and CP2 0384-0387*/
 } ControlBetaOut;
 V032 reserved06[0x01e];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved07[0x6e0];
} NvRenderTextureBilinearBeta;

/* class NV_RENDER_TEXTURE_QUADRATIC_BETA */
#define NV_RENDER_TEXTURE_QUADRATIC_BETA  53
typedef volatile struct
 tagNvRenderTextureQuadraticBeta {
 V032 SetNotifyCtxDma;         /*                                 0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaOutput;           /* P_B to BetaMax or BlendAnd      0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColorFormat;          /* NV_COLOR_FORMAT, must be packed 0300-0303*/
 V032 SubdivideIn;             /* NV_QTM_SUBDIVIDE OR'd values    0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvQuadBControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
  V032 y4_x4;                  /*                                 0320-0323*/
  V032 y5_x5;                  /*                                 0324-0327*/
  V032 y6_x6;                  /*                                 0328-032b*/
  V032 y7_x7;                  /*                                 032c-032f*/
  V032 y8_x8;                  /*                                 0330-0333*/
 } ControlPointOut;
 V032 reserved04[0x007];
 struct
  tagNvQuadBControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4 in pixels           0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4 in pixels           0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4 in pixels           0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4 in pixels           035c-035f*/
  V032 y4_x4;                  /* S12.4_S12.4 in pixels           0360-0363*/
  V032 y5_x5;                  /* S12.4_S12.4 in pixels           0364-0367*/
  V032 y6_x6;                  /* S12.4_S12.4 in pixels           0368-036b*/
  V032 y7_x7;                  /* S12.4_S12.4 in pixels           036c-036f*/
  V032 y8_x8;                  /* S12.4_S12.4 in pixels           0370-0363*/
 } ControlPointOut12d4;
 V032 reserved05[0x003];
 struct
  tagNvQuadBControlBetaOut {
  V032 beta1_beta0;            /* S1.15_S1.15 beta at CP1 and CP0 0380-0383*/
  V032 beta3_beta2;            /* S1.15_S1.15 beta at CP3 and CP2 0384-0387*/
  V032 beta5_beta4;            /* S1.15_S1.15 beta at CP5 and CP4 0388-038b*/
  V032 beta7_beta6;            /* S1.15_S1.15 beta at CP7 and CP6 038c-038f*/
  V032 na_beta8;               /* <don't care>_S1.15 beta at CP9  0390-0393*/
 } ControlBetaOut;
 V032 reserved06[0x01b];
 V032 Color[32];               /* texel colors, must be packed    0400-047f*/
 V032 reserved07[0x6e0];
} NvRenderTextureQuadraticBeta;

/***** Image Readback Class *****/

/* class NV_IMAGE_TO_MEMORY */
#define NV_IMAGE_TO_MEMORY  37
typedef volatile struct
 tagNvImageToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* cannot be an unpacked format    0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_TO_MEMORY        0304-0307*/
 V032 Point;                   /* y_x S16_S16 in pixels           0308-030b*/
 V032 Size;                    /* height_width U16_U16 in pixels  030c-030f*/
 S032 ImagePitch;              /* gap in bytes between scan lines 0310-0313*/
 U032 ImageStart;              /* byte offset of top-left pixel   0314-0317*/
 V032 reserved03[0x73a];
} NvImageToMemory;

/***** Audio Classes *****/

/* class NV_AUDIO_TO_MEMORY */
#define NV_AUDIO_TO_MEMORY  38
typedef volatile struct
 tagNvAudioToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetAudioFormat;          /*                                 030c-030f*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0310-0313*/
 V032 reserved04[0x03b];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved05[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved06[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved07[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved08[0x006];
 V032 SetBufferNotify[2];      /* indicates buff is ready to fill 0480-0487*/
 V032 reserved09[0x6de];
} NvAudioToMemory;

/* values for SetAudioFormat() */
#define NV_AUDIO_FORMAT_LE_S016_LINEAR     0x00000000
#define NV_AUDIO_FORMAT_LE_V008_ULAW       0x00000001
#define NV_AUDIO_FORMAT_LE_V008_ALAW       0x00000002
#define NV_AUDIO_FORMAT_LE_U008_OFFSET     0x00000003

/* class NV_AUDIO_FROM_MEMORY */
#define NV_AUDIO_FROM_MEMORY  39
typedef volatile struct
 tagNvAudioFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput[56];      /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetAudioFormat;          /*                                 030c-030f*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0310-0313*/
 V032 SetSampleRateAdjust;     /* U16.16 sample rate multiplier   0314-0317*/
 V032 reserved04[0x03a];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved05[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved06[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved07[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved08[0x006];
 V032 SetBufferNotify[2];      /* indicates buf is ready to be read 0480-0487*/
 V032 reserved09[0x6de];
} NvAudioFromMemory;

/* class NV_AUDIO_NOTE_FROM_MEMORY */
#define NV_AUDIO_NOTE_FROM_MEMORY  40
typedef volatile struct
 tagNvAudioNoteFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput[56];      /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetStopLoopingCtxTime;   /* no more looping after this time 0308-030b*/
 V032 reserved04[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0310-0313*/
 V032 SetAudioFormat;          /*                                 0314-0317*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0318-031b*/
 V032 SetSampleRateAdjust;     /* U16.16 sample rate multiplier   031c-031f*/
 V032 SetPortamento;           /* U16.16 10-90% ramp in millisec. 0320-0323*/
 U032 SetVibratoDepth;         /* U0.32 fraction                  0324-0327*/
 V032 SetVibratoFrequency;     /* U16.16 in Hertz (cycles/sec)    0328-032b*/
 V032 SetVibratoAttackCtxTime; /* NV_CONTEXT_TIME                 032c-032f*/
 V032 SetVibratoAttack;        /* U16.16 10-90% ramp in millisec. 0330-0333*/
 V032 reserved05[0x033];
 V032 SetBufferCtxDma;         /* NV_CONTEXT_DMA_FROM_MEMORY      0400-0403*/
 V032 SetBufferNotifyCtxDma;   /* NV_CONTEXT_DMA_TO_MEMORY        0404-0407*/
 U032 SetBufferStart;          /* offset within ctxdma in bytes   0408-040b*/
 U032 SetBufferLength;         /* in bytes                        040c-040f*/
 U032 SetBufferLoopStart;      /* offset in bytes of loop start   0410-0413*/
 U032 SetBufferLoopLength;     /* in bytes                        0414-0417*/
 V032 SetBufferNotify;         /* indicates buf is ready to read  0418-041b*/
 V032 reserved06[0x6f9];
} NvAudioNoteFromMemory;

/* class NV_AUDIO_MIXER */
#define NV_AUDIO_MIXER  41
typedef volatile struct
 tagNvAudioMixer {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO              0204-02e3*/
 V032 reserved02[0x007];
 V032 SetOutputGain;           /* U8.24 "master" volume           0300-0303*/
 V032 SetInputGain[56];        /* U8.24                           0303-03e3*/
 V032 reserved03[0x707];
} NvAudioMixer;

/* class NV_AUDIO_ENVELOPE */
#define NV_AUDIO_ENVELOPE  42
typedef volatile struct
 tagNvAudioEnvelope {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput;           /* NV_PATCHCORD_AUDIO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetAttack;               /* U16.16 10-90% ramp in millisec. 0300-0303*/
 V032 SetDecay;                /* U16.16 90-10% decay in msec.    0304-0307*/
 V032 SetSustain;              /* U16.16 90-10% decay in msec.    0308-030b*/
 V032 SetRelease;              /* U16.16 90-10% decay in msec.    030c-030f*/
 V032 SetAttackCtxTime;        /* NV_CONTEXT_TIME                 0310-0313*/
 V032 reserved03[0x001];
 V032 SetReleaseCtxTime;       /* NV_CONTEXT_TIME                 0318-031b*/
 V032 reserved04[0x001];
 U032 SetSustainLevel;         /* U0.32 fraction                  0320-0323*/
 V032 reserved05[0x737];
} NvAudioEnvelope;

/* class NV_AUDIO_TREMOLO */
#define NV_AUDIO_TREMOLO  43
typedef volatile struct
 tagNvAudioTremolo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput;           /* NV_PATCHCORD_AUDIO              0204-0207*/
 V032 reserved02[0x03e];
 U032 SetTremoloDepth;         /* U0.32 proportion                0300-0303*/
 V032 SetTremoloFrequency;     /* U16.16 in Hertz (cycles/sec)    0304-0307*/
 V032 SetTremoloAttackCtxTime; /* NV_CONTEXT_TIME                 0308-030b*/
 V032 SetTremoloAttack;        /* U16.16 10-90% ramp in millisec. 030c-030f*/
 V032 reserved03[0x73c];
} NvAudioTremolo;

/* class NV_CONTEXT_TIME */
#define NV_CONTEXT_TIME  44
typedef volatile struct
 tagNvContextTime {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetTime {
  U032 nanoseconds[2];
 } SetTime;                    /* nanoseconds since Jan. 1, 1970  0300-0307*/
 V032 reserved02[0x73e];
} NvContextTime;

/* class NV_AUDIO_SINK */
#define NV_AUDIO_SINK  45
typedef volatile struct
 tagNvAudioSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO              0200-02df*/
 V032 reserved02[0x748];
} NvAudioSink;

/* class NV_AUDIO_SOURCE */
#define NV_AUDIO_SOURCE  46
typedef volatile struct
 tagNvAudioSource {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCHORD_AUDIO             0200-0203*/
 V032 reserved02[0x77f];
} NvAudioSource;

/* class NV_PATCHCORD_AUDIO */
#define NV_PATCHCORD_AUDIO  47
typedef volatile struct
 tagNvPatchcordAudio {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordAudio;

/***************************************************************************
 *                   Subchannels within a Channel                          *
 ***************************************************************************/

/*
 * The first 256 bytes of each subchannel are the NvControl registers.
 * The interpretation of writes to offets in the rest of the
 * subchannel depends on the class of the object loaded in the
 * subchannel, so the rest of the NvSubchannel structure is a union
 * of the class structures.
 */
typedef struct
 tagNvSubchannel {
 NvControl                     control;
 union {
  NvClass                      nvClass;
  NvContextDmaFromMemory       contextDmaFromMemory;
  NvContextDmaToMemory         contextDmaToMemory;
  NvTimer                      timer;
  NvChipId                     chipId;
  NvContextOrdinal             contextOrdinal;
  NvNullClass                  nullClass;
  NvPatchcordGamePort          patchcordGamePort;
  NvGamePortSource             gamePortSource;
  NvGamePortToMemory           gamePortToMemory;
  NvPatchcordVideo             patchcordVideo;
  NvVideoSink                  videoSink;
  NvVideoSwitch                videoSwitch;
  NvVideoColormap              videoColormap;
  NvPatchcordImage             patchcordImage;
  NvImageToVideo               imageToVideo;
  NvImageStencil               imageStencil;
  NvPatchcordBeta              patchcordBeta;
  NvImageBlendAnd              imageBlendAnd;
  NvBetaSolid                  betaSolid;
  NvBetaMaximum                betaMaximum;
  NvPatchcordRop               patchcordRop;
  NvImageRopAnd                imageRopAnd;
  NvRopSolid                   ropSolid;
  NvImageColorKey              imageColorKey;
  NvImagePlaneSwitch           imagePlaneSwitch;
  NvImageSolid                 imageSolid;
  NvImagePattern               imagePattern;
  NvImageBlackRectangle        imageBlackRectangle;
  NvRenderSolidPoint           renderSolidPoint;
  NvRenderSolidLine            renderSolidLine;
  NvRenderSolidLin             renderSolidLin;
  NvRenderSolidTriangle        renderSolidTriangle;
  NvRenderSolidRectangle       renderSolidRectangle;
  NvImageBlit                  imageBlit;
  NvImageFromMemory            imageFromMemory;
  NvImageFromCpu               imageFromCpu;
  NvImageMonochromeFromCpu     imageMonochromeFromCpu;
  NvRenderTextureBilinear      renderTextureBilinear;
  NvRenderTextureQuadratic     renderTextureQuadratic;
  NvRenderTextureBilinearBeta  renderTextureBilinearBeta;
  NvRenderTextureQuadraticBeta renderTextureQuadraticBeta;
  NvImageToMemory              imageToMemory;
  NvAudioToMemory              audioToMemory;
  NvAudioFromMemory            audioFromMemory;
  NvAudioNoteFromMemory        audioNoteFromMemory;
  NvAudioMixer                 audioMixer;
  NvAudioEnvelope              audioEnvelope;
  NvAudioTremolo               audioTremolo;
  NvContextTime                contextTime;
  NvAudioSink                  audioSink;
  NvAudioSource                audioSource;
  NvPatchcordAudio             patchcordAudio;
 };
} NvSubchannel;

/*
 * There are 8 subchannels in one 64KByte channel.
 */
typedef struct
 tagNvChannel {
 NvSubchannel subchannel[8];
} NvChannel;

#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV1.C
//
// Abstract:
//
//     This is code specific to NV1
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv1c_ref.h"
#include "nv1_32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "sgs_dac.h"

#include "cmdcnst.h"

//******************************************************************************
//
// Function Declarations
//
//******************************************************************************

VOID SetRop(PHW_DEVICE_EXTENSION,ULONG);
VOID SetPattern(PHW_DEVICE_EXTENSION);
VOID SetColorKey(PHW_DEVICE_EXTENSION,ULONG);
VOID SetClip(PHW_DEVICE_EXTENSION, ULONG, ULONG, ULONG, ULONG);
VOID ImageMonoBlit(PHW_DEVICE_EXTENSION,LONG,LONG,ULONG,ULONG);
VOID MemoryToScreenBlit(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG);
VOID ScreenToScreenBlit(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
VOID RenderTriangle(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID RenderRectangle(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID UpdateRenderObjectContext(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID CalculateRenderObjectContext(PHW_DEVICE_EXTENSION,PRENDEROBJECT,ULONG);
VOID SetContextRopSolid(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextPattern(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextBlackRectangle(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextImageSolid(PHW_DEVICE_EXTENSION,ULONG);
VOID SetPatchContext(PHW_DEVICE_EXTENSION,ULONG);
VOID InitColorFormatTable(PHW_DEVICE_EXTENSION);
VOID SetObjectColorFormat(PHW_DEVICE_EXTENSION,PCOMMONOBJECT,ULONG,ULONG);
VOID ClearPatchContext(PHW_DEVICE_EXTENSION,PPATCHCONTEXT);
VOID NV1SetupPatches(PHW_DEVICE_EXTENSION);
VOID SetupRenderObject(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
VOID ClearOutRenderObjects(PHW_DEVICE_EXTENSION);
BOOLEAN NV1GetNVInfo(PHW_DEVICE_EXTENSION);
VOID NV1SetupGraphicsEngine(PHW_DEVICE_EXTENSION);
VOID NV1SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID SetObjectCachedCtxRegs(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID SetObjectHash(PHW_DEVICE_EXTENSION,ULONG,ULONG);
VOID FifoResend(PHW_DEVICE_EXTENSION);
VOID ClearOutGrTable(PHW_DEVICE_EXTENSION);
VOID ClearOutFifoTable(PHW_DEVICE_EXTENSION);
VOID ClearOutNVInfo(PHW_DEVICE_EXTENSION);
VOID ClearOutHashTables(PHW_DEVICE_EXTENSION);
VOID ClearOutContextMemoryAndRegisters(PHW_DEVICE_EXTENSION);
VOID LoadChannelContext(PHW_DEVICE_EXTENSION);
VOID NV1_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV1_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NV1_MapMemoryRanges(PVOID HwDeviceExtension);
BOOLEAN NV1_IsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NV1Interrupt(PHW_DEVICE_EXTENSION);
VOID dacCalcPClkVClkRatio(PHW_DEVICE_EXTENSION);
VOID dacCalcPLL(PHW_DEVICE_EXTENSION);
VOID NV1GraphicsTest(PHW_DEVICE_EXTENSION);
VOID NV1ClearScreen(PHW_DEVICE_EXTENSION);
VOID NV1WaitUntilFinished(PHW_DEVICE_EXTENSION);
VOID ImageMonoLetterY(PHW_DEVICE_EXTENSION,LONG,LONG,ULONG,ULONG);
VOID NV1SetOpenGLPatch(PHW_DEVICE_EXTENSION);
VOID NV1RestoreDisplayDriverPatch(PHW_DEVICE_EXTENSION);



VOID NV1ObjectSwappingTest(PHW_DEVICE_EXTENSION);
VOID NV1ObjectSwappingTryIt(PHW_DEVICE_EXTENSION);
VOID NV1ObjectSwappingRestore(PHW_DEVICE_EXTENSION);

// Make all other functions pageable???
#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NV1SetMode)
#pragma alloc_text(PAGE,NV1SetupGraphicsEngine)
#endif


//******************************************************************************
//
//  Function:   SetRop()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetRop(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG Rop)

    {

    NvChannel *nv;
    volatile ULONG FreeCount;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.free;

    while (FreeCount < 1*4)
        FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.free;
    FreeCount -= 1*4;

    //**************************************************************************
    // Set ROP
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop;


    }


//******************************************************************************
//
//  Function:   SetPattern()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetPattern(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    NvChannel *nv;
    ULONG color0;
    ULONG color1;
    PHWINFO NVInfo;

    //**************************************************************************
    // Get pointer to NVInfo structure, then init colors
    // according to what the current pixel depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            break;
        case 16:
            color0 =    NV_ALPHA_1_16 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_16 | 0x00007fff;         // WHITE
            break;
        case 8:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            break;
        }

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.free < 5*4);

    //*************************************************************************
    //
    //  nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
    //  nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetMonochromeFormat = NV_MONO_CGA6_M1_P32;
    //
    // Do NOT set ColorFormat and Monochrome format here, because
    // they require a Resource Manager to service them!  Doing so will cause
    // a lockup/interrupt. The remaining methods are hardware methods and go
    // straight to hardware. They will NOT generate an interrupt/lockup.
    //*************************************************************************

    //*************************************************************************
    // Regardless of what the pixel depth is, we should see a jailbar pattern.
    //*************************************************************************

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPatternShape = NV_PATTERN_SHAPE_64X1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColor0 = color0;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColor1 = color1;
//    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[0] = 0x50505050;
//    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[1] = 0x12345678;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[0] = 0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[1] = 0x50505050;

    }


//******************************************************************************
//
//  Function:   SetColorKey()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetColorKey(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG Color)

    {

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[7].control.free < 1*4);

    //**************************************************************************
    // Set color key value
    //**************************************************************************

    nv->subchannel[7].imageSolid.SetColor = Color; // 0 will disable color keying

    }


//******************************************************************************
//
//  Function:   SetClip()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetClip(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG x, ULONG y, ULONG width, ULONG height)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[CLIP_SUBCHANNEL].control.free < 2*4);

    //**************************************************************************
    // Set the clipping rectangle
    //**************************************************************************

    nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((y << 16) | x );
    nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = ((height<<16) | width);

    }


//******************************************************************************
//
//  Function:   ImageMonoLetterY()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ImageMonoLetterY(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       LONG x,LONG y, ULONG Color0, ULONG Color1)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixel;
    ULONG width,height;
    ULONG NumDwords;
    ULONG DwordCount;
    ULONG SizeInWidth;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // IMAGE MONO FROM CPU classes requires an UNpacked format !!!!
    //
    //          |<------------->| SizeIn = 8    (Data Width sent)
    //
    //          |<------->|  Size = 5           (Clipped size)
    //                    |
    //   ___     -------|-------
    //    ^     | | | | | | | | |
    //    |     | | | | | | | | |  1 dword = 0x00000000
    //    |     | | | | | | | | |
    //    |     | | | | | | | | |_________
    //    |     |x| | |x| | | | |
    //    |     |x| | |x| | | | |
    //Height=12 |x| | |x| | | | |  1 dword = 0x90909090
    //    |     |x| | |x| | | | |_________
    //    |     |x| | |x| | | | |
    //    |     | |x|x|x| | | | |
    //    |     | | | |x| | | | |  1 dword = 0xE0107090
    //    |     |x|x|x| | | | | |
    //   ---     ---------------
    //
    //**************************************************************************

    width = 5;
    height= 12;
    SizeInWidth = 8;

    //**************************************************************************
    // We'll set the alpha bits to test color 0 = transparent
    //                                  color 1 = visible
    //**************************************************************************

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 5*4);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color0 =  Color0 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color1 =  Color1 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Point =  ( (y <<16) | (x & 0xffff) );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.SizeIn = ( (height <<16) | SizeInWidth );

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 12);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[0] = 0x0;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[1] = 0x090909090;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[2] = 0x0E0107090;


    }



//******************************************************************************
//
//  Function:   ImageMonoBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ImageMonoBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       LONG x,LONG y, ULONG Color0, ULONG Color1)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixel;
    ULONG width,height;
    ULONG NumDwords;
    ULONG DwordCount;
    ULONG SizeInWidth;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // IMAGE MONO FROM CPU classes requires an UNpacked format !!!!
    //**************************************************************************

    width = 50;
    height= 20;
    SizeInWidth = (width + 31) & 0xffe0;    // Specify pixels as multiple of 32 since
                                            // we always output DWORDS at a time

    NumDwords = (width + 31)/32;            // Dwords at a time (32 pixels per dword)

    //**************************************************************************
    // We'll set the alpha bits to test color 0 = transparent
    //                                  color 1 = visible
    //**************************************************************************

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 5*4);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color0 =  Color0 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color1 =  Color1 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Point =  ( (y <<16) | (x & 0xffff) );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.SizeIn = ( (height <<16) | SizeInWidth );

    //**************************************************************************
    // The following method is EXTREMELY inefficient, but simple and works.
    // To get much better performance, do NOT constantly read the
    // freecount inside the loop.  Instead, CACHE it in local memory.
    // Also, don't constantly write to the same monochrome[0] location.
    // Use increasing locations to allow for PCI burst mode, and better performance.
    // See Text accleration code in the display driver for better examples.
    //**************************************************************************

    for (yscan=0; yscan < height; yscan ++)
        for (DwordCount = 0; DwordCount < NumDwords; DwordCount++)
            {
            while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 4);
            nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[0] = 0x0f0f0f0f;
            }


    }


//******************************************************************************
//
//  Function:   MemoryToScreenBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID MemoryToScreenBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        ULONG width,ULONG height, ULONG x,ULONG y)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixeldata;
    PHWINFO NVInfo;

    //**************************************************************************
    // Get pointer to NVInfo structure, then init colors
    // according to what the current pixel depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            pixeldata = NV_ALPHA_1_32 | 0x00ff0000;         // RED
            break;
        case 16:
            pixeldata = (ULONG) ((NV_ALPHA_1_16 | 0x7c00)<<16) |
                         (NV_ALPHA_1_16 | 0x7c00);          // RED
            break;
        case 8:
            pixeldata =   (ULONG) ( 0xff<<24) |
                                  ( 0xff<<16) |
                                  ( 0xff<<8)  |
                                  ( 0xff)     ;                     // WHITE
            break;
        }

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    // IMAGE FROM CPU classes require a PACKED format !!!!
    //**************************************************************************

    while (nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free < 3*4);
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Point =  ( (y <<16) | x );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.SizeIn = ( (height <<16) | width );

    for (yscan=0;yscan < height; yscan++)
        for (xscan=0; xscan < width; xscan++)
            {
            while (nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free < 4);
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Color[0] =  pixeldata;
            }


    }

//******************************************************************************
//
//  Function:   ScreenToScreenBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ScreenToScreenBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG width,ULONG height,
                        ULONG xsrc,ULONG ysrc, ULONG xdst,ULONG ydst)

    {

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[BLIT_SUBCHANNEL].control.free < 3*4);


    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.ControlPointIn =  ( (ysrc <<16) | xsrc );
    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.ControlPointOut = ( (ydst <<16) | xdst );
    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.Size = ( (height <<16) | width );


    }


//******************************************************************************
//
//  Function:   RenderTriangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID RenderTriangle(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG x,ULONG y,ULONG Color)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Since we've only got 8 subchannels, we don't have enough room for the
    // TRIANGLE object.  If we need it use it later (i.e. Direct 3D/OpenGL), we'll need
    // to manually swap out one of the current objects and load the TRIANGLE object
    //**************************************************************************

//    //**************************************************************************
//    // Get pointer to NV channel area
//    //**************************************************************************
//
//    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//    //**************************************************************************
//    // Wait for FIFO
//    //**************************************************************************
//
//    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 4*4);
//
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0x00000000 | Color;
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);

    }


//******************************************************************************
//
//  Function:   RenderRectangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID RenderRectangle(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG x,ULONG y,ULONG Color)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = Color;
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00400040;

    }

//******************************************************************************
//
//  Function:   UpdateRenderObjectContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID UpdateRenderObjectContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      ULONG ObjectName, ULONG SubChannel, ULONG Context)


    {
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Cache1 access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Add object to hash table
    //**************************************************************************

    SetObjectHash(HwDeviceExtension, ObjectName, Context);

    //**************************************************************************
    // Update the cached context register
    //**************************************************************************

    SetObjectCachedCtxRegs(HwDeviceExtension, SubChannel, ObjectName, Context);

    //**************************************************************************
    // Restore Cache1 state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }

//******************************************************************************
//
//  Function:   CalculateRenderObjectContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID CalculateRenderObjectContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                                   PRENDEROBJECT PObject,ULONG RenderObjectClass)

    {
    ULONG Context;
    ULONG Device;
    ULONG Buffer;

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            Device = DEVICE_BASE(NV_UPOINT);
            break;
        case NV_RENDER_SOLID_LINE:
            Device = DEVICE_BASE(NV_ULINE);
            break;
        case NV_RENDER_SOLID_LIN:
            Device = DEVICE_BASE(NV_ULIN);
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            Device = DEVICE_BASE(NV_UTRI);
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            Device = DEVICE_BASE(NV_URECT);
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            Device = DEVICE_BASE(NV_UBTM);
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            Device = DEVICE_BASE(NV_UQTM);
            break;
        case NV_IMAGE_FROM_CPU:
            Device = DEVICE_BASE(NV_UIMAGE);
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            Device = DEVICE_BASE(NV_UBITMAP);
            break;
//        case NV_IMAGE_FROM_MEM:
//            Device = DEVICE_BASE(NV_UFROMEM);
//            break;
//        case NV_IMAGE_TO_MEM:
//            Device = DEVICE_BASE(NV_UTOMEM);
//          break;
        case NV_IMAGE_BLIT:
            Device = DEVICE_BASE(NV_UBLIT);
            break;
        }

    //**************************************************************************
    // Generate the CONTEXT for this device...
    // It consists of 2 parts...the physical DEVICE and phyiscal INSTANCE
    //
    //    ----------------------------------------------------
    //   |       DEVICE           |         Instance          |
    //    ----------------------------------------------------
    //
    //
    //  Label   Bits    Name        Description
    //  -----   ----    ----        -----------
    //  a       (0-4)   Patch Cfg   Encoded configuration value for data path units
    //                                      Value   Meaning
    //                                      -----   -------
    //                                      0 thru 1f   Many different cfgs
    //
    //  b       (5)     ChromaKey   Enables Chroma Key or Beta Maximum
    //  c       (6)     PlaneMask   Enables Plane Mask
    //  d       (7)     UserClip    Enables User Clip
    //  e       (8)     Notify      Notify valid or invalid for object
    //  f       (9-12)  Color Buffer Specifies color format of source pixel data
    //                                      Value   Meaning (Single Buffer 0)
    //                                      -----   -------
    //                                      0x0     R5G5B5
    //                                      0x1     R8G8B8
    //                                      0x2     R10G10B10
    //                                      0x3     Y8
    //                                      0x4     Y16
    //
    //  g       (13)    Alpha       Enables Alpha
    //  h       (14)    Mono        Specifies little endian or CGA6 format
    //  i       (15)    Patch ID    Resource Manager is needed to do heavy weigh context switch
    //
    //**************************************************************************

    Buffer = 0;         // Is this the correct value ???
                        // 1 for R8G8B8 ???
    Context = Device                                      |
              PObject->RCPatchContext.ImageConfig         |
              PObject->CColorFormat                       |
              PObject->CMonoFormat +
              DRF_NUM(_PGRAPH,_CTX_SWITCH,_COLOR_BUFFER, Buffer);

    //**************************************************************************
    // .. and return it.
    //**************************************************************************

    PObject->CContext = Context;
    }


//******************************************************************************
//
//  Function:   SetContextRopSolid()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextRopSolid(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_ROP_SOLID).
    // Enable COLORKEY'ing
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_ROP_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;

    StaticObjectPtr->Context = DEVICE_BASE(NV_UROP) | StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable COLORKEY'ing
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    ;   // No updates necessary

    //**************************************************************************
    // Specify the actual ROP value.
    //**************************************************************************

    PatchContextPtr->Rop.Rop3 = 0xcc;   // Source Copy for now

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_ROP_SOLID;
    HwDeviceExtension->FifoTable.ObjectStack[ROP_SOLID_SUBCHANNEL] = MY_ROP_SOLID;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_ROP_SOLID, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, ROP_SOLID_SUBCHANNEL, MY_ROP_SOLID, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetContextPattern()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextPattern(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_PATTERN).
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_PATTERN_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

//    if (NVInfo->Framebuffer.Depth == 8)
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
//    else if (NVInfo->Framebuffer.Depth == 16)
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
//    else
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X24Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X17R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X8R8G8B8;

    StaticObjectPtr->MonoFormat = MONO_FORMAT_CGA6;
    StaticObjectPtr->Context = DEVICE_BASE(NV_UPATT)                    |
                              StaticObjectPtr->ColorFormat              |
                              StaticObjectPtr->MonoFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Here we just specify the patch configuration.
    //
    // - PatchConfig - See the Patch Configuration table (7-1) in the
    //                 graphics reference to determine how to set this value.
    //                 It is determined by where src, pattern, and destination
    //                 are hooked up to the ROP_AND object.  For the DISPLAY
    //                 driver, we will be using the following conceptual hookup patch.
    //
    //                                                     ---
    //                  IMAGE_TO_VIDEO (DST)---> input 0  | R |
    //                  RENDER OBJECT (SRC) ---> input 1  | O |
    //                  PATTERN OBJECT (PAT)---> input 2  | P |
    //                                                     ---
    //                  This corresponds to patch configuration 0x10
    //                  for the CTX_SWITCH register bits 0-4.
    //
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig &= 0xffffffe0;
    PatchContextPtr->ImageConfig |= DRF_NUM(_PGRAPH,_CTX_SWITCH, _PATCH_CONFIG, 0x10);

    //**************************************************************************
    // Specify the actual PATTERN values.  These will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->RopPat.PattColor0      = 0xff00ff00;
    PatchContextPtr->RopPat.PattColor0Alpha = 0xff00ff00;
    PatchContextPtr->RopPat.PattColor1      = 0xffffff00;
    PatchContextPtr->RopPat.Pattern0        = 0x50505050;
    PatchContextPtr->RopPat.Pattern1        = 0x12345678;
    PatchContextPtr->RopPat.PatternShape = NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1;

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_IMAGE_PATTERN;
    HwDeviceExtension->FifoTable.ObjectStack[IMAGE_PATTERN_SUBCHANNEL] = MY_IMAGE_PATTERN;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_IMAGE_PATTERN, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, IMAGE_PATTERN_SUBCHANNEL, MY_IMAGE_PATTERN, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetContextBlackRectangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextBlackRectangle(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************


    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_BLACK_RECTANGLE).
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_BLACK_RECTANGLE_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;


    StaticObjectPtr->Context = DEVICE_BASE(NV_UCLIP) | StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable CLIPPING
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig |= DRF_DEF(_PGRAPH,_CTX_SWITCH, _USER_CLIP, _ENABLED);

    //**************************************************************************
    // Specify the actual CLIP values.  These will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->Clip.xClipMin = 100;
    PatchContextPtr->Clip.xClipMax = 320;  // TO DO :Get values from NVINFO !!!
    PatchContextPtr->Clip.yClipMin = 100;
    PatchContextPtr->Clip.yClipMax = 240;  // TO DO: Get values from NVINFO

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_BLACK_RECTANGLE;
    HwDeviceExtension->FifoTable.ObjectStack[CLIP_SUBCHANNEL] = MY_BLACK_RECTANGLE;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_BLACK_RECTANGLE, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, CLIP_SUBCHANNEL, MY_BLACK_RECTANGLE, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }



//******************************************************************************
//
//  Function:   SetContextImageSolid()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextImageSolid(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_SOLID).
    // Enable COLORKEY'ing
    //
    // Color Format information (Assumes only Destination Buffer 0 Enabled):
    // See Table 7-2 in the NV1 Graphics Reference Manual for more information
    // on Color and Buffer Configuration Bits 9-12 in CTX_SWITCH register
    //
    //              DEFINE  corresponds to  COLOR FORMAT
    //              --------------          ------------
    //              X17R5G5B5               0x00000000
    //              X16A1R5G5B5             0x00002000
    //              X8R8G8B8                0x00000200
    //              A8RG8B8                 0x00002200
    //              X2R10G10B10             0x00000400
    //              A2R10G10B10             0x00002400
    //              etc..
    //
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_SOLID_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;
    StaticObjectPtr->Context = DEVICE_BASE(NV_UCHROMA)                    |
                              StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable COLORKEY'ing
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig |= DRF_DEF(_PGRAPH,_CTX_SWITCH,_CHROMA_KEY,_ENABLED);

    //**************************************************************************
    // Specify the actual ROP value.  This will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->ColorKey.Color = 0;  //Disable color keying

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_IMAGE_SOLID;
    HwDeviceExtension->FifoTable.ObjectStack[7] = MY_IMAGE_SOLID;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_IMAGE_SOLID, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, 7, MY_IMAGE_SOLID, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetPatchContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetPatchContext(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PPATCHCONTEXT PatchContext;
    PGRAPHICSCHANNEL GrTablePtr;
    PCOMMONOBJECT StaticObjectPtr;
    ULONG Data;
    ULONG XYLogicMisc1;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    //
    // grLoadPatch vs. grLoadChannelContext in Win 95RM
    // ------------------------------------------------
    // In the Win95 Resource Manager (for NV1), these functions are very similar.
    // The difference between these two functions is that grLoadChannelContext
    // is used mainly during Context Switching, whereas grLoadPatch is used
    // update the contexts of the NON-RENDERING objects, usually the first time.
    // grLoadChannelContext just manually goes in an modifies the global registers
    // and restores the global state of the graphics engine. In other words,
    // grLoadPatch is a SuperSet/One Time init of grLoadChannelContext.
    // Not only does it set the registers, it also sets up an entry in the
    // HASH TABLE for the object, and updates the object's context in the
    // appropriate cached context register.
    //
    // Here, in this miniport, the SetPatchContextXXXXX functions will be
    // analogous to grLoadPatch.
    //
    // This function will:
    //
    //         1) Set up the static object states (ROP,CLIP,PATTERN,COLOR KEY)
    //            This includes
    //                  - Adding an entry into the HASH table for each static object
    //                  - Setting up the context of static object in
    //                    the cached context registers
    //                  - Updating the associated RENDERING object's context.
    //                    It is affected by whatever values we specify in the
    //                    static objects (i.e.  enables clipping )
    //         2) Set the actual hardware registers for ROP, CLIP, PATTERN, and COLOR KEY
    //
    //**************************************************************************

    //**************************************************************************
    // The following functions will:
    //
    //      1) Calculate the context for the specific static object
    //         according to what attributes we specify
    //      2) Update the Hash Table and store the Context in the
    //         corresponding cached context register
    //      3) Update the context for the corresponding RENDER object
    //         associated with this patch
    //
    // Static Objects: ROP, PATTERN, BLACK RECTANGLE(CLIP), and IMAGE SOLID (COLOR KEY)
    //**************************************************************************

    //**************************************************************************
    // Color Keying is currently DISABLED !!! (Because we only have 8 subchannels
    // and color keying is not that important for a display driver.
    //
    // Update: Added SetContextImageSolid back in because DDRAW requires it!!
    //**************************************************************************

    SetContextImageSolid(HwDeviceExtension,PatchID);

    SetContextBlackRectangle(HwDeviceExtension,PatchID);

    SetContextRopSolid(HwDeviceExtension,PatchID);

    SetContextPattern(HwDeviceExtension,PatchID);

    //**************************************************************************
    // Get pointers to each of the static state objects so that
    // we can setup the hardware register values.
    //**************************************************************************

    PatchContext = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    GrTablePtr   = &(HwDeviceExtension->GrTable);

    GrTablePtr->CurrentColorKey  = &(PatchContext->ColorKey);
    GrTablePtr->CurrentRop       = &(PatchContext->Rop);
    GrTablePtr->CurrentClip      = &(PatchContext->Clip);
    GrTablePtr->CurrentPattern   = &(PatchContext->RopPat);

    //**************************************************************************
    // Load STATIC STATE into hardware registers:
    //**************************************************************************

    // Color Key/Image Solid
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, GrTablePtr->CurrentColorKey->Color);

    // Clip/Black Rectangle (ALWAYS write MIN values before MAX values!!)
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, GrTablePtr->CurrentClip->xClipMin);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, GrTablePtr->CurrentClip->yClipMin);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, GrTablePtr->CurrentClip->xClipMax);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, GrTablePtr->CurrentClip->yClipMax);

    // Always use the USER clip rects
    XYLogicMisc1=0;
    XYLogicMisc1 |= (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);

    // Pattern
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_0, GrTablePtr->CurrentPattern->PattColor0);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_1, GrTablePtr->CurrentPattern->PattColor0Alpha);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_0, GrTablePtr->CurrentPattern->PattColor1);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_1, GrTablePtr->CurrentPattern->PattColor1Alpha);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(0), GrTablePtr->CurrentPattern->Pattern0);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(1), GrTablePtr->CurrentPattern->Pattern1);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN_SHAPE, GrTablePtr->CurrentPattern->PatternShape);

    // Rop
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, GrTablePtr->CurrentRop->Rop3);

    // Beta and Plane Mask
////    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA, GrTablePtr->CurrentBeta->Beta);
////    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, GrTablePtr->CurrentPlaneMask->Color);

    //**************************************************************************
    // Reset context switch bits
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_EXCEPTIONS,0x00000000);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }


//******************************************************************************
//
//  Function:   InitColorFormatTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID InitColorFormatTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    HwDeviceExtension->ColorFormatTable[0] = 0x00000000;
    HwDeviceExtension->ColorFormatTable[1] = 0x00000001;
    HwDeviceExtension->ColorFormatTable[2] = 0x00000002;
    HwDeviceExtension->ColorFormatTable[3] = 0x00010000;
    HwDeviceExtension->ColorFormatTable[4] = 0x00010001;
    }



//******************************************************************************
//
//  Function:   SetObjectColorFormat()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectColorFormat(PHW_DEVICE_EXTENSION HwDeviceExtension,
                          PCOMMONOBJECT Pobject, ULONG UserColorFormat,
                          ULONG MonoFormat)

    {
    ULONG AdjustedColor;
    ULONG i;

    //**************************************************************************
    // This function is used to convert the user specified color format
    // into the hardware context field
    //**************************************************************************

    //**************************************************************************
    // Mask off 2 bits. (Don't accept monochrome formats)
    //**************************************************************************

    AdjustedColor = (UserColorFormat & ~0x01100000);

    for (i=0; i < 5; i++)
        {
        if (AdjustedColor == HwDeviceExtension->ColorFormatTable[i])
            {
            Pobject->ColorFormat = DRF_NUM(_PGRAPH, _CTX_SWITCH,_COLOR_BUFFER,i);

            //******************************************************************
            // Determine if we need to set the ALPHA bit for this color format
            //******************************************************************

            if (UserColorFormat & 0x00100000)
                Pobject->ColorFormat |= DRF_DEF(_PGRAPH,_CTX_SWITCH,_ALPHA,_ENABLED);
            }
        }

    //**************************************************************************
    // Set the MonoFormat bit (either 0 or 1)
    //**************************************************************************

    Pobject->MonoFormat = MonoFormat;

    }


//******************************************************************************
//
//  Function:   ClearPatchContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearPatchContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PPATCHCONTEXT PatchContext)

    {
    ULONG i;

    //**************************************************************************
    // Initialize context configuration.
    //**************************************************************************

    PatchContext->ImageConfig  = DRF_NUM(_PGRAPH, _CTX_SWITCH, _PATCH_CONFIG, 0x17);
    PatchContext->VideoConfig  = (ULONG)NULL;
//    PatchContext->ImageVideo   = NULL;
//    PatchContext->Canvas       = NULL;
//    PatchContext->Rop          = NULL;
//    PatchContext->RopPat       = NULL;
//    PatchContext->RopDst       = NULL;
//    PatchContext->Beta         = NULL;
//    PatchContext->BetaSrc      = NULL;
//    PatchContext->BetaPat      = NULL;
//    PatchContext->BetaDst      = NULL;
//    PatchContext->ColorKey     = NULL;
//    PatchContext->PlaneMask    = NULL;
//    PatchContext->PlaneMaskDst = NULL;
//    PatchContext->Clip         = NULL;
//    PatchContext->Pattern      = NULL;
//    PatchContext->ColorMap0    = NULL;
//    PatchContext->ColorMap1    = NULL;
//    PatchContext->VideoSwitch  = NULL;

    }

//******************************************************************************
//
//  Function:   NV1SetupPatches()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetupPatches(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;

    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Reset interrupt registers
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0, 0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_1, 0x11111111);

    //**************************************************************************
    // Init the PatchContexts to NULL for all the patches that we'll be using
    //**************************************************************************

    for (PatchCount=0; PatchCount < NUM_PATCHES; PatchCount++)
       {

       //***********************************************************************
       // Get the RENDER object structure that will be used for this patch
       //***********************************************************************

       PObject = &(HwDeviceExtension->RenderObject[PatchCount]);

       //***********************************************************************
       // Initialize the patch context values
       //***********************************************************************

       ClearPatchContext(HwDeviceExtension, &(PObject->RCPatchContext));

       }



    //**************************************************************************
    // Set the color format according to what the current mode depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Default mono format is 0 and ALPHA NOT enabled
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;

    //**************************************************************************
    // Now setup the individual patches that we'll be using for
    // the NT Display driver
    //**************************************************************************

RECTANGLE:

    //**************************************************************************
    // Set Patch for RECTANGLE
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, RECTANGLE_PATCH);

    //**************************************************************************
    // Setup the Render object (MY_RENDER_SOLID_RECTANGLE)
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension, RECTANGLE_SUBCHANNEL, RECTANGLE_PATCH,
                      NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
                      ColorFormat,MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;


TRIANGLE:

    //**************************************************************************
    // Since we've only got 8 subchannels, we don't have enough room for the
    // TRIANGLE object.  If we need it use it later (i.e. Direct 3D/OpenGL), we'll need
    // to manually swap out one of the current objects and load the TRIANGLE object
    //**************************************************************************


//    //**************************************************************************
//    // Set Patch for TRIANGLE
//    //**************************************************************************
//
//    SetPatchContext(HwDeviceExtension, TRIANGLE_PATCH);
//
//    //**************************************************************************
//    // Setup the Render object (MY_RENDER_SOLID_TRIANGLE)
//    //**************************************************************************
//
//    MonoFormat = MONO_FORMAT_LE;
//    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//                      ColorFormat,MonoFormat);
//
//    //**************************************************************************
//    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//    //**************************************************************************
//
//    GR_DONE;
//    GR_IDLE;


BLIT:

    //**************************************************************************
    // Set Patch for BLIT
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, BLIT_PATCH);

    //**************************************************************************
    // Setup the BLIT object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,BLIT_SUBCHANNEL,BLIT_PATCH ,
                      NV_IMAGE_BLIT, MY_RENDER_SCRN_TO_SCRN_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;


CPU_TO_SCREEN_BLIT:

    //**************************************************************************
    // Set Patch for IMAGE FROM CPU
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, IMAGE_FROM_CPU_PATCH);

    //**************************************************************************
    // Setup the IMAGE_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,IMAGE_FROM_CPU_SUBCHANNEL,IMAGE_FROM_CPU_PATCH,
                      NV_IMAGE_FROM_CPU, MY_IMAGE_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;



IMAGE_MONO_BLIT:

    //**************************************************************************
    // For text, we want color 0 (background) to be transparent
    // So set the color format appropriately with ALPHA channel enabled
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X16A1R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X16A8Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        }

    //**************************************************************************
    // Set Patch for IMAGE MONO FROM CPU
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, IMAGE_MONO_FROM_CPU_PATCH);

    //**************************************************************************
    // Setup the IMAGE_MONO_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_CGA6;
    SetupRenderObject(HwDeviceExtension,IMAGE_MONO_FROM_CPU_SUBCHANNEL,IMAGE_MONO_FROM_CPU_PATCH,
                      NV_IMAGE_MONOCHROME_FROM_CPU, MY_IMAGE_MONO_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;



    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));

    }




//******************************************************************************
//
//  Function:   SetupRenderObject()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetupRenderObject(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       ULONG SubChannel, ULONG PatchID,
                       ULONG RenderObjectClass, ULONG UserObjectName,
                       ULONG ColorFormat, ULONG MonoFormat)

    {
    PCOMMONOBJECT PObject;
    ULONG Class;
    ULONG Instance;
    ULONG Data;

    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to access graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Get a ptr to the RENDER object structure (Source Object)
    //**************************************************************************

    PObject = (PCOMMONOBJECT) &(HwDeviceExtension->RenderObject[PatchID]);

    //**************************************************************************
    // Save the user specified name of the object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    PObject->Base.Name = UserObjectName;
    HwDeviceExtension->FifoTable.ObjectStack[SubChannel] = UserObjectName;

    //**************************************************************************
    // Set Color format of the RENDER object
    //**************************************************************************

    SetObjectColorFormat(HwDeviceExtension,PObject,ColorFormat,MonoFormat);

    //**************************************************************************
    // After updating non-rendering objects and their contexts,
    // we now need to calculate the context for the the RENDER object.
    //
    // A Simple Patch:
    //
    //      RENDER SOLID  ----->  IMAGE TO  ------>  VIDEO SINK
    //        RECTANGLE             VIDEO
    //
    //**************************************************************************

    CalculateRenderObjectContext(HwDeviceExtension,(PRENDEROBJECT)PObject,RenderObjectClass);

    //**************************************************************************
    // CAREFUL!
    //
    // 1) When setting Device specific CTX_SWITCH registers,
    //    an INTERRUPT is generated.  So to avoid this,
    //    DISABLE interrupts when setting these registers !!
    //
    //     - Update-> The reason why interrupts were being generated
    //                is because the PATCH_ID switch was getting SET
    //                in the CTX_SWITCH register.  This is ok for Resource
    //                Manager code which handles interrupts, but here in this
    //                Miniport, we're doing a ONE TIME init of all the objects
    //                and don't want interrupts.  Disabling/Enabling
    //                interrupts around the USER_xxx_CTX_SWITCH registers
    //                is no longer necessary.  Oh Yeah!
    //
    // 2) If the object changed or is NEW, we need to set the device's
    //    OWN context switch register (as opposed to PGRAPH_CTX_SWITCH)
    //    First determine the device, then load the instance in the specific
    //    device's CTX_SWITCH register.  However, be aware that this WILL CLEAR
    //    FLOWTHRU !!! We need to make sure and re-enable it. Otherwise,
    //    subsequent functions which touch graphics registers may not work correctly.
    //
    // 2)  Also, the CTX_SWITCH register MUST be set BEFORE we call
    //     UpdateRenderObjectContext().  Otherwise, the graphics engine
    //     will stop when rendering the object.  I'm not sure I understand
    //     why this is, but for now, just make sure it occurs BEFORE, not AFTER.
    //
    //**************************************************************************

//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x00000000);

    //**************************************************************************
    // Get the physical instance from the context (Bottom 16 bits)
    // We will always be using Channel 0 (Specified in the Upper bits)
    //**************************************************************************

    Instance = (PObject->Context) & 0x0000ffff;

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            break;
        case NV_RENDER_SOLID_LINE:
            break;
        case NV_RENDER_SOLID_LIN:
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            UTRI_REG_WR32(UTRI_Base, NV_UTRI_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            URECT_REG_WR32(URECT_Base, NV_URECT_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            break;
        case NV_IMAGE_BLIT:
            UBLIT_REG_WR32(UBLIT_Base, NV_UBLIT_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_IMAGE_FROM_CPU:
            UIMAGE_REG_WR32(UIMAGE_Base, NV_UIMAGE_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            UBITMAP_REG_WR32(UIMAGE_Base, NV_UBITMAP_CTX_SWITCH, (0 | Instance) );
            break;
        default:
            break;
        }

//    //*************************************************************************
//    // Now that we've set the device specific CTX_SWITCH register,
//    // re-enable interrupts
//    //*************************************************************************
//
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x11111111);

    //**************************************************************************
    // FLOWTHRU was cleared up above! Make sure and RE-enable it,
    // Otherwise, UpdateRenderObjectContext may not work correctly.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED));

    //**************************************************************************
    // Now store the context for the RENDER object
    //**************************************************************************

    UpdateRenderObjectContext(HwDeviceExtension, UserObjectName, SubChannel,
                              PObject->Context);

    //**************************************************************************
    // FifoResend may be useful for debugging later on (not yet tested)
    //**************************************************************************

//    FifoResend(HwDeviceExtension);

    //**************************************************************************
    // Determine the CLASS value to store in the PGRAPH_MISC register
    // See Appendix E of the Graphics Register reference
    //**************************************************************************

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            Class = 0x8;
            break;
        case NV_RENDER_SOLID_LINE:
            Class = 0x9;
            break;
        case NV_RENDER_SOLID_LIN:
            Class = 0xA;
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            Class = 0xB;
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            Class = 0xC;
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            Class = 0xD;
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            Class = 0xE;
            break;
        case NV_IMAGE_BLIT:
            Class = 0x10;       // UBLIT
            break;
        case NV_IMAGE_FROM_CPU:
            Class = 0x11;       // UIMAGE
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            Class = 0x12;       // UBITMAP
            break;
        default:
            Class = 8;      // Default to a Point
            break;
        }

    //**************************************************************************
    // Prepare to put this value in the GRAPHIC_MISC register, Bit position 12.
    //**************************************************************************

    Class = Class << 12;

    //**************************************************************************
    // We're done modifying the Graphics registers.
    // ReEnable the FIFO and DMA engines as well as
    // specify the CLASS of the object.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED)            |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            Class);

    //**************************************************************************
    // Enable CACHE1.  Do NOT enable CACHE0 (Why? Runout data present?).
    // Otherwise, the rendering functions will NOT work.
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_ENABLED);

    }


//******************************************************************************
//
//  Function:   ClearOutRenderObjects()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutRenderObjects(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG Length;
    ULONG ObjectCount;
    PULONG Ptr;

    //**************************************************************************
    // Get length of RENDER object structure (in Dwords)
    //**************************************************************************

    Length = sizeof(RENDEROBJECT)/4;

    //**************************************************************************
    // Fill render object memory with zeros
    //**************************************************************************

    for (ObjectCount=0; ObjectCount < 10; ObjectCount++)
        {
        Ptr = (PULONG)&(HwDeviceExtension->RenderObject[ObjectCount]);

        //**********************************************************************
        // Clear out one object
        //**********************************************************************

        for (i=0; i<Length; i++)
            {
            *Ptr = 0;
            Ptr++;
            }

        }

    }


//******************************************************************************
//
//  Function:   NV1GetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NV1GetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG DepthIndex;
    ULONG i,j;
    BOOLEAN status=TRUE;

    //**************************************************************************
    // Get ptr to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_REVISION);
    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_VRAM ? BUFFER_VRAM : BUFFER_DRAM;

    //**************************************************************************
    // Get amount of VRAM
    //**************************************************************************

    switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
        {
        case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
            NVInfo->Framebuffer.RamSizeMb = 4;
            NVInfo->Framebuffer.RamSize   = 0x00400000;
            break;
        case NV_PFB_BOOT_0_RAM_AMOUNT_2MB:
            NVInfo->Framebuffer.RamSizeMb = 2;
            NVInfo->Framebuffer.RamSize   = 0x00200000;
            break;
        case NV_PFB_BOOT_0_RAM_AMOUNT_1MB:
            NVInfo->Framebuffer.RamSizeMb = 1;
            NVInfo->Framebuffer.RamSize   = 0x00100000;
            break;
        default:
            //******************************************************************
            // Invalid memory configuration
            //******************************************************************
            status=FALSE;
            return(status);
        }

    //**************************************************************************
    // Don't forget to fixup the RangeOffset array.
    // NVIsPresent() put a default value (4Mb) for the length of the Dumb Frame Buffer..
    // Now that we know what the correct memory size is, let's make sure to
    // update the correct value.
    //**************************************************************************

    RangeOffsets[NV_PDFB_INDEX].ulLength =  NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
//    NVInfo->Pram.AvailableSize[0]         = NV_PRAM_DEVICE_SIZE_12_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[1]         = NV_PRAM_DEVICE_SIZE_20_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[2]         = NV_PRAM_DEVICE_SIZE_36_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[3]         = NV_PRAM_DEVICE_SIZE_68_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 0;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 4;
    else
        refresh = 5;

    //**************************************************************************
    // Get depth index into fbTimingTable
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
      {
      case 8:
         DepthIndex = 0;
         break;
      case 16:
         DepthIndex = 1;
         break;
      case 32:
         DepthIndex = 2;
         break;
      default:
         DepthIndex = 0;
         break;
     }

    //**************************************************************************
    // Init Timing Table
    //**************************************************************************

    NVInfo->Framebuffer.HorizFrontPorch = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][4];
    NVInfo->Framebuffer.HorizSyncWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][5];
    NVInfo->Framebuffer.HorizBackPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][6];
    NVInfo->Framebuffer.VertFrontPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][7];
    NVInfo->Framebuffer.VertSyncWidth   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][8];
    NVInfo->Framebuffer.VertBackPorch   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][9];
    NVInfo->Framebuffer.HSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][10];
    NVInfo->Framebuffer.VSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][11];
    NVInfo->Framebuffer.CSync           = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][12];
    NVInfo->Dac.VClk                    = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][13];
    NVInfo->Framebuffer.RefreshRate     = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][14];

    //**************************************************************************
    // TODO: Need to add code to check amount of memory required for
    //       HASH TABLE, PRAM, and INSTANCES.  If not enough, then need to
    //       downgrade resolution until there is enough.
    //**************************************************************************

    //**************************************************************************
    // Determine the DAC type
    //**************************************************************************

    switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0,_DAC_WIDTH))
        {
        case NV_PFB_BOOT_0_DAC_WIDTH_16_BIT:
            NVInfo->Dac.InputWidth = 16;
        case NV_PFB_BOOT_0_DAC_WIDTH_32_BIT:
            NVInfo->Dac.InputWidth = 32;
        case NV_PFB_BOOT_0_DAC_WIDTH_64_BIT:
            NVInfo->Dac.InputWidth = 64;
        }


    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    // The cursor registers actually get set in NVSetMode
    //**************************************************************************

    NVInfo->Dac.CursorType = NV1_DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0xff;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // Return success
    //**************************************************************************

    return(status);
    }


//******************************************************************************
//
//  Function:   NV1SetupGraphicsEngine()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetupGraphicsEngine(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    PHWINFO NVInfo;


    //**************************************************************************
    // Wait Graphics engine to be IDLE
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Get ptr to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Master Control Registers
    //
    //      - Enable all ENGINES
    //      - HARDWARE interrupts on PIN A were already init in ModeSet code
    //        (PMC_INTR_EN_0_INTA set to HARDWARE)
    //
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_ENABLE, 0xfff000ff);  // Reset Text, Graphics
    PMC_REG_WR32(PMC_Base, NV_PMC_ENABLE, 0xffffffff);  //   and Fifo Engines

    //**************************************************************************
    // We MUST make sure to initialize these register addresses to 0.
    // If we don't, the Graphics Engine may not work !
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_RUNOUT_PUT,_ADDRESS,0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_RUNOUT_GET,_ADDRESS,0);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);

    //**************************************************************************
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      Class = 0 to access graphics registers
    //
    // NOTE:
    //      Just about every GRAPHICS register requires FLOWTHRU to be enabled.
    //      (except for PGRAPH_INTR_0 and PGRAPH_MISC). So we need to be careful
    //      that it is enabled when we need it.  When setting CTX_SWITCH registers,
    //      this bit can become disabled.  So be careful!  WE don't currently
    //      implement a Resource Manager/ Interrupt handling. If these registers
    //      are accessed when FLOWTHRU is disabled, the graphics engine will probably
    //      STOP , waiting for someone (the Resource Manager) to fix the error
    //      condition. This may occur in the user's 'While control.free < N' loop.
    //      Also, make sure to init CLASS field to 0.  Class = 0 should be
    //      used to denote writes to the graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Reset state machine in graphics engine
    //**************************************************************************

    PGRAPH_REG_WR_DRF_DEF(PGRAPH_Base,_PGRAPH, _DEBUG_1, _VOLATILE_RESET, _LAST);
    PGRAPH_REG_WR_DRF_DEF(PGRAPH_Base,_PGRAPH, _DEBUG_0, _STATE, _RESET);

    //**************************************************************************
    // Deal with bug in chip.
    // Block write is only enabled under certain conditions
    // For now, we always enable it
    //**************************************************************************

//******************************************************************************
//    if ((pDev.Framebuffer.RamType == BUFFER_VRAM)
//      && ((((pDev.Framebuffer.RamSizeMb != 4) && (pDev.Framebuffer.Depth == 32))
//       || ((pDev.Framebuffer.RamSizeMb == 1) && (pDev.Framebuffer.Depth == 16)))))
//         pDev.Graphics.Debug0 &= ~DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK, _ENABLED);
//    else
//         pDev.Graphics.Debug0 |=  DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK, _ENABLED);
//******************************************************************************

    Data = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_0);
    Data |= DRF_DEF(_PGRAPH,_DEBUG_0,_BLOCK, _ENABLED);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0,Data);

//******************************************************************************
// Need to load these DEBUG registers appropriately.
// Otherwise, performance may be dog slow !!!!
// Currently, we assume REV_B !!!!!  (Not yet tested on other REVS)
//******************************************************************************


    NVInfo->Graphics.Debug0 = DRF_DEF(_PGRAPH, _DEBUG_0, _ALPHA_ABORT,     _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _EDGE_FILLING,    _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _WRITE_ONLY_ROPS, _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _NONBLOCK_BROAD,  _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK_BROAD,     _ENABLED) |
                             DRF_DEF(_PGRAPH,_DEBUG_0, _BLOCK, _ENABLED)            |
                             DRF_DEF(_PGRAPH,_DEBUG_0, _BULK_READS, _ENABLED);

//******************************************************************************
// Revision was already obtained in GetNVInfo during FindAdapter call
//******************************************************************************

    switch (NVInfo->Chip.Revision)
        {
        case NV1_REV_B_02:
        case NV1_REV_B_03:
            NVInfo->Graphics.Debug1 = DRF_DEF(_PGRAPH, _DEBUG_1, _HIRES_TM,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_BUS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TM_QUAD_HANDOFF, _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_RMW_BLITS,  _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _PATT_BLOCK,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TRI_OPTS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _BI_RECTS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY,    _IGNORE)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,  _NOT_LAST);
            NVInfo->Graphics.Debug2 = DRF_DEF(_PGRAPH, _DEBUG_2, _VOLATILE_RESET,  _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TM_FASTINPUT,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BUSY_PATIENCE,   _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TRAPEZOID_TEXEL, _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _MONO_ABORT,      _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BETA_ABORT,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _ALPHA_ABORT,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _AVOID_RMW_BLEND, _DISABLED);
            break;
        case NV1_REV_C_01:
        case NV1_REV_C_02:
            NVInfo->Graphics.Debug1 = DRF_DEF(_PGRAPH, _DEBUG_1, _HIRES_TM,           _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_BUS,           _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TM_QUAD_HANDOFF,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_RMW_BLITS,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _PATT_BLOCK,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TRI_OPTS,           _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _BI_RECTS,           _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY,       _IGNORE)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,     _NOT_LAST);
            NVInfo->Graphics.Debug2 = DRF_DEF(_PGRAPH, _DEBUG_2, _VOLATILE_RESET,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TM_FASTINPUT,       _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BUSY_PATIENCE,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TRAPEZOID_TEXEL,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _MONO_ABORT,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BETA_ABORT,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _ALPHA_ABORT,        _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _AVOID_RMW_BLEND,    _ENABLED);
            NVInfo->Graphics.Debug3 = DRF_DEF(_PGRAPH, _DEBUG_3, _TM_RANGE_INTERRUPT, _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _MONO_BLOCK,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE1,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE2,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE3,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE4,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE5,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE6,             _ENABLED);
            break;
        }


    //**************************************************************************
    // Set the DEBUG register appropriately
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0,NVInfo->Graphics.Debug0);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_1,NVInfo->Graphics.Debug1);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2,NVInfo->Graphics.Debug2);

//******************************************************************************
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0, pDev.Graphics.Debug0);
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_1, pDev.Graphics.Debug1);
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2, pDev.Graphics.Debug2);
//
//    Need to check revision of chip if need to write out this register
//    if ((pDev.Chip.Revision == NV1_REV_C_01) || (pDev.Chip.Revision == NV1_REV_C_02))
//       REG_WR32(NV_PGRAPH_DEBUG_3, pDev.Graphics.Debug3);
//
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2, pDev.Graphics.Debug2);
//******************************************************************************


    //**************************************************************************
    // Initialize DMA related instance registers to zero
    //**************************************************************************

    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_CHANNEL, NV_PDMA_GR_CHANNEL_ACCESS_DISABLED);
    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_INSTANCE, 0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DMA,0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_NOTIFY,0x00000000);
    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_CHANNEL,  NV_PDMA_GR_CHANNEL_ACCESS_ENABLED);

    //**************************************************************************
    // Init Context register for the first time
    // Instance is zero, and Channel is currently invalid
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_CTX_SWITCH,  0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_CTX_CONTROL, DRF_DEF (_PGRAPH,_CTX_CONTROL,_MINIMUM_TIME,_33US)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_TIME,_EXPIRED)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_CHID,_INVALID)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_SWITCHING,_IDLE)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_DEVICE,_ENABLED));

//******************************************************************************
// Update system canvas to current settings.  In order to include offscreen access
// system clients, calculate the canvas height based on the limit of buffer[0].
//******************************************************************************

//******************************************************************************
//    CanvasHeight = pDev.Framebuffer.Limit[0]
//                             / (pDev.Framebuffer.Depth / 8)
//                             / pDev.Framebuffer.HorizDisplayWidth;
//    if (CanvasHeight > 0x0FFF)
//        CanvasHeight = 0x0FFF;
//******************************************************************************

//******************************************************************************
// On NV1, 320x200, 320x240 and 512x384 modes aren't really accelerated by the
// hardware directly.  The canvas and clip width has to be set up for 640 pixels
// like the hardware.
//******************************************************************************

//******************************************************************************
//      switch (pDev.Framebuffer.Resolution)
//        {
//        case RESOLUTION_320X200:
//        case RESOLUTION_320X240:
//        case RESOLUTION_512X384:
//            CanvasWidth = pDev.Framebuffer.HorizDisplayWidth * 2;
//            break;
//        default:
//            CanvasWidth = pDev.Framebuffer.HorizDisplayWidth;
//            break;
//        }
//
//    grSysCanvas->xyMin    = PACK_XY(0, 0);
//    grSysCanvas->xyMax    = PACK_XY(CanvasWidth, CanvasHeight);
//
//
//    grSysCanvas->ClipMisc = 0;
//    for (i = 0; i <MAX_CLIP_REGIONS; i++)
//        {
//        grSysCanvas->xyClipMin[i] = PACK_XY(0, 0);
//        grSysCanvas->xyClipMax[i] = PACK_XY(CanvasWidth, CanvasHeight);
//        grSysCanvas->InOutClip[i] = 0;
//        }
//******************************************************************************

    //**************************************************************************
    // Init color format table
    //**************************************************************************

    InitColorFormatTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local Graphics Channel (GrTable) memory (We only use 1 channel)
    //**************************************************************************

    ClearOutGrTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local FIFO table structure (We only use 1 channel)
    //**************************************************************************

    ClearOutFifoTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local RENDEROBJECT structures (Currently allow up to 10 objects)
    //**************************************************************************

    ClearOutRenderObjects(HwDeviceExtension);

//    //*************************************************************************
//    // Clear out local local NVInfo structure
//    //*************************************************************************
//
//    ClearOutNVInfo(HwDeviceExtension);

    //**************************************************************************
    // Clear out hardware Cached Context registers and FIFO Context memory
    //**************************************************************************

    ClearOutContextMemoryAndRegisters(HwDeviceExtension);

    //**************************************************************************
    // Clear out hardware HASH TABLE memory and local hash table)
    //**************************************************************************

    ClearOutHashTables(HwDeviceExtension);

    //**************************************************************************
    // Init current channel 0 context.
    // Since we cleared out the Fifo table up above (FifoTable.InUse=INVALID),
    // an initial 'default' context will be loaded
    //**************************************************************************

    LoadChannelContext(HwDeviceExtension);

    //**************************************************************************
    // Reset ALL the interrupts that the Graphics Engine can generate.
    // Then enable all of them.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0,    0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x11111111);

    //**************************************************************************
    // The second graphics interrupt register is more information for the
    // first interrupt register.  Don't bother enabling it.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_1,    0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_1, 0x00000000);

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // ReEnable the FIFO and DMA engines.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //      Specify Class = 0 to access graphics registers
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED)            |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // The Graphics engine is now ready to be used!
    //**************************************************************************

    HwDeviceExtension->NvInfo.Graphics.Enabled = TRUE;


    }



//******************************************************************************
//
//  Function:   dacCalcPLL()
//
//  Routine Description:
//
//       Find closest DAC PLL parameters for a given frequency.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID dacCalcPClkVClkRatio(PHW_DEVICE_EXTENSION HwDeviceExtension )

    {
    PHWINFO pDev;

    pDev = &(HwDeviceExtension->NvInfo);

    //
    // changed calculation - 28 Nov 95 ibb
    // this is so that the p/v ratio is minimised especially for
    // certain customers who want to drive NTSC and thus want 25 MHz
    // out from the DAC, and not 12.5 MHz as is the case with p/v of 2.
    //
    if (pDev->Dac.VClk < 50000000)
      pDev->Dac.PClkVClkRatio = 1;
    else if (pDev->Dac.VClk < 100000000)
      pDev->Dac.PClkVClkRatio = 2;
    else if (pDev->Dac.VClk < 200000000)
      pDev->Dac.PClkVClkRatio = 4;
    else if (pDev->Dac.VClk < 400000000)
      pDev->Dac.PClkVClkRatio = 8;
    else // if (pDev->Dac.VClk < 800000000)
      pDev->Dac.PClkVClkRatio = 16;
    }

//******************************************************************************
//
//  Function:   dacCalcPLL()
//
//  Routine Description:
//
//       Find closest DAC PLL parameters for a given frequency.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID dacCalcPLL(PHW_DEVICE_EXTENSION HwDeviceExtension )


    {
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 O;
    U032 P;
    U032 MinN;
    U032 MaxN;

    PHWINFO pDev;

    //**************************************************************************
    // Get pointer to hardware information
    //**************************************************************************

    pDev = &(HwDeviceExtension->NvInfo);

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.VPllM = M;
                    pDev->Dac.VPllN = N;
                    pDev->Dac.VPllO = 1;
                    pDev->Dac.VPllP = P;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }

    }




//******************************************************************************
//
//  Function:   NV1SetMode()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID NV1SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )


    {
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG ulBase;

    ULONG OutData;
    UCHAR SaveMCLK[4];
    ULONG index;
    PHWINFO NVInfo;
    ULONG DepthIndex;
    ULONG Refresh;
    ULONG DACWidth;
    ULONG i;
    ULONG m,n,o,p;
    ULONG clock;

    //**************************************************************************
    //
    // NOTE: Currently, this setmode code does NOT contain all the smart detection
    //       that the Resource Manager contains (due to time constraints), as follows:
    //
    //          - DAC Pclk/VClk ratio calculations
    //          - PRAM size (currently set to 20kb)
    //          - Framebuffer count = 0 (no double buffering)
    //          - DRAM detection (only VRAM functionality is implemented)
    //
    //       When the rest of the display driver is completed, we may want to
    //       pull in the rest of this functionality from the Resource Manager code.
    //
    //**************************************************************************

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Fill frame buffer with data (testing purposes)
    //**************************************************************************

//    OutData=0xffffffff;
//    for (index=0;index < ((640*480*2)/4); index++)
//        {
//        VideoPortWriteRegisterBufferUlong(
//                ((PULONG)(HwDeviceExtension->VideoMemoryAddress)) + index,
//                &OutData,1);
//        }

    //**************************************************************************
    // Enable Hardware Interrupts, Disable Software interrupts
    //**************************************************************************

    PMC_REG_WR32( HwDeviceExtension->NV1_Lin_PMC_Registers, NV_PMC_INTR_EN_0, 0x1);

    //**************************************************************************
    // Turn off BIOS Fixups (code taken from RM)
    // BIOS Fixups were never applied anyway.
    //**************************************************************************

    PRM_REG_WR32( PRM_Base, NV_PRM_INTR_EN_0, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_TRACE, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_CONFIG_0, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_IGNORE_0, 0x33333333);
    PRM_REG_WR32( PRM_Base, NV_PRM_IGNORE_1, 0x33333333);

    //**************************************************************************
    // Restore MCLK to full speed for Windows
    // This involves restoring DAC registers.
    // Here, we just save them because so far, we have not turned off VGA mode
    // Even though we only write BYTES at a time to the DAC,
    // we must write DWORDS at a time to the NV interface.
    //**************************************************************************

    //**************************************************************************
    //  Set the clock speed
    //
    // The following switch statement let's us experiment with increasing
    // the clock speed of an NV1 card.  I've only been able to increase
    // the speed of a 2Mb VRAM card to 65Mhz, and the speed of a 4Mb VRAM card
    // to 60Mhz.  As the clock is increased beyond the spec'd speed of NV1 (50Mhz),
    // you'll notice more and more graphics being drawn incorrectly with garbage.
    // At a certain point, the card just won't work.  This is somewhat useful
    // for predicting how much performance will increase when increasing the
    // clock speed.  For now, just default to the standard 50Mhz.
    //**************************************************************************

    clock = 50;

    switch (clock)
        {
        case 30:
            m=7;
            n=139;
            o=1;
            p=4;
            break;
        case 40:
            m=12;
            n=159;
            o=1;
            p=2;
            break;
        case 50:
            m=11;
            n=91;
            o=1;
            p=1;
            break;
        case 60:
            m=7;
            n=139;
            o=1;
            p=2;
            break;
        case 65:
            m=12;
            n=129;
            o=1;
            p=1;
            break;
        case 70:
            m=12;
            n=139;
            o=1;
            p=1;
            break;
        default:
            m=11;
            n=91;
            o=1;
            p=1;
            break;
        }


    OutData=(SGS_DAC_MPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, m);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, n);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, o);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, p);



    OutData=(SGS_DAC_MPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[0] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[1] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[2] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[3] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Output the config register for RAM
    //
    // TO DO: Need to calculate this value in realtime!!
    //        For now, specify 20Kb
    //**************************************************************************

    NVInfo->Pram.ConfigReg = DRF_DEF(_PRAM,_CONFIG_0,_SIZE,_20KB);
    NVInfo->Pram.HashDepth = 4;
    NVInfo->Pram.RunOutMask = 0x0fff;
    NVInfo->Pram.CurrentSize = NV_PRAM_DEVICE_SIZE_20_KBYTES;

    //**************************************************************************
    // Setup the NV1 memory map
    //**************************************************************************

    NVInfo->Pram.HashTableAddr = DEVICE_BASE(NV_PRAMHT);
    NVInfo->Pram.FifoRunoutAddr = DEVICE_BASE(NV_PRAMRO);
    NVInfo->Pram.FifoContextAddr = DEVICE_BASE(NV_PRAMFC);
    NVInfo->Pram.AudioScratchAddr = DEVICE_BASE(NV_PRAMAU);
    NVInfo->Pram.AuthScratchAddr = DEVICE_BASE(NV_PRAMPW);

    //**************************************************************************
    // For now, just force VClk = 0, which will force PClkVClkRatio to be 1.
    // (There's a lot of code associated with calculating this ratio.  So for
    // now, we just default to 1.  May want to pull this code in later)
    //**************************************************************************

//    NVInfo->Dac.VClk = 0;
//    NVInfo->Dac.PClkVClkRatio = 1;

    //**************************************************************************
    //  For now, set count to zero (no double buffering for now)
    //
    //  For NV1, we want a completely flat and available dumb frame buffer.
    //  Enabling double buffering causes PRAMIN Instance memory to be
    //  split in two places (i.e. on a 2 Mb system, instance memory would occur
    //  at end of 1 Mb and at end of 2Mb)  This is fine for apps that use
    //  the VIDEO_SWITCH class and an RM, which alternates between two buffers.
    //  But the problem is that the Instance memory gets in the way when
    //  giving offscreen memory to Direct X.  So by DISABLING double buffering,
    //  we avoid this issue entirely. We can do this because 1) we're bypassing
    //  the NVidia patch architecture (for the most part) in this display driver
    //  that is...we're not using the VIDEO_SWITCH_CLASS to flip buffers, we flip
    //  buffers directly by going straight to the PFB_START_ADDRESS register. and
    //  2) We're not using Resource Manager.  This miniport does all the initialization
    //  that a Resource Manager normally would do.
    //
    //**************************************************************************

    NVInfo->Framebuffer.Count = 0;

    //**************************************************************************
    // Now get the appropriate values from the requested mode
    // and set them in the NVInfo structure
    //**************************************************************************

    switch (RequestedMode->Width)
       {
       case 1600:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1600X1200;
          break;
       case 1280:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1280X1024;
          break;
       case 1152:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1152X864;
          break;
       case 1024:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1024X768;
          break;
       case 800:
          NVInfo->Framebuffer.Resolution = RESOLUTION_800X600;
          break;
       case 640:
          NVInfo->Framebuffer.Resolution = RESOLUTION_640X480;
          break;
       default:
          NVInfo->Framebuffer.Resolution = RESOLUTION_640X480;
          break;
       }

    //**************************************************************************
    // Set the requested depth
    //**************************************************************************

    NVInfo->Framebuffer.Depth = RequestedMode->Depth;

    if (RequestedMode->Depth == 32)
       DepthIndex = 2;
    else if (RequestedMode->Depth == 16)
       DepthIndex = 1;
    else
       DepthIndex = 0;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (RequestedMode->RefreshRate < 72)
        Refresh = 0;
    else if (RequestedMode->RefreshRate < 75)
        Refresh = 1;
    else if (RequestedMode->RefreshRate < 85)
        Refresh = 2;
    else if (RequestedMode->RefreshRate < 100)
        Refresh = 3;
    else if (RequestedMode->RefreshRate < 120)
        Refresh = 4;
    else
        Refresh = 5;

    //**************************************************************************
    // Set the display resolution and monitor timings
    //**************************************************************************

    NVInfo->Framebuffer.HorizDisplayWidth = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][1];
    NVInfo->Framebuffer.VertDisplayWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][2];

    NVInfo->Framebuffer.HorizFrontPorch = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][4];
    NVInfo->Framebuffer.HorizSyncWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][5];
    NVInfo->Framebuffer.HorizBackPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][6];
    NVInfo->Framebuffer.VertFrontPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][7];
    NVInfo->Framebuffer.VertSyncWidth   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][8];
    NVInfo->Framebuffer.VertBackPorch   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][9];
    NVInfo->Framebuffer.HSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][10];
    NVInfo->Framebuffer.VSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][11];
    NVInfo->Framebuffer.CSync           = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][12];
    NVInfo->Dac.VClk                    = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][13];
    NVInfo->Framebuffer.RefreshRate     = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][14];

    //**************************************************************************
    // Now that NVInfo->Dac.Vclk is initialized, calculate
    // the PClkVclk ratio and PLL values as well
    //**************************************************************************

    dacCalcPLL(HwDeviceExtension );
    dacCalcPClkVClkRatio(HwDeviceExtension );

    //**************************************************************************
    // Set 20Kb always...  (20Kb set up above)
    //**************************************************************************

    PRAM_REG_WR32( PRAM_Base, NV_PRAM_CONFIG_0, NVInfo->Pram.ConfigReg);

    //**************************************************************************
    // Output the Frame Buffer control register
    // Start at address 0
    //**************************************************************************

    OutData = 0x00000000;
    PFB_REG_WR32( PFB_Base, NV_PFB_START, OutData);

    //**************************************************************************
    // Output the Frame Buffer config0 register
    //**************************************************************************

    switch (NVInfo->Framebuffer.Resolution)
    {
        case RESOLUTION_1600X1200:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1600_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1280X1024:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1280_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1152X864:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1152_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1024X768:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1024_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_800X600:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _800_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_640X480:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _640_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
    }

    //**************************************************************************
    //  For now, we don't enable a second buffer (Count = 0 always, set up above)
    //
    //  For NV1, we want a completely flat and available dumb frame buffer.
    //  Enabling double buffering causes PRAMIN Instance memory to be
    //  split in two places (i.e. on a 2 Mb system, instance memory would occur
    //  at end of 1 Mb and at end of 2Mb)  This is fine for apps that use
    //  the VIDEO_SWITCH class and an RM, which alternates between two buffers.
    //  But the problem is that the Instance memory gets in the way when
    //  giving offscreen memory to Direct X.  So by DISABLING double buffering,
    //  we avoid this issue entirely. We can do this because 1) we're bypassing
    //  the NVidia patch architecture (for the most part) in this display driver
    //  that is...we're not using the VIDEO_SWITCH_CLASS to flip buffers, we flip
    //  buffers directly by going straight to the PFB_START_ADDRESS register. and
    //  2) We're not using Resource Manager.  This miniport does all the initialization
    //  that a Resource Manager normally would do.
    //
    //**************************************************************************

    if (NVInfo->Framebuffer.Count == 2)
        NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _SECOND_BUFFER, _ENABLED);
    else
        NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _SECOND_BUFFER, _DISABLED);

    //**************************************************************************
    // PClkVClk Ratio is hard coded up above for now....
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _32_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 16 / NVInfo->Dac.PClkVClkRatio + 3);
            break;
        case 16:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _16_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 16 / NVInfo->Dac.PClkVClkRatio + 3);
            break;
        case 8:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _8_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 15 / NVInfo->Dac.PClkVClkRatio + 3);
        }

    //**************************************************************************
    // Page height was set to zero in GetNVInfo() - disabled
    //**************************************************************************

    NVInfo->Framebuffer.ConfigReg |= DRF_NUM(_PFB, _CONFIG_0, _PAGE_HEIGHT, NVInfo->Framebuffer.ConfigPageHeight);

    //**************************************************************************
    // Currently , PClkVClk Ratio is set to 1 up above...
    //**************************************************************************

    switch (NVInfo->Dac.PClkVClkRatio)
    {
        case 1:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _1_TO_1);
            break;
        case 2:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _2_TO_1);
            break;
        case 4:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _4_TO_1);
            break;
        case 8:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _8_TO_1);
            break;
        case 16:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _16_TO_1);
            break;
    }

    //**************************************************************************
    // No stereoscopic stuff..
    //**************************************************************************

    NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _STEREOSCOPIC, _DISABLED);

    //**************************************************************************
    // Finally output the ConfigReg value
    //**************************************************************************

    PFB_REG_WR32( PFB_Base, NV_PFB_CONFIG_0,NVInfo->Framebuffer.ConfigReg );


    //**************************************************************************
    // Set LOW_MARK for VRAM type adapters only
    //...May want to pull in the DRAM code later!!!!
    //**************************************************************************

    OutData = (NV_PFB_CONFIG_1_FIFO_LOW_MARK_512_BITS);
    PFB_REG_WR32( HwDeviceExtension->NV1_Lin_PFB_Registers, NV_PFB_CONFIG_1, OutData);

    //**************************************************************************
    // Output for Monitor timings/Framebuffer display registers
    //**************************************************************************

    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_FRNT_PORCH,NVInfo->Framebuffer.HorizFrontPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_SYNC_WIDTH,NVInfo->Framebuffer.HorizSyncWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_BACK_PORCH,NVInfo->Framebuffer.HorizBackPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_DISP_WIDTH,NVInfo->Framebuffer.HorizDisplayWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_FRNT_PORCH,NVInfo->Framebuffer.VertFrontPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_SYNC_WIDTH,NVInfo->Framebuffer.VertSyncWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_BACK_PORCH,NVInfo->Framebuffer.VertBackPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_DISP_WIDTH,NVInfo->Framebuffer.VertDisplayWidth);

    //**************************************************************************
    // DAC Load Width/Depth
    //**************************************************************************

    OutData=(SGS_DAC_CONFIG_0 & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);


    OutData=((SGS_DAC_CONFIG_0>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    //**************************************************************************
    // Determine the DAC Width first...
    //**************************************************************************

    DACWidth = PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0,_DAC_WIDTH);

    switch (DACWidth)
        {
        case NV_PFB_BOOT_0_DAC_WIDTH_16_BIT:
            NVInfo->Dac.InputWidth =16;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_16BIT << 2) ;
            break;
        case NV_PFB_BOOT_0_DAC_WIDTH_32_BIT:
            NVInfo->Dac.InputWidth =32;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_32BIT << 2) ;
            break;
        case NV_PFB_BOOT_0_DAC_WIDTH_64_BIT:
            NVInfo->Dac.InputWidth =64;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_64BIT << 2) ;
            break;
        }

    //**************************************************************************
    // Then set the pixel depth appropriately
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 8:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_8BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_INDEX << 6);
            break;
        case 16:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_16BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR << 6);
            break;
        case 32:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_32BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR <<6);
            break;
        }

    //**************************************************************************
    // Set DAC_CONFIG_0 register
    //**************************************************************************

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // DAC Load PCLK/VCLK ratio
    //**************************************************************************

    OutData=(SGS_DAC_CONFIG_1 & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CONFIG_1>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    //**************************************************************************
    // Currently , PClkVClk Ratio is set to 1 up above...
    //**************************************************************************

    switch (NVInfo->Dac.PClkVClkRatio)
    {
        case 1:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_1 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 2:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_2 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 4:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_4 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 8:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_8 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 16:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_16 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
    }

    PDAC_REG_WR32(PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Prepare to output green power down level register
    //**************************************************************************

    if (NVInfo->Framebuffer.HSyncPolarity)
        OutData = DRF_DEF(_PFB,_GREEN_0,_POLAR_HSYNC,_POSITIVE);
    else
        OutData = DRF_DEF(_PFB,_GREEN_0,_POLAR_HSYNC,_NEGATIVE);

    if (NVInfo->Framebuffer.VSyncPolarity)
        OutData |= DRF_DEF(_PFB,_GREEN_0,_POLAR_VSYNC,_POSITIVE);
    else
        OutData |= DRF_DEF(_PFB,_GREEN_0,_POLAR_VSYNC,_NEGATIVE);

    if (NVInfo->Framebuffer.CSync)
        OutData |= DRF_DEF(_PFB,_GREEN_0,_CSYNC,_ENABLED);
    else
        OutData |= DRF_DEF(_PFB,_GREEN_0,_CSYNC,_DISABLED);

    //**************************************************************************
    // Make sure video is re-enabled
    //**************************************************************************

    OutData |= DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED);

    //**************************************************************************
    // Green register
    //**************************************************************************

    PFB_REG_WR32( PFB_Base, NV_PFB_GREEN_0, OutData);

    //**************************************************************************
    // Pixel Mask Register
    //**************************************************************************

    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_PIXEL_MASK, OutData);


    //**************************************************************************
    // DAC PLL values
    //**************************************************************************

    OutData=(SGS_DAC_VPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllM;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllN;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllO;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllP;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Init palette registers (for 8bpp modes only)
    //**************************************************************************

    if (NVInfo->Framebuffer.Depth == 8)
        NV1_InitPalette(HwDeviceExtension);


    //**************************************************************************
    // Init hardware cursor
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR_XOR;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 1
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_1_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_1_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_1_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 2
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_2_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_2_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_2_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 3
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_3_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_3_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_3_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor image plane 0
    //**************************************************************************

// Someone already loaded a cursor image?? BIOS?
//    OutData=(SGS_DAC_CURSOR_PLANE_0_WRITE_0 & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
//
//    OutData=((SGS_DAC_CURSOR_PLANE_0_WRITE_0>>8) & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
//
//    for (i=0;i<128;i++)
//        {
//        OutData = NVInfo->Dac.CursorImagePlane[0][i];
//        PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
//        }
//
//    //**************************************************************************
//    // Set cursor image plane 1
//    //**************************************************************************
//
//    OutData=(SGS_DAC_CURSOR_PLANE_1_WRITE_0 & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
//
//    OutData=((SGS_DAC_CURSOR_PLANE_1_WRITE_0>>8) & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
//
//    for (i=0;i<128;i++)
//        {
//        OutData = NVInfo->Dac.CursorImagePlane[1][i];
//        PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
//        }

    //**************************************************************************
    // Set cursor position
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_X_LO & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_POS_X_LO>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData=512;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData>>8);


    OutData=(SGS_DAC_CURSOR_POS_Y_LO & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_POS_Y_LO>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData=384;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData>>8);


    //**************************************************************************
    // Set palette register (DAC State Writable)?
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);


    //**************************************************************************
    // DAC Power Management values
    //**************************************************************************

    OutData=(SGS_DAC_POWER_MGMNT_A & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_A>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x88;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_POWER_MGMNT_B & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_B>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_POWER_MGMNT_C & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_C>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VBLANK_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VBLANK_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Disable SERR
    //**************************************************************************

    OutData = PBUS_REG_RD32( HwDeviceExtension->NV1_Lin_PBUS_Registers, NV_PBUS_PCI_NV_1);
    OutData = (OutData & (~0x00000100));    // SERR DISABLED ???  Why?
    PBUS_REG_WR32( HwDeviceExtension->NV1_Lin_PBUS_Registers, NV_PBUS_PCI_NV_1, OutData);

    //**************************************************************************
    // Enable HARDWARE interrupts throught Pin 1 (A)
    // Enable INTA_Hardware interrupts, NO SOFTWARE Interrupts allowed
    //**************************************************************************

    OutData = 0x1;
    PMC_REG_WR32( HwDeviceExtension->NV1_Lin_PMC_Registers, NV_PMC_INTR_EN_0, OutData);

    } // end NV1SetMode()


//******************************************************************************
//
//  Function:   SetObjectCachedCtxRegs()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectCachedCtxRegs(PHW_DEVICE_EXTENSION HwDeviceExtension,
                            ULONG CurrentSubChannel, ULONG ObjectName, ULONG NewContext)


    {
    ULONG SubChannelCount;

    //**************************************************************************
    // Update object's context in FIFO's cached context registers
    //**************************************************************************

    for (SubChannelCount = 0; SubChannelCount < 8; SubChannelCount++)
        {
        if (HwDeviceExtension->FifoTable.ObjectStack[SubChannelCount] == ObjectName )
            {
            PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(SubChannelCount),NewContext);

            //******************************************************************
            // If this is the current subchannel, tell engine the context
            // has been dirtied and needs to be updated
            // We shouldn't have to specify the SubChannel here because
            // that's done by hardware automatically, when we write out
            // the method???(Verify)
            //******************************************************************

            if (SubChannelCount == CurrentSubChannel)
                {
                PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_CTX,_DIRTY);

                //**************************************************************
                // This should be CHANGED so that object swapping works !!!!!
                //**************************************************************

                PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_OBJECT,_CHANGED);

                }

            }

        }

    }



//******************************************************************************
//
//  Function:   SetObjectHash()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectHash(PHW_DEVICE_EXTENSION HwDeviceExtension,
                    ULONG ObjectName, ULONG Context)


    {
    ULONG   HashValue;
    ULONG   HashEntry;
    ULONG   i;
    ULONG  *HashTablePtr;


    //**************************************************************************
    // Get ptr to array of hashed objects (object names)
    //**************************************************************************

    HashTablePtr = &(HwDeviceExtension->HashTable[0]);

    //**************************************************************************
    // Get hash value for this object in channel 0
    //**************************************************************************

    HashValue = FIFO_HASH(ObjectName,0);

    //**************************************************************************
    // Find first empty entry (FOR NOW WE ASSUME HASH_DEPTH = 4) UPDATE !!!!!!!
    //**************************************************************************

    for (i=0; i<HASH_DEPTH; i++)
        {
        HashEntry = HASH_ENTRY(HashValue,i);

        //**********************************************************************
        // Need to multiply HashEntry by 2 because HashEntry is only an index
        // from 0 - 255.  That is, when searching through the hash table, each
        // object context takes up 8 bytes.  However, C compiler will already
        // convert address into a ULONG address.  So end result is:
        //  HashEntry (aligned on 8 byte bndry) =  HashTablePtr + (HashEntry*4) *2.
        //**********************************************************************

        if ( *(HashTablePtr+HashEntry*2) == (ULONG)NULL)
            break;

        //**********************************************************************
        // If Object already exists, then use this SAME entry.
        //**********************************************************************

        if ( *(HashTablePtr+HashEntry*2) == ObjectName)
            break;

        }

    //**************************************************************************
    // If we did not find an empty entry, choose one randomly (use 2 for now)
    //**************************************************************************

    if (i == HASH_DEPTH)
        HashEntry = HASH_ENTRY(HashValue,2);

    //**************************************************************************
    // Add object to our local hash table array
    //**************************************************************************

    *(HashTablePtr+HashEntry*2) = ObjectName;

    //**************************************************************************
    // Set object name in hardware HASH table memory
    //**************************************************************************

    PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT) + HashEntry*8, ObjectName);

    //**************************************************************************
    // Set object context in hardware HASH table memory
    // No lie, using channel 0
    //**************************************************************************

    PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT) + HashEntry*8+4,Context & 0x00ffffff);
    }


//******************************************************************************
//
//  Function:   FifoResend()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID FifoResend(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    ULONG Method;
    ULONG caches, push0, pull0;

    //**************************************************************************
    // THIS FUNCTION HAS NOT YET BEEN TESTED
    //**************************************************************************

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable CACHE first
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Resend Data
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_GET,0x00000000);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_PUT,0x00000004);

    //**************************************************************************
    // Channel 0
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_PUSH1, 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_CTX(0), 0);

    //**************************************************************************
    // Wait for it to drain
    //**************************************************************************

    while (PFIFO_REG_RD_DRF(PFIFO_Base,_PFIFO,_CACHE0_STATUS,_LOW_MARK) ==
                                                NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY)
        {
        if (PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_INTR_0) &  0x11111011)
            VideoDebugPrint((1, "Error - FifoResend."));  /// oooopppssss
        }

    //**************************************************************************
    // Disable CACHE0
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL0,_ACCESS, _DISABLED);

    //**************************************************************************
    // Re-Enable CACHE1
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_ENABLED);


    }

//******************************************************************************
//
//  Function:   ClearOutGrTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutGrTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PGRAPHICSCHANNEL Ptr;

    //**************************************************************************
    // Get ptr to our Graphics Channel
    //**************************************************************************

    Ptr = (PGRAPHICSCHANNEL) &(HwDeviceExtension->GrTable);

    Ptr->NotifyObject       = NULL;
    Ptr->Notify             = (ULONG)NULL;
    Ptr->CurrentRop         = NULL;
    Ptr->CurrentBeta        = NULL;
    Ptr->CurrentColorKey    = NULL;
    Ptr->CurrentPlaneMask   = NULL;
    Ptr->CurrentClip        = NULL;
    Ptr->CurrentPattern     = NULL;
    Ptr->CurrentPatch       = NULL;
    Ptr->PatchList          = NULL;
    Ptr->PatchCount         = (ULONG)NULL;
    Ptr->Exceptions         = (ULONG)NULL;
    }

//******************************************************************************
//
//  Function:   ClearOutFifoTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutFifoTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    PFIFO Ptr;

    //**************************************************************************
    // Get ptr to our FIFO structure
    //**************************************************************************

    Ptr = (PFIFO) &(HwDeviceExtension->FifoTable);

    //**************************************************************************
    // Initialize FIFO table structure
    //**************************************************************************

    Ptr->InUse = INVALID;
    Ptr->ChID = INVALID;                    // We will always use channel 0 (for now)
    Ptr->ObjectCount = 0;                   // No objects loaded yet

    //**************************************************************************
    // Clear out the objects
    //**************************************************************************

    for (i=0; i<NUM_SUBCHANNELS; i++)
        Ptr->ObjectStack[i] = (ULONG)NULL;  // 0 means not used

    }



//******************************************************************************
//
//  Function:   ClearOutNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG Length;
    PULONG Ptr;

    //**************************************************************************
    // Get length of HWINFO object structure (in Dwords)
    //**************************************************************************

    Length = sizeof(HWINFO)/4;

    //**************************************************************************
    // Get Ptr to NVInfo structure and fill it with zeros
    //**************************************************************************

    Ptr = (PULONG)&(HwDeviceExtension->NvInfo);

    for (i=0; i<Length; i++)
            {
            *Ptr = 0;
            Ptr++;
            }


    }


//******************************************************************************
//
//  Function:   ClearOutHashTables()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutHashTables(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG caches, push0, pull0;

    //**************************************************************************
    // Save FIFO cache1 state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable CACHE1 first
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

   //***************************************************************************
    // Clear out local hash table with zeros (currently 1k worth)
    //**************************************************************************

    for (i=0; i < 256 * HASH_DEPTH; i++)
        HwDeviceExtension->HashTable[i] = 0;

    //**************************************************************************
    // Clear out hash virtual registers ( 128 of these , one per channel ?)
    // When the Hash Engine looks thru Hash Table memory and it finds
    // an entry that matches the one in the virtual register, then
    // the physical information about the object will be written to
    // the corresponding hash physical register.  Otherwise, zero will be written
    //      -------------------------------------------------------------
    //  n  |                   Object Handle                             |
    //      -------------------------------------------------------------
    //**************************************************************************

    for (i=0; i < 128  ; i++)
        PRAM_REG_WR32(PRAM_Base,NV_PRAM_HASH_VIRTUAL(i),0 );


    //**************************************************************************
    // Clear out hardware hash memory (current 8K worth)
    // There are 256 structures, each containing 4 entries which are each 8 bytes
    // For NV1 (currently), memory_size = 256 * HASH_DEPTH * 8 = 8k
    //      --------------------------------------------------------------
    //     |                    Object Handle                             |
    //  n   --------------------------------------------------------------
    //     | Channel ID       Phys Device Address   Phys Instance Address |
    //      --------------------------------------------------------------
    //**************************************************************************

    for (i=0; i < (256 * HASH_DEPTH * 8) ; i+=8) // Advance 8 bytes each time
        {
        PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT)+i,0 );
        PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT)+i+4,0 );
        }

    //**************************************************************************
    // Restore saved FIFO cache1 state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }

//******************************************************************************
//
//  Function:   ClearOutContextMemoryAndRegisters()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutContextMemoryAndRegisters(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG CurrentChID;
    ULONG Data;
    ULONG CurrentInstance;
    ULONG InitContextPtr;
    ULONG ContextPtr;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Tell Cache1 to use Channel 0
    //**************************************************************************

    CurrentChID=0;
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUSH1,_CHID, CurrentChID);

    //**************************************************************************
    // Clean out FIFO CONTEXT memory
    // Currently, There are a 128 total possible channels, each channel
    // contains 8 contexts, each 4 bytes.  Memory_size = 128 * 8 * 4;
    // However, since we are only using channel 0, just clear out channel 0.
    //**************************************************************************

    CurrentChID=0;
    InitContextPtr = DEVICE_BASE(NV_PRAMFC) + (CurrentChID*32) ;
    for (ContextPtr=InitContextPtr; ContextPtr < (InitContextPtr + 32); ContextPtr+=4)
        PRAMFC_REG_WR32(PRAMFC_Base, ContextPtr , 0);

    //**************************************************************************
    // Initialize Cache1 to use subchannel zero
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_SUBCHANNEL,0);

    //**************************************************************************
    // Set PUT and GET pointers to address 0
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUT,_ADDRESS,0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_GET,_ADDRESS,0);

    //**************************************************************************
    // Clear out CACHED CONTEXT registers
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_CTX(0), 0);

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(0), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(1), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(2), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(3), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(4), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(5), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(6), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(7), 0);

    //**************************************************************************
    // Check if Context has changed.
    // (Make sure that Chroma, Beta, Plane_Mask, UserClip, Alpha,
    // and Mono have not changed).
    // For now, we FORCE context to be loaded up above, so it should be the same..
    //**************************************************************************

//    Data = PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_CTX_SWITCH);
//    CurrentInstance = DRF_VAL(_PGRAPH,_CTX_SWITCH,_INSTANCE,Data);
//
//    if ( (CurrentContext & 0xffff) != CurrentInstance)
//            ASSERTDD(FALSE, "ClearOutContextMemory.");  /// oooopppssss

    //**************************************************************************
    // Make sure that channel is the same
    //**************************************************************************

//    CurrentChID = PGRAPH_REG_RD_DRF(PGRAPH_Base,_PGRAPH,_MISC,_CLASS);
//    if (CurrentChID != ((CurrentContext >> 16) & 0x7f))
//        {
//          ASSERTDD(FALSE, "ClearOutContextMemory.");  /// oooopppssss
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_CHANGED);
//        }

    //**************************************************************************
    // Check object_changed bit for CACHE1
    // Set CACHE0 bit to have same value.
    //**************************************************************************

//    Data = PFIFO_REG_RD32(PFIFO_Base,NV_PFIFO_CACHE1_PULL1);
//
//    if (Data)
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_CHANGED);
//    else
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_UNCHANGED);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }


//******************************************************************************
//
//  Function:   LoadChannelContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID LoadChannelContext(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    ULONG Result;
    ULONG CurrentInstance;
    ULONG SavedGraphicsState;
    ULONG CurrentChID;
    ULONG caches;
    ULONG cache0push0;
    ULONG cache0pull0;
    ULONG cache1push0;
    ULONG cache1pull0;
    ULONG XYLogicMisc1;
    PGRAPHICSCHANNEL GrTablePtr;
    ULONG i;

    //**************************************************************************
    // Get pointer to graphics channel
    //**************************************************************************

    GrTablePtr = &(HwDeviceExtension->GrTable);

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache0push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE0_PUSH0);
    cache0pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE0_PULL0);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Force Cache 0 and Cache 1 to be set for channel 0
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE0_PUSH1,_CHID, 0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUSH1,_CHID, 0);

    //**************************************************************************
    // Default Cache 1 to be set for subchannel 0 also.
    // Signal that the object is DIRTY and the object has CHANGED
    // since we haven't loaded it yet.  We don't bother setting
    // the subchannel for Cache0 because that's mainly used by the Resource Mgr.
    // Make sure the subsequent macros are the FLD type, to preserve what's
    // currently in the register.
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_SUBCHANNEL, 0);
    PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_CTX,_DIRTY);
    PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_OBJECT,_CHANGED);

    //**************************************************************************
    // Check for any outstanding graphics exceptions
    //**************************************************************************
//
//    while (PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_INTR_0) & 0x11111011)
//        ASSERTDD(FALSE, "LoadChannelContext.");      // Uh oh....shouldn't happen

    //**************************************************************************
    // Reset graphics state engine.  I'm not sure if this is necessary?
    // but I'm including it because the Resource Manager uses it.
    //**************************************************************************

    if (PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_DEBUG_1) & 0x01)
        PGRAPH_FLD_WR_DRF_DEF(PGRAPH_Base,_PGRAPH,_DEBUG_0,_STATE,_NORMAL);


    //**************************************************************************
    // Init Context Control register for the first time
    // Instance is zero, and Channel is currently invalid
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CTX_CONTROL,
                               DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _2MS)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));


    //**************************************************************************
    // Note: I'm skipping the grTextureFixup() call because
    //       we won't be using textures at this point.
    //**************************************************************************

    //**************************************************************************
    // Init Static State to Default value first, just to be safe. Necessary?
    // ROP, Beta, ColorKey, PlaneMask, Clip, and Pattern
    //**************************************************************************

//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, 0xcc);     // Source Copy
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA,0x07f8 );
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, 0);
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, 0);

    //**************************************************************************
    // Load STATIC STATE as follows:
    // ROP, Beta, ColorKey, PlaneMask, Clip, and Pattern
    //**************************************************************************

    if (GrTablePtr->CurrentRop)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, GrTablePtr->CurrentRop->Rop3);

    if (GrTablePtr->CurrentBeta)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA, GrTablePtr->CurrentBeta->Beta);

    if (GrTablePtr->CurrentClip)
        {
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, GrTablePtr->CurrentClip->xClipMin);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, GrTablePtr->CurrentClip->yClipMin);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, GrTablePtr->CurrentClip->xClipMax);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, GrTablePtr->CurrentClip->yClipMax);
        XYLogicMisc1 = (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);


        }

    if (GrTablePtr->CurrentPlaneMask)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, GrTablePtr->CurrentPlaneMask->Color);

    if (GrTablePtr->CurrentColorKey)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, GrTablePtr->CurrentColorKey->Color);

    if (GrTablePtr->CurrentPattern)
        {
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_0, GrTablePtr->CurrentPattern->PattColor0);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_1, GrTablePtr->CurrentPattern->PattColor0Alpha);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_0, GrTablePtr->CurrentPattern->PattColor1);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_1, GrTablePtr->CurrentPattern->PattColor1Alpha);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(0), GrTablePtr->CurrentPattern->Pattern0);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(1), GrTablePtr->CurrentPattern->Pattern1);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN_SHAPE, GrTablePtr->CurrentPattern->PatternShape);
        }

    //**************************************************************************
    // Load RENDERING STATE as follows:
    //**************************************************************************

    if (GrTablePtr->CurrentPatch)
        {

        //**********************************************************************
        // STATIC STATE vs. RENDERING STATE
        //
        // STATIC STATE values are those attributes associated with the patch
        // and are specified when creating a patch.
        //
        // RENDERING STATE refers to the current attributes that are present
        // when an object is currently rendering.  That is, if a blit is
        // is interrupted, additional registers need to be saved and restored
        // such as the current source color or BETA ram values, so that the
        // rendering state can be restored EXACTLY the way it was prior to
        // being context switched.  Since this Miniport driver will not handle
        // context switching (We are in full control of context switching here),
        // we do not have to worry about saving/restoring them.(Need to init, though?)
        //
        // So for now, we do nothing.  As long as we keep track of the
        // static state objects, we should be fine.
        //**********************************************************************

        }

    else

        {
        //**********************************************************************
        // Init default values for the rendering state, since no patch was present
        //**********************************************************************

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MAX, 0x1fff1fff);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP0_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP1_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP0_MAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP1_MAX, 0x00000000);

        //**********************************************************************
        // TO DO!!
        //
        // NOTE: We need to determine what mode we are in so we can ENABLE/DISABLE
        //       DAC bypass appropriately !!!
        //
        // Currently set as follows:  DITHERING enabled and DACBYPASS enabled
        //
        //**********************************************************************

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MISC, 0x00110001);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_SOURCE_COLOR, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MONO_COLOR0, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MONO_COLOR1, 0x00000000);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, 0x00007fff);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, 0x00007fff);

        for (i=0;i < 14;i++)
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA_RAM(i), 0x00000000);

        for (i=0;i < 18;i++)
            {
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_X_RAM(i), 0x00000000);
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_Y_RAM(i), 0x00000000);
            }

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_ICLIP_XMAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_ICLIP_YMAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC0, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1, 0x00000000);

        //**********************************************************************
        // Always use the USER clip rects
        //**********************************************************************

        XYLogicMisc1 |= (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);


        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_X_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_Y_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_SUBDIVIDE, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_EDGEFILL, 0x00000000);


        //**********************************************************************
        // Now that we've initialized the registers, go ahead and mark
        // this channel as valid in the FIFO table structure
        //**********************************************************************

        HwDeviceExtension->FifoTable.InUse = 1;             // 1 = Valid
        HwDeviceExtension->FifoTable.ChID = 0;              // Channel 0 always
        }


    //**************************************************************************
    // TO DO:
    // Notify object --> Need to update??
    //**************************************************************************


    //**************************************************************************
    // Reset Context Switch bits
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_EXCEPTIONS,0);


    //**************************************************************************
    // Update and validate the channel (0)
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CTX_CONTROL,
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_MINIMUM_TIME, _2MS) |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_TIME, _NOT_EXPIRED) |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_CHID, _VALID)       |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_SWITCHING,_IDLE)    |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_DEVICE,_ENABLED));


    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE0_PULL0,cache0pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE0_PUSH0,cache0push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
// Function: NV1_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV1_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )


    {
    ULONG OutData;
    USHORT i;

    //**************************************************************************
    // Set the first CLUT index
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData= (UCHAR) ClutBuffer->FirstEntry;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_WRITE_PAL_ADDR,OutData);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Red));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Green));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Blue));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);
        }

    }


//******************************************************************************
//
// Function: NV1_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV1_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

    {
    ULONG OutData;
    USHORT i;

    //**************************************************************************
    // Set the first CLUT index
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_WRITE_PAL_ADDR,OutData);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    // Init to a gray scale so we'll something appear instead of just black
    //**************************************************************************

    for (i = 0; i < 256 ; i++)
        {
        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);
        }

    }


//******************************************************************************
//
// Function:    NV1_MapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NV1_MapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHWREG LinearMasterControlAddress;
    PHWREG LinearPFBControlAddress;
    ULONG SavedPMC;
    ULONG SavedIntrEn0;
    ULONG SavedConfig0;
    ULONG SavedDelay0;
    ULONG SavedGreen0;

    //**************************************************************************
    // Map memory for the NV hardware registers.  Not all of these ranges
    // are necessary, but we may need to access some of them later.
    // So we'll map a good majority of them for now.
    //**************************************************************************

    //**************************************************************************
    // Map memory for the NV1 MASTER CONTROL registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PMC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PMC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PMC_Registers.LowPart += RangeOffsets[NV_PMC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PMC_Length = RangeOffsets[NV_PMC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PMC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PMC_Registers,
              hwDeviceExtension->NV1_PMC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Master Control Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    LinearMasterControlAddress = hwDeviceExtension->NV1_Lin_PMC_Registers;

    //**************************************************************************
    // Enable ALL devices and interrupts.  Memory registers will NOT be accessible
    // until we do this final step. (Trying to read an NV Memory location before
    // setting this register will cause the debugger to hang the bus).
    //
    // NOTE:   Memory locations which are UNDEFINED for the NV architecture
    //         could hang the BUS if read.  So be careful about which
    //         memory locations you look at.  Some debuggers don't handle
    //         this too well.  So you might not be able to manually
    //         examine the registers if your debugger tries to read more
    //         than one location at once (possibly reading some undefined regs)
    //         Also, the NV architecture is a 32-bit environment and
    //         does not like reading/writing bytes at a time.
    //**************************************************************************

    PMC_REG_WR32(LinearMasterControlAddress,NV_PMC_ENABLE, 0xffffffff);

    //**************************************************************************
    // Map memory for the NV1 FRAME BUFFER CONTROL registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PFB_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PFB_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PFB_Registers.LowPart += RangeOffsets[NV_PFB_INDEX].ulOffset;
    hwDeviceExtension->NV1_PFB_Length = RangeOffsets[NV_PFB_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PFB_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PFB_Registers,
              hwDeviceExtension->NV1_PFB_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Frame Buffer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    LinearPFBControlAddress = hwDeviceExtension->NV1_Lin_PFB_Registers;


    //**************************************************************************
    // Map memory for the NV1 REAL MODE CONTROL registers (32k worth )
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRM_Registers.LowPart += RangeOffsets[NV_PRM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRM_Length = RangeOffsets[NV_PRM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRM_Registers,
              hwDeviceExtension->NV1_PRM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Real Mode Control Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 DAC registers (4k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PDAC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PDAC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PDAC_Registers.LowPart += RangeOffsets[NV_PDAC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PDAC_Length = RangeOffsets[NV_PDAC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PDAC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PDAC_Registers,
              hwDeviceExtension->NV1_PDAC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map DAC Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAM registers (4k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAM_Registers.LowPart += RangeOffsets[NV_PRAM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAM_Length = RangeOffsets[NV_PRAM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAM_Registers,
              hwDeviceExtension->NV1_PRAM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAM Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAMFC registers
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.LowPart += RangeOffsets[NV_PRAMFC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAMFC_Length = RangeOffsets[NV_PRAMFC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAMFC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAMFC_Registers,
              hwDeviceExtension->NV1_PRAMFC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAMFC Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAMHT registers
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.LowPart += RangeOffsets[NV_PRAMHT_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAMHT_Length = RangeOffsets[NV_PRAMHT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAMHT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAMHT_Registers,
              hwDeviceExtension->NV1_PRAMHT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAMHT Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 FIFO registers (8k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PFIFO_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PFIFO_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PFIFO_Registers.LowPart += RangeOffsets[NV_PFIFO_INDEX].ulOffset;
    hwDeviceExtension->NV1_PFIFO_Length = RangeOffsets[NV_PFIFO_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PFIFO_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PFIFO_Registers,
              hwDeviceExtension->NV1_PFIFO_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map FIFO Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PBUS registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PBUS_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PBUS_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PBUS_Registers.LowPart += RangeOffsets[NV_PBUS_INDEX].ulOffset;
    hwDeviceExtension->NV1_PBUS_Length = RangeOffsets[NV_PBUS_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PBUS_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PBUS_Registers,
              hwDeviceExtension->NV1_PBUS_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PBUS Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PGRAPH registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.LowPart += RangeOffsets[NV_PGRAPH_INDEX].ulOffset;
    hwDeviceExtension->NV1_PGRAPH_Length = RangeOffsets[NV_PGRAPH_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PGRAPH_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PGRAPH_Registers,
              hwDeviceExtension->NV1_PGRAPH_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 Rectangle USER registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_URECT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_URECT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_URECT_Registers.LowPart += RangeOffsets[NV_URECT_INDEX].ulOffset;
    hwDeviceExtension->NV1_URECT_Length = RangeOffsets[NV_URECT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_URECT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_URECT_Registers,
              hwDeviceExtension->NV1_URECT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map URECT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 Triangle registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UTRI_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UTRI_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UTRI_Registers.LowPart += RangeOffsets[NV_UTRI_INDEX].ulOffset;
    hwDeviceExtension->NV1_UTRI_Length = RangeOffsets[NV_UTRI_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UTRI_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UTRI_Registers,
              hwDeviceExtension->NV1_UTRI_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UTRI Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 BLIT registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UBLIT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UBLIT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UBLIT_Registers.LowPart += RangeOffsets[NV_UBLIT_INDEX].ulOffset;
    hwDeviceExtension->NV1_UBLIT_Length = RangeOffsets[NV_UBLIT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UBLIT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UBLIT_Registers,
              hwDeviceExtension->NV1_UBLIT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UBLIT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 IMAGE From CPU registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.LowPart += RangeOffsets[NV_UIMAGE_INDEX].ulOffset;
    hwDeviceExtension->NV1_UIMAGE_Length = RangeOffsets[NV_UIMAGE_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UIMAGE_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UIMAGE_Registers,
              hwDeviceExtension->NV1_UIMAGE_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UIMAGE Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 IMAGE MONO From CPU registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.LowPart += RangeOffsets[NV_UBITMAP_INDEX].ulOffset;
    hwDeviceExtension->NV1_UBITMAP_Length = RangeOffsets[NV_UBITMAP_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UBITMAP_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UBITMAP_Registers,
              hwDeviceExtension->NV1_UBITMAP_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UBITMAP Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Map memory for the NV1 PCI CONFIG registers (512 bytes worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_CONFIG_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_CONFIG_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_CONFIG_Registers.LowPart += RangeOffsets[NV_CONFIG_INDEX].ulOffset;
    hwDeviceExtension->NV1_CONFIG_Length = RangeOffsets[NV_CONFIG_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_CONFIG_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_CONFIG_Registers,
              hwDeviceExtension->NV1_CONFIG_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map CONFIG Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 DMA registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PDMA_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PDMA_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PDMA_Registers.LowPart += RangeOffsets[NV_PDMA_INDEX].ulOffset;
    hwDeviceExtension->NV1_PDMA_Length = RangeOffsets[NV_PDMA_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PDMA_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PDMA_Registers,
              hwDeviceExtension->NV1_PDMA_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PDMA Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PTIMER registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PTIMER_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PTIMER_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PTIMER_Registers.LowPart += RangeOffsets[NV_PTIMER_INDEX].ulOffset;
    hwDeviceExtension->NV1_PTIMER_Length = RangeOffsets[NV_PTIMER_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PTIMER_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PTIMER_Registers,
              hwDeviceExtension->NV1_PTIMER_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PTIMER Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PAUDIO registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.LowPart += RangeOffsets[NV_PAUDIO_INDEX].ulOffset;
    hwDeviceExtension->NV1_PAUDIO_Length = RangeOffsets[NV_PAUDIO_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PAUDIO_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PAUDIO_Registers,
              hwDeviceExtension->NV1_PAUDIO_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PAUDIO Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PAUTH registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PAUTH_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PAUTH_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PAUTH_Registers.LowPart += RangeOffsets[NV_PAUTH_INDEX].ulOffset;
    hwDeviceExtension->NV1_PAUTH_Length = RangeOffsets[NV_PAUTH_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PAUTH_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PAUTH_Registers,
              hwDeviceExtension->NV1_PAUTH_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PAUTH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PEXTDEV registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.LowPart += RangeOffsets[NV_PEXTDEV_INDEX].ulOffset;
    hwDeviceExtension->NV1_PEXTDEV_Length = RangeOffsets[NV_PEXTDEV_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PEXTDEV_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PEXTDEV_Registers,
              hwDeviceExtension->NV1_PEXTDEV_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PEXTDEV Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PEEPROM registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.LowPart += RangeOffsets[NV_PEEPROM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PEEPROM_Length = RangeOffsets[NV_PEEPROM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PEEPROM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PEEPROM_Registers,
              hwDeviceExtension->NV1_PEEPROM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PEEPROM Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PROM registers (32k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PROM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PROM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PROM_Registers.LowPart += RangeOffsets[NV_PROM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PROM_Length = RangeOffsets[NV_PROM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PROM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PROM_Registers,
              hwDeviceExtension->NV1_PROM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PROM Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PALT registers (32k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PALT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PALT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PALT_Registers.LowPart += RangeOffsets[NV_PALT_INDEX].ulOffset;
    hwDeviceExtension->NV1_PALT_Length = RangeOffsets[NV_PALT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PALT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PALT_Registers,
              hwDeviceExtension->NV1_PALT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PALT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //******************************************************************
    // Store the USER channel address in our HwDeviceExtension
    // structure, so that we can verify that the graphics engine is
    // working HERE in the miniport, before the display driver takes over.
    //******************************************************************
    hwDeviceExtension->NV1_Phys_USER_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_USER_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_USER_Registers.LowPart += RangeOffsets[NV_USER_INDEX].ulOffset;
    hwDeviceExtension->NV1_USER_Length = RangeOffsets[NV_USER_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_USER_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_USER_Registers,
              hwDeviceExtension->NV1_USER_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map USER Channel\n"));
        return(ERROR_INVALID_PARAMETER);
        }



    //**************************************************************************
    // Init the Master Control Register
    //**************************************************************************

    SavedPMC = PMC_REG_RD32(LinearMasterControlAddress, NV_PMC_ENABLE);
    SavedIntrEn0 = PMC_REG_RD32(LinearMasterControlAddress, NV_PMC_INTR_EN_0);

    PMC_REG_WR32(LinearMasterControlAddress, NV_PMC_ENABLE, 0xffffffff);

    //**************************************************************************
    // Prepare to write to the frame buffer control registers
    //**************************************************************************

    SavedConfig0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_CONFIG_0);
    SavedDelay0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_DELAY_0);
    SavedGreen0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_GREEN_0);

    //**************************************************************************
    // TEST CODE:
    // Blank the screen, then turn it back on just to verify that we've
    // correctly mapped the NV registers and that they are enabled.
    //**************************************************************************

    PFB_REG_WR32(LinearPFBControlAddress, NV_PFB_GREEN_0, 0x00000001);
    PFB_REG_WR32(LinearPFBControlAddress, NV_PFB_GREEN_0, SavedGreen0);

    //**************************************************************************
    // Turn off all NV interrupts
    //**************************************************************************

    PMC_REG_WR32(LinearMasterControlAddress, NV_PMC_INTR_EN_0, 0x0);

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);
    } // NV1_MapMemoryRanges()



//******************************************************************************
//
// Function: NV1_IsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NV1_IsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PVIDEO_ACCESS_RANGE pNVAccessRange,
                      PULONG NV1Slot)


    {
    VIDEO_ACCESS_RANGE TempAccessRange;
    USHORT  usVendorId,stVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   Address;
    ULONG   i;

    //**************************************************************************
    // VideoPortGetAccessRanges calls the PCI Bios to determine
    //    if the specified device is present or not.  This appears
    //    to be the equivalent call to the PCI Bios FIND_PCI_DEVICE call.
    //
    // Specify NumRequestedResources = 0
    //         RequestedResources = NULL
    //         NumAccessRanges = 1
    //         TempAccessRanges = Bus relative memory ranges for device (returned)
    //         VendorID = ID which identifies manufacturer
    //         DeviceID = ID which identifies device
    //         Slot = Specifies the Nth device of this type.
    //                Specify 0 to find the first (zero'th) occurence of device)
    //**************************************************************************

    stVendorId = ST1_VENDOR_ID;
    usVendorId = NV1_VENDOR_ID;
    usDeviceId = NV1_DEVICE_NV1_ID;

    //**************************************************************************
    // First, check and see if NV1 is present
    //**************************************************************************

    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 1,
                                 &TempAccessRange,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)
        {

Treat_SGS_Same_As_NV:

        VideoDebugPrint((1,"Found an NV1 in pci slot %d\n", ulSlot));
        HwDeviceExtension->ulSlot = ulSlot;

        //**********************************************************************
        //  At this point we have identified an NV1 on the PCi bus by using the
        //  vendor and device id.
        //**********************************************************************

        HwDeviceExtension->ulChipID   = NV1_DEVICE_NV1_ID;
        HwDeviceExtension->ulRevLevel = REV_UNDEF;
        HwDeviceExtension->BoardID = NV1_VENDOR_ID;

        //**********************************************************************
        // Save the slot number of later (for VideoPortSetBusData)
        //**********************************************************************

        *NV1Slot = ulSlot;

        //**********************************************************************
        //  TO DO:  The VideoPortGetAccessRanges call seems to work
        //          by calling the PCI Bios.  However, to be safe, we should
        //          add additional code to manually search for an NV1 adapter
        //          (ala the ScanNVMechanism1/2 routines in the Resource Manager)
        //          just in case some system BIOS's don't work correctly, or
        //          we're using a system with an older/buggy PCI Bios
        //**********************************************************************

        //**********************************************************************
        // Initialize the BASE PHYSICAL ADDRESS of the NV adapter in the Access Ranges
        //**********************************************************************

        pNVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart = TempAccessRange.RangeStart;
        pNVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeLength = TempAccessRange.RangeLength;

        //**********************************************************************
        // QUERY_PUBLIC_ACCESS_RANGES will use the following values to properly map
        // in the public access ranges.  For our display driver, we're going
        // to declare 4 public access ranges:   1) NV User Channel
        //                                      2) Graphics Status Register
        //                                      3) Frame Buffer VBLANK register
        //                                      4) Frame Buffer START register
        // Only the miniport will have access to all of the other privileged
        // graphics registers.
        //**********************************************************************

        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PRM_INDEX].ulOffset = DEVICE_BASE(NV_PRM);
        RangeOffsets[NV_PRM_INDEX].ulLength = DEVICE_EXTENT(NV_PRM);

        RangeOffsets[NV_PDAC_INDEX].ulOffset = DEVICE_BASE(NV_PDAC);
        RangeOffsets[NV_PDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PDAC);

        RangeOffsets[NV_PRAM_INDEX].ulOffset = DEVICE_BASE(NV_PRAM);
        RangeOffsets[NV_PRAM_INDEX].ulLength = DEVICE_EXTENT(NV_PRAM);

        RangeOffsets[NV_PRAMFC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMFC);
        RangeOffsets[NV_PRAMFC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMFC);

        RangeOffsets[NV_PRAMHT_INDEX].ulOffset = DEVICE_BASE(NV_PRAMHT);
        RangeOffsets[NV_PRAMHT_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMHT);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_URECT_INDEX].ulOffset = DEVICE_BASE(NV_URECT);
        RangeOffsets[NV_URECT_INDEX].ulLength = DEVICE_EXTENT(NV_URECT);

        RangeOffsets[NV_UTRI_INDEX].ulOffset = DEVICE_BASE(NV_UTRI);
        RangeOffsets[NV_UTRI_INDEX].ulLength = DEVICE_EXTENT(NV_UTRI);

        RangeOffsets[NV_UBLIT_INDEX].ulOffset = DEVICE_BASE(NV_UBLIT);
        RangeOffsets[NV_UBLIT_INDEX].ulLength = DEVICE_EXTENT(NV_UBLIT);

        RangeOffsets[NV_UIMAGE_INDEX].ulOffset = DEVICE_BASE(NV_UIMAGE);
        RangeOffsets[NV_UIMAGE_INDEX].ulLength = DEVICE_EXTENT(NV_UIMAGE);

        RangeOffsets[NV_UBITMAP_INDEX].ulOffset = DEVICE_BASE(NV_UBITMAP);
        RangeOffsets[NV_UBITMAP_INDEX].ulLength = DEVICE_EXTENT(NV_UBITMAP);

        RangeOffsets[NV_CONFIG_INDEX].ulOffset = DEVICE_BASE(NV_CONFIG);
        RangeOffsets[NV_CONFIG_INDEX].ulLength = DEVICE_EXTENT(NV_CONFIG);

        RangeOffsets[NV_PDMA_INDEX].ulOffset = DEVICE_BASE(NV_PDMA);
        RangeOffsets[NV_PDMA_INDEX].ulLength = DEVICE_EXTENT(NV_PDMA);

        RangeOffsets[NV_PTIMER_INDEX].ulOffset = DEVICE_BASE(NV_PTIMER);
        RangeOffsets[NV_PTIMER_INDEX].ulLength = DEVICE_EXTENT(NV_PTIMER);

        RangeOffsets[NV_PAUDIO_INDEX].ulOffset = DEVICE_BASE(NV_PAUDIO);
        RangeOffsets[NV_PAUDIO_INDEX].ulLength = DEVICE_EXTENT(NV_PAUDIO);

        RangeOffsets[NV_PAUTH_INDEX].ulOffset = DEVICE_BASE(NV_PAUTH);
        RangeOffsets[NV_PAUTH_INDEX].ulLength = DEVICE_EXTENT(NV_PAUTH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PEEPROM_INDEX].ulOffset = DEVICE_BASE(NV_PEEPROM);
        RangeOffsets[NV_PEEPROM_INDEX].ulLength = DEVICE_EXTENT(NV_PEEPROM);

        RangeOffsets[NV_PROM_INDEX].ulOffset = DEVICE_BASE(NV_PROM);
        RangeOffsets[NV_PROM_INDEX].ulLength = DEVICE_EXTENT(NV_PROM);

        RangeOffsets[NV_PALT_INDEX].ulOffset = DEVICE_BASE(NV_PALT);
        RangeOffsets[NV_PALT_INDEX].ulLength = DEVICE_EXTENT(NV_PALT);

        //**********************************************************************
        // The following 5 ranges (in addition to the frame buffer range)
        // are the only ones that we'll pass to the display driver.
        // The previous ranges will only be used within this miniport driver.
        //
        // First, init the USER channel
        // NOTE: We will ONLY be using 1 Channel (for the display driver only)
        //       So we only need to allocate 64k for 1 channel.
        // Second, init the Graphics Status register
        // Third, init access to Vertical Blanking register (PFB_CONFIG_0)
        // Fourth, init access to Frame Buffer Start Address register (PFB_START_ADDRESS)
        // Fifth, init access to SGS DAC register (SGS_DAC)
        // Finally, init access to the dumb frame buffer
        //**********************************************************************

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
//      RangeOffsets[NV_USER_INDEX].ulLength = DEVICE_EXTENT(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Just allocate memory for the PFB_CONFIG_0 register
        // so we can check if we're in vertical blanking or not
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;


        //**********************************************************************
        // Just allocate memory for the PFB_START_ADDRESS register
        // so we can flip the current buffer
        //**********************************************************************

        RangeOffsets[NV_PFB_START_ADDRESS_INDEX].ulOffset = NV_PFB_START;
        RangeOffsets[NV_PFB_START_ADDRESS_INDEX].ulLength = 16;

        //**********************************************************************
        // Allocate memory for the SGS DAC memory range
        // so we can set the cursor registers.  Just allocate 64 bytes.
        // That will cover the entire needed range.
        //**********************************************************************

        RangeOffsets[NV_SGS_DAC_INDEX].ulOffset = DEVICE_BASE(NV_PDAC);
        RangeOffsets[NV_SGS_DAC_INDEX].ulLength = 64;


        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = DEVICE_BASE(NV_PDFB);
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;



        //**********************************************************************
        //  Make sure the base Physical Address of NV device access range is
        //  stored in the PCI configuration space. Here, we get the the base
        //  address currently stored in PCI configuration space.
        //      PCIConfiguration is an ENUMERATED type
        //      Address will hold the PCI Common Config information
        //**********************************************************************

        VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            ulSlot,
                            (PVOID) &Address,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                            sizeof(ULONG));

        //**********************************************************************
        //  Make sure the base Physical Address access range returned by
        //  GetAccessRanges is the same as the one returned by GetBusData.
        //  If not, then use SetBusData to make them agree.
        //**********************************************************************

        if (Address != TempAccessRange.RangeStart.LowPart)
            {
            VideoDebugPrint((0, "I really wish they we're equal, but\n"
                                "they're not, so make them equal!\n"));

            VideoPortSetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                ulSlot,
                                (PVOID) &TempAccessRange.RangeStart.LowPart,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                sizeof(ULONG));
            }


        return(TRUE);
        }


    //**************************************************************************
    // Also, check if an ST equivalent of the chip is present
    //**************************************************************************

    else if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 1,
                                 &TempAccessRange,
                                 &stVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)
        {
        goto Treat_SGS_Same_As_NV;
        }

    //**************************************************************************
    // Didn't recognize NV1 or ST
    //**************************************************************************

    else

        return(FALSE);

    }


//******************************************************************************
//
// Function: NV1Interrupt()
//
// Routine Description:
//
//      Debug Interrupt routine to catch any inadvertent Interrupts that
//      the NV engine may generate (since we don't implement a resource manager)
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NV1Interrupt(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG OutData;
    ULONG SavedEnable;
    ULONG SavedWho;
    ULONG SavedPgraph;
    ULONG SavedAddress;
    ULONG SavedData;
    ULONG SavedCtxSwitch;
    ULONG SavedCtxControl;

    //**************************************************************************
    // Get the current state of some important registers
    // to help us figure out why an interrupt was generated.
    //**************************************************************************

    SavedEnable = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    SavedWho    = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_0);
    SavedWho    = SavedWho & (~0x10000000);
    SavedPgraph = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_INTR_0);
    SavedAddress = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_TRAPPED_ADDR);
    SavedData = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_TRAPPED_DATA);
    SavedCtxSwitch = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_CTX_SWITCH);
    SavedCtxControl = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_CTX_CONTROL);

    //**************************************************************************
    // Check the interrupt that occurred
    //**************************************************************************

    if (SavedWho & 0x01000000)

        {
        OutData = DRF_DEF(_PGRAPH,_INTR_0,_VBLANK,_RESET);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0, OutData);
        return(TRUE);                   // This is probably 0x01000000 (VBLANK)
        }

    else if (SavedWho & ~0x11000000)    // Check all except vblank

        {
        //**********************************************************************
        // ARGHHHHH......ACCCKKKKK!!!!
        // We shouldn't be causing any interrupts....!!!!!
        // We don't have a Resource Manager yet.....
        //**********************************************************************

        OutData = DRF_DEF(_PFIFO,_INTR_0,_RUNOUT,_RESET) ;
        return(TRUE);       // This is PFIFO pending
        }


    return(FALSE);          // Someone else's interrupt, let them handle it

    }





//******************************************************************************
//
//  Function:   NV1ObjectSwappingTest()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingTest(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//      PRENDEROBJECT PObject;
//      ULONG Data;
//      ULONG PatchCount;
//      PHWINFO NVInfo;
//      ULONG ColorFormat;
//      ULONG MonoFormat;
//      ULONG FreeCount;
//      NvChannel *nv;
//
//      //**************************************************************************
//      // NOTE: This function currently just tests the SWAPPING of objects only.
//      //       If we need to load in a brand NEW object, then we'll
//      //       need to completely initialize that object, as in NVSetupPatches.
//      //       Since we're just swapping out the triangle and rectangle object
//      //       here, I've skipped the calls to ClearPatchContext() and
//      //       SetPatchContext().  Remember, the context of a RENDER object
//      //       depends on the 'static' objects that make up its patch.
//      //       That is, SetPatchContext() generates the context of an object
//      //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
//      //       PATTERN objects that make up the patch associated with the
//      //       RENDER object.
//      //**************************************************************************
//
//      //**************************************************************************
//      // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
//      // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
//      // idle before we swap out OBJECTS. Otherwise, swapping out objects
//      // while something is still being drawn will probably generate interrupts.
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free;
//      while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
//          FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free;
//
//      GR_DONE;
//
//
//      //**************************************************************************
//      //
//      // Enable FLOWTHRU
//      //
//      //      In order to access many of the registers in the Graphics Engine,
//      //      we need to enable FLOWTHRU and disable the FIFO engine.
//      //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
//      //      CLASS = 0 to specify graphics registers.
//      //
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
//                              DRF_NUM(_PGRAPH,_MISC,_CLASS,0));
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      //**************************************************************************
//
//      GR_DONE;
//
//      //**************************************************************************
//      // Checks for any interrupt requests.  For this miniport,
//      // we shouldn't be getting any
//      //**************************************************************************
//
//      GR_IDLE;
//
//
//      //**************************************************************************
//      // Set the color format according to what the current mode depth is
//      //**************************************************************************
//
//      NVInfo = &(HwDeviceExtension->NvInfo);
//
//      switch (NVInfo->Framebuffer.Depth)
//          {
//          case 32:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          case 16:
//              ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
//              break;
//          case 8:
//              ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
//              break;
//          default:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          }
//
//      //**************************************************************************
//      // Default mono format is 0 and ALPHA NOT enabled
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//
//      //**************************************************************************
//      // Now setup the individual patches that we'll be using for
//      // the NT Display driver
//      //**************************************************************************
//
//  RECTANGLE_SWAP:
//
//      //**************************************************************************
//      // Replace RECTANGLE with TRIANGLE
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//      SetupRenderObject(HwDeviceExtension,RECTANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//                        NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//                        ColorFormat,MonoFormat);
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//      //**************************************************************************
//
//      GR_DONE;
//      GR_IDLE;
//
//
//  //TRIANGLE_SWAP:
//  //
//  //    //**************************************************************************
//  //    // Replace the TRIANGLE object with RECTANGLE
//  //    //**************************************************************************
//  //
//  //    MonoFormat = MONO_FORMAT_LE;
//  //    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,RECTANGLE_PATCH ,
//  //                      NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
//  //                      ColorFormat,MonoFormat);
//  //
//  //    //**************************************************************************
//  //    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//  //    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//  //    //**************************************************************************
//  //
//  //    GR_DONE;
//  //    GR_IDLE;
//  //
//  //
//      //**************************************************************************
//      // We're done with the Graphics registers for now.
//      // Make sure the FIFO and DMA engines are enabled.
//      //
//      //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
//      //
//      // DON'T TOUCH THE CLASS bits!!
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));
//
    }



//******************************************************************************
//
//  Function:   NV1ObjectSwappingTryIt()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingTryIt(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//
//      ULONG i;
//      ULONG x,y,Color;
//      NvChannel *nv;
//
//      //**************************************************************************
//      // Get pointer to NV channel area
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      //**************************************************************************
//      // Rectangle subchannel is NOW the Triangle subchannel.
//      // See if we successfully swapped it.  Note the RECTANGLE_SUBCHANNEL
//      // is being used, but we're actually writing out TRIANGLE methods.
//      //**************************************************************************
//
//      Color = 0x000000ff;
//      x = 125;
//      y = 125;
//
//      while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 4*4);
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0xff000000 | Color;
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);
//
//      Color = 0x0000ff00;
//      x = 225;
//      y = 225;
//
//      while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 4*4);
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0xff000000 | Color;
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);
//
//
//  //    //**************************************************************************
//  //    // Triangle subchannel is NOW the Rectangle subchannel.
//  //    // Note the TRIANGLE_SUBCHANNEL is being used, but we're actually
//  //    // writing out RECTANGLE methods.
//  //    //**************************************************************************
//  //
//  //    Color = 0x00ff0000;
//  //    x = 325;
//  //    y = 325;
//  //
//  //
//  //    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 3*4);
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0xff000000 | Color;
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00500040;
//  //
//  //
//  //
//  //    Color = 0x00ff00ff;
//  //    x = 425;
//  //    y = 425;
//  //
//  //    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 3*4);
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0xff000000 | Color;
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00600040;
//  //
//
    }


//******************************************************************************
//
//  Function:   NV1ObjectSwappingRestore()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingRestore(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//      PRENDEROBJECT PObject;
//      ULONG Data;
//      ULONG PatchCount;
//      PHWINFO NVInfo;
//      ULONG ColorFormat;
//      ULONG MonoFormat;
//
//      ULONG FreeCount;
//      NvChannel *nv;
//
//
//      //**************************************************************************
//      // NOTE: This function currently just tests the SWAPPING of objects only.
//      //       If we need to load in a brand NEW object, then we'll
//      //       need to completely initialize that object, as in NVSetupPatches.
//      //       Since we're just swapping out the triangle and rectangle object
//      //       here, I've skipped the calls to ClearPatchContext() and
//      //       SetPatchContext().  Remember, the context of a RENDER object
//      //       depends on the 'static' objects that make up its patch.
//      //       That is, SetPatchContext() generates the context of an object
//      //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
//      //       PATTERN objects that make up the patch associated with the
//      //       RENDER object.
//      //**************************************************************************
//
//      //**************************************************************************
//      // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
//      // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
//      // idle before we swap out OBJECTS. Otherwise, swapping out objects
//      // while something is still being drawn will probably generate interrupts.
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      FreeCount = nv->subchannel[TRIANGLE_SUBCHANNEL].control.free;
//      while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
//          FreeCount = nv->subchannel[TRIANGLE_SUBCHANNEL].control.free;
//
//      GR_DONE;
//
//
//      //**************************************************************************
//      //
//      // Enable FLOWTHRU
//      //
//      //      In order to access many of the registers in the Graphics Engine,
//      //      we need to enable FLOWTHRU and disable the FIFO engine.
//      //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
//      //      CLASS = 0 to specify graphics registers.
//      //
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
//                              DRF_NUM(_PGRAPH,_MISC,_CLASS,0));
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      //**************************************************************************
//
//      GR_DONE;
//
//      //**************************************************************************
//      // Checks for any interrupt requests.  For this miniport,
//      // we shouldn't be getting any
//      //**************************************************************************
//
//      GR_IDLE;
//
//      //**************************************************************************
//      // Set the color format according to what the current mode depth is
//      //**************************************************************************
//
//      NVInfo = &(HwDeviceExtension->NvInfo);
//
//      switch (NVInfo->Framebuffer.Depth)
//          {
//          case 32:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          case 16:
//              ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
//              break;
//          case 8:
//              ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
//              break;
//          default:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          }
//
//      //**************************************************************************
//      // Default mono format is 0 and ALPHA NOT enabled
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//
//      //**************************************************************************
//      // Now setup the individual patches that we'll be using for
//      // the NT Display driver
//      //**************************************************************************
//
//  RECTANGLE_RESTORE:
//
//      //**************************************************************************
//      // Restore RECTANGLE object in TRIANGLE subchannel
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//      SetupRenderObject(HwDeviceExtension,RECTANGLE_SUBCHANNEL,RECTANGLE_PATCH ,
//                        NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
//                        ColorFormat,MonoFormat);
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//      //**************************************************************************
//
//      GR_DONE;
//      GR_IDLE;
//
//
//  //TRIANGLE_RESTORE:
//  //
//  //    //**************************************************************************
//  //    // Restore the TRIANGLE object
//  //    //**************************************************************************
//  //
//  //    MonoFormat = MONO_FORMAT_LE;
//  //    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//  //                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//  //                      ColorFormat,MonoFormat);
//  //
//  //    //**************************************************************************
//  //    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//  //    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//  //    //**************************************************************************
//  //
//  //    GR_DONE;
//  //    GR_IDLE;
//  //
//  //
//      //**************************************************************************
//      // We're done with the Graphics registers for now.
//      // Make sure the FIFO and DMA engines are enabled.
//      //
//      //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
//      //
//      // DON'T TOUCH THE CLASS bits!!
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));
//
    }


//******************************************************************************
//
// Function:    NV1WaitUntilFinished()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1WaitUntilFinished(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    ULONG Width;
    ULONG Height;
    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait until there's nothing left in the FIFO to be done
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < NV_GUARANTEED_FIFO_SIZE);

    //**************************************************************************
    // Make ABSOLUTELY sure the graphics engine is not busy anymore
    // by checking the Graphics status register.
    // This is a MUST.  If we don't do this, mode switches may hang
    // on fast systems (p6-200's or better).
    //**************************************************************************

    GR_DONE;

    }

//******************************************************************************
//
// Function:    NV1SetOpenGLPatch()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1SetOpenGLPatch(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;
    ULONG FreeCount;
    NvChannel *nv;

    //**************************************************************************
    // NOTE: This function currently just tests the SWAPPING of objects only.
    //       If we need to load in a brand NEW object, then we'll
    //       need to completely initialize that object, as in NVSetupPatches.
    //       Since we're just swapping out the triangle and rectangle object
    //       here, I've skipped the calls to ClearPatchContext() and
    //       SetPatchContext().  Remember, the context of a RENDER object
    //       depends on the 'static' objects that make up its patch.
    //       That is, SetPatchContext() generates the context of an object
    //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
    //       PATTERN objects that make up the patch associated with the
    //       RENDER object.
    //**************************************************************************

    //**************************************************************************
    // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
    // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
    // idle before we swap out OBJECTS. Otherwise, swapping out objects
    // while something is still being drawn will probably generate interrupts.
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;
    while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
        FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;

    GR_DONE;


    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;


    //**************************************************************************
    // Set the color format according to what the current mode depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Default mono format is 0 and ALPHA NOT enabled
    //**************************************************************************


SWAP_IMAGE_FROM_CPU_WITH_TRIANGLE:

    //**************************************************************************
    // Replace IMAGE_FROM_CPU with TRIANGLE
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
                      ColorFormat,MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));


    }


//******************************************************************************
//
// Function:    NV1RestoreDisplayDriverPatch()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1RestoreDisplayDriverPatch(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;
    ULONG FreeCount;
    NvChannel *nv;

    //**************************************************************************
    // NOTE: This function currently just tests the SWAPPING of objects only.
    //       If we need to load in a brand NEW object, then we'll
    //       need to completely initialize that object, as in NVSetupPatches.
    //       Since we're just swapping out the triangle and rectangle object
    //       here, I've skipped the calls to ClearPatchContext() and
    //       SetPatchContext().  Remember, the context of a RENDER object
    //       depends on the 'static' objects that make up its patch.
    //       That is, SetPatchContext() generates the context of an object
    //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
    //       PATTERN objects that make up the patch associated with the
    //       RENDER object.
    //**************************************************************************

    //**************************************************************************
    // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
    // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
    // idle before we swap out OBJECTS. Otherwise, swapping out objects
    // while something is still being drawn will probably generate interrupts.
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;
    while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
        FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;

    GR_DONE;


    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Now restore the individual patches that we'll be using for
    // the NT Display driver
    //**************************************************************************

SWAP_TRIANGLE_WITH_IMAGE_FROM_CPU:

    //**************************************************************************
    // For text, we want color 0 (background) to be transparent
    // So set the color format appropriately with ALPHA channel enabled
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Setup the IMAGE_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,IMAGE_FROM_CPU_SUBCHANNEL,IMAGE_FROM_CPU_PATCH,
                      NV_IMAGE_FROM_CPU, MY_IMAGE_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));


    }



//******************************************************************************
//
// Function:    NV1ClearScreen()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1ClearScreen(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    ULONG Width;
    ULONG Height;
    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Get width and height of current mode
    //**************************************************************************

    Width = NVInfo->Framebuffer.HorizDisplayWidth;
    Height = NVInfo->Framebuffer.VertDisplayWidth;

    //**************************************************************************
    // First set ROP, CLIP, and PATTERN objects.  Disable color keying
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x7fff, 0x7fff);
    SetPattern(HwDeviceExtension);
    SetColorKey(HwDeviceExtension, 0x00000000);

    //**************************************************************************
    // Fill Screen with black rectangle (color 0 will always be black
    // regardless of mode at this point)
    //**************************************************************************

    //**************************************************************************
    // Wait for FIFO to be available first
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0x00000000;
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((0 << 16) | 0 );
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ((Height << 16) | (Width));


    }


//******************************************************************************
//
// Function:    NV1GraphicsTest()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1GraphicsTest(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Give it a try! First set ROP, CLIP, and PATTERN objects
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x40, 0x40);
    SetPattern(HwDeviceExtension);

    //**************************************************************************
    // Disable Color keying for now, because it's not currently used by
    // the display driver, and we can use it's subchannel with another object
    //
    // Update: Initialize the ColorKey! We need to use the COLOR KEY object for
    //         Direct Draw.  (Currently, the only place that uses it is Direct Draw)
    //         Specify color = 0 to make it inactive.  Specify (ALPHA_1_32/
    //         ALPHA_1_16/ALPHA_1_08 | Color) to activate the color key.
    //**************************************************************************

    SetColorKey(HwDeviceExtension, 0x00000000);

    //**************************************************************************
    // Draw some rectangles at top left.
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            //******************************************************************
            // Color Format in 32bpp mode is X8R8G8B8 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x0000ffff);    // G and B
            RenderRectangle(HwDeviceExtension,10,10,0x00ff00ff);    // R and B
            RenderRectangle(HwDeviceExtension,20,20,0x00ffff00);    // R and G

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_32 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Not drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Drawn

            break;

        case 16:
            //******************************************************************
            // Color Format in 16bpp mode is X17R5G5B5 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x000003ff);    // G and B
            RenderRectangle(HwDeviceExtension,10,10,0x00007c1f);    // R and B
            RenderRectangle(HwDeviceExtension,20,20,0x00007fe0);    // R and G

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_16 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Not drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Drawn

            break;

        case 8:
            //******************************************************************
            // Color Format in 8bpp mode is X24Y8 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x00000030);    // Dark Grey
            RenderRectangle(HwDeviceExtension,10,10,0x00000080);    // Medium Grey
            RenderRectangle(HwDeviceExtension,20,20,0x000000c0);    // Light Grey

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_08 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,0x0000000);       // Not Drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,0x0000000);       // Drawn

            break;
        }

//    //**************************************************************************
//    // Init clip to a large rectangle
//    //**************************************************************************
//
//    SetClip(HwDeviceExtension, 0, 0, 640, 0x480);
//
//    switch (NVInfo->Framebuffer.Depth)
//        {
//        case 32:
//            RenderTriangle(HwDeviceExtension,320,240,0x00ffffff);
//            RenderTriangle(HwDeviceExtension,400,400,0x0000ffff);
//            break;
//
//        case 16:
//            RenderTriangle(HwDeviceExtension,320,240,0x0000ffff);
//            RenderTriangle(HwDeviceExtension,400,400,0x000003ff);
//            break;
//
//        case 8:
//            RenderTriangle(HwDeviceExtension,320,240,0x000000ff);
//            RenderTriangle(HwDeviceExtension,400,400,0x00000080);
//            break;
//        }

    //**************************************************************************
    // Draw a bunch of rectangles just to prove that the NV engine is working
    //
    // NOTE: The following example will show up better in 16bpp modes
    //       with 5:5:5 format (We're just generating random colors,
    //       and they probably won't look good since we're not paying
    //       attention to the color format)
    //**************************************************************************

    SetClip(HwDeviceExtension, 100, 100, 200, 200);

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);

        i++;
        }

    //**************************************************************************
    // Now test out ROP functionality
    //**************************************************************************

    SetClip(HwDeviceExtension, 200, 200, 300, 300);
    SetRop(HwDeviceExtension, SRCAND );           // Src AND ROP

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);


        i++;
        }

    //**************************************************************************
    // Now test out PATTERN functionality
    //**************************************************************************

    SetClip(HwDeviceExtension, 200, 200, 300, 300);
    SetRop(HwDeviceExtension, PATCOPY );

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);


        i++;
        }

    //**************************************************************************
    // Test out Screen to Screen Blits (IMAGE_BLIT class)
    //**************************************************************************

    SetClip(HwDeviceExtension, 0,0,640,480);
    SetRop(HwDeviceExtension, SRCCOPY );

    ScreenToScreenBlit(HwDeviceExtension,320,240,  0,0,  20,20);
    ScreenToScreenBlit(HwDeviceExtension,320,240,  50,50,  100,100);
    ScreenToScreenBlit(HwDeviceExtension,320,480,  0,0,  300,0);

    //**************************************************************************
    // Test out Memory to Screen Blits (IMAGE_FROM_CPU class)
    //**************************************************************************

    MemoryToScreenBlit(HwDeviceExtension,100,100,  200,200);

    //**************************************************************************
    // Test out Memory to Screen Blits (IMAGE_MONO_FROM_CPU class)
    // Used for text acceleration.  We want color 0 to be transparent
    // and color 1 to be visible (Make sure ALPHA channel is working)
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            //******************************************************************
            // Color Format in 32bpp mode is X8R8G8B8 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_32) & 0x00ff0000, (NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x00eeeeee);

            break;

        case 16:
            //******************************************************************
            // Color Format in 16bpp mode is X17R5G5B5 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_16) & 0x00007C00, (NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_16) & 0x00007c00,(NV_ALPHA_1_16) | 0x000003e0);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_16) & 0x00007c00,(NV_ALPHA_1_16) | 0x00007fff);


            break;

        case 8:
            //******************************************************************
            // Color Format in 8bpp mode is X24Y8 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_08) & 0x0, (NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_08) & 0x10,(NV_ALPHA_1_08) | 0xff);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_08) & 0x10,(NV_ALPHA_1_08) | 0xff);


            break;
        }

    //**************************************************************************
    // Default back to a full screen clip and SRCCOPY Rop
    // May need to modify this later for drawing to OFFSCREEN
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x7fff, 0x7fff);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1c_ref.h ===
/* %W% %E% NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000001FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_VGA_0                              0x00000000 /* R--4R */
#define NV_CONFIG_PCI_VGA_0__ALIAS_1              NV_PBUS_PCI_VGA_0 /*       */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID                          15:0 /* R--VF */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID_NVIDIA             0x000010DE /* R---V */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID_SGS                0x0000104A /* R---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC                    18:16 /* C--UF */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC_VGA           0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC_NV            0x00000001 /* ----V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP                    31:19 /* C--UF */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV0           0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV1           0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV2           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0                               0x00000100 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* R--VF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA              0x000010DE /* R---V */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_SGS                 0x0000104A /* R---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_NV             0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_1                              0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_VGA_1__ALIAS_1              NV_PBUS_PCI_VGA_1 /*       */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE                            0:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE_DISABLED            0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE_ENABLED             0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP                       5:5 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP_DISABLED       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP_ENABLED        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK                    23:23 /* C--VF */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK_INCAPABLE     0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK_CAPABLE       0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING                     26:25 /* C--VF */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_FAST           0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_MEDIUM         0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_SLOW           0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET                   27:27 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_NO_ABORT     0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_ABORT        0x00000001 /* R---V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_CLEAR        0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1                               0x00000104 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_SERR                                 8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SERR_DISABLED                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_SERR_ENABLED                  0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR                       30:30 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_NOT_SIGNALED     0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_SIGNALED         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_CLEAR            0x00000001 /* -W--V */
#define NV_CONFIG_PCI_VGA_2                              0x00000008 /* R--4R */
#define NV_CONFIG_PCI_VGA_2__ALIAS_1              NV_PBUS_PCI_VGA_2 /*       */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID                         7:0 /* C--UF */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_A                0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B                0x00000001 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B02              0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B03              0x00000003 /* C---V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_C01              0x00000004 /* ----V */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE                         31:8 /* C--VF */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE_VGA               0x00030000 /* C---V */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE_MULTIMEDIA        0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_2                               0x00000108 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B02               0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B03               0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_C01               0x00000004 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* C---V */
#define NV_CONFIG_PCI_VGA_3                              0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_VGA_3__ALIAS_1              NV_PBUS_PCI_VGA_3 /*       */
#define NV_CONFIG_PCI_VGA_3_HEADER_TYPE                       23:16 /* C--VF */
#define NV_CONFIG_PCI_VGA_3_HEADER_TYPE_MULTIFUNC        0x00000080 /* C---V */
#define NV_CONFIG_PCI_NV_3                               0x0000010C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_CACHE_LINE_SIZE                      7:0 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_CACHE_LINE_SIZE_0_DWORDS      0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* C---V */
#define NV_CONFIG_PCI_NV_4                               0x00000110 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:25 /* RWIUF */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS_0                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_4(i)                   (0x00000010+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_4__SIZE_1                               6 /*       */
#define NV_CONFIG_PCI_VGA_4__ALIAS_1              NV_PBUS_PCI_VGA_4 /*       */
#define NV_CONFIG_PCI_VGA_4_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_4_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5(i)                    (0x00000114+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_5__SIZE_1                                5 /*       */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_10(i)                  (0x00000028+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_10__SIZE_1                              2 /*       */
#define NV_CONFIG_PCI_VGA_10__ALIAS_1            NV_PBUS_PCI_VGA_10 /*       */
#define NV_CONFIG_PCI_VGA_10_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_10_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_10(i)                   (0x00000128+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_10__SIZE_1                               2 /*       */
#define NV_CONFIG_PCI_NV_10__ALIAS_1              NV_PBUS_PCI_NV_10 /*       */
#define NV_CONFIG_PCI_NV_10_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_10_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_12                             0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_VGA_12__ALIAS_1            NV_PBUS_PCI_VGA_12 /*       */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE                         0:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_12_ROM_BASE                         31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_12                              0x00000130 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_VGA_13(i)                  (0x00000034+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_13__SIZE_1                              2 /*       */
#define NV_CONFIG_PCI_VGA_13__ALIAS_1            NV_PBUS_PCI_VGA_13 /*       */
#define NV_CONFIG_PCI_VGA_13_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_13_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_13(i)                   (0x00000134+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_13__SIZE_1                               2 /*       */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15                             0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_VGA_15__ALIAS_1            NV_PBUS_PCI_VGA_15 /*       */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE                          7:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ0              0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ1              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ15             0x0000000F /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_UNKNOWN           0x000000FF /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_PIN                          15:8 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_INTR_PIN_INTA               0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT                          23:16 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT_NO_REQUIREMENTS     0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT_750NS               0x00000003 /* ----V */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT                          31:24 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT_NO_REQUIREMENTS     0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT_250NS               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_15                              0x0000013C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_16(i)                  (0x00000040+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_16__SIZE_1                             48 /*       */
#define NV_CONFIG_PCI_VGA_16__ALIAS_1            NV_PBUS_PCI_VGA_16 /*       */
#define NV_CONFIG_PCI_VGA_16_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_16_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_16(i)                   (0x00000140+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_16__SIZE_1                              48 /*       */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_16_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_MEMORY_RMC_SVGA                               0x000B1E10 /* RW-4R */
#define NV_MEMORY_RMC_SVGA__ALIAS_1                NV_PBUS_RMC_SVGA /*       */
#define NV_MEMORY_RMC_ACCESS(i)                  (0x000B1E00+(i)*4) /* -W-4A */
#define NV_MEMORY_RMC_ACCESS__SIZE_1                              4 /*       */
#define NV_MEMORY_RMC_ACCESS_SECURITY                          31:0 /* -W-VF */
#define NV_MEMORY_RMC_ACCESS_SECURITY_DISABLE            0x564E6F4E /* -W--V */
#define NV_MEMORY_RMC_ACCESS_SECURITY_ENABLE             0x564E6F47 /* -W--V */
#define NV_MEMORY_RMC_WINDOW(i)                 (0x000B1E40+(i)*16) /* RW-4A */
#define NV_MEMORY_RMC_WINDOW__SIZE_1                              3 /*       */
#define NV_MEMORY_RMC_WINDOW__ALIAS_1            NV_PBUS_RMC_WINDOW /*       */
#define NV_MEMORY_BIOS_ROM008(i)                   (0x000C0000+(i)) /* RW-1A */
#define NV_MEMORY_BIOS_ROM008__SIZE_1                         32768 /*       */
#define NV_MEMORY_BIOS_ROM008_VALUE                             7:0 /* RW-VF */
#define NV_MEMORY_BIOS_ROM016(i)                 (0x000C0000+(i)*2) /* RW-2A */
#define NV_MEMORY_BIOS_ROM016__SIZE_1                         16384 /*       */
#define NV_MEMORY_BIOS_ROM016_VALUE                            15:0 /* RW-VF */
#define NV_MEMORY_BIOS_ROM032(i)                 (0x000C0000+(i)*4) /* RW-4A */
#define NV_MEMORY_BIOS_ROM032__SIZE_1                          8192 /*       */
#define NV_MEMORY_BIOS_ROM032_VALUE                            31:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM008(i)                   (0x000B1000+(i)) /* RW-1A */
#define NV_MEMORY_BIOS_RAM008__SIZE_1                          3584 /*       */
#define NV_MEMORY_BIOS_RAM008_VALUE                             7:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM016(i)                 (0x000B1000+(i)*2) /* RW-2A */
#define NV_MEMORY_BIOS_RAM016__SIZE_1                          1792 /*       */
#define NV_MEMORY_BIOS_RAM016_VALUE                            15:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM032(i)                 (0x000B1000+(i)*4) /* RW-4A */
#define NV_MEMORY_BIOS_RAM032__SIZE_1                           896 /*       */
#define NV_MEMORY_BIOS_RAM032_VALUE                            31:0 /* RW-VF */
#define NV_MEMORY_WINDOW008(i,j)          (0x000B2000+(i)*8192+(j)) /* RW-1A */
#define NV_MEMORY_WINDOW008__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW008__SIZE_2                            8192 /*       */
#define NV_MEMORY_WINDOW008_VALUE                               7:0 /* RW-VF */
#define NV_MEMORY_WINDOW016(i,j)        (0x000B2000+(i)*8192+(j)*2) /* RW-2A */
#define NV_MEMORY_WINDOW016__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW016__SIZE_2                            4096 /*       */
#define NV_MEMORY_WINDOW016_VALUE                              15:0 /* RW-VF */
#define NV_MEMORY_WINDOW032(i,j)        (0x000B2000+(i)*8192+(j)*4) /* RW-4A */
#define NV_MEMORY_WINDOW032__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW032__SIZE_2                            2048 /*       */
#define NV_MEMORY_WINDOW032_VALUE                              31:0 /* RW-VF */
#define NV_MEMORY_RMC_VL                                 0x000B1E90 /* RW-4R */
#define NV_MEMORY_RMC_VL__ALIAS_1                    NV_PBUS_RMC_VL /*       */
#define NV_MEMORY_RMC_DMA_0                              0x000B1E80 /* RW-4R */
#define NV_MEMORY_RMC_DMA_0__ALIAS_1              NV_PBUS_RMC_DMA_0 /*       */
#define NV_MEMORY_RMC_DMA_1                              0x000B1E84 /* RW-4R */
#define NV_MEMORY_RMC_DMA_1__ALIAS_1              NV_PBUS_RMC_DMA_1 /*       */
/* dev_realmode.ref */
#define NV_MEMORY_TRACE                                  0x000B1F00 /* RW-4R */
#define NV_MEMORY_TRACE__ALIAS_1                       NV_PRM_TRACE /*       */
#define NV_MEMORY_TRACE_INDEX                            0x000B1F10 /* RW-4R */
#define NV_MEMORY_TRACE_INDEX__ALIAS_1           NV_PRM_TRACE_INDEX /*       */
#define NV_MEMORY_IGNORE_0                               0x000B1F20 /* RW-4R */
#define NV_MEMORY_IGNORE_0__ALIAS_1                    NV_PRM_TRACE /*       */
#define NV_MEMORY_IGNORE_1                               0x000B1F24 /* RW-4R */
#define NV_MEMORY_IGNORE_1__ALIAS_1                    NV_PRM_TRACE /*       */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_VSE_03C3                                   0x000003C3 /* RW-1R */
#define NV_IO_VSE_03C3_ENABLE                                   0:0 /* RW-VF */
#define NV_IO_VSE_03C3_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_VSE_03C3_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_VSE_46E8                                   0x000046E8 /* RW-1R */
#define NV_IO_VSE_46E8_ENABLE                                   3:3 /* RW-VF */
#define NV_IO_VSE_46E8_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_VSE_46E8_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_VSE_46E8_SETUP                                    4:4 /* RW-VF */
#define NV_IO_VSE_46E8_SETUP_DISABLED                    0x00000000 /* RW--V */
#define NV_IO_VSE_46E8_SETUP_ENABLED                     0x00000001 /* RW--V */
#define NV_IO_POS_0102                                   0x00000102 /* RW-1R */
#define NV_IO_POS_0102_ENABLE                                   0:0 /* RW-VF */
#define NV_IO_POS_0102_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_POS_0102_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_realmode.ref */
#define NV_IO_GAME_PORT                                  0x00000201 /* RW-1R */
#define NV_IO_GAME_PORT__ALIAS_1                 NV_PRMIO_GAME_PORT /*       */
#define NV_IO_GAME_PORT_DATA                                    7:0 /* RW-VF */
#define NV_IO_FM_ADDRESS__SOUND_BLASTER                  0x00000228 /* -W-1R */
#define NV_IO_FM_ADDRESS__ADLIB                          0x00000388 /* -W-1R */
#define NV_IO_RM_ADDRESS_INDEX                                  7:0 /* -WIUF */
#define NV_IO_RM_ADDRESS_INDEX_0                         0x00000000 /* -WI-V */
#define NV_IO_SB_WRITE_STATUS                            0x0000022C /* R--1R */
#define NV_IO_SB_WRITE_STATUS__ALIAS_1     NV_PRMIO_SB_WRITE_STATUS /*       */
#define NV_IO_SB_WRITE_STATUS_STATE                             7:7 /* R-IVF */
#define NV_IO_SB_WRITE_STATUS_STATE_EMPTY                0x00000000 /* R-I-V */
#define NV_IO_SB_WRITE_STATUS_STATE_FULL                 0x00000001 /* R---V */
#define NV_IO_SB_READ_STATUS                             0x0000022E /* RW-1R */
#define NV_IO_SB_READ_STATUS__ALIAS_1       NV_PRMIO_SB_READ_STATUS /*       */
#define NV_IO_SB_READ_STATUS_STATE                              7:7 /* RWIVF */
#define NV_IO_SB_READ_STATUS_STATE_EMPTY                 0x00000000 /* RWI-V */
#define NV_IO_SB_READ_STATUS_STATE_FULL                  0x00000001 /* RW--V */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1           NV_PRMIO_MPU_401_DATA /*       */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1       NV_PRMIO_MPU_401_STATUS /*       */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MISC_OUT__WRITE                            0x000003C2 /* -W-1R */
#define NV_IO_MISC_OUT__READ                             0x000003CC /* R--1R */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS                            0:0 /* RWIVF */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS_MONO                0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS_COLOR               0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS                            1:1 /* RWIVF */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT                          3:2 /* RWIVF */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT_25MHZ             0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT_28MHZ             0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_OE_PAGE                               5:5 /* RWIVF */
#define NV_IO_EX_MISC_OUT_OE_PAGE_LOW_64K                0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_OE_PAGE_HIGH_64K               0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY                        6:6 /* RWIVF */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY_POSITIVE        0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY_NEGATIVE        0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY                        7:7 /* RWIVF */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY_POSITIVE        0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY_NEGATIVE        0x00000001 /* RW--V */
#define NV_IO_EX_FEATURE__WRITE_MONO                     0x000003BA /* -W-1R */
#define NV_IO_EX_FEATURE__WRITE_COLOR                    0x000003DA /* -W-1R */
#define NV_IO_EX_FEATURE__READ                           0x000003CA /* R--1R */
#define NV_IO_EX_FEATURE_CONTROL_0                              0:0 /* C--VF */
#define NV_IO_EX_FEATURE_CONTROL_0_0                     0x00000000 /* C---V */
#define NV_IO_EX_FEATURE_CONTROL_1                              1:1 /* C--VF */
#define NV_IO_EX_FEATURE_CONTROL_1_0                     0x00000000 /* C---V */
#define NV_IO_EX_FEATURE_VSYNC_SELECT                           7:7 /* RWIVF */
#define NV_IO_EX_FEATURE_VSYNC_SELECT_ONLY               0x00000000 /* RWI-V */
#define NV_IO_EX_FEATURE_VSYNC_SELECT_OR_DISPLAY         0x00000001 /* RW--V */
#define NV_IO_EX_STATUS_0__READ                          0x000003C2 /* R--1R */
#define NV_IO_EX_STATUS_0_SENSE_CODE                            4:4 /* RWIVF */
#define NV_IO_EX_STATUS_0_SENSE_CODE_OFF                 0x00000000 /* RW--V */
#define NV_IO_EX_STATUS_0_SENSE_CODE_ON                  0x00000001 /* RWI-V */
#define NV_IO_EX_STATUS_0_FEATURE_0                             5:5 /* C--VF */
#define NV_IO_EX_STATUS_0_FEATURE_0_0                    0x00000000 /* C---V */
#define NV_IO_EX_STATUS_0_FEATURE_1                             6:6 /* C--VF */
#define NV_IO_EX_STATUS_0_FEATURE_1_0                    0x00000000 /* C---V */
#define NV_IO_EX_STATUS_0_VTRACE_INTR                           7:7 /* R-IVF */
#define NV_IO_EX_STATUS_0_VTRACE_INTR_VBLANK             0x00000000 /* R-I-V */
#define NV_IO_EX_STATUS_0_VTRACE_INTR_DISPLAY            0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1__READ_MONO                     0x000003BA /* R--1R */
#define NV_IO_EX_STATUS_1__READ_COLOR                    0x000003DA /* R--1R */
#define NV_IO_EX_STATUS_1_BLANK                                 0:0 /* R-XVF */
#define NV_IO_EX_STATUS_1_BLANK_DISPLAY                  0x00000000 /* R---V */
#define NV_IO_EX_STATUS_1_BLANK_HORZ_VERT                0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1_LPEN_STROBE                           1:1 /* C--VF */
#define NV_IO_EX_STATUS_1_LPEN_STROBE_0                  0x00000000 /* C---V */
#define NV_IO_EX_STATUS_1_LPEN_SWITCH                           2:2 /* C--VF */
#define NV_IO_EX_STATUS_1_LPEN_SWITCH_0                  0x00000001 /* C---V */
#define NV_IO_EX_STATUS_1_VSYNC                                 3:3 /* R-IVF */
#define NV_IO_EX_STATUS_1_VSYNC_OUTSIDE                  0x00000000 /* R-I-V */
#define NV_IO_EX_STATUS_1_VSYNC_INSIDE                   0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1_DIAGNOSTICS                           5:4 /* C--VF */
#define NV_IO_EX_STATUS_1_DIAGNOSTICS_0                  0x00000000 /* C---V */
#define NV_IO_SQ_ADDRESS                                 0x000003C4 /* RW-1R */
#define NV_IO_SQ_ADDRESS__ALIAS_1               NV_PRMIO_SQ_ADDRESS /*       */
#define NV_IO_SQ_ADDRESS_INDEX                                  2:0 /* RWIUF */
#define NV_IO_SQ_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK                                0x000003C5 /* RW-1R */
#define NV_IO_SQ_MAP_MASK__ALIAS_1             NV_PRMIO_SQ_MAP_MASK /*       */
#define NV_IO_SQ_MAP_MASK__INDEX                         0x00000002 /*       */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0                          0:0 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1                          1:1 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2                          2:2 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3                          3:3 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP                                0x000003C5 /* RW-1R */
#define NV_IO_SQ_CHAR_MAP__ALIAS_1             NV_PRMIO_SQ_CHAR_MAP /*       */
#define NV_IO_SQ_CHAR_MAP__INDEX                         0x00000003 /*       */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO                             1:0 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_0K                   0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_16K                  0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_32K                  0x00000002 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_48K                  0x00000003 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO                             3:2 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_0K                   0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_16K                  0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_32K                  0x00000002 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_48K                  0x00000003 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI                             4:4 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI_PLUS_0K              0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI_PLUS_16K             0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI                             5:5 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI_PLUS_0K              0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI_PLUS_16K             0x00000001 /* RW--V */
#define NV_IO_SQ_MEM_MAP                                 0x000003C5 /* RW-1R */
#define NV_IO_SQ_MEM_MAP__ALIAS_1               NV_PRMIO_SQ_MEM_MAP /*       */
#define NV_IO_SQ_MEM_MAP__INDEX                          0x00000004 /*       */
#define NV_IO_SQ_MEM_MAP_ALPHA_GRAPH                            0:0 /* C--VF */
#define NV_IO_SQ_MEM_MAP_ALPHA_GRAPH_0                   0x00000000 /* C---V */
#define NV_IO_SQ_MEM_MAP_EXT_MEMORY                             1:1 /* C--VF */
#define NV_IO_SQ_MEM_MAP_EXT_MEMORY_64K                  0x00000001 /* C---V */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN                               2:2 /* RWIVF */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN_ODD_EVEN               0x00000000 /* RWI-V */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN_SEQUENTIAL             0x00000001 /* RW--V */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR                             3:3 /* RWIVF */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR_PLANAR               0x00000000 /* RWI-V */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR_PIXEL                0x00000001 /* RW--V */
#define NV_IO_CC_ADDRESS__MONO                           0x000003B4 /* RW-1R */
#define NV_IO_CC_ADDRESS__COLOR                          0x000003D4 /* RW-1R */
#define NV_IO_CC_ADDRESS_INDEX                                  5:0 /* RWIUF */
#define NV_IO_CC_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_CC_MAX_SCAN__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_MAX_SCAN__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_MAX_SCAN__INDEX                         0x00000009 /*       */
#define NV_IO_CC_MAX_SCAN_CHAR_HEIGHT                           4:0 /* RWXUF */
#define NV_IO_CC_MAX_SCAN_2T4                                   5:5 /* RWXVF */
#define NV_IO_CC_MAX_SCAN_LINE_CMP9                             6:6 /* RWXVF */
#define NV_IO_CC_MAX_SCAN_VBS9                                  7:7 /* RWXVF */
#define NV_IO_CC_CURSOR_START__MONO                      0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_START__COLOR                     0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_START__INDEX                     0x0000000A /*       */
#define NV_IO_CC_CURSOR_START_START                             4:0 /* RWXUF */
#define NV_IO_CC_CURSOR_START_DISABLE                           5:5 /* RWXVF */
#define NV_IO_CC_CURSOR_START_DISABLE_CURSOR_ON          0x00000000 /* RW--V */
#define NV_IO_CC_CURSOR_START_DISABLE_CURSOR_OFF         0x00000001 /* RW--V */
#define NV_IO_CC_START_HI__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_START_HI__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_START_HI__INDEX                         0x0000000C /*       */
#define NV_IO_CC_START_HI_ADDRESS                               7:0 /* RWXUF */
#define NV_IO_CC_START_LO__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_START_LO__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_START_LO__INDEX                         0x0000000D /*       */
#define NV_IO_CC_START_LO_ADDRESS                               7:0 /* RWXUF */
#define NV_IO_CC_CURSOR_HI__MONO                         0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_HI__COLOR                        0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_HI__INDEX                        0x0000000E /*       */
#define NV_IO_CC_CURSOR_HI_LOCATION                             7:0 /* RWXUF */
#define NV_IO_CC_CURSOR_LO__MONO                         0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_LO__COLOR                        0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_LO__INDEX                        0x0000000F /*       */
#define NV_IO_CC_CURSOR_LO_LOCATION                             7:0 /* RWXUF */
#define NV_IO_CC_OFFSET__MONO                            0x000003B5 /* RW-1R */
#define NV_IO_CC_OFFSET__COLOR                           0x000003D5 /* RW-1R */
#define NV_IO_CC_OFFSET__INDEX                           0x00000013 /*       */
#define NV_IO_CC_OFFSET_PITCH                                   7:0 /* RWXUF */
#define NV_IO_GC_ADDRESS                                 0x000003CE /* RW-1R */
#define NV_IO_GC_ADDRESS__ALIAS_1               NV_PRMIO_GC_ADDRESS /*       */
#define NV_IO_GC_ADDRESS_INDEX                                  3:0 /* RWIUF */
#define NV_IO_GC_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_GC_SR                                      0x000003CF /* RW-1R */
#define NV_IO_GC_SR__ALIAS_1                         NV_PRMIO_GC_SR /*       */
#define NV_IO_GC_SR__INDEX                               0x00000000 /*       */
#define NV_IO_GC_SR_VALUE_0                                     0:0 /* RWIVF */
#define NV_IO_GC_SR_VALUE_0_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_0_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_1                                     1:1 /* RWIVF */
#define NV_IO_GC_SR_VALUE_1_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_1_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_2                                     2:2 /* RWIVF */
#define NV_IO_GC_SR_VALUE_2_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_2_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_3                                     3:3 /* RWIVF */
#define NV_IO_GC_SR_VALUE_3_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_3_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR                               0x000003CF /* RW-1R */
#define NV_IO_GC_ENABLE_SR__ALIAS_1           NV_PRMIO_GC_ENABLE_SR /*       */
#define NV_IO_GC_ENABLE_SR__INDEX                        0x00000001 /*       */
#define NV_IO_GC_ENABLE_SR_ENABLE_0                             0:0 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_0_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_0_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_1                             1:1 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_1_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_1_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_2                             2:2 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_2_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_2_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_3                             3:3 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_3_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_3_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_COLOR_COMP                              0x000003CF /* RW-1R */
#define NV_IO_GC_COLOR_COMP__ALIAS_1         NV_PRMIO_GC_COLOR_COMP /*       */
#define NV_IO_GC_COLOR_COMP__INDEX                       0x00000002 /*       */
#define NV_IO_GC_COLOR_COMP_COLOR_0                             0:0 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_0_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_1                             1:1 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_1_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_2                             2:2 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_2_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_3                             3:3 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_3_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE                                  0x000003CF /* RW-1R */
#define NV_IO_GC_ROTATE__ALIAS_1                 NV_PRMIO_GC_ROTATE /*       */
#define NV_IO_GC_ROTATE__INDEX                           0x00000003 /*       */
#define NV_IO_GC_ROTATE_RIGHT                                   2:0 /* RWIVF */
#define NV_IO_GC_ROTATE_RIGHT_0                          0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE_FUNCTION                                4:3 /* RWIVF */
#define NV_IO_GC_ROTATE_FUNCTION_NOP                     0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE_FUNCTION_AND                     0x00000001 /* RW--V */
#define NV_IO_GC_ROTATE_FUNCTION_OR                      0x00000002 /* RW--V */
#define NV_IO_GC_ROTATE_FUNCTION_XOR                     0x00000003 /* RW--V */
#define NV_IO_GC_READ_MAP                                0x000003CF /* RW-1R */
#define NV_IO_GC_READ_MAP__ALIAS_1             NV_PRMIO_GC_READ_MAP /*       */
#define NV_IO_GC_READ_MAP__INDEX                         0x00000004 /*       */
#define NV_IO_GC_READ_MAP_PLANE                                 1:0 /* RWIUF */
#define NV_IO_GC_READ_MAP_PLANE_0                        0x00000000 /* RWI-V */
#define NV_IO_GC_MODE                                    0x000003CF /* RW-1R */
#define NV_IO_GC_MODE__ALIAS_1                     NV_PRMIO_GC_MODE /*       */
#define NV_IO_GC_MODE__INDEX                             0x00000005 /*       */
#define NV_IO_GC_MODE_WRITE_MODE                                1:0 /* RWIVF */
#define NV_IO_GC_MODE_WRITE_MODE_0                       0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_TEST                                      2:2 /* C--VF */
#define NV_IO_GC_MODE_TEST_0                             0x00000000 /* C---V */
#define NV_IO_GC_MODE_READ_MODE                                 3:3 /* RWIVF */
#define NV_IO_GC_MODE_READ_MODE_LATCH                    0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_READ_MODE_COMPARISON               0x00000001 /* RW--V */
#define NV_IO_GC_MODE_ODD_EVEN                                  4:4 /* RWIVF */
#define NV_IO_GC_MODE_ODD_EVEN_SEQUENTIAL                0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_ODD_EVEN_ODD_EVEN                  0x00000001 /* RW--V */
#define NV_IO_GC_MODE_SHIFT                                     6:5 /* RWIVF */
#define NV_IO_GC_MODE_SHIFT_PLANAR                       0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_SHIFT_CGA                          0x00000001 /* RW--V */
#define NV_IO_GC_MODE_SHIFT_PIXEL                        0x00000002 /* RW--V */
#define NV_IO_GC_MISC                                    0x000003CF /* RW-1R */
#define NV_IO_GC_MISC__ALIAS_1                     NV_PRMIO_GC_MISC /*       */
#define NV_IO_GC_MISC__INDEX                             0x00000006 /*       */
#define NV_IO_GC_MISC_GRAPH_ALPHA                               0:0 /* RWIVF */
#define NV_IO_GC_MISC_GRAPH_ALPHA_ALPHANUMERICS          0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_GRAPH_ALPHA_GRAPHICS               0x00000001 /* RW--V */
#define NV_IO_GC_MISC_CHAIN_OE                                  1:1 /* RWIVF */
#define NV_IO_GC_MISC_CHAIN_OE_EGA_VGA                   0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_CHAIN_OE_MDA                       0x00000001 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP                                3:2 /* RWIVF */
#define NV_IO_GC_MISC_MEMORY_MAP_ALL                     0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_MEMORY_MAP_EGA                     0x00000001 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP_MDA                     0x00000002 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP_CGA                     0x00000003 /* RW--V */
#define NV_IO_GC_DONT_CARE                               0x000003CF /* RW-1R */
#define NV_IO_GC_DONT_CARE__ALIAS_1           NV_PRMIO_GC_DONT_CARE /*       */
#define NV_IO_GC_DONT_CARE__INDEX                        0x00000007 /*       */
#define NV_IO_GC_DONT_CARE_COLOR_0                              0:0 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_0_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_0_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_1                              1:1 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_1_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_1_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_2                              2:2 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_2_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_2_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_3                              3:3 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_3_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_3_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK                                0x000003CF /* RW-1R */
#define NV_IO_GC_BIT_MASK__ALIAS_1             NV_PRMIO_GC_BIT_MASK /*       */
#define NV_IO_GC_BIT_MASK__INDEX                         0x00000008 /*       */
#define NV_IO_GC_BIT_MASK_VALUE_0                               0:0 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_0_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_0_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_1                               1:1 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_1_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_1_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_2                               2:2 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_2_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_2_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_3                               3:3 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_3_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_3_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_4                               4:4 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_4_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_4_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_5                               5:5 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_5_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_5_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_6                               6:6 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_6_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_6_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_7                               7:7 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_7_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_7_WRITE                  0x00000001 /* RW--V */
#define NV_IO_AT_ADDRESS__WRITE_FLIPFLOP0                0x000003C0 /* -W-1R */
#define NV_IO_AT_ADDRESS__READ                           0x000003C0 /* R--1R */
#define NV_IO_AT_ADDRESS_INDEX                                  4:0 /* RWIUF */
#define NV_IO_AT_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS                         5:5 /* RWIVF */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS_CPU              0x00000000 /* RWI-V */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS_DISPLAY          0x00000001 /* RW--V */
#define NV_IO_AT_MODE__WRITE_FLIPFLOP1                   0x000003C0 /* -W-1R */
#define NV_IO_AT_MODE__READ                              0x000003C1 /* R--1R */
#define NV_IO_AT_MODE__INDEX                             0x00000010 /*       */
#define NV_IO_AT_MODE_G_OR_A                                    0:0 /* RWXVF */
#define NV_IO_AT_MODE_G_OR_A_ALPHA                       0x00000000 /* RW--V */
#define NV_IO_AT_MODE_G_OR_A_GRAPHICS                    0x00000001 /* RW--V */
#define NV_IO_AT_MODE_DISPLAY                                   1:1 /* RWXVF */
#define NV_IO_AT_MODE_DISPLAY_COLOR                      0x00000000 /* RW--V */
#define NV_IO_AT_MODE_DISPLAY_MDA                        0x00000001 /* RW--V */
#define NV_IO_AT_MODE_EXTEND_9                                  2:2 /* RWXVF */
#define NV_IO_AT_MODE_EXTEND_9_BACKGROUND                0x00000000 /* RW--V */
#define NV_IO_AT_MODE_EXTEND_9_BIT_8                     0x00000001 /* RW--V */
#define NV_IO_AT_MODE_BLINK_ENABLE                              3:3 /* RWXVF */
#define NV_IO_AT_MODE_BLINK_ENABLE_INTENSITY             0x00000000 /* RW--V */
#define NV_IO_AT_MODE_BLINK_ENABLE_BLINKING_ENABLED      0x00000001 /* RW--V */
#define NV_IO_AT_MODE_PIXEL_PANNING_COMP                        5:5 /* RWXVF */
#define NV_IO_AT_MODE_PIXEL_CLOCK_SELECT                        6:6 /* RWXVF */
#define NV_IO_AT_MODE_PALETTE_SIZE                              7:7 /* RWXVF */
#define NV_IO_DAC_DATA                                   0x000003C9 /* RW-1R */
#define NV_IO_DAC_DATA__ALIAS_1                   NV_PRMIO_DAC_DATA /*       */
#define NV_IO_DAC_DATA_VALUE                                    7:0 /* RW-VF */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_REVISION                                  7:0 /* C--VF */
#define NV_PMC_BOOT_0_REVISION_A                         0x00000000 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B                         0x00000001 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B02                       0x00000002 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B03                       0x00000003 /* C---V */
#define NV_PMC_BOOT_0_REVISION_C01                       0x00000004 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* R---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_MANUFACTURER                            31:24 /* R--VF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* R---V */
#define NV_PMC_BOOT_0_MANUFACTURER_SGS                   0x00000001 /* R---V */
#define NV_PMC_DEBUG_0                                   0x00000080 /* R--4R */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO                             0:0 /* RWIVF */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO_DISABLED             0x00000000 /* RWI-V */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO_ENABLED              0x00000001 /* RW--V */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH                           12:12 /* RWIVF */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH_DISABLED             0x00000000 /* RWI-V */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH_ENABLED              0x00000001 /* RW--V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PDMA                                      4:4 /* R--VF */
#define NV_PMC_INTR_0_PDMA_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PDMA_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH                                  12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PRM                                     16:16 /* R--VF */
#define NV_PMC_INTR_0_PRM_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PRM_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                28:28 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTB                                   5:4 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTB_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTB_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTB_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTC                                   9:8 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTC_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTC_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTC_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTD                                 13:12 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTD_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTD_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTD_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTB                                 4:4 /* R--VF */
#define NV_PMC_INTR_READ_0_INTB_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTB_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTC                                 8:8 /* R--VF */
#define NV_PMC_INTR_READ_0_INTC_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTC_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTD                               12:12 /* R--VF */
#define NV_PMC_INTR_READ_0_INTD_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTD_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_SERR                               16:16 /* R--VF */
#define NV_PMC_INTR_READ_0_SERR_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_SERR_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PDMA                                      4:4 /* RWIVF */
#define NV_PMC_ENABLE_PDMA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PDMA_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PRM                                     16:16 /* RWIVF */
#define NV_PMC_ENABLE_PRM_DISABLED                       0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PRM_ENABLED                        0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     24:24 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG                                  0x00000400 /* RW-4R */
#define NV_PMC_WATCHDOG_TIMEOUT                                 3:0 /* RWIVF */
#define NV_PMC_WATCHDOG_TIMEOUT_1_US                     0x00000000 /* RWI-V */
#define NV_PMC_WATCHDOG_TIMEOUT_2_US                     0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_4_US                     0x00000002 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_8_US                     0x00000003 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_16_US                    0x00000004 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_32_US                    0x00000005 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_64_US                    0x00000006 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_128_US                   0x00000007 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_256_US                   0x00000008 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_512_US                   0x00000009 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_1_MS                     0x0000000A /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_2_MS                     0x0000000B /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_4_MS                     0x0000000C /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_8_MS                     0x0000000D /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_16_MS                    0x0000000E /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_32_MS                    0x0000000F /* RW--V */
#define NV_PMC_WATCHDOG_STATE                                  10:8 /* RWIVF */
#define NV_PMC_WATCHDOG_STATE_SLEEPING                   0x00000000 /* RWI-V */
#define NV_PMC_WATCHDOG_STATE_SNIFFING                   0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_GROWLING                   0x00000002 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_BARKING                    0x00000003 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_BITING                     0x00000004 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE                             0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE_BY_TWO               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE_BY_ONE               0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_MCLK_LCLK                               4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_MCLK_LCLK_ASYNCHRONOUS           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MCLK_LCLK_SYNCHRONOUS            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_MEMORY_READ                             8:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_MEMORY_READ_DWORD                0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MEMORY_READ_LINE                 0x00000001 /* RW--V */
#define NV_PBUS_ACCESS                                   0x00001200 /* RW-4R */
#define NV_PBUS_ACCESS_GAME_PORT                                0:0 /* RWIVF */
#define NV_PBUS_ACCESS_GAME_PORT_DISABLED                0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_GAME_PORT_ENABLED                 0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MDA                                      4:4 /* RWIVF */
#define NV_PBUS_ACCESS_MDA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_MDA_ENABLED                       0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_SOUND_BOARD                              8:8 /* RWIVF */
#define NV_PBUS_ACCESS_SOUND_BOARD_DISABLED              0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_SOUND_BOARD_ENABLED               0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_RM_CONTROL                             12:12 /* RWIVF */
#define NV_PBUS_ACCESS_RM_CONTROL_DISABLED               0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_RM_CONTROL_ENABLED                0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401                                17:16 /* RWIVF */
#define NV_PBUS_ACCESS_MPU_401_DISABLED                  0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_MPU_401_0330H                     0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401_0300H                     0x00000002 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401_0230H                     0x00000003 /* RW--V */
#define NV_PBUS_ACCESS_DMA                                    20:20 /* RWIVF */
#define NV_PBUS_ACCESS_DMA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_DMA_ENABLED                       0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_FM_SYNTHESIS                           24:24 /* RWIVF */
#define NV_PBUS_ACCESS_FM_SYNTHESIS_DISABLED             0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_FM_SYNTHESIS_ENABLED              0x00000001 /* RW--V */
#define NV_PBUS_RMC_SVGA                                 0x00001410 /* RW-4R */
#define NV_PBUS_RMC_SVGA__ALIAS_1                NV_MEMORY_RMC_SVGA /*       */
#define NV_PBUS_RMC_SVGA_SEGMENT                                3:0 /* RWXUF */
#define NV_PBUS_RMC_SVGA_SEGMENT_0K                      0x00000000 /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_64K                     0x00000001 /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_896K                    0x0000000E /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_960K                    0x0000000F /* RW--V */
#define NV_PBUS_RMC_SVGA_TYPE                                 12:12 /* RWXVF */
#define NV_PBUS_RMC_SVGA_TYPE_LINEAR                     0x00000000 /* RW--V */
#define NV_PBUS_RMC_SVGA_TYPE_VGA                        0x00000001 /* RW--V */
#define NV_PBUS_RMC_WINDOW(i)                   (0x00001440+(i)*16) /* RW-4A */
#define NV_PBUS_RMC_WINDOW__SIZE_1                                3 /*       */
#define NV_PBUS_RMC_WINDOW__ALIAS_1            NV_MEMORY_RMC_WINDOW /*       */
#define NV_PBUS_RMC_WINDOW_SEGMENT                            24:13 /* RWXUF */
#define NV_PBUS_RMC_WINDOW_SEGMENT_0K                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_8K                    0x00000001 /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_32752K                0x00000FFE /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_32760K                0x00000FFF /* RW--V */
#define NV_PBUS_RMC_VL                                   0x00001490 /* RW-4R */
#define NV_PBUS_RMC_VL__ALIAS_1                    NV_MEMORY_RMC_VL /*       */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE                          3:3 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP                           4:4 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE                        16:16 /* RWIVF */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE                        24:24 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001480 /* RW-4R */
#define NV_PBUS_RMC_DMA_0__ALIAS_1              NV_MEMORY_RMC_DMA_0 /*       */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001484 /* RW-4R */
#define NV_PBUS_RMC_DMA_1__ALIAS_1              NV_MEMORY_RMC_DMA_1 /*       */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_VGA_0                                0x00001800 /* R--4R */
#define NV_PBUS_PCI_VGA_0__ALIAS_1              NV_CONFIG_PCI_VGA_0 /*       */
#define NV_PBUS_PCI_NV_0                                 0x00001900 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_VGA_1                                0x00001804 /* RW-4R */
#define NV_PBUS_PCI_VGA_1__ALIAS_1              NV_CONFIG_PCI_VGA_1 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001904 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_VGA_2                                0x00001808 /* R--4R */
#define NV_PBUS_PCI_VGA_2__ALIAS_1               NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001908 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_VGA_3                                0x0000180C /* RW-4R */
#define NV_PBUS_PCI_VGA_3__ALIAS_1              NV_CONFIG_PCI_VGA_3 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000190C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001910 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_VGA_4(i)                     (0x00001810+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_4__SIZE_1                                 6 /*       */
#define NV_PBUS_PCI_VGA_4__ALIAS_1              NV_CONFIG_PCI_VGA_4 /*       */
#define NV_PBUS_PCI_NV_5(i)                      (0x00001914+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_5__SIZE_1                                  5 /*       */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_VGA_10(i)                    (0x00001828+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_10__SIZE_1                                2 /*       */
#define NV_PBUS_PCI_VGA_10__ALIAS_1            NV_CONFIG_PCI_VGA_10 /*       */
#define NV_PBUS_PCI_NV_10(i)                     (0x00001928+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_10__SIZE_1                                 2 /*       */
#define NV_PBUS_PCI_NV_10__ALIAS_1              NV_CONFIG_PCI_NV_10 /*       */
#define NV_PBUS_PCI_VGA_12                               0x00001830 /* RW-4R */
#define NV_PBUS_PCI_VGA_12__ALIAS_1            NV_CONFIG_PCI_VGA_12 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001930 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_VGA_13(i)                    (0x00001834+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_13__SIZE_1                                2 /*       */
#define NV_PBUS_PCI_VGA_13__ALIAS_1            NV_CONFIG_PCI_VGA_13 /*       */
#define NV_PBUS_PCI_NV_13(i)                     (0x00001934+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_13__SIZE_1                                 2 /*       */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_VGA_15                               0x0000183C /* RW-4R */
#define NV_PBUS_PCI_VGA_15__ALIAS_1            NV_CONFIG_PCI_VGA_15 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000193C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_VGA_16(i)                    (0x00001840+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_16__SIZE_1                               48 /*       */
#define NV_PBUS_PCI_VGA_16__ALIAS_1            NV_CONFIG_PCI_VGA_16 /*       */
#define NV_PBUS_PCI_NV_16(i)                     (0x00001940+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_16__SIZE_1                                48 /*       */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_FREE_LIE                              1:0 /* RWXVF */
#define NV_PFIFO_CONFIG_0_FREE_LIE_DISABLED              0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_252_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_508_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_1020_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */

//	Fix double-definition warning

#ifdef	NV_PFIFO_CACHE1_PUSH1
#undef	NV_PFIFO_CACHE1_PUSH1
#endif
#define NV_PFIFO_CACHE1_PUSH1                            0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* R--4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL1                            0x00003050 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL1_OBJECT                            8:8 /* RWXVF */
#define NV_PFIFO_CACHE0_PULL1_OBJECT_UNCHANGED           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_OBJECT_CHANGED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_SUBCHANNEL                        2:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_OBJECT                            8:8 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_OBJECT_UNCHANGED           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_OBJECT_CHANGED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003020 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003220 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003030 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_LIE                               24:24 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_LIE_DISABLED                 0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_LIE_ENABLED                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_DEVICE_ACCESS                                28:28 /* R--VF */
#define NV_PFIFO_DEVICE_ACCESS_DISABLED                  0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_ACCESS_ENABLED                   0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            13:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                    10:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    11:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_2                    12:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_3                    13:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_dma.ref */
#define NV_PDMA                               0x00100FFF:0x00100000 /* RW--D */
#define NV_PDMA_RM_INTR_0                                0x00100100 /* RW-4R */
#define NV_PDMA_RM_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0                                0x00100108 /* RW-4R */
#define NV_PDMA_AU_INTR_0_INSTANCE                              0:0 /* RWXVF */
#define NV_PDMA_AU_INTR_0_INSTANCE_NOT_PENDING           0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_INSTANCE_PENDING               0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_INSTANCE_RESET                 0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_PRESENT                               4:4 /* RWXVF */
#define NV_PDMA_AU_INTR_0_PRESENT_NOT_PENDING            0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_PRESENT_PENDING                0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_PRESENT_RESET                  0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_PROTECTION                            8:8 /* RWXVF */
#define NV_PDMA_AU_INTR_0_PROTECTION_NOT_PENDING         0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_PROTECTION_PENDING             0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_PROTECTION_RESET               0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0                                0x00100110 /* RW-4R */
#define NV_PDMA_GR_INTR_0_INSTANCE                              0:0 /* RWXVF */
#define NV_PDMA_GR_INTR_0_INSTANCE_NOT_PENDING           0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_INSTANCE_PENDING               0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_INSTANCE_RESET                 0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_PRESENT                               4:4 /* RWXVF */
#define NV_PDMA_GR_INTR_0_PRESENT_NOT_PENDING            0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_PRESENT_PENDING                0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_PRESENT_RESET                  0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_PROTECTION                            8:8 /* RWXVF */
#define NV_PDMA_GR_INTR_0_PROTECTION_NOT_PENDING         0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_PROTECTION_PENDING             0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_PROTECTION_RESET               0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_RM_INTR_EN_0                             0x00100140 /* RW-4R */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0                             0x00100148 /* RW-4R */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE                           0:0 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE_DISABLED           0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE_ENABLED            0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_PRESENT                            4:4 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_PRESENT_DISABLED            0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_PRESENT_ENABLED             0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION                         8:8 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION_DISABLED         0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION_ENABLED          0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0                             0x00100150 /* RW-4R */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE                           0:0 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE_DISABLED           0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE_ENABLED            0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_PRESENT                            4:4 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_PRESENT_DISABLED            0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_PRESENT_ENABLED             0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION                         8:8 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION_DISABLED         0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION_ENABLED          0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_AU_CONTROL                               0x00100600 /* RW-4R */
#define NV_PDMA_AU_CONTROL_ADJUST                              11:0 /* RWXUF */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE                         16:16 /* RWIVF */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE_NOT_PRESENT        0x00000000 /* RWI-V */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE_PRESENT            0x00000001 /* RW--V */
#define NV_PDMA_AU_CONTROL_LIMIT32                            20:20 /* RWXUF */
#define NV_PDMA_GR_CONTROL                               0x00100800 /* RW-4R */
#define NV_PDMA_GR_CONTROL_ADJUST                              11:0 /* RWXUF */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE                         16:16 /* RWIVF */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE_NOT_PRESENT        0x00000000 /* RWI-V */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE_PRESENT            0x00000001 /* RW--V */
#define NV_PDMA_GR_CONTROL_LIMIT32                            20:20 /* RWXUF */
#define NV_PDMA_AU_LIMIT                                 0x00100604 /* RW-4R */
#define NV_PDMA_AU_LIMIT_OFFSET                                31:0 /* RWXUF */
#define NV_PDMA_GR_LIMIT                                 0x00100804 /* RW-4R */
#define NV_PDMA_GR_LIMIT_OFFSET                                31:0 /* RWXUF */
#define NV_PDMA_AU_TLB_PTE                               0x00100608 /* RW-4R */
#define NV_PDMA_AU_TLB_PTE_PAGE                                 0:0 /* RWXVF */
#define NV_PDMA_AU_TLB_PTE_PAGE_NOT_PRESENT              0x00000000 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_PAGE_PRESENT                  0x00000001 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_ACCESS                               1:1 /* RWXVF */
#define NV_PDMA_AU_TLB_PTE_ACCESS_READ_ONLY              0x00000000 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_ACCESS_READ_WRITE             0x00000001 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_FRAME_ADDRESS                      31:12 /* RWXUF */
#define NV_PDMA_GR_TLB_PTE                               0x00100808 /* RW-4R */
#define NV_PDMA_GR_TLB_PTE_PAGE                                 0:0 /* RWXVF */
#define NV_PDMA_GR_TLB_PTE_PAGE_NOT_PRESENT              0x00000000 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_PAGE_PRESENT                  0x00000001 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_ACCESS                               1:1 /* RWXVF */
#define NV_PDMA_GR_TLB_PTE_ACCESS_READ_ONLY              0x00000000 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_ACCESS_READ_WRITE             0x00000001 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_FRAME_ADDRESS                      31:12 /* RWXUF */
#define NV_PDMA_AU_CHANNEL                               0x00100610 /* RW-4R */
#define NV_PDMA_AU_CHANNEL_ACCESS                               0:0 /* RWIVF */
#define NV_PDMA_AU_CHANNEL_ACCESS_DISABLED               0x00000000 /* RWI-V */
#define NV_PDMA_AU_CHANNEL_ACCESS_ENABLED                0x00000001 /* RW--V */
#define NV_PDMA_GR_CHANNEL                               0x00100810 /* RW-4R */
#define NV_PDMA_GR_CHANNEL_ACCESS                               0:0 /* RWIVF */
#define NV_PDMA_GR_CHANNEL_ACCESS_DISABLED               0x00000000 /* RWI-V */
#define NV_PDMA_GR_CHANNEL_ACCESS_ENABLED                0x00000001 /* RW--V */
#define NV_PDMA_RM_STATUS_0                              0x00100414 /* R--4R */
#define NV_PDMA_RM_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_RM_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_RM_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0                              0x00100614 /* R--4R */
#define NV_PDMA_AU_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_AU_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_AU_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE                         4:4 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE                         8:8 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE                       12:12 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_READ_STATE                        16:16 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_READ_STATE_IDLE              0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_READ_STATE_BUSY              0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE                      20:20 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE_IDLE            0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE_BUSY            0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0                              0x00100814 /* R--4R */
#define NV_PDMA_GR_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_GR_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_GR_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE                         4:4 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE                         8:8 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE                       12:12 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_READ_STATE                        16:16 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_READ_STATE_IDLE              0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_READ_STATE_BUSY              0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE                      20:20 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE_IDLE            0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE_BUSY            0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_1                              0x00100618 /* RW-4R */
#define NV_PDMA_AU_STATUS_1_CONTROL                             0:0 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_CONTROL_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_AU_STATUS_1_CONTROL_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_OFFSET                              4:4 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_OFFSET_INVALID               0x00000000 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_OFFSET_VALID                 0x00000001 /* RW--V */
#define NV_PDMA_AU_STATUS_1_TLB_PTE                             8:8 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_TLB_PTE_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_AU_STATUS_1_TLB_PTE_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_ADJ_OFFSET32                      12:12 /* RWXUF */
#define NV_PDMA_GR_STATUS_1                              0x00100818 /* RW-4R */
#define NV_PDMA_GR_STATUS_1_CONTROL                             0:0 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_CONTROL_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_GR_STATUS_1_CONTROL_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_OFFSET                              4:4 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_OFFSET_INVALID               0x00000000 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_OFFSET_VALID                 0x00000001 /* RW--V */
#define NV_PDMA_GR_STATUS_1_TLB_PTE                             8:8 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_TLB_PTE_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_GR_STATUS_1_TLB_PTE_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_ADJ_OFFSET32                      12:12 /* RWXUF */
#define NV_PDMA_AU_TLB_TAG                               0x00100620 /* RW-4R */
#define NV_PDMA_AU_TLB_TAG_ADDRESS                            31:12 /* RWXUF */
#define NV_PDMA_GR_TLB_TAG                               0x00100820 /* RW-4R */
#define NV_PDMA_GR_TLB_TAG_ADDRESS                            31:12 /* RWXUF */
#define NV_PDMA_AU_ADJ_OFFSET                            0x00100630 /* RW-4R */
#define NV_PDMA_AU_ADJ_OFFSET_VALUE                            31:0 /* RWXUF */
#define NV_PDMA_GR_ADJ_OFFSET                            0x00100830 /* RW-4R */
#define NV_PDMA_GR_ADJ_OFFSET_VALUE                            31:0 /* RWXUF */
#define NV_PDMA_RM_PHY_START                             0x00100440 /* RW-4R */
#define NV_PDMA_RM_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_AU_PHY_START                             0x00100640 /* RW-4R */
#define NV_PDMA_AU_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_GR_PHY_START                             0x00100840 /* RW-4R */
#define NV_PDMA_GR_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_RM_BUFF_OUT(i)                   (0x00100500+(i)*4) /* RW-4A */
#define NV_PDMA_RM_BUFF_OUT__SIZE_1                               1 /*       */
#define NV_PDMA_RM_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_AU_BUFF_OUT(i)                   (0x00100700+(i)*4) /* RW-4A */
#define NV_PDMA_AU_BUFF_OUT__SIZE_1                               4 /*       */
#define NV_PDMA_AU_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_GR_BUFF_OUT(i)                   (0x00100900+(i)*4) /* RW-4A */
#define NV_PDMA_GR_BUFF_OUT__SIZE_1                               8 /*       */
#define NV_PDMA_GR_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_BUFF_IN(i)                       (0x00100580+(i)*4) /* RW-4A */
#define NV_PDMA_BUFF_IN__SIZE_1                                   8 /*       */
#define NV_PDMA_BUFF_IN_DATA                                   31:0 /* RWXVF */
#define NV_PDMA_AU_INSTANCE                              0x00100680 /* RW-4R */
#define NV_PDMA_AU_INSTANCE_ID                                 15:0 /* RWIUF */
#define NV_PDMA_AU_INSTANCE_ID_0                         0x00000000 /* RWI-V */
#define NV_PDMA_GR_INSTANCE                              0x00100880 /* RW-4R */
#define NV_PDMA_GR_INSTANCE_ID                                 15:0 /* RWIUF */
#define NV_PDMA_GR_INSTANCE_ID_0                         0x00000000 /* RWI-V */
#define NV_PDMA_AU_OFFSET                                0x00100690 /* -W-4R */
#define NV_PDMA_AU_OFFSET_VALUE                                31:0 /* -W-UF */
#define NV_PDMA_GR_OFFSET                                0x00100890 /* -W-4R */
#define NV_PDMA_GR_OFFSET_VALUE                                31:0 /* -W-UF */
#define NV_PDMA_AU_OUT8                                  0x001006A0 /* -W-1R */
#define NV_PDMA_AU_OUT8_DATA                                    7:0 /* -W-VF */
#define NV_PDMA_AU_OUT16                                 0x001006A0 /* -W-2R */
#define NV_PDMA_AU_OUT16_DATA                                  15:0 /* -W-VF */
#define NV_PDMA_AU_OUT32                                 0x001006A0 /* -W-4R */
#define NV_PDMA_AU_OUT32_DATA                                  31:0 /* -W-VF */
#define NV_PDMA_GR_OUT8                                  0x001008A0 /* -W-1R */
#define NV_PDMA_GR_OUT8_DATA                                    7:0 /* -W-VF */
#define NV_PDMA_GR_OUT16                                 0x001008A0 /* -W-2R */
#define NV_PDMA_GR_OUT16_DATA                                  15:0 /* -W-VF */
#define NV_PDMA_GR_OUT32                                 0x001008A0 /* -W-4R */
#define NV_PDMA_GR_OUT32_DATA                                  31:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH8                                0x001004B0 /* -W-1R */
#define NV_PDMA_RM_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH16                               0x001004B0 /* -W-2R */
#define NV_PDMA_RM_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH32                               0x001004B0 /* -W-4R */
#define NV_PDMA_RM_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH8                                0x001006B0 /* -W-1R */
#define NV_PDMA_AU_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH16                               0x001006B0 /* -W-2R */
#define NV_PDMA_AU_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH32                               0x001006B0 /* -W-4R */
#define NV_PDMA_AU_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH8                                0x001008B0 /* -W-1R */
#define NV_PDMA_GR_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH16                               0x001008B0 /* -W-2R */
#define NV_PDMA_GR_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH32                               0x001008B0 /* -W-4R */
#define NV_PDMA_GR_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH_BUFF                            0x001006C0 /* -W-4R */
#define NV_PDMA_AU_FLUSH_BUFF_NOW                              31:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH_BUFF                            0x001008C0 /* -W-4R */
#define NV_PDMA_GR_FLUSH_BUFF_NOW                              31:0 /* -W-VF */
#define NV_PDMA_RM_IN                                    0x001004D0 /* -W-4R */
#define NV_PDMA_RM_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_AU_IN                                    0x001006D0 /* -W-4R */
#define NV_PDMA_AU_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_GR_IN                                    0x001008D0 /* -W-4R */
#define NV_PDMA_GR_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_AU_NOTIFY                                0x001006E0 /* -W-4R */
#define NV_PDMA_AU_NOTIFY_INSTANCE                             15:0 /* -W-UF */
#define NV_PDMA_GR_NOTIFY                                0x001008E0 /* -W-4R */
#define NV_PDMA_GR_NOTIFY_INSTANCE                             15:0 /* -W-UF */
/* dev_timer.ref */
#define NV_PTIMER                             0x00101FFF:0x00101000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00101100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00101140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00101200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00101210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00101400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00101404 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00101410 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_audio.ref */
#define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
#define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
#define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
#define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
#define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
#define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
#define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
#define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
#define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
#define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
#define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
#define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_CONTEXT                                0x00300A08 /* RW-4R */
#define NV_PAUDIO_CONTEXT_INSTANCE                             15:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
#define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_RATIO                             13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_NEW_RATIO_1X                     0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_2X                     0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_4X                     0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_8X                     0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
#define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO                          13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_1X                  0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_2X                  0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_4X                  0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_8X                  0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP                             0x00300208 /* RW-4R */
#define NV_PAUDIO_BLOCK_PUMP_LENGTH                             7:0 /* R-XUF */
#define NV_PAUDIO_BLOCK_PUMP_RATIO                            13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_1X                    0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_2X                    0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_4X                    0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_8X                    0x00000003 /* RW--V */
#define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
#define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
#define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
#define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
#define NV_PAUDIO_TERMINATION                            0x00300980 /* RW-4R */
#define NV_PAUDIO_TERMINATION_LEVEL                            15:0 /* RWXUF */
#define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
#define NV_PAUDIO_USAGE                                  0x0030080C /* RW-4R */
#define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
#define NV_PAUDIO_CODEC(i)                      (0x00300500+(i)*16) /* RW-4A */
#define NV_PAUDIO_CODEC__SIZE_1                                   4 /*       */
#define NV_PAUDIO_CODEC_DATA                                    7:0 /* RW-VF */
#define NV_PAUDIO_CACHE_ANALOG                           0x00300600 /* -W-4R */
#define NV_PAUDIO_CACHE_ANALOG_CHANNEL_0                       15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_ANALOG_CHANNEL_1                      31:16 /* -W-VF */
#define NV_PAUDIO_CACHE_INPUT                            0x00300610 /* -W-4R */
#define NV_PAUDIO_CACHE_INPUT_CHANNEL_0                        15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_INPUT_CHANNEL_1                       31:16 /* -W-VF */
#define NV_PAUDIO_CACHE_OUTPUT                           0x00300620 /* -W-4R */
#define NV_PAUDIO_CACHE_OUTPUT_CHANNEL_0                       15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_OUTPUT_CHANNEL_1                      31:16 /* -W-VF */
#define NV_PAUDIO_FETCH(i)                       (0x00300640+(i)*4) /* -W-4A */
#define NV_PAUDIO_FETCH__SIZE_1                                   4 /*       */
#define NV_PAUDIO_FETCH_DATA                                   31:0 /* -W-VF */
#define NV_PAUDIO_TIME_RETURN(i)                 (0x00300660+(i)*4) /* -W-4A */
#define NV_PAUDIO_TIME_RETURN__SIZE_1                             2 /*       */
#define NV_PAUDIO_TIME_RETURN_VALUE                            31:0 /* -W-VF */
#define NV_PAUDIO_HEADER(i)                      (0x00300680+(i)*4) /* -W-4A */
#define NV_PAUDIO_HEADER__SIZE_1                                 32 /*       */
#define NV_PAUDIO_HEADER_DATA                                  31:0 /* -W-VF */
#define NV_PAUDIO_ROOT_INPUT                             0x00300800 /* RW-4R */
#define NV_PAUDIO_ROOT_INPUT_INSTANCE                          15:0 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT                            0x00300804 /* RW-4R */
#define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         15:0 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE                              0x00300808 /* RW-4R */
#define NV_PAUDIO_ROOT_NOTE_INSTANCE                           15:0 /* RWXUF */
#define NV_PAUDIO_DIAG(i)                        (0x0030080C+(i)*4) /* RW-4A */
#define NV_PAUDIO_DIAG__SIZE_1                                  253 /*       */
#define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00400FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLOCK                                 8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLOCK_DISABLED                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLOCK_ENABLED                  0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD                      16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS                     20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_BI_RECTS                              8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_BI_RECTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_BI_RECTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK                          16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS                      20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF                     24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_FAST_BUS                            28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_FAST_BUS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_FAST_BUS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_HIRES_TM                            29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_HIRES_TM_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_HIRES_TM_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT                           4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT                          12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL                     16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE                       20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008c /* RW-4R */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT                    0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE3                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE3_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE3_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE4                              20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE4_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE4_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE5                              24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE5_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE5_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE6                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE6_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE6_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_SOFTWARE                             20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_SOFTWARE_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_SOFTWARE_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_SOFTWARE_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST                            8:8 /* RWIVF */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE                          20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST                         8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_INSTANCE                          15:0 /* RW-VF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                       4:0 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                         5:5 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM                       5:5 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM_DISABLED       0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                         6:6 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                          7:7 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY                             8:8 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY_INVALID              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY_VALID                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER                      12:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                            13:13 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SOURCE_BUFFER                    13:13 /* RW-VF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                      14:14 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_LE              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_CGA6            0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_ID                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_ID_0                  0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHID                             22:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHID_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_OBJECT                           31:31 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_OBJECT_UNCHANGED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_OBJECT_CHANGED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_MISC                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_MISC_FIFO                                     0:0 /* RWIVF */
#define NV_PGRAPH_MISC_FIFO_DISABLED                     0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_FIFO_ENABLED                      0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_DMA                                      4:4 /* RWIVF */
#define NV_PGRAPH_MISC_DMA_DISABLED                      0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_DMA_ENABLED                       0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_FLOWTHRU                                 8:8 /* RWIVF */
#define NV_PGRAPH_MISC_FLOWTHRU_DISABLED                 0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_FLOWTHRU_ENABLED                  0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_CLASS                                  16:12 /* RWXVF */
#define NV_PGRAPH_MISC_FIFO_WRITE                             24:24 /* CW-VF */
#define NV_PGRAPH_MISC_FIFO_WRITE_IGNORED                0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_FIFO_WRITE_ENABLED                0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_DMA_WRITE                              25:25 /* CW-VF */
#define NV_PGRAPH_MISC_DMA_WRITE_IGNORED                 0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_DMA_WRITE_ENABLED                 0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE                         26:26 /* CW-VF */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE_IGNORED            0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE_ENABLED            0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_CLASS_WRITE                            27:27 /* CW-VF */
#define NV_PGRAPH_MISC_CLASS_WRITE_IGNORED               0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_CLASS_WRITE_ENABLED               0x00000001 /* CW--V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_FIFO                            24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_FIFO_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_FIFO_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006A8 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_VALUE                           20:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006AC /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_CANVAS_MISC                            0x00400634 /* RW-4R */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS                        0:0 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS_DISABLED        0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_RETAINED                          4:4 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_RETAINED_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_RETAINED_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE                      12:12 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE_SINGLE          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE_TRIPLE          0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DITHER                          16:16 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DITHER_DISABLED            0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DITHER_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE                       20:20 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE                        24:24 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MIN                             0x00400688 /* RW-4R */
#define NV_PGRAPH_CANVAS_MIN_X                                 15:0 /* RWXSF */
#define NV_PGRAPH_CANVAS_MIN_Y                                31:16 /* RWXSF */
#define NV_PGRAPH_CANVAS_MAX                             0x0040068C /* RW-4R */
#define NV_PGRAPH_CANVAS_MAX_X                                 11:0 /* RWXUF */
#define NV_PGRAPH_CANVAS_MAX_Y                                27:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_WRITE                                16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_WRITE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_WRITE_PENDING                   0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_INTERRUPT                            20:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_INTERRUPT_NOT_PENDING           0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_INTERRUPT_PENDING               0x00000001 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1                            0x00400620 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR1_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400630 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_REL_X_RAM(i)                   (0x00400500+(i)*4) /* RW-4A */
#define NV_PGRAPH_REL_X_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_REL_X_RAM_VALUE                              31:0 /* -W-UF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            18 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_REL_Y_RAM(i)                   (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_REL_Y_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_REL_Y_RAM_VALUE                              31:0 /* -W-UF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            18 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400640 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_MINOR                          8:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_MINOR_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    12:12 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_MAJOR                        24:16 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_MAJOR_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400644 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE                     0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE_NEEDED       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE_DONE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX                     4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX_NOTNULL      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX_NULL         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY                     5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY_NOTNULL      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY_NULL         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE                   20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE_CLIPMAX      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE_IMAGEMAX     0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG                24:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG_SET       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG_CLR       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT                    25:25 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400648 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN                              9:8 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX                            11:10 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN                            13:12 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX                            15:14 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x0040064c /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN                              9:8 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX                            11:10 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN                            13:12 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX                            15:14 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x00400460 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_XMIN                         0x00400560 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_XMIN_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400464 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_XMAX                         0x00400564 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_XMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400468 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_YMIN                         0x00400568 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_YMIN_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x0040046C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_YMAX                         0x0040056C /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_YMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_SOURCE_COLOR                           0x00400654 /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE                              0x00400658 /* RW-4R */
#define NV_PGRAPH_SUBDIVIDE_BTM_MAJOR_0123                      3:0 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_MAJOR_0268                      3:0 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_MINOR_0213                      7:4 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_MINOR_0628                      7:4 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_01                       19:16 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_02                       19:16 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_23                       23:20 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_68                       23:20 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_02                       27:24 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_06                       27:24 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_13                       31:28 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_28                       31:28 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BY_1                         0x00000000 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_2                         0x00000001 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_4                         0x00000002 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_8                         0x00000003 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_16                        0x00000004 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_32                        0x00000005 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_64                        0x00000006 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_128                       0x00000007 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_256                       0x00000008 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS                             0x00400650 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_X_VALID                            8:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_X_VALID_0                   0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_Y_VALID                          20:12 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_Y_VALID_0                   0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY                          24:24 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY_NO_ERROR            0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY_ONLY                0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH                          28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH_NO_ERROR            0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH_ONLY                0x00000001 /* RW--V */
#define NV_PGRAPH_EDGEFILL                               0x0040065c /* RW-4R */
#define NV_PGRAPH_EDGEFILL_STAGE                                1:0 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_STAGE_FIRST_STRIP             0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_STAGE_MIDDLE_STRIPS           0x00000001 /* RW--V */
#define NV_PGRAPH_EDGEFILL_STAGE_LAST_STRIP              0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_FIRST_MAJMIN                         4:4 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_FIRST_MINMAJ                         8:8 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_X16_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X16_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X16_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X16_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X16_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MIN                            25:24 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X17_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X17_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MAX                            27:26 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X17_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X17_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN                            29:28 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX                            31:30 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_BETA_RAM(i)                    (0x00400700+(i)*4) /* RW-4A */
#define NV_PGRAPH_BETA_RAM__SIZE_1                               14 /*       */
#define NV_PGRAPH_BETA_RAM_VALUE                               24:0 /* RWXUF */
#define NV_PGRAPH_BETA_RAM_BPORT(i)              (0x00400d00+(i)*4) /* R--4A */
#define NV_PGRAPH_BETA_RAM_BPORT__SIZE_1                         14 /*       */
#define NV_PGRAPH_BETA_RAM_BPORT_VALUE                         24:0 /* R--UF */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400450 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_ICLIP_XMAX                         0x00400550 /* -W-4R */
#define NV_PGRAPH_REL_ICLIP_XMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400454 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_ICLIP_YMAX                         0x00400554 /* -W-4R */
#define NV_PGRAPH_REL_ICLIP_YMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_BIT33                                  0x00400660 /* RW-4R */
#define NV_PGRAPH_BIT33_X_REG0                                  0:0 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG3                                  1:1 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG6                                  2:2 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG9                                  3:3 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG12                                 4:4 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG15                                 5:5 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG16                                 6:6 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG17                                 7:7 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG0                                16:16 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG3                                17:17 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG6                                18:18 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG9                                19:19 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG12                               20:20 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG15                               21:21 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG16                               22:22 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG17                               23:23 /* RWXVF */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_3                                0x0040008c /* RW-4R */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_MISC                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006A8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006AC /* R--4R */
#define NV_PGRAPH_CANVAS_MISC                            0x00400634 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CANVAS_MIN                             0x00400688 /* RW-4R */
#define NV_PGRAPH_CANVAS_MAX                             0x0040068C /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR1                            0x00400620 /* RW-4R */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_BETA                                   0x00400630 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400640 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400644 /* RW-4R */
#define NV_PGRAPH_X_MISC                                 0x00400648 /* RW-4R */
#define NV_PGRAPH_Y_MISC                                 0x0040064c /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x00400460 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_XMIN                         0x00400560 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400464 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_XMAX                         0x00400564 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400468 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_YMIN                         0x00400568 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x0040046C /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_YMAX                         0x0040056C /* -W-4R */
#define NV_PGRAPH_SOURCE_COLOR                           0x00400654 /* RW-4R */
#define NV_PGRAPH_SUBDIVIDE                              0x00400658 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS                             0x00400650 /* RW-4R */
#define NV_PGRAPH_EDGEFILL                               0x0040065c /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400450 /* RW-4R */
#define NV_PGRAPH_REL_ICLIP_XMAX                         0x00400550 /* -W-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400454 /* RW-4R */
#define NV_PGRAPH_REL_ICLIP_YMAX                         0x00400554 /* -W-4R */
#define NV_PGRAPH_BIT33                                  0x00400660 /* RW-4R */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x004C1FFF:0x004C0000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x004C0000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x004C0104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x004C0304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x004C0400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x004C0404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_bilinear.ref */
#define NV_UBTM                               0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UBTM_CTX_SWITCH                               0x004D0000 /* -W-4R */
#define NV_UBTM_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UBTM_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UBTM_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UBTM_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UBTM_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UBTM_SET_NOTIFY                               0x004D0104 /* -W-4R */
#define NV_UBTM_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UBTM_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN                             0x004D0304 /* -W-4R */
#define NV_UBTM_SUBDIVIDE_IN_MAJOR_0123                         3:0 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_MINOR_0213                         7:4 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_01                          19:16 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_23                          23:20 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_02                          27:24 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_13                          31:28 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_BY_1                        0x00000000 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_2                        0x00000001 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_4                        0x00000002 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_8                        0x00000003 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_16                       0x00000004 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_32                       0x00000005 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_64                       0x00000006 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_128                      0x00000007 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_256                      0x00000008 /* -W--V */
#define NV_UBTM_POINT_OUT(i)                     (0x004D0310+(i)*4) /* -W-4A */
#define NV_UBTM_POINT_OUT__SIZE_1                                 4 /*       */
#define NV_UBTM_POINT_OUT_X                                    15:0 /* -W-SF */
#define NV_UBTM_POINT_OUT_Y                                   31:16 /* -W-SF */
#define NV_UBTM_POINT_OUT12D4(i)                 (0x004D0350+(i)*4) /* -W-4A */
#define NV_UBTM_POINT_OUT12D4__SIZE_1                             4 /*       */
#define NV_UBTM_POINT_OUT12D4_X_FRACTION                        3:0 /* -W-UF */
#define NV_UBTM_POINT_OUT12D4_X                                15:4 /* -W-SF */
#define NV_UBTM_POINT_OUT12D4_Y_FRACTION                      19:16 /* -W-UF */
#define NV_UBTM_POINT_OUT12D4_Y                               31:20 /* -W-SF */
#define NV_UBTM_COLOR(i)                         (0x004D0400+(i)*4) /* -W-4A */
#define NV_UBTM_COLOR__SIZE_1                                    32 /*       */
#define NV_UBTM_COLOR_VALUE                                    31:0 /* -W-VF */
/* usr_quadratic.ref */
#define NV_UQTM                               0x004E1FFF:0x004E0000 /* -W--D */
#define NV_UQTM_CTX_SWITCH                               0x004E0000 /* -W-4R */
#define NV_UQTM_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UQTM_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UQTM_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UQTM_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UQTM_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UQTM_SET_NOTIFY                               0x004E0104 /* -W-4R */
#define NV_UQTM_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UQTM_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN                             0x004E0304 /* -W-4R */
#define NV_UQTM_SUBDIVIDE_IN_MAJOR_0268                         3:0 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_MINOR_0628                         7:4 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_02                          19:16 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_68                          23:20 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_06                          27:24 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_28                          31:28 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_BY_1                        0x00000000 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_2                        0x00000001 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_4                        0x00000002 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_8                        0x00000003 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_16                       0x00000004 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_32                       0x00000005 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_64                       0x00000006 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_128                      0x00000007 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_256                      0x00000008 /* -W--V */
#define NV_UQTM_POINT_OUT(i)                     (0x004E0310+(i)*4) /* -W-4A */
#define NV_UQTM_POINT_OUT__SIZE_1                                 9 /*       */
#define NV_UQTM_POINT_OUT_X                                    15:0 /* -W-SF */
#define NV_UQTM_POINT_OUT_Y                                   31:16 /* -W-SF */
#define NV_UQTM_POINT_OUT12D4(i)                 (0x004E0350+(i)*4) /* -W-4A */
#define NV_UQTM_POINT_OUT12D4__SIZE_1                             9 /*       */
#define NV_UQTM_POINT_OUT12D4_X_FRACTION                        3:0 /* -W-UF */
#define NV_UQTM_POINT_OUT12D4_X                                15:4 /* -W-SF */
#define NV_UQTM_POINT_OUT12D4_Y_FRACTION                      19:16 /* -W-UF */
#define NV_UQTM_POINT_OUT12D4_Y                               31:20 /* -W-SF */
#define NV_UQTM_COLOR(i)                         (0x004E0400+(i)*4) /* -W-4A */
#define NV_UQTM_COLOR__SIZE_1                                    32 /*       */
#define NV_UQTM_COLOR_VALUE                                    31:0 /* -W-VF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_from_mem.ref */
#define NV_UFROMEM                            0x00531FFF:0x00530000 /* -W--D */
#define NV_UFROMEM_CTX_SWITCH                            0x00530000 /* -W-4R */
#define NV_UFROMEM_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UFROMEM_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UFROMEM_DMA_REPLY(i)                  (0x00530040+(i)*4) /* -W-4A */
#define NV_UFROMEM_DMA_REPLY__SIZE_1                             16 /*       */
#define NV_UFROMEM_DMA_REPLY_DATA                              31:0 /* -W-VF */
#define NV_UFROMEM_SET_NOTIFY                            0x00530104 /* -W-4R */
#define NV_UFROMEM_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UFROMEM_POINT                                 0x00530308 /* -W-4R */
#define NV_UFROMEM_POINT_X                                     15:0 /* -W-SF */
#define NV_UFROMEM_POINT_Y                                    31:16 /* -W-SF */
#define NV_UFROMEM_SIZE                                  0x0053030C /* -W-4R */
#define NV_UFROMEM_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UFROMEM_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UFROMEM_PITCH                                 0x00530310 /* -W-4R */
#define NV_UFROMEM_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_UFROMEM_IMAGE_START                           0x00530314 /* -W-4R */
#define NV_UFROMEM_PITCH_START_OFFSET                          31:0 /* -W-UF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_bilinear_beta.ref */
#define NV_UBTMB                              0x005D1FFF:0x005D0000 /* -W--D */
#define NV_UBTMB_CTX_SWITCH                              0x005D0000 /* -W-4R */
#define NV_UBTMB_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBTMB_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBTMB_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBTMB_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBTMB_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBTMB_SET_NOTIFY                              0x005D0104 /* -W-4R */
#define NV_UBTMB_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBTMB_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN                            0x005D0304 /* -W-4R */
#define NV_UBTMB_SUBDIVIDE_IN_MAJOR_0123                        3:0 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_MINOR_0213                        7:4 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_01                         19:16 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_23                         23:20 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_02                         27:24 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_13                         31:28 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_BY_1                       0x00000000 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_2                       0x00000001 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_4                       0x00000002 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_8                       0x00000003 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_16                      0x00000004 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_32                      0x00000005 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_64                      0x00000006 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_128                     0x00000007 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_256                     0x00000008 /* -W--V */
#define NV_UBTMB_POINT_OUT(i)                    (0x005D0310+(i)*4) /* -W-4A */
#define NV_UBTMB_POINT_OUT__SIZE_1                                4 /*       */
#define NV_UBTMB_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBTMB_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBTMB_POINT_OUT12D4(i)                (0x005D0350+(i)*4) /* -W-4A */
#define NV_UBTMB_POINT_OUT12D4__SIZE_1                            4 /*       */
#define NV_UBTMB_POINT_OUT12D4_X_FRACTION                       3:0 /* -W-UF */
#define NV_UBTMB_POINT_OUT12D4_X                               15:4 /* -W-SF */
#define NV_UBTMB_POINT_OUT12D4_Y_FRACTION                     19:16 /* -W-UF */
#define NV_UBTMB_POINT_OUT12D4_Y                              31:20 /* -W-SF */
#define NV_UBTMB_BETA(i)                         (0x005D0380+(i)*4) /* -W-4A */
#define NV_UBTMB_BETA__SIZE_1                                     2 /*       */
#define NV_UBTMB_BETA_VALUE_0_FRACTION                         14:0 /* -W-UF */
#define NV_UBTMB_BETA_VALUE_0                                 15:15 /* -W-SF */
#define NV_UBTMB_BETA_VALUE_1_FRACTION                        30:16 /* -W-UF */
#define NV_UBTMB_BETA_VALUE_1                                 31:31 /* -W-SF */
#define NV_UBTMB_COLOR(i)                        (0x005D0400+(i)*4) /* -W-4A */
#define NV_UBTMB_COLOR__SIZE_1                                   32 /*       */
#define NV_UBTMB_COLOR_VALUE                                   31:0 /* -W-VF */
/* usr_quadratic_beta.ref */
#define NV_UQTMB                              0x005E1FFF:0x005E0000 /* -W--D */
#define NV_UQTMB_CTX_SWITCH                              0x005E0000 /* -W-4R */
#define NV_UQTMB_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UQTMB_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UQTMB_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UQTMB_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UQTMB_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UQTMB_SET_NOTIFY                              0x005E0104 /* -W-4R */
#define NV_UQTMB_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UQTMB_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN                            0x005E0304 /* -W-4R */
#define NV_UQTMB_SUBDIVIDE_IN_MAJOR_0268                        3:0 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_MINOR_0628                        7:4 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_02                         19:16 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_68                         23:20 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_06                         27:24 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_28                         31:28 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_BY_1                       0x00000000 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_2                       0x00000001 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_4                       0x00000002 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_8                       0x00000003 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_16                      0x00000004 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_32                      0x00000005 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_64                      0x00000006 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_128                     0x00000007 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_256                     0x00000008 /* -W--V */
#define NV_UQTMB_POINT_OUT(i)                    (0x005E0310+(i)*4) /* -W-4A */
#define NV_UQTMB_POINT_OUT__SIZE_1                                9 /*       */
#define NV_UQTMB_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UQTMB_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UQTMB_POINT_OUT12D4(i)                (0x005E0350+(i)*4) /* -W-4A */
#define NV_UQTMB_POINT_OUT12D4__SIZE_1                            9 /*       */
#define NV_UQTMB_POINT_OUT12D4_X_FRACTION                       3:0 /* -W-UF */
#define NV_UQTMB_POINT_OUT12D4_X                               15:4 /* -W-SF */
#define NV_UQTMB_POINT_OUT12D4_Y_FRACTION                     19:16 /* -W-UF */
#define NV_UQTMB_POINT_OUT12D4_Y                              31:20 /* -W-SF */
#define NV_UQTMB_BETA(i)                         (0x005E0380+(i)*4) /* -W-4A */
#define NV_UQTMB_BETA__SIZE_1                                     5 /*       */
#define NV_UQTMB_BETA_VALUE_0_FRACTION                         14:0 /* -W-UF */
#define NV_UQTMB_BETA_VALUE_0                                 15:15 /* -W-SF */
#define NV_UQTMB_BETA_VALUE_1_FRACTION                        30:16 /* -W-UF */
#define NV_UQTMB_BETA_VALUE_1                                 31:31 /* -W-SF */
#define NV_UQTMB_COLOR(i)                        (0x005E0400+(i)*4) /* -W-4A */
#define NV_UQTMB_COLOR__SIZE_1                                   32 /*       */
#define NV_UQTMB_COLOR_VALUE                                   31:0 /* -W-VF */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00600FFF:0x00600000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00600000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_DAC_WIDTH                                 9:8 /* RWXVF */
#define NV_PFB_BOOT_0_DAC_WIDTH_16_BIT                   0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_DAC_WIDTH_32_BIT                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_DAC_WIDTH_64_BIT                   0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAS_PRECHARGE                           12:12 /* RWIVF */
#define NV_PFB_BOOT_0_RAS_PRECHARGE_3_CYCLES             0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAS_PRECHARGE_2_CYCLES             0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE                          17:16 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_BY_8                0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_BY_4                0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT                       20:20 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_VRAM_SAM                                24:24 /* RWIVF */
#define NV_PFB_BOOT_0_VRAM_SAM_8192_BIT                  0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_VRAM_SAM_4096_BIT                  0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE                          28:28 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE_ENABLED             0x00000001 /* RW--V */
#define NV_PFB_DELAY_0                                   0x00600040 /* RW-4R */
#define NV_PFB_DELAY_0_SYNC                                     4:0 /* RWIUF */
#define NV_PFB_DELAY_0_SYNC_0                            0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_DSF                                      9:8 /* RWIUF */
#define NV_PFB_DELAY_0_DSF_0                             0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_SOE_RISE                               13:12 /* RWIUF */
#define NV_PFB_DELAY_0_SOE_RISE_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_SOE_FALL                               17:16 /* RWIUF */
#define NV_PFB_DELAY_0_SOE_FALL_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_LOAD_CLK                               25:20 /* RWIUF */
#define NV_PFB_DELAY_0_LOAD_CLK_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1                                   0x00600044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_ENABLE                            9:8 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_ENABLE_0                   0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00600080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SELFTIME                                 8:8 /* RWIVF */
#define NV_PFB_DEBUG_0_SELFTIME_ENABLED                  0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SELFTIME_DISABLED                 0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_TRANSFER                               12:12 /* RWIVF */
#define NV_PFB_DEBUG_0_TRANSFER_ENABLED                  0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_TRANSFER_DISABLED                 0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY                     16:16 /* RWIVF */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY_DISABLED       0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY_ENABLED        0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_FIFO_DRAIN_HINT                        31:24 /* RWIUF */
#define NV_PFB_DEBUG_0_FIFO_DRAIN_HINT_0                 0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0                                   0x006000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_HSYNC                            17:16 /* RWIVF */
#define NV_PFB_GREEN_0_POLAR_HSYNC_HIGH                  0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_LOW                   0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_POSITIVE              0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_NEGATIVE              0x00000003 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC                            21:20 /* RWIVF */
#define NV_PFB_GREEN_0_POLAR_VSYNC_LOW                   0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_HIGH                  0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_POSITIVE              0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_NEGATIVE              0x00000003 /* RW--V */
#define NV_PFB_GREEN_0_CSYNC                                  24:24 /* RWIVF */
#define NV_PFB_GREEN_0_CSYNC_DISABLED                    0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_CSYNC_ENABLED                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0                                  0x00600200 /* RW-4R */
#define NV_PFB_CONFIG_0_VERTICAL                                0:0 /* R-XVF */
#define NV_PFB_CONFIG_0_VERTICAL_DISPLAY                 0x00000000 /* R---V */
#define NV_PFB_CONFIG_0_VERTICAL_BLANK                   0x00000001 /* R---V */
#define NV_PFB_CONFIG_0_RESOLUTION                              6:4 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_576_PIXELS            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_4_BITS               0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_SECOND_BUFFER                         12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_SECOND_BUFFER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_SECOND_BUFFER_ENABLED            0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT                           18:16 /* RWIVF */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_DISABLED             0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_4_LINES              0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_8_LINES              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_16_LINES             0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_32_LINES             0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_SCANLINE                              20:20 /* RWIVF */
#define NV_PFB_CONFIG_0_SCANLINE_NO_DUPLICATE            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_SCANLINE_DUPLICATE               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO                       26:24 /* RWIVF */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_1_TO_1           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_2_TO_1           0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_4_TO_1           0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_8_TO_1           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_16_TO_1          0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_STEREOSCOPIC                          28:28 /* RWIVF */
#define NV_PFB_CONFIG_0_STEREOSCOPIC_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_STEREOSCOPIC_ENABLED             0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00600204 /* RW-4R */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK                           0:0 /* RWIVF */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK_512_BITS           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK_2048_BITS          0x00000001 /* RW--V */
#define NV_PFB_START                                     0x00600400 /* RW-4R */
#define NV_PFB_START_ADDRESS                                   21:1 /* RWIUF */
#define NV_PFB_START_ADDRESS_0                           0x00000000 /* RWI-V */
#define NV_PFB_HOR_FRNT_PORCH                            0x00600500 /* RW-4R */
#define NV_PFB_HOR_FRNT_PORCH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_FRNT_PORCH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_SYNC_WIDTH                            0x00600510 /* RW-4R */
#define NV_PFB_HOR_SYNC_WIDTH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_SYNC_WIDTH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_BACK_PORCH                            0x00600520 /* RW-4R */
#define NV_PFB_HOR_BACK_PORCH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_BACK_PORCH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_DISP_WIDTH                            0x00600530 /* RW-4R */
#define NV_PFB_HOR_DISP_WIDTH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_DISP_WIDTH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_VER_FRNT_PORCH                            0x00600540 /* RW-4R */
#define NV_PFB_VER_FRNT_PORCH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_FRNT_PORCH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_SYNC_WIDTH                            0x00600550 /* RW-4R */
#define NV_PFB_VER_SYNC_WIDTH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_SYNC_WIDTH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_BACK_PORCH                            0x00600560 /* RW-4R */
#define NV_PFB_VER_BACK_PORCH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_BACK_PORCH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_DISP_WIDTH                            0x00600570 /* RW-4R */
#define NV_PFB_VER_DISP_WIDTH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_DISP_WIDTH_LINES_1                    0x00000001 /* RWI-V */
/* dev_ram.ref */
#define NV_PRAM                               0x00602FFF:0x00602000 /* RW--D */
#define NV_PRAM_CONFIG_0                                 0x00602200 /* RW-4R */
#define NV_PRAM_CONFIG_0_SIZE                                   1:0 /* RWIVF */
#define NV_PRAM_CONFIG_0_SIZE_12KB                       0x00000000 /* RWI-V */
#define NV_PRAM_CONFIG_0_SIZE_20KB                       0x00000001 /* RW--V */
#define NV_PRAM_CONFIG_0_SIZE_36KB                       0x00000002 /* RW--V */
#define NV_PRAM_CONFIG_0_SIZE_68KB                       0x00000003 /* RW--V */
#define NV_PRAM_HASH_VIRTUAL(i)                  (0x00602400+(i)*4) /* -W-4A */
#define NV_PRAM_HASH_VIRTUAL__SIZE_1                            128 /*       */
#define NV_PRAM_HASH_VIRTUAL_HANDLE                            31:0 /* -W-VF */
#define NV_PRAM_HASH_PHYSICAL                            0x00602600 /* R--4R */
#define NV_PRAM_HASH_PHYSICAL_INSTANCE                         15:0 /* R-IUF */
#define NV_PRAM_HASH_PHYSICAL_INSTANCE_0                 0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_DEVICE                          22:16 /* R-IUF */
#define NV_PRAM_HASH_PHYSICAL_DEVICE_NOT_FOUND           0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE                        24:24 /* R-IVF */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE_DISABLED          0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE_ENABLED           0x00000001 /* R---V */
/* dev_ram.ref */
#define NV_PRAMFC                             0x0064BFFF:0x00648000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMAU                             0x00604FFF:0x00604000 /* RW--D */
/* dev_spooks.ref */
#define NV_PAUTH                              0x00605FFF:0x00605000 /* RW--D */
#define NV_PAUTH_DEBUG_0                                 0x00605080 /* R--4R */
#define NV_PAUTH_DEBUG_0_BREACH                                 0:0 /* R-IVF */
#define NV_PAUTH_DEBUG_0_BREACH_NOT_DETECTED             0x00000000 /* R-I-V */
#define NV_PAUTH_DEBUG_0_BREACH_DETECTED                 0x00000001 /* R---V */
#define NV_PAUTH_DEBUG_0_EEPROM                                 4:4 /* R-IVF */
#define NV_PAUTH_DEBUG_0_EEPROM_VALID                    0x00000000 /* R-I-V */
#define NV_PAUTH_DEBUG_0_EEPROM_INVALID                  0x00000001 /* R---V */
#define NV_PAUTH_CHIP_TOKEN_0                            0x00605400 /* R--4R */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_01_08                     7:0 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_09_16                    15:8 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_17_24                   23:16 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_25_32                   31:24 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1                            0x00605404 /* R--4R */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_33_40                     7:0 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_41_48                    15:8 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_49_56                   23:16 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_57_64                   31:24 /* R--VF */
#define NV_PAUTH_PASSWD_0(i)                  (0x00605800+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_0__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_0_ENCRYPT_01_08                         7:0 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_01_08_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_09_16                        15:8 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_09_16_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_17_24                       23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_17_24_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_25_32                       31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_25_32_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1(i)                  (0x00605804+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_1__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_1_ENCRYPT_33_40                         7:0 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_33_40_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_41_48                        15:8 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_41_48_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_49_56                       23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_49_56_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_57_64                       31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_57_64_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_2(i)                  (0x00605808+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_2__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_2_RESERVED                             31:0 /* CW-VF */
#define NV_PAUTH_PASSWD_2_RESERVED_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3(i)                  (0x0060580C+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_3__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_3_RESERVED                             15:0 /* CW-VF */
#define NV_PAUTH_PASSWD_3_RESERVED_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3_APP_SN_0                            23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_3_APP_SN_0_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3_APP_SN_1                            31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_3_APP_SN_1_0                     0x00000000 /* CW--V */
#define NV_PAUTH_UNUSED_0(i)                     (0x00605000+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_0__SIZE_1                                32 /*       */
#define NV_PAUTH_UNUSED_0_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_0_VALUE_0                        0x00000000 /* C---V */
#define NV_PAUTH_UNUSED_1(i)                     (0x00605084+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_1__SIZE_1                               223 /*       */
#define NV_PAUTH_UNUSED_1_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_1_VALUE_0                        0x00000000 /* C---V */
#define NV_PAUTH_UNUSED_2(i)                     (0x00605408+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_2__SIZE_1                               254 /*       */
#define NV_PAUTH_UNUSED_2_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_2_VALUE_0                        0x00000000 /* C---V */
/* dev_ram.ref */
#define NV_PRAMPW                             0x00606FFF:0x00606000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00608FFF:0x00608000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00608000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR                          0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR_NVIDIA            0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR_SGS               0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_VRAM            0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_DRAM            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD                           3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_MOTHER             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_1          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_2          0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_3          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_VL              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RESERVED                        7:5 /* R-XVF */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00609FFF:0x00609000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00609000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PEEPROM                            0x0060AFFF:0x0060A000 /* RW--D */
#define NV_PEEPROM_CONTROL                               0x0060A400 /* RW-4R */
#define NV_PEEPROM_CONTROL_DATA                                 7:0 /* RWXVF */
#define NV_PEEPROM_CONTROL_ADDRESS                             14:8 /* RWXUF */
#define NV_PEEPROM_CONTROL_COMMAND                            25:24 /* RWIVF */
#define NV_PEEPROM_CONTROL_COMMAND_NOP_0                 0x00000000 /* RWI-V */
#define NV_PEEPROM_CONTROL_COMMAND_WRITE                 0x00000001 /* RW--V */
#define NV_PEEPROM_CONTROL_COMMAND_READ                  0x00000002 /* RW--V */
#define NV_PEEPROM_CONTROL_COMMAND_NOP_3                 0x00000003 /* RW--V */
#define NV_PEEPROM_CONTROL_STATUS                             28:28 /* R-IVF */
#define NV_PEEPROM_CONTROL_STATUS_IDLE                   0x00000000 /* R---V */
#define NV_PEEPROM_CONTROL_STATUS_BUSY                   0x00000001 /* R-I-V */
/* dev_ext_devices.ref */
#define NV_PROM                               0x00617FFF:0x00610000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00610000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  32768 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0061FFFF:0x00618000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00618000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  32768 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ram.ref */
#define NV_PRAMHT                             0x00647FFF:0x00640000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMRO                             0x00653FFF:0x00650000 /* RW--D */
/* dev_realmode.ref */
#define NV_PRM                                0x006C7FFF:0x006C0000 /* RW--D */
#define NV_PRM_DEBUG_0                                   0x006C0080 /* RW-4R */
#define NV_PRM_DEBUG_0_FLIPFLOP                                 0:0 /* RWIVF */
#define NV_PRM_DEBUG_0_FLIPFLOP_ADDRESS                  0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_FLIPFLOP_DATA                     0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_WRITE                               4:4 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_WRITE_NOT_PENDING            0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_PENDING                0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC                          8:8 /* R-IVF */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC_PENDING           0x00000001 /* R---V */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER                         12:12 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER_FOREGROUND         0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER_BACKGROUND         0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_CURSOR                            16:16 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_CURSOR_FOREGROUND            0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_CURSOR_OFF                   0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT                                   20:20 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_DISABLED                     0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_ENABLED                      0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_STATE                             24:24 /* R-IVF */
#define NV_PRM_DEBUG_0_TEXT_STATE_IDLE                   0x00000000 /* R-I-V */
#define NV_PRM_DEBUG_0_TEXT_STATE_RENDERING              0x00000001 /* R---V */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP                         28:28 /* RWIVF */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_0                                    0x006C0100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_INDEX                             12:12 /* RWIVF */
#define NV_PRM_INTR_0_TRACE_INDEX_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_TRACE_INDEX_PENDING                0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_INDEX_RESET                  0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWIVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_VBLANK                                  20:20 /* RWIVF */
#define NV_PRM_INTR_0_VBLANK_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_VBLANK_PENDING                     0x00000001 /* R---V */
#define NV_PRM_INTR_0_VBLANK_RESET                       0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x006C0140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_INDEX                          12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_INDEX_DISABLED            0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_INDEX_ENABLED             0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_VBLANK                               20:20 /* RWIVF */
#define NV_PRM_INTR_EN_0_VBLANK_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_VBLANK_ENABLED                  0x00000001 /* RW--V */
#define NV_PRM_CONFIG_0                                  0x006C0200 /* RW-4R */
#define NV_PRM_CONFIG_0_TEXT                                    0:0 /* RWIVF */
#define NV_PRM_CONFIG_0_TEXT_DISABLED                    0x00000000 /* RWI-V */
#define NV_PRM_CONFIG_0_TEXT_ENABLED                     0x00000001 /* RW--V */
#define NV_PRM_CONFIG_0_DAC_WIDTH                               4:4 /* RWIVF */
#define NV_PRM_CONFIG_0_DAC_WIDTH_6_BITS                 0x00000000 /* RWI-V */
#define NV_PRM_CONFIG_0_DAC_WIDTH_8_BITS                 0x00000001 /* RW--V */
#define NV_PRM_TRACE                                     0x006C1F00 /* RW-4R */
#define NV_PRM_TRACE__ALIAS_1                       NV_MEMORY_TRACE /*       */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWIVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R-I-V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWIVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R-I-V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_VGA_CAPTURE                                9:8 /* RWIVF */
#define NV_PRM_TRACE_VGA_CAPTURE_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_TRACE_VGA_CAPTURE_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_TRACE_VGA_CAPTURE_READS                   0x00000002 /* RW--V */
#define NV_PRM_TRACE_VGA_CAPTURE_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_TRACE_VGA_WRITE                                12:12 /* RWIVF */
#define NV_PRM_TRACE_VGA_WRITE_NONE                      0x00000000 /* R-I-V */
#define NV_PRM_TRACE_VGA_WRITE_OCCURED                   0x00000001 /* R---V */
#define NV_PRM_TRACE_VGA_WRITE_RESET                     0x00000001 /* -W--V */
#define NV_PRM_TRACE_VGA_READ                                 13:13 /* RWIVF */
#define NV_PRM_TRACE_VGA_READ_NONE                       0x00000000 /* R-I-V */
#define NV_PRM_TRACE_VGA_READ_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_VGA_READ_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x006C1F10 /* RW-4R */
#define NV_PRM_TRACE_INDEX__ALIAS_1           NV_MEMORY_TRACE_INDEX /*       */
#define NV_PRM_TRACE_INDEX_ADDRESS                             13:0 /* RWIUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0                                  0x006C1F20 /* RW-4R */
#define NV_PRM_IGNORE_0__ALIAS_1                    NV_MEMORY_TRACE /*       */
#define NV_PRM_IGNORE_0_DAC                                     1:0 /* RWIVF */
#define NV_PRM_IGNORE_0_DAC_DISABLED                     0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_DAC_WRITES                       0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_DAC_READS                        0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_DAC_READS_WRITES                 0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT                                5:4 /* RWIVF */
#define NV_PRM_IGNORE_0_GAMEPORT_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_GAMEPORT_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401                                  9:8 /* RWIVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1                                  0x006C1F24 /* RW-4R */
#define NV_PRM_IGNORE_1__ALIAS_1                    NV_MEMORY_TRACE /*       */
#define NV_PRM_IGNORE_1_FM_INDEX                                1:0 /* RWIVF */
#define NV_PRM_IGNORE_1_FM_INDEX_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_FM_INDEX_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_FM_INDEX_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_FM_INDEX_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA                                 5:4 /* RWIVF */
#define NV_PRM_IGNORE_1_FM_DATA_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_FM_DATA_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA_READS                    0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL                              9:8 /* RWIVF */
#define NV_PRM_IGNORE_1_SB_DIGITAL_DISABLED              0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW                                17:16 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_HW_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_HW_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW                                21:20 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_SW_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_SW_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC                              25:24 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_MISC_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_MISC_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_MPU_401                                   0x006C0400 /* RW-4R */
#define NV_PRM_MPU_401_DATA                                     7:0 /* RWXVF */
#define NV_PRM_MPU_401_DATA_ACK                          0x000000FE /* RW--V */
#define NV_PRM_MPU_401_WRITE_STATUS                             8:8 /* RWIVF */
#define NV_PRM_MPU_401_WRITE_STATUS_EMPTY                0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_WRITE_STATUS_FULL                 0x00000001 /* RW--V */
#define NV_PRM_MPU_401_WRITE_FORCE                            12:12 /* RWIVF */
#define NV_PRM_MPU_401_WRITE_FORCE_EMPTY                 0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_WRITE_FORCE_DISABLED              0x00000001 /* RW--V */
#define NV_PRM_MPU_401_READ_STATUS                            16:16 /* RWIVF */
#define NV_PRM_MPU_401_READ_STATUS_FULL                  0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_READ_STATUS_EMPTY                 0x00000001 /* RW--V */
#define NV_PRM_MPU_401_READ_FORCE                             20:20 /* RWIVF */
#define NV_PRM_MPU_401_READ_FORCE_FULL                   0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_READ_FORCE_DISABLED               0x00000001 /* RW--V */
#define NV_PRM_MPU_401_UART_MODE                              24:24 /* RWIVF */
#define NV_PRM_MPU_401_UART_MODE_COMPLEX                 0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_UART_MODE_SIMPLE                  0x00000001 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x006DFFFF:0x006D0000 /* RW--D */
#define NV_PRMIO_GAME_PORT                               0x006D0201 /* RW-1R */
#define NV_PRMIO_GAME_PORT__ALIAS_1                 NV_IO_GAME_PORT /*       */
#define NV_PRMIO_FM_ADDRESS__SOUND_BLASTER               0x006D0228 /* -W-1R */
#define NV_PRMIO_FM_ADDRESS__ADLIB                       0x006D0388 /* -W-1R */
#define NV_PRMIO_SB_WRITE_STATUS                         0x006D022C /* R--1R */
#define NV_PRMIO_SB_WRITE_STATUS__ALIAS_1     NV_IO_SB_WRITE_STATUS /*       */
#define NV_PRMIO_SB_READ_STATUS                          0x006D022E /* RW-1R */
#define NV_PRMIO_SB_READ_STATUS__ALIAS_1       NV_IO_SB_READ_STATUS /*       */
#define NV_PRMIO_MPU_401_DATA                            0x006D0330 /* R--1R */
#define NV_PRMIO_MPU_401_DATA__ALIAS_1           NV_IO_MPU_401_DATA /*       */
#define NV_PRMIO_MPU_401_STATUS                          0x006D0331 /* R--1R */
#define NV_PRMIO_MPU_401_STATUS__ALIAS_1       NV_IO_MPU_401_STATUS /*       */
#define NV_PRMIO_EX_MISC_OUT__WRITE                      0x006D03C2 /* -W-1R */
#define NV_PRMIO_EX_MISC_OUT__READ                       0x006D03CC /* R--1R */
#define NV_PRMIO_EX_FEATURE__WRITE_MONO                  0x006D03BA /* -W-1R */
#define NV_PRMIO_EX_FEATURE__WRITE_COLOR                 0x006D03DA /* -W-1R */
#define NV_PRMIO_EX_FEATURE__READ                        0x006D03CA /* R--1R */
#define NV_PRMIO_EX_STATUS_0__READ                       0x006D03c2 /* R--1R */
#define NV_PRMIO_EX_STATUS_1__READ_MONO                  0x006D03BA /* R--1R */
#define NV_PRMIO_EX_STATUS_1__READ_COLOR                 0x006D03DA /* R--1R */
#define NV_PRMIO_SQ_ADDRESS                              0x006D03C4 /* RW-1R */
#define NV_PRMIO_SQ_ADDRESS__ALIAS_1               NV_IO_SQ_ADDRESS /*       */
#define NV_PRMIO_SQ_MAP_MASK                             0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_MAP_MASK__ALIAS_1             NV_IO_SQ_MAP_MASK /*       */
#define NV_PRMIO_SQ_MAP_MASK__INDEX                      0x00000002 /*       */
#define NV_PRMIO_SQ_CHAR_MAP                             0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_CHAR_MAP__ALIAS_1             NV_IO_SQ_CHAR_MAP /*       */
#define NV_PRMIO_SQ_CHAR_MAP__INDEX                      0x00000003 /*       */
#define NV_PRMIO_SQ_MEM_MAP                              0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_MEM_MAP__ALIAS_1               NV_IO_SQ_MEM_MAP /*       */
#define NV_PRMIO_SQ_MEM_MAP__INDEX                       0x00000004 /*       */
#define NV_PRMIO_CC_ADDRESS__MONO                        0x006D03B4 /* RW-1R */
#define NV_PRMIO_CC_ADDRESS__COLOR                       0x006D03D4 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__INDEX                      0x00000009 /*       */
#define NV_PRMIO_CC_CURSOR_START__MONO                   0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_START__COLOR                  0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_START__INDEX                  0x0000000A /*       */
#define NV_PRMIO_CC_START_HI__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_START_HI__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_START_HI__INDEX                      0x0000000C /*       */
#define NV_PRMIO_CC_START_LO__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_START_LO__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_START_LO__INDEX                      0x0000000D /*       */
#define NV_PRMIO_CC_CURSOR_HI__MONO                      0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_HI__COLOR                     0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_HI__INDEX                     0x0000000E /*       */
#define NV_PRMIO_CC_CURSOR_LO__MONO                      0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_LO__COLOR                     0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_LO__INDEX                     0x0000000F /*       */
#define NV_PRMIO_CC_OFFSET__MONO                         0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_OFFSET__COLOR                        0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_OFFSET__INDEX                        0x00000013 /*       */
#define NV_PRMIO_GC_ADDRESS                              0x006D03CE /* RW-1R */
#define NV_PRMIO_GC_ADDRESS__ALIAS_1               NV_IO_GC_ADDRESS /*       */
#define NV_PRMIO_GC_SR                                   0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_SR__ALIAS_1                         NV_IO_GC_SR /*       */
#define NV_PRMIO_GC_SR__INDEX                            0x00000000 /*       */
#define NV_PRMIO_GC_ENABLE_SR                            0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_ENABLE_SR__ALIAS_1           NV_IO_GC_ENABLE_SR /*       */
#define NV_PRMIO_GC_ENABLE_SR__INDEX                     0x00000001 /*       */
#define NV_PRMIO_GC_COLOR_COMP                           0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_COLOR_COMP__ALIAS_1         NV_IO_GC_COLOR_COMP /*       */
#define NV_PRMIO_GC_COLOR_COMP__INDEX                    0x00000002 /*       */
#define NV_PRMIO_GC_ROTATE                               0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_ROTATE__ALIAS_1                 NV_IO_GC_ROTATE /*       */
#define NV_PRMIO_GC_ROTATE__INDEX                        0x00000003 /*       */
#define NV_PRMIO_GC_READ_MAP                             0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_READ_MAP__ALIAS_1             NV_IO_GC_READ_MAP /*       */
#define NV_PRMIO_GC_READ_MAP__INDEX                      0x00000004 /*       */
#define NV_PRMIO_GC_MODE                                 0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_MODE__ALIAS_1                     NV_IO_GC_MODE /*       */
#define NV_PRMIO_GC_MODE__INDEX                          0x00000005 /*       */
#define NV_PRMIO_GC_MISC                                 0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_MISC__ALIAS_1                     NV_IO_GC_MISC /*       */
#define NV_PRMIO_GC_MISC__INDEX                          0x00000006 /*       */
#define NV_PRMIO_GC_DONT_CARE                            0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_DONT_CARE__ALIAS_1           NV_IO_GC_DONT_CARE /*       */
#define NV_PRMIO_GC_DONT_CARE__INDEX                     0x00000007 /*       */
#define NV_PRMIO_GC_BIT_MASK                             0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_BIT_MASK__ALIAS_1             NV_IO_GC_BIT_MASK /*       */
#define NV_PRMIO_GC_BIT_MASK__INDEX                      0x00000008 /*       */
#define NV_PRMIO_AT_ADDRESS__WRITE_FLIPFLOP0             0x006D03C0 /* -W-1R */
#define NV_PRMIO_AT_ADDRESS__READ                        0x006D03C0 /* R--1R */
#define NV_PRMIO_AT_MODE__WRITE_FLIPFLOP1                0x006D03C0 /* -W-1R */
#define NV_PRMIO_AT_MODE__READ                           0x006D03C1 /* R--1R */
#define NV_PRMIO_DAC_DATA                                0x006D03C9 /* RW-1R */
#define NV_PRMIO_DAC_DATA__ALIAS_1                   NV_IO_DAC_DATA /*       */
/* dev_realmode.ref */
#define NV_PRMVGA                             0x006EFFFF:0x006E0000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--D */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_PW(i,j,k)   (0x800020+(i)*0x10000+(j)*0x2000+(k)*4) /* -W-4A */
#define NV_USER_PW__SIZE_1                                      128 /*       */
#define NV_USER_PW__SIZE_2                                        8 /*       */
#define NV_USER_PW__SIZE_3                                        4 /*       */
#define NV_USER_PW_PASSWORD                                    31:0 /* -W-VF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x01FFFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                             4194304 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             8388608 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                            12582912 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                            16777216 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_dma.ref */
#define NV_NOTIFY                             0x0000000F:0x00000000 /* RW--M */
#define NV_NOTIFY_TIME_0                      ( 0*32+31):( 0*32+ 5) /* RWXUF */
#define NV_NOTIFY_TIME_1                      ( 1*32+28):( 1*32+ 0) /* RWXUF */
#define NV_NOTIFY_RETURN_VALUE                ( 2*32+31):( 2*32+ 0) /* RWXVF */
#define NV_NOTIFY_ERROR_CODE                  ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_NOTIFY_STATUS                      ( 3*32+31):( 3*32+24) /* RWXUF */
#define NV_NOTIFY_STATUS_COMPLETED                       0x00000000 /* RW--V */
#define NV_NOTIFY_STATUS_IN_PROCESS                      0x00000001 /* RW--V */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_FLIPFLOP                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_TRACE_FLIPFLOP_ADDRESS                        0x00000000 /* RW--V */
#define NV_TRACE_FLIPFLOP_DATA                           0x00000001 /* RW--V */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
#define NV_RAMHT_FREE_LIE                     ( 1*32+31):( 1*32+31) /* RWXVF */
#define NV_RAMHT_FREE_LIE_DISABLED                       0x00000000 /* RW--V */
#define NV_RAMHT_FREE_LIE_ENABLED                        0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_2                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_3                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_SIZE                         ( 0*32+26):( 0*32+26) /* RWXVF */
#define NV_RAMRO_SIZE_ILLEGAL                            0x00000000 /* RW--V */
#define NV_RAMRO_SIZE_16_BIT                             0x00000001 /* RW--V */
#define NV_RAMRO_TYPE                         ( 0*32+27):( 0*32+27) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
#define NV_RAMAU_DATA                                          31:0 /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_2                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_3                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_0                        ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_RAMFC_LIE_0_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_0_ENABLED                           0x00000001 /* RW--V */
#define NV_RAMFC_SUBCHANNEL                   ( 0*32+30):( 0*32+28) /* RWXUF */
#define NV_RAMFC_OBJECT                       ( 0*32+31):( 0*32+31) /* RWXVF */
#define NV_RAMFC_OBJECT_UNCHANGED                        0x00000000 /* RW--V */
#define NV_RAMFC_OBJECT_CHANGED                          0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_1                        ( 1*32+24):( 1*32+24) /* RWXVF */
#define NV_RAMFC_LIE_1_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_1_ENABLED                           0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_7                        ( 7*32+24):( 7*32+24) /* RWXVF */
#define NV_RAMFC_LIE_7_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_7_ENABLED                           0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMPW                              0x000003FF:0x00000000 /* RW--M */
#define NV_RAMPW_PASSWORD_0                   ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMPW_PASSWORD_1                   ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMIN                              0x000FFFFF:0x00000000 /* RW--M */
#define NV_RAMIN_CONTEXT_0                    ( 0*32+31):( 0*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_1                    ( 1*32+31):( 1*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_2                    ( 2*32+31):( 2*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_3                    ( 3*32+31):( 3*32+ 0) /*       */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
#define NV_AUDIN_AE_STATE                     ( 0*32+31):( 0*32+ 0) /* RWWVF */
#define NV_AUDIN_AE_SKIP_COUNT                ( 1*32+31):( 1*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_POSITION                  ( 2*32+31):( 2*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_NEXT_INSTANCE             ( 3*32+15):( 3*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_STATE                     ( 3*32+31):( 3*32+16) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_LOW            ( 4*32+15):( 4*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_STATE                     ( 4*32+31):( 4*32+16) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_HIGH           ( 5*32+31):( 5*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_SKIP_INC                  ( 6*32+31):( 6*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_DMA_INSTANCE        ( 7*32+15):( 7*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INSTANCE     ( 7*32+31):( 7*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_START_POSITION      ( 8*32+31):( 8*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_LAST_SAMPLE_PLUS1   ( 9*32+31):( 9*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_DMA_INSTANCE        (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INSTANCE     (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_LAST_SAMPLE_PLUS1   (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+21):( 0*32+21) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+22):( 0*32+22) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+25):( 0*32+25) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+28):( 0*32+28) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
#define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
#define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 3*32+20):( 3*32+20) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 3*32+21):( 3*32+21) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 3*32+22):( 3*32+22) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 3*32+23):( 3*32+23) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_OFFSET              ( 4*32+17):( 4*32+16) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_OFFSET              ( 4*32+21):( 4*32+20) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_IN_USE              ( 4*32+24):( 4*32+24) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_IN_USE              ( 4*32+25):( 4*32+25) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY              ( 4*32+26):( 4*32+26) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY              ( 4*32+27):( 4*32+27) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT                    ( 4*32+29):( 4*32+28) /* RWXVF */
#define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
#define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
#define NV_AUDIN_SU_CHANNEL                   ( 4*32+30):( 4*32+30) /* RWXVF */
#define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
#define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
#define NV_AUDIN_SU_PDFB                      ( 4*32+31):( 4*32+31) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDOUT                             0x0000003B:0x00000000 /* RW--M */
#define NV_AUDOUT_AE_POSITION_LOW             ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_STATE                    ( 0*32+31):( 0*32+16) /* RWXVF */
#define NV_AUDOUT_AE_POSITION                 ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_VOLUME_CHANNEL_1         ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_VOLUME_CHANNEL_0         ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_AUDOUT_RM_NEXT_INSTANCE            ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_AUDOUT_RM_STATE                    ( 3*32+31):( 3*32+16) /* RWXVF */
#define NV_AUDOUT_RM_VOLUME_CHANNEL_1         ( 4*32+15):( 4*32+ 0) /* RWXUF */
#define NV_AUDOUT_RM_VOLUME_CHANNEL_0         ( 4*32+31):( 4*32+16) /* RWXUF */
#define NV_AUDOUT_SU_POSITION_INC             ( 5*32+31):( 5*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_VOLUME_CHANNEL_1         ( 6*32+15):( 6*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_VOLUME_CHANNEL_0         ( 6*32+31):( 6*32+16) /* RWXUF */
#define NV_AUDOUT_SU_START_TIME_LOW           ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_STATE                    ( 7*32+31):( 7*32+16) /* RWXUF */
#define NV_AUDOUT_SU_START_TIME_HIGH          ( 8*32+31):( 8*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       ( 9*32+15):( 9*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INSTANCE    ( 9*32+31):( 9*32+16) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_START_POSITION     (10*32+31):(10*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_LAST_SAMPLE_PLUS1  (11*32+31):(11*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (12*32+15):(12*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INSTANCE    (12*32+31):(12*32+16) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_LAST_SAMPLE_PLUS1  (14*32+31):(14*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+17):( 0*32+17) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+21):( 0*32+21) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+22):( 0*32+22) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+25):( 0*32+25) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+28):( 0*32+28) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
#define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
#define NV_AUDOUT_RM_INTR_MIXING              ( 3*32+16):( 3*32+16) /* RWXVF */
#define NV_AUDOUT_RM_INTR_VOLUME              ( 3*32+17):( 3*32+17) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        ( 3*32+20):( 3*32+20) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        ( 3*32+21):( 3*32+21) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     ( 3*32+22):( 3*32+22) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     ( 3*32+23):( 3*32+23) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_BYTE_OFFSET        ( 7*32+17):( 7*32+16) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_BYTE_OFFSET        ( 7*32+21):( 7*32+20) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_IN_USE             ( 7*32+24):( 7*32+24) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_IN_USE             ( 7*32+25):( 7*32+25) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY             ( 7*32+26):( 7*32+26) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY             ( 7*32+27):( 7*32+27) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT                   ( 7*32+29):( 7*32+28) /* RWXVF */
#define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL                  ( 7*32+30):( 7*32+30) /* RWXVF */
#define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
#define NV_AUDOUT_SU_PDFB                     ( 7*32+31):( 7*32+31) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDNOTE                            0x0000007B:0x00000000 /* RW--M */
#define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_STATE                   ( 0*32+31):( 0*32+16) /* RWXVF */
#define NV_AUDNOTE_AE_ADSR_LEVEL              ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION_LOW            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_ADSR_VOLUME             ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_AUDNOTE_AE_POSITION_INC            ( 3*32+31):( 3*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VIBRATO_POSITION        ( 4*32+31):( 4*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VIBRATO_VALUE           ( 5*32+31):( 5*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_TREMOLO_POSITION        ( 6*32+31):( 6*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VOLUME_CHANNEL_1        ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VOLUME_CHANNEL_0        ( 7*32+31):( 7*32+16) /* RWXUF */
#define NV_AUDNOTE_RM_NEXT_INSTANCE           ( 8*32+15):( 8*32+ 0) /* RWXUF */
#define NV_AUDNOTE_RM_STATE                   ( 8*32+31):( 8*32+16) /* RWXVF */
#define NV_AUDNOTE_RM_VOLUME_CHANNEL_1        ( 9*32+15):( 9*32+ 0) /* RWXUF */
#define NV_AUDNOTE_RM_VOLUME_CHANNEL_0        ( 9*32+31):( 9*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_STATE                   (10*32+31):(10*32+16) /* RWXVF */
#define NV_AUDNOTE_SU_DMA_INSTANCE            (11*32+15):(11*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_NOTIFY_INSTANCE         (11*32+31):(11*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_START_TIME_LOW          (12*32+15):(12*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_START_TIME_HIGH         (13*32+31):(13*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_STOP_TIME_HIGH          (14*32+31):(14*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (15*32+15):(15*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (15*32+31):(15*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (16*32+31):(16*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (17*32+31):(17*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VOLUME_CHANNEL_1        (18*32+15):(18*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VOLUME_CHANNEL_0        (18*32+31):(18*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION                (19*32+31):(19*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LOOP_START_POSITION     (21*32+31):(21*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LOOP_LAST_SAMPLE_PLUS1  (22*32+31):(22*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LAST_SAMPLE_PLUS1       (23*32+31):(23*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_ATTACK_RATE             (24*32+15):(24*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_DECAY_RATE              (24*32+31):(24*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_RATE            (25*32+15):(25*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_SUSTAIN_RATE            (25*32+31):(25*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_SUSTAIN_LEVEL           (26*32+15):(26*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_PORTAMENTO_RATE         (26*32+31):(26*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_DEPTH           (27*32+15):(27*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (27*32+31):(27*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (28*32+15):(28*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (28*32+31):(28*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_DEPTH           (29*32+15):(29*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_OFFSET          (29*32+31):(29*32+16) /* RWXUF */
#define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+17):( 0*32+17) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDNOTE_AE_IN_USE                  ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_MIXING             ( 8*32+16):( 8*32+16) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_VOLUME             ( 8*32+17):( 8*32+17) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_NOTIFY             ( 8*32+20):( 8*32+20) /* RWXVF */
#define NV_AUDNOTE_SU_OFFSET                  (10*32+17):(10*32+16) /* RWXVF */
#define NV_AUDNOTE_SU_IN_USE                  (10*32+24):(10*32+24) /* RWXVF */
#define NV_AUDNOTE_SU_NOTIFY                  (10*32+26):(10*32+26) /* RWXVF */
#define NV_AUDNOTE_SU_NOTIFY_DMA_WRITE                   0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_NOTIFY_INTERRUPT                   0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT                  (10*32+29):(10*32+28) /* RWXVF */
#define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL                 (10*32+30):(10*32+30) /* RWXVF */
#define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_PDFB                    (10*32+31):(10*32+31) /* RWXVF */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV.C
//
// Abstract:
//
//     This is the miniport driver for NV Adapters.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the ET4000 Miniport driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvapi.h"

#include "modedefs.h"

#include "nvMultiMon.h"

#ifdef PC98
#include "modes.h"
#endif // PC98

#include "rm.h"
#include "nvcm.h"

// To get the twinview definitions
#include "nvMultiMon.h"

// to get the multi device helper routines
#include "multidev.h"


#include <nvRmStereo.h>


// modeset DLL definitions                    
#include "modeext.h"

extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);

#if (_WIN32_WINNT >= 0x0500)

// Normally we would include #ntddk.h, but that would include a bunch
// of other structures that would cause redefinitions / errors.

typedef struct _IO_STATUS_BLOCK
    {
    union
        {
        ULONG Status;
        PVOID Pointer;
        };

    ULONG *Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

extern ULONG ZwCreateFile(
  PVOID FileHandle,
  ULONG DesiredAccess,
  PVOID ObjectAttributes,
  PVOID IoStatusBlock,
  PVOID AllocationSize,
  ULONG FileAttributes,
  ULONG ShareAccess,
  ULONG CreateDisposition,
  ULONG CreateOptions,
  PVOID EaBuffer,
  ULONG EaLength );

extern ULONG ZwWriteFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  PVOID  Buffer,
  ULONG  Length,
  PVOID  ByteOffset,
  PVOID  Key );

extern ULONG ZwReadFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  PVOID  Buffer,
  ULONG  Length,
  PVOID  ByteOffset,
  PVOID  Key );

extern ULONG ZwDeviceIoControlFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  ULONG  IoControlCode,
  PVOID  InputBuffer,
  ULONG  InputBufferLength,
  PVOID  OutputBuffer,
  ULONG  OutputBufferLength
);

extern ULONG ZwClose( PVOID Handle );

extern BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PNV_UNICODE_STRING CSDVersion OPTIONAL
    );

#endif

extern InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension);
extern VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData);

VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistrySaveSettingsCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize);

ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);

ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask);

VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION hwDeviceExtension);

VOID vInitializeSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vWriteSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vReadSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vPrintSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);

static VOID SetSafeDeviceMasks_SingleHeadBoard(PHW_DEVICE_EXTENSION hwDeviceExtension);
static VOID SetSafeDeviceMasks_DualHeadBoard(PHW_DEVICE_EXTENSION hwDeviceExtension);
ULONG MaskToDeviceType( ULONG ulDeviceMask);
ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask);
ULONG MaskToTVFormat( ULONG ulDeviceMask);
ULONG ACPIHwIdToMask( ULONG ACPIHwId);
VOID HandleBIOSHeads(PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID HandleBestResolution(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN   TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID   InvalidateTwinViewData(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID InitFromTwinViewInfo(PHW_DEVICE_EXTENSION HwDeviceExtension);

VOID Verify1400x1050DFP(PHW_DEVICE_EXTENSION hwDeviceExtension);
ULONG WriteFPModeToRegistry (PHW_DEVICE_EXTENSION hwDeviceExtension);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);


extern VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension);
extern ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode);
// 
//extern VOID SetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulWidth, ULONG ulHeight, ULONG ulDepth, ULONG ulRefreshRate);
// 
//  Use CheckForcedResolution with the last parameter TRUE if you want to SetTheBestResolution
//
//extern   
//
// Function is now in nv.c since I could not get it to compile including nv.h in nvfloat.c

void CheckForcedResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, USHORT ulWidth, USHORT ulHeight, USHORT ulDepth, USHORT ulRefreshRate, BOOLEAN SetBestResolution );

extern VOID SignalModeSwitchEvent();
extern VOID SignalNVCplHotKeyEvent();
extern VOID InitNVSVCEvents();


//******************************************************************************
// The following declarations are needed to use the memory manager functions
//******************************************************************************
#define NV_PWR_MGMT
#define SYSMEM_FUDGE    (0x1000)

#define NTKERNELAPI DECLSPEC_IMPORT


extern VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION);
extern VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION);
extern VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION);
extern VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION);
extern U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10];
extern VOID NV_DisableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID NV_ReEnableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION);
extern VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION);
extern VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION);
extern VOID WakeUpCard(PHW_DEVICE_EXTENSION);
extern VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
extern VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NV_ManualTextModeSet(PHW_DEVICE_EXTENSION);
extern ULONG NVObReferenceObjectByHandle(HANDLE, HANDLE*);


extern void NVMapPhysIntoUserSpace(
        PHYSICAL_ADDRESS pa,
        LONG byteLength,
        PVOID *userVirtualAddress);

extern void NvUnmapPhysFromUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void NvMapIntoUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void NvUnmapFromUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void
NvLockdownMemory(
    NV_LOCK_DOWN_MEMORY *pLockdownMemory
    );

extern void
NvUnlockMemory(
    NV_UNLOCK_MEMORY *pUnlockMemory
    );

extern void
NvSystemMemoryShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

extern void
NvSystemMemoryUnShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

NTKERNELAPI PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmCachingTypeDoNotUse1,
    MmCachingTypeDoNotUse2,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN size_t NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN size_t NumberOfBytes
    );


//******************************************************************************
//
// Function declarations
//
//******************************************************************************
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension);

SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    );

SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    );

VP_STATUS
NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
NVInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
NVInitialize_DacsAndEDID(
    PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime
    );

BOOLEAN
NVOneTimeInit_TwinView(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
NVInterrupt(
    PVOID HwDeviceExtension
    );

VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


#if (_WIN32_WINNT >= 0x0500)
#ifdef NT_BUILD_NV4
extern BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    );
#endif
#endif

#if (_WIN32_WINNT >= 0x0500)

ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

VP_STATUS
NVGetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVValidateChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVSetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVSwitchDualView(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG                dwViewEnable
    );

#ifdef NV_PWR_MGMT
VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );
#endif // #ifdef NV_PWR_MGMT

#endif // if (_WIN32_WINNT >= 0x0500)

// Support to validate a mode on a particular display device for control panel
BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx);

//******************************************************************************
// Global variable used to detect if the ALI 1541 chipset is found.
// It needs to be global since the hwDeviceExtension is not preserved.
//******************************************************************************

ULONG Ali_1541_Chipset_Found = FALSE;

//******************************************************************************
// Value of VIA GA Translation Table Base register (offset 88)
//******************************************************************************

ULONG   ViaAgpRegister;


//******************************************************************************
// Global variable used to detect if several adapters are present
//******************************************************************************

ULONG MultiAdaptersPresent = FALSE;

//******************************************************************************
// Global variable used to track the slots where devices are located on the bus
// initialized with -1 (so DetectNextDevice starts looking for slot 0
//******************************************************************************

ULONG ulFindSlot = 0xffffffff;  

//******************************************************************************
// Static area buffer used to read information from the registry
//******************************************************************************

U016 registry_data[MAX_STRING_REGISTRY_DATA_WORDS];

//
//  Global flag to ensure RmInitRm() to be called only once.
//

BOOLEAN g_bIsRmInitRmCalled = FALSE;

//******************************************************************************
//
// Private function prototypes.
//
//******************************************************************************

VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

BOOLEAN
NVIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    //PVIDEO_ACCESS_RANGE pAccessRange,
    PULONG NV1Slot
    );

VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VOID
NVValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VOID NV10CursorTimer(
    PVOID HwDeviceExtension
);

BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);

//////// H.AZAR
#ifdef NVPE
VP_STATUS NVQueryInterface( PVOID HwDeviceExtension, PQUERY_INTERFACE QueryInterface);
VP_STATUS NVPEProcessCommand(PVOID pHwDeviceExtension, PVIDEO_REQUEST_PACKET pRequestPacket);
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

#ifdef PC98

// global device extension pointer and frame buffer pointer
// used for local POST and mode sets
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern PHWREG fbAddr;
VOID NvPostEx(PHW_DEVICE_EXTENSION pHwDevExt)
{
    PHYSICAL_ADDRESS physFbAddr;
    ULONG length, inIoSpace;

    // init global device extension for local POST
    HwDeviceExtension = pHwDevExt;

    // map the frame buffer
    physFbAddr.HighPart = 0x00000000;
    physFbAddr.LowPart = NVAccessRange[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    physFbAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
    length = 0x400000;
    inIoSpace = FALSE;
    fbAddr = 0;
    VideoPortMapMemory(
        pHwDevExt,
        physFbAddr,
        &length,
        &inIoSpace,
        &fbAddr
    );

    // perform the POST based on global fbAddr and addresses in the device extension
    NvPost();

    // unmap the frame buffer
    VideoPortUnmapMemory(
        pHwDevExt,
        fbAddr,
        0
    );
}

#endif // PC98

//******************************************************************************
// The functions listed below are pageable
//******************************************************************************

#if defined(ALLOC_PRAGMA)

#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,NVFindAdapter)
#pragma alloc_text(PAGE,NVInitialize)
#pragma alloc_text(PAGE,NVStartIO)
#pragma alloc_text(PAGE,NVIsPresent)
#pragma alloc_text(PAGE,NVSetColorLookup)

#if (_WIN32_WINNT >= 0x500)
#pragma alloc_text(PAGE, NVGetPowerState)
#pragma alloc_text(PAGE, NVSetPowerState)
#endif  // #if (_WIN32_WINNT >= 0x500)

#endif  // #if defined(ALLOC_PRAGMA)

//******************************************************************************
//
// Function: DriverEntry()
//
// Routine Description:
//
//     Installable driver initialization entry point.
//     This entry point is called directly by the I/O system.
//
// Arguments:
//
//     Context1 - First context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
//     Context2 - Second context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
// Return Value:
//
//     Status from VideoPortInitialize()
//
//******************************************************************************


ULONG DriverEntry(
    PVOID Context1,
    PVOID Context2
    )


    {

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;



    //**************************************************************************
    // Zero out structure.
    //**************************************************************************

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //**************************************************************************
    // Specify sizes of structure and extension.
    //**************************************************************************

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //**************************************************************************
    // Set entry points.
    //**************************************************************************

    hwInitData.HwFindAdapter = NVFindAdapter;
    hwInitData.HwInitialize = NVInitialize;
    hwInitData.HwStartIO = NVStartIO;
    hwInitData.HwInterrupt = NVInterrupt;
    // This timer is only enabled on NV10 and alpha cursor blending.
//    hwInitData.HwTimer = NV10CursorTimer;

    //**************************************************************************
    // New NT 5.0 EntryPoint
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0500)

    hwInitData.HwGetVideoChildDescriptor = NVGetChildDescriptor;

#ifdef NT_BUILD_NV4
    // To fix a hang on soft reboot issue for Toshiba and Dell.
    hwInitData.HwResetHw = NVResetHW;
#endif

#ifdef NV_PWR_MGMT
    hwInitData.HwGetPowerState = NVGetPowerState;
    hwInitData.HwSetPowerState = NVSetPowerState;
#endif // #ifdef NV_PWR_MGMT

#ifdef NVPE
    hwInitData.HwQueryInterface = NVQueryInterface;

#endif

#endif

    //**************************************************************************
    // Determine the size we require for the device extension.
    //**************************************************************************

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //**************************************************************************
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //**************************************************************************

//    hwInitData.StartingDeviceNumber = 0;

    //**************************************************************************
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //
    //
    // NOTE: For NV, we must be running on a PCI Bus
    //
    //**************************************************************************

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
       {
       return initializationStatus;
       }

    //**************************************************************************
    // We didn't find the card on any bus type, so lets
    // return the last error.
    //**************************************************************************

    return initializationStatus;

    } // end DriverEntry()


//**************************************************************************
// NT 5.0 specific entry points.
//**************************************************************************


#if (_WIN32_WINNT >= 0x0500)

#ifdef NV_PWR_MGMT

#ifndef _WIN64
VOID
NVAMD751ChipsetSaveHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PCI_COMMON_CONFIG AGPConfigInfo;
    PHYSICAL_ADDRESS physaddr;
    ULONG GetBusDataStatus;
    #define RM_PAGE_MASK 0x0FFF
    #define RM_PAGE_SIZE 4096

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &AGPConfigInfo,
                sizeof(PCI_COMMON_CONFIG));

    // Sanity check. Check the vendor ID and device ID.
    if ((GetBusDataStatus <= 2) || (AGPConfigInfo.VendorID != 0x1022) ||  (AGPConfigInfo.DeviceID != 0x7006)) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetSaveHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }

    // AMD 751 has its AGP related regs memory-mapped via BAR1 (setup this mapping).
    physaddr.HighPart = 0;
    physaddr.LowPart  = AGPConfigInfo.u.type0.BaseAddresses[1] & ~RM_PAGE_MASK;
    HwDeviceExtension->AMD751_BAR1_Mapped_Address = (PHWREG)MmMapIoSpace(physaddr, RM_PAGE_SIZE, FALSE);
    VideoDebugPrint((3, "hwDeviceExtension->AMD751_BAR1_Mapped_Address: 0x%p\n",HwDeviceExtension->AMD751_BAR1_Mapped_Address));
    if (HwDeviceExtension->AMD751_BAR1_Mapped_Address == (PHWREG)NULL) {
        VideoDebugPrint((0,"*** Failed to map AMD 751's AGP chipset registers\n"));
    } else {
        // Save the registers values. We restore them later while coming back up from hibernation.
        HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1];
        HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG  =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1];
        VideoDebugPrint((3, "Saved AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Saved AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}

VOID
NVAMD751ChipsetRestoreHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    // Sanity check. Ensure the chipset is AMD751.
    if (HwDeviceExtension->AMD751ChipsetFound != TRUE) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetRestoreHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }
    //***********************************************************************
    // Two of the AMD 751 chipset's BAR1 registers are not set correctly when
    // the machines wakes up from hibernation. So we restore these
    // Enable and Status register and GART base register to the values at the
    // normal bootup time. 
    //***********************************************************************
    if ((VOID *)HwDeviceExtension->AMD751_BAR1_Mapped_Address != NULL) {
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1] = HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1] = HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
        VideoDebugPrint((3, "Restored AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Restored AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}
#endif // #ifndef _WIN64

VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the NV card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/
{
ULONG CurrentPowerState;

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;

    //
    // on ACPI systems, Win2K actually calls us for "device ID 0 - Other".
    // Not sure how we should handle this device id. 
    // we simply return  true for now.
    //
    if (HwDeviceId == 0)
    {
        return(NO_ERROR);
    }

    //
    // For getPowerState, we treat the ACPI(100,110,200) and non-ACPI(QUERY_NONDDC_MONITOR_ID, QUERY_MONITOR_ID) device Ids
    // the same way. (Since all monitors essentially have only on/off support in the resMan. If the resMan were to support
    // a finer granularity of power management for monitors, this code should change.)
    // For SetPowerState, we treat yhe ACPI and non-ACPI device IDs differently since ACPI device IDs are mask based
    // and non-ACPI devices are head based.
    //
    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID)  ||
        (HwDeviceId == QUERY_NONDDC_MONITOR_ID2) ||
        (HwDeviceId == QUERY_MONITOR_ID)         ||
        (HwDeviceId == QUERY_MONITOR_ID2)        ||
        (HwDeviceId == QUERY_ACPI_CRT_ID)        ||
        (HwDeviceId == QUERY_ACPI_DFP_ID)        ||
        (HwDeviceId == QUERY_ACPI_TV_ID))
    {
        //
        // We deal with only the head0 since the Win2K OS is aware of only head0.
        //
        ULONG ulPrimaryHead;
        BOOL bRet;
        ulPrimaryHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerShutdown:
            return(NO_ERROR);
            break;

        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // The requested monitor power state is not supported by ResMan.
        //
        VideoDebugPrint((0,"Oops! NVGetPowerState for Monitor, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } 
    else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) 

    {
        BOOL bRet;
        
        //
        // We are querying power support for the graphics card.
        //


        switch (VideoPowerManagement->PowerState)
        {
        
        case VideoPowerOn:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
            
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;

        case VideoPowerShutdown:
            return(NO_ERROR);
            break;

        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        // The requested monitor power state is not supported by ResMan.
        VideoDebugPrint((0,"Oops! NVGetPowerState for Adapter, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } else {

        VideoDebugPrint((0, "Unknown HwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}



VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{

    ULONG ulStopImage, ModesetStopImage;

    //
    // Print the request for debugging purposes.
    //
    VideoDebugPrint((1, "nvSetPowerState(): HwDeviceId: 0x%x, Power State: ", HwDeviceId));
    switch (VideoPowerManagement->PowerState)
    {
    
    case VideoPowerOn:
        VideoDebugPrint((1, "VideoPowerOn\n"));
        break;
    case VideoPowerHibernate:
        VideoDebugPrint((1, "VideoPowerHibernate\n"));
        break;

    case VideoPowerStandBy:         
        VideoDebugPrint((1, "VideoPowerStandBy\n"));
        break;
    case VideoPowerSuspend:
        VideoDebugPrint((1, "VideoPowerSuspend\n"));
        break;
    case VideoPowerOff:
        VideoDebugPrint((1, "VideoPowerOff\n"));
        break;
    case VideoPowerShutdown:
        VideoDebugPrint((1, "VideoPowerShutdown\n"));
        break;
    default:
        VideoDebugPrint((1, "Unknown power state: 0x%x\n", VideoPowerManagement->PowerState));
        break;
    }

    //
    // We should not turn on the monitor power state if we have defered a modeset via NVSVC.
    //
    //
    ulStopImage = 0;
    ModesetStopImage = 0;
    if (HwDeviceExtension->ulInduceModeChangeDeviceMask)
    {
        ulStopImage = 1;
    }

    //
    // We should also not turn on the monitor power state if Sony's ModesetStopImage feature is turned on.
    //
    if (HwDeviceExtension->EnableModesetStopImage)
    {
        //
        // Read the registry entry.
        //
        VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ModesetStopImage",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ModesetStopImage));
        if (ModesetStopImage == 1)
        {
            ulStopImage = 1;
        }
    }

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************
    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;

    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID)  ||
        (HwDeviceId == QUERY_MONITOR_ID)         ||
        (HwDeviceId == QUERY_NONDDC_MONITOR_ID2) ||
        (HwDeviceId == QUERY_MONITOR_ID2))
    {

        ULONG i, ulHead, State;
        BOOL bRet;

        HwDeviceExtension->curMonitorPowerState = VideoPowerManagement->PowerState;

        for (i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
        {
            ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];

            switch (VideoPowerManagement->PowerState)
            {
            
            case VideoPowerOn:
                //
                // If the image has been stopped, we should not turn the monitor on
                //
                if (ulStopImage)
                {
                    VideoDebugPrint((1, "Image has been stopped, so ignoring monitor poweron\n"));
                    return(NO_ERROR);
                }
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOn];
                break;
            case VideoPowerHibernate:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerHibernate];
                break;

            case VideoPowerStandBy:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerStandBy];
                break;
            case VideoPowerSuspend:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerSuspend];
                break;
            case VideoPowerOff:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOff];
                break;
            case VideoPowerShutdown:
                return(NO_ERROR);
                break;

            default:
                VideoDebugPrint((0, "Unknown power state.\n"));
                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
            }

            bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, ulHead, State);
            if (bRet == FALSE)
            {
                VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for monitor %d, for State: 0x%x\n",
                                 ulHead, State));
            }

        }
        return(NO_ERROR);
    }

    //
    // The ACPI table has a "device ID 0 - for Other". Not sure what this device ID refers to.
    //
    if (HwDeviceId == 0)
    {
        VideoDebugPrint((0,"nvSetPowerState: HwID: 0x0, not sure what to do ,returning NO_ERROR\n"));
        return(NO_ERROR);
    }

    //
    // Handle the ACPI devices - CRT, TV, DFP on a laptop
    //
    if ((HwDeviceId == QUERY_ACPI_CRT_ID) ||
        (HwDeviceId == QUERY_ACPI_DFP_ID) ||
        (HwDeviceId == QUERY_ACPI_TV_ID))
    {

        ULONG i, ulHead, State, ulDeviceMask;
        BOOL bRet;

        HwDeviceExtension->curMonitorPowerState = VideoPowerManagement->PowerState;

        ulDeviceMask = ACPIHwIdToMask(HwDeviceId);
        if (ulDeviceMask == 0)
        {
            // Invalid device. simply return NO_ERROR.
            VideoDebugPrint((0,"Invalid deviceId, returning NO_ERROR\n"));
            return(NO_ERROR);
        }

        // Now we need to convert the device mask to a head. Since our ResMan power management interface is
        // specified in terms of head and not device mask. This leaves us with a hole. What if the device 
        // that we watnto set the power state is not currently one of the active heads? Hopefully win2K does not
        // call us in this fashion. Otherwise we will have to make more changes in resman's internal power management code
        // and its interface to the miniport.


        for (i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
        {
            ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
            if (HwDeviceExtension->DeskTopInfo.ulDeviceMask[ulHead] == ulDeviceMask)
            {
                // We found the head for which this requested device is attached.
                switch (VideoPowerManagement->PowerState)
                {
                
                case VideoPowerOn:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOn];
                    //
                    // If the image has been stopped, we should not turn the monitor on
                    //
                    if (ulStopImage)
                    {
                        VideoDebugPrint((1, "Image has been stopped, so ignoring monitor poweron\n"));
                        return(NO_ERROR);
                    }
                    break;
                case VideoPowerHibernate:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerHibernate];
                    break;

                case VideoPowerStandBy:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerStandBy];
                    break;
                case VideoPowerSuspend:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerSuspend];
                    break;
                case VideoPowerOff:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOff];
                    break;
                case VideoPowerShutdown:
                    return(NO_ERROR);
                    break;
                default:
                    VideoDebugPrint((0, "Unknown power state.\n"));
                    ASSERT(FALSE);
                    return ERROR_INVALID_PARAMETER;
                }

                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, ulHead, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for monitor %d, for State: 0x%x\n",
                                     ulHead, State));
                }
                return(NO_ERROR);
            }
        }

        // Oops! We did not find any active head which was attached to this device!
        VideoDebugPrint((1,"Did not find the head for the requested deviceMask: 0x%x was attached\n", HwDeviceId));
        return(NO_ERROR);
    }

    if (HwDeviceId == DISPLAY_ADAPTER_HW_ID)
    {


        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            {
                ULONG State;
                BOOL bRet;


                //
                // If the device was previously turned off, we need to reinitialize it.
                //


                if ( (HwDeviceExtension->curAdapterPowerState == VideoPowerHibernate)  ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerStandBy)    ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerSuspend)    ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerOff))
                {
                    VIDEO_REQUEST_PACKET requestPacket;
                    STATUS_BLOCK statusblock;

                    // 
                    // The display driver needs to know whether we are resuming from hibernation/stdby/suspend so write the
                    // power down state to the registry.
                    //
                    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"ResumingFromAdapterPowerDownState",
                                      &HwDeviceExtension->curAdapterPowerState,
                                      sizeof(ULONG));


                    if (HwDeviceExtension->CurrentMode==NULL)
                    {
                        //
                        //  If CurrentMode is not initialized, we know that our chip is
                        //  never initialized at all therefore, we must exit immediately.
                        //  And we should return no error. (configuration: ATI on motherboard
                        //  primary, NV3 as secondary, not posted)

                        //  NOTE:  Keep this fix here for now, until we can verify that
                        //  we can write to hardware registers in RmLoadState().
                        //  i.e....If this device was NOT posted, I'm not convinced that
                        //  we'll be able to touch the hardware registers (device is NOT on).
                        //  We should be able to delete this check once BIOS post code is added here.
                        //
                        return(NO_ERROR);
                    }


#ifndef IA64
                    //**********************************************************
                    // If the Via chipset is found, then we need to
                    // fixup one of the THEIR registers in order for AGP to work.
                    // Somewhat dangerous, but hibernation won't resume in
                    // AGP mode unless this register is programmed correctly.
                    //**********************************************************

                    if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                    {

                        //******************************************************
                        // Save the value of this VIA AGP register
                        //******************************************************

                        /*
                        _asm {
                             mov    eax,0x80000088
                             mov    dx,0xcf8
                             out    dx,eax
    
                             mov    dx,0xcfc
                             mov    eax,ViaAgpRegister
                             out    dx,eax
                             }
                        */

                        HalSetBusDataByOffset(PCIConfiguration,
                                              0,    //  Bus 0
                                              0,    //  Slot 0
                                              &ViaAgpRegister,
                                              (0x88 >> 2),  //  Offset in byte
                                              sizeof(ULONG));   //  Size in byte
                    }

                    //**********************************************************
                    // If the AMD 751 chipset is found, then we need to 
                    // fixup two of THEIR registers in order for the AGP to work.
                    //**********************************************************
                    if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                    {
                        NVAMD751ChipsetRestoreHibernationRegisters(HwDeviceExtension);
                    }
#endif // IA64
                }

                // Call the resman to set to PowerOn state
                State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn];
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                     State));
                }

                if (HwDeviceExtension->SavedPMCState != 0)
                {
                    NV_ReEnableNVInterrupts(HwDeviceExtension);
                }

                HwDeviceExtension->curAdapterPowerState = VideoPowerManagement->PowerState;

                return(NO_ERROR);
            }


            break;


        case VideoPowerHibernate:

        case VideoPowerStandBy:

        case VideoPowerSuspend:


        case VideoPowerOff:


            {
                VIDEO_REQUEST_PACKET requestPacket;
                STATUS_BLOCK statusblock;
                ULONG State;
                BOOL bRet;
                ULONG PrevDevMask;
                VP_STATUS RegStatus;

                //
                // if the PrevDevMask registry key exists, set it to zero.
                // This is to ensure that we do the begin/end modeset bracket in
                // the display driver.
                //
                PrevDevMask = 0;
                RegStatus = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"PrevDevMask",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(PrevDevMask));
                if (RegStatus == NO_ERROR)
                {
                    PrevDevMask = 0;
                    RegStatus = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"PrevDevMask",
                                                &(PrevDevMask),
                                                sizeof(ULONG));
                }


                HwDeviceExtension->curAdapterPowerState = VideoPowerManagement->PowerState;

#ifndef IA64
                //**************************************************************
                // If the Via chipset is found, then we need to
                // fixup one of the THEIR registers in order for AGP to work.
                // Somewhat dangerous, but hibernation won't resume in
                // AGP mode unless this register is programmed correctly.
                //**************************************************************

                if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                {

                    //**********************************************************
                    // Save the value of this VIA AGP register
                    //**********************************************************

                    /*
                    _asm {
                         mov    eax,0x80000088
                         mov    dx,0xcf8
                         out    dx,eax

                         mov    dx,0xcfc
                         in     eax,dx
                         mov    ViaAgpRegister,eax
                         }
                    */

                    HalGetBusDataByOffset(PCIConfiguration,
                                          0,    //  Bus 0
                                          0,    //  Slot 0
                                          &ViaAgpRegister,
                                          (0x88 >> 2),  //  Offset in bytes
                                          sizeof(ULONG));   //  Size in bytes
                }

                //**********************************************************
                // If the AMD 751 chipset is found, then we need to 
                // fixup two of THEIR registers in order for the AGP to work.
                //**********************************************************
                if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                {
                    NVAMD751ChipsetSaveHibernationRegisters(HwDeviceExtension);
                }
#endif // IA64


                switch (  VideoPowerManagement->PowerState)
                {
                
                case VideoPowerHibernate:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate];
                    break;
                case VideoPowerStandBy:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy];
                    break;
                case VideoPowerSuspend:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend];
                    break;
                case VideoPowerOff:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
                    // use some safe off value.
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                }

                // We are going out of high res mode. So indicate it.
                HwDeviceExtension->SystemModeSetHasOccurred = 0;
                VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &HwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));

                NV_DisableNVInterrupts(HwDeviceExtension);

                // Call the ResMan to set the adapter power down to the required state
                // The 'head' arguement is irrelevant since we are setting the adapter power state.
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                 State));
                }

                return(NO_ERROR);
            }

            break;

        case VideoPowerShutdown:
            // Disable interrupts

            NV_DisableNVInterrupts(HwDeviceExtension);
            return(NO_ERROR);

        default:
            //
            // Unrecognized power state.
            //
            VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        return(NO_ERROR);
    }

    VideoDebugPrint((0, "Unknown HwDeviceId: 0x%x\n", HwDeviceId));
    ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;

}

#endif // #ifdef NV_PWR_MGMT

#endif // #ifdef (_WIN32_WINNT >= 0x0500)


#if _WIN32_WINNT >= 0x0500
ULONG NVGetNumBootDevices(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulConnectedDeviceMask, ulNumberDacsOnBoard;

    ulConnectedDeviceMask = BITMASK_INVALID_DEVICE;
    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &ulConnectedDeviceMask))
    {
        return 1;
    }

    if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulConnectedDeviceMask, 
                            sizeof(ulConnectedDeviceMask)))
    {
        return 1;
    }
    if (ulConnectedDeviceMask == 0)
    {
        return 1;
    }
    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &ulNumberDacsOnBoard))
    {
        return 1;
    }

    if (ulNumberDacsOnBoard < 2)
    {
        return 1;
    }

    if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
    {
        if (ulConnectedDeviceMask & BITMASK_ALL_DFP)
            return 2;
        else
        {
            // A mobile without Panel????
            ASSERT(FALSE);
            return 1;
        }
    }
    else if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
    {
        return 2;
    }
    return 1;
}
#endif

VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    )
{
    VP_STATUS status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                                      L"TwinviewInfo",
                                                      FALSE,
                                                      NVReadRegistryTwinViewInfoCallback,
                                                      pTwinviewInfo);

    if (status == NO_ERROR)
    {
        VideoDebugPrint((2, "NVGetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
        VideoDebugPrint((2, "State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d\n",
            pTwinviewInfo->dwState, pTwinviewInfo->dwOrientation, pTwinviewInfo->DeskTopRectl.left,pTwinviewInfo->DeskTopRectl.top,pTwinviewInfo->DeskTopRectl.right,
            pTwinviewInfo->DeskTopRectl.bottom, pTwinviewInfo->dwAllDeviceMask, pTwinviewInfo->dwConnectedDeviceMask, pTwinviewInfo->dwDeviceDisplay[0],pTwinviewInfo->dwDeviceDisplay[1]));
        VideoDebugPrint((2, "dwDeviceMask[2] = {%x,%x}   dwDeviceType[2] = {%x,%x}\n", 
                        pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask,
                        pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceType));
        VideoDebugPrint((2,"........................\n"));
    }
    else
    {
        VideoDebugPrint((1, "NVGetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
        VideoDebugPrint((1, "NVGetRegistryTwinviewInfo Failed\n"));
    }

    return status;
}

VP_STATUS NVSetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    )
{
    VideoDebugPrint((2,"NVSetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
    VideoDebugPrint((2,"State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d\n",
        pTwinviewInfo->dwState, pTwinviewInfo->dwOrientation, pTwinviewInfo->DeskTopRectl.left,pTwinviewInfo->DeskTopRectl.top,pTwinviewInfo->DeskTopRectl.right,
        pTwinviewInfo->DeskTopRectl.bottom, pTwinviewInfo->dwAllDeviceMask, pTwinviewInfo->dwConnectedDeviceMask, pTwinviewInfo->dwDeviceDisplay[0],pTwinviewInfo->dwDeviceDisplay[1]));
    VideoDebugPrint((2, "dwDeviceMask[2] = {%x,%x}   dwDeviceType[2] = {%x,%x}\n", 
                     pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask,
                     pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceType));
    VideoDebugPrint((2,"........................\n"));

    return VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"TwinviewInfo",
                                   pTwinviewInfo,
                                   sizeof(NVTWINVIEWDATA));
}

VP_STATUS NVInitRm (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    if (hwDeviceExtension->bRmInitialized)
    {
        NV_ReEnableNVInterrupts(hwDeviceExtension);
        return NO_ERROR;
    }
    
    hwDeviceExtension->bRmInitialized = TRUE;
    
    if (hwDeviceExtension->DeviceMappingFailed == FALSE)
    {
        //**************************************************************************
        // Map the frame buffer here, so the Resource Manager can also get access to it,
        // instead of enablehardware in the display driver.
        //**************************************************************************

        if (NVMapFrameBuffer(hwDeviceExtension) != NO_ERROR)
        {
            return ERROR_INVALID_PARAMETER;
        }

        //**************************************************************************
        // For NV3, instead of passing the Frame buffer pointer back to the RM,
        // we will ONLY map instance memory beginning at address = framebuffer + 12Mb
        // This is because , for NV3, the RM accesses instance memory using the 'frame buffer'
        // ptr, and it must NOT be write combined.  Essentially, for NV3, we map
        // the frame buffer (write combined) and give this to the display driver.
        // But we also map 4Mb of instance memory (NON write combined) and
        // give it to the resource manager.
        //
        //  FrameBufferPtr = WRITE COMBINED mapping of frame buffer
        //  FrameBufferBase = NON write combined mapping of framebuffer+12Mb
        //                    used to access instance memory
        //
        // This is DIFFERENT from NV4 !!
        //**************************************************************************

        SetGlobalHwDev(hwDeviceExtension);

        //**************************************************************************
        // Make sure Non_primary monitor is alive, so that
        // dacConnectMonitorStatus in the RM will correctly detect the monitor!!
        // Only do this for NON primary devices.  Otherwise, the screen
        // will get garbled on the primary monitor.
        //**************************************************************************

        if (MultiAdaptersPresent == TRUE)
           if (hwDeviceExtension->NonPrimaryDevice == TRUE)
                WakeUpCard(hwDeviceExtension);

        // initialize the device
        if (!RmInitNvDevice(hwDeviceExtension->DeviceReference,
                            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart,
                            hwDeviceExtension->FrameBufferBase))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    return NO_ERROR;
}

//******************************************************************************
//
// Function:    NVFindAdapter()
//
// Routine Description:
//
//     This routine is called to determine if the adapter for this driver
//     is present in the system.
//     If it is present, the function fills out some information describing
//     the adapter.
//
// Arguments:
//
//     HwDeviceExtension - Supplies the miniport driver's adapter storage. This
//         storage is initialized to zero before this call.
//
//     HwContext - Supplies the context value which was passed to
//         VideoPortInitialize().
//
//     ArgumentString - Supplies a NULL terminated ASCII string. This string
//         originates from the user.
//
//     ConfigInfo - Returns the configuration information structure which is
//         filled by the miniport driver. This structure is initialized with
//         any known configuration information (such as SystemIoBusNumber) by
//         the port driver. Where possible, drivers should have one set of
//         defaults which do not require any supplied configuration information.
//
//     Again - Indicates if the miniport driver wants the port driver to call
//         its VIDEO_HW_FIND_ADAPTER function again with a new device extension
//         and the same config info. This is used by the miniport drivers which
//         can search for several adapters on a bus.
//
// Return Value:
//
//     This routine must return:
//
//     NO_ERROR - Indicates a host adapter was found and the
//         configuration information was successfully determined.
//
//     ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
//         error obtaining the configuration information. If possible an error
//         should be logged.
//
//     ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
//         supplied configuration information.
//
//******************************************************************************

VP_STATUS NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG NV1Slot;
    ULONG OutData;
    ULONG Status;
    PVOID NonCachedSystemMemoryPtr;
    ULONG TestSize;
    ULONG SysMemTextureFlag2;
    ULONG SysMemTextureFlag4;
    ULONG SysMemTextureFlag6;
    ULONG DMADisableFlag;
    ULONG DMAEnableFlag;
    ULONG DisableVBlankFlag;
    VP_STATUS   status;
    int i;
    PCI_COMMON_CONFIG pciData;
    PCI_COMMON_CONFIG ALIPciData;
    PCI_COMMON_CONFIG IntelPciData;
    ULONG SlotSearchNum;
    ULONG BusSearchNum;
    ULONG GetBusDataStatus;
    ULONG AliFoundStatus = FALSE;
    ULONG Intel810FoundStatus = FALSE;
    USHORT usVendorID, usDeviceID;
    BOOLEAN bIsPrimaryDevice;


    //**************************************************************************
    // Initialize this local variable before using it.
    //**************************************************************************
    //numAccessRanges = 0;

    //**************************************************************************
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //**************************************************************************

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }
#if (_WIN32_WINNT >= 0x0500)
    //**************************************************************************
    // Try to get VideoPortGetAssociatedDeviceID routine address
    //**************************************************************************
    hwDeviceExtension->pfnVideoPortGetAssociatedDeviceID = 
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension, "VideoPortGetAssociatedDeviceID");
#endif
    //  Make sure that we only called this once
    //  The reason why RmInitRm() is moved to FindAdapter is that
    //  W2k/Whistler will unload miniport right after DriverEntry
    //  during setup.  Since there is no way to clean up any buffer
    //  allocation which we allocate in RmInitRm(), we end up holding
    //  a chunk of memory.
    //  Also, RmInitRm allocates global clientInfo and dmaListElementPool.
    //  In W2k/Whistler, DriverEntry is called multiple time depending on
    //  the number of devices.  If RmInitRm() is called more than one time,
    //  the new allocation will overwritten the previous one without freeing
    //  them first.  This leads to memory leads.

    if(!g_bIsRmInitRmCalled)
    {
        if(!RmInitRm())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        g_bIsRmInitRmCalled = TRUE;
    }

    //**************************************************************************
    // Look for ALI 15411 chipset
    // Need to implement a workaround for chipset cache issues
    //**************************************************************************

    SlotSearchNum = 0;
    GetBusDataStatus = FALSE;
    AliFoundStatus   = FALSE;
    hwDeviceExtension->Via694ChipsetFound = FALSE;
    hwDeviceExtension->AMD751ChipsetFound = FALSE;


#if (_WIN32_WINNT >= 0x0500)
#if !defined(_WIN64)

    // Try to find ALI1541 chipset under Win2k
    //
    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &ALIPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************
   
    if (GetBusDataStatus > 2)
        {
        if ((ALIPciData.DeviceID == 0x1541) &&
            (ALIPciData.VendorID == 0x10B9))
            {
            AliFoundStatus = TRUE;
            }


        //**********************************************************************
        // Use the same structure, see if a VIA 694 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x691) &&
            (ALIPciData.VendorID == 0x1106))
            {
            hwDeviceExtension->Via694ChipsetFound = TRUE;
            }
    

        //**********************************************************************
        // Use the same structure, see if an AMD 751 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x7006) &&
            (ALIPciData.VendorID == 0x1022))
            {
                hwDeviceExtension->AMD751ChipsetFound = TRUE;
                // Note: Do not try to get the BAR1 address of the chipset.
                // It has not been set correctly at this point in time.
                // We will do that when we are going down in hibernation.
            }

        }
    //**************************************************************************
    // Try to find an Intel 810 chip
    //**************************************************************************

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                1,                          // slot number
                &IntelPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************

    if (GetBusDataStatus > 2)
        {
        if ( ((IntelPciData.DeviceID == 0x7121) || (IntelPciData.DeviceID == 0x7123) || (IntelPciData.DeviceID == 0x7125)) &&
            (IntelPciData.VendorID == 0x8086))
            {
            Intel810FoundStatus = TRUE;
            }

        }
#endif // !defined(_WIN64)


    //*************************************************************************
    // Save the size of physical system memory in the device extension.
    //*************************************************************************
    hwDeviceExtension->SystemMemorySize = ConfigInfo->SystemMemorySize;

#else // (_WIN32_WINNT >= 0x0500)

    // Try to find ALI1541 chipset under NT4

    while ( (SlotSearchNum<8) && (AliFoundStatus == FALSE) )
        {

        GetBusDataStatus = VideoPortGetBusData(
                           hwDeviceExtension,
                           PCIConfiguration,
                           SlotSearchNum,
                           &ALIPciData,
                           0,
                           PCI_COMMON_HDR_LENGTH
                           );

        //**************************************************************************
        // If status is Non-zero, and greater than 2, check the vendor id, device id
        //**************************************************************************

        if (GetBusDataStatus > 2)
            {
            if ((ALIPciData.DeviceID == 0x1541) &&
                (ALIPciData.VendorID == 0x10B9))
                {
                AliFoundStatus = TRUE;
                }

            }


        SlotSearchNum++;

        }

#endif

    //**************************************************************************
    // Tell the display driver to implement an IO workaround for the ALI 1541 chipset
    // Since FindAdapter gets called for the PCI and AGP buses, and
    // the HwDeviceExtension is NOT preserved, we unfortunately have to resort
    // to using a global variable.
    //**************************************************************************

    if (AliFoundStatus)
        Ali_1541_Chipset_Found = TRUE;

    //**************************************************************************
    // Check and see if NV adapter is present.  If NV is present, the
    // the BASE PHYSICAL address of NV is stored in the NVAccessRange
    // member of the device extension.
    //**************************************************************************

    // search for nvidia boards 
    Status = DetectNextDevice(hwDeviceExtension, 
                              &ulFindSlot,                            // global variable !!!
                              2,
                              hwDeviceExtension->NVAccessRanges, 
                              &usVendorID,
                              &usDeviceID,
                              &bIsPrimaryDevice, 
                              TRUE);                                   // claim resources
    if (NO_ERROR != Status)
    {
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    //  update some board related data in the device extension
    //
    hwDeviceExtension->ulSlot       = ulFindSlot;
    hwDeviceExtension->ulChipID     = (ULONG)(usDeviceID) & 0xffff;
    hwDeviceExtension->ulRevLevel   = REV_UNDEF;
    hwDeviceExtension->BoardID      = usVendorID;

    //
    // call our old NVIsPresent routine, this now only updates some RangeOffsets...
    //
    if (!NVIsPresent(hwDeviceExtension, &ulFindSlot))
        return(ERROR_DEV_NOT_EXIST);

    NV1Slot = ulFindSlot;


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // Code change request for Win2k per Microsoft
    // Fail if there is a resource conflict
    //**************************************************************************

    if ( (ConfigInfo->BusInterruptLevel == 0 ) && (ConfigInfo->BusInterruptVector == 0))
        return(ERROR_DEV_NOT_EXIST);

#endif

    //**************************************************************************
    // Initialize the Ali_1541 flag in the hwDeviceExtension according
    // to the global flag (Since VideoPortGetBusData doesn't work
    // across buses)
    //**************************************************************************

    if (Ali_1541_Chipset_Found == TRUE)
        hwDeviceExtension->AliChipset_Problem_Found = TRUE;


    //**************************************************************************
    // Assume that the device mapping will always succeed
    //**************************************************************************

    hwDeviceExtension->DeviceMappingFailed = FALSE;

    //**************************************************************************
    // Now map the NV registers so we can get to them
    //**************************************************************************
    Status = NVMapMemoryRanges(hwDeviceExtension);
    if (Status != NO_ERROR)
        {
        //**********************************************************************
        // Our device mapping requires 16Mb.  This call has ALWAYS succeeded, even on 32Mb
        // systems.  However, during Win2k unattended install with an Intel 810 present,
        // this call may fail. In order to workaround this, We set a flag acknowledging
        // this low memory situation.  Subsequent functions will have to be forced
        // to succeed (and do nothing), at least enough to get through the unattended install.
        //**********************************************************************

        if (Intel810FoundStatus == TRUE)

            {
            hwDeviceExtension->DeviceMappingFailed = TRUE;

            ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
            ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
            ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

            ConfigInfo->NumEmulatorAccessEntries     = 0;
            ConfigInfo->EmulatorAccessEntries        = NULL;
            ConfigInfo->EmulatorAccessEntriesContext = 0;

            ConfigInfo->HardwareStateSize = 0;

            *Again = 0;

            //******************************************************************
            // The only thing this function needed to do anyway
            // was to detect the presence of our chip
            //******************************************************************

            return NO_ERROR;
            }

        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Show all relevant Linear memory ranges to help debug
    //**************************************************************************

    VideoDebugPrint((0,"PMC = 0x%p \n", hwDeviceExtension->NV1_Lin_PMC_Registers));
    VideoDebugPrint((0,"PFB = 0x%p \n",hwDeviceExtension->NV1_Lin_PFB_Registers));
    VideoDebugPrint((0,"PRAMIN = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMIN_Registers));
    VideoDebugPrint((0,"PRAMFC = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMFC_Registers));
    VideoDebugPrint((0,"PRAMHT = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMHT_Registers));
    VideoDebugPrint((0,"PFIFO = 0x%p \n",hwDeviceExtension->NV1_Lin_PFIFO_Registers));
    VideoDebugPrint((0,"PBUS = 0x%p \n",hwDeviceExtension->NV1_Lin_PBUS_Registers));
    VideoDebugPrint((0,"PGRAPH = 0x%p \n",hwDeviceExtension->NV1_Lin_PGRAPH_Registers));
    VideoDebugPrint((0,"CONFIG = 0x%p \n",hwDeviceExtension->NV1_Lin_CONFIG_Registers));
    VideoDebugPrint((0,"PRAMDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMDAC_Registers));
    VideoDebugPrint((0,"USERDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_USERDAC_Registers));
    VideoDebugPrint((0,"PRMVIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMVIO_Registers));
    VideoDebugPrint((0,"PRMCIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMCIO_Registers));


#ifdef PC98

    //
    // POST the chip if we're running on a system with no VGA BIOS
    //
    NvPostEx(hwDeviceExtension);

#endif // PC98

    // initialize the RM device register mapping
    if (
        !RmInitNvMapping(
            (VOID*)hwDeviceExtension,
            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart,
            hwDeviceExtension->NvRegisterBase,
            &hwDeviceExtension->DeviceReference
        )
    )
    {
        return ERROR_DEV_NOT_EXIST;
    }

    // We need to update the IRQ info as the RM has not done this
    {
       U032 oldValue;

       // Get the hals view of the IRQ line from the adapter
       VideoPortGetBusData(
            hwDeviceExtension,
            PCIConfiguration,
            NV1Slot,
            &pciData,
            0,
            PCI_COMMON_HDR_LENGTH
            );

       // Go ahead and set the mapping
       RmConfigSetKernel(hwDeviceExtension->DeviceReference, NV_CFG_IRQ,
                                   (ULONG)pciData.u.type0.InterruptLine, &oldValue);

    }

    //**************************************************************************
    // Flag to denote if adapter is NON primary (ie..device was not booted)
    //**************************************************************************

    hwDeviceExtension->NonPrimaryDevice = FALSE;



    if (!bIsPrimaryDevice)
    {
        VP_STATUS ntStatus = NO_ERROR;
        PHYSICAL_ADDRESS fbPhysAddr;
        ULONG qtyBytesSet, inIoSpace, fbLength;
        PVOID fbAddr;
        // hook up the HAL state now that the chip is accessible
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }

        // create a large enuff temporary FB mapping to POST the device
        fbPhysAddr.HighPart = 0x00000000;
        fbPhysAddr.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        fbPhysAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
        fbLength = 0x04000000 + BIOS_MEM_SIZE_ADJUST_FACTOR;
        inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
        fbAddr = NULL;
        ntStatus = VideoPortMapMemory
        (
            hwDeviceExtension,
            fbPhysAddr,
            &fbLength,
            &inIoSpace,
            &fbAddr
        );
        if (ntStatus != NO_ERROR)
        {
            return ntStatus;
        }


        //**********************************************************************
        // Extract the BIOS image (64k) from either PROM or PRAMIN
        // (This function call behaves differently depending on whether
        // MEMORY_SPACE is set by VideoPortSetBusData)
        //**********************************************************************

        NVExtractBiosImage(hwDeviceExtension);


        // POST the device
        if (!RmPostNvDevice(hwDeviceExtension->DeviceReference, (PHWREG)(&(hwDeviceExtension->SavedBiosImageArray[0])), (PHWREG)fbAddr))
        {
            return ERROR_INVALID_PARAMETER;
        }

        // free up the temporary FB mapping
        VideoPortUnmapMemory(
            hwDeviceExtension,
            fbAddr,
            0
        );

        //**************************************************************************
        // If multiple adapters are present, do NOT invoke reset device
        //**************************************************************************

        MultiAdaptersPresent = TRUE;

        //**************************************************************************
        // Flag to denote if adapter is NON primary (ie..device was not booted)
        //**************************************************************************

        hwDeviceExtension->NonPrimaryDevice = TRUE;
    }
    else
    {
        // hook up the HAL state for the primary device
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }
    }

    //**************************************************************************
    // If this is the PRIMARY adapter, we still need to save off the BIOS image
    // (ExtractBiosImage behaves differently, the BIOS image will be in PROM or PRAMIN)
    //**************************************************************************

    if (hwDeviceExtension->NonPrimaryDevice == FALSE)
        NVExtractBiosImage(hwDeviceExtension);



    //**************************************************************************
    // Fill in NVInfo information structure
    //**************************************************************************

    if (NVGetNVInfo(hwDeviceExtension) == FALSE)
        return(ERROR_DEV_NOT_EXIST);        // Default to VGA if error getting info


    //
    // Store Memory Size
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &(hwDeviceExtension->NvInfo.Framebuffer.RamSize),
                                   sizeof(ULONG));

    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //**************************************************************************
    // Check the DisableVBLANK registry setting
    //**************************************************************************

    DisableVBlankFlag = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableVBlank",
                                       FALSE,
                                       NVRegistryCallback,
                                       NULL);

    if (DisableVBlankFlag == NO_ERROR)
        hwDeviceExtension->DisableVBlankFlag = TRUE;
    else
        hwDeviceExtension->DisableVBlankFlag = FALSE;

    //**************************************************************************
    // Check to see if we should handle IF09 format video data.
    //**************************************************************************
    hwDeviceExtension->bEnableIF09 = TRUE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"IF09",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bEnableIF09));
#if _WIN32_WINNT < 0x0500
    //**************************************************************************
    // Check the EnableExtRefresh registry setting. If this is false or
    // not present we limit refresh rates to 85Hz.
    //**************************************************************************
    hwDeviceExtension->bExtRefreshDisable = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableExtRefresh",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bExtRefreshDisable));
#endif // #if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Check the Disable19x12Mode registry setting.
    //**************************************************************************
    hwDeviceExtension->bMax16x12 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Max16x12",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bMax16x12));

    hwDeviceExtension->bDisable19x12x32at60 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x12x32at60",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x12x32at60));

    hwDeviceExtension->bDisable16x12x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable16x12x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable16x12x32ge70));

    hwDeviceExtension->bDisable19x10x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x10x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x10x32ge70));

    hwDeviceExtension->ulDisableDfpModesGreaterThan = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableDfpModesGreaterThan",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->ulDisableDfpModesGreaterThan));

    //**************************************************************************
    // DellSwitch1 registry switch 1:
    //
    // 1) Add 1600x1024 modes 76hz for specific customers
    // 2) Also change 1920x1200 75Hz to 1920x1200 76Hz
    //**************************************************************************

    hwDeviceExtension->bDellSwitch1 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DellSwitch1",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDellSwitch1));


    //**************************************************************************
    // OGL Stencil registry switch
    //**************************************************************************

    hwDeviceExtension->OglStencilSwitch = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"OglStencil",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->OglStencilSwitch));

    //**************************************************************************
    // Force SW cursor registry switch
    //**************************************************************************

    hwDeviceExtension->ulForceSwCursor = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"ForceSwCursor",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->ulForceSwCursor));


    //**************************************************************************
    // This function is only meaningful for NV4 or better (uses newer RM modeset code)
    // It creates the list of available modes, depending on
    // what modes are available in vesadata.c, and what modes
    // are specified in the registry
    //**************************************************************************

    BuildAvailableModesTable(HwDeviceExtension);

    //**************************************************************************
    // This function is only meaningful for NV4 or better
    // If the NV registry switches are NOT present, then write them to the registry.
    // (Otherwise read the registry values).
    // Then load the registry values into the NT_NV_REGISTRY structure
    // so the miniport/display driver can get to them.
    //**************************************************************************

    LoadRegistrySettings(HwDeviceExtension);


    //**************************************************************************
    // ** MODE DATA FIXUP HACK **
    // The ModeTimingTable is normally a fixed STATIC data table.
    // We can't just ADD another refresh rate without some major changes.
    // So for now, just manually change the 1920x1200 75Hz timing to 1920x1200 76Hz
    // (Note: ValidateModes in nvmode.c also needs to be changed!)
    //
    // OEM Customer wants a SPECIFIC 76hz timing which is NOT GTF or DMT compliant.
    // So we'll accommodate them an use their specific timing....
    //**************************************************************************

    if (hwDeviceExtension->bDellSwitch1)
        {

// Standard GTF timing

//        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2624;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 2064;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2272;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1253;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1201;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1204;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24988;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;

// OEM specific requested timing (for Wide Sony monitor)

        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2584;
        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 1984;
        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2240;
        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1250;
        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1203;
        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1206;
        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24548;
        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;
        ModeTimingTable[14*NUMBER_OF_RATES+3][8] = BUFFER_HSYNC_NEGATIVE;
        ModeTimingTable[14*NUMBER_OF_RATES+3][9] = BUFFER_VSYNC_NEGATIVE;


        }


#if _WIN32_WINNT >= 0x0500
    //**************************************************************************
    // Determine if we should DISABLE AGP support (Default=ENABLE AGP support)
    //**************************************************************************
    status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DisableAgp",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisableAgp));


#endif // #if _WIN32_WINNT >= 0x0500


#ifdef NVPE
    //**************************************************************************
    // Determine if we should DISABLE VPE (Video Port Extension that controls
    // the Media Port). Default is VPE Enabled !
    //**************************************************************************
    status = VideoPortGetRegistryParameters(
                hwDeviceExtension,
                L"VPEENABLE",
                FALSE,
                NVRegistryCallbackPnpId,
                (PVOID)(&(hwDeviceExtension->dwVPEEnabled)));
    if (status != NO_ERROR)
    {
       // most probably, we didn't find the VPEEnable key, so enable VPE by default !!!
       hwDeviceExtension->dwVPEEnabled = TRUE;
    }
#endif


    *Again = 0;

#if _WIN32_WINNT < 0x0500

    //
    // on NT4 *Again == TRUE indicates the OS to call us back for a further device with FindAdapter and a new hwDeviceExtension
    // so we check here if this is necessary 
    // different here is that we don't want to claim the resources
    //
    {
        ULONG ulNextSlot;
        BOOLEAN bPrimDev;
        USHORT usVendorID, usDeviceID;
        ulNextSlot = ulFindSlot;
        if (NO_ERROR == DetectNextDevice( hwDeviceExtension, 
                                        &ulNextSlot,
                                        2,
                                        NULL, 
                                        &usVendorID,
                                        &usDeviceID,
                                        &bPrimDev,
                                        FALSE))
        {
            *Again = TRUE;
        }
        else
        {
            // reset global slot counter to be ready for the next bus...
            ulFindSlot = 0xFFFFFFFF;
        }
    }
#endif
    
    NVUpdateRegNVInfo(hwDeviceExtension);

#if _WIN32_WINNT >= 0x0500
    //**************************************************************************
    // Copy driver registry path over
    //**************************************************************************
    for (i = 0; i < sizeof(hwDeviceExtension->DriverRegPath) && ConfigInfo->DriverRegistryPath[i] != 0; i++)
        hwDeviceExtension->DriverRegPath[i] = (UCHAR)ConfigInfo->DriverRegistryPath[i];
    if (i < sizeof(hwDeviceExtension->DriverRegPath))
        hwDeviceExtension->DriverRegPath[i] = 0;

    //
    // Read in the registry entry to see if we shoud export the EDID for the DFP or not.
    // This is only to fix a Win2k PnP bug of failing to install PnP monitor.  It only affects Win2k
    //
    hwDeviceExtension->DFPAsDefaultMonitor = 0;
    if (!(ConfigInfo->VideoPortGetProcAddress)(hwDeviceExtension, "VideoPortCreateSecondaryDisplay"))
    {
        VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DFPAsDefaultMonitor",
                                       FALSE,
                                       NVRegistryCallback,
                                       (PVOID)&hwDeviceExtension->DFPAsDefaultMonitor);
    }

    //**************************************************************************
    // Enable DualView based several rules
    // 1. Check if setup allows it
    // 2. Check if OS supports it 
    // 3. Check if the chipn has the capability
    //**************************************************************************
    status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"EnableDualView",
                                       FALSE,
                                       NVRegistryCallback,
                                       &OutData);
    if (status == NO_ERROR && OutData)
    {
        typedef
        VP_STATUS
        (*PVIDEO_PORT_CREATE_SECONDARY_DISPLAY)(
            IN PVOID     HwDeviceExtension,
            IN OUT PVOID *SecondaryDeviceExtension,
            IN ULONG     ulFlag
        );
        PVIDEO_PORT_CREATE_SECONDARY_DISPLAY VideoPortCreateSecondaryDisplay = NULL;

        if (ConfigInfo->VideoPortGetProcAddress)
        {
            VideoPortCreateSecondaryDisplay = (PVIDEO_PORT_CREATE_SECONDARY_DISPLAY)
                                              ((ConfigInfo->VideoPortGetProcAddress)(hwDeviceExtension, "VideoPortCreateSecondaryDisplay"));
            if (VideoPortCreateSecondaryDisplay)
            {
                //
                // For Dualview, we moved NVInitRm from HwInitialize to FindAdapter for the reason of detecting DACs beforehand.
                // One side effect of this change is that NVInitRm enables interrupt by itself, thus cause VideoPortFindAdapter
                // having trouble at IOConnectInterrupt (An Interrupt storm happens on toshiba when Reboot).  The fix is to 
                // Disable Interrupt explicitly here and enable it explicitly at NVInitialize.
                //
                if (NVInitRm(hwDeviceExtension) != NO_ERROR)
                    return ERROR_INVALID_PARAMETER;
                NV_DisableNVInterrupts(hwDeviceExtension);

                // Check if it's Laptop
                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                                   L"DualviewMobile",
                                                   FALSE,
                                                   NVRegistryCallback,
                                                   &OutData);
                if (status == NO_ERROR && OutData)
                {
                   hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_MOBILE;
                }

                //
                // Only we have two DACs (and physically connected two devices for Desktop),
                // have enough video memory, we enable DualView
                //
                if (NVGetNumBootDevices(hwDeviceExtension) > 1 &&
                    hwDeviceExtension->NvInfo.Framebuffer.RamSize >= VIDEOMEMSIZELIMIT_FOR_DUALVIEW)
                {
                    PHW_DEVICE_EXTENSION hwDE2;
                    status = VideoPortCreateSecondaryDisplay(HwDeviceExtension,
                                                             (PVOID*)&hwDE2,
                                                             (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) ? VIDEO_DUALVIEW_REMOVABLE : 0);
                    if (status == NO_ERROR)
                    {
                        hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_ENABLE_DUALVIEW;

                        VideoPortMoveMemory(hwDE2, hwDeviceExtension, sizeof(HW_DEVICE_EXTENSION));
                        hwDE2->ulDualViewStatus |= DUALVIEW_STATUS_SECONDARY;
                        hwDE2->pDualViewAssociatedDE = hwDeviceExtension;
                        hwDeviceExtension->pDualViewAssociatedDE = hwDE2;

                        // BUGBUG  We assume secondary display always be primary device index plus 1.
                        // But the assumption is broken on combination of Multimon and Dualview
                        // The regkey path should only be used for debug purposes
                        for (i = 0; i < sizeof(hwDE2->DriverRegPath) && ConfigInfo->DriverRegistryPath[i] != 0; i++)
                            hwDE2->DriverRegPath[i] = (UCHAR)ConfigInfo->DriverRegistryPath[i];
                        if (i < sizeof(hwDE2->DriverRegPath))
                            hwDE2->DriverRegPath[i] = 0;
                        if (i != 0)
                            hwDE2->DriverRegPath[i]++;

                        NVUpdateRegNVInfo(hwDE2);
                    }
                }
            }
        }
    }

#endif // #if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Indicate a successful completion status.
    //**************************************************************************

    return NO_ERROR;

    } // NVFindAdapter()


#if (_WIN32_WINNT >= 0x0500)
//*******************************************************************************
//
//  Function: NVUpdateDualViewDevice
//
//  For DualView.
//
//  Update the secondary display Hardware_Device_Extension and copy relevant
//  information after HwInitialize() be called.
//
//*******************************************************************************

VOID NVUpdateDualViewDevice (PHW_DEVICE_EXTENSION pHwDE)
    {
    PHW_DEVICE_EXTENSION    pHwDE2;
    ULONG                   status;
    ULONG                   SecondviewMemSize, dwMinSize = 640*480;

    //
    // We can not copy ALL HwDeviceExtension data
    //
    if ((pHwDE2 = pHwDE->pDualViewAssociatedDE) == NULL)
        return;

    pHwDE2->CursorTopScanLine    = pHwDE->CursorTopScanLine;
    pHwDE2->CursorBottomScanLine = pHwDE->CursorBottomScanLine;
    pHwDE2->CursorEnable         = pHwDE->CursorEnable;
    pHwDE2->curAdapterPowerState = pHwDE->curAdapterPowerState;
    pHwDE2->curMonitorPowerState = pHwDE->curMonitorPowerState;
    pHwDE2->BiosArea             = pHwDE->BiosArea;
    pHwDE2->flMapMemory          = pHwDE->flMapMemory;

    pHwDE2->NvInfo          = pHwDE->NvInfo;
    pHwDE2->FrameBufferPtr  = pHwDE->FrameBufferPtr;
    pHwDE2->FrameBufferBase = pHwDE->FrameBufferBase;

    pHwDE2->TotalInstanceMemory = pHwDE->TotalInstanceMemory;

    pHwDE2->AgpPagesTotal   = pHwDE->AgpPagesTotal;
    pHwDE2->bAgp            = pHwDE->bAgp;
    pHwDE2->AgpServices     = pHwDE->AgpServices;

    pHwDE2->GammaCache      = pHwDE->GammaCache;
    VideoPortMoveMemory(pHwDE2->GammaCacheData, pHwDE->GammaCacheData, sizeof(pHwDE->GammaCacheData));

    pHwDE2->ulCurrentMacrovisionKey = pHwDE->ulCurrentMacrovisionKey;
    pHwDE2->ulNextMacrovisionKey    = pHwDE->ulNextMacrovisionKey;
    pHwDE2->ulMacrovisionMode       = pHwDE->ulMacrovisionMode;

    pHwDE2->MaxFlatPanelWidth  = pHwDE->MaxFlatPanelWidth;
    pHwDE2->MaxFlatPanelHeight = pHwDE->MaxFlatPanelHeight;

    //
    // Corresponding to NVInitialize_DacsAndEDID(pHwDE2, TRUE);
    // The heads need to be reversed
    //
    pHwDE2->EdidCollection  = pHwDE->EdidCollection;
    pHwDE2->DeskTopInfo     = pHwDE->DeskTopInfo;
    {
        NVTWINVIEWDATA TwinviewInfo;

        if (NVGetRegistryTwinviewInfo(pHwDE, &TwinviewInfo) == NO_ERROR)
        {
            NVSetRegistryTwinviewInfo(pHwDE2, &TwinviewInfo);
        }
    }
    
    SetTimingOverRide(pHwDE2);

    //
    // Corresponding to InitializeCommonModesetCode()
    //
    pHwDE2->pFPStateSave         = pHwDE->pFPStateSave;
    pHwDE2->pFPMutex             = pHwDE->pFPMutex;
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_8bpp, pHwDE->maxPixelClockFrequency_8bpp, sizeof(pHwDE->maxPixelClockFrequency_8bpp));
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_16bpp, pHwDE->maxPixelClockFrequency_16bpp, sizeof(pHwDE->maxPixelClockFrequency_16bpp));
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_32bpp, pHwDE->maxPixelClockFrequency_32bpp, sizeof(pHwDE->maxPixelClockFrequency_32bpp));

    NVSetBiosInfo(pHwDE2);
    NVValidateModes(pHwDE2);
    }
#endif


//******************************************************************************
//
// Function: NVInitialize()
//
// Routine Description:
//
//     This routine does one time initialization of the device.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOLEAN NVInitialize(
    PVOID HwDeviceExtension
    )
    {

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Status;


    //**************************************************************************
    // Check for unattended install with Intel 810.
    // If so, then just return true.
    //**************************************************************************

    if (hwDeviceExtension->DeviceMappingFailed == TRUE)
        return TRUE;

    //**************************************************************************
    // Set up the default cursor position and type.
    //**************************************************************************


    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    hwDeviceExtension->BiosArea = (PUSHORT)NULL;

    //***************************************************************************
    // Default to disabling write combining when mapping fb.
    //***************************************************************************
    hwDeviceExtension->flMapMemory = 0;

    //***************************************************************************
    // Initialize current power state.
    //***************************************************************************
    hwDeviceExtension->curAdapterPowerState = VideoPowerOn;
    hwDeviceExtension->curMonitorPowerState = VideoPowerOn;

    if (NVInitRm(hwDeviceExtension) != NO_ERROR)
        return FALSE;

    // One time initialization of the twinview structures.
    NVOneTimeInit_TwinView(hwDeviceExtension);

    // One time initialization of the saveSettings table.
    vInitializeSaveSettings(hwDeviceExtension);

    // Debug print
    vPrintSaveSettings(hwDeviceExtension);

    // Detect the Head info and read in the EDIDs
    // The TRUE indicates it is a boottime operation.
    if (!NVInitialize_DacsAndEDID(hwDeviceExtension, TRUE))
    {
        return FALSE;
    }

    // Initialize our CRT timing standard overrides.
    SetTimingOverRide(HwDeviceExtension);

    // One time initialization of the common mode set code fields.
    InitializeCommonModesetCode(hwDeviceExtension);

    // One time initialization of the mapping of power states from Win2K's states to nVidia's states.
    InitializeACPIStates(hwDeviceExtension);


    //**************************************************************************
    // Store BIOS revision string in the registry. This must be
    // done now since we need to call the RM to get the BIOS rev,
    // and the RM is not fully initialized at FindAdapter time.
    //**************************************************************************
    NVSetBiosInfo(hwDeviceExtension);

    //**************************************************************************
    // Get monitor info (TV out) into NVInfo struct
    //**************************************************************************
    NVGetMonitorType(hwDeviceExtension);

    //**************************************************************************
    // Get total amount of instance memory.
    // We need to save/restore all of instance memory across a Win2k standby
    //**************************************************************************

    RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_INSTANCE_TOTAL, &(hwDeviceExtension->TotalInstanceMemory));

    if (hwDeviceExtension->TotalInstanceMemory > MAX_INSTANCE_MEM_SIZE)
        {
        VideoDebugPrint((2, "ERROR:  ----------------------------- !!!!\n"));
        VideoDebugPrint((2, "ERROR:  Need to increase size of      !!!!\n"));
        VideoDebugPrint((2, "ERROR:  SavedInstanceMemory buffer    !!!!\n"));
        VideoDebugPrint((2, "ERROR:  in HwDeviceExtension          !!!!\n"));
        VideoDebugPrint((2, "ERROR:  ----------------------------- !!!!\n"));
        }

    //**************************************************************************
    // Validate the modes.
    // This function call was originally in NVFindAdapter.
    // However, since it depends on the result of GetMonitorType,
    // (whether we're running on a TV or not), it needs to occur
    // AFTER GetMonitorType.
    //**************************************************************************

    NVValidateModes(hwDeviceExtension);

    // Check to see if the DFP supports 1400x1050 natively on a laptop.
    Verify1400x1050DFP(hwDeviceExtension);

#if (_WIN32_WINNT >= 0x0500) && (!defined(DISABLE_AGP))
    {
    //**************************************************************************
    // Check registry switch to see if we disabled AGP support
    //**************************************************************************

    if (hwDeviceExtension->bDisableAgp)
        goto Agp_Done;

    //**************************************************************************
    // Disable AGP if running on an ALI 1541 chipset
    //**************************************************************************

    if (hwDeviceExtension->AliChipset_Problem_Found)
        goto Agp_Done;

    hwDeviceExtension->AgpPagesTotal = ((MAX_AGP_HEAP + (PAGE_SIZE - 1)) &
                                            ~(PAGE_SIZE - 1)) / PAGE_SIZE;

    //***********************************************************
    // Determine if AGP memory is available.
    //***********************************************************
    hwDeviceExtension->bAgp =
        VideoPortGetAgpServices(hwDeviceExtension,
            &(hwDeviceExtension->AgpServices));
    }
Agp_Done:

    //**************************************************************************
    // If successful, let the RM know where the AGP services are
    //**************************************************************************
    if (hwDeviceExtension->bAgp)
    {
        RmSetAgpServices(hwDeviceExtension->DeviceReference,
                         &hwDeviceExtension->AgpServices);
    }

#endif // #if _WIN32_WINNT >= 0x0500

    {
      PVIDEO_CLUTDATA   pvcdItem;
      int i, iHead;

      VideoDebugPrint((1, "NVInitialize - Initializing the Gamma cache values to defaults\n"));

      // - Init the clut params
      hwDeviceExtension->GammaCache.NumEntries = 256;
          hwDeviceExtension->GammaCache.FirstEntry = 0;

                pvcdItem = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;

      // - Init the CLUT data to a default gamma ramp
      for(iHead = 0; iHead < NV_NO_DACS; iHead++)
      {
        for(i = 0; i < 256; i++) 
        {
            pvcdItem[i+iHead*256].Blue   = (UCHAR)i; /* blue value */
            pvcdItem[i+iHead*256].Green  = (UCHAR)i; /* green value */
            pvcdItem[i+iHead*256].Red    = (UCHAR)i; /* red value */
            pvcdItem[i+iHead*256].Unused = (UCHAR)0; /* unused value */
        }
      }

    }

   
    // To rid oursleves of some nasty visual effects when opening the panel when on a TV,
    // we need to stash the encoder status and type in the registry for later reference
    {
        NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
        ULONG TVEncoderType;
        ULONG TVEncoderID;

        // Assume that this adapter lacks a TV encoder 
        TVEncoderType = TV_ENCODER_NONE;
        TVEncoderID = 0;

        // Use head 0 for this case
        TVInfo.Head = 0;
        TVInfo.EncoderType = TV_ENCODER_NONE;
        TVInfo.EncoderID = 0;

        // Attemp the resman call for the encoder info...
        if (RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_TV_ENCODER_INFO_MULTI, &TVInfo, 
                                sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS)))

        {

            // We have a valid blob from the resman, so extract the encoder info
            TVEncoderType = TVInfo.EncoderType;
            TVEncoderID = TVInfo.EncoderID;

        }
        else
        {

            // The resman had issues with our request, so spew a warning
            VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_GET_TV_ENCODER_INFO_MULTI\n"));
        }

        //
        // Save the encoder info in the HwDevExtension as it gets referenced frequently
        //
        hwDeviceExtension->ulTVEncoderType = TVEncoderType;
        hwDeviceExtension->ulTVEncoderID =   TVEncoderID;

        //
        // Set up the max TV resolution. We need to pass it to the common modeset code while calling
        // FindModeEntry().
        //
        if (TVInfo.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            hwDeviceExtension->ulMaxTVOutResolution = (1024 << 16) | 768;
        }
        else
        {
            hwDeviceExtension->ulMaxTVOutResolution = (800 << 16) | 600;
        }


        // No matter what the outcome above, flush the derived encoder values to the registry

        VideoPortSetRegistryParameters( HwDeviceExtension,
                                        L"TVEncoderType",
                                        &TVEncoderType,
                                        sizeof(ULONG));

        VideoPortSetRegistryParameters( HwDeviceExtension,
                                        L"TVEncoderID",
                                        &TVEncoderID,
                                        sizeof(ULONG));

    }

    // After initialing the EDIDs, parse the EDIDs for the best supported resolution the first time boot
    // after driver installation.
    HandleBestResolution(HwDeviceExtension);
    

#if (_WIN32_WINNT >= 0x0500)
    // Initializing the macrovision
    hwDeviceExtension->ulCurrentMacrovisionKey = -1;
    hwDeviceExtension->ulNextMacrovisionKey = 0x99999999;
    hwDeviceExtension->ulMacrovisionMode = 3;

    NVUpdateDualViewDevice(hwDeviceExtension);
#endif
    return TRUE;

    } // NVInitialize()


//******************************************************************************
//
// Function: NVStartIO()
//
// Routine Description:
//
//    This routine is the main execution routine for the miniport driver. It
//    acceptss a Video Request Packet, performs the request, and then returns
//    with the appropriate status.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
//    RequestPacket - Pointer to the video request packet. This structure
//        contains all the parameters passed to the VideoIoControl function.
//
// Return Value:
//
//    This routine will return error codes from the various support routines
//    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
//    buffers and ERROR_INVALID_FUNCTION for unsupported functions.
//
//******************************************************************************


BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG byteLength;
    ULONG sharedViewSize;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG Address;
    PHYSICAL_ADDRESS NVFrameBuffer;
    PHYSICAL_ADDRESS AliFixupBaseAddress;
    ULONG IOLength;
    PVOID AliVirtualAddress;
    PHWINFO NVInfo;

    //**************************************************************************
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //**************************************************************************

    VideoDebugPrint((2, "W32StartIO Entry - %08.8x\n", RequestPacket->IoControlCode));

    switch (RequestPacket->IoControlCode) {
    
#ifdef ENABLE_WIN2K_HOTKEY_CODE
#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // GET_CHILD_STATE
    //**************************************************************************
    case IOCTL_VIDEO_GET_CHILD_STATE:
        
        VideoDebugPrint((1, "\nW32StartIO - SetChildState\n"));
        status = NVGetChildState(HwDeviceExtension, RequestPacket);
        break;

    //**************************************************************************
    // VALIDATE_CHILD_STATE_CONFIGURATION
    //**************************************************************************
    case IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION:

        VideoDebugPrint((1, "\nW32StartIO - ValidateChildStateConfiguration\n"));
        status = NVValidateChildState(HwDeviceExtension, RequestPacket);
        break;

    //**************************************************************************
    // SET_CHILD_STATE_CONFIGURATION
    //**************************************************************************
    case IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION:

        VideoDebugPrint((1, "\nW32StartIO - SetChildStateConfiguration\n"));
        status = NVSetChildState(HwDeviceExtension, RequestPacket);
        break;

#endif _WIN32_WINNT >= 0x0500
#endif ENABLE_WIN2K_HOTKEY_CODE

#if (_WIN32_WINNT >= 0x0500)
    //**************************************************************************
    // SWITCH_DUALVIEW
    //**************************************************************************
    case IOCTL_VIDEO_SWITCH_DUALVIEW:

        VideoDebugPrint((1, "\nW32StartIO - Switch Dualview\n"));
        status = NVSwitchDualView(HwDeviceExtension, *((PULONG)RequestPacket->InputBuffer));
        break;
#endif _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // SHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:


        VideoDebugPrint((2, "W32StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
            }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //**********************************************************************
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //**********************************************************************

        //**********************************************************************
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //
        //       When sharing memory (for Direct X), we must make sure that
        //       we don't give anyone else access to the last 196k or so of offscreen VRAM.
        //       Otherwise, someone else may corrupt our instance memory.
        //**********************************************************************

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = 0;

        //**********************************************************************
        // NOTE: we are ignoring ViewOffset
        //**********************************************************************

        shareAddress.HighPart = 0x00000000;
        shareAddress.LowPart = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        shareAddress.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

        //**********************************************************************
        // Specifying virtualAddress = 0 will cause this address to be
        // mapped into the address space of the current process
        //**********************************************************************
        inIoSpace |= hwDeviceExtension->flMapMemory;
        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        //**********************************************************************
        // Returned shared virtual address to specific process
        //**********************************************************************

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    //**************************************************************************
    // UNSHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "W32StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    //**************************************************************************
    // QUERY_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((1, "NVStartIO - Map W32 MMU or ACL\n"));

        //**********************************************************************
        // Currently, we'll be giving the display driver
        // public access to 5 ranges (in addition to the frame buffer)
        //
        //     1) User Channel
        //     2) Graphics Status register (to check for Engine Busy)
        //     3) Vertical Blank (PFB_CONFIG_0 register)
        //     4) Frame Buffer Start Address
        //     5) DAC Registers
        //
        // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
        //
        //
        // NV3: We also need access to the following memory ranges for NV3
        //      to access the cursor, vertical,miscellaneous registers
        //      which are different from NV1.
        //
        //     6) PRMCIO
        //     7) PRMVIO
        //     8) PRAMDAC
        //     9) PRAMIN (So we can get to the cursor image data)
        //     10) TEXTURE DATA (in System Memory)
        //     11) PGRAPH Registers
        //     12) DMA Buffer Area (Fixed/Locked contiguous memory)
        //     13) PFIFO Registers
        //
        //**********************************************************************

        if (RequestPacket->OutputBufferLength <
            13 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        else

            {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PVOID                       base;
            ULONG                       ulIndex;

            //******************************************************************
            // Currently, we'll be giving the display driver
            // public access to 5 ranges (in addition to the frame buffer)
            //
            //     1) User Channel
            //     2) Graphics Status register (to check for Engine Busy)
            //     3) Vertical Blank (PFB_CONFIG_0 register)
            //     4) Frame Buffer Start Address
            //     5) DAC Registers
            //
            // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
            //
            //
            // NV3: We also need access to the following memory ranges for NV3
            //      to access the cursor,vertical,miscellaneous registers
            //      which are different from NV1.
            //
            //     6) PRMCIO
            //     7) PRMVIO
            //     8) PRAMDAC
            //     9) PRAMIN (So we can get to the cursor image data)
            //     10) TEXTURE DATA (in System Memory)
            //     11) PGRAPH Registers
            //
            //******************************************************************

            RequestPacket->StatusBlock->Information =
                12 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            //******************************************************************
            // Map the NV user channel area (Treat it like Memory Mapped IO)
            //******************************************************************

            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            //******************************************************************
            // We now use just 1 mapping to access ALL registers, and
            // just 1 mapping to access the framebuffer.  Display Driver,
            // miniport, and Resource Manager now use the same mappings!
            // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
            //******************************************************************

            status = NO_ERROR;

            portAccess->VirtualAddress  = (PVOID)(hwDeviceExtension->NvRegisterBase);
            base                         = (PVOID)(hwDeviceExtension->NvRegisterBase);



//Map_PGRAPH_Status:

            //******************************************************************
            // Map the second range for the PGRAPH Status register
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset;

//Map_PFG_CONFIG_0:

            //******************************************************************
            // Map the third range for the PFB_CONFIG_0 register
            // (so we can check for vertical blanking)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset;

//Map_PFB_Start_Address:

            //******************************************************************
            // Map the fourth range for the PFB_START_ADDRESS register
            // (so we can flip the current buffer)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_DAC_Regs:

            //******************************************************************
            // Map the fifth range for the DACRegs memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;



//Map_PRMCIO_Regs:

            //******************************************************************
            // Map the sixth range for the NV3 PRMCIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;

            //******************************************************************
            // PRMCIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMCIO_INDEX].ulOffset;


//Map_PRMVIO_Regs:

            //******************************************************************
            // Map the seventh range for the NV3 PRMVIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRMVIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMVIO_INDEX].ulOffset;


//Map_PRAMDAC_Regs:

            //******************************************************************
            // Map the eighth range for the NV3 PRAMDAC memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRAMDAC only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRAMDAC_INDEX].ulOffset;


//Map_PRAMIN_Memory:

            //******************************************************************
            // Map the ninth range for the NV3 PRAMIN Instance Memory
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_Texture_Buffer:

            //******************************************************************
            // Map the Tenth range to contain information about
            // the texture buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;



//Map_PGRAPH_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Eleventh range for the NV3 PGRAPH registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_INDEX].ulOffset;

//Map_PFIFO_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Twelfth range for the NV3 PFIFO registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFIFO_INDEX].ulOffset;


//Map_NV3_DMA_Buffer_Area:

            //******************************************************************
            // Map the 13th range to contain information about
            // the DMA buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;

            }

        break;

    //**************************************************************************
    // FREE_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((2, "NVStartIO - FreePublicAccessRanges\n"));

        {
        PVIDEO_MEMORY mappedMemory;
        ULONG i;

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        status = NO_ERROR;


        //******************************************************************
        // We now use just 1 mapping to access ALL registers, and
        // just 1 mapping to access the framebuffer.  Display Driver,
        // miniport, and Resource Manager now use the same mappings!
        // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
        //
        // It never gets unmapped, and is always available
        //******************************************************************

        }

        break;

    //**************************************************************************
    // MAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //*********************************************************************
        // Make sure to set the VideoRamLength!
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //
        //*********************************************************************

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        //*********************************************************************
        // Get the ptr to the NVInfo structure and initialize the video ram
        // length to be mapped.  DO NOT use hwDeviceExtension->AdapterMemorySize
        // because that value is NOT aligned on a MB boundary (it's adjusted to
        // exclude a portion of video memory).  Using that value would cause
        // the VideoPortMapMemory call to NOT correctly set write combining.
        // Use Framebuffer.RamSize instead !!!
        //*********************************************************************

        NVInfo = &(hwDeviceExtension->NvInfo);

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // So just return that mapping...Mapping is done in ONE place
        // ONLY, so the miniport, RM, and display driver can access it.
        // (No more multiple mappings of the frame buffer!)
        //**********************************************************************

        memoryInformation->FrameBufferBase = hwDeviceExtension->FrameBufferPtr;
        memoryInformation->FrameBufferLength = NVInfo->Framebuffer.RamSize;

        status = NO_ERROR;


        break;

    //**************************************************************************
    // UNMAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // It's mapped one time, and doesn't get unmapped
        //**********************************************************************

        status = NO_ERROR;

        break;

    //**************************************************************************
    // QUERY_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryAvailableModes\n"));

        status = NVQueryAvailableModes(hwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_NUM_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryNumAvailableModes\n"));

        status = NVQueryNumberOfAvailableModes(hwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_CURRENT_MODE
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "NVStartIO - QueryCurrentMode\n"));

        status = NVQueryCurrentMode(hwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // GET TIMING OF DAC at giving resolution
    //
    //**************************************************************************
    case IOCTL_VIDEO_GET_TIMING_DAC:
    {
        HEAD_RESOLUTION_INFO * pResolution;
        DAC_TIMING_VALUES * pTimingInfo;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(HEAD_RESOLUTION_INFO))
        {
            pResolution = (HEAD_RESOLUTION_INFO *) RequestPacket->InputBuffer;
            if(RequestPacket->OutputBufferLength == sizeof(DAC_TIMING_VALUES))
            {
                pTimingInfo = (DAC_TIMING_VALUES *) RequestPacket->OutputBuffer;
                if(NVGetTimingForDac(hwDeviceExtension, pResolution, pTimingInfo))
                {
                    // Patch for Timing values.  Our engine only accepts values aligned to 8
                    pTimingInfo->HorizontalTotal &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalBlankStart &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalRetraceStart &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalRetraceEnd &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalBlankEnd &= 0xFFFFFFFC;

                    RequestPacket->StatusBlock->Information = sizeof(DAC_TIMING_VALUES);
                    status = NO_ERROR;
                }
            }
        }
    }

    break;

    //**************************************************************************
    // Call RM before set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_PREMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPreModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;
            }
        }


    }
    break;

    //**************************************************************************
    // Call RM after set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_POSTMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPostModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;

            }

        }


    }
    break;

    //**************************************************************************
    // Setup Virtual Desktop information
    //**************************************************************************
    case IOCTL_VIDEO_SET_DESKTOP_INFO_MODE:
        {
            NV_DESKTOP_INFO * pDeskTop;
            ULONG i;

            if(RequestPacket->InputBufferLength == sizeof(NV_DESKTOP_INFO))
            {
                pDeskTop = (NV_DESKTOP_INFO *) RequestPacket->InputBuffer;
                hwDeviceExtension->DeskTopInfo.ulDesktopModeIndex = pDeskTop->ulDesktopModeIndex;

                hwDeviceExtension->DeskTopInfo.ulDesktopMode = pDeskTop->ulDesktopMode;
                hwDeviceExtension->DeskTopInfo.ulTwinView_State = pDeskTop->ulTwinView_State;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard = pDeskTop->ulNumberDacsOnBoard;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = pDeskTop->ulNumberDacsConnected;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsActive = pDeskTop->ulNumberDacsActive;

                hwDeviceExtension->DeskTopInfo.ulDesktopWidth = pDeskTop->ulDesktopWidth;
                hwDeviceExtension->DeskTopInfo.ulDesktopHeight = pDeskTop->ulDesktopHeight;

                hwDeviceExtension->DeskTopInfo.ulAllDeviceMask = pDeskTop->ulAllDeviceMask;
                hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask = pDeskTop->ulConnectedDeviceMask;

                for(i = 0; i < NV_NO_DACS; i++)
                {
                    hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i] = pDeskTop->ulDisplayWidth[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i] = pDeskTop->ulDisplayHeight[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayRefresh[i] = pDeskTop->ulDisplayRefresh[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[i] = pDeskTop->ulDisplayPixelDepth[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i] = pDeskTop->ulDeviceDisplay[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceMask[i] = pDeskTop->ulDeviceMask[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceType[i] = pDeskTop->ulDeviceType[i];
                    hwDeviceExtension->DeskTopInfo.ulTVFormat[i] = pDeskTop->ulTVFormat[i];
                }

                // TODO ...  
                // Display driver already checks this; Miniport driver should double check ??
                // Should call RM to check dual head support
                if(1)
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  TRUE ;
                else
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  FALSE ;

                RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
                status = NO_ERROR;
                break;
            }
            else
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_DESKTOP_DISPLAY_MODE - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }

        break;

    
    case IOCTL_VIDEO_CLEAR_FRAMEBUFFER:
        {
        ULONG i;
        if (hwDeviceExtension->FrameBufferPtr !=NULL)
            {
            //**********************************************************************
            // Clear the framebuffer prior to setting the video mode.
            // This is for aesthetics only.
            // Back up 1Mb to make absolutely sure we don't walk over any instance memory
            //**********************************************************************
            for (i = 0; i < ( (hwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
                {
                ((PULONG) hwDeviceExtension->FrameBufferPtr)[i] = 0;
                }
            }
        }
        status = NO_ERROR;
        break;

    //**************************************************************************
    // SET_CURRENT_MODE
    //**************************************************************************

    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "NVStartIO - SetCurrentModes\n"));

        // Call the RM to enable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, TRUE);

        // Also clear the hotkeyPending flag since a modeset will be done.
        hwDeviceExtension->ulHotKeyPending = 0;

#if 1
   {   //check for last saved flat panel mode and set it if necessary
        ULONG  regmode  = -1;
        BOOL   fpstatus = 0;
        BOOL   Status;
        ULONG  head;
        ULONG  i;
        NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS fpGetParams; 
        NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS fpSetParams;
         
        Status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                           L"FlatPanelMode",
                                           FALSE,
                                           NVRegistryCallback,
                                           &regmode);
                                          
        if (Status == NO_ERROR && regmode <= 2)
        {
            for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
            {
                head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
                if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                                    MONITOR_TYPE_FLAT_PANEL)
                {
                    fpGetParams.Head = head;
                    fpstatus = RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                        NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI,
                                        &(fpGetParams), 
                                        sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS));
    
                    if( fpstatus == TRUE && 
                        regmode  != fpGetParams.FlatPanelMode && 
                        fpGetParams.FlatPanelMode  <= 2 )
                    {
                        fpSetParams.CommitChanges = 0; //already committed
                        fpSetParams.FlatPanelMode = regmode;
                        fpSetParams.Head = head;
                        RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                            NV_CFGEX_SET_FLAT_PANEL_SCALING,
                                            &fpSetParams, 
                                            sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS));
                    } //if modes arent the same
                }//if flat panel
            }//for each active dac
        }//if registry returns no error
        else
        {
            //else the registry didn't tell us what to do, so default to adapter scaling. NEC hi-priority request.
            for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
            {
                head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
                if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                                    MONITOR_TYPE_FLAT_PANEL)
                {
                    {
                        fpSetParams.CommitChanges = 1; //not committed yet
                        regmode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;
                        fpSetParams.FlatPanelMode = regmode;
                        fpSetParams.Head = head;
                        RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                            NV_CFGEX_SET_FLAT_PANEL_SCALING,
                                            &fpSetParams, 
                                            sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS));
                    } //if modes arent the same
                }//if flat panel
            }//for each active dac     
        }
    } //end of checking for last saved flat panel mode and setting.
#endif    

        status = NVSetMode(hwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        //******************************************************************************
        // Did caller ask if we supported hw video overlay?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(BOOLEAN))
            {
            //******************************************************************************
            // return whether or hw video overlay is supported in the current mode.
            //******************************************************************************
            *((BOOLEAN *) RequestPacket->OutputBuffer) = hwDeviceExtension->bHwVidOvl;
            RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
            }


// removed hard coded status....

        //
        // Refresh gamma clut after modeset
        //
        // Update the gamma concept if we are not on an NV3
        if( !(hwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
        {

            VideoDebugPrint((2, "IOCTL_VIDEO_SET_CURRENT_MODE - Updating gamma registers\n"));

                // We need to make sure that we wait for the vblank interrupt handler to run at least once before
                // we update the gamma values, as the handler will also write out the values in the dac.gamma table
                // and clobber anything that we have written.  This is very backdoor, and should be handled in a more
                // proper way, say by letting the vblank code update these for us by letting it know what we want.


            if(hwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
            {
               U032   StartVBlank,CurrentVBlank;

               // Do this: Get some vblank count and wait for it to change

               // Get the first relative start value
               if(RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {

                  StartVBlank = CurrentVBlank;
                  while(CurrentVBlank == StartVBlank) {    // Wait till they are different
                        if(!RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {
                           CurrentVBlank = StartVBlank + 1;   // This is how we break out of here if the RM fails
                        }
                  }
               }

                NV_SetPixMixBits(hwDeviceExtension);

                NVSetColorLookup(hwDeviceExtension,
                            (PVIDEO_CLUT) &hwDeviceExtension->GammaCache,
                            MAX_CLUT_SIZE);
            }
        }

        //**************************************************************************
        //
        // We need to let the control panel know that the modeset has occurred.
        // For example, in TwinView configuration, NT4.0/Win2K sometimes ignores a 
        // modeset request for the same mode even though we could be changing the mode
        // from normal to clone, but with the same resolution.
        // nVidia control sets this registry entry to 0, calls Win2K to do a modeset
        // and then tests this registry entry to see if the display driver actually
        // was called or not.
        //
        //**************************************************************************

        {
          ULONG NvCplModeSetHasOccurred;      // Used only by the control panel.
          
          NvCplModeSetHasOccurred = 1;
          hwDeviceExtension->SystemModeSetHasOccurred = 1;

          VideoPortSetRegistryParameters(hwDeviceExtension,
                                      L"NvCplModeSetHasOccurred",
                                      &NvCplModeSetHasOccurred,
                                      sizeof(ULONG));
          VideoPortSetRegistryParameters(hwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &hwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));
        }
        break;

    //**************************************************************************
    // Store the unique integer ID for the ppdev for the ensuing IOCTL_RESET_DEVICE.
    //**************************************************************************
    case IOCTL_VIDEO_SET_UNIQUENESS_VGA:
        {
            ULONG ulUniqueness;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_UNIQUENESS_VGA - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulUniqueness = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulUniquenessVGA = ulUniqueness;
            VideoDebugPrint((1, "UniquenessVGA stored: 0x%x\n",ulUniqueness));
        }
        break;

    //**************************************************************************
    // Store Status of the NVSVC service.
    //**************************************************************************
    case IOCTL_VIDEO_SET_NVSVC_STATUS:
        {
            ULONG ulNVSVCStatus;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_NVSVC_STATUS - ERROR_INSUFFICIENT_BUFFER\n"));
                //
                // Set the status to stopped to be safe.
                //
                hwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulNVSVCStatus = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulNVSVCStatus = ulNVSVCStatus;
            VideoDebugPrint((1, "ulNVSVCStatus stored: 0x%x\n",ulNVSVCStatus));
        }
        break;

    //**************************************************************************
    // Store Status of the NVSVC service.
    //**************************************************************************
    case IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK:
        {
            ULONG ulInduceModeChangeDeviceMask;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK - ERROR_INSUFFICIENT_BUFFER\n"));
                hwDeviceExtension->ulInduceModeChangeDeviceMask = 0;
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulInduceModeChangeDeviceMask = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulInduceModeChangeDeviceMask = ulInduceModeChangeDeviceMask;
            VideoDebugPrint((1, "ulInduceModeChangeDeviceMask stored: 0x%x\n",ulInduceModeChangeDeviceMask));
        }
        break;

    //**************************************************************************
    // Signal the NVModesetEvent to invoke the NVSVC
    //**************************************************************************
    case IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT:
        {
            VideoDebugPrint((1, "NVStartIO - SignalNVSVCModeSetEvent\n"));
            status = NO_ERROR;
            SignalModeSwitchEvent();
        }
        break;

    //*****************************************************************************
    // Signal the control panel thread to indicate a hotkey switch has taken place.
    //*****************************************************************************
    case IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT:
        {
            VideoDebugPrint((1, "NVStartIO - SignalNVCplHotKeyEvent\n"));
            status = NO_ERROR;
            SignalNVCplHotKeyEvent();
        }
        break;


    //**************************************************************************
    // RESET_DEVICE
    //**************************************************************************

    case IOCTL_VIDEO_RESET_DEVICE:

        // Clean up virtual desktop flag.
        hwDeviceExtension->DeskTopInfo.ulDesktopMode = 0;

        VideoDebugPrint((2, "NVStartIO - Reset Device\n"));

        status = NO_ERROR;
        
#if (_WIN32_WINNT >= 0x0500)
        hwDeviceExtension->ulDualViewStatus &= ~DUALVIEW_STATUS_GRAPHICS_MODE;

        //
        // For DualView(MHS), we need to check whether the other view is in graphics mode.
        //
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            //
            // If another display still in graphics mode, do nothing.
            //
            if (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_GRAPHICS_MODE)
            {
                break;
            }
        }
#endif

        // Call the RM to disable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, FALSE);

        if(hwDeviceExtension->ulRmTurnedOffMonitor)
        {
            // PowerManagement turn off the monitor 
            // It is not necessary to call BIOS to reset the chip
            break;
        }

        //**********************************************************************
        // Because we're going to do a reset, we need to write current value
        // to registry.  Temporary fix, used to keep mobile scaling hotkey in
        // some sort of sync with registry.
        //**********************************************************************

        WriteFPModeToRegistry (hwDeviceExtension);
        
        //**********************************************************************
        // Must *NOT* call Int10 in a multiple adapter configuration
        //**********************************************************************

        if (MultiAdaptersPresent == FALSE)
            {
            //******************************************************************
            // Make sure that NV interrupts are disabled before we call Int10!!!
            // Otherwise, there may be conflicts writing to the hardware registers
            // (especially in an SMP system)
            //******************************************************************

            NV_DisableNVInterrupts(hwDeviceExtension);


#if _WIN32_WINNT < 0x0500

            //******************************************************************
            // For NT4, always use the bios to do the modeset.
            // SMP issue that used to reqire setting the text mode by hand
            // seems to be gone now.
            //******************************************************************

                status = RMVideoResetDevice(hwDeviceExtension->DeviceReference);
                if (status != NO_ERROR)
                    VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));

#else
            //******************************************************************
            // For Win2k, always use Int10
            //******************************************************************

            if(hwDeviceExtension->curAdapterPowerState == VideoPowerOn ||
                hwDeviceExtension->curAdapterPowerState == VideoPowerHibernate)
            {
                //FPMode needs to be saved/restored because of bios bug in nv11
                status = RMVideoResetDevice(hwDeviceExtension->DeviceReference);
                if (status != NO_ERROR)
                    VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));
            }
#endif

            //******************************************************************
            // Turn NV interrupts back on
            //******************************************************************

            NV_ReEnableNVInterrupts(hwDeviceExtension);
            }


        break;

    //**************************************************************************
    // SET_COLOR_REGISTERS
    //**************************************************************************

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "NVStartIO - SetColorRegs\n"));

        status = NVSetColorLookup(hwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);


// Initialize this adapters CLUT to the requested gamma ramp
   {

      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut;
      ULONG index,item,NumEntries,FirstEntry;

      VideoDebugPrint((1, "IOCTL_VIDEO_SET_COLOR_REGISTERS - Saving gamma mods in gammacache\n"));

      // - Make things nice to look at
          pvcdItemSrc = &(((PVIDEO_CLUT)RequestPacket->InputBuffer)->LookupTable->RgbArray);
          pvcdItemDst = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
      srcclut = (PVIDEO_CLUT)RequestPacket->InputBuffer;

      // - Set the limits on the item count
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    }

        break;

    //**************************************************************************
    // Enable the PIXMIX bits in NV_PRAMDAC_GENERAL_CONTROL
    //**************************************************************************
    case IOCTL_VIDEO_ENABLE_PIXMIX_INDEX:
            //
            //      Set PIXMIX bits to 11b
            //
            NV_SetPixMixBits(hwDeviceExtension);

            status = NO_ERROR;
            break;

    //**************************************************************************
    // ENABLE_VDM
    // Do we need to implement this call ??
    // We'll need to implement ResetDevice because we'll be using VgaCompatible=0
    //**************************************************************************

    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "NVStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;

    //**************************************************************************
    // Private IOCTLs established with the driver
    //**************************************************************************


    //**************************************************************************
    // GET_VIDEO_CARD_INFO
    // This call is unnecessary , we don't do banking
    //**************************************************************************

    case IOCTL_VIDEO_GET_VIDEO_CARD_INFO:

        VideoDebugPrint((2, "NVStartIO - Get video card info\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_COPROCESSOR_INFORMATION)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        // return the Coproc Base Address.

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulChipID =
            hwDeviceExtension->ulChipID;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulRevLevel =
            hwDeviceExtension->ulRevLevel;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulVideoMemory =
            hwDeviceExtension->AdapterMemorySize;

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Map IO port for ALI\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }
        RequestPacket->StatusBlock->Information = sizeof(VIDEO_MEMORY_INFORMATION);


        memoryInformation = RequestPacket->OutputBuffer;
        memoryInformation->FrameBufferBase   = 0;
        memoryInformation->FrameBufferLength = FALSE;
        hwDeviceExtension->AliFixupIOBase    = NULL;

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {
            //******************************************************************
            // Setup to map an IO register
            //******************************************************************

            AliFixupBaseAddress.HighPart = 0x00000000;
            AliFixupBaseAddress.LowPart  = 0x000003d0;
            IOLength            = 4;
            inIoSpace           = TRUE;
            AliVirtualAddress   = NULL;

            //******************************************************************
            // Map the IO port, and pass it back to the display driver
            //******************************************************************

            status = VideoPortMapMemory(hwDeviceExtension,
                                     AliFixupBaseAddress,
                                     &(IOLength),
                                     &(inIoSpace),
                                     &AliVirtualAddress);

            memoryInformation->FrameBufferBase   = AliVirtualAddress;
            memoryInformation->FrameBufferLength = TRUE;
            hwDeviceExtension->AliFixupIOBase    = AliVirtualAddress;
            }



        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Free mapping for IO port \n"));

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {

            //******************************************************************
            // Free up the mapping for the IO port
            //******************************************************************

            if (hwDeviceExtension->AliFixupIOBase !=NULL)
                {
                status = VideoPortUnmapMemory(hwDeviceExtension,
                                         hwDeviceExtension->AliFixupIOBase,
                                         0);
                }

            hwDeviceExtension->AliFixupIOBase = NULL;
            }


        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_MAP_NV_PFIFO_USER:
        {
        PHYSICAL_ADDRESS            base, pa;
        ULONG                       length;

        VideoDebugPrint((2, "NVStartIO - Map PFIFO User\n"));

        if (RequestPacket->OutputBufferLength < sizeof(ULONG) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return mapping to PFIFO registers in user address space
        //**********************************************************************

        virtualAddress = (PVOID)0L;

        //******************************************************************
        // Get physical base address again (since we modified it up above
        // for the PFIFO registers
        //******************************************************************

        base = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart;

        //**************************************************************
        // Call VideoPort to map the range for us
        //**************************************************************

        pa          = base;
        pa.HighPart = 0x00000000;
        pa.LowPart  += RangeOffsets[NV_PFIFO_INDEX].ulOffset;
        sharedViewSize = RangeOffsets[NV_PFIFO_INDEX].ulLength;

        NVMapPhysIntoUserSpace(pa, sharedViewSize, &virtualAddress);
        *(PVOID *)RequestPacket->OutputBuffer = virtualAddress;
        RequestPacket->StatusBlock->Information = sizeof(PVOID);

        status = NO_ERROR;

        }
        break;

    case IOCTL_VIDEO_UNMAP_NV_PFIFO_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        VideoDebugPrint((2, "NVStartIO - UnMap PFIFO User\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNMAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapPhysFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;

    case IOCTL_VIDEO_MAP_NV_PBUS_USER:
        {
        PHYSICAL_ADDRESS            base, pa;
        ULONG                       length;

        VideoDebugPrint((2, "NVStartIO - Map PBUS User\n"));

        if (RequestPacket->OutputBufferLength < sizeof(ULONG) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return mapping to PBUS registers in user address space
        //**********************************************************************

        virtualAddress = (PVOID)0L;

        //******************************************************************
        // Get physical base address again (since we modified it up above
        // for the PBUS registers
        //******************************************************************

        base = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart;

        //**************************************************************
        // Call VideoPort to map the range for us
        //**************************************************************

        pa          = base;
        pa.HighPart = 0x00000000;
        pa.LowPart  += RangeOffsets[NV_PBUS_INDEX].ulOffset;
        sharedViewSize = RangeOffsets[NV_PBUS_INDEX].ulLength;

        NVMapPhysIntoUserSpace(pa, sharedViewSize, &virtualAddress);
        *(PVOID *)RequestPacket->OutputBuffer = virtualAddress;
        RequestPacket->StatusBlock->Information = sizeof(PVOID);

        status = NO_ERROR;

        }
        break;

    case IOCTL_VIDEO_UNMAP_NV_PBUS_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        VideoDebugPrint((2, "NVStartIO - UnMap PBUS User\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNMAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapPhysFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;

    case IOCTL_VIDEO_ENABLE_WRITE_COMBINING:

        VideoDebugPrint((2, "NVStartIO - VIDEO_ENABLE_WRITE_COMBINING\n"));

        //**********************************************************************
        // Set flags to enable fb write combining.
        //**********************************************************************
        hwDeviceExtension->flMapMemory |= VIDEO_MEMORY_SPACE_P6CACHE;
        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO:

        VideoDebugPrint((2, "NVStartIO - Return TV cursor adjustment values\n"));

        if (RequestPacket->OutputBufferLength < sizeof(TV_CURSOR_ADJUST_INFO) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return information about our DMA buffer
        //**********************************************************************

        RequestPacket->StatusBlock->Information = sizeof(TV_CURSOR_ADJUST_INFO);

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->MonitorType =
                                  hwDeviceExtension->NvInfo.Framebuffer.MonitorType;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->FilterEnable =
                                  hwDeviceExtension->NvInfo.Framebuffer.FilterEnable;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMin =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMin;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMax =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMax;

        status = NO_ERROR;

        break;

    //**************************************************************************
    // GET_IF09_VIDEO_SUPPORT
    //**************************************************************************

    case IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT\n"));

        //******************************************************************************
        // Should we support IF09 format video data?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
            {
            //******************************************************************************
            // return whether or IF09 format video data should be supported.
            //******************************************************************************
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->bEnableIF09;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
            }
        else
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        break;

    //**************************************************************************
    // GET_COMMON_DEVICE_INFO
    //**************************************************************************

    case IOCTL_VIDEO_GET_COMMON_DEVICE_INFO:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_COMMON_DEVICE_INFO\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(NV_COMMON_DEVICE_INFO))
        {
            NV_COMMON_DEVICE_INFO *pCommonDeviceInfo = (NV_COMMON_DEVICE_INFO *)RequestPacket->OutputBuffer;
            NV_OS_VERSION_INFO    *pOsVersionInfo    = &(pCommonDeviceInfo->OsVersionInfo);

            pCommonDeviceInfo->ulDeviceReference   = hwDeviceExtension->DeviceReference;
            pCommonDeviceInfo->ulEnableDualView    = 0;
            pCommonDeviceInfo->ulDualViewSecondary = 0;

            pOsVersionInfo->dwBuildType    = 0xffffffff;
            pOsVersionInfo->dwMajorVersion = 0xffffffff;
            pOsVersionInfo->dwMinorVersion = 0xffffffff;
            pOsVersionInfo->dwBuildNumber  = 0xffffffff;

#if _WIN32_WINNT >= 0x0500
            pCommonDeviceInfo->ulEnableDualView = (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW) ? 1 : 0;
            pCommonDeviceInfo->ulDualViewSecondary = (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? 1 : 0;
            pOsVersionInfo->dwBuildType = PsGetVersion(&pOsVersionInfo->dwMajorVersion,
                                                       &pOsVersionInfo->dwMinorVersion,
                                                       &pOsVersionInfo->dwBuildNumber, NULL);
            pCommonDeviceInfo->SysMemInfo.SystemMemorySize   = hwDeviceExtension->SystemMemorySize;
            pCommonDeviceInfo->SysMemInfo.AgpAllocationLimit = hwDeviceExtension->AgpServices.AllocationLimit;
#endif

            RequestPacket->StatusBlock->Information = sizeof(NV_COMMON_DEVICE_INFO);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;

    //**************************************************************************
    // GET_OGL_STENCIL_SWITCH
    //**************************************************************************

    case IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
        {
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->OglStencilSwitch;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;


    //**********************************************************************************
    // The following IOCTLs allow communication between the display driver and the RM
    //**********************************************************************************

    //****CHECK FOR ERROR_INSUFFICIENT_BUFFER here

    // MP/RM merge...

    // TO DO: remove open and close
    // open and close are here for compatibility
    case NVAPI_IOCTL_OPEN:
        status = NO_ERROR;
        break;

    case NVAPI_IOCTL_CLOSE:
        status = NO_ERROR;
        break;

    case IOCTL_NV01_ALLOC_ROOT:
        Nv01AllocRoot((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_DEVICE:
        Nv01AllocDevice((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CONTEXT_DMA:
        Nv01AllocContextDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CHANNEL_PIO:
        Nv01AllocChannelPio((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_ALLOC_CHANNEL_DMA:
        Nv03AllocChannelDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_MEMORY:
        Nv01AllocMemory((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_OBJECT:
        Nv01AllocObject((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_EVENT:
        Nv01AllocEvent((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_ALLOC:
        Nv04Alloc((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_FREE:
        Nv01Free((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_DMA_FLOW_CONTROL:
        Nv03DmaFlowControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ARCH_HEAP:
        Nv03ArchHeap((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_VERSION:
        Nv01ConfigVersion((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_GET:
        Nv01ConfigGet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_SET:
        Nv01ConfigSet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_GET_EX:
        Nv04ConfigGetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_SET_EX:
        Nv04ConfigSetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_UPDATE:
        Nv01ConfigUpdate((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_DEBUG_CONTROL:
        Nv01DebugControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_DIRECT_METHOD_CALL:
        Nv04DirectMethodCall((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

        //...jsw

    case IOCTL_NV04_I2C_ACCESS:
         {
            NVOS_I2C_ACCESS_PARAMS *i2cparams;

            i2cparams = (NVOS_I2C_ACCESS_PARAMS *)RequestPacket->InputBuffer;

            // Make sure that the data handed us is within limits
            if( (RequestPacket->InputBufferLength  < sizeof(NVOS_I2C_ACCESS_PARAMS)) ||
                (RequestPacket->OutputBufferLength < sizeof(NVOS_I2C_ACCESS_PARAMS)) ){

               status = ERROR_INSUFFICIENT_BUFFER;
               RequestPacket->StatusBlock->Information = 0;
            }
            else {

               // Have the RM help us with this one...
               Nv04I2CAccess((NVOS_I2C_ACCESS_PARAMS *)i2cparams);

               // Make sure that we only give back the right amount
               RequestPacket->StatusBlock->Information = sizeof(NVOS_I2C_ACCESS_PARAMS);
               status = NO_ERROR;
            }
         }
        break;


    //**************************************************************************
    // SYSMEM_SHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_SHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SYSMEM_SHARE_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        NvSystemMemoryShare(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;

        pSysmemShareMemoryOut->pSystemMdl       = pSysmemShareMemoryIn->pSystemMdl;
        pSysmemShareMemoryOut->physicalAddress  = pSysmemShareMemoryIn->physicalAddress;
        pSysmemShareMemoryOut->ddVirtualAddress = pSysmemShareMemoryIn->ddVirtualAddress;
        pSysmemShareMemoryOut->byteLength       = pSysmemShareMemoryIn->byteLength;
        pSysmemShareMemoryOut->bDontModifyMDL   = pSysmemShareMemoryIn->bDontModifyMDL;

        VideoDebugPrint((0, "SHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryOut->pSystemMdl));
        VideoDebugPrint((0, "SHARE: physicalAddress = 0x%p\n",
                        pSysmemShareMemoryOut->physicalAddress));
        VideoDebugPrint((0, "SHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryOut->ddVirtualAddress));
        VideoDebugPrint((0, "SHARE: bDontModifyMDL = 0x%p\n",
                        pSysmemShareMemoryOut->bDontModifyMDL));

        status = NO_ERROR;

        }
        break;

    //**************************************************************************
    // SYSMEM_UNSHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn;

        if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        VideoDebugPrint((0, "UNSHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryIn->pSystemMdl));
        VideoDebugPrint((0, "UNSHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryIn->ddVirtualAddress));
        VideoDebugPrint((0, "UNSHARE: bDontModifyMDL = 0x%p\n",
                        pSysmemShareMemoryIn->bDontModifyMDL));
        NvSystemMemoryUnShare(pSysmemShareMemoryIn);
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // LOCK_DOWN_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_LOCK_DOWN_MEMORY:
        {
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryIn = NULL;
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_LOCK_DOWN_MEMORY);
        NvLockdownMemory(pLockdownMemoryIn);
        if (pLockdownMemoryIn->pMdl == NULL)
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - Fails lock - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryOut = RequestPacket->OutputBuffer;
        pLockdownMemoryOut->pMdl           = pLockdownMemoryIn->pMdl;
        pLockdownMemoryOut->virtualAddress = pLockdownMemoryIn->virtualAddress;
        pLockdownMemoryOut->byteLength     = pLockdownMemoryIn->byteLength;

        VideoDebugPrint((0, "LOCKDOWN: virtualAddress = 0x%p\n",
                        pLockdownMemoryOut->virtualAddress));
        VideoDebugPrint((0, "LOCKDOWN: pMdl = 0x%p\n",
                        pLockdownMemoryOut->pMdl));
        status = NO_ERROR;

        VideoDebugPrint((2, "W32StartIO - LockDownMemory Exit\n"));
        }
        break;

    //**************************************************************************
    // UNLOCK_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNLOCK_MEMORY:
        {
        NV_UNLOCK_MEMORY *pUnlockMemoryIn = NULL;
        NV_UNLOCK_MEMORY *pUnlockMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_UNLOCK_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_UNLOCK_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNLOCK_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pUnlockMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_UNLOCK_MEMORY);
        NvUnlockMemory(pUnlockMemoryIn);
        pUnlockMemoryOut = RequestPacket->OutputBuffer;
        pUnlockMemoryOut->pMdl = pUnlockMemoryIn->pMdl;
        VideoDebugPrint((0, "UNLOCK: pMdl = 0x%p\n", pUnlockMemoryOut->pMdl));
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // MAP_TO_USER
    //**************************************************************************

    case IOCTL_VIDEO_MAP_TO_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->ddVirtualAddress points to kernel address which may be locked down
        // pSysmemShareMemoryIn->byteLength points to length of kernel address memory
        NvMapIntoUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        pSysmemShareMemoryOut->userVirtualAddress = pSysmemShareMemoryIn->userVirtualAddress;
        pSysmemShareMemoryOut->physicalAddress    = pSysmemShareMemoryIn->physicalAddress;
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // UNMAP_FROM_USER
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_FROM_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // NT5 only !
    // IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS
    //**************************************************************************

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        VideoDebugPrint((2, "NVStartIO - IOCTL Handle Video Parameters\n"));

        status = ERROR_INVALID_FUNCTION;
        
        if( (RequestPacket->InputBufferLength  == sizeof(VIDEOPARAMETERS) ) &&
            (RequestPacket->OutputBufferLength == sizeof(VIDEOPARAMETERS) ) )
        {
            VIDEOPARAMETERS * pInVideoParameters  = (VIDEOPARAMETERS *) RequestPacket->InputBuffer;
            VIDEOPARAMETERS * pOutVideoParameters = (VIDEOPARAMETERS *) RequestPacket->OutputBuffer;
            ULONG i, dwTemp;
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS nvEncoder;

            switch(pInVideoParameters->dwCommand)
            {
                case VP_COMMAND_GET:
                {
                    pOutVideoParameters->dwMode = VP_MODE_WIN_GRAPHICS;
                    pOutVideoParameters->dwFlags = 0;
                    pOutVideoParameters->dwTVStandard = 0;
            
                    for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                    {
                        if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                            (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                        {
                            pOutVideoParameters->dwFlags  = VP_FLAGS_TV_MODE;
                            pOutVideoParameters->dwFlags |= VP_FLAGS_TV_STANDARD;
                            if(hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC)
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard 
                                    = VP_TV_STANDARD_NTSC_M;
                            }
                            else
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard
                                    = VP_TV_STANDARD_PAL_B;
                            }

                            pOutVideoParameters->dwAvailableModes = VP_MODE_WIN_GRAPHICS;
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_MAX_UNSCALED;
                            pOutVideoParameters->dwMaxUnscaledX = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                            pOutVideoParameters->dwMaxUnscaledY = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_POSITION;
                            pOutVideoParameters->dwPositionX = 0;
                            pOutVideoParameters->dwPositionY = 0;
            
                            pOutVideoParameters->dwCPType = 0;
                            pOutVideoParameters->dwCPStandard = 0;
            
                            nvEncoder.Head = i;
                            RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                            switch(nvEncoder.EncoderType)
                            {
                                case NV_ENCODER_BROOKTREE_868:
                                case NV_ENCODER_CHRONTEL_7003:
                                case NV_ENCODER_CHRONTEL_7006:
                                case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                    break;
                                default:
                                    // macrovision support
                                    pOutVideoParameters->dwFlags |= VP_FLAGS_COPYPROTECT;
                                    pOutVideoParameters->dwCPType = VP_CP_TYPE_APS_TRIGGER;
                                    pOutVideoParameters->bCP_APSTriggerBits = hwDeviceExtension->ulMacrovisionMode; 
                                    switch(hwDeviceExtension->DeskTopInfo.ulTVFormat[i])
                                    {
                                        case NTSC_M:
                                            dwTemp = VP_TV_STANDARD_NTSC_M;
                                        break;
                                        case NTSC_J:
                                            dwTemp = VP_TV_STANDARD_NTSC_M_J;
                                        break;
                                        case PAL_M:
                                            dwTemp = VP_TV_STANDARD_PAL_M;
                                        break;
                                        case PAL_A:
                                            dwTemp = VP_TV_STANDARD_PAL_B | VP_TV_STANDARD_PAL_D | VP_TV_STANDARD_PAL_G |
                                                 VP_TV_STANDARD_PAL_H | VP_TV_STANDARD_PAL_I;
                                        break;
                                        case PAL_N:
                                            dwTemp = VP_TV_STANDARD_PAL_N;
                                        break;
                                        case PAL_NC:
                                        default:
                                            dwTemp = VP_TV_STANDARD_WIN_VGA;
                                        break;
                                    }
                                    pOutVideoParameters->dwCPStandard = dwTemp;
                                    break;
                                break;
                            }
                            break;
                        } // if
                    } // for
                    RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                    VideoDebugPrint((0, "NVStartIO - IOCTL Handle Video Parameters Get dwCommand \n"));
                    status = NO_ERROR;
                    break;
                }
                case VP_COMMAND_SET:
                {
                    if((pInVideoParameters->dwFlags  &  VP_FLAGS_COPYPROTECT) &&
                       (pInVideoParameters->dwCPType == VP_CP_TYPE_APS_TRIGGER) )
                    {
                        NV_CFGEX_SET_MACROVISION_MODE_PARAMS nvMacrovision;

                        memcpy((PUCHAR) pOutVideoParameters, (PUCHAR) pInVideoParameters, sizeof(VIDEOPARAMETERS));
                        for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                        {
                            if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                                (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                            {
                                nvEncoder.Head = i;
                                RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, 
                                        &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                                switch(nvEncoder.EncoderType)
                                {
                                    case NV_ENCODER_BROOKTREE_868:
                                    case NV_ENCODER_CHRONTEL_7003:
                                    case NV_ENCODER_CHRONTEL_7006:
                                    case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                        break;
                                    default:
                                        // macrovision support
                                        nvMacrovision.head = i;
                                        nvMacrovision.mode = pInVideoParameters->bCP_APSTriggerBits;
                                        nvMacrovision.resx = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                                        nvMacrovision.resy = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
                                        switch(pInVideoParameters->dwCPCommand)
                                        {
                                            case VP_CP_CMD_ACTIVATE:
                                                if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                     NV_CFGEX_SET_MACROVISION_MODE,
                                                     &nvMacrovision,
                                                     sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                {
                                                    pOutVideoParameters->dwCPKey = hwDeviceExtension->ulCurrentMacrovisionKey 
                                                                                 = hwDeviceExtension->ulNextMacrovisionKey++;
                                                }
                                            break;
                                            case VP_CP_CMD_DEACTIVATE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode = 0;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // Disabled successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to disable it.
                                                    }
                                                }
                                            break;
                                            case VP_CP_CMD_CHANGE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode  = pInVideoParameters->bCP_APSTriggerBits & 0x03;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // changed successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to change it.
                                                    }
                                                }
                                            break;
                                        }
                                        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                                        hwDeviceExtension->ulMacrovisionMode = nvMacrovision.mode;
                                } // switch
                            } // if
                        } // for
                   } // if
                   status = NO_ERROR;
                    break; //  
                } // 
                default:
                    break;
             } // switch
        }
        break;

        case IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED:
            {
                if (hwDeviceExtension->bAgp)
                    status = NO_ERROR;
                else
                    status = ERROR_INVALID_FUNCTION;
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_ALLOC_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_ALLOC_AGP_MEM:
            {
            ULONG       cPages;
            PAGP_MEM    pBlock, pOutputBuffer;
            PVOID       VirtualAddress;
            VideoDebugPrint((2, "NVStartIO - IOCTL Alloc AGP Mem\n"));

            if ((RequestPacket->OutputBufferLength < sizeof(AGP_MEM)) ||
                 (RequestPacket->InputBufferLength < sizeof(AGP_MEM)))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_ALLOC_AGP_MEM - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) (RequestPacket->InputBuffer);
            pOutputBuffer = (PAGP_MEM) (RequestPacket->OutputBuffer);
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            //
            // WARNING: The (ULONG_PTR) cast makes the warning go away, 
            //          but it is possible this is broken since hContext
            //          may not be big enough on 64 bit systems.
            //
            if (!(hwDeviceExtension->AgpVirtualBaseAddress =
                    VideoPortAgpReserveVirtual(
                        hwDeviceExtension,
                        (HANDLE)((ULONG_PTR)pBlock->hContext),
                        hwDeviceExtension->AgpPhysContext,
                        (PVOID *)(&(hwDeviceExtension->dummyVirtualContext)))))
                {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
            *pOutputBuffer = *pBlock;
            if (!(pOutputBuffer->VirtualAddress =
                    VideoPortAgpCommitVirtual(
                        hwDeviceExtension,
                        hwDeviceExtension->dummyVirtualContext,
                        cPages, 0)))
                {
                VideoPortAgpReleaseVirtual(
                    hwDeviceExtension,
                    hwDeviceExtension->dummyVirtualContext);
                hwDeviceExtension->dummyVirtualContext = NULL;
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
                RequestPacket->StatusBlock->Information = sizeof(AGP_MEM);
                status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_FREE_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_FREE_AGP_MEM:
            {
            PVOID       VirtualAddress;
            PAGP_MEM    pBlock;
            ULONG       cPages;

            VideoDebugPrint((2, "NVStartIO - IOCTL Free AGP Mem\n"));
            if (RequestPacket->InputBufferLength < sizeof(AGP_MEM))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) RequestPacket->InputBuffer;
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            VideoPortAgpFreeVirtual(
                hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext,
                cPages,
                (ULONG)((PUCHAR)pBlock->VirtualAddress - (PUCHAR)hwDeviceExtension->dummyVirtualContext)
            );
            VideoPortAgpReleaseVirtual(hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext);
            hwDeviceExtension->dummyVirtualContext = NULL;
            status = NO_ERROR;
            }
            break;

        ////// all VPE commands go thru here !
#ifdef NVPE
        case IOCTL_VIDEO_VPE_COMMAND:
            VideoDebugPrint((2, "NVStartIO - IOCTL Video Port Extension Command\n"));
            status = NVPEProcessCommand(hwDeviceExtension, RequestPacket);
            break;
#endif  // #ifdef NVPE
#endif  // _WIN32_WINNT >= 0x0500




        //****************************************************************************************************
        // IOCTL_VIDEO_SET_TWINVIEW_STATE
        // Sets the user selected state of Clone/Normal/Multimon.
        // Also sets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_SET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_SET_TWINVIEW_STATE():\n"));
                if(RequestPacket->InputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->InputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                status = NVSetRegistryTwinviewInfo(hwDeviceExtension, pInfo);
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_TWINVIEW_STATE
        // Gets the user selected state of Clone/Normal/Multimon.
        // Also gets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_TWINVIEW_STATE():\n"));
                if(RequestPacket->OutputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                status = NVGetRegistryTwinviewInfo(hwDeviceExtension, pInfo);
                if (status != NO_ERROR)
                {
                    VideoPortZeroMemory(pInfo, sizeof(NVTWINVIEWDATA));
                    pInfo->dwState = hwDeviceExtension->DeskTopInfo.ulTwinView_State;
                }
                RequestPacket->StatusBlock->Information = sizeof(NVTWINVIEWDATA);
                status = NO_ERROR;
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PCI_NUMBER
        //****************************************************************************************************
        case IOCTL_VIDEO_QUERY_PCI_SLOT:
        {
            ULONG * pulTemp;

            status = NO_ERROR;
            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) 
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_QUERY_PCI_SLOT(): Error: pInfo is wrong Size.\n"));
                status = ERROR_INVALID_PARAMETER;
                break;
            }
            pulTemp = (ULONG *)(RequestPacket->OutputBuffer);

            *pulTemp = hwDeviceExtension->ulSlot; 

            if (status == NO_ERROR)
                RequestPacket->StatusBlock->Information = sizeof(ULONG);
            else
                RequestPacket->StatusBlock->Information = 0;

        }
        break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_NUMBER_DACS_ON_BOARD
        // Gets the number of DACS on the board
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_NUMBER_DACS:
            {
                GET_NUMBER_DACS *pInfo;
                NV_DESKTOP_INFO *pDeskTopInfo;
                ULONG i, Count = 0;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_NUMBER_DACS():\n"));

                status = NO_ERROR;
                if(RequestPacket->OutputBufferLength < sizeof(GET_NUMBER_DACS)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (GET_NUMBER_DACS *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                // Extract the info from the hwDeviceExtension.
                pDeskTopInfo = (NV_DESKTOP_INFO *)&hwDeviceExtension->DeskTopInfo;

                // Stuff the info to send back to the display driver.
                pInfo->ulNumberDacsOnBoard = pDeskTopInfo->ulNumberDacsOnBoard;
                pInfo->ulNumberDacsConnected = pDeskTopInfo->ulNumberDacsConnected;
                pInfo->ulAllDeviceMask = pDeskTopInfo->ulAllDeviceMask;
                pInfo->ulConnectedDeviceMask = pDeskTopInfo->ulConnectedDeviceMask;
                pInfo->Mobile = hwDeviceExtension->Mobile;
                pInfo->UseHWSelectedDevice = hwDeviceExtension->UseHWSelectedDevice;
                pInfo->GDIModePruning = hwDeviceExtension->GDIModePruning;
                pInfo->UseHotKeySameMode = hwDeviceExtension->UseHotKeySameMode;
                pInfo->PanScanSelection = hwDeviceExtension->PanScanSelection;
                pInfo->ulDFPSupports1400x1050 = hwDeviceExtension->ulDFPSupports1400x1050;
                pInfo->ulHotKeyPending = hwDeviceExtension->ulHotKeyPending;
                pInfo->ulUniquenessVGA = hwDeviceExtension->ulUniquenessVGA;
                pInfo->ACPISystem = hwDeviceExtension->ACPISystem;

                for (i=0; i < pDeskTopInfo->ulNumberDacsOnBoard; i++)
                {
                    pInfo->ulDeviceMask[i] = pDeskTopInfo->ulDeviceMask[i];
                    pInfo->ulDeviceDisplay[i] = pDeskTopInfo->ulDeviceDisplay[i];
                    pInfo->ulDeviceType[i] = pDeskTopInfo->ulDeviceType[i];
                    pInfo->ulTVFormat[i] = pDeskTopInfo->ulTVFormat[i];
                    pInfo->ulHeadDeviceOptions[i] = pDeskTopInfo->ulHeadDeviceOptions[i];
                }


                VideoDebugPrint((3,"IOCTL_GET_NUMBER_DACS: Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
                    pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(GET_NUMBER_DACS);
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING:
            {
                VideoDebugPrint((1, "IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING():\n"));
                status = NO_ERROR;
#if _WIN32_WINNT >= 0x0500
                if (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) {
                    hwDeviceExtension = hwDeviceExtension->pDualViewAssociatedDE;
                }
#endif
                bScanHeadDeviceOptions(hwDeviceExtension);
                RequestPacket->StatusBlock->Information = 0;
#if _WIN32_WINNT >= 0x0500
                //******************************************************************
                // bScanHeadDeviceOptions has updated ulConnectedDeviceMask, so now's a good time to
                // have our NVGetChildDescriptor callback run (triggerd by VideoPortEnumerateChildren).
                // This allows new ACPI HwIds to be passed to VALIDATE/SET_CHILD_STATE_CONFIGURATION
                //******************************************************************
                VideoPortEnumerateChildren(hwDeviceExtension, NULL);
#endif // _WIN32_WINNT >= 0x0500
            }
            break;

    case IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE:
            {
                VideoDebugPrint((1, "IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE():\n"));
                status = NO_ERROR;
                SetTimingOverRide(hwDeviceExtension);
                RequestPacket->StatusBlock->Information = 0;
            }
            break;


        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PHYSICAL_MODE_LIST
        // Returns the number and list of physical modes for the specified head.
        // Input is the list of virtual modes for that head (no doubled resolutions but single screen resolutions)
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST:
            {
                HEAD_MODE_LIST_INFO *pInput, *pOutput;
                ULONG ulRet, ulRetSize;
                

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST():\n"));
                status = NO_ERROR;
                
                if(RequestPacket->InputBufferLength < sizeof(HEAD_MODE_LIST_INFO)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: InputBufferLength is wrong Size: 0x%x\n",
                        RequestPacket->InputBufferLength));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInput = (HEAD_MODE_LIST_INFO *)(RequestPacket->InputBuffer);
                
                if (pInput == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: pInput is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }
                


                ulRetSize = 0;
                ulRet = GetHeadPhysicalModeList(hwDeviceExtension, 
                            pInput, &ulRetSize);

                if (ulRet == FALSE)
                {
                    status = ERROR_INVALID_PARAMETER;
                }


                VideoDebugPrint((3,"IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST: Number of PhysicalModes for head: %d returned is: %d\n",
                    pInput->ulHead, (ulRetSize/sizeof(MODE_ENTRY))));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = ulRetSize;
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;



        //**************************************************************************
        // IOCTL_VIDEO_SET_REGISTRY_VALUE
        // Sets a registry value.
        // Supports only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_SET_REGISTRY_VALUE:
            {
                PNV_REGISTRY_STRUCT pRegStruct;

                pRegStruct = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);

                status = VideoPortSetRegistryParameters(hwDeviceExtension,
                                       pRegStruct->keyName,
                                       pRegStruct->keyVal,
                                       pRegStruct->keyValSize);
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_GET_REGISTRY_PATH
        // Queries a registry path.
        //**************************************************************************
        case IOCTL_VIDEO_GET_REGISTRY_PATH:
            {
                if (strlen(hwDeviceExtension->DriverRegPath) > RequestPacket->OutputBufferLength)
                    status = ERROR_INVALID_PARAMETER;
                else
                {
                    strcpy((PUCHAR)(RequestPacket->OutputBuffer), hwDeviceExtension->DriverRegPath);
                    RequestPacket->StatusBlock->Information = strlen(hwDeviceExtension->DriverRegPath);
                    status = NO_ERROR;
                }
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_VAL
        // Queries a registry value.
        // We support only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_VAL:
            {
                PWSTR     regKeyName;
                PVOID     regValData;

                regKeyName = (PWSTR)(RequestPacket->InputBuffer);
                regValData = (PVOID)(RequestPacket->OutputBuffer);

                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVRegistryCallback,
                                       regValData);
                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL
        // Queries a Binary registry value.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL:
            {
                PWSTR     regKeyName;
                PNV_REGISTRY_STRUCT pRegStructInput;
                NV_REGISTRY_STRUCT  RegStruct;
                PVOID pOutput;
                ULONG OutputLength;
                
                pRegStructInput = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);
                regKeyName = (PWSTR)(pRegStructInput->keyName);
                pOutput = (PVOID)(RequestPacket->OutputBuffer);
                OutputLength = (ULONG)(RequestPacket->OutputBufferLength);
                
                // Copy the required values into the input structure
                // Note that the OS preserves/restores the content of the  the 
                RegStruct.keyVal = pOutput;
                RegStruct.keyValSize = OutputLength;
                RegStruct.keyName = regKeyName;

                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVReadRegistryBinaryCallback,
                                       (PVOID)&RegStruct);
                if (status == NO_ERROR)
                {
                    RequestPacket->StatusBlock->Information = RegStruct.keyValSize;
                }
                else
                {
                    RequestPacket->StatusBlock->Information = 0;
                }
            }
            break;

#if (_WIN32_WINNT >= 0x0500)

#ifdef NV_ZW_FILE_IO_ENABLED
        //**************************************************************************
        // IOCTL_VIDEO_ZW_XXX
        // Wrappers for the Zw file IO functions.
        //**************************************************************************

        case IOCTL_VIDEO_ZW_CREATE_FILE:
            {
                PNV_ZW_CREATE_FILE_IN pZwCreateFileIn = (PNV_ZW_CREATE_FILE_IN)RequestPacket->InputBuffer;
                IO_STATUS_BLOCK IoBlock;
                PVOID hFile;
                PVOID *phFileOutput = RequestPacket->OutputBuffer;

                status = ZwCreateFile( &hFile,
                                       pZwCreateFileIn->ulDesiredAccess,
                                       &pZwCreateFileIn->ObjectAttributes,
                                       &IoBlock,
                                       &pZwCreateFileIn->liAllocationSize,
                                       pZwCreateFileIn->ulFileAttributes,
                                       pZwCreateFileIn->ulShareAccess,
                                       pZwCreateFileIn->ulCreateDisposition,
                                       pZwCreateFileIn->ulCreateOptions,
                                       pZwCreateFileIn->pvEaBuffer,
                                       pZwCreateFileIn->ulEaLength );

    

                if (status == NO_ERROR)
                {
                    *phFileOutput = hFile;
                    RequestPacket->StatusBlock->Information = sizeof(hFile);
                }
                else
                {
                    *phFileOutput = NULL;
                    RequestPacket->StatusBlock->Information = 0;
                }

            }
            break;

        case IOCTL_VIDEO_ZW_WRITE_FILE:
            {
                PNV_ZW_RW_FILE_IN pZwWriteFileIn = (PNV_ZW_RW_FILE_IN)RequestPacket->OutputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwWriteFile( pZwWriteFileIn->pvFileHandle,
                                      pZwWriteFileIn->pvEvent,
                                      pZwWriteFileIn->pvApcRoutine,
                                      pZwWriteFileIn->pvApcContext,
                                      &IoBlock,
                                      pZwWriteFileIn->pvBuffer,
                                      pZwWriteFileIn->ulLength,
                                      &pZwWriteFileIn->liByteOffset,
                                      pZwWriteFileIn->pvKey );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_ZW_READ_FILE:
            {
                PNV_ZW_RW_FILE_IN pZwReadFileIn = (PNV_ZW_RW_FILE_IN)RequestPacket->OutputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwReadFile( pZwReadFileIn->pvFileHandle,
                                     pZwReadFileIn->pvEvent,
                                     pZwReadFileIn->pvApcRoutine,
                                     pZwReadFileIn->pvApcContext,
                                     &IoBlock,
                                     pZwReadFileIn->pvBuffer,
                                     pZwReadFileIn->ulLength,
                                     &pZwReadFileIn->liByteOffset,
                                     pZwReadFileIn->pvKey );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = pZwReadFileIn->ulLength;
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_ZW_CLOSE_HANDLE:
            {
                PVOID *phFile = RequestPacket->InputBuffer;
                status = ZwClose( *phFile );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_CONTROL_DEVICE:
            {
                PNV_ZW_DEVICE_IO_CONTROL_FILE pControlDevice = (PNV_ZW_DEVICE_IO_CONTROL_FILE)RequestPacket->InputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwDeviceIoControlFile( pControlDevice->hDevice,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoBlock,
                                                pControlDevice->ulIoControlCode,
                                                pControlDevice->pvInputBuffer,
                                                pControlDevice->ulInputBufferSize,
                                                RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength );

                if( status == NO_ERROR )
                    RequestPacket->StatusBlock->Information = RequestPacket->OutputBufferLength;
                else
                    RequestPacket->StatusBlock->Information = 0ul;
            }
            break;

        case IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS:
            {
                PNV_ZW_FILE_IO_FUNCS pFuncs = (PNV_ZW_FILE_IO_FUNCS)RequestPacket->OutputBuffer;

                pFuncs->pvZwCreateFile = (LPNVZWCREATEFILEFUNCTION)ZwCreateFile;
                pFuncs->pvZwWriteFile = (LPNVZWWRITEFILEFUNCTION)ZwWriteFile;
                pFuncs->pvZwReadFile = (LPNVZWREADFILEFUNCTION)ZwReadFile;
                pFuncs->pvZwClose = (LPNVZWCLOSEFUNCTION)ZwClose;
                pFuncs->pvZwDeviceIoControlFile = (LPNVZWDEVICEIOCONTROLFILEFUNCTION)ZwDeviceIoControlFile;

                status = NO_ERROR;
                RequestPacket->StatusBlock->Information = sizeof(NV_ZW_FILE_IO_FUNCS);
            }
            break;

#else

        case IOCTL_VIDEO_ZW_CREATE_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_CREATE_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_WRITE_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_WRITE_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_READ_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_READ_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_CLOSE_HANDLE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_CLOSE_HANDLE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_CONTROL_DEVICE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_CONTROL_DEVICE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;
#endif

#endif // (_WIN32_WINNT >= 0x0500)


      // Sets a Display value ( vga, fp or tv, and tv type: ntsc or pal) in the registry
      case IOCTL_VIDEO_SET_DISPLAY_DEVICE:
         {
            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidParams;

            if(RequestPacket->InputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               sgdt = (PSETGETDEVTYPE)RequestPacket->InputBuffer;
               VideoDebugPrint((2, "NVStartIO - SetDisplayDevice\n"));

               switch(sgdt->dwDeviceType) {
                  case 0:     // NV_DISPLAY_TYPE_VGA
                     sdtp.Type = DISPLAY_TYPE_MONITOR;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  case 2:     // NV_DISPLAY_TYPE_TV_NTSC
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 3:     // NV_DISPLAY_TYPE_TV_PAL
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 4:     // NV_DISPLAY_TYPE_FLAT_PANEL
                     sdtp.Type = DISPLAY_TYPE_FLAT_PANEL;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  default: // ?
                     ValidParams = FALSE;
                     break;
               }

               // - If all of the params are cool, attempt the settings
               if(ValidParams) {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: Type: %d, TVType: %d\n",sdtp.Type,sdtp.TVType));

                  // - Go set the values in the registry
                  if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                         NV_CFGEX_SET_DISPLAY_TYPE,
                                         &sdtp,
                                         sizeof(NV_CFGEX_SET_DISPLAY_TYPE_PARAMS))) {

                     // The Rm call seems to have succeded
                     status = NO_ERROR;
                  }
                  else {

                     VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: RmConfigSetExKernel failed\n"));
                     status = ERROR_INVALID_PARAMETER;   // This is not correct, but the other error codes are
                                                         // just as incorrect!
                  }

                  // - Nothing to return to the caller
                  RequestPacket->StatusBlock->Information = 0;

               }
               else {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: The parameters were in error.\n"));
                  // - Wrap up IOCTL control info for failure
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // Gets a Display value ( vga, fp or tv, and tv type: ntsc or pal) from the registry
      case IOCTL_VIDEO_GET_DISPLAY_DEVICE:
         {

            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidRegData;

            if(RequestPacket->OutputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - GetDisplayDevice\n"));
               sgdt = (PSETGETDEVTYPE)RequestPacket->OutputBuffer;
               status = NO_ERROR;

               // - Go get the values in the registry
               ValidRegData = FALSE;
               if(RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                      NV_CFGEX_GET_DISPLAY_TYPE,
                                      &sdtp,
                                      sizeof(NV_CFGEX_GET_DISPLAY_TYPE_PARAMS))) {
                  ValidRegData = TRUE;
               }

               if(ValidRegData) {

                  // - Update the values in the passed in buffer
                  switch(sdtp.Type) {

                     case DISPLAY_TYPE_MONITOR:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;

                     case DISPLAY_TYPE_TV:
                        switch(sdtp.TVType) {
                           case 0: // NV_REG_TVFORMAT_NTSCM
                           case 1: // NV_REG_TVFORMAT_NTSCJ
                              sgdt->dwDeviceType = 2; // NV_DISPLAY_TYPE_TV_NTSC
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           case 2: // NV_REG_TVFORMAT_PALM
                           case 3: // NV_REG_TVFORMAT_PALB
                           case 4: // NV_REG_TVFORMAT_PALN
                           case 5: // NV_REG_TVFORMAT_PALNC
                              sgdt->dwDeviceType = 3; // NV_DISPLAY_TYPE_TV_PAL
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           default:
                              sgdt->dwDeviceType = 2; // Make this NTSC just in case someone does not pay attention
                              sgdt->dwTvFormat = 0;
                              sgdt->dwSuccessFlag = FALSE;
                              break;
                        }
                        break;

                     case DISPLAY_TYPE_FLAT_PANEL: // NV_DISPLAY_TYPE_FLAT_PANEL
                        sgdt->dwDeviceType = 4;
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;


                     default:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;
                  }
               }
               else {   // Data in reg not avail, so return faliure
                     sgdt->dwDeviceType = 0;
                     sgdt->dwTvFormat = 0;
                     sgdt->dwSuccessFlag = FALSE;
               }

               // - Wrap up IOCTL control info
               RequestPacket->StatusBlock->Information = sizeof(SETGETDEVTYPE);
               status = NO_ERROR;

            }
         }
         break;

     case IOCTL_VIDEO_GET_TV_ENCODER_TYPE:
         {
            NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
            VideoDebugPrint((2, "NVStartIO -  IOCTL_VIDEO_GET_TV_ENCODER_TYPE\n"));
            if ( RequestPacket->OutputBufferLength < sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS) )
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else
            {
                TVInfo.Head        = 0;
                TVInfo.EncoderID   = hwDeviceExtension->ulTVEncoderID;
                TVInfo.EncoderType = hwDeviceExtension->ulTVEncoderType;

                // We have a valid blob from the resman, so extract the encoder info
                VideoDebugPrint((2,"From RM: TVEncoderType = 0x%x, TVEncoderID = 0x%x\n",TVInfo.EncoderType,TVInfo.EncoderID));
                *((NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS*)RequestPacket->OutputBuffer) = TVInfo;
                RequestPacket->StatusBlock->Information = sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS);
                status = NO_ERROR;
            }
         }
         break;

      // - NV_ESC_VALIDATE_DEVICE_MODE path into the miniport
      case IOCTL_VALIDATE_DEVICE_MODE:
         {

            BOOL  ValidParams;
            VALMODEXTR *vmx;

            if( (RequestPacket->InputBufferLength < sizeof(VALMODEXTR)) ||
                (RequestPacket->OutputBufferLength < sizeof(ULONG)) ){
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               vmx = (VALMODEXTR *)RequestPacket->InputBuffer;
               VideoDebugPrint((1, "NVStartIO - ValidateDeviceMode\n"));
               VideoDebugPrint((1, "NVStartIO -   dwHRes = %ld\n",vmx->dwHRes));
               VideoDebugPrint((1, "NVStartIO -   dwVRes = %ld\n",vmx->dwVRes));
               VideoDebugPrint((1, "NVStartIO -   dwBpp = %ld\n",vmx->dwBpp));
               VideoDebugPrint((1, "NVStartIO -   dwRefresh = %ld\n",vmx->dwRefresh));
               VideoDebugPrint((1, "NVStartIO -   dwDeviceType = %ld\n",vmx->dwDeviceType));

               ValidParams = TRUE;

               // - If all of the params are cool, attempt the validate mode function
               if(ValidParams) {

                  // - Go set the values in the device context, no error checking for now...
                  if(NVValidateDeviceMode(hwDeviceExtension, vmx)) {

                     // - That mode is VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = TRUE;
                  }
                  else {

                     // - That mode is NOT VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = FALSE;
                  }

                  RequestPacket->StatusBlock->Information = sizeof(ULONG);
                  status = NO_ERROR;

               }
               else {
                  RequestPacket->StatusBlock->Information = 0;
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // - This next one seems like a lot of work for nothing, but is keeps it comp with 9x for now
      case IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER:
         {

            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER\n"));

               // - We use the device reference + 1
               *(ULONG *)RequestPacket->OutputBuffer = hwDeviceExtension->DeviceReference + 1;
               RequestPacket->StatusBlock->Information = sizeof(ULONG);
               status = NO_ERROR;

            }
         }
         break;

      // - This IOCTL return the current gamma cache clut stored in the device extension
      case IOCTL_VIDEO_GET_GAMMA_CLUT:
         {

            if(RequestPacket->OutputBufferLength != MAX_CLUT_SIZE) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_GAMMA_CLUT\n"));

               status = NVGetColorLookup(hwDeviceExtension,
                                         (PVIDEO_CLUT)RequestPacket->OutputBuffer,
                                         RequestPacket->OutputBufferLength );

               RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE;

            }
         }
         break;
         
        
        //**************************************************************************
        // Save/Restore the Gamma values for the mode switching.
        //**************************************************************************
        case IOCTL_VIDEO_SAVE_GAMMA_VALUES:
            if(RequestPacket->InputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->InputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pGammaCache++ = *pCallerBuffer++;
                }
                status = NO_ERROR;
            }
            break;
            
        case IOCTL_VIDEO_RESTORE_GAMMA_VALUES:
            if(RequestPacket->OutputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->OutputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pCallerBuffer++ = *pGammaCache++;
                }
                status = NO_ERROR;
                RequestPacket->StatusBlock->Information =sizeof(hwDeviceExtension->GammaCacheData);
            }
            break;
        //**************************************************************************
        // CONVERT_RING3_HANDLE
        // Converts a ring3 handle to a ring0 handle
        //**************************************************************************

        case IOCTL_CONVERT_RING3_HANDLE:
            {
            HANDLE** input = (HANDLE**) RequestPacket->InputBuffer;

            status = NVObReferenceObjectByHandle(*(input[0]), input[1]);
            }
            break;

        //**************************************************************************
        // MAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_MAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory, *pShareMemoryInformation;
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS params;
            U032 physicalAGPBase;

            VideoDebugPrint((2, "W32StartIO - MapPhysAddr\n"));

            if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY) ||
                 (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // NOTE: we are ignoring ViewOffset
            //**********************************************************************

            shareAddress.HighPart = 0x00000000;
            PHYSICAL_ADDRESS_VALUE(shareAddress) = pShareMemory->physicalAddress;
            pShareMemoryInformation = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->OutputBuffer;

            //**********************************************************************
            // Map the physical address into a non-cached kernel mode address.
            //**********************************************************************
            pShareMemoryInformation->ddVirtualAddress =
                MmMapIoSpace(shareAddress,
                            (size_t) sharedViewSize,
                            (MmNonCached | MmWriteCombined));

            if (pShareMemoryInformation->ddVirtualAddress == NULL)
                {
                status = ERROR_INVALID_PARAMETER;
                break;
                }

            //**********************************************************************
            // Set the RM's AGP linear base if a mapping doesn't exist already. We
            // don't expect this to ever been needed, since the RM should've been
            // able to create their own mapping to the AGP phys base. Just in case,
            // set it up if it's not already.
            //**********************************************************************
            RmConfigGetKernel(hwDeviceExtension->DeviceReference,
                              NV_CFG_AGP_PHYS_BASE, &physicalAGPBase);

            RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_AGP_LINEAR_BASE,
                                &params,
                                sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            if ((params.linaddr == NULL) &&
                (physicalAGPBase == pShareMemory->physicalAddress)) {
                
                // update the RM's linear base
                params.linaddr = pShareMemoryInformation->ddVirtualAddress;
                RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                    NV_CFGEX_AGP_LINEAR_BASE,
                                    &params,
                                    sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            }

            //**********************************************************************
            // Returned amount of mapped memory to specific process
            //**********************************************************************

            pShareMemoryInformation->byteLength = sharedViewSize;

            status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // UNMAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_UNMAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory;

            VideoDebugPrint((2, "W32StartIO - UnmapPhysAddr\n"));

            if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // Unmap the virtual address.
            //**********************************************************************
            MmUnmapIoSpace(pShareMemory->ddVirtualAddress,
                        (size_t) sharedViewSize);

            pShareMemory->ddVirtualAddress = NULL;
            status = NO_ERROR;
            }
            break;

        case IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR:
            {
                ULONG * pulXY;

                if(RequestPacket->InputBufferLength != sizeof(ULONG))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pulXY = (ULONG *)RequestPacket->InputBuffer;
                    hwDeviceExtension->NvCursorInfo.lCursorX= (LONG)( (SHORT)(*pulXY & 0xFFFF));
                    hwDeviceExtension->NvCursorInfo.lCursorY= (LONG)( (SHORT)(*pulXY >> 16));
                    status = NO_ERROR;
                    break;
                }
            }
            break;

        case IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR:
            {
                NV_CURSOR_INFO * pNvCursorInfo;

                if(RequestPacket->InputBufferLength != sizeof(NV_CURSOR_INFO))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pNvCursorInfo = (NV_CURSOR_INFO * )RequestPacket->InputBuffer;

                    hwDeviceExtension->NvCursorInfo.lCursorX = pNvCursorInfo->lCursorX;
                    hwDeviceExtension->NvCursorInfo.lCursorY = pNvCursorInfo->lCursorY;
                    hwDeviceExtension->NvCursorInfo.lCursorWidth = pNvCursorInfo->lCursorWidth;
                    hwDeviceExtension->NvCursorInfo.lCursorHeight = pNvCursorInfo->lCursorHeight;
                    hwDeviceExtension->NvCursorInfo.lScreenStride = pNvCursorInfo->lScreenStride;
                    hwDeviceExtension->NvCursorInfo.lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;
                    hwDeviceExtension->NvCursorInfo.ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
                    hwDeviceExtension->NvCursorInfo.ulOriginalImageMemOffset = pNvCursorInfo->ulOriginalImageMemOffset;
                    hwDeviceExtension->NvCursorInfo.ulCursorMemOffset = pNvCursorInfo->ulCursorMemOffset;

                    VideoPortStartTimer(hwDeviceExtension);
                    status = NO_ERROR;
                }
            }
            break;

        case IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR:
            {
                VideoPortStopTimer(hwDeviceExtension);
                status = NO_ERROR;
            }
            break;


#if !defined(_WIN64)
        case IOCTL_VIDEO_STEREO_GLASSES_SWITCH:
            {
                if (   (NULL!=RequestPacket->InputBuffer)
                    && (RequestPacket->InputBufferLength==sizeof(NV_CFG_STEREO_PARAMS)) )
                {
                    NV_CFG_STEREO_PARAMS  StereoParamsOld;

                    // this interface is used for workstation opengl api stewreo so far !
                    ASSERT( ((NV_CFG_STEREO_PARAMS*)RequestPacket->InputBuffer)->Flags & STEREOCFG_WS_OGL_API_STEREO);

                    // NOT IA64 SAVE !! because we cast a pointer to U032 !!
                    if( RmConfigSetKernel( hwDeviceExtension->DeviceReference,
                                           NV_CFG_STEREO_CONFIG,
                                           (U032)RequestPacket->InputBuffer,
                                           (U032*)&StereoParamsOld)
                      )
                    {
                        status = NO_ERROR;
                    }
                }
                else
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_STEREO_GLASSES_SWITCH failed because of invalid RequestPacket->InputBuffer data!"));
                }

            }
            break;
#endif

        case IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS:  // should be called only from the multi dev layer of the NT4 display driver!
            {
                PVOID pvDevObj;
                ULONG ulNumDevObj;

                if (RequestPacket->OutputBufferLength < sizeof(QUERY_NUM_OF_DEVICE_OBJECTS) ||
                    RequestPacket->InputBufferLength < sizeof(QUERY_NUM_OF_DEVICE_OBJECTS))
                {
                  status = ERROR_INSUFFICIENT_BUFFER;
                  break;
                }
                pvDevObj = ((QUERY_NUM_OF_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->pvDevObj;  // need hDriver in InputBuffer
                ASSERT(pvDevObj);
                if (pvDevObj)
                {
                    ((QUERY_NUM_OF_DEVICE_OBJECTS *)(RequestPacket->OutputBuffer))->ulNumDevObj = ulQueryNumDevices(pvDevObj);

                    status = NO_ERROR;
                    RequestPacket->StatusBlock->Information = sizeof(QUERY_NUM_OF_DEVICE_OBJECTS);
                }
            }  
            break;

        case IOCTL_VIDEO_GET_DEVICE_OBJECTS:  // should be called only from the multi dev layer of the NT4 display driver!
            {
                ULONG ulNumDevObj;
                PVOID pvDevObj;
                PVOID *ppvOutDevObj;

                if (RequestPacket->InputBufferLength < (sizeof (GET_DEVICE_OBJECTS)))
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                pvDevObj    = ((GET_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->pvDevObj;     // need hDriver in InputBuffer
                ulNumDevObj = ((GET_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->ulNumDevObj;  


                if (RequestPacket->OutputBufferLength < (sizeof (GET_DEVICE_OBJECTS) + (ulNumDevObj -1) * sizeof(PVOID) )) 
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                ppvOutDevObj = &((GET_DEVICE_OBJECTS *)(RequestPacket->OutputBuffer))->apvDevObj[0];

                if (!bGetDevices(pvDevObj, ppvOutDevObj))
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                }
                else
                {
                    RequestPacket->StatusBlock->Information = (sizeof (GET_DEVICE_OBJECTS) + (ulNumDevObj -1) * sizeof(PVOID) );
                    status = NO_ERROR;
                }
            }
            break;

    default:

        //**************************************************************************
        // if we get here, an invalid IoControlCode was specified.
        //**************************************************************************

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;
        }

        //  Zero out the Information in StatusBlock when Error occurs.
        
        if(status != NO_ERROR)
        {
            RequestPacket->StatusBlock->Information = 0;
        }

    RequestPacket->StatusBlock->Status = status;
#if DBG
    VideoDebugPrint((2, "W32StartIO Exit  - %08.8x\n", RequestPacket->IoControlCode));
#endif
    return TRUE;

    } // NVStartIO()

//******************************************************************************
//
// Function: NVInterrupt()
//
// Routine Description:
//   This function services interrupts generated by the device.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//   TRUE -- if this device caused the interrupt and when the interrupt is
//           serviced and the interrupt reset
//
//   FALSE -- if this device was not responsible for the interrupt
//
//******************************************************************************


BOOLEAN NVInterrupt(
    PVOID HwDeviceExtension
)
{
        PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
        BOOLEAN serviced;

        // Only service the interrupt when the power of adapter is on
        if(hwDeviceExtension->curAdapterPowerState != VideoPowerOn)
            return(FALSE);

        serviced = (BOOLEAN) RmIsr(hwDeviceExtension->DeviceReference);

        return serviced;
}

//******************************************************************************
//
// private routines
//
//******************************************************************************


//******************************************************************************
//
// Function: NVSetColorLookup()
//
// Routine Description:
//
//     This routine sets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the input buffer supplied by the user.
//
//     ClutBuffer - Pointer to the structure containing the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************


VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )


    {
    USHORT i;
    ULONG OutData;

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //**************************************************************************
    // Check to see if the parameters are valid.
    //**************************************************************************

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //**************************************************************************
    // Set palette for either.
    //**************************************************************************
    NV_SetColorLookup(HwDeviceExtension,ClutBuffer,ClutBufferSize);

    return NO_ERROR;

    } // end NVSetColorLookup()



//******************************************************************************
//
// Function: NVGetColorLookup()
//
// Routine Description:
//
//     This routine gets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the output buffer supplied by the user.
//
//     ClutBuffer - Pointer to the buffer to store the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - output buffer not large enough for clut data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************

VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

    {
      PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut,dstclut;
      ULONG index,item,NumEntries,FirstEntry;

      //**************************************************************************
      // Get data from gamma cache.
      //**************************************************************************

      // - Make things nice to look at
                pvcdItemSrc = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pvcdItemDst = &ClutBuffer->LookupTable->RgbArray;
      srcclut = &hwDeviceExtension->GammaCache;
      dstclut = ClutBuffer;

      // - Copy over the clut specs
      dstclut->NumEntries = srcclut->NumEntries;
      dstclut->FirstEntry = srcclut->FirstEntry;

      // - Set the limits on the item copy
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    return NO_ERROR;

    } // end NVGetColorLookup()



//******************************************************************************
//
// Function: NVRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    //**********************************************************************
    // Deals with data if size > 4 bytes
    // If > 4 bytes, we'll treat it as Unicode string data  (MODE ENTRIES)
    // and not dword registry switches
    //**********************************************************************

    if (ValueLength > sizeof(ULONG))
        {
        //*******************************************************************
        // Copy string data into our temporary buffer registry_data[]
        // Since this callback can be called MANY times per each
        // VideoPortGetRegistry call, we need to manually keep track of where
        // to store the incoming data, since the Context ptr is NOT
        // automatically incremented.  It's always equal to the
        // base address of registry_data.  That is, the RegistryDataOffset value
        // is incremented each time we read a short value from the registry,
        // so that the next time this callback gets called, we'll know where
        // we left off.
        //*******************************************************************

        DestPtr = (SHORT*)((PUCHAR)Context + hwDeviceExtension->RegistryDataOffset);
        SrcStrPtr = (PUCHAR)(ValueData);

        //**********************************************************************
        // Reading mode data numbers from the current mode entry line.
        // This registry callback will continue getting called for each line
        // until the last line is encountered.
        //**********************************************************************

        while (SrcStrPtr < (PUCHAR)ValueData + ValueLength - 2)
            {

            shortvalue = GetNextWordFromRegistry(hwDeviceExtension,&SrcStrPtr);
            *DestPtr = shortvalue;

            //******************************************************************
            // Need to manually keep track of where we need to store the numbers
            // (short values) the next time the registry call back gets called.
            //******************************************************************

            (hwDeviceExtension->RegistryDataOffset)+=2;
            DestPtr++;

            //******************************************************************
            // Debug Safety Check:
            // Make sure we don't go past the end of the registry_data table
            // Backup 30 words from end of table
            //******************************************************************

            if (hwDeviceExtension->RegistryDataOffset > ( (MAX_STRING_REGISTRY_DATA_WORDS*2) - (30*2))  )
                {
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                }

            }



        return(NO_ERROR);


        }

    //*************************************************************************
    // Read dword entries
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, (size_t) ValueLength);
    return(NO_ERROR);
    } // end NVRegistryCallback()



//******************************************************************************
//
// Function: NVReadLocalRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()

//******************************************************************************
//
// Function: NVReadRegistryTwinViewInfoCallback()
//
// Routine Description:     Used to read the "TwinViewInfo" registry entry.
//                          Do not use it for any other purpose.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    // In rare pathlogical condidtions, it is possible for the disk copy of the "TwinViewInfo" structure to be different
    // than the incore structure. This happens when for example the structure gets modified in the source tree but
    // there is a leftover disk entry from a previous version of driver.
    if (ValueLength != sizeof(NVTWINVIEWDATA))
    {
        VideoDebugPrint((1, "Oops!TwinViewCallback(): size mismatch Diskcopy size: %d, struct size: %d\n",
                         ValueLength, sizeof(NVTWINVIEWDATA)));
        return(ERROR_INVALID_PARAMETER);
    }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()

//******************************************************************************
//
// Function: NVReadRegistrySaveSettingsCallback()
//
// Routine Description:     Used to read the "SaveSettings" registry entry.
//                          Do not use it for any other purpose.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistrySaveSettingsCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;
    ULONG ulCurrentTwinViewInfoSize;
    ULONG ulExpectedDataSize;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    ulCurrentTwinViewInfoSize = sizeof(NVTWINVIEWDATA);
    ulExpectedDataSize = ulCurrentTwinViewInfoSize * NUM_ENTRIES_SAVE_SETTINGS;

    // In rare pathlogical condidtions, it is possible for a data mismatch. For example, the user could have manually
    // copied the driver binaries without doing a full driver installation. A full driver kit installation will blow
    // away any existing "SaveSettings" registry entry.
    if (ValueLength != ulExpectedDataSize)
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): size mismatch Diskcopy size: %d, expected size: %d\n",
                         ValueLength, ulExpectedDataSize));
        return(ERROR_INVALID_PARAMETER);
    }

    // Sanity check. Make sure sufficient array was set aside to read in the SaveSettings.
    if (ValueLength > sizeof(hwDeviceExtension->SaveSettings))
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): not enough array size in hwdevextension: size: %d, expected size: %d\n",
                         ValueLength, sizeof(hwDeviceExtension->SaveSettings)));
        return(ERROR_INVALID_PARAMETER);
    }

    // Sanity check. Should never happen
    if (ValueData == NULL)
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): ValueData pointer is NULL\n"));
        return(ERROR_INVALID_PARAMETER);
    }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadSaveSettingsCallback()

//******************************************************************************
//
// Function: NVReadRegistryCallbackBinaryValue()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PNV_REGISTRY_STRUCT pRegStruct;




    //**********************************************************************
    // If the destination ptr is null, we return error.
    // The user sent us a null output pointer.
    //**********************************************************************
    if (Context == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pRegStruct = (PNV_REGISTRY_STRUCT)Context;

    // Check to see if the user passed us a non-NULL buffer
    if (pRegStruct->keyVal == NULL)
    {
        // Tell him what is the expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    // Check to see if the user passed us enough of a buffer
    if (pRegStruct->keyValSize < ValueLength || pRegStruct->keyValSize == 0)
    {
        // The user did not send us enough buffer. Tell him what is the 
        // expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) pRegStruct->keyVal, (PUCHAR) ValueData, ValueLength);
    pRegStruct->keyValSize = ValueLength;
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()



//******************************************************************************
//
// Function: NVReadMonitorTimingModeCallback()
//
// Routine Description: If there is a reg entry and it fits, copy it
//                      If it is to big, copy the string L"DMT" instead
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if(Context == NULL) {
      return(NO_ERROR);
    }


    //*************************************************************************
    // Compare the value to the GTF and DMT strings
    //*************************************************************************

    if(!memcmp( (PUCHAR)L"GTF", (PUCHAR) ValueData, sizeof(L"GTF"))) {
        VideoDebugPrint((1, "GTF overide detected\n"));
        *(ULONG *)Context = TRUE;
        }
    else {
        *(ULONG *)Context = FALSE;
        }

    return(NO_ERROR);
}


//******************************************************************************
//
// Function:    NVSetBiosInfo(HwDeviceExtension)
//
// Routine Description:
//  Attempts to locate BIOS version string. First it searches for
//  a standard NV Bios Info block. If that is not present, it
//  assumes this is a Viper board and scans for a version
//  string.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NVSetBiosInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PUCHAR VersionStr = "Version ";
    PUCHAR pBios = HwDeviceExtension->pBios;
    USHORT  i, j, c;
    BOOLEAN Found = FALSE;
    WCHAR   wcNameStr[BIOS_STR_MAX] = L"<unavailable>";
    CHAR    NameStr[BIOS_STR_MAX];

    //********************************************************
    // Ask RM for NVidia BIOS revision.
    //********************************************************
    if (RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_BIOS_REVISION, &(HwDeviceExtension->BiosRevision))
        && HwDeviceExtension->BiosRevision)
        {

        //********************************************************
        // See if it's an Elsa BIOS: Elsa uses a similar data structure
        // as the NVIDIA BIOS, but the version string is 24-bits instead of 32.
        //********************************************************
        if (pBios != NULL)
        {
            strcpy(NameStr, "ELSA");
            for (i = 0; i < MAX_BIOS_SCAN; i++)
                if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
                    break;
        }

        strcpy(NameStr, "Version ");

        // If Found, it's an ELSA BIOS

        if (Found)
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ff00) >> 8), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x000000ff)), &(NameStr[strlen(NameStr)]), 16, 2);
        }
        else
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0xff000000) >> 24), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ffff)), &(NameStr[strlen(NameStr)]), 16, 4);
        }

        //*******************************************************
        // Convert BIOS version string to unicode.
        //*******************************************************
        for (c = i = 0; c < strlen(NameStr); c++)
            {
            wcNameStr[c] = (WCHAR)(NameStr[i + c]) & (WCHAR) 0xff;
            }
        wcNameStr[c] = (WCHAR) 0;
        goto WriteRegistryVersionStr;
        }

    //********************************************************
    // Search for Diamond Viper BIOS: it doesn't use the same
    // version strings as the standard NV BIOS.
    //********************************************************
    if (pBios == NULL)
        return;

    strcpy(NameStr, "Viper ");
    for (i = 0; i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Viper BIOS: write the default version
        // string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    Found = FALSE;
    for ( i += (strlen(NameStr) + 1); i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(VersionStr, &pBios[i], strlen(VersionStr)) == strlen(VersionStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Version String in the Viper BIOS: write
        // the default version string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    //*******************************************************
    // Determine length of BIOS version string.
    //*******************************************************
    Found = FALSE;
    for (j = i; j < MAX_BIOS_SCAN; j++)
        if (Found = (pBios[j] == '\r'))
            break;

    if (!Found || (j == i))
        return;

    //*******************************************************
    // Convert BIOS version string to unicode.
    //*******************************************************
    for (c = 0; (c < j - i) && (c < BIOS_STR_MAX - 1); c++)
        {
        wcNameStr[c] = (WCHAR)(pBios[i + c] & 0xffffL);
        }

    wcNameStr[c] = (WCHAR) 0;

WriteRegistryVersionStr:
    //*******************************************************
    // Write version string to registry so display applet
    // can access it.
    //*******************************************************
    VideoPortSetRegistryParameters(HwDeviceExtension,
                L"HardwareInformation.BiosString",
                wcNameStr,
                (wcslen(wcNameStr) + 1) * sizeof(WCHAR));
    return;
}

//******************************************************************************
//
// Function: wtoa(Number, pString, radix, width
//
// Routine Description:
//  Converts an unsigned 16 number to an ASCII string.
//
// Arguments:
//      Number      Number to be converted
//      pString     ptr to buffer for converted string. Must be
//                  a min of 6 bytes long.
//      radix       base for conversion
//      width       If 0, do not store leading 0s in pString, otherwise == number of nibbles in input number
//
// Return Value:
//
//******************************************************************************
VOID wtoa(USHORT Number, PUCHAR pString, UCHAR radix, UCHAR width)
{
    ULONG   divisor;
    USHORT  digit;
    USHORT  i;


    if (width)
        divisor = 1 << (4 * (width - 1));
    else
    {
        divisor = radix;
        while (divisor <= Number)
            divisor *= radix;
    }

    for (i = 0; divisor; (divisor /= radix))
        {
        digit = (USHORT)(Number / divisor);
        if (!(!i && !digit && !width))
            if (digit < 10)
                pString[i++] = (UCHAR) ((digit) + '0');
            else
                pString[i++] = (UCHAR) ((digit - 10) + 'A');
        Number = (USHORT) (Number % divisor);
        }
    pString[i]='\0';
}

#if _WIN32_WINNT < 0x0500
//******************************************************************************
//
// Function: wcslen(pString)
//
// Routine Description:
//  Our implementation of a wide char string length routine. We
//  can't call the c lib version of wcslen from this kernel mode
//  driver.
//
// Arguments:
//      pString     wide char string
//
// Return Value:
//      Length of string in wide chars, less the null terminator.
//******************************************************************************
ULONG wcslen(PWCHAR pString)
{
    ULONG i;

    for (i = 0; pString[i]; i++);
    return(i);
}
#endif // #if _WIN32_WINNT < 0x0500



//******************************************************************************
//
// Function: GetNextWordFromRegistry
//
// Routine Description:
//
//          Read the next value in the mode entry line.
//          This function 1) skips unicode white space, and then
//          Converts the unicode string to an integer (short) value.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    )


    {
    SHORT value;
    UCHAR ch;

    ch = **SrcStrPtr;

    //******************************************************************************
    // Skip over empty space in unicode string
    //******************************************************************************

    while ((ch == 0) || (ch == ' '))
        {
        (*SrcStrPtr)++;                 // Advance the unicode string ptr
        ch = **SrcStrPtr;
        }

    //******************************************************************************
    // We're now at the beginning of the next 'unicode' number
    //******************************************************************************

    value = my_wtoi(SrcStrPtr);

    return(value);
    }


//******************************************************************************
//
// Function: my_wtoi
//
// Routine Description:
//
//      Converts unicode string to an integer (short value)
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    )

    {
    short i,n;

    n=0;
    for (i=0  ; ((**SrcStrPtr) >= '0') && ((**SrcStrPtr) <='9')  ; (*SrcStrPtr)+=2 )
        n=10 * n + ((**SrcStrPtr) - '0');

    return(n);
    }

//******************************************************************************
//
// Function: my_strupr
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strupr(
    PUCHAR s
    )

    {
    short i;

    for (i=0; s[i] != '\0'; i++)
        if ( (s[i] >= 'a') && ( s[i] <='z')  )
            s[i] = (s[i] - 'a') + 'A';

    }

//******************************************************************************
//
// Function: my_strcmp
//
// Routine Description:
//
//      String compare routine.
//      Returns Zero if strings are equal.
//      Returns NonZero if string are not equal
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


ULONG my_strcmp(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;


    for (i=0; s[i] == t[i] ; i++)
        if (s[i] == '\0')
            return(0);

    return(s[i] - t[i]);
    }


//******************************************************************************
//
// Function: my_strcpy
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strcpy(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;

    i=0;

    while (  ( s[i] = t[i]  ) != '\0')
        i++;
    }


//******************************************************************************
//
// Function: NV10CursorTimer
//
// Routine Description:
//
//      This function is to workaround the NV10 HW cursor alpha blending problem.
//      Please also see NV10SetPointerShape and NV10MovePointer in NV10ptr.c in
//      displays driver.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NV10CursorTimer(
    PVOID HwDeviceExtension
)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    LONG i, j, x, y;
    LONG lScreenStride;
    LONG lScreenPixelDepth;

    ULONG ulAlpha;
    ULONG ulBgdColor;
    ULONG ulBgdRed;
    ULONG ulBgdGreen;
    ULONG ulBgdBlue;
    ULONG ulSrcRed;
    ULONG ulSrcGreen;
    ULONG ulSrcBlue;
    ULONG ulSrcColor;
    ULONG ulDstColor;
    ULONG ulHwCursorWidth;      // HW : 32 or 64

    NV_CURSOR_INFO * pNvCursorInfo;

    UCHAR * pjScreenLoc;
    ULONG * pulDstCursor;
    ULONG * pulSrcCursor;


    pNvCursorInfo = &hwDeviceExtension->NvCursorInfo;

    lScreenStride = pNvCursorInfo->lScreenStride;
    ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
    lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;

    pulDstCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulCursorMemOffset);
    pulSrcCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulOriginalImageMemOffset);

    x = pNvCursorInfo->lCursorX;
    y = pNvCursorInfo->lCursorY;

    pjScreenLoc = (PUCHAR)hwDeviceExtension->FrameBufferPtr + y * lScreenStride + x * lScreenPixelDepth;

    for(i = 0; i < pNvCursorInfo->lCursorHeight; i++)
    {
        if( (y+i) < 0 ) continue;

        for(j = 0; j < pNvCursorInfo->lCursorWidth; j++)
        {
            if( (x+j) < 0) continue;
            ulSrcColor = *(i * ulHwCursorWidth + j + pulSrcCursor);
            ulAlpha = (ulSrcColor >> 24);
            if( (!ulAlpha) || (ulAlpha == 0xFF))
            {
                // HW will take care it
                continue;
            }
            else
            {

                // HW is broken;  SW Alpha blending
                ulBgdColor = *(ULONG *)(i * lScreenStride + j * lScreenPixelDepth + pjScreenLoc);

                if(lScreenPixelDepth == 2)
                {
                    // Screen is on 16 BPP mode.
                    ulBgdRed   = (ulBgdColor >> 11) & 0x1F;
                    ulBgdGreen = (ulBgdColor >> 05) & 0x3F;
                    ulBgdBlue  = (ulBgdColor & 0x1F);

                    ulBgdRed   = ulBgdRed  * 0xFF / 0x1F;         // convert to 8 bits format
                    ulBgdGreen = ulBgdGreen  * 0xFF / 0x3F;       // convert to 8 bits format
                    ulBgdBlue  = ulBgdBlue * 0xFF / 0x1F;

                }
                else
                {
                    // Screen is on 32 BPP mode
                    ulBgdRed   = (ulBgdColor >> 16) & 0xFF;
                    ulBgdGreen = (ulBgdColor >> 8) & 0xFF;
                    ulBgdBlue  = (ulBgdColor & 0xFF);
                }

                ulSrcRed   = (ulSrcColor >> 16) & 0xFF;
                ulSrcGreen = (ulSrcColor >> 8) & 0xFF;
                ulSrcBlue  = (ulSrcColor & 0xFF);

                ulSrcRed    = ulSrcRed   + (((255 - ulAlpha) * ulBgdRed + 128) >> 8) ;
                ulSrcRed   &= 0xFF;

                ulSrcGreen  = ulSrcGreen + (((255 - ulAlpha) * ulBgdGreen + 128) >> 8);
                ulSrcGreen &= 0xFF;

                ulSrcBlue   = ulSrcBlue  + (((255 - ulAlpha) * ulBgdBlue + 128) >> 8);
                ulSrcBlue  &= 0xFF;

                ulDstColor =  (0xFF000000) | (ulSrcRed << 16) | (ulSrcGreen << 8) | ulSrcBlue;

                *(i * ulHwCursorWidth + j + pulDstCursor) = ulDstColor;
            }
        }
    }

}




#ifdef NVPE
//******************************************************************************
//
// Function: NVRegistryCallbackPnpId()
//
// Routine Description: callback function used to read 'pnpid' strings from
//                      registry
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS NVRegistryCallbackPnpId(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        return (NO_ERROR);

    VideoPortMoveMemory(Context, ValueData, ValueLength);

    return(NO_ERROR);

} // end NVRegistryCallbackPnpId()

#endif


//
// Detects the number of heads present and reads in the EDID for each head.
// bBootTime: If TRUE, sets safe default masks.
//

BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime)
{
    ULONG Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    LONG i, numChildren;
    ULONG ulConnectedDeviceMask;
    NVTWINVIEWDATA TwinViewData;
    VP_STATUS Status;
    PVOID ptr;

    VideoDebugPrint((2, "INVInitialize_DacsAndEDID():\n"));

    if (bBootTime)
        HwDeviceExtension->bNeedRetrieveEDID = FALSE;
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;

    // Get the bitmask for all the connectors in the system.
    pInfo->ulAllDeviceMask = BITMASK_INVALID_DEVICE;
    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &pInfo->ulAllDeviceMask);
    VideoDebugPrint((1,"ulAllDeviceMask: 0x%x\n",pInfo->ulAllDeviceMask));

    // Get the connect status for all the connectors.
    pInfo->ulConnectedDeviceMask = pInfo->ulAllDeviceMask;
    ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

    if (RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &pInfo->ulConnectedDeviceMask, 
                            sizeof(pInfo->ulConnectedDeviceMask)))
    {
        // success.
        VideoDebugPrint((1,"ulConnectedDeviceMask: 0x%x\n",pInfo->ulConnectedDeviceMask));
        if (pInfo->ulConnectedDeviceMask == 0)
        {
            VideoDebugPrint((0,"Oops! ConnectedDevicemask is 0. Assume a CRT\n"));
            pInfo->ulConnectedDeviceMask = 0x1;

        }
        ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    }
    else
    {
        // The resman had issues with our request, so spew a warning
        VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
    }


    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &pInfo->ulNumberDacsOnBoard))
    {
        VideoDebugPrint((0,"Ooops! RmConfigGetKernel() failed for NV_CFG_NUMBER_OF_HEADS\n"));
        bRet = FALSE;
    }
    else
    {
        if (pInfo->ulNumberDacsOnBoard == 1)
        {
            pInfo->ulNumberDacsConnected = 1;
            if (bBootTime) 
            {
                SetSafeDeviceMasks_SingleHeadBoard(HwDeviceExtension);
            }
        }
        if (pInfo->ulNumberDacsOnBoard == 2)
        {
            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) == 1)
            {
                pInfo->ulNumberDacsConnected = 1;
            }
            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
            {
                pInfo->ulNumberDacsConnected = 2;
            }
            if (bBootTime)
            {
                SetSafeDeviceMasks_DualHeadBoard(HwDeviceExtension);
                InitFromTwinViewInfo(HwDeviceExtension);
            }
        }
        HandleBIOSHeads(HwDeviceExtension);

        // Print the info collected
        VideoDebugPrint((1,"DacsOnBoard: %d, DacsConnected: %d, AllDeviceMask: 0x%x, ConnectedDeviceMask: 0x%x,\n",
                 pInfo->ulNumberDacsOnBoard, pInfo->ulNumberDacsConnected,pInfo->ulAllDeviceMask,  pInfo->ulConnectedDeviceMask));
    } 


    VideoDebugPrint((2,"Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
        pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

    numChildren = ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask);
    ptr = ExAllocatePool(PagedPool, sizeof(EDID_COLLECTION)+sizeof(EDID_UNIT)*(numChildren+1));
    if (ptr == NULL)
    {
        return FALSE;
    }
    if (HwDeviceExtension->EdidCollection)
    {
        ExFreePool(HwDeviceExtension->EdidCollection);
        HwDeviceExtension->EdidCollection = NULL;
    }
    HwDeviceExtension->EdidCollection = (LPEDID_COLLECTION)ptr;
    VideoPortZeroMemory(HwDeviceExtension->EdidCollection, sizeof(EDID_COLLECTION)+sizeof(EDID_UNIT)*(numChildren+1));
    //
    // By default, all HeadMaps points to a dummy EdidUnit, which is the last one EdidUnits array
    // It's also why we allocate one more EdidUnit
    //
    for (i = 0; i < NV_NO_CONNECTORS; i++)
    {
        HwDeviceExtension->EdidCollection->HeadMaps[i] = &(HwDeviceExtension->EdidCollection->EdidUnits[numChildren]);
    }

    //
    // Now read the EDID for all the connected devices.
    // Get the EDID buffer from the RM always.
    //
    numChildren = 0;
    for (i = 0; i < NV_NO_CONNECTORS; i++)
    {
        ULONG ulDeviceMask;
        ulDeviceMask = (1 << i);

        // See if this device is connected
        if (ulConnectedDeviceMask & ulDeviceMask)
        {
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS EdidParams;
            LPEDID_UNIT pEdidUnit = &HwDeviceExtension->EdidCollection->EdidUnits[numChildren];
            ULONG EdidBufferSize          = EDID_V2_SIZE;

            EdidParams.displayMap   = ulDeviceMask;
            EdidParams.edidBuffer   = (UCHAR *) &(pEdidUnit->EDIDBuffer[0]);
            EdidParams.bufferLength = &EdidBufferSize;

            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_LOGICAL_DEV_EDID, &EdidParams, sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS) ))
            {
                VideoDebugPrint((1, "RmConfigGetExKernel() returned error for NV_CFGEX_GET_LOGICAL_DEV_EDID for DeviceMask: 0x%x\n",ulDeviceMask));
                // Reset all the data fields.
                VideoPortZeroMemory(pEdidUnit, sizeof(EDID_UNIT));
            }
            else
            {
                pEdidUnit->Valid = 1;
                pEdidUnit->Size  = EdidBufferSize;
            }
            HwDeviceExtension->EdidCollection->HeadMaps[i] = &(HwDeviceExtension->EdidCollection->EdidUnits[numChildren]);
            numChildren++;
        }
    }

    // Now read the TwinViewInfo registry structure. If it is invalid with the current configuration,
    // Invalidate it. For example, the user might have done a output device switch to TV, shut down the system,
    // reboot without the TV.
    Status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &TwinViewData);
    if (Status == NO_ERROR)
    {
        // Check to see if the data is valid.
        if (!TwinViewDataOK(HwDeviceExtension, &TwinViewData))
        {
            // Invalidate the registry data.
            InvalidateTwinViewData(HwDeviceExtension, &TwinViewData);
        }
    }

#if (_WIN32_WINNT >= 0x0500)
    if (HwDeviceExtension->pDualViewAssociatedDE)
        HwDeviceExtension->pDualViewAssociatedDE->EdidCollection  = HwDeviceExtension->EdidCollection;
#endif

    return(TRUE);
}




//
// Returns TRUE if the device list is successfully scanned
//
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    // The FALSE indicates it is not a boottime operation.
    NVInitialize_DacsAndEDID(HwDeviceExtension, FALSE);
    return(TRUE);
} // End function bScanHeadDeviceOptions()



//
// This function should be called once at boot time.
// It initializes the DeskTopInfo structure to safe values.
//
BOOLEAN NVOneTimeInit_TwinView(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i, Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    VP_STATUS status;
    ULONG ulValue;
    
    VideoDebugPrint((2, "NVOneTimeInit_TwinView():\n"));

    //
    // If we don't create the events, NVSVC can not open the events and will keep spitting out debug messages.
    // Just creating the events is harmless even if the NVSVC is never installed or started.
    //
    InitNVSVCEvents();
    HwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;

    //
    // We are booting up the system. So no modeset has happended yet.
    // The display driver needs to know this because on Mobile systems, we need to
    // honor the BIOS's output device selections at boot time.
    //
    HwDeviceExtension->SystemModeSetHasOccurred = 0;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &HwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));

    //
    // Per Terry, blindly create "NvCplSetAtStartup" with a value of 0xFFFFFFFF at boot time. This will be
    // used and managed by the control panel.
    //
    ulValue = 0xFFFFFFFF;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"NvCplSetAtStartup",
                                      &ulValue,
                                      sizeof(ULONG));
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulDesktopModeIndex = 0;

    pInfo->ulDesktopMode = 0;
    //
    // Initialize the state to Standard mode. This will be changed to clone mode only in the case of 
    // 'UseHwSelectedDevice' (i.e. laptops) being on and the BIOSDeviceMask indicating two devices.
    //
    pInfo->ulTwinView_State = NVTWINVIEW_STATE_NORMAL;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;
    pInfo->ulNumberDacsActive = 1;
    pInfo->ulAllDeviceMask = BITMASK_CRT0;
    pInfo->ulConnectedDeviceMask = BITMASK_CRT0;

    pInfo->ulDesktopWidth = 640;
    pInfo->ulDesktopHeight = 480;

    for(i = 0; i < NV_NO_DACS; i++)
    {
        pInfo->ulDisplayWidth[i] = 640;
        pInfo->ulDisplayHeight[i] = 480;
        pInfo->ulDisplayRefresh[i] = 60;
        pInfo->ulDisplayPixelDepth[i] = 8;
        pInfo->ulDeviceDisplay[i] = i;
        pInfo->ulDeviceMask[i] = BITMASK_CRT0;
        pInfo->ulDeviceType[i] = MONITOR_TYPE_VGA;
        pInfo->ulTVFormat[i] = 0;
    }

    HwDeviceExtension->ulUniquenessVGA = 0;
    HwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;
    HwDeviceExtension->ulInduceModeChangeDeviceMask = 0;

    return(bRet);
}


//
// Returns the number and list of physical modes for the specified head.
// The following filters are applied
// 1. PixelClockFrequency of the specified head. Note if ulHead is 1 and ulDeviceType is CRT, then the 
//  pixelFreq of Head1 (150MHZ) is used. For other device types (DFP,TV) the head0's (350MHZ) pixel freq is used.
// 2. If a MonitorModeList is found, use this list (after filtering against the pixelFreq) and Return.
// 3. If ulEnableDDC is enabled, then parse the EDID for this to get the modes.
//
BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize)
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    MODE_ENTRY *MonitorModeList, *VirtualModeList;
    ULONG NumMonitorModes, NumVirtualModes, NumValidModes;
    MODE_ENTRY *DestPtr;
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulRet, i, j;
    BOOLEAN bFoundMatchInVirtualList;
    ULONG ulHeadEDID;
    LPEDID_UNIT pEdidUnit;
    ULONG ulDeviceType;
    ULONG ulWidth, ulHeight;

    VideoDebugPrint((3,"Enter GetHeadPhysicalModeList()\n"));

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;
    

    ulHead = pInput->ulHead;
    ulEnableDDC = pInput->ulEnableDDC;
    
    ulHeadEDID =  ConvertDeviceMaskToIndex(pInput->ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulHeadEDID];

    // If the device type is TV, w simply return the virtual mode list with only
    // 640x480 and 800x600 for all color depths at only 60HZ
    // For brooktree871 encoder, add the 1024x768 resolution

    pInput->ulDeviceType = MaskToDeviceType(pInput->ulDeviceMask);

    
    if (pInput->ulDeviceType == MONITOR_TYPE_NTSC || pInput->ulDeviceType == MONITOR_TYPE_PAL)
    {
        DestPtr = pInput->pPhysicalModeList;
        VirtualModeList = pInput->pVirtualModeList;

        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumVirtualModes;

        for (i=0; i < NumVirtualModes; i++)
        {

            if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871)
            {
                if (VirtualModeList->Width > 1024 || VirtualModeList->Height > 768 || VirtualModeList->RefreshRate != 60)
                { 
                    // Not a valid mode.
                    NumValidModes--;
                    VirtualModeList++;
                    continue;
                }
            }
            else if (VirtualModeList->Width > 800 || VirtualModeList->Height > 600 || VirtualModeList->RefreshRate != 60)
            {
                // Not a valid mode.
                NumValidModes--;
                VirtualModeList++;
                continue;
            }

            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *VirtualModeList++;
            }
            else
            {
                VirtualModeList++;
            }
            
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        return(TRUE);
    }

    // Set up the generic fields required for the FindModeEntry() call.
    //
    // Check if CRT is connected for second head. Only then should we
    // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
    // DAC 0 for both heads.
    //
    ulFrequencyHead = ulHead;
    if (ulHead == 1 && pInput->ulDeviceType != MONITOR_TYPE_VGA) {
         ulFrequencyHead = 0;
    }
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = ulHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    
    // Read in the monitor restriction mode lists for each head.
    ReadMonitorRestrictionModeList(HwDeviceExtension);

    
    // use the right monitor mode list entry for this head.
    switch (ulHead)
    {
        case 0:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
        case 1:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable1[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes1;
            break;
        default:
            VideoDebugPrint((1,"Oops! Invalid Head: 0x%x\n",ulHead));
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
    }

    
 
    // If the monitor mode list is present, then we simply return this mode list for this head.
    // We do not bother about EDID for this case.
    if (NumMonitorModes != 0)
    {
        DestPtr = pInput->pPhysicalModeList;
        
        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumMonitorModes;

        lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
        lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pInput->ulDeviceMask);
        lpModeDesc->MIDevData.cFormat   = (CHAR)pInput->ulTVType;
        lpModeDesc->MIDevData.cReserved = 0x0;

        EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        for (i=0; i < NumMonitorModes; i++)
        {
            VirtualModeList = pInput->pVirtualModeList;
            bFoundMatchInVirtualList = FALSE;
            // First validate against the virtual mode list.

            for (j=0; j < NumVirtualModes; j++)
            {
                if (VirtualModeList->Width == MonitorModeList->Width &&
                    VirtualModeList->Height == MonitorModeList->Height &&
                    VirtualModeList->Depth == MonitorModeList->Depth &&
                    VirtualModeList->RefreshRate == MonitorModeList->RefreshRate &&
                    MonitorModeList->ValidMode)
                {
                    bFoundMatchInVirtualList = TRUE;
                    break;
                }
                VirtualModeList++;

            }
            // If we did not find a match for this specified mode in the virtual mode list, this mode is not valid.
            if (bFoundMatchInVirtualList == FALSE)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }

            // Now validate against the pixel frequency of the head.
            lpModeDesc->dwXRes = MonitorModeList->Width;
            lpModeDesc->dwYRes = MonitorModeList->Height;
            lpModeDesc->dwBpp = MonitorModeList->Depth;
            lpModeDesc->dwRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwOriginalRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwDevType = MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
            lpModeDesc->dwTVFormat = pInput->ulTVType;


            // We want to ignore the EDID since we are using the explicit monitor mode list.
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
            // Call the modeset DLL to see if this mode is valid.
            // We are not interested in the mode timings but just to see if this is a valid mode.
            VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

            ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                                  lpModeDesc, lpModeOut, lpModeNew);
            VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
            VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
            VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

            if (ulRet != 0)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }
            
            if((pInput->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
            {
                ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
                ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
                if ((VirtualModeList->Width > ulWidth) && (VirtualModeList->Height > ulHeight))
                { 
                    // Not a valid mode.
                    NumValidModes--;
                    VirtualModeList++;
                    continue;
                }
            }

            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *MonitorModeList++;
            }
            else
            {
                MonitorModeList++;
            }
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        return(TRUE);
    }

    //
    // There is no specified monitor mode list for this head.
    // Now see if we need to parse the EDID.
    //
    if (pInput->ulEnableDDC)
    {
        // There is no monitor mode list for this head and DDC is enabled by the user for this head.
        // So we need to filter against pixel clock freq and EDID.
        if (pEdidUnit->Valid)
        {
            lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
        }
        else
        {
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        }
    }
    else
    {
        // There is no monitor mode list for this head and DDC is disabled by the user for this head.
        // So we need to filter against pixel clock freq only.
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        // BUGBUG: I am assuming that just setting the UNKNOWN_DEVICE is sufficient while still passing
        // in the EDID and EDIDSize into FindModeEntry().
    }
    // The user does not want EDID detection for this head.
    // We need to only do the filtering of all virtual list modes against the pixel clock.

    DestPtr = pInput->pPhysicalModeList;
    VirtualModeList = pInput->pVirtualModeList;

    NumVirtualModes = pInput->ulNumVirtualModes;
    NumValidModes = NumVirtualModes;
    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pInput->ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)pInput->ulTVType; 
    lpModeDesc->MIDevData.cReserved = 0x0;

    for (i=0; i < NumVirtualModes; i++)
    {

        // Now validate against the pixel frequency of the head.
        lpModeDesc->dwXRes = VirtualModeList->Width;
        lpModeDesc->dwYRes = VirtualModeList->Height;
        lpModeDesc->dwBpp  = VirtualModeList->Depth;
        lpModeDesc->dwRefreshRate   = VirtualModeList->RefreshRate;
        lpModeDesc->dwOriginalRefreshRate = VirtualModeList->RefreshRate;
        lpModeDesc->dwDevType       = MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
        lpModeDesc->dwTVFormat      = pInput->ulTVType;


        // Call the modeset DLL to see if this mode is valid.
        // We are not interested in the mode timings but just to see if this is a valid mode.
        VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

        ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                              lpModeDesc, lpModeOut, lpModeNew);
        VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
        VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
            lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
            lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

        if (ulRet != 0)
        {
            // Not a valid mode.
            NumValidModes--;
            VirtualModeList++;
            continue;
        }

        if((pInput->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
        {
            ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
            ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
            if ((VirtualModeList->Width > ulWidth) && (VirtualModeList->Height > ulHeight))
            { 
                // Not a valid mode.
                NumValidModes--;
                VirtualModeList++;
                continue;
            }
        }

        // The mode passes all filters.
        // Copy this valid mode and process the next mode from the monitor modelist.
        if (DestPtr)
        {
            *DestPtr++ = *VirtualModeList++;
        }
        else
        {
            VirtualModeList++;
        }
    }
    *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    return(TRUE);
 
}



//
// This function initializes the mapping layer between Win2K's power states and nVidia's power states
//
VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    BOOL bRet;
    ULONG Caps, ulHead;
    ULONG HighestNVAdapterState, i;
    TOSHIBA_HOTKEY_MODE ToshibaHotKeyMode;
    VP_STATUS status;
    ULONG ModeSetInitiated;
    ULONG InduceModeChange;
    ULONG ResumingFromAdapterPowerDownState;
    ULONG PrevDevMask;

    ulHead = 0;

    
    //
    // Note, at this point in time, it does not matter if we have actually done a modeset to the head or
    // not. Anyways, we support only two states for monitors. Its the capabilities of the adapter we
    // need to get.
    //
    bRet = RmGetPowerCaps(HwDeviceExtension->DeviceReference, ulHead, &Caps);

    //
    // Initialize the monitor power states
    //
    for (i=0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; i++ )
    {
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOn] = NV_POWER_MONITOR_STATE_0;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerStandBy] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerSuspend] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOff] = NV_POWER_MONITOR_STATE_1;            
        //
        // If the RM exports an explicit monitor HIBERNATE state, we use that explicit state.
        // This explicit state would leave the monitor in an On state.
        // Otherwise, we map Hibernate to the Off state. Note that Win2K dictates that we use On state for
        // hibernate.
        //
        if (Caps & NV_POWER_MONITOR_STATE_HIBERNATE)
        {
            HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerHibernate] = NV_POWER_MONITOR_STATE_HIBERNATE;
        }
        else
        {
            HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerHibernate] = NV_POWER_MONITOR_STATE_1;            
        }
    }

    //
    // Search for the highest supported adapter power state
    //
    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_1) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the desktop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_1;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_3;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_3;            
        //
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature. If the RM exports an explicit HIBERNATE state,
        // then we use that explicit state.
        // This explicit state would leave the adaptor in an On state but does the save/restore.
        // Note that Win2K dictates that we use On state for hibernate.
        //
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            if (Caps & NV_POWER_ADAPTER_STATE_HIBERNATE)
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_HIBERNATE;
            }
            else
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
            }
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
     }

    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_2) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the laptop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_2;            
        //
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature. If the RM exports an explicit HIBERNATE state,
        // then we use that explicit state.
        // This explicit state would leave the adaptor in an On state but does the save/restore.
        // Note that Win2K dictates that we use On state for hibernate.
        //
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            if (Caps & NV_POWER_ADAPTER_STATE_HIBERNATE)
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_HIBERNATE;
            }
            else
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
            }
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
     }

    // Hotkey Initialization.
    HwDeviceExtension->ulHotKeyPending = 0;
    ToshibaHotKeyMode.ValidMode = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ForceGDIMode",
                                            FALSE,
                                            NVReadRegistryBinaryCallback,
                                            (PVOID)&ToshibaHotKeyMode);
    if (status == NO_ERROR)
    {
        if (ToshibaHotKeyMode.ValidMode == 1)
        {
            // Invalidate it. This may happen as a rare pathological condition.
            // For example, the user has hit the hotkey function, miniport has written the 'ToshibaHotKeyMode'
            // registry entry, but before the DrvEnablePdev or DrvAssertMode(TRUE) is called, system is rebooted.
            ToshibaHotKeyMode.ValidMode = 0;
            status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                    L"ForceGDIMode",
                                                    &ToshibaHotKeyMode,
                                                    sizeof(TOSHIBA_HOTKEY_MODE));
        }

    }

    // if the ModeSetInitiated registry key exists, set it to zero.
    ModeSetInitiated = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"NVCplInduceModeSetInitiated",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ModeSetInitiated));
    if (status == NO_ERROR)
    {
        ModeSetInitiated = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"NVCplInduceModeSetInitiated",
                                                &ModeSetInitiated,
                                                sizeof(ULONG));
    }

    // if the InduceModeChange registry key exists, set it to zero.
    InduceModeChange = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"InduceModeChange",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(InduceModeChange));
    if (status == NO_ERROR)
    {
        InduceModeChange = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"InduceModeChange",
                                                &InduceModeChange,
                                                sizeof(ULONG));
    }

    // if the ResumingFromAdapterPowerDownState registry key exists, set it to zero.
    ResumingFromAdapterPowerDownState = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ResumingFromAdapterPowerDownState",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ResumingFromAdapterPowerDownState));
    if (status == NO_ERROR)
    {
        ResumingFromAdapterPowerDownState = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"ResumingFromAdapterPowerDownState",
                                                &(ResumingFromAdapterPowerDownState),
                                                sizeof(ULONG));
    }

    // if the PrevDevMask registry key exists, set it to zero.
    PrevDevMask = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"PrevDevMask",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(PrevDevMask));
    if (status == NO_ERROR)
    {
        PrevDevMask = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"PrevDevMask",
                                                &(PrevDevMask),
                                                sizeof(ULONG));
    }

}

//
// Returns the index from the device mask.
// Input: A 32bit bitmask with only one of the 32bits set specifying a unique device
// Return Value: Index of this bitmask
//      For example: 
//      input: 0x4, Return: 2
//      input: 0x20, Return: 5
//      input: 0x1, Return: 0
//      input: 0x0, Return: 0
//
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask)
{
    ULONG i;
    ULONG ulTmp;
    ulTmp = ulDeviceMask;

  
    i=0;
    for (;;)
    {
        if (ulTmp == 0)
        {
            VideoDebugPrint((1,"Oops! ConvertDeviceMaskToIndex(): Invalid ulDeviceMask: 0x%x\n",ulDeviceMask));
            return(0);
        }
        if (ulTmp & 0x1)
        {
            return(i);
        }
        // shift right by one and increment the index
        ulTmp >>= 1;
        i++;
    }
    
}

//
// Returns the number of bits that are set in the mask.
// 
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask)
{
    ULONG i, NumDevices, ulDeviceMask;
    NumDevices = 0;
    for(i=0; i < NV_NO_CONNECTORS; i++)
    {
        ulDeviceMask = (1 << i);
        if(ulConnectedDeviceMask & ulDeviceMask)
        {
            NumDevices++;
        }
    }
    return(NumDevices);

}

//
// Sets some safe default device masks in the hwdeviceExtension based on the current config returned by the miniport.
// Later we will read the TwinViewInfo registry data to see if should use the device masks specified in the registry
//
static VOID SetSafeDeviceMasks_SingleHeadBoard( PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i;
    NV_DESKTOP_INFO * pInfo;
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    
    pInfo->ulDeviceMask[0] = LOWESTBIT(pInfo->ulConnectedDeviceMask);
    if (pInfo->ulDeviceMask[0])
    {
        return;
    }

    // Something wrong. No devices are connected. So use a default CRT0.
    VideoDebugPrint((0,"Oops!  SetSafeDeviceMasks(): No devices connected. So assume CRT0"));
    pInfo->ulDeviceMask[0] = BITMASK_CRT0;
    return;
}

//
// We need to set up a safe standard mode device mask and deviceDisplay mapping array. This is needed for the special 
// case of the first time boot after driver install since there will no TwinViewInfo structure present after a 
// driver install.
// Later we will read the TwinViewInfo registry data to see if should use the device masks specified in the registry.
//
static VOID SetSafeDeviceMasks_DualHeadBoard( PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i;
    ULONG DeviceMask;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG status;
    NV_DESKTOP_INFO * pInfo;

    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;

    for (i = 0; i < NV_NO_DACS; i++)
    {
        pInfo->ulDeviceMask[i] = BITMASK_INVALID_DEVICE;
    }


    if (pInfo->ulNumberDacsConnected == 0)
    {
        VideoDebugPrint((0,"Oops!  SetSafeDeviceMasks(): No devices connected. So assume CRT0\n"));
        pInfo->ulDeviceMask[0] = BITMASK_CRT0;
        pInfo->ulConnectedDeviceMask = BITMASK_CRT0;
        pInfo->ulNumberDacsConnected = 1;
        return;
    }

    if (pInfo->ulNumberDacsConnected == 1 || pInfo->ulNumberDacsConnected == 2)
    {
        for (i = 0; i < NV_NO_CONNECTORS; i++)
        {
            if (pInfo->ulConnectedDeviceMask & (1 << i))
            {
                DeviceMask = (1 << i);
                // Ask ResMan what head to use.
                nvConfig.DevicesConfig = DeviceMask;
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;

                
                if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
                {

                    VideoDebugPrint((0, "SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
                }
                else
                {
                    if (nvConfig.DevicesAllocationMap > 1)
                    {
                        VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
                    }
                    if (nvConfig.DevicesAllocationMap == 0)
                    {
                        pInfo->ulDeviceMask[0] = DeviceMask;
                        pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        pInfo->ulDeviceDisplay[0] = 0;
                        pInfo->ulDeviceDisplay[1] = 1;
                    }
                    if (nvConfig.DevicesAllocationMap == 1)
                    {
                        pInfo->ulDeviceMask[1] = DeviceMask;
                        pInfo->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                        pInfo->ulDeviceDisplay[0] = 1;
                        pInfo->ulDeviceDisplay[1] = 0;
                    }

                }
                return;
            }
        }
        return;
    }

}// end of SetSafeDeviceMasks_DualHeadBoard()

//
// Input: bitmask for a single device
// Return: device type of this device as expected by the display driver and the control panel.
//
ULONG MaskToDeviceType( ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = MONITOR_TYPE_VGA; 
    else if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = MONITOR_TYPE_FLAT_PANEL;
    else if (ulDeviceMask & BITMASK_ALL_TV) ulRet = MONITOR_TYPE_NTSC; 
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}

//
// Input: bitmask for a single device
// Return: device type of this device as expected by the common modeset code and FindModeEntry().
//
ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = DEVTYPE_CRT; 
    else if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = DEVTYPE_DFP;
    else if (ulDeviceMask & BITMASK_ALL_TV) ulRet = DEVTYPE_TV; 
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}

//
// Input: bitmask for a single device
// Return: TV Format of this device. Currently returns only NTSC_M format
//
ULONG MaskToTVFormat( ULONG ulDeviceMask)
{
    return(NTSC_M);
}

//
// If the system is a desktop, this routine does nothing.
// If the system is a laptop, we should use the output deive posted by the BIOS for the desktop.
// We honor the BIOS output only at boot time.
// BUGBUG: Currently this function only handles a single output device posted by the BIOS.
// The code does not yet support when the BIOS posts to two devices (sort of BIOS clone mode).
// We follow the following Kevin K's specs for laptops:
//      If a single bit is enabled, that should be the primary boot device.  
//      If more than one bit is enabled, and Windows was previously in standard or clone mode,
//          the driver should enter clone mode with the associated devices.  I would give priority
//          (what gets chosen as the primary) to the LCD, CRT, then TV (in that order if bit enabled).
//      If more than one bit is enabled, and Windows was previously in extended mode,
//          the driver should remain in extended mode with the associated devices.  I would give
//          priority (what gets chosen as the primary) to the LCD, CRT, then TV (in that order if bit enabled).
//
//
VOID HandleBIOSHeads(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulHead;
    ULONG Status, RetSize;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;

    NV_DESKTOP_INFO * pInfo;
    NV_DESKTOP_INFO sOri;
    ULONG DeviceMask[NV_NO_DACS] = {0, 0};
    ULONG i, status;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHeadData;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHead0, * pHead1;
    ULONG TwinViewDataPresent;
    ULONG Width, Height, Depth, Refresh;
    ULONG ulPrimaryHead;
    ULONG SwapHeadMapping;
    ULONG ulTmp;
    

    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    
    // Save this structure off for later use.
    sOri = *pInfo;
    
    //
    // Initialize the registry keys to zero.
    //
    HwDeviceExtension->Mobile = 0;
    HwDeviceExtension->UseHWSelectedDevice = 0;
    HwDeviceExtension->GDIModePruning = 0;
    HwDeviceExtension->UseHotKeySameMode = 0;
    HwDeviceExtension->PanScanSelection = 0;
    HwDeviceExtension->EnableModesetStopImage = 0;
    HwDeviceExtension->EnumerateTVAsACPIDevice = 0;

    // Read the registry entry "Mobile" to see if we are on a desktop or laptop.
    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Mobile",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->Mobile));
    VideoDebugPrint((3,"HwDeviceExtension->Mobile registry value: 0x%x\n",HwDeviceExtension->Mobile));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"UseHWSelectedDevice",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->UseHWSelectedDevice));
    VideoDebugPrint((3,"HwDeviceExtension->UseHWSelectedDevice registry value: 0x%x\n",HwDeviceExtension->UseHWSelectedDevice));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"GDIModePruning",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->GDIModePruning));
    VideoDebugPrint((3,"HwDeviceExtension->GDIModePruning registry value: 0x%x\n",HwDeviceExtension->GDIModePruning));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"UseHotKeySameMode",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->UseHotKeySameMode));
    VideoDebugPrint((3,"HwDeviceExtension->UseHotKeySameMode registry value: 0x%x\n",HwDeviceExtension->UseHotKeySameMode));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"PanScanSelection",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->PanScanSelection));
    VideoDebugPrint((3,"HwDeviceExtension->PanScanSelection registry value: 0x%x\n",HwDeviceExtension->PanScanSelection));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"EnableModesetStopImage",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->EnableModesetStopImage));
    VideoDebugPrint((3,"HwDeviceExtension->EnableModesetStopImage registry value: 0x%x\n",HwDeviceExtension->EnableModesetStopImage));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"EnumerateTVAsACPIDevice",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->EnumerateTVAsACPIDevice));
    VideoDebugPrint((3,"HwDeviceExtension->EnumerateTVAsACPIDevice registry value: 0x%x\n",HwDeviceExtension->EnumerateTVAsACPIDevice));


    if (HwDeviceExtension->UseHWSelectedDevice)
    {
        ULONG BIOSDeviceMask;
        // We are on a laptop (either dell or toshiba).
        // So we should use the same devices that the BIOS used for the desktop.
        // We honor the BIOS's selections only at boot time.
        if (HwDeviceExtension->SystemModeSetHasOccurred)
        {
            // A high res modeset has already occurred. So don't bother about the BIOS
            return;
           
        }
        
        // Read the twinviewinfo data from the registry if it is present.
        TwinViewDataPresent = 0;
        status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData);
        if (status == NO_ERROR)
        {
            if (TwinViewDataOK(HwDeviceExtension, &sData))
            {
                TwinViewDataPresent = 1;
            }
        }
                


        if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference,
                                  NV_CFG_GET_BOOT_DEVICES, &BIOSDeviceMask))
        {
            VideoDebugPrint((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed\n"));
        }

        VideoDebugPrint((1,"BIOSDeviceMask returned by ResMan: 0x%x\n",BIOSDeviceMask));

        // see if the BIOS had posted on a single device or two devices.
        if (ConvertConnectedMaskToNumDevices(BIOSDeviceMask) == 1)
        {
            // BIOS posted on a single device.
            if (TwinViewDataPresent == 0)
            {
                ulHead = pInfo->ulDeviceDisplay[0];
                if (pInfo->ulDeviceMask[ulHead] == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }

            // Ask ResMan for which head to use.
            // Ask ResMan what head to use.
            nvConfig.DevicesConfig = BIOSDeviceMask;
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                                     NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
            {

                VideoDebugPrint((0, "SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
            }
            else
            {
                if (nvConfig.DevicesAllocationMap > 1)
                {
                    VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
                }
                if (nvConfig.DevicesAllocationMap == 0)
                {
                    pInfo->ulDeviceMask[0] = BIOSDeviceMask;
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    pInfo->ulDeviceDisplay[0] = 0;
                    pInfo->ulDeviceDisplay[1] = 1;
                }
                if (nvConfig.DevicesAllocationMap == 1)
                {
                    pInfo->ulDeviceMask[1] = BIOSDeviceMask;
                    pInfo->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                    pInfo->ulDeviceDisplay[0] = 1;
                    pInfo->ulDeviceDisplay[1] = 0;
                }
            }

            if (TwinViewDataPresent)
            {
                ulHead = sData.dwDeviceDisplay[0];
                if ((sData.dwState == NVTWINVIEW_STATE_NORMAL || sData.dwState == NVTWINVIEW_STATE_DUALVIEW) && 
                    sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask == BIOSDeviceMask)
                {
                    // Nothing to do
                    return;
                }
                //
                // If the TwinViewInfo registry exists, we need to patch it to reflect the BIOS.
                // For the single BIOS device, we simply invalidate the registry.
                //
                // This functions also writes the invalidated TwinViewInfo structure to the registry.
                InvalidateTwinViewData(HwDeviceExtension, &sData);
            }
            
        }


        if (ConvertConnectedMaskToNumDevices(BIOSDeviceMask) >= 2)
        {
            // We need to do this only if the connfig has been changed underneath us such as by the
            // user hot-keying around in BIOS mode.
            if (pInfo->ulNumberDacsActive == 2)
            {
                // So we were in clone or multimon mode. Were we using the same BIOS devices?
                if ((pInfo->ulDeviceMask[0] | pInfo->ulDeviceMask[1]) == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }
            if (TwinViewDataPresent && (sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_SPAN))
            {
                // So we were in clone or multimon mode. Were we using the same BIOS devices?
                if ((sData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask | sData.NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask) 
                    == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }


            pInfo->ulDeviceDisplay[0] = 0;
            pInfo->ulDeviceDisplay[1] = 1;

            // Grab the first output device.
            DeviceMask[0] = LOWESTBIT(BIOSDeviceMask);
            DeviceMask[1] = LOWESTBIT(BIOSDeviceMask & ~DeviceMask[0]);

            // Ask ResMan what head to use for the devices.
            nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            status = RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                          NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
            if (status == 0)
            {

                VideoDebugPrint((0, "Oops! SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
                // Set to a safe single head mode.
                pInfo->ulNumberDacsConnected = 1;
                pInfo->ulConnectedDeviceMask = DeviceMask[0];
                pInfo->ulAllDeviceMask = DeviceMask[0];
                pInfo->ulDeviceMask[0] = DeviceMask[0];
                pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
            }
            else
            {
                // We got a successful head assignment for both the devices.
                switch (nvConfig.DevicesAllocationMap)
                {
                case 0x10:
                    // Head assignment 1, 0
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = DeviceMask[1];

                    break;
                case 0x01:
                    // Head assignment 0, 1
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    break;
                }

                for (i=0; i < pInfo->ulNumberDacsConnected; i++)
                {
                    pInfo->ulDeviceType[i] = MaskToDeviceType(pInfo->ulDeviceMask[i]);
                    pInfo->ulTVFormat[i] = MaskToTVFormat(pInfo->ulDeviceMask[i]);
                }
            }

            //
            // If the TwinViewInfo registry exists, we need to patch it to reflect the BIOS.
            // We patch the following fields.
            // - dwState
            // - dwDeviceDisplay
            // - DeviceMask
            // - DeviceType.
            // Note: We don't need to worry about the desktop resolution here since the DELL or Toshiba logic kicks in
            // DrvGetModes(). For example, on DELL where there is no pan-scan in standard mode, Windows may be in 16x12
            // on CRT Standard mode, the user may hotkey to DFP in BIOS, then Win2K will fall back to 8x6 or 6x4 since DrvGetModes() 
            // will filter out 16x12. TODO: It could be handled more elegantly by figuring out the best-fit mode for this
            // BIOS device and writing it into the ToshibaHotKeyMode registry entry. Later.
            //
            if (TwinViewDataPresent)
            {
                Width = sData.DeskTopRectl.right - sData.DeskTopRectl.left;
                Height = sData.DeskTopRectl.bottom - sData.DeskTopRectl.top;
                ulPrimaryHead = sData.dwDeviceDisplay[0];
                Depth = sData.NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp;
                Refresh = sData.NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwRefresh;
            }
            else
            {

                Width = sOri.ulDesktopWidth;
                Height = sOri.ulDesktopHeight;
                ulPrimaryHead = sOri.ulDeviceDisplay[0];
                Depth = sOri.ulDisplayPixelDepth[ulPrimaryHead];
                Refresh = sOri.ulDisplayRefresh[ulPrimaryHead];
            }


            // Set the desktop resolution.
            sData.DeskTopRectl.left = 0;
            sData.DeskTopRectl.top = 0;
            sData.DeskTopRectl.right = Width;
            sData.DeskTopRectl.bottom = Height;

            
            // If it does not exist or is standard/clone mode, create a full registry entry for clone mode.
            // Lets handle all cases the same for now. Later, we will need to remember the modes per device.
            if (TwinViewDataPresent == 0 || 
               (TwinViewDataPresent == 1 && (sData.dwState == NVTWINVIEW_STATE_NORMAL ||
                                             sData.dwState == NVTWINVIEW_STATE_DUALVIEW ||
                                             sData.dwState == NVTWINVIEW_STATE_CLONE)))
            {
                sData.dwState = NVTWINVIEW_STATE_CLONE;
                sData.dwAllDeviceMask = pInfo->ulAllDeviceMask;
                sData.dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

                for (i=0; i < NV_NO_DACS; i++)
                {
                    sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];

                    pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                    pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                    pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                    pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
                    //
                    // BUGBUG we should really remember the last mode info for each device and use that. Later.
                    //
                    pHeadData->dwBpp = Depth;
                    pHeadData->dwRefresh = Refresh;
                    pHeadData->VirtualRectl.left = 0;
                    pHeadData->VirtualRectl.top = 0;
                    pHeadData->VirtualRectl.right = Width;
                    pHeadData->VirtualRectl.bottom = Height;
                    pHeadData->PhysicalRectl.left = 0;
                    pHeadData->PhysicalRectl.top = 0;
                    pHeadData->PhysicalRectl.right = Width;
                    pHeadData->PhysicalRectl.bottom = Height;
                }
            }

            // Handle the special case of when windows is in spanning mode and BIOS is in clone mode.
            // Per Kevin's specs we need to put windows into spanning mode with the BIOS heads.
            if (TwinViewDataPresent == 1 && sData.dwState == NVTWINVIEW_STATE_SPAN)
            {
                sData.dwAllDeviceMask = pInfo->ulAllDeviceMask;
                sData.dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

                for (i=0; i < NV_NO_DACS; i++)
                {
                    sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];
                    pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                    pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                    pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                    pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
                }
            }

            // Now we have chosen wither clone or span mode.
            // Always make LCD/CRT the primary in that order.
            // We change the dvice mapping array to reflect that.
            ChoosePrimaryDevice(HwDeviceExtension, &sData);

            // Now write the TwinViewInfo to registry.
            NVSetRegistryTwinviewInfo(HwDeviceExtension, &sData);
        }
    }

    return;
}


VOID HandleDualviewHeads(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bEnableDualView)
{
#if (_WIN32_WINNT >= 0x0500)
    ULONG ulHead;
    ULONG i, Status, TwinViewDataPresent = 0;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;

    NV_DESKTOP_INFO *pInfo, *pInfo2;
    ULONG DeviceMask[NV_NO_DACS] = {0, 0}, SecondHeadMask;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA  *pHeadData;
    ULONG ulConnectedDeviceMask;

    //
    // If Dualview, use ResMan default head setting
    //
    if (HwDeviceExtension->pDualViewAssociatedDE)
    {
        pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
        pInfo2 = (NV_DESKTOP_INFO *) &HwDeviceExtension->pDualViewAssociatedDE->DeskTopInfo;
    
        // Read the twinviewinfo data from the registry if it is present.
        VideoPortZeroMemory(&sData, sizeof(sData));
        if (NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData) == NO_ERROR)
        {
            if (TwinViewDataOK(HwDeviceExtension, &sData))
            {
                TwinViewDataPresent = 1;
            }
            else
            {
                VideoPortZeroMemory(&sData, sizeof(sData));
            }
        }

        if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
        {
            DeviceMask[0] = (pInfo->ulConnectedDeviceMask & BITMASK_ALL_DFP);
            if (DeviceMask[0] == 0)
            {
                // A laptop wothout LCD ??????
                ASSERT(FALSE);
                DeviceMask[0] = pInfo->ulAllDeviceMask & BITMASK_ALL_DFP;
                if (DeviceMask[0] == 0)
                    DeviceMask[0] = BITMASK_ALL_DFP;
            }
            DeviceMask[0] = LOWESTBIT(DeviceMask[0]);

            // Continue further and grab the next device.
            DeviceMask[1] = (pInfo->ulConnectedDeviceMask & ~DeviceMask[0]);
            if (DeviceMask[1] == 0)
            {
                // If on laptop, there is no devices other than LCD, force the secondary to be CRT0
                DeviceMask[1] = pInfo->ulAllDeviceMask & (~BITMASK_ALL_DFP);
                if (DeviceMask[1] == 0)
                {
                    ASSERT(FALSE);
                    DeviceMask[1] = BITMASK_CRT0;
                }
            }
            DeviceMask[1] = LOWESTBIT(DeviceMask[1]);

            ulConnectedDeviceMask = DeviceMask[0] | DeviceMask[1];
        }
        else
        {
            ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
            // If on LCD/CRT/TV all exist, pick CLD and CRT
            if ((ulConnectedDeviceMask & BITMASK_ALL_CRT) &&
                (ulConnectedDeviceMask & BITMASK_ALL_TV) &&
                (ulConnectedDeviceMask & BITMASK_ALL_DFP))
                ulConnectedDeviceMask &= ~BITMASK_ALL_TV;
        }

        // Config the heads
        if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
        {
            // Grab the first output device.
            DeviceMask[0] = LOWESTBIT(ulConnectedDeviceMask);
            DeviceMask[1] = LOWESTBIT(ulConnectedDeviceMask & ~DeviceMask[0]);

            // Ask ResMan what head to use for the devices.
            nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            Status = RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                          NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
            if (Status == 0)
            {
                VideoDebugPrint((0, "Oops! HandleDualViewHeads - Cannot get DEVICES_CONFIG value from RM\n"));
                ASSERT(FALSE);
                if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
                {
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                }
                else
                {
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                }
            }
            else
            {
                // We got a successful head assignment for both the devices.
                switch (nvConfig.DevicesAllocationMap)
                {
                case 0x10:
                    // Head assignment 1, 0
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = DeviceMask[1];
                    break;
                case 0x01:
                    // Head assignment 0, 1
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
                    ASSERT(FALSE);
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    break;
                }

                for (i = 0; i < pInfo->ulNumberDacsConnected; i++)
                {
                    pInfo->ulDeviceType[i] = MaskToDeviceType(pInfo->ulDeviceMask[i]);
                    pInfo->ulTVFormat[i] = MaskToTVFormat(pInfo->ulDeviceMask[i]);
                }

                pInfo->ulDeviceDisplay[0] = 0;
                pInfo->ulDeviceDisplay[1] = 1;
                if ((HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) &&
                    (pInfo->ulDeviceMask[1] & BITMASK_ALL_DFP))
                {
                    pInfo->ulDeviceDisplay[0] = 1;
                    pInfo->ulDeviceDisplay[1] = 0;
                }

                VideoDebugPrint((2, "HandleDualviewHeads: ulDeviceMask[]={0x%x,0x%x}\n",
                                 pInfo->ulDeviceMask[0], pInfo->ulDeviceMask[1]));
                VideoDebugPrint((2, "                     ulDeviceDisplay[]={%d,%d}\n",
                                 pInfo->ulDeviceDisplay[0], pInfo->ulDeviceDisplay[1]));
            }

            // Second view reversed the head mapping
            for (i = 0; i < NV_NO_DACS; i++)
            {
                pInfo2->ulDeviceMask[i] = pInfo->ulDeviceMask[i];
                pInfo2->ulDeviceType[i] = pInfo->ulDeviceType[i];
                pInfo2->ulTVFormat[i] = pInfo->ulTVFormat[i];
            }
            sData.dwDeviceDisplay[0] = pInfo2->ulDeviceDisplay[1] = pInfo->ulDeviceDisplay[0];
            sData.dwDeviceDisplay[1] = pInfo2->ulDeviceDisplay[0] = pInfo->ulDeviceDisplay[1];
            sData.dwAllDeviceMask = pInfo2->ulAllDeviceMask = pInfo->ulAllDeviceMask;
            sData.dwConnectedDeviceMask = pInfo2->ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

            if (bEnableDualView)
            {
                pInfo->ulTwinView_State = NVTWINVIEW_STATE_DUALVIEW;
            }
            else
            {
                if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_NORMAL)
                {
                    pInfo->ulTwinView_State = NVTWINVIEW_STATE_NORMAL;
                    // Put secondary head to invalid device for primary view
                    ulHead = pInfo->ulDeviceDisplay[1];
                    pInfo->ulDeviceMask[ulHead] = BITMASK_INVALID_DEVICE;
                }
                else
                    pInfo->ulTwinView_State = sData.dwState;
            }
            sData.dwState = pInfo->ulTwinView_State;

            for (i = 0; i < NV_NO_DACS; i++)
            {
                sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];

                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
            }

            // Now write the TwinViewInfo to registry.
            // Primary view needs to be updated only when Dualview is enabled or TwinViewData state
            // is not Spanning or Clone
            // A scenario would be from Dualview to Spanning mode.
            if (bEnableDualView || !TwinViewDataPresent ||
                sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_NORMAL)
            {
                VideoPortZeroMemory(&sData.DeskTopRectl, sizeof(sData.DeskTopRectl));
                NVSetRegistryTwinviewInfo(HwDeviceExtension, &sData);
            }

            // Second view should always be updated.  It's only reversed head setting from primary view.
            // The state is always DUALVIEW
            pInfo2->ulTwinView_State = sData.dwState = NVTWINVIEW_STATE_DUALVIEW;
            for (i = 0; i < NV_NO_DACS; i++)
            {
                sData.dwDeviceDisplay[i] = pInfo2->ulDeviceDisplay[i];
                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                pHeadData->dwDeviceMask = pInfo2->ulDeviceMask[i];
            }
            VideoPortZeroMemory(&sData.DeskTopRectl, sizeof(sData.DeskTopRectl));
            NVSetRegistryTwinviewInfo(HwDeviceExtension->pDualViewAssociatedDE, &sData);
        }
        else
        {
            // At this point, we know CRT and LCD have to exist
            ASSERT(FALSE);
        }
    }
#endif
}

//
// Returns true if the tinviewData is safe. Otherwise returns FALSE>
//
BOOLEAN TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData)
{
    BOOLEAN bRet = TRUE;
    ULONG i, ulHead, ulDeviceMask;

    if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 && 
        pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)
    {
        
        return(FALSE);
    }

    if (pData->dwState != NVTWINVIEW_STATE_SPAN && pData->dwState != NVTWINVIEW_STATE_CLONE &&
        pData->dwState != NVTWINVIEW_STATE_DUALVIEW && pData->dwState != NVTWINVIEW_STATE_NORMAL) 
    {
       
        return(FALSE);
    }

    if ((pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW) && pData->dwDeviceDisplay[0] > 1)
    {
       
       return(FALSE);
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE)
    {
        if (pData->dwDeviceDisplay[0] > 1 || 
            pData->dwDeviceDisplay[1] > 1 ||
            (pData->dwDeviceDisplay[0] == 0 && pData->dwDeviceDisplay[1] == 0) ||
            (pData->dwDeviceDisplay[0] == 1 && pData->dwDeviceDisplay[1] == 1))
        {
       
            return(FALSE);
        }
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE) 
    {
        if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp != pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp)
        {
       
            return(FALSE);
        }
    }


    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp == 0)
    {
       
        return(FALSE);
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwRefresh == 0)
    {
       
        return(FALSE);
    }
    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.bottom == 0)
    {
       
        return(FALSE);
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.bottom == 0)
    {
       
        return(FALSE);
    }

    // If there is just one head on the board and the registry says any mode other than normal, mark it as invalid.
    if (hwDeviceExtension)
    {

        if (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 1 &&
            (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE))
        {
       
            return(FALSE);
        }
    }

    // Check to see if the user has swapped the board
    if (pData->dwAllDeviceMask != hwDeviceExtension->DeskTopInfo.ulAllDeviceMask)
    {
        return(FALSE);
    }

    // Now check to see if the output device specified in the registry are actually present in this
    // current configuration.
    if (pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW)
    {
        ulHead = pData->dwDeviceDisplay[0];
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
    }
    
    // Check the connected devices for clone/span modes.
    if (pData->dwState == NVTWINVIEW_STATE_CLONE || pData->dwState == NVTWINVIEW_STATE_SPAN)
    {
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
    }
    return(TRUE);
}

//
// Invalidates the twinview data and writes back to the registry. Ideally we would have just wanted to delete
// the TwinViewInfo structure registry entry but we can not delete registry entries from the miniport.
//
VOID InvalidateTwinViewData(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData)
{
    VideoPortZeroMemory(&pData->DeskTopRectl, sizeof(pData->DeskTopRectl));
    
    NVSetRegistryTwinviewInfo(hwDeviceExtension, pData);
    return;
}

//
// Select the primary device correctly.
// For laptops, we want LCD/CRT/TV in that order.
// For desktops, this function does nothing.
// This function updates both the pData and the hwDevExt->DeskTopInfo structures.
//
VOID ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData)
{
    NV_DESKTOP_INFO * pInfo;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHead0, * pHead1;
    ULONG SwapHeadMapping;
    ULONG ulTmp;

    pInfo = &HwDeviceExtension->DeskTopInfo;
    pHead0 = &(pData->NVTWINVIEWUNION.nvtwdevdata[0]);
    pHead1 = &(pData->NVTWINVIEWUNION.nvtwdevdata[1]);

    // Initialize the flag to zero.
    SwapHeadMapping = 0;
    if (pData->dwDeviceDisplay[0] == 0)
    {
        // Head0 is the primary. 
        // Now check the physical head types to make DFP the primary device.
        if ((pHead0->dwDeviceType == MONITOR_TYPE_VGA && pHead1->dwDeviceType == MONITOR_TYPE_FLAT_PANEL) ||
            ((pHead0->dwDeviceType == MONITOR_TYPE_NTSC || pHead0->dwDeviceType == MONITOR_TYPE_PAL) && 
             pHead1->dwDeviceType == MONITOR_TYPE_FLAT_PANEL))
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }

        // Now check the physical head types to make CRT the primary device.
        if ((pHead0->dwDeviceType == MONITOR_TYPE_NTSC || pHead0->dwDeviceType == MONITOR_TYPE_PAL) && 
            pHead1->dwDeviceType == MONITOR_TYPE_VGA)
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }
    }

    if (pData->dwDeviceDisplay[0] == 1)
    {
        // Head1 is the primary. 
        // Now check the physical head types to make DFP the primary device.
        if ((pHead1->dwDeviceType == MONITOR_TYPE_VGA && pHead0->dwDeviceType == MONITOR_TYPE_FLAT_PANEL) ||
            ((pHead1->dwDeviceType == MONITOR_TYPE_NTSC || pHead1->dwDeviceType == MONITOR_TYPE_PAL) && 
             pHead0->dwDeviceType == MONITOR_TYPE_FLAT_PANEL))
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }

        // Now check the physical head types to make CRT the primary device.
        if ((pHead1->dwDeviceType == MONITOR_TYPE_NTSC || pHead1->dwDeviceType == MONITOR_TYPE_PAL) && 
            pHead0->dwDeviceType == MONITOR_TYPE_VGA)
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }
    }

    // Swap the head mapping if we need to
    if (SwapHeadMapping)
    {
        // Swap the registry data
        ulTmp = pData->dwDeviceDisplay[0];
        pData->dwDeviceDisplay[0] = pData->dwDeviceDisplay[1];
        pData->dwDeviceDisplay[1] = ulTmp;

        // Swap the incore data in HwDevExt.
        ulTmp = pInfo->ulDeviceDisplay[0];
        pInfo->ulDeviceDisplay[0] = pInfo->ulDeviceDisplay[1];
        pInfo->ulDeviceDisplay[1] = ulTmp;
    }
}

//
// Verifies if the DFP supports 1400x1050. This is done if the EnablePanScanAl lregistry entry is set.
// This routine should be called after nvInitialize_dacsAndEdid(),InitializeCommonModeSetCode() 
// have been called.
//
VOID Verify1400x1050DFP(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;

    NV_DESKTOP_INFO *pInfo;
    ULONG ulDeviceMask;
    ULONG ulHead, ulIndex, ulRet;
    LPEDID_UNIT pEdidUnit;

    VideoDebugPrint((1,"Verify1400x1050DFP()\n"));

    pInfo = &HwDeviceExtension->DeskTopInfo;
    HwDeviceExtension->ulDFPSupports1400x1050 = 0;

    // Test the conditions to enable this check.
    if ((pInfo->ulConnectedDeviceMask & 0xFF0000) == 0)
    {
        // No DFP in this system, so return.
        return;
    }

    if (HwDeviceExtension->PanScanSelection != PAN_SCAN_SELECTION_ENABLE_ALL)
    {
        // We are not asked to pan scan always. So return.
        return;
    }

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = 1400;
    lpModeDesc->dwYRes = 1050;
    lpModeDesc->dwBpp = 8;
    lpModeDesc->dwRefreshRate = 60;
    lpModeDesc->dwOriginalRefreshRate = 60;

    // DFP goes to physical head 0.
    ulHead = 1;
    ulDeviceMask = 0x10000;
    ulIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
    ulFrequencyHead = 0;

    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    lpDispData->dwCRTCIndex = ulHead;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];

    // Now validate against the pixel frequency of the head.

    lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->dwTVFormat = 0;

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)0;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    // We are not interested in the mode timings but just to see if this is a valid mode.
    VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                     ulDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid));

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                          lpModeDesc, lpModeOut, lpModeNew);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                     lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

    if (ulRet != 0)
    {
        // This mode is not physically supported.
        HwDeviceExtension->ulDFPSupports1400x1050 = 0;
        return;
    }

    // BUGBUG: FindModeEntry returns 0 even if the DFP does not support this mode. Not sure why.
    // So check the lpModeNew also as a backup test.
    if (lpModeNew->dwXRes != lpModeDesc->dwXRes ||
        lpModeNew->dwYRes != lpModeDesc->dwYRes ||
        lpModeNew->dwBpp != lpModeDesc->dwBpp ||
        lpModeNew->dwRefreshRate != lpModeDesc->dwRefreshRate
        )
    {
        // This mode is not physically supported.
        HwDeviceExtension->ulDFPSupports1400x1050 = 0;
        return;
    }


    // This mode is natively supported.
    HwDeviceExtension->ulDFPSupports1400x1050 = 1;
    
    return;
}


//   DetectNextDevice   walks thru the bus (specified indirectly thru pHDE) starting at (*pulPrevDevice + 1) and checks for 
//                      presense of nvidia boards. It returns the Vendos/Device ID of the found board and the slot where it 
//                      is located on the bus (*pulPrevDevice). If bClaimResources is TRUE it also claims the boards memory
//                      access ranges in the registry (using VideoPortGetAccessRanges). As a result it also indicates whether
//                      the board is our primary device (VGA is enabled) or a secondary device in *pbIsPrimaryDevice.
//
VP_STATUS DetectNextDevice( IN      PHW_DEVICE_EXTENSION  pHDE,                     // our devices 'global' data struct
                            IN OUT  ULONG                 *pulPrevDevice,           // in : slot where the last nvidia device was detected (or where the search begins)
                                                                                    // out: slot where the next nvidia device is located                                                                                    
                                                                                    // NOTE: can be 0xffffffff : start looking at dev 0 and must be lower than 32 (5bit)
                            IN      ULONG                 ulNumAccessRanges,        // is needed the to claim the resources, for now it's always 2
                               OUT  PVIDEO_ACCESS_RANGE   pAccessRanges,            // if bClaimResources == TRUE this exports the device's mapping
                               OUT  USHORT                *pusVendorID,             // 
                               OUT  USHORT                *pusDeviceID,             //
                               OUT  BOOLEAN               *pbIsPrimaryDevice,       // 
                            IN      BOOLEAN               bClaimResources)          //
{
    VP_STATUS         status = ERROR_DEV_NOT_EXIST;
    ULONG             ulDevice;
    PCI_SLOT_NUMBER   psnSlot;

    ASSERT(pHDE);
    ASSERT(pulPrevDevice);
    ASSERT((*pulPrevDevice == 0xffffffff) || (*pulPrevDevice < PCI_MAX_DEVICES));
    ASSERT(2 == ulNumAccessRanges);
    ASSERT(pAccessRanges);
    ASSERT(pusVendorID);
    ASSERT(pusDeviceID);
    ASSERT(pbIsPrimaryDevice);

    if ((*pulPrevDevice == 0xffffffff) || (*pulPrevDevice < (PCI_MAX_DEVICES - 1)))  // no need to look behind slot 31
    {
        //
        // walk thru our bus and try to detect nvidia boards
        //
        for (ulDevice = *pulPrevDevice + 1; ulDevice < PCI_MAX_DEVICES; ulDevice++)
        {
            psnSlot.u.bits.DeviceNumber  = ulDevice;
            psnSlot.u.bits.FunctionNumber= 0;
            psnSlot.u.bits.Reserved      = 0;

            status = DetectDevice(pHDE, 
                                psnSlot, 
                                ulNumAccessRanges, 
                                pAccessRanges,
                                pusVendorID,
                                pusDeviceID,
                                pbIsPrimaryDevice, 
                                bClaimResources);

            if (NO_ERROR == status)
            {
                // 
                // return slot # 
                //
                *pulPrevDevice = psnSlot.u.AsULONG;
                break;
            }
        }
    }
    return status;
}


//
// Sets the display resolution to the highest supported resolution at 16BPP. The refresh rate chosen will be the
// highest supported at this resolution.
// Note: Currently this logic is supported only if we are booting into Standard mode.
//
VOID HandleBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulHead, ulDeviceMask, ulEDIDIndex, ulDeviceType, ulMaxTVOutResolution;
    ULONG UseBestResolution;
    NV_DESKTOP_INFO *pInfo;
    MODE_ENTRY BestMode;
    ULONG ulRet;
    ULONG RegStatus;

    UseBestResolution = 0;
    pInfo = &HwDeviceExtension->DeskTopInfo;


    RegStatus = VideoPortGetRegistryParameters(HwDeviceExtension,
                    L"UseBestResolution",
                    FALSE,
                    NVRegistryCallback,
                    &(UseBestResolution));

    // Get the best resolution for this chosen device.
    // Handle only the case when we are going to boot into single device standard mode.
    if (pInfo->ulNumberDacsActive == 1)
    {
        if (RegStatus == NO_ERROR && UseBestResolution == 1)
        {
            LPEDID_UNIT pEdidUnit;

            ulHead = pInfo->ulDeviceDisplay[0];
            ulDeviceMask = pInfo->ulDeviceMask[ulHead];
            ulDeviceType = MaskToDeviceType(ulDeviceMask);
            ulEDIDIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
            pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex];

            // If there is a valid EDID for CRT or DFP, process it. Otherwise, do nothing.
            if (ulDeviceType == MONITOR_TYPE_VGA || ulDeviceType == MONITOR_TYPE_FLAT_PANEL)
            {
                if (pEdidUnit->Valid)
                {
                    // parse the EDID
                    ulRet = GetBestResolution(HwDeviceExtension, ulEDIDIndex, ulHead, ulDeviceMask, &BestMode);
                    if (ulRet)
                    {
                        BestMode.ValidMode = 1;
                        CheckForcedResolution(HwDeviceExtension, BestMode.Width, BestMode.Height, 
                            BestMode.Depth, BestMode.RefreshRate, TRUE);
                    }
                }
            }

            // If the device is TV, we pick the best resolution.
            if (ulDeviceType == MONITOR_TYPE_NTSC || ulDeviceType == MONITOR_TYPE_PAL)
            {
                ulMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;
                BestMode.ValidMode = 1;
                BestMode.Width = (USHORT)((ulMaxTVOutResolution & 0xffff0000) >> 16);
                BestMode.Height = (USHORT)(ulMaxTVOutResolution & 0xffff);
                BestMode.Depth = 32;
                BestMode.RefreshRate = 60;
                CheckForcedResolution(HwDeviceExtension, BestMode.Width, BestMode.Height, 
                    BestMode.Depth, BestMode.RefreshRate, TRUE);
                
            }
        } // if UseBestResolution == 1

        else
        {
            // Else, even if UseBestResolution flag was cleared, we could be in 
            // the middle of a one-time-after-reboot-forced-mode sequence so
            // we NEED to check the status of this sequence so DrvEnablePdev
            // will be able to force the mode since we are now passing again
            // in hwinit() (rebooted)
            // (see CheckForcedResolution() (in this file) for details)

            // Even if a one-time-forced-mode sequence is active, only pursue it
            // if we are in standard mode...            
            
            // Note that when setbestresolution (last param) is FALSE, the modeinfo
            // is not used anyways -> see checkforced...
            //
            CheckForcedResolution(HwDeviceExtension, 640, 480, 4, 1, FALSE);

        }


    } // if standard mode
        

    // If the regkey exists, set it to 0.
    if (RegStatus == NO_ERROR && UseBestResolution == 1)
    {
        UseBestResolution = 0;
        VideoPortSetRegistryParameters(HwDeviceExtension,
                    L"UseBestResolution",
                    &UseBestResolution,
                    sizeof(ULONG));
    }

        
    // done
    return;
}

//
// If the twinViewInfo registry structure is present and is valid, use twinVieInfo to initiliaze the 
// fields in HwDeviceExtension strutcure.
// This handles the case when UseHwSelectedDevice has been disabled such as on compal. We still need to initialize
// device masks correctly so that at boot time, GET_CHILD_STATE returns the correct device state for
// ACPI systems. This ensures Win2K uses the correct resolution to bootup.
//
// Note: 
// - This function should be called just once, at boot time.
//
VOID InitFromTwinViewInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pHeadData;
    ULONG ulCombinedMask;
    NV_DESKTOP_INFO * pInfo;
    ULONG i,j, ulHead;
    VP_STATUS Status;

    VideoDebugPrint((1, "InitFromTwinViewInfo():\n"));
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;

    //
    // Read in the twinview info structure
    //
    if (NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData) != NO_ERROR) 
    {
        return;
    }

    //
    // See if the twinviewInfo is valid before using it.
    //
    if (TwinViewDataOK(HwDeviceExtension, &sData))
    {
        pInfo->ulDesktopWidth = sData.DeskTopRectl.right - sData.DeskTopRectl.left;
        pInfo->ulDesktopHeight = sData.DeskTopRectl.bottom - sData.DeskTopRectl.top;
        pInfo->ulTwinView_State = sData.dwState;

        //
        // Set the number of active dacs based on the mode.
        //
        if (sData.dwState == NVTWINVIEW_STATE_NORMAL || sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
        {
            pInfo->ulNumberDacsActive = 1;
        }
        if (sData.dwState == NVTWINVIEW_STATE_CLONE)
        {
            pInfo->ulNumberDacsActive = 2;
        }
        if (sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            if (MULTIMON_MODE(pInfo->ulDesktopWidth, pInfo->ulDesktopHeight))
            {
                pInfo->ulNumberDacsActive = 2;
            }
            else
            {
                pInfo->ulNumberDacsActive = 1;
            }
        }
        
        //
        // Transfer the head mapping array,device masks and other info for the clone, spanning and standard modes.
        //
        if (sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_NORMAL ||
            sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            for (i=0; i < pInfo->ulNumberDacsActive; i++)
            {
                ulHead = sData.dwDeviceDisplay[i];
                pInfo->ulDeviceDisplay[i] = ulHead;
                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[ulHead]);
                pInfo->ulDeviceMask[ulHead] = pHeadData->dwDeviceMask;
                pInfo->ulDeviceType[ulHead] = pHeadData->dwDeviceType;
                pInfo->ulTVFormat[ulHead] = pHeadData->dwTVFormat;
                pInfo->ulDisplayWidth[ulHead] = pHeadData->PhysicalRectl.right - pHeadData->PhysicalRectl.left;
                pInfo->ulDisplayHeight[ulHead] = pHeadData->PhysicalRectl.bottom - pHeadData->PhysicalRectl.top;
                pInfo->ulDisplayRefresh[ulHead] = pHeadData->dwRefresh;
                pInfo->ulDisplayPixelDepth[ulHead] = pHeadData->dwBpp;
            }
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    return;
}

// Writes the current flat panel scaling mode to the registry.
// Temporary until resman is able to do this in a more timely fashion.
ULONG WriteFPModeToRegistry (PHW_DEVICE_EXTENSION hwDeviceExtension)
{   
    BOOL   fpstatus = 0;
    ULONG  head;
    ULONG  i;
    NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS fpGetParams; 
     
                                      
    for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
        if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                            MONITOR_TYPE_FLAT_PANEL)
        {
            fpGetParams.Head = head;
            fpstatus = RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI,
                                &(fpGetParams), 
                                sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS));

            if( fpstatus == TRUE && 
                fpGetParams.FlatPanelMode  <= 2 )
            {
                VideoPortSetRegistryParameters(hwDeviceExtension,
                                  L"FlatPanelMode",
                                  &fpGetParams.FlatPanelMode,
                                  sizeof(ULONG));
            } //if scaling mode is reasonable
        }//if flat panel
    }//for each active dac
    return fpGetParams.FlatPanelMode;
} //end WriteFPModeToRegistry.

//
// Reads the SaveSettings into the hwDevExtension from the registry and returns TRUE.
// If the registry entry is absent, returns FALSE.
//
BOOLEAN bReadSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    VP_STATUS RegStatus;
    RegStatus = VideoPortGetRegistryParameters(
                        hwDeviceExtension,
                        L"SaveSettings",
                        FALSE,
                        NVReadRegistrySaveSettingsCallback,
                        hwDeviceExtension->SaveSettings);
    if (RegStatus == NO_ERROR)
    {
    
        return(TRUE);
    }
    VideoDebugPrint((1,"SaveSettings regKey could not be read: error: 0x%x\n",RegStatus));
    return(FALSE);
}

//
// Debug helper routine to print the SaveSettings table.
//
VOID vPrintSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;
    CHAR *pcMode;

    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        switch (pData->dwState)
        {
        case NVTWINVIEW_STATE_NORMAL:
            pcMode = "Standard";
            break;
        case NVTWINVIEW_STATE_CLONE:
            pcMode = "Clone";
            break;
        case NVTWINVIEW_STATE_SPAN:
            pcMode = "Spanning";
            break;
        default:
            pcMode = "Invalid mode";
            break;
        }
        VideoDebugPrint((1,"%d: %s,%d,  (%d,%d), (0x%x, %d), (0x%x, %d)\n",i,
            pcMode, pData->dwOrientation, pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1], 
            pDevData0->dwDeviceMask, pDevData0->dwTVFormat, pDevData1->dwDeviceMask, pDevData1->dwTVFormat));

        if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 &&
            pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)   
        {
            // don't print this since this slot is not valid.
        }
        else
        {
            // This slot is valid and occupied. Print the mode info.
            VideoDebugPrint((1, "   Desktop: (%d, %d), (%d, %d)\n", 
                pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right, pData->DeskTopRectl.bottom));
            VideoDebugPrint((1,"    Head0 virt: (%d, %d), (%d, %d)\n",
                pDevData0->VirtualRectl.left,pDevData0->VirtualRectl.top,pDevData0->VirtualRectl.right,pDevData0->VirtualRectl.bottom));
            VideoDebugPrint((1,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData0->PhysicalRectl.left,pDevData0->PhysicalRectl.top,pDevData0->PhysicalRectl.right,pDevData0->PhysicalRectl.bottom,
                pDevData0->dwBpp, pDevData0->dwRefresh));
            VideoDebugPrint((1,"    Head1 virt: (%d, %d), (%d, %d)\n",
                pDevData1->VirtualRectl.left,pDevData1->VirtualRectl.top,pDevData1->VirtualRectl.right,pDevData1->VirtualRectl.bottom));
            VideoDebugPrint((1,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData1->PhysicalRectl.left,pDevData1->PhysicalRectl.top,pDevData1->PhysicalRectl.right,pDevData1->PhysicalRectl.bottom,
                pDevData1->dwBpp, pDevData1->dwRefresh));
            VideoDebugPrint((1,"\n"));
        }
        
    }

    return;
}

//
// Writes the SaveSettings from hwDeviceExtension into registry
//
VOID vWriteSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    VP_STATUS RegStatus;

    RegStatus = VideoPortSetRegistryParameters(hwDeviceExtension,
                           L"SaveSettings",
                           hwDeviceExtension->SaveSettings,
                           sizeof(hwDeviceExtension->SaveSettings));
    return;
}

//
// If the "SaveSettings" is absent (as with fresh driver installation), creates the structure in registry. 
// If the "SaveSettings" is present but invalid (as with manual driver binary loads), resets the structure.
// If the "SaveSettings" is present and valid, then does nothing.
// Should be called once at boot time.
// Supported devices for now are CRT0, LCD, TV and CRT1
//
VOID vInitializeSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    VP_STATUS RegStatus;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;

    VideoDebugPrint((1,"Enter vInitializeSaveSettings\n"));

    if (bReadSaveSettings(hwDeviceExtension))
    {
        //
        // Valid SaveSettings was found and has been read into the hwDeviceExtension.
        // Nothing else to do. Return.
        //
        return;
    }
    
    //
    // Either the "saveSettings" was not found or was found to be invalid. So we need to initialize it.
    // First initialize the mapping array. Note that this does not matter for now, since per Ilyas's requirements,
    // LCD+CRT is to be treated the same as CRT+LCD.
    //
    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pData->dwDeviceDisplay[0] = 0;
        pData->dwDeviceDisplay[1] = 1;
    }

    //
    // Set the standard devices.
    //
    for (i=0; i < 4; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_NORMAL;
        switch (i)
        {
        case 0:
            ulDeviceMask = BITMASK_CRT0;
            break;
        case 1:
            ulDeviceMask = BITMASK_DFP0;
            break;
        case 2:
            ulDeviceMask = BITMASK_TV0;
            break;
        case 3:
            ulDeviceMask = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS. Set both head's devicemask just to be uniform.
        //
        pDevData0->dwDeviceMask = ulDeviceMask;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the clone devices.
    //
    for (i=4; i < 10; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_CLONE;
        switch (i)
        {
        case 4:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 5:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 6:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 7:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 8:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 9:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the horizontal span devices.
    //
    for (i=10; i < 16; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_SPAN;
        pData->dwOrientation = HORIZONTAL_ORIENTATION;
        switch (i)
        {
        case 10:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 11:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 12:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 13:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 14:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 15:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the vertical span devices.
    //
    for (i=16; i < 22; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_SPAN;
        pData->dwOrientation = VERTICAL_ORIENTATION;
        switch (i)
        {
        case 16:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 17:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 18:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 19:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 20:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 21:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Now write the initialized table to registry.
    //
    vWriteSaveSettings(hwDeviceExtension);
    VideoDebugPrint((1,"Exit vInitializeSaveSettings\n"));
    return;
}



//****************************************************************************************
//
//   CheckForcedResolution()
//
//   ( It was SetBestResolution() when it was doing this ->
//     
//     Writes the preferred mode into the DefaultSettings part of the registry.
//     (Hack to force the best mode for next bootup: we're writing to an OS key (hardware profile)
//     that don't belong to us)
//   )
//
// New method: Use a private key to tell us to force a mode during the next bootup. 
//             The key will contain the mode info.
//
// THIS FUNCTION MUST BE CALLED at hwinit(), even if we don't want to set the best resolution :
//  
//  the last parameter, BOOLEAN SetBestResolution, is used for that purpose:
//  When we want to set the best res (using the other function parameters) on next reboot, 
//  set this to TRUE, otherwise FALSE
// 
//  Note that even if the function is called with SetBestResolution == TRUE, 
//  if the ForceModeNextBoot key is set to 1, a forced mode will overide the first modeset 
//  sent by GDI anyway, like it is supposed to. (Because the one-time-after-reboot-forced-mode
//  was already induced, we already have a mode to set, from a previous call to this function)
//
//****************************************************************************************

VOID CheckForcedResolution(
    
            PHW_DEVICE_EXTENSION HwDeviceExtension, 
            USHORT               usWidth, 
            USHORT               usHeight, 
            USHORT               usDepth, 
            USHORT               usRefreshRate,
            BOOLEAN              SetBestResolution )
{
    MODE_ENTRY              ModeEntry;
    NV_REGISTRY_STRUCT      RegStruct;
    VP_STATUS               RegStatus;
    
    WCHAR                   ReBootedNowForceMode_namew[] = {L"ReBootedNowForceMode"};
   
    ULONG                   ForceModeNextBoot;  // see below

    BOOLEAN                 ModeEntryIsUpdated; // did we update the modeentry struct or kept the data from the registry ?



    ModeEntryIsUpdated = FALSE;


    /*
    
    This method won't work all the time: for example, on winxp the path is different, and on Toshiba
    compal (bug 35795) the first boot resolution was incorrect if you had a clean system because the
    NV4 key didnt existed yet)
    
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.XResolution",
        REG_DWORD, &usWidth, sizeof(ULONG));

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.YResolution",
        REG_DWORD, &usHeight, sizeof(ULONG));
    
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.BitsPerPel",
        REG_DWORD, &usDepth, sizeof(ULONG));

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.VRefresh",
        REG_DWORD, &usRefreshRate, sizeof(ULONG));
        
    */

    // Write two reg keys: mode info of the mode to force for next bootup, and a flag to tell us when we passed
    // through miniport initialization again for the first mode set of the next boot: 
    //
    // This is done because otherwise, in the drvenablepdev, we won't know if the user tried to change a res
    // without rebooting: if he did just that, we don't want to overide his new choice! We only want to force
    // the best resolution *for the next boot*  *IF AND ONLY IF* the user has not selected a new res prior to that.
    // 
    // One key will be: ForceModeNextBoot  (set here, cleared if  - user changes mode before rebooting OR
    //                                                            - we have rebooted (passed through hwinit again
    //                                                              and this flag was set)
    //
    // The other will tell the DrvEnablePdev function to force a mode: we will use MODE_INFO.validmode
    // (set during hwinit IF ForceModeNextBoot is set, cleared during DrvEnablePdev if it was set)
    //
    // Since this function IS CALLED by hwinit (through handlebestresolution()), we:
    //
    // 1) read ReBootedNowForceMode;
    //
    // 2) read the ForceModeNextBoot flag:  if it is set -> clear it and set ReBootedNowForceMode.ValidMode = 1;
    //                                      else 
    //                                          -> set it (to induce a one-time-after-reboot-forced-mode, since
    //                                             we call setbestresolution for this purpose ) 
    //                                             IF SETBESTRESOLUTION is false, do not set it!!
    //                                             (note that ReBootedNowForceMode.ValidMode = 0);
    // 3) write back the keys;
    //
    //
    //
    // In DrvEnablePdev(): ***!ASSUMING it is called ONLY on modeset!*** 
    //
    //
    //    1) read the ForceModeNextBoot flag: 
    //
    //                                 if it is set ->        clear it ! (the user changed the mode but we haven't rebooted
    //                                                        yet because otherwise, on reboot, in this very function,
    //                                                        we would have cleared it);   ReBootedNowForceMode.ValidMode is 
    //                                                        probably = 0, else the state is inconsistant.
    //                                 else 
    //                                     -> 
    //                                 read the ReBootedNowForceMode.ValidMode flag:  
    //                       
    //                                     if it is set -> clear it and overide the GDI mode with
    //                                                     ReBootedNowForceMode;
    //                                     else 
    //                                         -> nothing special;
    //
    //
    // NOTE: This seems similar to what we do with the UseBestResolution key, but then we might ask "why not use
    //       only that key in the first place?" Because this key is not set *first* by the miniport bootup, but 
    //       by the INF file ! So if the flag is set by the INF, we might think it's ok to turn on
    //       ReBootedNowForceMode.ValidMode, but if the user decides to change the res before rebooting (after the
    //       first install of the drv without reboot) the behavior is going to be wrong: we're going to overide 
    //       the modeset triggered by the user ( because ReBootedNowForceMode.ValidMode will be true! )

    
    // Copy the required values into the input context (submitted to the callback)
    
    RegStruct.keyVal     = (PVOID) &ModeEntry;
    RegStruct.keyValSize = sizeof(MODE_ENTRY);
    RegStruct.keyName    = (PWSTR) ReBootedNowForceMode_namew;

    RegStatus = VideoPortGetRegistryParameters(
                           HwDeviceExtension,
                           ReBootedNowForceMode_namew,
                           FALSE,
                           NVReadRegistryBinaryCallback,
                           (PVOID)&RegStruct);
    
    
    if(RegStatus != NO_ERROR)  
    {
        // the key wasn't there, so fill the structure
        //
        // We only need to to this when we are actually setting 
        // the best resolution, when we check for the forced res
        // sequence, we must have this key valid, so no error
        // on the read should occur.  But if we just check the forced
        // sequence, and WE HAVE an error (the ModeEntry key isnt there, 
        // we will fill a valid mode); this is not necessarily an error
        // condition: if we check the forced resolution sequence, but
        // we don't want to set it, AND the sequenced WAS NOT "started" (by setting the 
        // ForceModeNextBoot key) it is possible not to have any modeentry
        // (ReBootedNowForceMode) registry key set for this...
        // 

        if( SetBestResolution )
        {
            ModeEntry.Depth       = usDepth;        // in bits
            ModeEntry.Height      = usHeight;
            ModeEntry.Width       = usWidth;
            ModeEntry.RefreshRate = usRefreshRate;
            ModeEntry.ValidMode   = 0;              
        }
        else 
        {
            ModeEntry.Depth       = 4;        // in bits
            ModeEntry.Height      = 640;      //
            ModeEntry.Width       = 480;      //
            ModeEntry.RefreshRate = 1;        // this is what windows set as the "safest mode request" 
                                              // in VGASAVE reg key and this is what it sends the driver in safe mode
            ModeEntry.ValidMode   = 0;              
        }
        
        ModeEntryIsUpdated = TRUE;
    }
    
    // when mode data is taken without error from the regkey, assume it is ok


    ForceModeNextBoot = 0;

    RegStatus = VideoPortGetRegistryParameters(
                    HwDeviceExtension,
                    L"ForceModeNextBoot",
                    FALSE,
                    NVRegistryCallback,       
                    (PVOID) &(ForceModeNextBoot));    // This param is passed to our callback. This callback uses ULONGs
    
    if( (RegStatus == NO_ERROR) && (ForceModeNextBoot == 1) )
    {
        // Here, if the forcemode flag was set, we should have read (without error) the mode entry
        // from the registry.  We don't keep and check the status NO_ERROR here because even if 
        // it was invalid, now it is (this case should never happen but it won't do us harm)
        
        ForceModeNextBoot     = 0;
        ModeEntry.ValidMode   = 1;

        ModeEntryIsUpdated = TRUE; // this is not really true, because only one field is updated,
                                   // but we use ModeEntryIsUpdated also to avoid an unecessary 
                                   // write back to the registry ( ModeEntryIsUpdated == FALSE tells
                                   // us we have a mode info from the registry, not from the values
                                   // passed at SetBestResolution()


    } // ... if the key ForceModeNextBoot was set (and it existed)    
    
    else if ( SetBestResolution )     
    {
        // The ForceModeNextBoot key didn't exist, or it was not set:
        // We set it here to induce a one-time-after-reboot-forced-mode, since
        // we called this function with setbestresolution == TRUE for this purpose 
        // We don't call with SetBestResolution == TRUE at each boot because we
        // clear the UseBestResolution flag in HandleBestResolution

        // (the next time we boot, we clear ForceModeNextBoot, by making a call to this
        //  function but with SetBestResolution == FALSE, and we also set modeentry.validmode.  
        //  Even if the function is
        //  called with SetBestResolution == TRUE, if the ForceModeNextBoot key is set
        //  to 1, a forced mode will overide the first modeset sent by GDI, but we
        //  won't update the mode_entry for this mode, so the other function parameters are 
        //  not used, )

        ForceModeNextBoot = 1;

        // Here, one case could make use choose the wrong best resolution:
        // if the key ReBootedNowForceMode was not removed by the wizard uninstall 
        // it could be valid, and we would read some old best mode.  So,
        // if we haven't updated the modeentry, we force it here:

        if( ModeEntryIsUpdated == FALSE )
        {
            ModeEntry.Depth       = usDepth;        // in bits
            ModeEntry.Height      = usHeight;
            ModeEntry.Width       = usWidth;
            ModeEntry.RefreshRate = usRefreshRate;
            ModeEntry.ValidMode   = 0; 
            
            ModeEntryIsUpdated = TRUE;
        }
    
    } // ... else the key ForceModeNextBoot was cleared


    // Write back the keys
    //
    //
    // Note: if the key doesn't exist, it will be created

    
    if( ModeEntryIsUpdated )
    {
        RegStatus = VideoPortSetRegistryParameters(
                           HwDeviceExtension,
                           L"ReBootedNowForceMode",
                           (PVOID) &ModeEntry,
                           sizeof(MODE_ENTRY));    
    }
        
    // Write the ForceModeNextBoot flag 
    
    RegStatus = VideoPortSetRegistryParameters(
                       HwDeviceExtension,
                       L"ForceModeNextBoot",
                       (PVOID) &ForceModeNextBoot,
                       sizeof(ULONG));

} // ... CheckForcedResolution()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv.h
//
// Abstract:
//
//     This module contains the definitions for the code that implements the
//     NVidia NV device driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//******************************************************************************
// Include IOCTL codes to be shared among all components of driver
//******************************************************************************

#include <dspioctl.h>
#include "ntnvreg.h"

#ifdef NVPE
#include "nvpecntx.h"
#endif // NVPE

#include "nvMultiMon.h"

////////////////////////
// BUGBUG: The following section is extracted from nvmisc.h.
//         The miniport has no access to the nvidia\sdk directory !!!
//
//#include "nvmisc.h"
// 
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long	token;
    unsigned long	cmd;
    unsigned long	port;
    unsigned long	flags;
    unsigned long	data;
    unsigned long	status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define	NVRM_I2C_ACCESS_CMD_ACQUIRE     1
#define	NVRM_I2C_ACCESS_CMD_RELEASE     2
#define	NVRM_I2C_ACCESS_CMD_WRITE_BYTE  3
#define	NVRM_I2C_ACCESS_CMD_READ_BYTE   4
#define	NVRM_I2C_ACCESS_CMD_NULL        5
#define	NVRM_I2C_ACCESS_CMD_RESET       6
#define NVRM_I2C_ACCESS_CMD_READ_SDA    7
#define NVRM_I2C_ACCESS_CMD_READ_SCL    8
#define NVRM_I2C_ACCESS_CMD_WRITE_SDA   9
#define NVRM_I2C_ACCESS_CMD_WRITE_SCL   10

// flags
#define NVRM_I2C_ACCESS_FLAG_START	    0x1
#define	NVRM_I2C_ACCESS_FLAG_STOP	    0x2
#define	NVRM_I2C_ACCESS_FLAG_ACK	    0x4

// port
#define	NVRM_I2C_ACCESS_PORT_PRIMARY    1
#define	NVRM_I2C_ACCESS_PORT_SECONDARY  2

// status
#define	NVRM_I2C_ACCESS_STATUS_SUCCESS         0
#define	NVRM_I2C_ACCESS_STATUS_ERROR           1
#define	NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR  2
#define	NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY     3

//
// misc string definitions for registry manipulation
//
#define STR_NVIDIA                  "NVidia"
#define STR_DEV_NODE_RM             "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System"
#define STR_DEV_NODE_DISPLAY        "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display";
#define STR_DEV_NODE_DISPLAY_NUMBER "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
#define STR_RM_CORE_NAME            "RmCoreName"

// End of extracted section
//////////////////////////////////////////////


//
// Undefine this line to disable interrupts via Mutex for Win2K and cli/sti for NT4.0
// This works OK on desktop Win2K but crashes on Toshiba laptop. So disable for now
//
// #define ENABLE_FP_MUTEX



//
// Win2K currently supports 8 different power states as defined in ntddvdeo.h
// We use 16 slots just as a cushion for future additional power states in succeeding
// versions of Win2K.
//
#define MAX_WIN2K_POWER_STATES 16
//
// The only power states of relevance in Win2K currently are on, standby, suspend, off, hibernate
//
#define NV_VideoPowerUnspecified 0
#define NV_VideoPowerOn 1
#define NV_VideoPowerStandBy 2
#define NV_VideoPowerSuspend 3
#define NV_VideoPowerOff 4
#define NV_VideoPowerHibernate 5
#define NV_VideoPowerShutdown 6


//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;

#define LOWESTBIT(x)    ((x) & (((x)-1) ^ (x)))

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

//******************************************************************************
// Polymorphic type stubs for NT4
//******************************************************************************

#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

//******************************************************************************
// Monitor types  -> Values MUST agree with those from RM !!!
//******************************************************************************

#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3

//******************************************************************************
// Our hardcoded defines
//******************************************************************************

#define MAX_CLIP_REGIONS      16
#define MAX_GRPATCH_FANOUT    56
#define MAX_GRPATCH_INPUT     56
#define NUM_PATCHES           10
#define NUM_SUBCHANNELS       8
#define NUM_GRAPHICS_DEVICES  0x1e
#define INVALID               0xffffffff;
#define BIOS_STR_MAX 50

//******************************************************************************
// Size of saved BIOS image (used for manual posting)
//******************************************************************************

#define SAVED_BIOS_IMAGE_SIZE   0x10000

//******************************************************************************
// Bios memory sizing adjust value (for RM Post Device memory sizing)
//******************************************************************************

#define BIOS_MEM_SIZE_ADJUST_FACTOR 0x00010000;

//******************************************************************************
// EDID buffer size (in bytes)
//******************************************************************************

#define EDID_V2_SIZE   256

//******************************************************************************
// Max Size in bytes of saved instance memory (used when powering down)
//******************************************************************************

#define MAX_INSTANCE_MEM_SIZE   0x30000

//******************************************************************************
// Enough memory to store registry data
//
// Set MAX of 30 numbers per mode entry (each line) in INF
// Set MAX of 90  mode entries ( MAX 30 width_height * 3 (for depths))
// Data table will consist of type U016
//
//          Registry Data Format (word values)
//              MAX word values per line = 30 word values
//              MAX of 90 lines (90 mode entries)
//
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           etc...
//******************************************************************************

#define MAX_STRING_REGISTRY_VALUES  30
#define MAX_STRING_REGISTRY_LINES   90
#define MAX_STRING_REGISTRY_DATA_WORDS (MAX_STRING_REGISTRY_VALUES * MAX_STRING_REGISTRY_LINES)

//******************************************************************************
// Enough memory to store valid mode table data
// Set MAX of 1800 mode entries ( MAX 30 width/height * 3 (for depths) * MAX 20 refresh rates)
// Each struct entry  has 5 entries (valid flag, width,height, bpp, refresh)
// Data table will consist of type U016
//******************************************************************************

#define MAX_VALID_MODE_REFRESH_RATES 20
#define MAX_VALID_MODE_TABLE_DATA_WORDS (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 5)


#define MAX_BIOS_SCAN 1024

//******************************************************************************
// VSync/HSync defines
//******************************************************************************

#define BUFFER_HSYNC_NEGATIVE  0
#define BUFFER_HSYNC_POSITIVE  1

//******************************************************************************
// Memory types
//******************************************************************************

#define NV_BUFFER_SDRAM            0
#define NV_BUFFER_SGRAM            1

//******************************************************************************
// Resolution defines
//******************************************************************************
#define RESOLUTION_640X480      0
#define RESOLUTION_320X240      3
#define RESOLUTION_320X400      6
#define RESOLUTION_400X300      9
#define RESOLUTION_480X360      12
#define RESOLUTION_512X384      15
#define RESOLUTION_640X400      18
#define RESOLUTION_320X200      21
#define RESOLUTION_800X600      24
#define RESOLUTION_960X720      27
#define RESOLUTION_1024X768     30
#define RESOLUTION_1152X864     33
#define RESOLUTION_1280X1024    36
#define RESOLUTION_1600X1200    39
#define RESOLUTION_1800X1440    42
#define RESOLUTION_1920X1080    45
#define RESOLUTION_1920X1200    48

//******************************************************************************
// Various NV Chip ID's
//******************************************************************************

#define NV1_REV_B_02             2
#define NV1_REV_B_03             3
#define NV1_REV_C_01             4
#define NV1_REV_C_02             5
#define NV3_REV_A_00             0
#define NV3_REV_B_00             1
#define NV3_REV_C_00             2


//******************************************************************************
// NV1 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
//******************************************************************************

#define COLOR_FORMAT_X17R5G5B5        0x00000000
#define COLOR_FORMAT_X16A1R5G5B5      0x00002000
#define COLOR_FORMAT_X8R8G8B8         0x00000200
#define COLOR_FORMAT_A8R8G8B8         0x00002200
#define COLOR_FORMAT_X2R10G10B10      0x00000400
#define COLOR_FORMAT_A2R10G10B10      0x00002400
#define COLOR_FORMAT_X24Y8            0x00000600
#define COLOR_FORMAT_X16A8Y8          0x00002600

//******************************************************************************
// NV3 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
// See PGRAPH_CTX_SWITCH register definition for more information.
//******************************************************************************

#define NV3_COLOR_FORMAT_X17R5G5B5        (0x00000000)
#define NV3_COLOR_FORMAT_X16A1R5G5B5      (0x00000008 | 0x00000000)
#define NV3_COLOR_FORMAT_X8R8G8B8         (0x00000001)
#define NV3_COLOR_FORMAT_A8R8G8B8         (0x00000008 | 0x00000001)
#define NV3_COLOR_FORMAT_X2R10G10B10      (0x00000002)
#define NV3_COLOR_FORMAT_A2R10G10B10      (0x00000008 | 0x00000002)
#define NV3_COLOR_FORMAT_X24Y8            (0x00000003)
#define NV3_COLOR_FORMAT_X16A8Y8          (0x00000008 | 0x00000003)
#define NV3_COLOR_FORMAT_Y16                           (0x00000004)


//******************************************************************************
// Monochrome Format values to be used to generate CONTEXT values
// See the CTX_SWITCH register definition for more information (Bit 14)
//******************************************************************************

#define MONO_FORMAT_LE        0x00000000
#define MONO_FORMAT_CGA6      0x00004000

#define NV3_MONO_FORMAT_LE    0x00000000
#define NV3_MONO_FORMAT_CGA6  0x00000100

//******************************************************************************
// NV1 Cursor defines
//******************************************************************************

#define NV1_DAC_CURSOR_TWO_COLOR_XOR    2
#define NV1_DAC_CURSOR_TWO_COLOR        3

//******************************************************************************
// ID values for STATIC image objects
// (Index into the CommonObject array - Currently allow up to 10)
//******************************************************************************

#define IMAGE_SOLID_ID                 0
#define IMAGE_BLACK_RECTANGLE_ID       1
#define IMAGE_PATTERN_ID               2
#define IMAGE_ROP_ID                   3

//******************************************************************************
// ID values for the patches, each is associated with a Rendering object
// (Index into the Render Object array - Currently allow up to 15)
//******************************************************************************

#define RECTANGLE_PATCH                0
#define TRIANGLE_PATCH                 1
#define BLIT_PATCH                     2
#define IMAGE_FROM_CPU_PATCH           3
#define IMAGE_MONO_FROM_CPU_PATCH      4
#define D3DTRIANGLE_PATCH              5
#define CLEARZ_PATCH                   6
#define SRCIMAGE_IN_MEMORY_PATCH       7
#define DSTIMAGE_IN_MEMORY_PATCH       8
#define MEMORY_TO_MEMORY_PATCH         9
#define D3DTRIANGLE_SYSMEM_PATCH       10
#define RENDER_SOLID_LIN_PATCH         11

//******************************************************************************
// Special cased ROP3 operations
//******************************************************************************

#define BLACKNESS 0x0000
#define DSTINVERT 0x0055
#define PATINVERT 0x005A
#define SRCAND    0x0088
#define DSTCOPY   0x00AA
#define SRCCOPY   0x00CC
#define SRCPAINT  0x00EE
#define PATCOPY   0x00F0
#define WHITENESS 0x00FF
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// maximum Number of output device connectors on a board.
//******************************************************************************
#define NV_NO_CONNECTORS                  24

//******************************************************************************
// Type of video ram
//******************************************************************************

#define BUFFER_DRAM 0
#define BUFFER_VRAM 1

//******************************************************************************
// Page size definitions.
//******************************************************************************
#if defined(_M_IA64)

#define PAGE_SIZE 0x2000

#elif defined(_M_IX86)

#define PAGE_SIZE 0x1000

#endif

//******************************************************************************
// This cursor structure MUST also match the one defined in driver.h
// (in the display driver directory)
//******************************************************************************

typedef struct _TV_CURSOR_ADJUST_INFO
    {
    ULONG   MonitorType;
    ULONG   Underscan_x;
    ULONG   Underscan_y;
    ULONG   Scale_x;
    ULONG   Scale_y;
    ULONG   FilterEnable;
    ULONG   TVCursorMin;
    ULONG   TVCursorMax;
    } TV_CURSOR_ADJUST_INFO;


//******************************************************************************
// Current PRAMIN map: (Currently only 64k is allocated for total PRAMIN size)
//                      in NV3_IsPresent()
//
// Offset   Type of Instance Data
// ======   =====================
//
//          ------------------------------   <--- Start of PRAMIN area
// 0        Hash Table                       ^
//          Run Out                          |
//          Fifo Context                     |
//          Free Instances                   |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |
// 16k                                       |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |----> 64k allocated for PRAMIN
// 32k      VRAM Texture Page Table Entries  |
//          (Used by D3DTriangle Object for  |
//           textures in VRAM)               |
//                                           |
// 42k      SYSMEM Texture Page Table Entreis|
//          (Used by the D3dTriangle Object  |
//           for textures in System Memory)  |
//                                           |
//          ------------------------------   |
// 48k      Cursor data (8 cached images)    |
//          Each bitmap takes up 2k          |
//                                           |
//                                           |
//                                           |
//                                           v
// 64k      ------------------------------
//
//******************************************************************************

//******************************************************************************
// Types of Engine known to FIFO (NV3)
//******************************************************************************

#define ENGINE_SW       0
#define ENGINE_GRAPHICS 1

//******************************************************************************
// Dedicated privileged device ram size in bytes. (NV1)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_12_KBYTES   0x3000  // 12KB
#define NV_PRAM_DEVICE_SIZE_20_KBYTES  0x5000   // 20KB
#define NV_PRAM_DEVICE_SIZE_36_KBYTES  0x9000   // 36KB
#define NV_PRAM_DEVICE_SIZE_68_KBYTES  0x11000  // 68KB

//******************************************************************************
// NV3's privileged size, minus audio (NV3)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_5_5_KBYTES   0x1600 // 5.5KB
#define NV_PRAM_DEVICE_SIZE_9_5_KBYTES   0x2600 // 9.5KB
#define NV_PRAM_DEVICE_SIZE_17_5_KBYTES  0x4600 // 17.5KB
#define NV_PRAM_DEVICE_SIZE_33_5_KBYTES  0x8600 // 33.5KB

//******************************************************************************
// Offscreen Instance Memory size.
//******************************************************************************

#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB

#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1

//******************************************************************************
// Forward declaration of all structures
//******************************************************************************

typedef struct _def_object                  OBJECT,*POBJECT;
typedef struct _def_common_object           COMMONOBJECT, *PCOMMONOBJECT;
typedef struct _def_render_common           RENDERCOMMON, *PRENDERCOMMON;
typedef struct _def_render_common_object    RENDERCOMMONOBJECT, *PRENDERCOMMONOBJECT;
typedef struct _def_image_blt_object        IMAGEBLITOBJECT, *PIMAGEBLITOBJECT;
typedef struct _def_image_mem_object        IMAGEMEMOBJECT, *PIMAGEMEMOBJECT;
typedef struct _def_render_object           RENDEROBJECT, *PRENDEROBJECT;
typedef struct _def_render_beta_object      RENDERBETAOBJECT, *PRENDERBETAOBJECT;
typedef struct _def_video_object            VIDEOOBJECT, *PVIDEOOBJECT;
typedef struct _def_video_patchcord         VIDEOPATCHCORD, *PVIDEOPATCHCORD;
typedef struct _def_video_switch_object     VIDEOSWITCHOBJECT, *PVIDEOSWITCHOBJECT;
typedef struct _def_ordinal_object          ORDINALOBJECT, *PORDINALOBJECT;
typedef struct _def_video_sink              VIDEOSINKOBJECT, *PVIDEOSINKOBJECT;
typedef struct _def_video_colormap_object   VIDEOCOLORMAPOBJECT, *PVIDEOCOLORMAPOBJECT;
typedef struct _def_image_object            IMAGEOBJECT, *PIMAGEOBJECT;
typedef struct _def_image_patchcord         IMAGEPATCHCORD, *PIMAGEPATCHCORD;
typedef struct _def_image_video_object      IMAGEVIDEOOBJECT, *PIMAGEVIDEOOBJECT;
typedef struct _def_rop_patchcord           ROPPATCHCORD, *PROPPATCHCORD;
typedef struct _def_solid_object            SOLIDOBJECT, *PSOLIDOBJECT;
typedef struct _def_black_rect_object       CLIPOBJECT, *PCLIPOBJECT;
typedef struct _def_pattern_object          PATTERNOBJECT, *PPATTERNOBJECT;
typedef struct _def_rop_object              ROPOBJECT, *PROPOBJECT;
typedef struct _def_beta_object             BETAOBJECT, *PBETAOBJECT;
typedef struct _def_beta_max_object         BETAMAXOBJECT, *PBETAMAXOBJECT;
typedef struct _def_bool_object             BOOLOBJECT, *PBOOLOBJECT;
typedef struct _def_blend_object            BLENDOBJECT, *PBLENDOBJECT;
typedef struct _def_beta_patchcord          BETAPATCHCORD, *PBETAPATCHCORD;
typedef struct _def_stencil_object          STENCILOBJECT, *PSTENCILOBJECT;
typedef struct _def_colorkey_object         COLORKEYOBJECT, *PCOLORKEYOBJECT;
typedef struct _def_plane_mask_object       PLANEMASKOBJECT, *PPLANEMASKOBJECT;
typedef struct _def_fifo                    FIFO, *PFIFO;
typedef struct _def_patch_context           PATCHCONTEXT, *PPATCHCONTEXT;
typedef struct _def_graphics_patch          GRAPHICSPATCH, *PGRAPHICSPATCH;
typedef struct _def_graphics_channel        GRAPHICSCHANNEL, *PGRAPHICSCHANNEL;
typedef struct _def_canvas                  CANVAS, *PCANVAS;
typedef struct _def_node                    NODE, *PNODE;

//******************************************************************************
// Regular Object
//******************************************************************************


struct _def_object
{
    U032       Name;
    U032       ChID;
    U032       ClassType;
};

//******************************************************************************
// Common Object
//******************************************************************************

struct _def_common_object
{
    OBJECT      Base;
    U032        Valid;
    U032        NotifyPending;
    U032        Context;
    U032        Device;
    U032        Instance;           // Useful for NV3 (Uses Instance Addresses)
    PCOMMONOBJECT Next;
    U032        ColorFormat;
    U032        MonoFormat;
};

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define CBase            Common.Base
#define CValid           Common.Valid
#define CNotifyPending   Common.NotifyPending
#define CContext         Common.Context
#define CDevice          Common.Device
#define CInstance        Common.Instance
#define CNext            Common.Next
#define CColorFormat     Common.ColorFormat
#define CMonoFormat      Common.MonoFormat


//******************************************************************************
// BTREE structure.
//******************************************************************************

struct _def_node
{
    U032              Value;
    VOID             *Data;
    U032              LeftCount;
    U032              RightCount;
    struct _def_node *LeftBranch;
    struct _def_node *RightBranch;
} ;

//******************************************************************************
// Canvas
//******************************************************************************

struct _def_canvas
{
    NODE Node;
    U032 CanvasID;
    U032 UsageCount;
    U032 BufferToggle;
    U032 xyMin;
    U032 xyMax;
    U032 ClipCount;
    U032 ClipMisc;
    U032 xyClipMin[MAX_CLIP_REGIONS];
    U032 xyClipMax[MAX_CLIP_REGIONS];
    U032 InOutClip[MAX_CLIP_REGIONS];
    U032 CplxClipCount;
    U032 xyCplxClipMin[2];
    U032 xyCplxClipMax[2];
} ;


//******************************************************************************
// Video Object
//******************************************************************************

struct _def_video_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video Patchcord
//******************************************************************************

struct _def_video_patchcord
{
    OBJECT       Base;
    PVIDEOOBJECT Source;
    PVIDEOOBJECT Destination;
} ;

//******************************************************************************
// Video Switch Object
//******************************************************************************

struct _def_video_switch_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[2];
//    VBLANKNOTIFY    VBlankNotify[2];
    PORDINALOBJECT  Ordinal;
    PCANVAS         Canvas;
} ;

//******************************************************************************
// Ordinal Object
//******************************************************************************

struct _def_ordinal_object
{
    OBJECT             Base;
    U032               Value;
    PVIDEOSWITCHOBJECT Switch[MAX_GRPATCH_FANOUT];
    U032               FanOut;
} ;

//******************************************************************************
// Video Sink Object
//******************************************************************************

struct _def_video_sink
{
    OBJECT          Base;
//    PDMAOBJECT      NameXlate;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video ColorMap Object
//******************************************************************************

struct _def_video_colormap_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput;
    U032            ColorFormat;
//    PDMAOBJECT      Xlate;
    U032            Start;
    U032            Length;
    U032            DirtyStart;
    U032            DirtyLength;
    U032            ColorMap[256];
} ;

//******************************************************************************
// Image Object
//******************************************************************************

struct _def_image_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Image Patchcord
//******************************************************************************

struct _def_image_patchcord
{
    OBJECT       Base;
    U032         FanOut;
    PIMAGEOBJECT Source;
    PIMAGEOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Image Video Object
//******************************************************************************

struct _def_image_video_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
    PVIDEOPATCHCORD VideoOutput;
//    PDMAOBJECT      NameXlate;
    PCANVAS         Canvas;
    U032            Buffer;
} ;

//******************************************************************************
// ROP Patchcord
//******************************************************************************

struct _def_rop_patchcord
{
    OBJECT      Base;
    U032        FanOut;
    PROPOBJECT  Source;
    PBOOLOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Solid Object
//******************************************************************************

struct _def_solid_object
{
        COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            Color;
} ;

//******************************************************************************
// Clip Object
//******************************************************************************

struct _def_black_rect_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            xClipMin;
    U032            xClipMax;
    U032            yClipMin;
    U032            yClipMax;
} ;

//******************************************************************************
// Pattern Object
//******************************************************************************

struct _def_pattern_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            PattColor0;
    U032            PattColor0Alpha;
    U032            PattColor1;
    U032            PattColor1Alpha;
    U032            Pattern0;
    U032            Pattern1;
    U032            PatternShape;
} ;

//******************************************************************************
// Rop Object
//******************************************************************************

struct _def_rop_object
{
    COMMONOBJECT  Common;
    PROPPATCHCORD RopOutput;
    U032          Rop3;
} ;


//******************************************************************************
// Beta Object
//******************************************************************************

struct _def_beta_object
{
    COMMONOBJECT   Common;
    PBETAPATCHCORD BetaOutput;
    U032           Beta;
} ;

//******************************************************************************
// Beta Max Object
//******************************************************************************

struct _def_beta_max_object
{
    OBJECT         Base;
    PBETAPATCHCORD BetaOutput;
    PBETAPATCHCORD BetaInput[2];
} ;

//******************************************************************************
// Bool object
//******************************************************************************

struct _def_bool_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PROPPATCHCORD     RopInput;
    PROPOBJECT        RopObject;
    PPATTERNOBJECT    PatObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;

//******************************************************************************
// Blend Object
//******************************************************************************

struct _def_blend_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PBETAPATCHCORD    BetaInput;
    PPATTERNOBJECT    PatObject;
    PCOMMONOBJECT     SrcObject;
    PBETAOBJECT       BetaObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;


//******************************************************************************
// Beta Patchcord Object
//******************************************************************************

struct _def_beta_patchcord
{
    OBJECT  Base;
    U032    FanOut;
    POBJECT Source;
    POBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Stencil Object
//******************************************************************************

struct _def_stencil_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[2];
    PCLIPOBJECT     ClipObject;
} ;

//******************************************************************************
// Color Key Object
//******************************************************************************

struct _def_colorkey_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Plane Mask Object
//******************************************************************************

struct _def_plane_mask_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Graphics patch context representation,
//
// NOTE: In the RESOURCE MANAGER, this structure mainly consists of POINTERS.
//       But here, we store the actual structures, so we don't have to
//       allocate the memory dynamically.  That is, instead of PROPOBJECT,
//       we use ROPOBJECT instead.  This will take up memory in the
//       HwDeviceExtension structure (which holds all the 'global' values.
//
//******************************************************************************

struct _def_patch_context
{
    U032                 ImageConfig;
    U032                 VideoConfig;
//    PIMAGEVIDEOOBJECT    ImageVideo;
//    PCANVAS              Canvas;
//    PROPOBJECT           Rop;
//    PPATTERNOBJECT       RopPat;
//    PIMAGEVIDEOOBJECT    RopDst;
//    PBETAOBJECT          Beta;
//    PCOMMONOBJECT        BetaSrc;
//    PPATTERNOBJECT       BetaPat;
//    PIMAGEVIDEOOBJECT    BetaDst;
//    PSOLIDOBJECT         ColorKey;
//    PSOLIDOBJECT         PlaneMask;
//    PIMAGEVIDEOOBJECT    PlaneMaskDst;
//    PCLIPOBJECT          Clip;
//    PPATTERNOBJECT       Pattern;
//    PVIDEOCOLORMAPOBJECT ColorMap0;
//    PVIDEOCOLORMAPOBJECT ColorMap1;
//    PVIDEOSWITCHOBJECT   VideoSwitch;

      IMAGEVIDEOOBJECT    ImageVideo;
      CANVAS              Canvas;
      ROPOBJECT           Rop;
      PATTERNOBJECT       RopPat;
      IMAGEVIDEOOBJECT    RopDst;
      BETAOBJECT          Beta;
      COMMONOBJECT        BetaSrc;
      PATTERNOBJECT       BetaPat;
      IMAGEVIDEOOBJECT    BetaDst;
      SOLIDOBJECT         ColorKey;
      SOLIDOBJECT         PlaneMask;
      IMAGEVIDEOOBJECT    PlaneMaskDst;
      CLIPOBJECT          Clip;
      PATTERNOBJECT       Pattern;
      VIDEOCOLORMAPOBJECT ColorMap0;
      VIDEOCOLORMAPOBJECT ColorMap1;
      VIDEOSWITCHOBJECT   VideoSwitch;


} ;

//******************************************************************************
// Render Common Object
//******************************************************************************

struct _def_render_common
{
    PGRAPHICSPATCH  Patch;
    PATCHCONTEXT    PatchContext;
//    PDMAOBJECT      Xlate;
} ;

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define RCPatch            RenderCommon.Patch
#define RCPatchContext     RenderCommon.PatchContext
#define RCXlate            RenderCommon.Xlate


//******************************************************************************
// RenderCommon Object
//******************************************************************************

struct _def_render_common_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
} ;

//******************************************************************************
// Image Blit Object
//******************************************************************************

struct _def_image_blt_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput;
} ;

//******************************************************************************
// ImageMem Object
//******************************************************************************

struct _def_image_mem_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageInputOutput;
} ;

//******************************************************************************
// Render Object
//******************************************************************************

struct _def_render_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
} ;

//******************************************************************************
// Render Beta Object
//******************************************************************************

struct _def_render_beta_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PBETAPATCHCORD  BetaOutput;
} ;

//******************************************************************************
// FIFO structure
//******************************************************************************

struct _def_fifo
{
    BOOL    InUse;
    U032    ChID;
//    POBJECT ObjectStack[NUM_SUBCHANNELS];
    ULONG   ObjectStack[NUM_SUBCHANNELS];
    ULONG   SavedChDevInstance[NUM_SUBCHANNELS];
    ULONG   SavedContext[NUM_SUBCHANNELS];
    U032    ObjectCount;
} ;

//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_patch
{
    U032                 UsageCount;        // # of objects using this patch c
    U032                 RopUsage;          // # of objects using ROP.
    U032                 BetaUsage;         // # of objects using Beta.
    U032                 ColorKeyUsage;     // # of objects using Color Key.
    U032                 PlaneMaskUsage;    // # of objects using Plane Mask.
    U032                 ClipUsage;         // # of objects using Clip.
    U032                 PatternUsage;      // # of objects using Pattern.
    PGRAPHICSPATCH       Next;
    PRENDERCOMMONOBJECT  XferObject;        // DMA information for graphics.
    PCANVAS              Canvas;            // Associated canvas to this patch
    U032                 xyMinPrev;         // Previous xyMin of canvas.
    U032                 xyMaxPrev;         // Previous xyMax of canvas.
    PVIDEOCOLORMAPOBJECT ColorMap0;         // Associated colormap to buffer 0
    PVIDEOCOLORMAPOBJECT ColorMap1;         // Associated colormap to buffer 1
    PVIDEOSWITCHOBJECT   VideoSwitch;       // Associated video switch.
    PCOMMONOBJECT        UserObjects[NUM_GRAPHICS_DEVICES];
    U032                 AbsX[18];          // Internal state that isn't
    U032                 AbsY[18];          // object specific.  It is
    U032                 XYLogicMisc0;      // restored for whatever
    U032                 XYLogicMisc1;      // object that was last
    U032                 XMisc;             // rendering.
    U032                 YMisc;             // ...
    U032                 CanvasMisc;        // ...
    U032                 MonoColor0;        // ...
    U032                 MonoColor1;        // ...
    U032                 SourceColor;       // ...
    U032                 SubDivide;         // ...
    U032                 EdgeFill;          // ...
    U032                 BetaRam[14];       // ...
    U032                 XAbsIClipMax;      // ...
    U032                 YAbsIClipMax;      // ...
    U032                 Bit33;             // ...
} ;


//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_channel
{
    PCOMMONOBJECT  NotifyObject;
    U032           Notify;
    PROPOBJECT     CurrentRop;
    PBETAOBJECT    CurrentBeta;
    PSOLIDOBJECT   CurrentColorKey;
    PSOLIDOBJECT   CurrentPlaneMask;
    PCLIPOBJECT    CurrentClip;
    PPATTERNOBJECT CurrentPattern;
    PGRAPHICSPATCH CurrentPatch;
    PGRAPHICSPATCH PatchList;
    U032           PatchCount;
    U032           Exceptions;
} ;

//******************************************************************************
// Register base macros
//******************************************************************************

#define PMC_Base            HwDeviceExtension->NV1_Lin_PMC_Registers
#define PFB_Base            HwDeviceExtension->NV1_Lin_PFB_Registers
#define PRM_Base            HwDeviceExtension->NV1_Lin_PRM_Registers
#define PDAC_Base           HwDeviceExtension->NV1_Lin_PDAC_Registers
#define PRAM_Base           HwDeviceExtension->NV1_Lin_PRAM_Registers
#define PRAMFC_Base         HwDeviceExtension->NV1_Lin_PRAMFC_Registers
#define PRAMHT_Base         HwDeviceExtension->NV1_Lin_PRAMHT_Registers
#define USER_Base           HwDeviceExtension->NV1_Lin_USER_Registers
#define PFIFO_Base          HwDeviceExtension->NV1_Lin_PFIFO_Registers
#define PBUS_Base           HwDeviceExtension->NV1_Lin_PBUS_Registers
#define PGRAPH_Base         HwDeviceExtension->NV1_Lin_PGRAPH_Registers
#define CONFIG_Base         HwDeviceExtension->NV1_Lin_CONFIG_Registers
#define MEM_Base            HwDeviceExtension->NV1_Lin_MEM_Registers
#define IO_Base             HwDeviceExtension->NV1_Lin_IO_Registers
#define PDMA_Base           HwDeviceExtension->NV1_Lin_PDMA_Registers
#define PTIMER_Base         HwDeviceExtension->NV1_Lin_PTIMER_Registers
#define PAUDIO_Base         HwDeviceExtension->NV1_Lin_PAUDIO_Registers
#define PAUTH_Base          HwDeviceExtension->NV1_Lin_PAUTH_Registers
#define PEXTDEV_Base        HwDeviceExtension->NV1_Lin_PEXTDEV_Registers
#define PEEPROM_Base        HwDeviceExtension->NV1_Lin_PEEPROM_Registers
#define PROM_Base           HwDeviceExtension->NV1_Lin_PROM_Registers
#define PALT_Base           HwDeviceExtension->NV1_Lin_PALT_Registers
#define PRMIO_Base          HwDeviceExtension->NV1_Lin_PRMIO_Registers
#define URECT_Base          HwDeviceExtension->NV1_Lin_URECT_Registers
#define UTRI_Base           HwDeviceExtension->NV1_Lin_UTRI_Registers
#define UBLIT_Base          HwDeviceExtension->NV1_Lin_UBLIT_Registers
#define UIMAGE_Base         HwDeviceExtension->NV1_Lin_UIMAGE_Registers
#define UBITMAP_Base        HwDeviceExtension->NV1_Lin_UBITMAP_Registers
#define PRAMIN_Base         HwDeviceExtension->NV3_Lin_PRAMIN_Registers
#define PRMVIO_Base         HwDeviceExtension->NV3_Lin_PRMVIO_Registers
#define PRMCIO_Base         HwDeviceExtension->NV3_Lin_PRMCIO_Registers
#define PRAMDAC_Base        HwDeviceExtension->NV3_Lin_PRAMDAC_Registers
#define USERDAC_Base        HwDeviceExtension->NV3_Lin_USERDAC_Registers
#define PVIDEO_Base         HwDeviceExtension->NV3_Lin_PVIDEO_Registers

//******************************************************************************
// Device macros
//******************************************************************************


#define GR_DEVICE_INDEX(d)      ((((d)>>16)&0x7F)-0x41)


//******************************************************************************
//
// Save/Restore state macros for graphics engine
//
//******************************************************************************

#define GR_SAVE_STATE(misc)                                                             \
{                                                                                   \
        misc = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_MISC);    \
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                        | DRF_DEF(_PGRAPH, _MISC, _FIFO,       _DISABLED));  \
}

#define GR_RESTORE_STATE(misc)                                                          \
{                                                                                   \
        PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                              | (DRF_DEF(_PGRAPH, _MISC, _FIFO, _ENABLED) & misc)); \
}

//*************************************************************************
// Graphics Engine DONE and IDLE macros
//*************************************************************************

#define GR_IDLE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE"));    \
                        }

#define GR_DONE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS));

#define GR_IDLE_NV3 while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH0,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE_NV3"));  \
                        }



//******************************************************************************
//
// Hash table function.
//
//******************************************************************************

#define FIFO_HASH(h,c)  ((((h)^((h)>>8)^((h)>>16)^((h)>>24))&0xFF)^((c)&0x7F))
#define HASH_DEPTH      4
#define HASH_ENTRY(h,d) ((h)*HASH_DEPTH+(d))


//******************************************************************************
//
// NV Reference Manual register access definitions.
//
//******************************************************************************


typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

// Start using flat register range (instead of using multiple ranges)

#define REG_WR32(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]=(U032)(d)
#define REG_RD32(a)     (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]
#define REG_WR08(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]  =(U008)(d)
#define REG_RD08(a)     (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]


//#ifdef PC98
#define MEM_WR32(a,d)   fbAddr->Reg032[(a)/4]=(U032)(d)
#define MEM_RD32(a)     fbAddr->Reg032[(a)/4]
//#endif // PC98


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMIN registers (NV3)
//******************************************************************************

#define PRAMIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]=(U032)(d)
#define PRAMIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]
#define PRAMIN_REG_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMIN_REG_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMIN_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMIN_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMIN_REG_RD_DRF(b,d,r,f)       (((PRAMIN_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
//
// NV Reference Manual INSTANCE MEMORY structure access definitions.
//
//******************************************************************************

#define INST_WR32(b,i,o,d)      PRAMIN_REG_WR32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o),(d))
#define INST_RD32(b,i,o)        PRAMIN_REG_RD32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(b,i,s,f)       (((INST_RD32(b,i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))

//******************************************************************************
// Unlike Win95, we don't allocate one pointer to reference the entire
// address space mapped by the NV memory map (32Mb). NT doesn't like us
// taking all this memory.  So what we'll do instead is allocate separate
// chunks of memory for the various classes of registers.  The downside
// is that we can't use the REG_RD and REG_WR macros as is.  We'll need
// to use specific macros for each type of register class.
// The goal is that we want to use all those DEFINES that have already
// been done for us (Instead of having to Re-define the REGISTER BASES)
//
// Format is as follows:
//    b = Base address mapped for this type of register class
//    o = Register Offset address from the base of the NV device (address=0)
//        The correct address will be fixed up as follows:
//        OFFSET_FROM_REGISTER_BASE = OFFSET_FROM_0 - REGISTER_BASE_OFFSET
//
//        For example, OFFSET of NV_PFIFO_INTR_0 = 2100.
//        NEW OFFSET (from register base ) = 2100 - NV_PFIFO = 100
//
// ???? What about performance ?????
// ???? Redefine macros to improve performance ??????
// ???? Does compiler optimize well ?????
//******************************************************************************

//******************************************************************************
// Temporary register range
//******************************************************************************

#define TEMP_REG_WR32(b,d)   (b)->Reg032[0]=(U032)(d)
#define TEMP_REG_RD32(b)     (b)->Reg032[0]

//******************************************************************************
// Macros for NV_CONFIG registers
//******************************************************************************

#define CONFIG_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]=(U032)(d)
#define CONFIG_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]
#define CONFIG_REG_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define CONFIG_REG_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define CONFIG_FLD_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define CONFIG_FLD_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define CONFIG_REG_RD_DRF(b,d,r,f)       (((CONFIG_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_MEMORY registers
//******************************************************************************

#define MEMORY_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]=(U032)(d)
#define MEMORY_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]
#define MEMORY_REG_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define MEMORY_REG_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define MEMORY_FLD_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define MEMORY_FLD_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define MEMORY_REG_RD_DRF(b,d,r,f)       (((MEMORY_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_IO registers
//******************************************************************************

#define IO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]=(U032)(d)
#define IO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]
#define IO_REG_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define IO_REG_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define IO_FLD_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define IO_FLD_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define IO_REG_RD_DRF(b,d,r,f)       (((IO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PMC registers
//******************************************************************************

#define PMC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]=(U032)(d)
#define PMC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]
#define PMC_REG_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PMC_REG_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PMC_FLD_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PMC_FLD_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PMC_REG_RD_DRF(b,d,r,f)       (((PMC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PBUS registers
//******************************************************************************

#define PBUS_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]=(U032)(d)
#define PBUS_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]
#define PBUS_REG_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PBUS_REG_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PBUS_FLD_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PBUS_FLD_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PBUS_REG_RD_DRF(b,d,r,f)       (((PBUS_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PFIFO registers
//******************************************************************************

#define PFIFO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]=(U032)(d)
#define PFIFO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]
#define PFIFO_REG_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFIFO_REG_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFIFO_FLD_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFIFO_FLD_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFIFO_REG_RD_DRF(b,d,r,f)       (((PFIFO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDMA registers
//******************************************************************************

#define PDMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]=(U032)(d)
#define PDMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]
#define PDMA_REG_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDMA_REG_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDMA_FLD_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDMA_FLD_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDMA_REG_RD_DRF(b,d,r,f)       (((PDMA_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PTIMER registers
//******************************************************************************

#define PTIMER_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]=(U032)(d)
#define PTIMER_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]
#define PTIMER_REG_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PTIMER_REG_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PTIMER_FLD_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PTIMER_FLD_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PTIMER_REG_RD_DRF(b,d,r,f)       (((PTIMER_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUDIO registers
//******************************************************************************

#define PAUDIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]=(U032)(d)
#define PAUDIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]
#define PAUDIO_REG_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUDIO_REG_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUDIO_FLD_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUDIO_FLD_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUDIO_REG_RD_DRF(b,d,r,f)       (((PAUDIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PGRAPH registers
//******************************************************************************

#define PGRAPH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]=(U032)(d)
#define PGRAPH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]
#define PGRAPH_REG_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PGRAPH_REG_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PGRAPH_FLD_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PGRAPH_FLD_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PGRAPH_REG_RD_DRF(b,d,r,f)       (((PGRAPH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMVIO registers (NV3)
//******************************************************************************

#define PRMVIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]=(U032)(d)
#define PRMVIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]
#define PRMVIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMVIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMVIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMVIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMVIO_REG_RD_DRF(b,d,r,f)       (((PRMVIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMVIO_REG_WR08(b,a,d)   (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]=(U008)(d)
#define PRMVIO_REG_RD08(b,a)     (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]

#define NV_SR_UNLOCK_VALUE                               0x00000057
#define NV_SR_LOCK_VALUE                                 0x00000099

//******************************************************************************
// Macros for NV_PRMCIO registers (NV3)
//******************************************************************************

#define PRMCIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]=(U032)(d)
#define PRMCIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]
#define PRMCIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMCIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMCIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMCIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMCIO_REG_RD_DRF(b,d,r,f)       (((PRMCIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMCIO_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]=(U008)(d)
#define PRMCIO_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]

//******************************************************************************
// Macros for NV_PRAMDAC registers (NV3)
//******************************************************************************

#define PRAMDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]=(U032)(d)
#define PRAMDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]
#define PRAMDAC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMDAC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMDAC_REG_RD_DRF(b,d,r,f)       (((PRAMDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USERDAC registers (NV3)
//******************************************************************************

#define USERDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]=(U032)(d)
#define USERDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]
#define USERDAC_REG_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USERDAC_REG_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USERDAC_FLD_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USERDAC_FLD_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define USERDAC_REG_RD_DRF(b,d,r,f)       (((USERDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//#ifdef PC98
#define USERDAC_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]=(U008)(d)
#define USERDAC_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]
//#endif // PC98

//******************************************************************************
// Macros for NV_PVIDEO registers (NV3)
//******************************************************************************

#define PVIDEO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]=(U032)(d)
#define PVIDEO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]
#define PVIDEO_REG_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PVIDEO_REG_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PVIDEO_FLD_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PVIDEO_FLD_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PVIDEO_REG_RD_DRF(b,d,r,f)       (((PVIDEO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))




//******************************************************************************
// CRTC Access Macros
//
// For now use the priviliged space, but we may have to switch to standard VGA i/o
//******************************************************************************

#define CRTC_WR(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CR__COLOR, (d));}
#define CRTC_RD(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        (d) = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_CR__COLOR);}

//******************************************************************************
// Macros for NV_UBETA registers
//******************************************************************************

#define UBETA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]=(U032)(d)
#define UBETA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]

//******************************************************************************
// Macros for NV_UROP registers
//******************************************************************************

#define UROP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]=(U032)(d)
#define UROP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]

//******************************************************************************
// Macros for NV_UCHROMA registers
//******************************************************************************

#define UCHROMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]=(U032)(d)
#define UCHROMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]

//******************************************************************************
// Macros for NV_UPLANE registers
//******************************************************************************

#define UPLANE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]=(U032)(d)
#define UPLANE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]

//******************************************************************************
// Macros for NV_UCLIP registers
//******************************************************************************

#define UCLIP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]=(U032)(d)
#define UCLIP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]

//******************************************************************************
// Macros for NV_UPATT registers
//******************************************************************************

#define UPATT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]=(U032)(d)
#define UPATT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]

//******************************************************************************
// Macros for NV_UPOINT registers
//******************************************************************************

#define UPOINT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]=(U032)(d)
#define UPOINT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]

//******************************************************************************
// Macros for NV_ULINE registers
//******************************************************************************

#define ULINE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]=(U032)(d)
#define ULINE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]

//******************************************************************************
// Macros for NV_ULIN registers
//******************************************************************************

#define ULIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]=(U032)(d)
#define ULIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]

//******************************************************************************
// Macros for NV_UTRI registers
//******************************************************************************

#define UTRI_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]=(U032)(d)
#define UTRI_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]

//******************************************************************************
// Macros for NV_URECT registers
//******************************************************************************

#define URECT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]=(U032)(d)
#define URECT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]

//******************************************************************************
// Macros for NV_UBTM registers
//******************************************************************************

#define UBTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]=(U032)(d)
#define UBTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]

//******************************************************************************
// Macros for NV_UQTM registers
//******************************************************************************

#define UQTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]=(U032)(d)
#define UQTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]

//******************************************************************************
// Macros for NV_UBLIT registers
//******************************************************************************

#define UBLIT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]=(U032)(d)
#define UBLIT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]

//******************************************************************************
// Macros for NV_UIMAGE registers
//******************************************************************************

#define UIMAGE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]=(U032)(d)
#define UIMAGE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]

//******************************************************************************
// Macros for NV_UBITMAP registers
//******************************************************************************

#define UBITMAP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]=(U032)(d)
#define UBITMAP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]

//******************************************************************************
// Macros for NV_UFROMEM registers
//******************************************************************************

#define UFROMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]=(U032)(d)
#define UFROMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]

//******************************************************************************
// Macros for NV_UTOMEM registers
//******************************************************************************

#define UTOMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]=(U032)(d)
#define UTOMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]

//******************************************************************************
// Macros for NV_UBTMB registers
//******************************************************************************

#define UBTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]=(U032)(d)
#define UBTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]

//******************************************************************************
// Macros for NV_UQTMB registers
//******************************************************************************

#define UQTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]=(U032)(d)
#define UQTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]

//******************************************************************************
// Macros for NV_PFB registers
//******************************************************************************

#define PFB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]=(U032)(d)
#define PFB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]
#define PFB_REG_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFB_REG_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFB_FLD_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFB_FLD_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFB_REG_RD_DRF(b,d,r,f)       (((PFB_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAM registers
//******************************************************************************

#define PRAM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]=(U032)(d)
#define PRAM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]
#define PRAM_REG_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAM_REG_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAM_FLD_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAM_FLD_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAM_REG_RD_DRF(b,d,r,f)       (((PRAM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMFC registers
//******************************************************************************

#define PRAMFC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]=(U032)(d)
#define PRAMFC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]
#define PRAMFC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMFC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMFC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMFC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMFC_REG_RD_DRF(b,d,r,f)       (((PRAMFC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMHT registers
//******************************************************************************

#define PRAMHT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]=(U032)(d)
#define PRAMHT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]
#define PRAMHT_REG_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMHT_REG_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMHT_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMHT_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMHT_REG_RD_DRF(b,d,r,f)       (((PRAMHT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUTH registers
//******************************************************************************

#define PAUTH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]=(U032)(d)
#define PAUTH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]
#define PAUTH_REG_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUTH_REG_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUTH_FLD_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUTH_FLD_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUTH_REG_RD_DRF(b,d,r,f)       (((PAUTH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_EXTDEV registers
//******************************************************************************

#define PEXTDEV_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]=(U032)(d)
#define PEXTDEV_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]
#define PEXTDEV_REG_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEXTDEV_REG_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEXTDEV_FLD_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEXTDEV_FLD_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEXTDEV_REG_RD_DRF(b,d,r,f)       (((PEXTDEV_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDAC registers
//******************************************************************************

#define PDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]=(U032)(d)
#define PDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]
#define PDAC_REG_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDAC_REG_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDAC_REG_RD_DRF(b,d,r,f)       (((PDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PEEPROM registers
//******************************************************************************

#define PEEPROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]=(U032)(d)
#define PEEPROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]
#define PEEPROM_REG_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEEPROM_REG_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEEPROM_FLD_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEEPROM_FLD_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEEPROM_REG_RD_DRF(b,d,r,f)       (((PEEPROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PROM registers
//******************************************************************************

#define PROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]=(U032)(d)
#define PROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]
#define PROM_REG_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PROM_REG_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PROM_FLD_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PROM_FLD_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PROM_REG_RD_DRF(b,d,r,f)       (((PROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PALT registers
//******************************************************************************

#define PALT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]=(U032)(d)
#define PALT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]
#define PALT_REG_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PALT_REG_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PALT_FLD_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PALT_FLD_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PALT_REG_RD_DRF(b,d,r,f)       (((PALT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRM registers
//******************************************************************************

#define PRM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]=(U032)(d)
#define PRM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]
#define PRM_REG_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRM_REG_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRM_FLD_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRM_FLD_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRM_REG_RD_DRF(b,d,r,f)       (((PRM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMIO registers
//******************************************************************************

#define PRMIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]=(U032)(d)
#define PRMIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]
#define PRMIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMIO_REG_RD_DRF(b,d,r,f)       (((PRMIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USER registers
//******************************************************************************

#define USER_REG_WR32(b,o,d)           (b)->Reg032[(o)/4]=(U032)(d)
#define USER_REG_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USER_REG_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USER_FLD_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USER_FLD_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

//******************************************************************************
// Mode Entry Structure (Taken from Resource Manager code and modified)
//******************************************************************************

#define NUM_RESOLUTIONS 18
#define NUM_REFRESHES 7
#define NUM_DEPTHS 5
#define NUM_ELEMENTS 5

extern U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS];


//******************************************************************************
// Master NVInfo Structure
//
// CAREFUL:  There are now 2 HWINFO structures, the original one (this one)
//           and the one that also exists in the RM (in nvrm.h).  Modeset.c
//           includes nvrm.h but does NOT include NV.H, so for now, this is ok.
//           (This confuses Soft-Ice though when loading symbols).
// TODO:     These structures should be renamed or consolidated to minimize confusion!
//******************************************************************************

typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 SavePmc;
        U032 SaveIntrEn0;
        U032 IntrEn0;
        U032 Implementation;
        U032 Revision;
        U032 Architecture;
        U032 Manufacturer;
        U032 Bus;
        U032 ChipToken[2];
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 IntLine;
        U032 IntPin;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 HashDepth;
        U032 RunOutMask;
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 CurrentSize;
        U032 AvailableSize[4];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 HashTableAddr;
        U032 FifoRunoutAddr;
        U032 FifoContextAddr;
        U032 AudioScratchAddr;
        U032 AuthScratchAddr;
        U032 DMATextureInstances;
    } Pram;
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
        U032 ServiceCount;
        U032 AllocateCount;
        U032 CacheDepth;
        U032 LieDepth;
        U032 RetryCount;
        U032 Count;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 DmaFetchAmount;       // Burst amount the DMA pusher should use
                                   // when reading into the FIFO
        U032 DmaWaterMark;         // Fifo level which will kick of the next
                                   // DMA burst
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Master;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 ConfigPageHeight;
        U032 RamSizeMb;
        U032 RamSize;
        U032 RamType;
        U032 RamTech;
        U032 DpmLevel;
        U032 Depth;
        U032 Resolution;
        U032 RefreshRate;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 HorizDisplayWidth;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 VertDisplayWidth;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
        U032 ServiceCount;
        U032 ActiveCount;
        U032 ActiveMask;
        U032 Start[3];
        U032 Limit[3];
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 VBlankToggle;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 MonitorType;
        U032 FilterEnable;
        U032 SaveToEEPROMEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;
        U032 Scale_y;
        U032 Instance;
        U032 DmaInstance;
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 CurrentChID;
        U032 Count;
        U032 CanvasCount;
        U032 Enabled;
        U032 ServiceCount;
        U032 ComplexClipCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Graphics;
    struct _def_video_info
    {
        U032 CurrentChID;
        U032 ColorKeyEnabled;
        U032 ScaleFactor;   // 12.20
        U032 Enabled;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScale;
        U032 VideoColorKey;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Video;
    struct _def_mediaport_info
    {
        U032 CurrentChID;
        U032 Enabled;
    } MediaPort;
    struct _def_audio_info
    {
        U032 Size;
        char ID[32];
        U032 OutLogVolumeLeft;
        U032 OutLogVolumeRight;
        U032 NoteLogVolumeLeft;
        U032 NoteLogVolumeRight;
        U032 OutLinVolumeLeft;
        U032 OutLinVolumeRight;
        U032 NoteLinVolumeLeft;
        U032 NoteLinVolumeRight;
        U032 VolumeThreshold;
        U032 MaxNotes;
        U032 MaxIOs;
        U032 NoteCount;
        U032 InCount;
        U032 OutCount;
        U032 NearMark;
        U032 BlockLength;
        U032 RateConversion;
        U032 ServiceCount;
        U032 Enabled;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Audio;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 InputWidth;
        U032 PClkVClkRatio;
        U032 VClk;
        U032 MClk;
        U032 VPllM;
        U032 VPllN;
        U032 VPllO;
        U032 VPllP;
        U032 MPllM;
        U032 MPllN;
        U032 MPllO;
        U032 MPllP;
        U032 DpmLevel;
        S032 CursorPosX;
        S032 CursorPosY;
        U032 CursorWidth;
        U032 CursorHeight;
        U008 CursorImagePlane[2][32 * sizeof(U032)];
        U032 CursorType;
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U008 CursorColorImage[32][32 * sizeof(U032)];
        S032 CursorSaveUnderPosX;
        S032 CursorSaveUnderPosY;
        U032 CursorSaveUnderWidth;
        U032 CursorSaveUnderHeight;
        U032 CursorSaveUnder[32][32];
        U032 CursorExclude;
        U032 CursorEmulation;
        U032 Palette[272];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 CursorImageInstance;
        U032 TVCursorMin;
        U032 TVCursorMax;
    } Dac;
    struct _def_codec_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 DpmLevel;
        U032 Frequency;
        U032 OutputAttenuation;
        U032 InputSource;
        U032 InputLineLogGainLeft;
        U032 InputLineLogGainRight;
        U032 InputAuxLogGainLeft;
        U032 InputAuxLogGainRight;
        U032 InputMicLogGainLeft;
        U032 InputMicLogGainRight;
        U032 InputMixLogGainLeft;
        U032 InputMixLogGainRight;
        U032 PassThruAux1LogLeft;
        U032 PassThruAux1LogRight;
        U032 PassThruAux2LogLeft;
        U032 PassThruAux2LogRight;
        U032 InputLineLinGainLeft;
        U032 InputLineLinGainRight;
        U032 InputAuxLinGainLeft;
        U032 InputAuxLinGainRight;
        U032 InputMicLinGainLeft;
        U032 InputMicLinGainRight;
        U032 InputMixLinGainLeft;
        U032 InputMixLinGainRight;
        U032 PassThruAux1LinLeft;
        U032 PassThruAux1LinRight;
        U032 PassThruAux2LinLeft;
        U032 PassThruAux2LinRight;
        U032 Monitor;
        U032 ControlPins;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Codec;
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Dgp;
    struct _def_gameport_info
    {
        U032 Size;
        char ID[32];
        U032 DevicePort;
        V032 InputTypes;
        V032 DigitalInputs;
        S032 AnalogInputs[8];
        U032 XferRateDelay;
        U032 HorizRange;
        S032 HorizCenter;
        U032 VertRange;
        S032 VertCenter;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Gameport[13];
    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
        U032 ServiceCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
    struct _def_null_info
    {
        U032 Size;
        char ID[32];
    } Null;
} HWINFO, * PHWINFO;


typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG ulChipID;         // ET3000, ET4000, W32, W32I, W32P, or ET6000
    ULONG ulRevLevel;       // REV_A, REV_B, REV_C, REV_D, REV_UNDEF
    ULONG ulVideoMemory;    // in bytes
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

typedef enum _CHIP_TYPE {
    NV3 = 1,
    NV4,
} CHIP_TYPE;

typedef enum _REV_TYPE {
    REV_UNDEF = 1,
    REV_A,
    REV_B,
    REV_C,
    REV_D,
} REV_TYPE;

//
//  NV1 PCI defines - These values should match those in NV1_REF.H
//
#define NV1_VENDOR_ID       0x10DE
#define ST1_VENDOR_ID       0x104A
#define NV1_DEVICE_VGA_ID   0x0008
#define NV1_DEVICE_NV1_ID   0x0009


//
//  NV3 PCI defines - These values should match those in NV3_REF.H
//
#define NV3_VENDOR_ID       0x12D2
#define ST3_VENDOR_ID       0x12D2
#define NV3_DEVICE_VGA_ID   0x0008
#define NV3_DEVICE_NV3_ID   0x0018
#define NV3_DEVICE_NV3_ID_2 0x0019


//
//  NV4 PCI defines - These values should match those in NV4_REF.H
//
#define NV4_VENDOR_ID                   0x10DE
#define ST4_VENDOR_ID                   0x10DE
#define NV4_DEVICE_VGA_ID               0x0008
#define NV4_DEVICE_NV4_ID               0x0020
#define NV5_DEVICE_NV5_ID               0x0028
#define NV5ULTRA_DEVICE_NV5ULTRA_ID     0x0029
#define NV5VANTA_DEVICE_NV5VANTA_ID     0x002C
#define NV5MODEL64_DEVICE_NV5MODEL64_ID 0x002D
#define NV0A_DEVICE_NV0A_ID             0x00A0
#define NV10_DEVICE_NV10_ID             0x0100
#define NV10DDR_DEVICE_NV10DDR_ID       0x0101
#define NV10GL_DEVICE_NV10GL_ID         0x0103
#define NV11_DEVICE_NV11_ID             0x0110
#define NV11DDR_DEVICE_NV11DDR_ID       0x0111
#define NV11M_DEVICE_NV11M_ID           0x0112
#define NV11GL_DEVICE_NV11GL_ID         0x0113
#define NV11_DEVICE_CRUSH11_ID          0x01A0
#define NV15_DEVICE_NV15_ID             0x0150
#define NV15DDR_DEVICE_NV15DDR_ID       0x0151
#define NV15BR_DEVICE_NV15BR_ID         0x0152
#define NV15GL_DEVICE_NV15GL_ID         0x0153
#define NV20_DEVICE_NV20_ID             0x0200
#define NV20_DEVICE_NV20_1_ID           0x0201
#define NV20_DEVICE_NV20_2_ID           0x0202
#define NV20_DEVICE_NV20_3_ID           0x0203


//////////////////////////////////////////////////////////////////////////////

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// BIOS Variables
//

#define BIOS_INFO_1 0x488
#define PRODESIGNER_BIOS_INFO 0x4E8

//
// Define type of ET4000 boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPLUS = 1,
    SPEEDSTAR24,
    SPEEDSTAR,
    PRODESIGNERIISEISA,
    PRODESIGNERIIS,
    PRODESIGNER2,
    TSENG3000,
    TSENG4000,
    TSENG4000W32,
    STEALTH32,
    TSENG6000,
    OTHER
} BOARD_TYPE;



//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//******************************************************************************
// Indices corresponding to the NV Memory ranges
//******************************************************************************

#define NV_PHYSICAL_ADDRESS_QTY         3
#define NV_PHYSICAL_BASE_ADDRESS        0
#define NV_PHYSICAL_DFB_ADDRESS         1
#define NV_PHYSICAL_REMAPPER_ADDRESS    2

#define NV_PMC_INDEX          0
#define NV_PFB_INDEX          1
#define NV_PRM_INDEX          2
#define NV_PDAC_INDEX         3
#define NV_PRAM_INDEX         4
#define NV_PRAMFC_INDEX       5
#define NV_PRAMHT_INDEX       6
#define NV_PFIFO_INDEX        7
#define NV_PBUS_INDEX         8
#define NV_PGRAPH_INDEX       9
#define NV_URECT_INDEX        10
#define NV_UTRI_INDEX         11
#define NV_UBLIT_INDEX        12
#define NV_UIMAGE_INDEX       13
#define NV_UBITMAP_INDEX      14
#define NV_CONFIG_INDEX       15
#define NV_PDMA_INDEX         16
#define NV_PTIMER_INDEX       17
#define NV_PAUDIO_INDEX       18
#define NV_PAUTH_INDEX        19
#define NV_PEXTDEV_INDEX      20
#define NV_PEEPROM_INDEX      21
#define NV_PROM_INDEX         22
#define NV_PALT_INDEX         23

#define NV_USER_INDEX          24
#define NV_PGRAPH_STATUS_INDEX 25
#define NV_PDFB_INDEX          26

#define NV_PRAMIN_INDEX        27
#define NV_PRMVIO_INDEX        28
#define NV_PRMCIO_INDEX        29

#define NV_PFB_CONFIG_0_INDEX  30
#define NV_PFB_START_ADDRESS_INDEX  31

#define NV_PRAMDAC_INDEX       32
#define NV_USERDAC_INDEX       33

#define NV_SGS_DAC_INDEX       34
#define NV_PVIDEO_INDEX        35

#define NV_NUM_RANGES          36


#define BANKED_FRAME_BUFFER 3
#define LINEAR_FRAME_BUFFER 4

//
// W32 MMU stuff
//

#define PORT_IO_ADDR                0
#define PORT_IO_LEN                 0x10000

// When we are banked

#define BANKED_MMU_BUFFER_MEMORY_ADDR          0xB8000
#define BANKED_MMU_BUFFER_MEMORY_LEN           (0xBE000 - 0xB8000)
#define BANKED_MMU_MEMORY_MAPPED_REGS_ADDR     0xBFF00
#define BANKED_MMU_MEMORY_MAPPED_REGS_LEN      (0xC0000 - 0xBFF00)
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_ADDR   0xBE000
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_LEN    (0xBF000 - 0xBE000)

#define BANKED_APERTURE_0_OFFSET   0x0000
#define BANKED_APERTURE_1_OFFSET   0x2000
#define BANKED_APERTURE_2_OFFSET   0x4000

// When we are linear

#define MMU_BUFFER_MEMORY_ADDR          0x200000
#define MMU_BUFFER_MEMORY_LEN           0x180000
#define MMU_MEMORY_MAPPED_REGS_ADDR     0x3FFF00
#define MMU_MEMORY_MAPPED_REGS_LEN      0x000100
#define MMU_EXTERNAL_MAPPED_REGS_ADDR   0x3FE000
#define MMU_EXTERNAL_MAPPED_REGS_LEN    0x001000

typedef struct {
    ULONG  ulOffset;
    ULONG  ulLength;
} RANGE_OFFSETS;

#define APERTURE_0_OFFSET   0x000000
#define APERTURE_1_OFFSET   0x080000
#define APERTURE_2_OFFSET   0x100000

#define MMU_APERTURE_2_ACL_BIT  0x04

typedef struct {
    ULONG   ulPhysicalAddress;
    ULONG   ulLength;
    ULONG   ulInIoSpace;
    PVOID   pvVirtualAddress;
} W32_ADDRESS_MAPPING_INFORMATION, *PW32_ADDRESS_MAPPING_INFORMATION;


//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// W32 CRTCB port addresses (used for ID)
//

#define CRTCB_IO_PORT_BASE    0x0000217A
#define CRTCB_IO_PORT_LEN     0x00000002

#define CRTCB_IO_PORT_INDEX   CRTCB_IO_PORT_BASE
#define CRTCB_IO_PORT_DATA    (CRTCB_IO_PORT_INDEX+1)
#define IND_CRTCB_CHIP_ID     0xEC




//
// VGA register definitions
//
#define NUM_VGA_ACCESS_RANGES  3
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define MODE_CONTROL_PORT_MONO      0x03B8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in mono mode
#define HERCULES_COMPATIBILITY_PORT 0x03BF  // used to unlock Tseng key to
                                            //  get at extended ports

#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define SEGMENT_SELECT_PORT         0x03CD  // Tseng banking control register
#define SEGMENT_SELECT_HIGH         0x03CB  // Tseng W32 SegSel extension
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define MODE_CONTROL_PORT_COLOR     0x03D8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_STATE_CONTROL       0x06    // index of TS State Control reg in Seq
#define IND_TS_AUX_MODE         0x07    // index of TS Aux Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_RAS_CAS_CONFIG      0x32    // index of RAS/CAS Config reg in CRTC
#define IND_EXT_START_ADDR      0x33    // index of Extended Start Address reg
                                        //  in CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_OFLOW_HIGH          0x35    // index of Overflow High reg in CRTC
#define IND_VID_SYS_CONFIG_1    0x36    // index of Video System Configuration
#define IND_VID_SYS_CONFIG_2    0x37    //  1 & 2 registers in CRTC
#define IND_ATC_MISC            0x16    // index of Miscellaneous reg in ATC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

#define UNLOCK_KEY_1            0x03    // value to output to Herc Compat
                                        //  register as first step in unlocking
                                        //  key so Tseng registers can be set
#define UNLOCK_KEY_2            0xA0    // value to output to Mode Control Port
                                        //  register as 2nd step in unlocking
                                        //  key so Tseng registers can be set
#define LOCK_KEY_1              0x00    // value to output to Herc Compat
                                        //  register as first step in locking
                                        //  key so Tseng registers can't be set
#define LOCK_KEY_2              0x00    // value to output to Mode Control Port
                                        //  register as 2nd step in locking
                                        //  key so Tseng registers can't be set
#define HERCULES_COMPATIBILITY_DEFAULT 0x00
                                        // value to output to Herc Compat
                                        //  register to put back to MDA
                                        //  compatibility

#define MODE_CONTROL_PORT_COLOR_DEFAULT 0x00
#define MODE_CONTROL_PORT_MONO_DEFAULT 0x00
                                        // values to output to CGA and MDA mode
                                        //  registers to put to default state
                                        //  (video disabled).

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F



//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Start;          // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    MemMgrBanking,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType;             // color or monochrome, text or graphics, via
                                //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;          // # of video memory planes
    USHORT  bitsPerPlane;       // # of bits of color in each plane
    SHORT   col;                // # of text columns across screen with default font

    SHORT   row;                // # of text rows down screen with default font
    USHORT  hres;               // # of pixels across screen
    USHORT  vres;               // # of scan lines down screen
    USHORT  wbytes;             // # of bytes from start of one scan line to start of next
    ULONG   sbytes;             // total size of addressable display memory in bytes
    ULONG   Frequency;          // Vertical Frequency
    ULONG   Interlaced;         // Determines if the mode is interlaced or not
    BANK_TYPE banktype;         // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP MemMap;    // index from VIDEO_MEMORY_MAP of memory
                                //  mapping used by this mode
    BOOLEAN ValidMode;          // Determines which modes are valid.
    ULONG   Int10ModeNumber;    // Mode number via Int 10
    PUSHORT CmdStrings;         // pointer to array of register-setting commands
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0



// 
// Added structs for control panel support
//

// For setting the current device type 
typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE, *PSETGETDEVTYPE;

// For validating a particular mode on a particular device type 
typedef struct  tagVALMODEEXTR
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwRefresh;
    unsigned long   dwDeviceType;
} VALMODEXTR;

// Size of the color lookup table cache in the device extension
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//


//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define ET4000_SEQUENCER_EXT_START     0x06
#define ET4000_SEQUENCER_EXT_END       0x07

#define ET4000_CRTC_EXT_START          0x31
#define ET4000_CRTC_EXT_END            0x37
#define ET4000_CRTC_1_EXT_START        0x3F
#define ET4000_CRTC_1_EXT_END          0x3F

#define ET4000_ATTRIB_EXT_START        0x16
#define ET4000_ATTRIB_EXT_END          0x16

//
// Number of extended regs for both chip types.
//

#define ET4000_NUM_SEQUENCER_EXT_PORTS (ET4000_SEQUENCER_EXT_END - ET4000_SEQUENCER_EXT_START + 1)
#define ET4000_NUM_CRTC_EXT_PORTS      (ET4000_CRTC_EXT_END - ET4000_CRTC_EXT_START + 1) + \
                                       (ET4000_CRTC_1_EXT_END - ET4000_CRTC_1_EXT_START + 1)
#define ET4000_NUM_ATTRIB_EXT_PORTS    (ET4000_ATTRIB_EXT_END - ET4000_ATTRIB_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     ET4000_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          ET4000_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   ET4000_NUM_ATTRIB_EXT_PORTS
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif


#define VGA_MAX_VALIDATOR_DATA       100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

//
// Dualview related status
//
#define DUALVIEW_STATUS_GRAPHICS_MODE   0x00000001
#define DUALVIEW_STATUS_ENABLE_DUALVIEW 0x80000000
#define DUALVIEW_STATUS_SECONDARY       0x40000000
#define DUALVIEW_STATUS_VIEW_ON         0x20000000
#define DUALVIEW_STATUS_MOBILE          0x10000000

// If video memory size < 12M, disable Dualview for performance concern 
#define VIDEOMEMSIZELIMIT_FOR_DUALVIEW  0xC00000

#if 0
//////////////////////
// H.AZAR: (02/15/99)
//

#define NVP_MAX_VPORTS              1
#define NVP_MAX_SURFACES            5
#define NVP_MAX_TRANSFER_BUFFERS    10

//
// Surface definition (Video or VBI) and related data
//
typedef struct _NVP_SURFACE_INFO
{
    //HANDLE              hSurface;           // DirectDraw surface handle
    ULONG               dwCaps;             // capabilites of this DD surface
    ULONG               pVidMem;            // Flat pointer to the surface
    ULONG               dwOffset;           // Offset from the base of the frame buffer
    ULONG               dwPitch;
    ULONG               dwLength;
    ULONG               dwHeight;
    ULONG               dwWidth;            // Ignored for VBI
    ULONG               dwStartLine;        // Programs Y-crop for image, and startline for vbi
    ULONG               dwPreScaleSizeX;    // Ignored for VBI.. prescale size width
    ULONG               dwPreScaleSizeY;    // Ignored for VBI.. prescale size height
    ULONG               dwFieldType;        // what field was this surface setup to capture?
    //ULONG               bAutoFlip;          // do we turn around and auto program this surface?
    ULONG               bIsFirstFieldCaptured;
    LONG                nNextSurfaceIdx;     // the next surface idx in the chain
} NVP_SURFACE_INFO, *PNVP_SURFACE_INFO;

#define NVP_MAX_EXTRA422 10
// Overlay info
typedef struct _NVP_OVERLAY {
    ULONG   dwOverlayFormat;
    ULONG   dwOverlaySrcX;
    ULONG   dwOverlaySrcY;
    ULONG   dwOverlaySrcPitch;
    ULONG   dwOverlaySrcSize;
    ULONG   dwOverlaySrcWidth;
    ULONG   dwOverlaySrcHeight;
    ULONG   dwOverlayDstWidth;
    ULONG   dwOverlayDstHeight;
    ULONG   dwOverlayDstX;
    ULONG   dwOverlayDstY;
    ULONG   dwOverlayDeltaX;
    ULONG   dwOverlayDeltaY;
    ULONG   dwOverlayColorKey;
    ULONG   dwOverlayMode;
    ULONG   aExtra422OverlayOffset[NVP_MAX_EXTRA422];   // extra memory space used for prescaling
    ULONG   dwExtra422Index;            // index of current extra surface
    ULONG   dwExtra422NumSurfaces;      // number of extra allocated surfaces
    ULONG   dwExtra422Pitch;            // extra surface pitch
    ULONG   pNvPioFlipOverlayNotifierFlat;
    ULONG   dwOverlayMaxDownScale;
    ULONG   dwOverlayBufferIndex;
    ULONG   dwReserved1;
    ULONG   dwReserved2;
} NVP_OVERLAY, *PNVP_OVERLAY;

// Transfer
typedef struct _NVP_TRANSFER_BUFFER
{
    ULONG   dwTransferId;
    ULONG   dwTransferStatus;
    ULONG   pSurfaceData;
    //LONG  nSurfaceIdx;    // Idx of surface we're transfering from
    LONG    lStartLine;
    LONG    lEndLine;
    ULONG   dwTransferFlags;
    ULONG   pDestMDL;
    LONG    nNextTransferIdx;
    LONG    nPrevTransferIdx;
} NVP_TRANSFER_BUFFER, *PNVP_TRANSFER_BUFFER;

// transfer status
#define NVP_TRANSFER_QUEUED         0x01
#define NVP_TRANSFER_IN_PROGRESS    0x02
#define NVP_TRANSFER_DONE           0x03
#define NVP_TRANSFER_FAILURE        0x04
#define NVP_TRANSFER_FREE           0xFFFFFFFF

//
// NVidia Video Port context
//
typedef struct _NVP_CONTEXT
{
    NVP_SURFACE_INFO    aVideoSurfaceInfo[NVP_MAX_SURFACES];
    NVP_SURFACE_INFO    aVBISurfaceInfo[NVP_MAX_SURFACES];
    int                 nNumVidSurf;            // number of allocated video surfaces
    int                 nNumVBISurf;            // number of allocated vbi surfaces
    int                 nVidSurfIdx;            // current video surface index
    int                 nVBISurfIdx;            // current vbi surface index
    int                 nNextVideoSurfId;
    int                 nNextVBISurfId;

    int                 nLastFieldId;           // Id of last field captured
    ULONG               bLastFieldType;         // type of last field captured (TRUE if VBI, FALSE if VIDEO)

    ULONG               dwVPState;              // NVP_STATE_STOPPED, NVP_STATE_STARTED
    ULONG               dwVPFlags;
    ULONG               dwVPConFlags;           // connection flags

    ULONG               dwChipId;               // chip version Id
    ULONG               hClient;
    ULONG               dwDeviceId;             // NV_WIN_DEVICE
    ULONG               dwOverlayObjectID;      // overlay object Id (shared object!)
    ULONG               dwScalerObjectID;       // scaler object Id
    ULONG               dwDVDSubPicObjectID;    // used for prescaling on nv4 and nv5
    ULONG               dwDVDObjectCtxDma;      // context dma used for synchronization.
    int                 nFreeCount;     // fifo free count

    // BUGBUG: hacking declerations to avoid including hardware dependent header files
    //         in "nv.h"
    ULONG               pNVPChannel;            // NvChannel *pNVPChannel; // VPE pio channel
    UCHAR               avpNotifiers[16*9];     // (Media port notifiers) NvNotification avpNotifiers[NVP_CLASS04D_MAX_NOTIFIERS];
    UCHAR               aovNotifiers[16*3];     // (Overlay notifiers) NvNotification aovNotifiers[NVP_CLASS07A_MAX_NOTIFIERS];

    // overlay
    NVP_OVERLAY         nvpOverlay;             // information retrieved from UpdateOverlay32() in Ring3
    ULONG               pOverlayChannel;        // NvChannel *pOverlayChannel; // Overlay channel
    ULONG               dwOvrSubChannel;


    // vidmem to sysmem transfer (vbi and video capture !)
    NVP_TRANSFER_BUFFER aTransferBuffers[NVP_MAX_TRANSFER_BUFFERS];
    UCHAR               axfNotifiers[16*6]; //
    int                 nCurTransferIdx;    // current transfer buffer index
    int                 nLastTransferIdx;
    int                 nRecentTransferIdx; // index of most recently transfered buffer
    int                 nNumTransfer;       // current number of transfer buffer in queue
    ULONG               bxfContextCreated;  // TRUE if context already created
    ULONG               bxfContextFlushed;  // TRUE if context flushed
    ULONG               dwTransferCtxStart; // old transfer context start
    ULONG               dwTransferCtxSize;  // transfer size

    ULONG               hVPSyncEvent;       // media port Vsync event handle // PKEVENT hVSyncEvent;

    // DMA push buffer
    PVOID               pDmaChannel;
    ULONG               *nvDmaFifo;
    ULONG               nvDmaCount;
    ULONG               DmaPushBufTotalSize;    // 32 DWORDs
    UCHAR               DmaPushBufErrNotifier[16*1];

} NVP_CONTEXT, *PNVP_CONTEXT;

//////////////////////
#endif

//
// EDID cache structure
//
typedef struct _EDID_UNIT
{
    UCHAR EDIDBuffer[EDID_V2_SIZE];
    ULONG Valid;
    ULONG Size;
} EDID_UNIT, *PEDID_UNIT, *LPEDID_UNIT;

typedef struct _EDID_COLLECTION
{
    LPEDID_UNIT HeadMaps[NV_NO_CONNECTORS];
    EDID_UNIT   EdidUnits[0];
} EDID_COLLECTION, *PEDID_COLLECTION, *LPEDID_COLLECTION;

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344
#define QUERY_MONITOR_ID2           QUERY_MONITOR_ID+1
#define QUERY_NONDDC_MONITOR_ID2    QUERY_NONDDC_MONITOR_ID+1
#define QUERY_ACPI_CRT_ID           0x0100
#define QUERY_ACPI_DFP_ID           0x0110
#define QUERY_ACPI_TV_ID            0x0200

#define NVCAP_I2C_DEVICE_ID         0xCA000002
#define NVXBAR_I2C_DEVICE_ID        0xCA000003
#define NVTUNER_I2C_DEVICE_ID       0xCA000004
#define NVTVSND_I2C_DEVICE_ID       0xCA000005

#define DISPLAY_ADAPTER_HW_ID       0xFFFFFFFF

#define I2C_ACCESS_DYNAMIC_PORT     0
#define I2C_ACCESS_PRIMARY_PORT     1
#define I2C_ACCESS_SECONDARY_PORT   2

#define I2C_PORT_FREE               0
#define I2C_PORT_ACQUIRED           1

#define I2C_PORT_TIMEOUT            0xB2D05E00  // 5 minutes in NT system timer

//
// I2C port structure
//
typedef struct _I2C_PORT
{
    ULONG                   ulStatus;   /* Status of I2C port (Acquired/Free) */
    ULONG                   ulOwner;    /* Current owner of I2C port (PDO) */
    LARGE_INTEGER           lTimeStamp; /* Time stamp of last port access */
    NVRM_I2C_ACCESS_CONTROL rmI2CCtrl;  /* RM I2C control structure */
} I2C_PORT, *PI2C_PORT, *LPI2C_PORT;

//
// Child device structure
//
typedef struct _CHILD_DEVICE
{
    ULONG           ulPDO;          /* PDO of the child device */
    ULONG           ulHwID;         /* Hardware ID of the child device */
} CHILD_DEVICE, *PCHILD_DEVICE, *LPCHILD_DEVICE;

#if _WIN32_WINNT <= 0x0501

VIDEOPORT_API
ULONG
VideoPortGetAssociatedDeviceID(
    IN PVOID DeviceObject
    );

#endif

//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PUCHAR  VgaPortRange[NUM_VGA_ACCESS_RANGES];
                                  // Non-palette related VGA regs
    PVOID   VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   AdapterMemorySize;    // size, in bytes, of the memory on the
                                  // board.
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    ULONG   NumRegistryModes;     // number of modes specified from registry/vesadata
    ULONG   NumAvailableModes;    // number of valid modes on this device for first head
    ULONG   NumAvailableModes1;    // number of valid modes on this device for second head.
    ULONG   NonPrimaryDevice;     // Denotes if system was booted on this device

//    PVIDEOMODE  CurrentMode;    // pointer to VIDEOMODE structure for
//                                // current mode.

    PMODE_ENTRY  CurrentMode;     // pointer to MODE_ENTRY structure for
                                  // current mode.

    ULONG   ulChipID;
    REV_TYPE    ulRevLevel;
    WCHAR LegacyPnPId[8];         // legacy PnP ID

    USHORT  FontPelColumns;       // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    NV_CURSOR_INFO NvCursorInfo;  // Cursor position and other info

    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

    USHORT BoardID;               // Used to Identify Diamond boards
    UCHAR  DriverRegPath[128];    // The name of registry path ofthis device
    
    //**************************************************************************
    // OLD Style modeset code
    // ModeTiming table  (represents modes that are valid for this adapter)
    // This needs to be put here in the hw device extension for multi adapter
    // configurations. (still used by NV3)
    //**************************************************************************

    MODE_ENTRY fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS*NUM_REFRESHES];

    //**************************************************************************
    // NEW Style modeset code
    // Allocate a table which will contain all valid modes
    //**************************************************************************
    USHORT ValidModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS];

    //***************************************************************************
    // The OEM-specific and monitor-specific restriction mode lists.
    //***************************************************************************
    USHORT RestrictionModeTable0[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the first head
    USHORT RestrictionModeTable1[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the second head
    ULONG  NumRestrictionModes0; // Number of monitor restriction modes for head0
    ULONG  NumRestrictionModes1; // Number of monitor restriction modes for head1

    //**************************************************************************
    // Used to keep track of where to story parsed registry data
    //**************************************************************************

    ULONG RegistryDataOffset;

    //**************************************************************************
    // Structure containing registry switch data
    //**************************************************************************

    NT_NV_REGISTRY NV_Registry_Table;

    //**************************************************************************
    // Saved BIOS image (64k)
    //**************************************************************************

    UCHAR SavedBiosImageArray[SAVED_BIOS_IMAGE_SIZE];

    //**************************************************************************
    // Saved instance memory (128k)
    //**************************************************************************

    UCHAR SavedInstanceMemory[MAX_INSTANCE_MEM_SIZE];
    ULONG TotalInstanceMemory;

    //**************************************************************************
    // NV1 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV1Registers;     // NV1 initialization registers
    ULONG  NV1RegistersLength;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PMC_Registers;    // NV1 Master Control Registers
    PHWREG NV1_Lin_PMC_Registers;      // Linear address to Master Control Registers
    ULONG  NV1_PMC_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFB_Registers;    // NV1 Frame Buffer Control Registers
    PHWREG  NV1_Lin_PFB_Registers;     // Linear address to Frame Buffer Control Registers
    ULONG  NV1_PFB_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRM_Registers;    // NV1 Real Mode Control Registers
    PHWREG  NV1_Lin_PRM_Registers;     // Linear address to Real Mode Control Registers
    ULONG  NV1_PRM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDAC_Registers;   // NV1 DAC Registers
    PHWREG  NV1_Lin_PDAC_Registers;    // Linear address to DAC Registers
    ULONG  NV1_PDAC_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAM_Registers;   // NV1 RAM Registers
    PHWREG  NV1_Lin_PRAM_Registers;    // Linear address to RAM Registers
    ULONG  NV1_PRAM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMFC_Registers; // NV1 RAMFC Registers
    PHWREG  NV1_Lin_PRAMFC_Registers;  // Linear address to RAMFC Registers
    ULONG  NV1_PRAMFC_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMHT_Registers;   // NV1 RAMHT Registers
    PHWREG  NV1_Lin_PRAMHT_Registers;    // Linear address to RAMHT Registers
    ULONG  NV1_PRAMHT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_USER_Registers;   // NV1 USER Registers
    PHWREG  NV1_Lin_USER_Registers;    // Linear address to USER Registers
    ULONG  NV1_USER_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFIFO_Registers;  // NV1 FIFO Registers
    PHWREG  NV1_Lin_PFIFO_Registers;   // Linear address to FIFO Registers
    ULONG  NV1_PFIFO_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PBUS_Registers;   // NV1 PBUS Registers
    PHWREG  NV1_Lin_PBUS_Registers;    // Linear address to PBUS Registers
    ULONG  NV1_PBUS_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PGRAPH_Registers; // NV1 PGRAPH Registers
    PHWREG  NV1_Lin_PGRAPH_Registers;  // Linear address to PGRAPH Registers
    ULONG  NV1_PGRAPH_Length;          // NV1 register window



    PHYSICAL_ADDRESS NV1_Phys_CONFIG_Registers; // NV1 Config Registers
    PHWREG NV1_Lin_CONFIG_Registers;   // Linear address to Config Registers
    ULONG  NV1_CONFIG_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_MEM_Registers;    // NV1 Mermory Registers
    PHWREG NV1_Lin_MEM_Registers;      // Linear address to Memory Registers
    ULONG  NV1_MEM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_IO_Registers;     // NV1 IO Registers
    PHWREG NV1_Lin_IO_Registers;       // Linear address to IO Registers
    ULONG  NV1_IO_Length;              // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDMA_Registers;   // NV1 DMA Registers
    PHWREG NV1_Lin_PDMA_Registers;     // Linear address to DMA Registers
    ULONG  NV1_PDMA_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PTIMER_Registers; // NV1 Timer Registers
    PHWREG NV1_Lin_PTIMER_Registers;   // Linear address to Timer Registers
    ULONG  NV1_PTIMER_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUDIO_Registers; // NV1 Audio Registers
    PHWREG NV1_Lin_PAUDIO_Registers;   // Linear address to Audio Registers
    ULONG  NV1_PAUDIO_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUTH_Registers;  // NV1 Authority Registers
    PHWREG NV1_Lin_PAUTH_Registers;    // Linear address to Authority Registers
    ULONG  NV1_PAUTH_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEXTDEV_Registers; // NV1 Extdev Registers
    PHWREG NV1_Lin_PEXTDEV_Registers;   // Linear address to Extdev Registers
    ULONG  NV1_PEXTDEV_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEEPROM_Registers;// NV1 Eeprom Registers
    PHWREG NV1_Lin_PEEPROM_Registers;  // Linear address to Eeprom Registers
    ULONG  NV1_PEEPROM_Length;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PROM_Registers;   // NV1 ROM Registers
    PHWREG NV1_Lin_PROM_Registers;     // Linear address to ROM Registers
    ULONG  NV1_PROM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PALT_Registers;   // NV1 Alt Registers
    PHWREG NV1_Lin_PALT_Registers;     // Linear address to Alt Registers
    ULONG  NV1_PALT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRMIO_Registers;  // NV1 Real Mode IO Registers
    PHWREG NV1_Lin_PRMIO_Registers;    // Linear address to Real Mode IO Registers
    ULONG  NV1_PRMIO_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_URECT_Registers;  // NV1 User Rectangle Registers
    PHWREG NV1_Lin_URECT_Registers;    // Linear address to User Rectangle Registers
    ULONG  NV1_URECT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UTRI_Registers;  // NV1 User Triangle Registers
    PHWREG NV1_Lin_UTRI_Registers;    // Linear address to User Triangle Registers
    ULONG  NV1_UTRI_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBLIT_Registers;  // NV1 User BLIT Registers
    PHWREG NV1_Lin_UBLIT_Registers;    // Linear address to User BLIT Registers
    ULONG  NV1_UBLIT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UIMAGE_Registers;  // NV1 User IMAGE Registers
    PHWREG NV1_Lin_UIMAGE_Registers;    // Linear address to User IMAGE Registers
    ULONG  NV1_UIMAGE_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBITMAP_Registers;  // NV1 User IMAGE MONO Registers
    PHWREG NV1_Lin_UBITMAP_Registers;   // Linear address to User IMAGE MONO Registers
    ULONG  NV1_UBITMAP_Length;          // NV1 register window

    //**************************************************************************
    // NV3 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV3_Phys_PRAMIN_Registers;   // NV3 RAMIN Registers
    PHWREG  NV3_Lin_PRAMIN_Registers;   // Linear address to RAMIN Registers
    ULONG  NV3_PRAMIN_Length;           // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMVIO_Registers;   // NV3 PRMVIO Registers
    PHWREG  NV3_Lin_PRMVIO_Registers;    // Linear address to PRMVIO Registers
    ULONG  NV3_PRMVIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMCIO_Registers;   // NV3 PRMCIO Registers
    PHWREG  NV3_Lin_PRMCIO_Registers;    // Linear address to PRMCIO Registers
    ULONG  NV3_PRMCIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRAMDAC_Registers;   // NV3 PRAMDAC Registers
    PHWREG  NV3_Lin_PRAMDAC_Registers;  // Linear address to PRAMDAC Registers
    ULONG  NV3_PRAMDAC_Length;          // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_USERDAC_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_USERDAC_Registers;  // Linear address to USERDAC Registers
    ULONG  NV3_USERDAC_Length;          // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PVIDEO_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_PVIDEO_Registers;   // Linear address to USERDAC Registers
    ULONG  NV3_PVIDEO_Length;           // NV3 register window

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBase; // physical memory address and
    ULONG PhysicalFrameLength;          // length of display memory for the

    ULONG TextureDataLength;            //  Length of allocated texture data in Sys Mem

    ULONG DMABufferLength;              //  Length of allocated texture data in Sys Mem

    ULONG DMAPushLength;                // Size of DMA Push Buffer
    PVOID FrameBufferPtr;               // Get access to frame buffer

    //**************************************************************************
    // NV Software structures
    //**************************************************************************

    ULONG HashTable[HASH_DEPTH*256*2];   // Our local hash table
    ULONG ColorFormatTable[5];         // Color format conversion table
    GRAPHICSCHANNEL GrTable;           // Currently using 1 channel only
    FIFO FifoTable;                    // Currently using 1 channel only
    RENDEROBJECT RenderObject[15];     // Allocate up to 15 objects for now
    COMMONOBJECT CommonObject[10];     // Allocate up to 10 NON Render objects
    HWINFO NvInfo;                     // NVInfo structure information
    UCHAR CRTC[64];                    // Holds CRTC values
    UCHAR FreeInstanceUsage[NV_PRAM_MIN_SIZE_INSTANCE_MEM / 16];
                                       // Array denoting usage of FreeInstance mem
                                       // Each byte represents 1 paragraph of instance mem

    ULONG LastInstanceIndex;      //
    ULONG DisableVBlankFlag;      // Check for VBlank in OpenGL?
    PUSHORT BiosArea;             // address of the BIOS area
    USHORT OriginalBiosData;      // Orignal value in the Bios data area.

    BOOLEAN bLinearModeSupported; // Do we support linear modes?
    BOOLEAN bInLinearMode;        // Are we currently in a linear mode?
    ULONG ulSlot;                 // the slot that the card is in

    //**************************************************************************
    // Denotes if Flat panel is active or not
    //**************************************************************************

    BOOLEAN FlatPanelIsPresent;
    BOOLEAN TvIsPresent;
    BOOLEAN FlatPanelIsOff[NV_NO_DACS];

    //**************************************************************************
    // Max width and height of display (detected by RM)
    //**************************************************************************

    ULONG   MaxFlatPanelWidth;
    ULONG   MaxFlatPanelHeight;

    //**************************************************************************
    // Flag to denote if driver is being installed during unattended install
    //**************************************************************************

    BOOL    DeviceMappingFailed;
    
    //**************************************************************************
    // Save last DPMS state
    //**************************************************************************

    ULONG   CurrentDPMSState;
    
    //**************************************************************************
    // Used to save/restore power managment related registers for Win2k
    //**************************************************************************

    ULONG   Power_refresh;
    ULONG   Power_PfbBoot0;
    ULONG   Power_PfbConfig0;
    ULONG   Power_PfbConfig1;
    ULONG   Power_PfbMrs;
    ULONG   Power_PfbEmrs;
    ULONG   Power_PfbRef;
    ULONG   Power_PbusDebug1;
    ULONG   Power_PextdevBoot0;
    ULONG   Power_PfifoRamHT;
    ULONG   Power_PfifoRamRO;
    ULONG   Power_PfifoRamFC;    
    ULONG   Power_coeff_select;
    ULONG   Power_nvpll;
    ULONG   Power_vpll;
    ULONG   Power_mpll;

    ULONG   Master_Enable;
    ULONG   Fifo_Mode    ;
    ULONG   Numerator    ;
    ULONG   Denominator  ;
    ULONG   PCINV19      ;

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM
    FLONG   flMapMemory;            // Flags passed to VideoPortMapMemory for mapping fb
    BOOLEAN bHwVidOvl;              // Is hw video overlay supported in the current mode?
    ULONG   bEnableIF09;             // Should we support IF09 format video data?
    ULONG   bUseDMT;                // Did a registry flag indicate we should use DMT
                                    // monitor timings?
    ULONG   ulTimingOverrideTwinViewInfo[NV_NO_DACS]; // DMT/GTF/Auto override specifed in the
                                    // TwinViewInfo registry structure. This makes the 
                                    // bUseDMT field obsolete. Delete the bUseDMT field later.

    // MP/RM integration...
    PHWREG      NvRegisterBase;
    PHWREG      FrameBufferBase;
    ULONG       DeviceReference;

    ULONG       curAdapterPowerState;      // Last known power state of the adapter
    ULONG       curMonitorPowerState;      // Last known power state of the monitor

    ULONG       ulRmTurnedOffMonitor;     // Last known value power state of monitor
                                    // This field is obsolete and will be deleted later.

#if _WIN32_WINNT < 0x0500
    ULONG       bExtRefreshDisable;     // DWORD is defined in INF file
#endif // #if _WIN32_WINNT < 0x0500
    ULONG       bMax16x12;
    ULONG       bDisable19x12x32at60;
    ULONG       bDisable19x10x32ge70;
    ULONG       bDisable16x12x32ge70;
    ULONG       ulDisableDfpModesGreaterThan;
    ULONG       bDellSwitch1;
    ULONG       OglStencilSwitch;
    ULONG       ulForceSwCursor;

    ULONG       Via694ChipsetFound;
    ULONG       AMD751ChipsetFound;
    USHORT      AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
    ULONG       AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
    PHWREG      AMD751_BAR1_Mapped_Address;
    ULONG       AliChipset_Problem_Found;
    PVOID       AliFixupIOBase;
    ULONG       LastWidth;
    ULONG       LastHeight;
    ULONG       LastDepth;
    ULONG       LastRefreshRate;

    ULONG       SavedPMCState;


    ULONG       BiosRevision;
    PUCHAR      pBios;
#if _WIN32_WINNT >= 0x0500
    BOOLEAN     bAgp;
    BOOLEAN     bDisableAgp;
    VIDEO_PORT_AGP_SERVICES AgpServices;
    PHYSICAL_ADDRESS AgpAddressRange;
    ULONG       AgpPagesTotal;
    PVOID       *AgpPhysContext;
    PVOID       dummyVirtualContext;
    PVOID       AgpHeapBase;
    PVOID       AgpVirtualBaseAddress;
    ULONGLONG   SystemMemorySize;
    struct _HW_DEVICE_EXTENSION *pDualViewAssociatedDE;
    ULONG       ulDualViewStatus;
#endif // #if _WIN32_WINNT >= 0x0500

    // per-device PCI addresses
    VIDEO_ACCESS_RANGE NVAccessRanges[NV_PHYSICAL_ADDRESS_QTY];


// Added to support gamma clut support
   VIDEO_CLUT       GammaCache;
   VIDEO_CLUTDATA   GammaCacheData[NV_NO_DACS*256];    // Make it 256 just to be safe...

// Added to support GTF or DMT method selection
    ULONG   bUseGTF; // Did a registry flag indicate we should use GTF?
    // On the fly valid device mode work area
    USHORT ValidDeviceModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS];

    // VPE integration
    ULONG       BusInterruptLevel;
    ULONG       BusInterruptVector;
    PVOID       IRQCallback;
    PVOID       pIRQData;
    ULONG       dwIRQSources;

#ifdef NVPE
    /////////// 
    // H.AZAR: (02/15/99)
    NVP_CONTEXT avpContexts[NVP_MAX_VPORTS];
    ULONG       dwVPEEnabled;       // TRUE Enabled/default, FALSE disabled (registry key)
    ///////////
#endif // NVPE

    // Added for new I2C interface support (DDC-CI) [Not using child structures]
    I2C_PORT        I2C_Ports[2];           // I2C port structures
    ULONG           I2C_Reference_Count;    // I2C version 2 reference count
    ULONG           (*pfnVideoPortGetAssociatedDeviceID) (PVOID);
    CHILD_DEVICE    Child_Devices[8];       // Child device structures

    // TwinView related fields with info about the dacs.
    //**************************************************************************
    // Saved EDID Buffer
    //**************************************************************************
    LPEDID_COLLECTION EdidCollection;
    BOOLEAN bNeedRetrieveEDID;

    BOOLEAN bRmInitialized;
    // TRUE if we are on a ACPI system (such as laptops).
    ULONG   ACPISystem;

    // 1 if any high res modeset has occurred. 0 if any modeset has not yet occurred, i.e. we are in the 
    // early parts of the system bootup.
    ULONG SystemModeSetHasOccurred;

    //
    // The max pixelclock frequencies of each head as returned by ResMan.
    // Note: if CRT is connected for second head, only then should we
    // use the pixel clock for the second head. Otherwise, we use the pixel clock of
    // DAC 0 for both heads.
    //
    ULONG maxPixelClockFrequency_8bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_16bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_32bpp[NV_NO_DACS];

    //
    // We create a mapping array from Win2K's power state to NVidia's supported power states
    //
    ULONG NVMonitorPowerState[NV_NO_DACS][MAX_WIN2K_POWER_STATES];
    ULONG NVAdapterPowerState[MAX_WIN2K_POWER_STATES];

    //
    // 0: Desktop
    // 1,2: Laptops (DELL, Toshiba).
    // NOTE: The miniport should not refer to this registry key. This will be deleted eventually.
    //
    ULONG Mobile;

    ULONG   UseHWSelectedDevice;        // BIOS devices take precedence over windows devices.
    ULONG   UseHotKeySameMode;          // On hot key switches, keeps the same desktop mode (resolution,depth).
                                        // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                        // This field is obsolete now since no OEM is using this feature curently.
    ULONG   PanScanSelection;           // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                        // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                        // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG   EnableModesetStopImage;     // Sony specific feature to STOP_IMAGE during modesets and 
                                        // DPMS power on.
    ULONG   DFPAsDefaultMonitor;        // If the registry entry is1, does not export the EDID of the DFP to 
                                        // Win2K causing the DFP to show up as default monitor. 
                                        // This is done for Dell laptop.
    ULONG   EnumerateTVAsACPIDevice;    // On systems such as Dell laptop, miniport should enumerate TV as
                                        // an ACPI device since SBIOS is not enumerating TV.
    ULONG   GDIModePruning;             // Absent or 0: Driver always provides EDID mode pruning protection.
                                        // 1:   For desktop or laptop systems, for CRT, for the
                                        //      standard mode device and the primary device in clone mode and
                                        //      both devices in XP DualView mode, lets the GDI handle EDID 
                                        //      mode pruning via "Hide Modes" monitor checkbox.
                                        // 2:   For desktop systems only, for CRT or DFP, for the
                                        //      standard mode device and the primary device in clone mode and
                                        //      both devices in XP DualView mode, lets the GDI handle EDID 
                                        //      mode pruning via "Hide Modes" monitor checkbox.
                                        //
    ULONG   ulDFPSupports1400x1050;     // If the builtin DFP of the laptop supports 1400x1050 or not.
    ULONG   ulHotKeyPending;            // 1 if miniport has a hotkey pending to be done by the display driver.
                                        // Then the display will ignore the BOOT_HEADS.
    ULONG   ulUniquenessVGA;            // The unique integer ID for the ppdev
                                        // of the last IOCTL_RESET_DEVICE.
    ULONG   ulNVSVCStatus;               // Started, Stoped or Paused status of the NVSVC service.
    ULONG   ulInduceModeChangeDeviceMask; // The device mask/masks used by the NVSVC to induce mode change.


    VOID    *pFPStateSave;              // To do Floating point state save/restore for common modeset.mhd code.
                                        // Should be typecast as KFLOATING_SAVE
    VOID    *pFPMutex;                  // To disable interrupts during floating point opearations for common modeset.mhd code.
                                        // Should be typecast as FAST_MUTEX.
    
    NV_DESKTOP_INFO DeskTopInfo;         // Information about the virtual desktop
    ULONG ulMaxTVOutResolution;          // Max TV resolution for common mode set code.
    ULONG ulTVEncoderType;               // TV encoder info
    ULONG ulTVEncoderID;                 // TV encoder info
    NVTWINVIEWDATA SaveSettings[NUM_ENTRIES_SAVE_SETTINGS]; // Saved settings for each device combo.
    // End TwinView related fields

#if (_WIN32_WINNT >= 0x0500)
    // macrovision
    ULONG ulCurrentMacrovisionKey;
    ULONG ulNextMacrovisionKey;
    ULONG ulMacrovisionMode;
#endif

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;



//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR PlanarHCBankSwitchStart;
extern UCHAR EnablePlanarHCStart;
extern UCHAR DisablePlanarHCStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

extern MEMORYMAPS MemoryMaps[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;

extern RANGE_OFFSETS RangeOffsets[NV_NUM_RANGES];

extern VIDEO_ACCESS_RANGE VgaAccessRange[];
extern VIDEO_ACCESS_RANGE VgaPaletteAccessRange;

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];



//
// These are macros used to call the VideoPort AGP functions. Their
// purpose is to make the code more readable. VideoPortGetAGPServices
// MUST be called prior to invoking these macros.
//
#define VideoPortAgpReservePhysical(_HwDeviceExt, _Pages, _Caching, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReservePhysical((_HwDeviceExt), (_Pages), \
                (_Caching), (_PhysContext))

#define VideoPortAgpReleasePhysical(_HwDeviceExt, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReleasePhysical((_HwDeviceExt), (_PhysContext))

#define VideoPortAgpCommitPhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitPhysical((_HwDeviceExt), (_PhysContext), \
                _Pages, _Offset)

#define VideoPortAgpFreePhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreePhysical((_HwDeviceExt), \
                (_PhysContext), (_Pages), (_Offset))

#define VideoPortAgpReserveVirtual(_HwDeviceExt, _Pid, _PhysContext, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReserveVirtual((_HwDeviceExt), (_Pid), \
                (_PhysContext), (_VirtContext))

#define VideoPortAgpReleaseVirtual(_HwDeviceExt, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReleaseVirtual((_HwDeviceExt), (_VirtContext))

#define VideoPortAgpCommitVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

#define VideoPortAgpFreeVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreeVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

//******************************************************************************
// Capabilities flags
//
// These are private flags passed to the NV display driver.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the display drivers 'driver.h'!
//******************************************************************************

typedef enum {
  CAPS_NV1_IS_PRESENT       = 0x00000010,   // NV1 Chip is present
  CAPS_NV3_IS_PRESENT       = 0x00000020,   // NV3 Chip is present
  CAPS_NV4_IS_PRESENT       = 0x00000040,   // NV4 Chip is present
  CAPS_NV5_IS_PRESENT       = 0x00000080,   // NV5 Chip is present
  CAPS_NV5VANTA_IS_PRESENT  = 0x00000100,   // NV5 VANTA Chip is present
  CAPS_NV5ULTRA_IS_PRESENT  = 0x00000200,   // NV5 ULTRA Chip is present
  CAPS_NV0A_IS_PRESENT      = 0x00000400,   // NV0A Chip is present
  CAPS_NV10_IS_PRESENT      = 0x00000800,   // NV10 Chip is present
  CAPS_NV5MODEL64_IS_PRESENT= 0x00001000,   // NV5 MODEL64 Chip is present
  CAPS_NV10DDR_IS_PRESENT   = 0x00002000,   // NV10 DDR Chip is present
  CAPS_NV10GL_IS_PRESENT    = 0x00004000,   // NV10 GL Chip is present
  CAPS_NV11_IS_PRESENT      = 0x00008000,   // NV11 Chip is present
  CAPS_NV11DDR_IS_PRESENT   = 0x00010000,   // NV11 DDR Chip is present
  CAPS_NV11GL_IS_PRESENT    = 0x00020000,   // NV11 GL Chip is present
  CAPS_NV15_IS_PRESENT      = 0x00040000,   // NV15 Chip is present
  CAPS_NV15DDR_IS_PRESENT   = 0x00080000,   // NV15 DDR Chip is present
  CAPS_NV15GL_IS_PRESENT    = 0x00100000,   // NV15 GL Chip is present
  CAPS_NV15BR_IS_PRESENT    = 0x00200000,   // NV15 BR Chip is present
  CAPS_NV20_IS_PRESENT      = 0x00400000,   // NV20 Chip is present
  CAPS_NV11M_IS_PRESENT     = 0x00800000,   // NV11M Chip is present
  CAPS_CRUSH11_IS_PRESENT   = 0x01000000,   // CRUSH11 Chip is present
  CAPS_SW_POINTER           = 0x40000000,   // No hardware pointer; use software simulation


} CAPS;

//**********************************************************************************
// Defines for VESA power management function.
//**********************************************************************************
#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f

#if DBG
VOID DbgBreakPoint(VOID);
#define NvDbgBreak() DbgBreakPoint();
#else
#define NvDbgBreak()
#endif

//******************************************************************************
// External declarations.
//******************************************************************************
BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION);
VOID NVUpdateRegNVInfo(PHW_DEVICE_EXTENSION);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
ULONG NVMapMemoryRanges(PVOID);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NVSetBiosInfo(PHW_DEVICE_EXTENSION);
VOID wtoa(USHORT, PUCHAR, UCHAR, UCHAR);

#if _WIN32_WINNT < 0x0500
ULONG wcslen(PWCHAR pString);
#endif // #if _WIN32_WINNT < 0x0500

#if _WIN32_WINNT >= 0x0500
VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
#endif

//
//
//
VP_STATUS DetectDevice(PHW_DEVICE_EXTENSION   pHDE,                             // our devices 'global' data struct
                        PCI_SLOT_NUMBER       psnSlot,                          // the slot to check
                        ULONG                 ulNumAccessRanges,                // is needed the to claim the resources, for now it's always 2
                        PVIDEO_ACCESS_RANGE   pAccessRanges,                    // if bClaimResources == TRUE this exports the device's mapping
                        USHORT                *pusVendorID,
                        USHORT                *pusDeviceID,
                        BOOLEAN               *pbIsPrimaryDevice,
                        BOOLEAN               bClaimResources);


VP_STATUS DetectNextDevice( IN      PHW_DEVICE_EXTENSION  pHDE, 
                            IN OUT  ULONG                 *pulPrevDevice,           // can be 0xffffffff : start looking at dev 0 and must be lower than 32 (5bit)
                            IN      ULONG                 ulNumAccessRanges,
                               OUT  PVIDEO_ACCESS_RANGE   pAccessRanges, 
                               OUT  USHORT                *pusVendorID,
                               OUT  USHORT                *pusDeviceID,
                               OUT  BOOLEAN               *pbIsPrimaryDevice,
                            IN      BOOLEAN                 bClaimResources);


//******************************************************************************
// Normally we would include #ntddk.h, but that would include a bunch
// of other structures that would cause redefinitions / errors.
//******************************************************************************

extern ULONG HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

extern ULONG HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;


extern PVOID ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

extern PVOID ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

extern PVOID ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

extern VOID ExFreePool(
    IN PVOID P
    );

#if _WIN32_WINNT >= 0x0500

#ifndef VIDEO_CHILD_DETACHED
#define VIDEO_CHILD_DETACHED    0x2
#endif //#ifndef VIDEO_CHILD_DETACHED

#ifndef IOCTL_VIDEO_SWITCH_DUALVIEW
#define IOCTL_VIDEO_SWITCH_DUALVIEW \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif //#ifndef IOCTL_VIDEO_SWITCH_DUALVIEW

#ifndef VIDEO_DUALVIEW_REMOVABLE
#define VIDEO_DUALVIEW_REMOVABLE    1
#endif //#ifndef VIDEO_DUALVIEW_REMOVABLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv3a_ref.h ===
/* @(#) $Header: /drivers/display/WINNT40/miniport/NV_MINI/NV3A_REF.H 2     1/10/97 7:10p Vidall $
 NVidia Corporation */
/* basis: nv1 manuals 10.1
 95/06/27 NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
#define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
#define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
#define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
#define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
#define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID               31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                       15:0 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID               31:16 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                       15:0 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
#define NV_CONFIG_PCI_NV_23(i)                   (0x0000005C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_23__SIZE_1                              41 /*       */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_23_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_23_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_RMA_ID                                        0x00000000 /* R--4R */
#define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
#define NV_RMA_ID_CODE                                         31:0 /* C--UF */
#define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
#define NV_RMA_PTR                                       0x00000004 /* RW-4R */
#define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
#define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
#define NV_RMA_DATA                                      0x00000008 /* RW-4R */
#define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
#define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
#define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
#define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
#define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
#define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
#define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
#define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
#define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
#define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
#define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
#define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
/* dev_bus.ref */
#define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
#define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
#define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
#define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
#define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS                  4:4 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_FALSE     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_TRUE      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE               25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VPLL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_XTALOSC  0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000010 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCK                 29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000010 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000100 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000011 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000010 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
#define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
#define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
#define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
#define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
#define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
#define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
#define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
#define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
#define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
#define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
#define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000011 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_1                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_2                     0x00000002 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_C                    0x00000002 /* C---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV2MUTARA           0x00000004 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000005 /* R---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
#define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_23(i)                     (0x0000185C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_23__SIZE_1                                41 /*       */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
#define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
#define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_audio.ref */
#define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
#define NV_PAUDIO_PINS                                   0x00300000 /* RW-4R */
#define NV_PAUDIO_PINS_SI_DELAY                                 0:0 /* RWIVF */
#define NV_PAUDIO_PINS_SI_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SI_EDGE                                  1:1 /* RWIVF */
#define NV_PAUDIO_PINS_SI_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_DELAY                                 4:4 /* RWIVF */
#define NV_PAUDIO_PINS_SO_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_EDGE                                  5:5 /* RWIVF */
#define NV_PAUDIO_PINS_SO_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_FMT_AC97                                 8:8 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL                                   9:9 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SERIAL_ENABLED                    0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_LEFT_JUST                              10:10 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_SENSE                             11:11 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_LOW                          0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_LEFT_HIGH                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL                                14:12 /* RWIVF */
#define NV_PAUDIO_PINS_CONTROL_0                         0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_CONTROL_1                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_2                         0x00000002 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_3                         0x00000003 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_4                         0x00000004 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_5                         0x00000005 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_6                         0x00000006 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_7                         0x00000007 /* RW--V */
#define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
#define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
#define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_CODEC_WARM                            8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_WARM_END                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_WARM_UP                  0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
#define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
#define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_OVFL                                8:8 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_OVFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_OVFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_OVFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_UNFL                              12:12 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_UNFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_UNFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_UNFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
#define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
#define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
#define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
#define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2                                 0x00300108 /* RW-4R */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE                           0:0 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT                            8:8 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_PENDING           0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_RESET             0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3                                 0x0030010C /* RW-4R */
#define NV_PAUDIO_INTR_3_PINS_0                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_0_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_0_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_0_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_1                                 4:4 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_1_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_1_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_1_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_2                                 8:8 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_2_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_2_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_2_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_3                               12:12 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_3_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_3_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_3_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
#define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL                             8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL                           12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
#define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_2                              0x00300148 /* RW-4R */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE                        0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_NOT_PENDING     0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_PENDING         0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_RESET           0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT                         4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT                         8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR                     12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_PENDING        0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_RESET          0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3                              0x0030014C /* RW-4R */
#define NV_PAUDIO_INTR_EN_3_PINS_0                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_0_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_1                              4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_1_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_2                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_2_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_3                            12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_3_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
#define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_LG2                     14:12 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_1                  0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_2                  0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_4                  0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_8                  0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_16                 0x00000004 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_32                 0x00000005 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_64                 0x00000006 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_128                0x00000007 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
#define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_LG2                  14:12 /* R-XVF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_1               0x00000000 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_2               0x00000001 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_4               0x00000002 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_8               0x00000003 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_16              0x00000004 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_32              0x00000005 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_64              0x00000006 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_128             0x00000007 /* R---V */
#define NV_PAUDIO_RAMAU                                  0x00300210 /* RW-4R */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS                          15:12 /* RWXVF */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS_1000                0x00001000 /* RWI-V */
#define NV_PAUDIO_ISA_SEL                                0x00300280 /* RW-4R */
#define NV_PAUDIO_ISA_SEL_IRQ                                   2:0 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_IRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_2                          0x00000004 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ                                   9:8 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_DRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_TLB_PTE                                0x00300310 /* R-X4R */
#define NV_PAUDIO_TLB_PTE_PAGE                                31:10 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_READ_ONLY                             1:1 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_PRESENT                               0:0 /* R-XVF */
#define NV_PAUDIO_TLB_TAG                                0x00300320 /* R-X4R */
#define NV_PAUDIO_DMA_TLB_TAG                                 31:12 /* R-XVF */
#define NV_PAUDIO_DMAIA                                  0x00300330 /* R-X4R */
#define NV_PAUDIO_DMA_INSTANCE                                 31:2 /* R-XVF */
#define NV_PAUDIO_DMA_INSTANCE_TARGET                           1:0 /* R-XVF */
#define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
#define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
#define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
#define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
#define NV_PAUDIO_PROG_COUNTER                           0x00300420 /* R--4R */
#define NV_PAUDIO_PROG_COUNTER_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_AN_VOLUME                              0x00300430 /* RWI4R */
#define NV_PAUDIO_AN_VOLUME_INITIAL                               7 /* RWI-V */
#define NV_PAUDIO_AN_VOLUME_VALUE                               2:0 /* RWXUF */
#define NV_PAUDIO_TERM_USAGE                             0x00300C0C /* RW-4R */
#define NV_PAUDIO_TERMINATION_LEVEL                           31:16 /* RWXUF */
#define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
#define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
#define NV_PAUDIO_CONTEXT                                0x00300E10 /* RW-4R */
#define NV_PAUDIO_CONTEXT_INSTANCE                             31:0 /* RWXUF */
#define NV_PAUDIO_BLASTER(i)                       (0x00301000+(i)) /* RW-1A */
#define NV_PAUDIO_BLASTER__SIZE_1                                 1 /*       */
#define NV_PAUDIO_BLASTER_DATA                                  7:0 /* RW-VF */
#define NV_PAUDIO_CODEC(i)                       (0x00302800+(i)*4) /* RW-4A */
#define NV_PAUDIO_CODEC__SIZE_1                                 256 /*       */
#define NV_PAUDIO_CODEC_DATA                                   19:0 /* RW-VF */
#define NV_PAUDIO_INST_TARGET_NVM                        0x00000000 /* RW--V */
#define NV_PAUDIO_INST_TARGET_CART                       0x00000001 /* RW--V */
#define NV_PAUDIO_INST_TARGET_PCI                        0x00000002 /* RW--V */
#define NV_PAUDIO_ROOT_INPUT                             0x00300C00 /* RW-4R */
#define NV_PAUDIO_ROOT_INPUT_TARGET                             1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_INPUT_INSTANCE                          31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT                            0x00300C04 /* RW-4R */
#define NV_PAUDIO_ROOT_OUTPUT_TARGET                            1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE                              0x00300C08 /* RW-4R */
#define NV_PAUDIO_ROOT_NOTE_TARGET                              1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE_INSTANCE                           31:2 /* RWXUF */
#define NV_PAUDIO_DIAG(i)                        (0x00300C10+(i)*4) /* RW-4A */
#define NV_PAUDIO_DIAG__SIZE_1                                  252 /*       */
#define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         3:3 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_TILING                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_TILING_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_TILING_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ                        21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CW-VF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT                       14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D                           15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_FORMAT                               20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
#define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
#define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
#define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
#define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
#define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
#define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
#define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
#define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
#define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
#define NV_PGRAPH_BOFFSET0_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
#define NV_PGRAPH_BOFFSET1_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
#define NV_PGRAPH_BOFFSET2_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
#define NV_PGRAPH_BOFFSET3_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x004006c0 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x004006c4 /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     25:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
#define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
#define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
#define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
#define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
#define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
#define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
#define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
#define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
#define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
#define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
#define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
#define NV_PGRAPH_DMA_SIZE_VALUE                               21:0 /* RW-UF */
#define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
#define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
#define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
#define NV_PGRAPH_DMA_Y_SIZE_VALUE                             10:0 /* RW-UF */
#define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
#define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       21:0 /* RWXUF */
#define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
#define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
#define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
#define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
#define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE                         31:0 /* RWIVF */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE_HW                0x00000000 /* RWI-V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               6:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */

// actually an NV4 register, but nv3ddraw uses this file for both NV3 and NV4
#define NV_PCRTC_RASTER                                  0x00600808 /* R-I4R */
#define NV_PCRTC_RASTER_POSITION                               10:0 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD                               13:12 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD_DISPLAY                  0x00000000 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_BEFORE                   0x00000001 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_AFTER                    0x00000002 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK                            16:16 /* R---F */
#define NV_PCRTC_RASTER_VERT_BLANK_ACTIVE                0x00000001 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK_INACTIVE              0x00000000 /* R---V */

/* vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----- */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                           0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
#define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
#define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
/* vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_LOCK_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_NOTIFY                                    0:0 /* RWIVF */
#define NV_PME_INTR_0_NOTIFY_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_INTR_0_NOTIFY_PENDING                     0x00000001 /* R---V */
#define NV_PME_INTR_0_NOTIFY_RESET                       0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                       4:4 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_NOTIFY_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_NOTIFY_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                    4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_CCIR656                                 0:0 /* RWIVF */
#define NV_PME_CONFIG_0_CCIR656_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_CCIR656_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VMI                                     4:4 /* RWIVF */
#define NV_PME_CONFIG_0_VMI_DISABLED                     0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VMI_ENABLED                      0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */
#define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */
#define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_d3d0_triangle_zeta.ref */
#define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
#define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
#define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4B4   0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
#define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
#define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
#define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
#define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
#define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
#define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER                         15:15 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     25:24 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
#define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
#define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
#define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
#define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
#define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
#define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
#define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
#define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
#define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
#define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
#define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
#define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
#define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_pointz.ref */
#define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
#define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
#define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    25:24 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
#define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
#define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
#define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
#define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
#define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
#define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
#define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
#define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
#define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_mem_to_mem.ref */
#define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
#define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
#define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
#define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
#define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
#define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
#define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
#define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
#define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
#define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
#define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
#define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
#define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_scaled_image_from_mem.ref */
#define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
#define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
#define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
#define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
#define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
#define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
#define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
#define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
#define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
#define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
#define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
#define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
#define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
#define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
#define NV_USCALED_SIZE_Y                                0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_PITCH_420                             0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
#define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
#define NV_USCALED_OFFSET_Y                              0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_U                              0x004E040C /* -W-4R */
#define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_V                              0x004E0410 /* -W-4R */
#define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_POINT_Y                               0x004E0414 /* -W-4R */
#define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
#define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
#define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
#define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
#define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
#define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
/* usr_stretch_from_cpu.ref */
#define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
#define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
#define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
#define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
#define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
#define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
#define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
#define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
#define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
#define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
/* usr_win95_text.ref */
#define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
#define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
#define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
#define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
#define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
#define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
#define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
#define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
#define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
#define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
#define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
#define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
#define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
#define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
#define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
#define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
#define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
#define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
#define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
#define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
#define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
#define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
#define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
#define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
#define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
/* usr_image_in_mem.ref */
#define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
#define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
#define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
#define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
#define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
#define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
#define NV_UINMEM_OFFSET_LINADRS                               22:0 /* -WIUF */
#define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
#define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
#define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
// need to consolidate nv3.ref files!
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_UNDEFINED               0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BANKS                                 3:3 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BANKS_2BANK                    0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BANKS_4BANK                    0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE                           4:4 /* RWIVF */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_OFF                0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_ON                 0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION                      5:5 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_OFF           0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_8MB           0x00000001 /* RW--V */

#define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
#define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_SG100                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_PCHG_SG100                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW_SG100                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_SG100              0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100              0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_SG100              0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_S                                            1:0 /* RWIUF */
#define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_V                                            5:4 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_M                                            9:8 /* RWIUF */
#define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_H                                          13:12 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_A                                          17:16 /* RWIUF */
#define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_G                                          21:20 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x01BFFFFF:0x01800000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01800000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01800000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01800000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01800000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x01400FFF:0x01400000 /* RW--M */
#define NV_PRAMIN_RAMAU_0                     0x01401BFF:0x01401000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x01401DFF:0x01401C00 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x01401FFF:0x01401E00 /* RW--M */
#define NV_PRAMIN_RAMRM_0                     0x01402FFF:0x01402000 /* RW--M */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED        0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K      0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                        9:9 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20              0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21              0x00000001 /* R---V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  65536 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
#define NV_RAMAU_DATA                                          31:0 /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
#define NV_AUDIN_AE_STATE                       (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDIN_AE_SKIP_COUNT                  (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_POSITION                    (2*32+31):(2*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_NEXT_INSTANCE               (3*32+31):(3*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_STATE                       (4*32+15):(4*32+ 0) /* RWWVF */
#define NV_AUDIN_SU_STATE                       (5*32+15):(5*32+ 0) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_LOW              (5*32+31):(5*32+16) /* RWWUF */
#define NV_AUDIN_SU_START_TIME_HIGH             (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_SKIP_INC                    (7*32+31):(7*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_DMA_INSTANCE          (8*32+15):(8*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_DMA_INSTANCE          (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_START_POSITION        (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_LAST_PLUS1          (10*32+31):(10*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_LAST_PLUS1          (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_EVENT_START               ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
#define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
#define NV_AUDIN_AE_INTR_DMA                  ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 4*32+ 4):( 4*32+ 4) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 4*32+ 5):( 4*32+ 5) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 4*32+ 6):( 4*32+ 6) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 4*32+ 7):( 4*32+ 7) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_OFFSET              ( 5*32+ 1):( 5*32+ 0) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_OFFSET              ( 5*32+ 3):( 5*32+ 2) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_PTE                ( 5*32+ 4):( 5*32+ 4) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_PTE_DISABLED                  0x00000000 /* RW--V */
#define NV_AUDIN_SU_BYPASS_PTE_ENABLED                   0x00000001 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET             ( 5*32+ 6):( 5*32+ 5) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_TARGET_NVM                    0x00000000 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET_PCI                    0x00000002 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET_AGP                    0x00000003 /* RW--V */
#define NV_AUDIN_SU_BUFF0_IN_USE              ( 5*32+ 8):( 5*32+ 8) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_IN_USE              ( 5*32+ 9):( 5*32+ 9) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY              (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY              (16*32+11):(16*32+11) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_CHANNEL                   ( 5*32+12):( 5*32+12) /* RWXVF */
#define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
#define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT                    ( 5*32+15):( 5*32+13) /* RWXVF */
#define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
#define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
/* dev_ram.ref */
#define NV_AUDOUT                             0x0000003b:0x00000000 /* RW--M */
#define NV_AUDOUT_AE_STATE                      (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDOUT_AE_POSITION_LOW               (0*32+31):(0*32+16) /* RWWUF */
#define NV_AUDOUT_AE_POSITION                   (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_VOLUME_1                   (2*32+15):(2*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_VOLUME_0                   (2*32+31):(2*32+16) /* RWWUF */
#define NV_AUDOUT_RM_VOLUME_0                   (3*32+15):(3*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_VOLUME_0                   (3*32+31):(3*32+16) /* RWWUF */
#define NV_AUDOUT_RM_VOLUME_1                   (4*32+15):(4*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_VOLUME_1                   (4*32+31):(4*32+16) /* RWWUF */
#define NV_AUDOUT_AE_POSITION_INC               (5*32+31):(5*32+ 0) /* RWWUF */
#define NV_AUDOUT_RM_NEXT_INSTANCE              (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDOUT_RM_STATE                      (7*32+15):(7*32+ 0) /* RWWVF */
#define NV_AUDOUT_SU_STATE                      (8*32+15):(8*32+ 0) /* RWWVF */
#define NV_AUDOUT_SU_START_TIME_LOW             (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDOUT_SU_START_TIME_HIGH            (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_START_POSITION     (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_LAST_PLUS1         (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_LAST_PLUS1         (14*32+31):(14*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
#define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
#define NV_AUDOUT_AE_EVENT_START              ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
#define NV_AUDOUT_AE_GAP_DETECT               ( 0*32+10):( 0*32+10) /* RWXVF */
#define NV_AUDOUT_AE_INTR_DMA                 ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
#define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
#define NV_AUDOUT_RM_INTR_MIXING              (15*32+ 0):(15*32+ 0) /* RWXVF */
#define NV_AUDOUT_RM_INTR_VOLUME              (15*32+ 1):(15*32+ 1) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        (15*32+ 4):(15*32+ 4) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        (15*32+ 5):(15*32+ 5) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     (15*32+ 6):(15*32+ 6) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     (15*32+ 7):(15*32+ 7) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_OFFSET             (16*32+ 3):(16*32+ 2) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_PTE               (16*32+ 4):(16*32+ 4) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_PTE_DISABLED                 0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_PTE_ENABLED                  0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET            (16*32+ 6):(16*32+ 5) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_TARGET_NVM                   0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET_PCI                   0x00000002 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET_AGP                   0x00000003 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_IN_USE             (16*32+ 8):(16*32+ 8) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_IN_USE             (16*32+ 9):(16*32+ 9) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY             (16*32+11):(16*32+11) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL                  (16*32+12):(16*32+12) /* RWXVF */
#define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT                   (16*32+15):(16*32+13) /* RWXVF */
#define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDNOTE                            0x00000083:0x00000000 /* RW--M */
#define NV_AUDNOTE_AE_STATE                     (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDNOTE_AE_POSITION_LOW              (0*32+31):(0*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_POSITION                  (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_POSITION_INC              (2*32+31):(2*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_EG_ADSR_LEVEL             (3*32+31):(3*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_PE_ADSR_LEVEL             (4*32+31):(4*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_ADSR_VOLUME               (5*32+15):(5*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL     (5*32+31):(5*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_VIBRATO_POSITION          (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_TREMOLO_POSITION          (7*32+31):(7*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VOLUME_1                  (8*32+15):(8*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VOLUME_0                  (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_NEXT_INSTANCE             (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDNOTE_RM_VOLUME_0                (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VOLUME_0                (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_VOLUME_1                (11*32+15):(11*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VOLUME_1                (11*32+31):(11*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_STATE                   (12*32+15):(12*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_STATE                   (13*32+15):(13*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_START_TIME_LOW          (13*32+31):(13*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_START_TIME_HIGH         (14*32+31):(14*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_STOP_TIME_HIGH          (15*32+31):(15*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_FM_STATE                (16*32+15):(16*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (16*32+31):(16*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_DMA_INSTANCE            (17*32+15):(17*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (17*32+31):(17*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (18*32+31):(18*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (19*32+31):(19*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LOOP_START              (21*32+31):(21*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LOOP_END_PLUS1          (22*32+31):(22*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LAST_PLUS1              (23*32+31):(23*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_ATTACK_RATE          (24*32+15):(24*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_DECAY_RATE           (24*32+31):(24*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_EG_SUSTAIN_RATE         (25*32+15):(25*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_RELEASE_RATE         (25*32+31):(25*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_ATTACK_RATE          (26*32+15):(26*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_DECAY_RATE           (26*32+31):(26*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SUSTAIN_RATE         (27*32+15):(27*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_RELEASE_RATE         (27*32+31):(27*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (28*32+15):(28*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_DEPTH           (29*32+15):(29*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL        (29*32+31):(29*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SCALE                (30*32+15):(30*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL        (30*32+31):(30*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (31*32+15):(31*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (31*32+31):(31*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_DEPTH           (32*32+15):(32*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_OFFSET          (32*32+31):(32*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
#define NV_AUDNOTE_AE_EVENT_STOP              ( 0*32+ 2):( 0*32+ 2) /* RWXVF */
#define NV_AUDNOTE_AE_EVENT_START             ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDNOTE_AE_PE_STATE                ( 0*32+ 7):( 0*32+ 6) /* RWXVF */
#define NV_AUDNOTE_AE_PE_ATTACK                          0x00000000 /* RW--V */
#define NV_AUDNOTE_AE_PE_DECAY                           0x00000001 /* RW--V */
#define NV_AUDNOTE_AE_PE_SUSTAIN                         0x00000002 /* RW--V */
#define NV_AUDNOTE_AE_PE_RELEASE                         0x00000003 /* RW--V */
#define NV_AUDNOTE_AE_IN_USE                  ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDNOTE_AE_GAP_DETECT              ( 0*32+10):( 0*32+10) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_DMA                ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDNOTE_AE_EG_STATE                ( 0*32+14):( 0*32+13) /* RWXVF */
#define NV_AUDNOTE_AE_EG_ATTACK                          0x00000000 /* RW--V */
#define NV_AUDNOTE_AE_EG_DECAY                           0x00000001 /* RW--V */
#define NV_AUDNOTE_AE_EG_SUSTAIN                         0x00000002 /* RW--V */
#define NV_AUDNOTE_AE_EG_RELEASE                         0x00000003 /* RW--V */
#define NV_AUDNOTE_AE_POS_VALID               ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_MIXING             (14*32+ 0):(14*32+ 0) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_VOLUME             (14*32+ 1):(14*32+ 1) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_NOTIFY             (14*32+ 4):(14*32+ 4) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_PTE              (12*32+ 4):(12*32+ 4) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_PTE_DISABLED                0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                 0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET           (12*32+ 6):(12*32+ 5) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_TARGET_NVM                  0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET_PCI                  0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET_AGP                  0x00000003 /* RW--V */
#define NV_AUDNOTE_SU_EG_LINEAR               (12*32+ 7):(12*32+ 7) /* RWXVF */
#define NV_AUDNOTE_SU_EG_ATCK_NV1                        0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_EG_ATCK_LINEAR                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_IN_USE                  (12*32+ 8):(12*32+ 8) /* RWXVF */
#define NV_AUDNOTE_SU_BUFF_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL                 (12*32+12):(12*32+12) /* RWXVF */
#define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT                  (12*32+15):(12*32+13) /* RWXVF */
#define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_FEEDBACK                (15*32+ 6):(15*32+ 4) /* RWXVF */
#define NV_AUDNOTE_FM_FB_0                               0x00000000 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_16                           0x00000001 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_8                            0x00000002 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_4                            0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_2                            0x00000004 /* RW--V */
#define NV_AUDNOTE_FM_FB_1_PI                            0x00000005 /* RW--V */
#define NV_AUDNOTE_FM_FB_2_PI                            0x00000006 /* RW--V */
#define NV_AUDNOTE_FM_FB_4_PI                            0x00000007 /* RW--V */
#define NV_AUDNOTE_FM_WAVE_SELECT             (15*32+ 2):(15*32+ 0) /* RWXVF */
#define NV_AUDNOTE_FM_WS_SINE                            0x00000000 /* RW--V */
#define NV_AUDNOTE_FM_WS_HALF_SINE                       0x00000001 /* RW--V */
#define NV_AUDNOTE_FM_WS_ABS_SINE                        0x00000002 /* RW--V */
#define NV_AUDNOTE_FM_WS_SHARK_SINE                      0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_WS_QUICK_SINE                      0x00000004 /* RW--V */
#define NV_AUDNOTE_FM_WS_ABS_QUICK                       0x00000005 /* RW--V */
#define NV_AUDNOTE_FM_WS_SQUARE                          0x00000006 /* RW--V */
#define NV_AUDNOTE_FM_WS_INV_SINE                        0x00000007 /* RW--V */
#define NV_AUDNOTE_FM_PHASE_OUT               (15*32+ 8):(15*32+ 8) /* RWXVF */
#define NV_AUDNOTE_FM_SYNTHESIS               (15*32+12):(15*32+12) /* RWXVF */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv4_ref.h ===
/* NVidia Corporation */ 
/* basis: nv4 manuals 
built on Thu Mar  5 04:04:41 PST 1998*/

#ifndef _NV_REG_H_
#define _NV_REG_H_


/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_MSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_RSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_6(i)                    (0x00000018+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_6__SIZE_1                                5 /*       */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_23                              0x0000005C /* RW-4A */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_24                              0x00000060 /* RW-4R */
#define NV_CONFIG_PCI_NV_24__ALIAS_1              NV_PBUS_PCI_NV_24 /*       */
#define NV_CONFIG_PCI_NV_25                              0x00000064 /* RW-4R */
#define NV_CONFIG_PCI_NV_25__ALIAS_1              NV_PBUS_PCI_NV_25 /*       */
#define NV_CONFIG_PCI_NV_26(i)                   (0x00000068+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_26__SIZE_1                              38 /*       */
#define NV_CONFIG_PCI_NV_26__ALIAS_1              NV_PBUS_PCI_NV_25 /*       */
/* dev_bus.ref */
/* dev_bus.ref */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID_CODE                                   31:0 /* C--UF */
#define NV_PRMIO_RMA_ID_CODE_VALID                       0x2B16D065 /* C---V */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR_ADDRESS                               24:2 /* RWXUF */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA_PORT                                 31:0 /* RWXUF */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-4R */
#define NV_PRMIO_RMA_DATA32_BYTE2                             23:16 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE1                              15:8 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE0                               7:0 /* RWXUF */
/* dev_bus.ref */
#define NV_EXPROM                             0x0000FFFF:0x00000000 /* R---D */
#define NV_EXPROM_BIOS_ROM008(i)                   (0x00000000+(i)) /* RW-1A */
#define NV_EXPROM_BIOS_ROM008__SIZE_1                         65536 /*       */
#define NV_EXPROM_BIOS_ROM008_VALUE                             7:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM016(i)                 (0x00000000+(i)*2) /* RW-2A */
#define NV_EXPROM_BIOS_ROM016__SIZE_1                         32768 /*       */
#define NV_EXPROM_BIOS_ROM016_VALUE                            15:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM032(i)                 (0x00000000+(i)*4) /* RW-4A */
#define NV_EXPROM_BIOS_ROM032__SIZE_1                         16384 /*       */
#define NV_EXPROM_BIOS_ROM032_VALUE                            31:0 /* RW-VF */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_NVPLL_COEFF                           0x00680500 /* RW-4R */
#define NV_PRAMDAC_NVPLL_COEFF_MDIV                             7:0 /* RWIUF */
#define NV_PRAMDAC_NVPLL_COEFF_NDIV                            15:8 /* RWIUF */
#define NV_PRAMDAC_NVPLL_COEFF_PDIV                           18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE                 0:0 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_XTAL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE                     10:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_DEFAULT       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_MPLL     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_VPLL     0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_NVPLL    0x00000004 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_ALL      0x00000007 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV                17:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_NONE      0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_VSCLK     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_PCLK      0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_BOTH      0x00000003 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE              20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE_EXT     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE_VIP     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO               24:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO_DB1      0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO_DB2      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   14:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_MPLL         0x00000001 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_VPLL         0x00000002 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_NVPLL        0x00000004 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000007 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000002 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_NVCLK         0x00000000 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCK                29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_NOTLOCKED      0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED         0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT                 0:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT_24       0x00000001 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT_31       0x00000000 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX                       5:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_OFF            0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_POS            0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_NEG            0x00000002 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON             0x00000003 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSEL      0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_15           0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_16           0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_24           0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_30           0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000002 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000004 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000003 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000002 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_TV_SETUP                              0x00680700 /* RW-4R */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE                            0:0 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE               0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT                           6:4 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_555                0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_565                0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_888                0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_101010             0x00000003 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_YUV                0x00000004 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC                            9:8 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_COMP                0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_SCALER              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_VIP                 0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC                          12:12 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC_SCALER              0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC_NO_SCALER           0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL                          17:16 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_NONE            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_HSYNC           0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_VSYNC           0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_BOTH            0x00000003 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC                         20:20 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC_LEAD               0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC_TRAIL              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS                       24:24 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS_7_0              0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS_11_4             0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD                         28:28 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD_0                  0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD_1                  0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_VBLANK_START                       0x00680704 /* RW-4R */
#define NV_PRAMDAC_TV_VBLANK_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_TV_VBLANK_END                         0x00680708 /* RW-4R */
#define NV_PRAMDAC_TV_VBLANK_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_TV_HBLANK_START                       0x0068070C /* RW-4R */
#define NV_PRAMDAC_TV_HBLANK_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_TV_HBLANK_END                         0x00680710 /* RW-4R */
#define NV_PRAMDAC_TV_HBLANK_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_BLANK_COLOR                           0x00680714 /* RW-4R */
#define NV_PRAMDAC_BLANK_COLOR_VAL                             23:0 /* RWIVF */
#define NV_PRAMDAC_TV_CHECKSUM                           0x00680718 /* RW-4R */
#define NV_PRAMDAC_TV_CHECKSUM_VAL                             23:0 /* R--VF */
#define NV_PRAMDAC_TV_VSYNC                                   28:28 /* R--VF */
#define NV_PRAMDAC_TV_VSYNC_ACTIVE                       0x00000000 /* R---V */
#define NV_PRAMDAC_TV_VSYNC_INACTIVE                     0x00000001 /* R---V */
#define NV_PRAMDAC_TV_TEST_CONTROL                       0x0068071c /* RW-4R */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET                    0:0 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET_DEASSERTED  0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET_ASSERTED    0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE                   4:4 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE_DEASSERTED 0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE_ASSERTED   0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL                  9:8 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_7_0       0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_15_8      0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_23_16     0x00000002 /* RW--V */

// Added for NV5 flat panel support
#define NV_PRAMDAC_FP_VDISPLAY_END                       0x00680800 /* RW-4R */
#define NV_PRAMDAC_FP_VDISPLAY_END_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VTOTAL                             0x00680804 /* RW-4R */
#define NV_PRAMDAC_FP_VTOTAL_VAL                               10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VCRTC                              0x00680808 /* RW-4R */
#define NV_PRAMDAC_FP_VCRTC_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VSYNC_START                        0x0068080c /* RW-4R */
#define NV_PRAMDAC_FP_VSYNC_START_VAL                          10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VSYNC_END                          0x00680810 /* RW-4R */
#define NV_PRAMDAC_FP_VSYNC_END_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VVALID_START                       0x00680814 /* RW-4R */
#define NV_PRAMDAC_FP_VVALID_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VVALID_END                         0x00680818 /* RW-4R */
#define NV_PRAMDAC_FP_VVALID_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HDISPLAY_END                       0x00680820 /* RW-4R */
#define NV_PRAMDAC_FP_HDISPLAY_END_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HTOTAL                             0x00680824 /* RW-4R */
#define NV_PRAMDAC_FP_HTOTAL_VAL                               10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HCRTC                              0x00680828 /* RW-4R */
#define NV_PRAMDAC_FP_HCRTC_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HSYNC_START                        0x0068082c /* RW-4R */
#define NV_PRAMDAC_FP_HSYNC_START_VAL                          10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HSYNC_END                          0x00680830 /* RW-4R */
#define NV_PRAMDAC_FP_HSYNC_END_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HVALID_START                       0x00680834 /* RW-4R */
#define NV_PRAMDAC_FP_HVALID_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HVALID_END                         0x00680838 /* RW-4R */
#define NV_PRAMDAC_FP_HVALID_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_FP_CHECKSUM                           0x00680840 /* RW-4R */
#define NV_PRAMDAC_FP_CHECKSUM_VAL                             23:0 /* R--VF */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS                         24:24 /* R--VF */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS_CAPTURED           0x00000001 /* R---V */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS_WAITING            0x00000000 /* R---V */
#define NV_PRAMDAC_FP_VSYNC                                   28:28 /* R--VF */
#define NV_PRAMDAC_FP_VSYNC_LOW                          0x00000000 /* R---V */
#define NV_PRAMDAC_FP_VSYNC_HIGH                         0x00000001 /* R---V */
#define NV_PRAMDAC_FP_TEST_CONTROL                       0x00680844 /* RW-4R */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET                    0:0 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET_DEASSERTED  0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET_ASSERTED    0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE                   4:4 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE_DEASSERTED 0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE_ASSERTED   0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL                  9:8 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_7_0       0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_15_8      0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_23_16     0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE                10:10 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE_ALWAYS    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE_ONE       0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL                         0x00680848 /* RW-4R */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC                          1:0 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_NEG               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS               0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_DISABLE           0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_RSVD              0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC                          5:4 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_NEG               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS               0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_DISABLE           0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_RSVD              0x00000003 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE                           9:8 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE              0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER             0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_NATIVE             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER                       13:12 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_NONE             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_HORIZ            0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_VERT             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_BOTH             0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE                       17:16 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_NONE             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_HORIZ            0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_VERT             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_BOTH             0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_READ                         20:20 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_READ_ACTUAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_READ_PROG               0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH                        24:24 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH_24                0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH_12                0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN                       29:28 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_NEG              0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE          0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_RSVD             0x00000003 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE                            0:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE_DISABLE             0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE                            4:4 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE_DISABLE             0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP                           8:8 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR           0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP                         12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR           0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_VCNTR                           17:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NONE                  0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_VCNTR                 0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH                  0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT                         20:20 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT                         24:24 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN                         28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1                            0x00680884 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE                     11:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE_ZERO          0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE                 12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE                    27:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE_ZERO          0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE                 28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_2                            0x00680888 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE                 12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_VALUE                    25:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE                 28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_3                            0x0068088c /* R--4R */
#define NV_PRAMDAC_FP_DEBUG_3_XSTEPSIZE                        12:0 /* R--VF */
#define NV_PRAMDAC_FP_DEBUG_3_YSTEPSIZE                       28:16 /* R--VF */
#define NV_PRAMDAC_FP_RAM_CONTROL                        0x006808A0 /* RW-4R */
#define NV_PRAMDAC_FP_RAM_CONTROL_ADDRESS                       8:0 /* RW-VF */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE                    16:16 /* RWIVF */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE_DISABLE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE_ENABLE        0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_RAM_DATA_0                         0x006808A4 /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_0_VAL                           31:0 /* RW--F */
#define NV_PRAMDAC_FP_RAM_DATA_1                         0x006808A8 /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_1_VAL                           31:0 /* RW--F */
#define NV_PRAMDAC_FP_RAM_DATA_2                         0x006808AC /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_2_VAL                            7:0 /* RW--F */


/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000003 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_dac.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
/* dev_dac.ref */
#define NV_PRMDIO                             0x00681FFF:0x00681000 /* RW--D */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_MINOR_REVISION                            3:0 /* C--VF */
#define NV_PMC_BOOT_0_MINOR_REVISION_0                   0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MAJOR_REVISION                            7:4 /* C--VF */
#define NV_PMC_BOOT_0_MAJOR_REVISION_A                   0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MAJOR_REVISION_B                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           11:8 /* C--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV4_0               0x00000000 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            15:12 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV4                   0x00000004 /* C---V */
#define NV_PMC_BOOT_0_FIB_REVISION                            19:16 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION                           23:20 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_TSMC                       0x00000002 /* C---V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH                                  12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PCRTC                                   24:24 /* R--VF */
#define NV_PMC_INTR_0_PCRTC_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PCRTC_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                         3:0 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC                            4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY                       11:8 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY_8               0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_OVERRIDE           0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY                       19:16 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC                          20:20 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY                       27:24 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC                          28:28 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_HASH_DECODE                             2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_HASH_DECODE_1FF                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_HASH_DECODE_2FF                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE                           13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV4                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV3                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE1                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                15:15 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE3                                16:16 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE3_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE3_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE4                                17:17 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE4_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE4_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE5                                18:18 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE5_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE5_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE6                                19:19 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE6_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE6_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE7                                20:20 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE7_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE7_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE8                                21:21 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE8_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE8_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE9                                22:22 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE9_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE9_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE10                               23:23 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE10_ZERO                     0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE10_ONE                      0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2                                  0x00001088 /* RW-4R */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL                        0:0 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_DISABLED        0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY                        9:4 /* RWIUF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY_34              0x00000022 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_OVERRIDE           0x00000001 /* RW0-V */
#define NV_PBUS_DEBUG_3                                  0x0000108C /* RW-4R */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE                            1:0 /* RWIVF */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_UNLIMITED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_64_BYTES            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTL                                0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_CTL_MODE                                  0:0 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_MODE_DISABLED                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_MODE_ENABLED                   0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT                           4:4 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_1                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_READ                               0x00001094 /* R--4R */
#define NV_PBUS_DEBUG_READ_DATA                                31:0 /* R-XUF */
#define NV_PBUS_DEBUG_HOST                               0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_0                              0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x000010A4 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x000010A8 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x000010AC /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_ROM_CONFIG                               0x00001200 /* RWI4R */
#define NV_PBUS_ROM_CONFIG_TW1                                  3:0 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW1_DEFAULT                   0x0000000F /* RWI-V */
#define NV_PBUS_ROM_CONFIG_TW0                                  5:4 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW0_DEFAULT                   0x00000003 /* RWI-V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_0_VENDOR_ID                             15:0 /* C--UF */
#define NV_PBUS_PCI_NV_0_VENDOR_ID_NVIDIA_SGS            0x000012D2 /* ----V */
#define NV_PBUS_PCI_NV_0_VENDOR_ID_NVIDIA                0x000010DE /* C---V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC                       18:16 /* C--UF */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA              0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP                       31:19 /* C--UF */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV0              0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV1              0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV2              0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV3              0x00000003 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV4              0x00000004 /* C---V */

// Used to determine chip id on Win2k 
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04                0x00000020 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0         0x00000028 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1         0x00000029 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2         0x0000002A /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3         0x0000002B /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0         0x0000002C /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1         0x0000002D /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2         0x0000002E /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3         0x0000002F /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0         0x000000A0 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1         0x000000A1 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2         0x000000A2 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3         0x000000A3 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0         0x00000100 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1         0x00000101 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2         0x00000102 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3         0x00000103 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0         0x00000110 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1         0x00000111 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2         0x00000112 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3         0x00000113 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CRUSH11_DEVID0      0x000001A0 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0         0x00000150 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1         0x00000151 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2         0x00000152 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3         0x00000153 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0         0x00000200 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1         0x00000201 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2         0x00000202 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3         0x00000203 /* C---V */

#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_1_IO_SPACE                               0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_1_IO_SPACE_DISABLED               0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_IO_SPACE_ENABLED                0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE                           1:1 /* RWIVF */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_BUS_MASTER                             2:2 /* RWIVF */
#define NV_PBUS_PCI_NV_1_BUS_MASTER_DISABLED             0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_BUS_MASTER_ENABLED              0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL                        4:4 /* C--VF */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL_DISABLED        0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL_ENABLED         0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP                          5:5 /* RWIVF */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_CAPLIST                              20:20 /* C--VF */
#define NV_PBUS_PCI_NV_1_CAPLIST_NOT_PRESENT             0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_CAPLIST_PRESENT                 0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_66MHZ                                21:21 /* C--VF */
#define NV_PBUS_PCI_NV_1_66MHZ_INCAPABLE                 0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_66MHZ_CAPABLE                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK                       23:23 /* C--VF */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK_INCAPABLE        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK_CAPABLE          0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING                        26:25 /* C--VF */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_FAST              0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_MEDIUM            0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_SLOW              0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET                      27:27 /* RWIVF */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET                      28:28 /* RWIVF */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER                      29:29 /* RWIVF */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_2_REVISION_ID                            7:0 /* C--UF */
#define NV_PBUS_PCI_NV_2_REVISION_ID_A01                 0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_2_REVISION_ID_B01                 0x00000010 /* ----V */
#define NV_PBUS_PCI_NV_2_CLASS_CODE                            31:8 /* C--VF */
#define NV_PBUS_PCI_NV_2_CLASS_CODE_VGA                  0x00030000 /* C---V */
#define NV_PBUS_PCI_NV_2_CLASS_CODE_MULTIMEDIA           0x00048000 /* ----V */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER                        15:11 /* RWIUF */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_0_CLOCKS          0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_8_CLOCKS          0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_240_CLOCKS        0x0000001E /* RW--V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS        0x0000001F /* RW--V */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE                          23:16 /* C--VF */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE_SINGLEFUNC          0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE_MULTIFUNC           0x00000080 /* ----V */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE                             0:0 /* C--VF */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE_MEMORY               0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE_IO                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE                           2:1 /* C--VF */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_32_BIT             0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_20_BIT             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_64_BIT             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE                           3:3 /* C--VF */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE_NOT                0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE_MERGABLE           0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_BASE_ADDRESS                         31:24 /* RWXUF */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE                             0:0 /* C--VF */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE_MEMORY               0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE_IO                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE                           2:1 /* C--VF */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_32_BIT             0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_20_BIT             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_64_BIT             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE                           3:3 /* C--VF */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE_NOT                0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE_MERGABLE           0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_5_BASE_ADDRESS                         31:24 /* RWXUF */
#define NV_PBUS_PCI_NV_6(i)                      (0x00001818+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_6__SIZE_1                                  5 /*       */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_6_RESERVED                              31:0 /* C--VF */
#define NV_PBUS_PCI_NV_6_RESERVED_0                      0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_VENDOR_ID                  15:0 /* R--UF */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE       0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_ID                        31:16 /* R--UF */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_ID_NONE              0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_12_ROM_DECODE                            0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_12_ROM_DECODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_12_ROM_DECODE_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_12_ROM_BASE                            31:16 /* RWXUF */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_13_CAP_PTR                               7:0 /* C--VF */
#define NV_PBUS_PCI_NV_13_CAP_PTR_AGP                    0x00000044 /* ----V */
#define NV_PBUS_PCI_NV_13_CAP_PTR_POWER_MGMT             0x00000060 /* C---V */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_14_RESERVED                             31:0 /* C--VF */
#define NV_PBUS_PCI_NV_14_RESERVED_0                     0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_15_INTR_LINE                             7:0 /* RWIVF */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ0                 0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ1                 0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ15                0x0000000F /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_UNKNOWN              0x000000FF /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_PIN                             15:8 /* C--VF */
#define NV_PBUS_PCI_NV_15_INTR_PIN_INTA                  0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_15_MIN_GNT                             23:16 /* C--VF */
#define NV_PBUS_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_15_MIN_GNT_750NS                  0x00000003 /* ----V */
#define NV_PBUS_PCI_NV_15_MIN_GNT_1250NS                 0x00000005 /* C---V */
#define NV_PBUS_PCI_NV_15_MAX_LAT                             31:24 /* C--VF */
#define NV_PBUS_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_15_MAX_LAT_250NS                  0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_VENDOR_ID                  15:0 /* RW-VF */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE       0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_ID                        31:16 /* RW-VF */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_ID_NONE              0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_17_AGP_REV_MAJOR                       23:20 /* C--VF */
#define NV_PBUS_PCI_NV_17_AGP_REV_MAJOR_1                0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_17_AGP_REV_MINOR                       19:16 /* C--VF */
#define NV_PBUS_PCI_NV_17_AGP_REV_MINOR_0                0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_17_NEXT_PTR                             15:8 /* C--VF */
#define NV_PBUS_PCI_NV_17_NEXT_PTR_NULL                  0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_17_CAP_ID                                7:0 /* C--VF */
#define NV_PBUS_PCI_NV_17_CAP_ID_AGP                     0x00000002 /* C---V */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ                       31:24 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ_16               0x0000000F /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE            0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_CAPABLE         0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE                       1:0 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_2X             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X      0x00000003 /* C---V */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH                27:24 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0         0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE                 1:0 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X       0x00000002 /* RW--V */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW                            0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_21_VGA                                   0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_21_VGA_DISABLED                   0x00000000 /* RW--V */
#define NV_PBUS_PCI_NV_21_VGA_ENABLED                    0x00000001 /* RWI-V */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_22_SCRATCH                              23:0 /* RWIVF */
#define NV_PBUS_PCI_NV_22_SCRATCH_DEFAULT                0x0023D6CE /* RWI-V */
#define NV_PBUS_PCI_NV_23                                0x0000185C /* RW-4A */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
#define NV_PBUS_PCI_NV_23_DT_TIMEOUT                            3:0 /* RWIVF */
#define NV_PBUS_PCI_NV_23_DT_TIMEOUT_16                  0x0000000F /* RWI-V */
#define NV_PBUS_PCI_NV_24                                0x00001860 /* RW-4R */
#define NV_PBUS_PCI_NV_24__ALIAS_1              NV_CONFIG_PCI_NV_24 /*       */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD                         31:31 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD_SUPPORTED          0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD_NOT_SUPPORTED      0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT                          30:30 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT_SUPPORTED           0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT_NOT_SUPPORTED       0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D2                              29:29 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D2_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D2_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D1                              28:28 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D1_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D1_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D0                              27:27 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D0_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D0_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_D2                                  26:26 /* C--VF */
#define NV_PBUS_PCI_NV_24_D2_SUPPORTED                   0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_D2_NOT_SUPPORTED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_D1                                  25:25 /* C--VF */
#define NV_PBUS_PCI_NV_24_D1_SUPPORTED                   0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_D1_NOT_SUPPORTED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_DSI                                 21:21 /* C--VF */
#define NV_PBUS_PCI_NV_24_DSI_NOT_REQUIRED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_CLOCK                           19:19 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_CLOCK_NOT_REQUIRED         0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_VERSION                             18:16 /* C--VF */
#define NV_PBUS_PCI_NV_24_VERSION_1                      0x00000001 /* C--VF */
#define NV_PBUS_PCI_NV_24_NEXT_PTR                             15:8 /* R--VF */
#define NV_PBUS_PCI_NV_24_NEXT_PTR_NULL                  0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_24_NEXT_PTR_AGP                   0x00000044 /* ----V */
#define NV_PBUS_PCI_NV_24_CAP_ID                                7:0 /* C--VF */
#define NV_PBUS_PCI_NV_24_CAP_ID_POWER_MGMT              0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_25                                0x00001864 /* RW-4R */
#define NV_PBUS_PCI_NV_25__ALIAS_1              NV_CONFIG_PCI_NV_25 /*       */
#define NV_PBUS_PCI_NV_25_POWER_STATE                           1:0 /* RWIVF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D3_HOT             0x00000003 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D2                 0x00000002 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D1                 0x00000001 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D0                 0x00000000 /* RWIVF */
#define NV_PBUS_PCI_NV_26(i)                     (0x00001868+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_26__SIZE_1                                38 /*       */
#define NV_PBUS_PCI_NV_26__ALIAS_1              NV_CONFIG_PCI_NV_25 /*       */
#define NV_PBUS_PCI_NV_26_RESERVED                             31:0 /* C--VF */
#define NV_PBUS_PCI_NV_26_RESERVED_0                     0x00000000 /* C---V */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             9:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE                           0x00002044 /* RW-4R */
#define NV_PFIFO_DMA_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE                           0x00002048 /* RW-4R */
#define NV_PFIFO_PIO_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_TIMESLICE                               0x0000204C /* RW-4R */
#define NV_PFIFO_TIMESLICE_TIMER                               17:0 /* RWIUF */
#define NV_PFIFO_TIMESLICE_TIMER_EXPIRED                 0x0003FFFF /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL                            0x00002050 /* RW-4R */
#define NV_PFIFO_NEXT_CHANNEL_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_NEXT_CHANNEL_MODE                              8:8 /* RWXVF */
#define NV_PFIFO_NEXT_CHANNEL_MODE_PIO                   0x00000000 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_MODE_DMA                   0x00000001 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH                          12:12 /* RWIVF */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_NOT_PENDING         0x00000000 /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_PENDING             0x00000001 /* RW--V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PT                                16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PT                             16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                             8:4 /* RWIUF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_10000                0x00000010 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWIUF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH                                 25:24 /* RWIUF */
#define NV_PFIFO_RAMHT_SEARCH_16                         0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SEARCH_32                         0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_64                         0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_128                        0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_11000                0x00000088 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11200                0x00000089 /* RWI-V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_12000                0x00000090 /* RW--V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWIVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHES_DMA_SUSPEND                             4:4 /* R--VF */
#define NV_PFIFO_CACHES_DMA_SUSPEND_IDLE                 0x00000000 /* R---V */
#define NV_PFIFO_CACHES_DMA_SUSPEND_BUSY                 0x00000001 /* R---V */
#define NV_PFIFO_MODE                                    0x00002504 /* RW-4R */
#define NV_PFIFO_MODE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_0_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_0_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_1_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_1_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_2_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_2_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_3_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_3_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_4_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_4_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_5_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_5_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_6_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_6_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_7_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_7_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_8_PIO            