R  lpLCData,
        int     cchData,
        int     code_page
        )
{
        static int f_use = 0;

        /*
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use)
        {
            if (0 != GetLocaleInfoW(0, LOCALE_ILANGUAGE, NULL, 0))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int retval = 0;
            int buff_size;
            unsigned char *buffer;
            int malloc_flag = 0;

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == code_page)
                code_page = __lc_codepage;

            /* find out how big buffer needs to be */
            if (0 == (buff_size = GetLocaleInfoA(Locale, LCType, NULL, 0)))
                return 0;

            /* allocate buffer */
            __try {
                buffer = (unsigned char *)_alloca( buff_size * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer = NULL;
            }

            if ( buffer == NULL ) {
                if ( (buffer = (unsigned char *)_malloc_crt(buff_size * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag++;
            }

            /* get the info in ANSI format */
            if (0 == GetLocaleInfoA(Locale, LCType, buffer, buff_size))
                goto error_cleanup;

            if (0 == cchData)
            {
                /* find out how much space needed */
                retval = MultiByteToWideChar( code_page,
                                              MB_PRECOMPOSED,
                                              buffer,
                                              -1,
                                              NULL,
                                              0 );
            }
            else {
                /* convert into user buffer */
                retval = MultiByteToWideChar( code_page,
                                              MB_PRECOMPOSED,
                                              buffer,
                                              -1,
                                              lpLCData,
                                              cchData );
            }

error_cleanup:
            if ( malloc_flag )
                _free_crt(buffer);

            return retval;

        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\w_cmp.c ===
/***
*w_cmp.c - W versions of CompareString.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either CompareStringA or CompareStringW depending on which is 
*       available
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       05-09-94  CFW   Do not let CompareString compare past NULL.
*       06-03-94  CFW   Test for empty string early.
*       11/01-94  CFW   But not too early for MB strings.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-95  CFW   assert -> _ASSERTE.
*       02-15-97  RDK   For narrow comparsion, try W version first so Windows NT
*                       can process nonANSI codepage correctly.
*       05-15-97  GJF   Split off from aw_cmp.c. Replaced use of _malloc_crt
*                       and _free_crt with _alloca. Also, detab-ed and cleaned
*                       up the code a bit.
*       05-27-98  GJF   Changed wcsncnt() so that it will never examine the
*                       (cnt + 1)-th byte of the string.
*       08-18-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#if !defined(_XBOX) || defined(_XBNLS)

#include <cruntime.h>
#include <internal.h>
#include <dbgint.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       int n                   - byte count
*
*Exit:
*       returns number of wide characaters from start of string to
*       NULL (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl wcsncnt (
        const wchar_t *string,
        int cnt
        )
{
        int n = cnt;
        wchar_t *cp = (wchar_t *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtCompareStringW - Get type information about a wide string.
*
*Purpose:
*  Internal support function. Assumes info in wide string format. Tries
*  to use NLS API call CompareStringW if available and uses CompareStringA
*  if it must. If neither are available it fails and returns 0.
*
*Entry:
*  LCID     Locale      - locale context for the comparison.
*  DWORD    dwCmpFlags  - see NT\Chicago docs
*  LPCWSTR  lpStringn   - wide string to be compared
*  int      cchCountn   - wide char (word) count (NOT including NULL)
*                       (-1 if NULL terminated)
*  int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*  Success: 1 - if lpString1 <  lpString2
*           2 - if lpString1 == lpString2
*           3 - if lpString1 >  lpString2
*  Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtCompareStringW(
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCWSTR  lpString1,
        int      cchCount1,
        LPCWSTR  lpString2,
        int      cchCount2,
        int      code_page
        )
{
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use)
        {
            if (0 != CompareStringW(0, 0, L"\0", 1, L"\0", 1))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /*
         * CompareString will compare past NULL. Must find NULL if in string
         * before cchCountn wide characters.
         */

        if (cchCount1 > 0)
            cchCount1= wcsncnt(lpString1, cchCount1);
        if (cchCount2 > 0)
            cchCount2= wcsncnt(lpString2, cchCount2);

        if (!cchCount1 || !cchCount2)
            return (cchCount1 - cchCount2 == 0) ? 2 :
                   (cchCount1 - cchCount2 < 0) ? 1 : 3;

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return CompareStringW( Locale,
                                   dwCmpFlags,
                                   lpString1,
                                   cchCount1,
                                   lpString2,
                                   cchCount2 );
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int buff_size1;
            int buff_size2;
            unsigned char *buffer1;
            unsigned char *buffer2;
            int retcode = 0;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP;

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == Locale)
                Locale = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(Locale)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /*
             * Convert strings and return the requested information.
             */

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (buff_size1 = WideCharToMultiByte( code_page,
                                                         0,
                                                         lpString1,
                                                         cchCount1,
                                                         NULL,
                                                         0,
                                                         NULL,
                                                         NULL )) )
                return 0;

            /* allocate enough space for chars */
            __try {
                buffer1 = (unsigned char *)_alloca( buff_size1 * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer1 = NULL;
            }

            if ( buffer1 == NULL ) {
                if ( (buffer1 = (unsigned char *)_malloc_crt(buff_size1 * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 == WideCharToMultiByte( code_page, 
                                           0,
                                           lpString1,
                                           cchCount1,
                                           buffer1, 
                                           buff_size1,
                                           NULL,
                                           NULL ) )
                goto error_cleanup;

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (buff_size2 = WideCharToMultiByte( code_page,
                                                         0,
                                                         lpString2, 
                                                         cchCount2, 
                                                         NULL, 
                                                         0, 
                                                         NULL, 
                                                         NULL )) )
                goto error_cleanup;

            /* allocate enough space for chars */
            __try {
                buffer2 = (unsigned char *)_alloca( buff_size2 * sizeof(char) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer2 = NULL;
            }

            if ( buffer2 == NULL ) {
                if ( (buffer2 = (unsigned char *)_malloc_crt(buff_size2 * sizeof(char)))
                     == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do the conversion */
            if ( 0 != WideCharToMultiByte( code_page, 
                                           0,
                                           lpString2,
                                           cchCount2,
                                           buffer2,
                                           buff_size2,
                                           NULL,
                                           NULL ) )
                retcode = CompareStringA( Locale,
                                          dwCmpFlags,
                                          buffer1,
                                          buff_size1,
                                          buffer2,
                                          buff_size2 );

            if ( malloc_flag2 )
                _free_crt(buffer2);

error_cleanup:
            if ( malloc_flag1 )
                _free_crt(buffer1);

            return retcode;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}

#endif // XBNLS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\w_map.c ===
/***
*w_map.c - W version of LCMapString.
*
*       Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use either LCMapStringA or LCMapStringW depending on which is available
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       07-26-94  CFW   Bug fix #14730, LCMapString goes past NULLs.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-15-97  RDK   For narrow mapping, try W version first so Windows NT
*                       can process nonANSI codepage correctly.
*       03-16-97  RDK   Added error flag to __crtLCMapStringA.
*       05-09-97  GJF   Split off from aw_map.c. Revised to use _alloca
*                       instead of malloc. Also, reformatted.
*       05-27-98  GJF   Changed wcsncnt() so that it will never examine the
*                       (cnt + 1)-th byte of the string.
*       08-18-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#if !defined(_XBOX) || defined(_XBNLS)

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl wcsncnt - count wide characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before
*       null. If null not found in n chars, then return n.
*
*Entry:
*       const wchar_t *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of wide characaters from start of string to
*       null (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl wcsncnt (
        const wchar_t *string,
        int cnt
        )
{
        int n = cnt;
        wchar_t *cp = (wchar_t *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtLCMapStringW - Get type information about a wide string.
*
*Purpose:
*       Internal support function. Assumes info in wide string format. Tries
*       to use NLS API call LCMapStringW if available and uses LCMapStringA
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       DWORD    dwMapFlags  - see NT\Chicago docs
*       LPCWSTR  lpSrcStr    - pointer to string to be mapped
*       int      cchSrc      - wide char (word) count of input string 
*                              (including NULL if any)
*                              (-1 if NULL terminated) 
*       LPWSTR   lpDestStr   - pointer to memory to store mapping
*       int      cchDest     - wide char (word) count of buffer (including NULL)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*       NOTE:    if LCMAP_SORTKEY is specified, then cchDest refers to number 
*                of BYTES, not number of wide chars. The return string will be
*                a series of bytes with a NULL byte terminator.
*
*Exit:
*       Success: if LCMAP_SORKEY:
*                   number of bytes written to lpDestStr (including NULL byte 
*                   terminator)
*               else
*                   number of wide characters written to lpDestStr (including 
*                   NULL)
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtLCMapStringW(
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCWSTR  lpSrcStr,
        int      cchSrc,
        LPWSTR   lpDestStr,
        int      cchDest,
        int      code_page
        )
{
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */
    
        if (0 == f_use) {
            if (0 != LCMapStringW(0, LCMAP_LOWERCASE, L"\0", 1, NULL, 0))
                f_use = USE_W;
            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /*
         * LCMapString will map past NULL. Must find NULL if in string
         * before cchSrc wide characters.
         */
        if (cchSrc > 0)
            cchSrc = wcsncnt(lpSrcStr, cchSrc);

        /* Use "W" version */

        if (USE_W == f_use) {
            return LCMapStringW( Locale, dwMapFlags, lpSrcStr, cchSrc, 
                                 lpDestStr, cchDest );
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0) {

            int retval = 0;
            int inbuff_size;
            int outbuff_size;
            unsigned char *inbuffer;
            unsigned char *outbuffer;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP = 0;

            /*
             * Convert string and return the requested information. Note that 
             * we are converting to a multibyte string so there is not a 
             * one-to-one correspondence between number of wide chars in the 
             * input string and the number of *bytes* in the buffer. However, 
             * there had *better be* a one-to-one correspondence between the 
             * number of wide characters and the number of multibyte characters 
             * (enforced by WC_SEPCHARS) in the buffer or the resulting mapped 
             * string will be worthless to the user.
             * 
             */

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == Locale)
                Locale = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(Locale)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /* find out how big a buffer we need (includes NULL if any) */
            if ( 0 == (inbuff_size = WideCharToMultiByte( code_page, 
                                                          0,
                                                          lpSrcStr, 
                                                          cchSrc, 
                                                          NULL, 
                                                          0, 
                                                          NULL, 
                                                          NULL )) )
                return 0;

            /* allocate enough space for chars */
            __try {
                inbuffer = (unsigned char *)_alloca( inbuff_size * sizeof(char) );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                _resetstkoflw();
                inbuffer = NULL;
            }

            if ( inbuffer == NULL ) {
                if ( (inbuffer = (unsigned char *)_malloc_crt(inbuff_size * sizeof(char)))
                     == NULL )
                    return 0;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 ==  WideCharToMultiByte( code_page, 
                                            0,
                                            lpSrcStr, 
                                            cchSrc, 
                                            inbuffer, 
                                            inbuff_size, 
                                            NULL, 
                                            NULL ) )
                goto error_cleanup;

            /* get size required for string mapping */
            if ( 0 == (outbuff_size = LCMapStringA( Locale, 
                                                    dwMapFlags, 
                                                    inbuffer, 
                                                    inbuff_size, 
                                                    NULL, 
                                                    0 )) )
                goto error_cleanup;

            /* allocate enough space for chars and NULL */
            __try {
                outbuffer = (unsigned char *)_alloca( outbuff_size * sizeof(char) );
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                _resetstkoflw();
                outbuffer = NULL;
            }

            if ( outbuffer == NULL ) {
                if ( (outbuffer = (unsigned char *)_malloc_crt(outbuff_size * sizeof(char)))
                     == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do string mapping */
            if ( 0 == LCMapStringA( Locale, 
                                    dwMapFlags, 
                                    inbuffer, 
                                    inbuff_size, 
                                    outbuffer, 
                                    outbuff_size ) )
                goto error_cleanup;

            if (dwMapFlags & LCMAP_SORTKEY) {

                /* outbuff_size > cchDest is allowed */
                retval = outbuff_size;

                if (0 != cchDest)
                    /* SORTKEY returns BYTES, just copy */
                    strncpy( (char *)lpDestStr, 
                             (char *)outbuffer, 
                             cchDest < outbuff_size ? cchDest : outbuff_size );
            }
            else {
                if (0 == cchDest) {
                    /* get size required */
                    if ( 0 == (retval = MultiByteToWideChar( code_page, 
                                                             MB_PRECOMPOSED, 
                                                             outbuffer, 
                                                             outbuff_size, 
                                                             NULL, 
                                                             0 )) )
                        goto error_cleanup;
                } 
                else {
                    /* convert mapping */
                    if ( 0 == (retval = MultiByteToWideChar( code_page, 
                                                             MB_PRECOMPOSED, 
                                                             outbuffer, 
                                                             outbuff_size, 
                                                             lpDestStr, 
                                                             cchDest )) )
                        goto error_cleanup;
                }
            }

error_cleanup:
            if ( malloc_flag2 )
                _free_crt(outbuffer);

            if ( malloc_flag1 )
                _free_crt(inbuffer);

            return retval;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return 0;
}

#endif // XBNLS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\w_env.c ===
/***
*w_env.c - W version of GetEnvironmentStrings.
*
*       Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use GetEnvironmentStringsW if available, otherwise use A version.
*
*Revision History:
*       03-29-94  CFW   Module created.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       04-07-95  CFW   Create __crtGetEnvironmentStringsA.
*       07-03-95  GJF   Modified to always malloc a buffer for the 
*                       environment strings, and to free the OS's buffer.
*       06-10-96  GJF   Initialize aEnv and wEnv to NULL in
*                       __crtGetEnvironmentStringsA. Also, detab-ed.
*       05-14-97  GJF   Split off from aw_env.c.
*       03-03-98  RKP   Supported 64 bits
*       08-21-98  GJF   Use CP_ACP instead of __lc_codepage.
*       01-08-99  GJF   Changes for 64-bit size_t.
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

#define USE_W   1
#define USE_A   2

/***
*LPVOID __cdecl __crtGetEnvironmentStringsW - Get wide environment.
*
*Purpose:
*       Internal support function. Tries to use NLS API call
*       GetEnvironmentStringsW if available and uses GetEnvironmentStringsA
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       VOID
*
*Exit:
*       LPVOID - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPVOID __cdecl __crtGetEnvironmentStringsW(
        VOID
        )
{
        static int f_use = 0;
        void *penv = NULL;
        char *pch;
        wchar_t *pwch;
        wchar_t *wbuffer;
        int total_size = 0;
        int str_size;

        /*
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */

        if ( 0 == f_use )
        {
            if ( NULL != (penv = GetEnvironmentStringsW()) )
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if ( USE_W == f_use )
        {
            if ( NULL == penv )
                if ( NULL == (penv = GetEnvironmentStringsW()) )
                    return NULL;

            /* find out how big a buffer is needed */

            pwch = penv;
            while ( *pwch != L'\0' ) {
                if ( *++pwch == L'\0' )
                    pwch++;
            }

            total_size = (int)((char *)pwch - (char *)penv) +
                         (int)sizeof( wchar_t );

            /* allocate the buffer */

            if ( NULL == (wbuffer = _malloc_crt( total_size )) ) {
                FreeEnvironmentStringsW( penv );
                return NULL;
            }

            /* copy environment strings to buffer */

            memcpy( wbuffer, penv, total_size );

            FreeEnvironmentStringsW( penv );

            return (LPVOID)wbuffer;
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            /*
             * Convert strings and return the requested information.
             */
            if ( NULL == penv )
                if ( NULL == (penv = GetEnvironmentStringsA()) )
                    return NULL;

            pch = penv;

            /* find out how big a buffer we need */
            while ( *pch != '\0' )
            {
                if ( 0 == (str_size =
                      MultiByteToWideChar( CP_ACP,
                                           MB_PRECOMPOSED,
                                           pch,
                                           -1,
                                           NULL,
                                           0 )) )
                    return 0;

                total_size += str_size;
                pch += strlen(pch) + 1;
            }

            /* room for final NULL */
            total_size++;

            /* allocate enough space for chars */
            if ( NULL == (wbuffer = (wchar_t *)
                 _malloc_crt( total_size * sizeof( wchar_t ) )) )
            {
                FreeEnvironmentStringsA( penv );
                return NULL;
            }

            /* do the conversion */
            pch = penv;
            pwch = wbuffer;
            while (*pch != '\0')
            {
                if ( 0 == MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED,
                                               pch,
                                               -1,
                                               pwch,
                                               total_size - (int)(pwch -
                                                 wbuffer) ) )
                {
                    _free_crt( wbuffer );
                    FreeEnvironmentStringsA( penv );
                    return NULL;
                }

                pch += strlen(pch) + 1;
                pwch += wcslen(pwch) + 1;
            }
            *pwch = L'\0';

            FreeEnvironmentStringsA( penv );
            
            return (LPVOID)wbuffer;

        }
        else   /* f_use is neither USE_A nor USE_W */
            return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\_wcserr.c ===
/***
*_wcserr.c - routine for indexing into system error list
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Returns system error message index by errno; conforms to the
*	XENIX standard, much compatibility with 1983 uniforum draft standard.
*	(wide char version of _strerror())
*
*Revision History:
*   11-30-99  GB    Module Created
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "_strerr.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\exsup2.asm ===
;***
;exsup2.asm
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This is just the C8.0 version of
;	the language-specific exception handler.  The C9.0 version is
;	found in exsup3.asm, and the routines common to both C8 and C9
;	are found in exsup.asm.
;
;Notes:
;
;Revision History:
;	01-10-94  PML	Created with __except_handler2 from exsup.asm
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_C8_EXCEPTION_REGISTRATION struc	; C8.0 version
                        dd      ?	; prev (common)
                        dd      ?	; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
    _ebp                dd      ?
    xpointers           dd      ?
_C8_EXCEPTION_REGISTRATION ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;/* _EXCEPT_HANDLER2 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler2(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
	db	'VC10'	;; VC/C++ 1.0/32-bit (C8.0) version
	db	'XC00'	;; so debugger can recognize this proc (cuda:3936)
cProc _except_handler2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  xrecord
        parmDP  registration
        parmDP  context
        parmDP  dispatcher
        localV  xp,SIZEOF_EXCEPTION_POINTERS
cBegin
	;4*4b for callee saves + 4b return address + 4b param = 24

	;DF in indeterminate state at time of exception, so clear it
	cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     short _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

        mov     ebp, [ebx._ebp]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

	; Accept <0, 0, >0 instead of just -1, 0, +1
	or	eax, eax
	jz	short _lh_continue
	js	short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
        mov     ebp, [ebx._ebp]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8

        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3
; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
        mov     ebp, [ebx._ebp]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
cEnd

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\longjmp.asm ===
;***
;longjmp.asm
;
;	Copyright (C) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp(), longjmp() & raisex() routines;
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	01-12-94  PML	Split from setjmp.asm, added C9.0 generic EH
;			callback for unwind.
;	01-11-95  SKS	Remove MASM 5.X support
;	04-11-95  JWM	Added NLG support
;	06-07-95  JWM	__SetNLGCode() used, for multithread safety.
;	06-20-95  JWM	__SetNLGCode() removed, code passed on stack (11803).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

BeginDATA

COMM    __setjmpexused:dword

EndDATA

extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbols defined in exsup.asm, sehsupp.c
extrn __except_list:near
extrn __global_unwind2:near
extrn __local_unwind2:near
extrn __rt_probe_read4@4:near
extrn __NLG_Notify:near
;EXTERN C __SetNLGCode:near

; int
; longjmp (
;	IN jmp_buf env
;	IN int val)
;
; Routine Description:
;
;	Restore the stack and register environment saved by _setjmp.
;	Reloads callee-save registers and stack pointer to that saved in
;	the jmp_buf, then returns to the point of the _setjmp call.
;
;	If exception unwinding is enabled, also reload the exception state
;	from the jmp_buf by doing an unwind (both global and local) back
;	to the old state.  Do so by checking for a new-format (C9.0)
;	jmp_buf, and call the EH longjmp unwinder saved therein if
;	found, else assume a C8.0-vintage jmp_buf and SEH.
;
; Arguments:
;
;	env - Address of the buffer holding the reload state
;	val - Value to return from the _setjmp callsite (if nonzero)
;
; Return Value:
;
;	None.  longjmp does not return directly, but instead continues
;	execution from the point of the _setjmp used to initialize the
;	jmp_buf.  That call will return the 'val' parameter if nonzero,
;	else a one.

cProc longjmp,<C,PUBLIC>
cBegin
        mov     ebx, [esp+4]            ;get jmp_buf

        ;restore ebp before possible call to local_unwind-er
        ; the call to global/local unwind will preserve this (callee save).
	mov	ebp, [ebx.saved_ebp]	;set up bp
ifdef	_NTSDK
	cmp	__setjmpexused, 0
        je      short _lj_no_unwind
endif
        mov     esi, [ebx.saved_xregistration]
        cmp     esi, dword ptr fs:__except_list
	je	short _lj_local_unwind

        push    esi
        call    __global_unwind2
        add     esp,4

_lj_local_unwind:
        cmp     esi, 0
	je	short _lj_no_unwind

	; Check if called with old or new format jmp_buf.  Look for the
	; version cookie that's only present in the new format.
	lea	eax, [ebx.version_cookie]
	push	eax
	call	__rt_probe_read4@4
	or	eax, eax
	jz	short _lj_old_unwind
	mov	eax, [ebx.version_cookie]
	cmp	eax, JMPBUF_COOKIE
	jnz	short _lj_old_unwind

	; Called with a new-format jmp_buf.  Call unwind function supplied
	; to the jmp_buf at setjmp time.
	mov	eax, [ebx.unwind_func]
	or	eax, eax
	jz	short _lj_no_unwind	;no local unwind necessary
	push	ebx
	call	eax
	jmp	short _lj_no_unwind

	; Called with an old-format jmp_buf.  Duplicate old longjmp behavior,
	; assuming there's a C8.0 SEH node at top.
_lj_old_unwind:
        mov	eax, [ebx.saved_trylevel]
	push	eax
        push    esi
        call    __local_unwind2
        add     esp, 8

_lj_no_unwind:
        push    0h
        mov     eax, [ebx.saved_return]
        call    __NLG_Notify

        mov     edx, ebx
        mov     ebx, [edx.saved_ebx]    ;recover registers...
        mov     edi, [edx.saved_edi]
        mov     esi, [edx.saved_esi]

        mov     eax, [esp+8]		;load the return value
	cmp	eax, 1			;make sure it's not 0
	adc	eax, 0

        mov     esp, [edx.saved_esp]    ;here, sp gets scorched
        add     esp, 4                  ;punt the (old) return address
        jmp     [edx.saved_return]      ;return
cEnd

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\sehprolg.asm ===
;***
;sehprolog.asm   - defines __SEH_prolog and __SEH_epilog
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       SEH prolog/epilog helper function. Sets up the frame for a function 
;	with SEH try block.
;
;Revision History:
;	03-28-2000  LL	Module created.
;
;*******************************************************************************
	title	sehprolog.asm
	.386P

.model FLAT

	ASSUME	FS: FLAT

PUBLIC	__SEH_prolog
PUBLIC	__SEH_epilog
EXTRN	__except_handler3:DWORD

_TEXT	SEGMENT


; First argument:  local frame size
; Second argument: address of SEH try table

__SEH_prolog PROC NEAR
	push	OFFSET FLAT:__except_handler3	; push address of SEH handler
	mov	eax, DWORD PTR fs:0		
	push	eax				; push previous except list head
	mov	DWORD PTR fs:0, esp		; link this node to except list
	mov	eax, DWORD PTR [esp+16]		; load frame size
	mov	DWORD PTR [esp+16], ebp		; save off EBP
	lea	ebp, [esp+16]			; setup base pointer
	sub	esp, eax			; allocate frame
	push	ebx				; push callee save regs
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebp-8]		; load return address
	mov	DWORD PTR [ebp-24], esp		; save off ESP in except record
	push	eax				; push back return address
	mov	eax, DWORD PTR [ebp-4]		; load SEH table address
	mov	DWORD PTR [ebp-4], -1		; initialize SEH state index
	mov	DWORD PTR [ebp-8], eax		; Move SEH table addr to the right place
	ret	0
__SEH_prolog ENDP


__SEH_epilog PROC NEAR
	mov	ecx, DWORD PTR [ebp-16]		; unlink from except list
	mov	DWORD PTR fs:0, ecx
	pop	ecx				; pop return address
	pop	edi				; pop callee save regs
	pop	esi
	pop	ebx
	leave
	push	ecx				; push back return address
	ret	0
__SEH_epilog ENDP

_TEXT	ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\chkesp.c ===
/***
*chkesp.c
*
*       Copyright (c) 1997-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines _chkesp() and other run-time error checking support routines.
*
*Revision History:
*       05-22-98  JWM   Support added for KFrei's RTC work; header added.
*       07-28-98  JWM   RTC update.
*       10-30-98  KBF   Quit messing with the CRT's Debug Heap flags
*       11-19-98  KBF   Added stuff to handle multiple callbacks
*       11-24-98  KBF   Added 3rd callback for memory/string function checks
*       12-03-98  KBF   Added 4th callback to disable mem/string function
*                       checks temporarily
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*
*******************************************************************************/

#include <malloc.h>
#include <dbgint.h>
#include <windows.h>
#include <rtcsup.h>

/***
*void __chkesp() - check to make sure esp was properly restored
*
*Purpose:
*       A debugging check called after every function call to make sure esp has
*       the same value before and after the call.
*
*Entry:
*       condition code: the ZF flag should be cleared if esp has changed
*
*Return:
*       <void>
*
*******************************************************************************/
void __declspec(naked) _chkesp() {
    __asm {
        jne esperror    ; 
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    /**
     * let the user know that there is a problem, and allow them to debug the
     * program.
     */
#ifdef _DEBUG
    if (_CrtDbgReport(_CRT_ERROR, __FILE__, __LINE__, "", 
        "The value of ESP was not properly saved across a function "
        "call.  This is usually a result of calling a function "
        "declared with one calling convention with a function "
        "pointer declared with a different calling convention. "     ) == 1) 
#endif    
    {

        /* start the debugger */
        __asm int 3;
    }

    __asm {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }
}

#ifdef  _RTC
/***
*void __CRT_RTC_INIT() - Initialize the RTC subsystem (in section .CRT$XIC)
*
*Purpose:
*       Setup anything involving the RTC subsystem
*
*Entry:
*       The allocation hook - function to use to allocate memory
*       The release hook - function to use to release memory
*
*Return:
*       The default error reporting function
*
*******************************************************************************/

#ifdef _RTC_ADVMEM
// This stuff is currently disabled
#define mk_list(type)                   \
    typedef struct type##_l {           \
        int version;                    \
        type##_hook_fp funcptr;         \
    } type##_l;                         \
    static struct {                     \
        int size;                       \
        int max;                        \
        type##_l *hooks;                \
    } type##_list = {0,0,0};            \
    type##_hook_fp type##_hook = 0;     \
    static int type##_version = 0

mk_list(_RTC_Allocate);
mk_list(_RTC_Free);
mk_list(_RTC_MemCheck);
mk_list(_RTC_FuncCheckSet);
HANDLE _RTC_api_change_mutex = NULL;

#define add_func(type, vers, fp) {                                       \
    if (type##_version < vers)                                           \
    {                                                                    \
        type##_version = vers;                                           \
        type##_hook = (type##_hook_fp)fp;                                \
    }                                                                    \
    if (!type##_list.hooks)                                              \
    {                                                                    \
        type##_list.hooks = (type##_l*)                                  \
            VirtualAlloc(0, 65536, MEM_RESERVE, PAGE_READWRITE);         \
    }                                                                    \
    if (type##_list.size == type##_list.max)                             \
    {                                                                    \
        type##_list.max += 4096/sizeof(type##_l);                        \
        VirtualAlloc(type##_list.hooks, type##_list.max*sizeof(type##_l),\
                     MEM_COMMIT, PAGE_READWRITE);                        \
    }                                                                    \
    type##_list.hooks[type##_list.size].funcptr = (type##_hook_fp)fp;    \
    type##_list.hooks[type##_list.size++].version = vers;                \
}

#define del_func(type, fp) {                                                    \
    int i;                                                                      \
    for (i = 0; i < type##_list.size; i++)                                      \
    {                                                                           \
        if (type##_list.hooks[i].funcptr == fp)                                 \
        {                                                                       \
            for (i++; i < type##_list.size; i++)                                \
            {                                                                   \
                type##_list.hooks[i-1].funcptr = type##_list.hooks[i].funcptr;  \
                type##_list.hooks[i-1].version = type##_list.hooks[i].version;  \
            }                                                                   \
            type##_list.size--;                                                 \
            break;                                                              \
        }                                                                       \
    }                                                                           \
    if (fp == (void*)type##_hook)                                               \
    {                                                                           \
        int hiver = 0;                                                          \
        type##_hook_fp candidate = 0;                                           \
        for (i = 0; i < type##_list.size; i++)                                  \
        {                                                                       \
            if (type##_list.hooks[i].version > hiver)                           \
            {                                                                   \
                hiver = type##_list.hooks[i].version;                           \
                candidate = type##_list.hooks[i].funcptr;                       \
            }                                                                   \
        }                                                                       \
        type##_hook = candidate;                                                \
        type##_version = hiver;                                                 \
    }                                                                           \
}

#endif

/*
    funcs is a list of function pointers that are currently defined as:
    funcs[0] = Allocation hook
    funcs[1] = Free hook
    funcs[2] = Memory Check hook
    funcs[3] = Function Check enabler/disabler hook
 */

_RTC_error_fn __cdecl 
_CRT_RTC_INIT(HANDLE mutex, void **funcs, int funccount, int version, int unloading)
{
#ifdef _RTC_ADVMEM
    // This stuff is currently disabled
    if (mutex && !_RTC_api_change_mutex)
        _RTC_api_change_mutex = mutex;
    if (funccount > 0)
    {
        if (!unloading)
        {
            switch (funccount)
            {
            default:
            case 4:
                add_func(_RTC_FuncCheckSet, version, funcs[3]);
            case 3:
                add_func(_RTC_MemCheck, version, funcs[2]);
            case 2:
                add_func(_RTC_Free, version, funcs[1]);
            case 1:
                add_func(_RTC_Allocate, version, funcs[0]);
            }
        } else {
            switch (funccount)
            {
            default:
            case 4:
                del_func(_RTC_FuncCheckSet, funcs[3]);
            case 3:
                del_func(_RTC_MemCheck, funcs[2]);
            case 2:
                del_func(_RTC_Free, funcs[1]);
            case 1:
                del_func(_RTC_Allocate, funcs[0]);
            }
        }
    }
#endif

#ifdef _DEBUG
    return &_CrtDbgReport;
#else
    return 0;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\exsup3.asm ===
;***
;exsup3.asm
;
;	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This is just the C9.0 version of
;	the language-specific exception handler.  The C8.0 version is
;	found in exsup2.asm, and the routines common to both C8 and C9
;	are found in exsup.asm.
;
;Notes:
;
;Revision History:
;	01-10-94  PML	Create VC/C++ 2.0 (C9.0) version from C8.0 original
;	01-11-95  SKS	Remove MASM 5.X support
;	04-18-95  JWM	Added NLG support
;	06-07-95  JWM	__SetNLGCode() used, for multithread safety.
;	06-20-95  JWM	__SetNLGCode() removed, code passed on stack (11803).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near
extrn __NLG_Notify:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;/* _esp, xpointers at negative offset */
;     int _esp;
;     PEXCEPTION_POINTERS xpointers;
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
;private (at negative offsets from node ptr)
    _esp		=	-8
    xpointers		=	-4
_C9_EXCEPTION_REGISTRATION struc	; C9.0 version
;public:
                        dd      ?	; prev (common)
                        dd      ?	; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
_C9_EXCEPTION_REGISTRATION ends
FRAME_EBP_OFFSET equ 16

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;EXTERN C __SetNLGCode:near

;/* _EXCEPT_HANDLER3 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler3(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
	db	'VC20'	;; VC/C++ 2.0/32-bit (C9.0) version
	db	'XC00'	;; so debugger can recognize this proc (cuda:3936)

xrecord      equ [ebp+8]
registration equ [ebp+12]
context      equ [ebp+16]
dispatcher   equ [ebp+20]

xp           equ [ebp-8]

_except_handler3 proc C
	; FPO = 0 dwords locals allocated in prolog
	;       3 dword parameters
	;       10 bytes in prolog
	;       7 registers saved (includes locals to work around debugger bug)
	;       1 EBP is used
	;       0 frame type = FPO
	.FPO    (0,3,10,7,1,0)
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	push	ebp

	;4*4b for callee saves + 4b return address + 4b param = 24

	;DF in indeterminate state at time of exception, so clear it
	cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

	lea	ebp, FRAME_EBP_OFFSET[ebx]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

	; Accept <0, 0, >0 instead of just -1, 0, +1
	or	eax, eax
	jz	short _lh_continue
	js	short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
	lea	ebp, FRAME_EBP_OFFSET[ebx]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8
        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3

        push    01h
        mov     eax, [(edi+ecx*4).specific_handler]
        call    __NLG_Notify

; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
	lea	ebp, FRAME_EBP_OFFSET[ebx]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp
	ret
_except_handler3 endp

public __seh_longjmp_unwind@4
__seh_longjmp_unwind@4 proc near
	push	ebp
	mov	ecx, 8[esp]
	mov	ebp, [ecx.saved_ebp]
	mov	eax, [ecx.saved_trylevel]
	push	eax
	mov	eax, [ecx.saved_xregistration]
	push	eax
	call	__local_unwind2
	add	esp, 8
	pop	ebp
	ret	4
__seh_longjmp_unwind@4 endp

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\_strerr.c ===
/***
*_strerr.c - routine for indexing into system error list
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Returns system error message index by errno; conforms to the
*   XENIX standard, much compatibility with 1983 uniforum draft standard.
*
*Revision History:
*   02-24-87  JCR   Renamed this routine from "strerror" to "_strerror"
*                   for MS. The new "strerror" routine conforms to the
*                   ANSI interface.
*   11-10-87  SKS   Remove IBMC20 switch
*   12-11-87  JCR   Added "_LOAD_DS" to declaration
*   01-05-87  JCR   Mthread support
*   05-31-88  PHG   Merged DLL and normal versions
*   06-06-89  JCR   386 mthread support
*   11-20-89  GJF   Fixed copyright, indents. Removed unreferenced local.
*                   Added const attribute to type of message
*   03-13-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                   <cruntime.h> and removed #include <register.h>
*   07-25-90  SBM   Removed redundant include (stdio.h)
*   10-04-90  GJF   New-style function declarator.
*   07-18-91  GJF   Multi-thread support for Win32 [_WIN32_].
*   02-17-93  GJF   Changed for new _getptd().
*   04-06-93  SKS   Replace _CRTAPI* with __cdecl
*   09-06-94  CFW   Remove Cruiser support.
*   09-06-94  CFW   Replace MTHREAD with _MT.
*   01-10-95  CFW   Debug CRT allocs.
*   29-11-99  GB    Added support for wide char by adding _wcserror() 
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <errmsg.h>
#include <syserr.h>
#include <string.h>
#include <tchar.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>

/* Max length of message = user_string(94)+system_string+2 */
/* [NOTE: The mthread error message buffer is shared by both strerror
   and _strerror so must be the max length of both. */
#define _ERRMSGLEN_ 94+_SYS_MSGMAX+2

#ifdef _UNICODE
#define _terrmsg    _werrmsg
#else
#define _terrmsg    _errmsg
#endif


/***
*char *_strerror(message) - get system error message
*
*Purpose:
*   builds an error message consisting of the users error message
*   (the message parameter), followed by ": ", followed by the system
*   error message (index through errno), followed by a newline.  If
*   message is NULL or a null string, returns a pointer to just
*   the system error message.
*
*Entry:
*   char *message - user's message to prefix system error message
*
*Exit:
*   returns pointer to static memory containing error message.
*   returns NULL if malloc() fails in multi-thread versions.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * __cdecl __wcserror(
#else
char * __cdecl _strerror (
#endif
    REG1 const _TCHAR *message
    )
{
#ifdef  _MT

    _ptiddata ptd = _getptd();
    _TCHAR *bldmsg;

#else

    static _TCHAR bldmsg[_ERRMSGLEN_];

#endif


#ifdef  _MT

    /* Use per thread buffer area (malloc space, if necessary) */
    /* [NOTE: This buffer is shared between _strerror and streror.] */

    if ( (ptd->_terrmsg == NULL) && ((ptd->_terrmsg =
            _malloc_crt(_ERRMSGLEN_ * sizeof(_TCHAR))) == NULL) )
            return(NULL);
    bldmsg = ptd->_terrmsg;

#endif

    /* Build the error message */

    bldmsg[0] = '\0';

    if (message && *message) {
        _tcscat( bldmsg, message );
        _tcscat( bldmsg, _T(": "));
    }

#ifdef _UNICODE
    mbstowcs(bldmsg + wcslen(bldmsg), _sys_err_msg( errno ), _ERRMSGLEN_ - wcslen(bldmsg));
#else
    strcat( bldmsg, _sys_err_msg( errno ) );
#endif
    return( _tcscat( bldmsg, _T("\n")) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\exsup.asm ===
;***
;exsup.asm
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Exception handling for i386.  This file contains those routines
;	common to both C8.0 and C9.0.
;
;Notes:
;
;Revision History:
;	04-13-93  JWM	setjmp(), longjmp() & raisex() moved to setjmp.asm;
;                       common data definitions moved to exsup.inc.
;	10-18-93  GJF	Ensure direction flag is clear in _except_handler2
;	12-16-93  PML	Accept <0,0,>0 from except filter, not just -1,0,+1
;	01-10-94  PML	Moved C8-specific __except_handler2 to exsup2.inc.
;			Only C8/C9 common routines left here.
;	01-20-94  GJF	Gave _EXCEPTION_REGISTRATION a _COMMON suffix (fix
;			from SteveWo).
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  SKS	Remove MASM 5.X support
;	04-18-95  JWM	Added NLG support
;	04-21-95  JWM	NLG routines moved from setjmp.asm, NLG data from
;			frame.cpp.
;	04-25-95  JWM	Added __NLG_Return2 label.
;	06-07-95  JWM	NLG now multithread safe.
;	06-20-95  JWM	dwCode passed on stack (11803).
;	07-11-95  JWM	unwanted prologue removed from NLG_Notify (11803).
;	07-21-95  JWM	Added new entry point, _NLG_Notify1 (16585).
;	03-09-01  PML   Add FPO directives for proper callstacks (vs7#221754)
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?
ifndef _BUILD_DLL_LIB_
extrn _RtlUnwind@16:near
endif           ; _BUILD_DLL_LIB_

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
_EXCEPTION_REGISTRATION_COMMON struc	; C8.0/C9.0 common only
                        dd      ?	; prev (OS-req, def'd in exsup.inc)
                        dd      ?	; handler (ditto)
;private:
    scopetable          dd      ?	; C8/C9 common
    trylevel            dd      ?	; C8/C9 common
_EXCEPTION_REGISTRATION_COMMON ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

assumes DS,DATA
assumes FS,DATA

public __except_list
__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginDATA

__NLG_Destination _NLG_INFO <>
PUBLIC __NLG_Destination

EndDATA

BeginCODE

ifndef _BUILD_DLL_LIB_

;NB: call to RtlUnwind appears to trash ebx! and possibly others so just
; to be safe, we save all callee save regs.
cProc _global_unwind2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  stop
cBegin
        push    0                       ; ReturnValue
        push    0                       ; ExceptionRecord
        push    offset flat:_gu_return  ; TargetIp
        push    stop                    ; TargetFrame

        call    _RtlUnwind@16
_gu_return:
cEnd

endif           ; _BUILD_DLL_LIB_

;_unwind_handler(
;  PEXCEPTION_RECORD xr,
;  PREGISTRATION_RECORD establisher,
;  PCONTEXT context,
;  PREGISTRATION_RECORD dispatcher);
;
;this is a special purpose handler used to guard our local unwinder.
; its job is to catch collided unwinds.
;
;NB: this code is basically stolen from the NT routine xcptmisc.asm
; and is basically the same method used by the system unwinder (RtlUnwind).
;
cProc _unwind_handler,<C>
cBegin
        mov     ecx, dword ptr [esp+4]
        test    dword ptr [ecx.exception_flags], EXCEPTION_UNWIND_CONTEXT
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jz      short _uh_return

    ; We collide in a _local_unwind.  We set the dispatched to the
    ; establisher just before the local handler so we can unwind
    ; any future local handlers.

        mov     eax, [esp+8]            ; Our establisher is the one
                                        ; in front of the local one

        mov     edx, [esp+16]
        mov     [edx], eax              ; set dispatcher to local_unwind2

        mov     eax, DISPOSITION_COLLIDED_UNWIND
_uh_return:
cEnd

;/* _LOCAL_UNWIND2 - run all termination handlers listed in the scope table
; * associated with the given registration record, from the current lexical
; * level through enclosing levels up to, but not including the given 'stop'
; * level.
; */
;void _local_unwind2(PEXCEPTION_REGISTRATION xr, int stop)
;{
;    int ix;
;
;    for(ix=xr->trylevel; ix!=-1 && ix!=stop; ix=xr->xscope[i].enclosing_level){
;       /* NULL indicates that this entry is for a termination handler */
;       if(xr->xscope[i].filter==NULL){
;           /* NB: call to the termination handler may trash callee save regs */
;           (*xr->xscope[i].specific_handler)();
;       }
;    }
;    xr->trylevel=stop;
;}
;/* NOTE: frame (ebp) is setup by caller of __local_unwind2 */

PUBLIC	__NLG_Return2

cProc _local_unwind2,<C,PUBLIC>
cBegin
        .FPO    (0,2,3,3,0,0)
        push    ebx
        push    esi
        push    edi     ;call to the handler may trash, so we must save it

        mov     eax, [esp+16]           ; (eax) = PEXCEPTION_REGISTRATION

        ;link in a handler to guard our unwind
	push	eax
        push    TRYLEVEL_INVALID
        push    OFFSET FLAT:__unwind_handler
        push    fs:__except_list
        mov     fs:__except_list, esp

_lu_top:
        mov     eax, [esp+32]           ; (eax) = PEXCEPTION_REGISTRATION
        mov     ebx, [eax.scopetable]
        mov     esi, [eax.trylevel]

        cmp     esi, -1                 ; REVIEW: do we need this extra check?
        je      short _lu_done
        cmp     esi, [esp+36]
        je      short _lu_done

        lea     esi, [esi+esi*2]        ; esi*= 3

        mov     ecx, [(ebx+esi*4).enclosing_level]
        mov     [esp+8], ecx            ; save enclosing level
        mov     [eax.trylevel], ecx

        cmp     dword ptr [(ebx+esi*4).filter], 0
        jnz     short _lu_continue

        push    0101h
        mov     eax, [(ebx+esi*4).specific_handler]
        call    _NLG_Notify

        call    [(ebx+esi*4).specific_handler]

__NLG_Return2::
_lu_continue:
        jmp     short _lu_top
_lu_done:
        pop     fs:__except_list
        add     esp, 4*3                ; cleanup stack

        pop     edi                     ; restore c-runtime registers
        pop     esi
        pop     ebx
cEnd

;/* _ABNORMAL_TERMINATION - return TRUE if __finally clause entered via
; * _local_unwind2.
; */
;BOOLEAN _abnormal_termination(void);
cProc _abnormal_termination,<C,PUBLIC>
cBegin
        .FPO    (0,0,0,0,0,0)
        xor     eax, eax                ; assume FALSE

        mov     ecx, fs:__except_list
        cmp     [ecx.handler], offset FLAT:__unwind_handler
        jne     short _at_done          ; UnwindHandler first?

        mov     edx, [ecx+12]           ; establisher of local_unwind2
        mov     edx, [edx.trylevel]     ; is trylevel the same as the
        cmp     [ecx+8], edx            ; local_unwind level?
        jne     short _at_done          ; no - then FALSE

        mov     eax, 1                  ; currently in _abnormal_termination
_at_done:
cEnd

;
; NLG entrypoints, for debugger support
; On entry: address of non-local goto in eax
;

public __NLG_Dispatch

OPTION PROLOGUE:NONE
OPTION EPILOGUE:NONE

_NLG_Notify1 PROC C PUBLIC
        push ebx
        push ecx
        mov  ebx, OFFSET __NLG_Destination
	jmp  __NLG_go		; ecx is already set
_NLG_Notify1 ENDP

_NLG_Notify PROC C PUBLIC, dwInCode:DWORD
        push ebx
        push ecx
        mov  ebx, OFFSET __NLG_Destination
        mov  ecx, dwInCode
__NLG_Go:
        mov  [ebx.dwCode], ecx
        mov  [ebx.uoffDestination], eax
        mov  [ebx.uoffFramePointer], ebp
__NLG_Dispatch::
        pop  ecx
        pop  ebx
        ret  4
_NLG_Notify ENDP

OPTION PROLOGUE:PROLOGUEDEF
OPTION EPILOGUE:EPILOGUEDEF

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\w_str.c ===
/***
*w_str.c - W version of GetStringType.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetStringTypeA or GetStringTypeW depending on which is
*       unstubbed.
*
*Revision History:
*       09-14-93  CFW   Module created.
*       09-17-93  CFW   Use unsigned chars.
*       09-23-93  CFW   Correct NLS API params and comments about same.
*       10-07-93  CFW   Optimize WideCharToMultiByte, use NULL default char.
*       10-22-93  CFW   Remove bad verification test from "A" version.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       11-09-93  CFW   Allow user to pass in code page.
*       11-18-93  CFW   Test for entry point function stubs.
*       02-23-94  CFW   Use W flavor whenever possible.
*       03-31-94  CFW   Include awint.h.
*       04-18-94  CFW   Use lcid value if passed in.
*       04-18-94  CFW   Use calloc and don't test the NULL.
*       10-24-94  CFW   Must verify GetStringType return.
*       12-21-94  CFW   Remove invalid MB chars NT 3.1 hack.
*       12-27-94  CFW   Call direct, all OS's have stubs.
*       01-10-95  CFW   Debug CRT allocs.
*       02-15-97  RDK   For narrow string type, try W version first so
*                       Windows NT can process nonANSI codepage correctly.
*       03-16-97  RDK   Added error flag to __crtGetStringTypeA.
*       05-12-97  GJF   Split off from old aw_str.c and moved into a separate
*                       file. Revised to use _alloca instead of malloc. Also,
*                       removed some silly code and reformatted.
*       08-19-98  GJF   Use _malloc_crt if _alloca fails.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       05-17-00  GB    Use ERROR_CALL_NOT_IMPLEMENTED for existance of W API
*       08-23-00  GB    Fixed bug with non Ansi CP on Win9x.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl __crtGetStringTypeW - Get type information about a wide string.
*
*Purpose:
*       Internal support function. Assumes info in wide string format. Tries
*       to use NLS API call GetStringTypeW if available and uses GetStringTypeA
*       if it must. If neither are available it fails and returns FALSE.
*
*Entry:
*       DWORD    dwInfoType  - see NT\Chicago docs
*       LPCWSTR  lpSrcStr    - wide string for which character types are 
*                              requested
*       int      cchSrc      - wide char (word) count of lpSrcStr (including 
*                              NULL if any)
*       LPWORD   lpCharType  - array to receive character type information
*                              (must be same size as lpSrcStr)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       int      lcid        - for A call, specify LCID, If 0, use 
*                              __lc_handle[LC_CTYPE].
*
*Exit:
*       Success: TRUE
*       Failure: FALSE
*
*Exceptions:
*
*******************************************************************************/

BOOL __cdecl __crtGetStringTypeW(
        DWORD    dwInfoType,
        LPCWSTR  lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid
        )
{                      
        static int f_use = 0;

        /* 
         * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */

        if (0 == f_use)
        {
            unsigned short dummy;

            if (0 != GetStringTypeW(CT_CTYPE1, L"\0", 1, &dummy))
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if (USE_W == f_use)
        {
            return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            int buff_size;
            BOOL retbool;
            unsigned char *buffer;
            WORD * pwCharInfo;
            int malloc_flag1 = 0;
            int malloc_flag2 = 0;
            int AnsiCP;

            /*
             * Convert string and return the requested information. Note that 
             * we are converting to a multibyte string so there is not a 
             * one-to-one correspondence between number of wide chars in the 
             * input string and the number of *bytes* in the buffer. However, 
             * there had *better be* a one-to-one correspondence between the 
             * number of wide characters and the number of WORDs in the
             * return buffer.
             */

            /*
             * Use __lc_codepage for conversion if code_page not specified
             */

            if (0 == lcid)
                lcid = __lc_handle[LC_CTYPE];
            if (0 == code_page)
                code_page = __lc_codepage;

            /*
             * Always use Ansi codepage with Ansi WinAPI because they use
             * Ansi codepage
             */
            if ( code_page != (AnsiCP = __ansicp(lcid)))
            {
                if (AnsiCP != -1)
                    code_page = AnsiCP;
            }

            /* find out how big a buffer we need */
            if ( 0 == (buff_size = WideCharToMultiByte( code_page,
                                                        0,
                                                        lpSrcStr,
                                                        cchSrc,
                                                        NULL,
                                                        0,
                                                        NULL,
                                                        NULL )) )
                return FALSE;

            /* allocate enough space for chars */
            __try {
                buffer = (unsigned char *)_alloca( sizeof(char) * buff_size );
                (void)memset( buffer, 0, sizeof(char) * buff_size );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                buffer = NULL;
            }

            if ( buffer == NULL ) {
                if ( (buffer = (unsigned char *)_calloc_crt(sizeof(char), buff_size))
                    == NULL )
                    return FALSE;
                malloc_flag1++;
            }

            /* do the conversion */
            if ( 0 == WideCharToMultiByte( code_page, 
                                           0,
                                           lpSrcStr,
                                           cchSrc, 
                                           buffer,
                                           buff_size,
                                           NULL,
                                           NULL ) )
                goto error_cleanup;

            /* allocate enough space for result (+1 for sanity check) */
            __try {
                pwCharInfo = (WORD *)_alloca( sizeof(WORD) * (buff_size + 1) );
            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                _resetstkoflw();
                pwCharInfo = NULL;
            }

            if ( pwCharInfo == NULL ) {
                if ( (pwCharInfo = (WORD *)_malloc_crt(sizeof(WORD) * (buff_size + 1)))
                    == NULL )
                    goto error_cleanup;
                malloc_flag2++;
            }

            /* do we use default lcid */
            if (0 == lcid)
                lcid = __lc_handle[LC_CTYPE];

            /* set to known value */
            pwCharInfo[cchSrc - 1] = pwCharInfo[cchSrc] = 0xFFFF;

            /* obtain result */
            retbool = GetStringTypeA( lcid, dwInfoType, buffer, buff_size,
                                      pwCharInfo );

            /*
             * GetStringTypeA does not reveal how many WORDs have been
             * modifed - to be safe we use another buffer and then
             * verify that EXACTLY cchSrc WORDs were modified. Note that
             * not all multibyte LCID/codepage combos are guaranteed to work.
             */
            if ( (pwCharInfo[cchSrc - 1] == 0xFFFF) || (pwCharInfo[cchSrc] != 0xFFFF) )
                retbool = FALSE;
            else
                memmove(lpCharType, pwCharInfo, cchSrc * sizeof(WORD));

            if ( malloc_flag2 )
                _free_crt(pwCharInfo);

error_cleanup:
            if ( malloc_flag1 )
                _free_crt(buffer);

            return retbool;
        }
        else   /* f_use is neither USE_A nor USE_W */
            return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\setjmpex.asm ===
;***
;setjmpex.asm
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmpex().
;
;Notes:
;
;Revision History:
;	10-14-93  GJF	Grabbed from NT SDK tree, cleaned up a bit and this
;			header was added.
;	01-13-94  PML	Trigger off __longjmpex instead of __setjmpex, since
;			_setjmp is an intrinsic, but longjmp isn't.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
.list


extrn _longjmp:near

;
; If setjmpex is included then set __setjmpexused = 1.
;

BeginDATA
            public  __setjmpexused
__setjmpexused  dd      1
EndDATA

BeginCODE

public __longjmpex
__longjmpex PROC NEAR
        jmp     _longjmp
__longjmpex ENDP

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\sehsupp.c ===
/***
*sehsupp.c - helper functions for Structured Exception Handling support
*
*	Copyright (C) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains _rt_probe_read.  Helper for the SEH runtime support
*	routines (longjmp in particular).  Much of the SEH code is written
*	in asm, so these routines are available when probing memory in ways
*	that must be guarded with __try/__except in case of access violation.
*
*Revision History:
*	12-05-93  PML	Module created.
*	12-22-93  GJF	Made #define WIN32_LEAN_AND_MEAN conditional.
*	01-12-94  PML	Rewritten - still need helpers, just different ones
*
*******************************************************************************/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>

/***
*BOOL __stdcall _rt_probe_read4 - Check if a DWORD is readable
*
*Purpose:
*  Internal support function called by longjmp.  Check if a DWORD is
*  readable under a __try/__except.
*
*Entry:
*  DWORD * p - Pointer to DWORD to be probed
*
*Exit:
*  Success: TRUE - Able to read
*  Failure: FALSE - Access violation while reading
*
******************************************************************************/

BOOL __stdcall _rt_probe_read4(
    DWORD * ptr)
{
    BOOL readable;

    __try
    {
	*(volatile DWORD *)ptr;
	readable = TRUE;
    }
    __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
		? EXCEPTION_EXECUTE_HANDLER
		: EXCEPTION_CONTINUE_SEARCH)
    {
	readable = FALSE;
    }

    return readable;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\callsite.cpp ===
/***
*callsite.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   This stuff has been permanently canceled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#if 0

#error This stuff has all been cut - the CRT's heap could provide
#error equivalent functionality

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\contain.cpp ===
/***
*contain.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Added _RTC_ prefix, _RTC_ADVMEM stuff
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

_RTC_Container *
_RTC_Container::AddChild(_RTC_HeapBlock *hb) throw()
{
    if (kids)
    {
        _RTC_Container *p = kids->get(hb);
        if (p)
            return p->AddChild(hb);
        kids->add(hb);

    } else
    {   
        kids = new _RTC_BinaryTree(new _RTC_Container(hb));
    }
    return this;
}


_RTC_Container *
_RTC_Container::DelChild(_RTC_HeapBlock* hb) throw()
{
    if (kids)
    {
        _RTC_Container *p = kids->get(hb);
        if (p)
        {
            if (p->inf == hb) {
                kids->del(hb)->kill();
                return this;
            } else
                return p->DelChild(hb);
        }
        kids->del(hb);
        return this;
    } else
        return 0;
}


_RTC_Container *
_RTC_Container::FindChild(_RTC_HeapBlock *i) throw()
{
    if (inf == i)
        return this;
    else if (kids)
    {
        _RTC_Container *res = kids->get(i);
        if (res)
            return res->FindChild(i);
    }
    return 0;
}


void 
_RTC_Container::kill() throw()
{
    if (kids) 
    {
        _RTC_BinaryTree::iter i;

        for (_RTC_Container *c = kids->FindFirst(&i); c; c = kids->FindNext(&i))
            c->kill();

        delete kids;
        kids = 0;
    } 
    
    if (inf)
    {
        delete inf;
        inf = 0;
    }
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\bintree.cpp ===
/***
*bintree.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   Removed alloca dependency for CRT independence
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Everything is now prefixed with _RTC_
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

void 
_RTC_BinaryTree::BinaryNode::kill() throw()
{
    if (l)
    {
        l->kill();
        delete l;
    }
    if (r)
    {
        r->kill();
        delete r;
    }
    delete val;
}

_RTC_Container *
_RTC_BinaryTree::get(_RTC_HeapBlock *data) throw()
{
    BinaryNode *t = tree;
    while (t)
    {
        if (t->val->contains(data))
            return t->val;

        if (*t->val->info() < *data)
            t = t->l;
        else
            t = t->r;
    }
    return 0;
}


_RTC_Container *
_RTC_BinaryTree::add(_RTC_HeapBlock* data) throw()
{
    BinaryNode *t = tree;
    if (!tree)
    {
        tree = new BinaryNode(0,0,new _RTC_Container(data));
        return tree->val;
    }
    for (;;)
    {
        if (*t->val->info() < *data)
        {
            // before this one
            if (t->l)
                t = t->l;
            else 
            {
                t->l = new BinaryNode(0,0,new _RTC_Container(data));
                return t->l->val;
            }
        } else 
        {
            if (t->r)
                t = t->r;
            else
            {
                t->r = new BinaryNode(0, 0, new _RTC_Container(data));
                return t->r->val;
            }
        }
    }
}


_RTC_Container *
_RTC_BinaryTree::del(_RTC_HeapBlock *data) throw()
{
    BinaryNode **prv = &tree;
    while (*prv && (*prv)->val->info() != data)
    {
        prv = (*(*prv)->val->info() < *data) ? &(*prv)->l : &(*prv)->r;
    }

    if (!*prv)
        return 0;

    BinaryNode *dl = *prv;
    
    if (dl->r) 
    {
        *prv = dl->r;
        BinaryNode *left = dl->r;
        
        while (left->l)
            left = left->l;

        left->l = dl->l;
    
    } else 
        *prv = dl->l;

    _RTC_Container* res = dl->val;
    delete dl;
    return res;
}


_RTC_Container *
_RTC_BinaryTree::FindNext(_RTC_BinaryTree::iter *i) throw()
{
    // Return the next element from the iterator
    // If the iterator is done, free up it's memory
    if (++i->curSib >= i->totSibs) 
    {
        VirtualFree(i->allSibs, 0, MEM_RELEASE);
        i->curSib = i->totSibs = 0;
        return 0;
    } else
        return i->allSibs[i->curSib];
}

_RTC_Container *
_RTC_BinaryTree::FindFirst(_RTC_BinaryTree::iter *i) throw()
{
    // Initialize the iterator, and return it's first element
    // Flatten the siblings into a nice array..
    struct stk {
        stk(stk *p, BinaryNode *i) : next(p), cur(i) {}
        void *operator new(unsigned) {return _RTC_heap2->alloc();}
        void operator delete(void *p) {_RTC_heap2->free(p);}
        stk *next;
        BinaryNode *cur;
    };

    stk *stack = new stk(0, this->tree);
    stk *list = 0;
    stk *tmp;

    int count = 0;
    
    // Build a list of all elements (reverse in-order traversal)
    while (stack) 
    {
        BinaryNode *cur = stack->cur;
        tmp = stack;
        stack = stack->next;
        delete tmp;
        while (cur) 
        {
            list = new stk(list, cur);
            count++;
            if (cur->l)
                stack = new stk(stack, cur->l);
            cur = cur->r;
        }
    }
    i->totSibs = 0;
    i->curSib = 0;
    if (!count)
    {
        i->allSibs = 0;
        return 0;
    }

    i->allSibs = (_RTC_Container**)VirtualAlloc(0, sizeof(_RTC_Container*) * count,
                                           MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    while (list)
    {
        i->allSibs[i->totSibs++] = list->cur->val;
        tmp = list;
        list = list->next;
        delete tmp;
    }
    return i->allSibs[0];

}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\chsyheap.cpp ===
/***
*chsyheap.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-25-99  KBF   Renamed - _RTC_SimpleHeap instead of CheesyHeap
*       05-26-99  KBF   Removed RTCl and RTCv, added _RTC_ADVMEM stuff
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

// This is my 'Cheesy Heap' implementation...

/* Here are the sizes that I need:

BinaryNode              3 DWORDS - use heap4
BinaryTree              1 DWORD  - use heap2
Container               2 DWORDS - use heap2
BreakPoint              2 DWORDS - use heap2
HashTable<HeapBlock>    2 DWORDS - use heap2
HeapBlock               6 DWORDS - use heap8

Container[] - short term...
CallSite[]  - permanent
HeapBlock[] - permanent

*/

_RTC_SimpleHeap *_RTC_heap2 = 0;
_RTC_SimpleHeap *_RTC_heap4 = 0;
_RTC_SimpleHeap *_RTC_heap8 = 0;

void *
_RTC_SimpleHeap::operator new(unsigned) throw()
{
    void *res = VirtualAlloc(NULL, ALLOC_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
#ifdef _RTC_SHADOW
    if (shadow)
        _RTC_MSCommitRange((memptr)res, ALLOC_SIZE, IDX_STATE_ILLEGAL);
#endif
    return res;
}    

void 
_RTC_SimpleHeap::operator delete(void *addr) throw()
{
    VirtualFree(addr, 0, MEM_RELEASE);
#ifdef _RTC_SHADOW
    if (shadow)
        _RTC_MSDecommitRange((memptr)addr, ALLOC_SIZE);
#endif
}

_RTC_SimpleHeap::_RTC_SimpleHeap(unsigned blockSize)  throw()
{
    // Flag it as the only item in the heap
    head.next = 0;
    head.inf.top.nxtFree = 0;

    // Align the block size
    head.inf.top.wordSize = 8;
    blockSize = (blockSize - 1) >> 3;
    
    while (blockSize) {
        blockSize >>= 1;
        head.inf.top.wordSize <<= 1;
    }

    // Build up the free-list
    head.free = (FreeList*)(((unsigned)&head) + 
                           ((head.inf.top.wordSize < sizeof(HeapNode)) ?
                                sizeof(HeapNode) :
                                head.inf.top.wordSize));
    FreeList *t = head.free;
    while (((unsigned)t) + head.inf.top.wordSize < ((unsigned)&head) + ALLOC_SIZE)
    {
        t->next = (FreeList*)(((unsigned)t) + head.inf.top.wordSize);
        t = t->next;
    }
    t->next = 0;
}

_RTC_SimpleHeap::~_RTC_SimpleHeap() throw()
{
    // Free all sections that we have allocated
    HeapNode *n, *c = head.next;
    while(c) {
        n = c->next;
        _RTC_SimpleHeap::operator delete(c);
        c = n;
    }
    // the 'head' page will be handled by delete
}

void *
_RTC_SimpleHeap::alloc() throw()
{
    void *res;

    // If there's a free item, remove it from the list
    // And decrement the free count for it's parent page
    
    if (head.free) 
    {
        // There's a free block on the first page
        res = head.free;
        head.free = head.free->next;

        // Since it's on the top page, there's no free-count to update,
        // And it ain't on no stinkin' free-list
        
    } else if (head.inf.top.nxtFree)
    {
        // There's a free block on some page
        HeapNode *n = head.inf.top.nxtFree;
        
        res = n->free;
        n->free = n->free->next;
        n->inf.nontop.freeCount--;

        if (!n->free)
        {
            // This page is now full, so it must be removed from the freelist
            for (n = head.next; n && !n->free; n = n->next) {}
            // Now the nxtFree pointer is either null (indicating a full heap)
            // or it's pointing to a page that has free nodes
            head.inf.top.nxtFree = n;
        }
        
    } else 
    {
        // No pages have any free blocks
        // Get a new page, and add it to the list
        HeapNode *n = (HeapNode *)_RTC_SimpleHeap::operator new(0);
        
        // Count the number of free nodes
        n->inf.nontop.freeCount = 
            (ALLOC_SIZE - sizeof(HeapNode)) / head.inf.top.wordSize - 1;
   
        res = (void *)(((unsigned)n) + 
                        ((head.inf.top.wordSize < sizeof(HeapNode)) ?
                            sizeof(HeapNode) :
                            head.inf.top.wordSize));
        
        // Build the free-list for this node
        FreeList *f;
        for (f = n->free = (FreeList*)(((unsigned)res) + head.inf.top.wordSize);
             ((unsigned)f) + head.inf.top.wordSize < ((unsigned)n) + ALLOC_SIZE;
             f = f->next)
            f->next = (FreeList*)(((unsigned)f) + head.inf.top.wordSize);
        
        f->next = 0;
             
        // Stick it in the page list
        n->next = head.next;
        n->inf.nontop.prev = &head;
        head.next = n;
        
        // Flag this as a page with free stuff on it...
        head.inf.top.nxtFree = n;
    }
    return res;
}

void
_RTC_SimpleHeap::free(void *addr) throw()
{
    // Get the heap node for this address
    HeapNode *n = (HeapNode *)(((unsigned)addr) & ~(ALLOC_SIZE - 1));

    // Stick this sucker back in the free list
    FreeList *f = (FreeList *)addr;
    f->next = n->free;
    n->free = f;

    if (n == &head)
        // If this is in the head node, just return...
        return;
    
    if (++n->inf.nontop.freeCount == 
        (ALLOC_SIZE - sizeof(HeapNode)) / head.inf.top.wordSize)
    {
        // This page is free
        if (head.inf.top.freePage)
        {
            // There's already another free page, go ahead and free this one
            
            // (there's always a previous node)
            n->inf.nontop.prev->next = n->next;
            if (n->next)
                n->next->inf.nontop.prev = n->inf.nontop.prev;
            _RTC_SimpleHeap::operator delete(n);
                
            if (head.inf.top.nxtFree == n)
            {   
                // This was the free page
                // find a page with some free nodes on it...
                for (n = head.next; !n->free; n = n->next) {}
                // ASSERT(n)
                // If n is null, we're in some serious trouble...
                head.inf.top.nxtFree = n;
            }
            // If it wasn't the free page, we're just fine...
        } else
        { 
            // flag the freePages to say we have a 100% free page
            head.inf.top.freePage = true;

            if (head.inf.top.nxtFree == n)
            {
                // If this is the free page,
                // try to find another page with some free nodes
                HeapNode *t;
                for (t = head.next; t && (!t->free || t == n) ; t = t->next) {}

                // if there was a different page with some nodes, pick it
                head.inf.top.nxtFree = t ? t : n;
            }
        }
    } else
        // This page isn't empty, so just set it as the next free
        head.inf.top.nxtFree = n;
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\setjmp3.asm ===
;***
;setjmp3.asm
;
;	Copyright (C) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp(), longjmp() & raisex() routines;
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	01-12-94  PML	Split from setjmp.asm, added C9.0 generic EH
;			callback for unwind.
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list

assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbol defined in exsup.asm
extrn __except_list:near

; int
; _setjmp3 (
;	OUT jmp_buf env,
;	int count,
;	...)
;
; Routine Description:
;
;	(New) implementation of setjmp intrinsic.  Saves the current
;	nonvolatile register state in the specified jump buffer and returns
;	a function value of zero.
;
;	Saves the callee-save registers, stack pointer and return address.
;	Also saves the exception registration list head.  If setjmp is
;	called from a function using any form of exception handling, then
;	additional data is also saved allowing some form of local unwind
;	at longjmp time to restore the proper exception handling state.
;
; Arguments:
;
;	env - Address of the buffer for storing the state information
;	count - count of additional DWORDs of information.  Zero if setjmp
;		not called from a function with any form of EH.
;	...	Additional data pushed by the setjmp intrinsic if called
;		from a function with any form of EH.  The first DWORD is
;		a function ptr which will be called at longjmp time to do
;		the local unwind.  The second DWORD is the try level to be
;		restored (if applicable).  Any further data is saved in the
;		generic data array in the jmp_buf for use by the local
;		unwind function.
;
; Return Value:
;
;	A value of zero is returned.

public __setjmp3
__setjmp3 PROC NEAR
        mov     edx, [esp+4]
        mov     [edx.saved_ebp], ebp    ; old bp and the rest
        mov     [edx.saved_ebx], ebx
        mov     [edx.saved_edi], edi
        mov     [edx.saved_esi], esi
        mov     [edx.saved_esp], esp

        mov     eax, [esp]              ; return address
        mov     [edx.saved_return], eax

	mov	dword ptr [edx.version_cookie], JMPBUF_COOKIE
	mov	dword ptr [edx.unwind_func], 0

        mov     eax, dword ptr fs:__except_list
        mov     [edx.saved_xregistration], eax

	cmp	eax, -1 		; -1 means no higher-level handler
	jnz	short _s3_get_count
        mov     dword ptr [edx.saved_trylevel], -1 ;something invalid
	jmp	short _s3_done

_s3_get_count:
	mov	ecx, [esp+8]		; count of additional data
	or	ecx, ecx
	jz	short _s3_default_trylevel

	mov	eax, [esp+12]		; func to do local unwind at longjmp
	mov	[edx.unwind_func], eax
	dec	ecx
	jnz	_s3_save_trylevel

	; Not called from a function with any form of EH, or no trylevel
	; passed.  Save the TryLevel from the topmost EH node anyway,
	; assuming a C8.0 SEH node.  If we're linked to an obsolete CRTDLL
	; and call the old longjmp, then we'll still do the right thing.
_s3_default_trylevel:
        mov     eax, [eax + C8_TRYLEVEL]
        mov     [edx.saved_trylevel], eax
	jmp	short _s3_done

_s3_save_trylevel:
	mov	eax, [esp+16]		; try level to unwind to
	mov	[edx.saved_trylevel], eax
	dec	ecx
	jz	short _s3_done

	push	esi
	push	edi
	lea	esi, [esp+20+8]
	lea	edi, [edx.unwind_data]
	cmp	ecx, 6			; save up to 6 more DWORDs in jmp_buf
	jbe	_s3_save_data
	mov	ecx, 6

_s3_save_data:
	rep movsd
	pop	edi
	pop	esi

_s3_done:
        sub     eax, eax
        ret
__setjmp3 ENDP

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\misc\i386\setjmp.asm ===
;***
;setjmp.asm
;
;	Copyright (C) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Contains setjmp();
;	split from exsup.asm for granularity purposes.
;
;Notes:
;
;Revision History:
;	04-13-93  JWM	Module created.
;	10-14-93  GJF	Merged in NT verson.
;	01-12-94  PML	Added C9.0 generic EH callback for unwind.  Split
;			into setjmp.asm, setjmp3.asm, and longjmp.asm.
;	02-10-94  GJF	-1 is the end-of-exception-handler chain marker, not 0.
;	01-11-95  GJF	Purged raisex(). Nobody uses it. Nobody even remembers
;			what it was used for (it was part of the test harness
;			for early EH unit testing).
;	01-11-95  SKS	Remove MASM 5.X support
;	01-13-95  JWM	Added NLG routines for debugger support.
;	04-11-95  JWM	NLG_Return moved to lowhelpr.asm.
;	04-21-95  JWM	NLG routines moved to exsup.asm.
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =	1
?NODATA =	1
include cmacros.inc
include exsup.inc
.list


assumes DS,DATA
assumes FS,DATA

BeginCODE

; Following symbol defined in exsup.asm
extrn __except_list:near

; int
; _setjmp (
;	OUT jmp_buf env)
;
; Routine Description:
;
;	(Old) implementation of setjmp intrinsic.  Saves the current
;	nonvolatile register state in the specified jump buffer and returns
;	a function value of zero.
;
;	Saves the callee-save registers, stack pointer and return address.
;	Also saves the exception registration list head.
;
;	This code is only present for old apps that link to the DLL runtimes,
;	or old object files compiles with C8.0.  It intentionally duplicates
;	the old setjmp bugs, blindly assuming that the topmost EH node is a
;	C8.0 SEH node.
;
; Arguments:
;
;	env - Address of the buffer for storing the state information
;
; Return Value:
;
;	A value of zero is returned.

public __setjmp
__setjmp PROC NEAR
        mov     edx, [esp+4]
        mov     [edx.saved_ebp], ebp    ; old bp and the rest
        mov     [edx.saved_ebx], ebx
        mov     [edx.saved_edi], edi
        mov     [edx.saved_esi], esi
        mov     [edx.saved_esp], esp

        mov     eax, [esp]              ; return address
        mov     [edx.saved_return], eax

        mov     eax, dword ptr fs:__except_list
        mov     [edx.saved_xregistration], eax

	cmp	eax, -1 		; -1 means no higher-level handler
	jnz	short _sj_save_trylevel
        mov     dword ptr [edx.saved_trylevel], -1 ;something invalid
	jmp	short _sj_done

_sj_save_trylevel:
        mov     eax, [eax + C8_TRYLEVEL]
        mov     [edx.saved_trylevel], eax

_sj_done:
        sub     eax, eax
        ret
__setjmp ENDP


EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\memory.cpp ===
/***
*memory.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       12-01-98  KBF   Added some debugging info for _RTC_DEBUG
*       12-02-98  KBF   Fixed MC 11240
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Wrapped in _RTC_ADVMEM, simplified due to loss of -RTClv
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

#ifdef _RTC_DEBUG

#include <windows.h>

#pragma intrinsic(strcpy)
#pragma intrinsic(strcat)

char *IntToString(int i)
{
    static char buf[15];
    bool neg = i < 0;
    int pos = 14;
    buf[14] = 0;
    do {
        int val = i % 16;
        if (val < 10)
            val += '0';
        else
            val = val - 10 + 'A';
        buf[--pos] = val;
        i /= 16;
    } while (i);
    if (neg)
        buf[--pos] = '-';
    return &buf[pos];
}

#endif



void __cdecl
_RTC_Allocate(void *addr, size_t size, short level)
{
    if (!addr)
        return;

#ifdef _RTC_DEBUG
    char buf[88];
    strcpy(buf, IntToString((int)retaddr));
    strcat(buf, " Allocate Memory located @ ");
    strcat(buf, IntToString((int)addr));
    strcat(buf, " of size ");
    strcat(buf, IntToString((int)size));
    strcat(buf, "\n");
    OutputDebugString(buf);
#endif

    _RTC_HeapBlock key(addr, level);
    _RTC_HeapBlock *hb = _RTC_heapblocks->find(&key);
    
    if (!hb) 
    {
        hb = new _RTC_HeapBlock(addr, level, size);
        _RTC_heapblocks->add(hb);
    
    } else
    {
        hb->size(size);
    }
    
    if (level) 
    {
        _RTC_Container *parent = _RTC_memhier->AddChild(hb);
        
        if (parent && parent->info())
        {
            hb->tag(_RTC_MSRenumberShadow((memptr)addr, size, parent->info()->tag()));
            return;
        }
    }
    hb->tag(_RTC_MSAllocShadow((memptr)addr, size, IDX_STATE_FULLY_KNOWN));
}

void __cdecl
_RTC_Free(void *mem, short level)
{
    if (!mem)
        return;


#ifdef _RTC_DEBUG
    char buf[88];
    strcpy(buf, IntToString((int)retaddr));
    strcat(buf, " Freeing Memory located at ");
    strcat(buf, IntToString((int)mem));
    strcat(buf, "\n");
    OutputDebugString(buf);
#endif

    bool fail = false;
    
    _RTC_HeapBlock key(mem, level);
    _RTC_HeapBlock *hb = _RTC_heapblocks->find(&key);
    
    if (hb)
    {
        if (level)
        {
            _RTC_Container *parent = _RTC_memhier->DelChild(hb);
            
            if (parent)
            {
                if (parent->info())
                    _RTC_MSRestoreShadow((memptr)(hb->addr()), hb->size(), parent->info()->tag());
                else
                    _RTC_MSFreeShadow((memptr)(hb->addr()), hb->size());
            }
        } else 
        {
            _RTC_heapblocks->del(hb);
            _RTC_MSFreeShadow((memptr)(hb->addr()), hb->size());
            delete hb;
        }
    }
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\fileio.cpp ===
/***
*fileio.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code & removed
*                       alloca to make more CRT independent
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   This stuff has been permanently cut
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#if 0

#error This stuff has all been cut, permanently - it belongs in the heap code,
#error not in compiler-provided extras

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\initsect.cpp ===
/***
*initsect.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       11-03-98  KBF   Module incorporated into CRTs
*       05-11-99  KBF   Error if RTC support define not enabled
*       08-10-99  RMS   Use external symbols for BBT support
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "internal.h"
#include "rtcpriv.h"
#include "sect_attribs.h"

#pragma const_seg(".rtc$IAA")
extern "C" const _CRTALLOC(".rtc$IAA") _PVFV __rtc_iaa[] = { 0 };


#pragma const_seg(".rtc$IZZ")
extern "C" const _CRTALLOC(".rtc$IZZ") _PVFV __rtc_izz[] = { 0 };


#pragma const_seg(".rtc$TAA")
extern "C" const _CRTALLOC(".rtc$TAA") _PVFV __rtc_taa[] = { 0 };


#pragma const_seg(".rtc$TZZ")
extern "C" const _CRTALLOC(".rtc$TZZ") _PVFV __rtc_tzz[] = { 0 };

#pragma const_seg()


#pragma comment(linker, "/MERGE:.rtc=.rdata")

#ifndef _RTC_DEBUG
#pragma optimize("g", on)
#endif

// Run the RTC initializers
#ifdef _XBOX
extern "C" int __declspec(nothrow) __cdecl _RTC_Initialize()
#else
extern "C" void __declspec(nothrow) __cdecl _RTC_Initialize()
#endif // XBOX
{
    // Just step thru every item
    const _PVFV *f;
    for (f = __rtc_iaa + 1; f < __rtc_izz; f++)
    {
	__try {
            if (*f)
                (**f)();
        } __except(1){}
    }
    return 0;
}

// Run the RTC terminators
extern "C" void __declspec(nothrow) __cdecl _RTC_Terminate()
{
    // Just step thru every item
    const _PVFV *f;
    for (f = __rtc_taa + 1; f < __rtc_tzz; f++)
    {
	__try {
            if (*f)
                (**f)();
        } __except(1){}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\pdblkup.cpp ===
/***
*pdblkup.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Minor Cleanup, _RTC_ prefix added to GetSrcLine
*       11-30-99  PML   Compile /Wp64 clean.
*       06-20-00  KBF   Major mods to use PDBOpenValidate3 & MSPDB70
*       03-19-01  KBF   Fix buffer overruns (vs7#227306), eliminate all /GS
*                       checks (vs7#224261), use correct VS7 registry key.
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"
#include <tlhelp32.h>

#pragma warning(disable:4311 4312)      // 32-bit specific, ignore /Wp64 warnings

#define REGISTRY_KEY_MASTER HKEY_LOCAL_MACHINE
#define REGISTRY_KEY_NAME "EnvironmentDirectory"
#define REGISTRY_KEY_LOCATION "SOFTWARE\\Microsoft\\VisualStudio\\7.0\\Setup\\VS"

static const char *mspdbName = "MSPDB70.DLL";
static const mspdbNameLen = 11;

// Here's some stuff from the PDB header
typedef char *          SZ;
typedef ULONG           SIG;    // unique (across PDB instances) signature
typedef long            EC;     // error code
typedef USHORT          ISECT;  // section index
typedef LONG            OFF;    // offset
typedef LONG            CB;     // count of bytes
typedef BYTE*           PB;     // pointer to some bytes
struct PDB;                 // program database
struct DBI;                 // debug information within the PDB
struct Mod;                 // a module within the DBI
#define pdbRead                 "r"

// Here's some stuff from the psapi header
typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;

static HINSTANCE mspdb  = 0;
static HINSTANCE psapi  = 0;
static HINSTANCE imghlp = 0;
static HINSTANCE kernel = 0;

#define declare(rettype, call_type, name, parms)\
    extern "C" { typedef rettype ( call_type * name ## Proc) parms; }
#define decldef(rettype, call_type, name, parms)\
    declare(rettype, call_type, name, parms)\
    static name ## Proc name = 0

#define GetProcedure(lib, name) name = (name ## Proc)GetProcAddress(lib, #name)
#define GetW9xProc(lib, name) name ## W9x = (name ## W9xProc)GetProcAddress(lib, #name)

#define GetReqProcedure(lib, name, err) {if (!(GetProcedure(lib, name))) return err;}
#define GetReqW9xProc(lib, name, err) {if (!(GetW9xProc(lib, name))) return err;}

 
/* PDB functions */
decldef(BOOL, __cdecl, PDBOpenValidate3, 
        (SZ szExe, SZ szPath, OUT EC* pec, OUT SZ szError, OUT SZ szDbgPath, OUT DWORD *pfo, OUT DWORD *pcb, OUT PDB** pppdb));
decldef(BOOL, __cdecl, PDBOpenDBI, 
        (PDB* ppdb, SZ szMode, SZ szTarget, OUT DBI** ppdbi));
decldef(BOOL, __cdecl, DBIQueryModFromAddr,
        (DBI* pdbi, ISECT isect, OFF off, OUT Mod** ppmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb));
decldef(BOOL, __cdecl, ModQueryLines,
        (Mod* pmod, PB pbLines, CB* pcb));
decldef(BOOL, __cdecl, ModClose,
        (Mod* pmod));
decldef(BOOL, __cdecl, DBIClose, 
        (DBI* pdbi));
decldef(BOOL, __cdecl, PDBClose, 
        (PDB* ppdb));

/* ImageHlp Functions */
decldef(PIMAGE_NT_HEADERS, __stdcall, ImageNtHeader,
        (IN PVOID Base));

/* PSAPI Functions */
decldef(BOOL, WINAPI, GetModuleInformation,
        (HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb));
decldef(BOOL, WINAPI, EnumProcessModules,
        (HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded));

/* Win9X Functions */
decldef(HANDLE, WINAPI, CreateToolhelp32SnapshotW9x,
        (DWORD dwFlags, DWORD th32ProcessID));
decldef(BOOL, WINAPI, Module32FirstW9x,
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme));
decldef(BOOL, WINAPI, Module32NextW9x,
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme));

/* AdvAPI32 Functions */
declare(WINADVAPI LONG, APIENTRY, RegOpenKeyExA,
        (HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult));
declare(WINADVAPI LONG, APIENTRY, RegQueryValueExA,
        (HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData));
declare(WINADVAPI LONG, APIENTRY, RegCloseKey,
        (HKEY hKey));

struct ImageInfo {
    DWORD sig;
    DWORD BaseAddress;
    DWORD BaseSize;
    HMODULE hndl;
    PIMAGE_NT_HEADERS img;
    PIMAGE_SECTION_HEADER sectHdr;
    char *imgName;
    ImageInfo *next;
};

static ImageInfo *lImages = 0;

// I do lots of assignments in conditionals intentionally
#pragma warning(disable:4706) 

static ImageInfo *
GetImageInfo(DWORD address)
{
    ImageInfo *res, *cur;
    // This will not run the first time, because lImages is null
    for (res = lImages; res; res = res->next)
    {
        if (res->BaseAddress <= address && address - res->BaseAddress <= res->BaseSize)
            return res;
    }

    // We didn't find the address in the images we already know about
    // Let's refresh the image list, to see if it was delay-loaded
    
    // Clear out the old list
    while (lImages)
    {
        ImageInfo *next = lImages->next;
        HeapFree(GetProcessHeap(), 0, lImages);
        lImages = next;
    }

    if (!imghlp)
    {
        // We haven't already loaded all the DLL entrypoints we need

        kernel = LoadLibrary("KERNEL32.DLL");
        imghlp = LoadLibrary("IMAGEHLP.DLL");

        if (!kernel || !imghlp)
            return 0;
        
        GetReqProcedure(imghlp, ImageNtHeader, 0);

        GetW9xProc(kernel, CreateToolhelp32Snapshot);

        if (!CreateToolhelp32SnapshotW9x)
        {
            // We're running under WinNT, use PSAPI DLL

            psapi = LoadLibrary("PSAPI.DLL");
            if (!psapi) 
                return 0;

            GetReqProcedure(psapi, EnumProcessModules, 0);
            GetReqProcedure(psapi, GetModuleInformation, 0);
        } else
        {
            // We're running under Win9X, use the toolhelp functions
            GetReqW9xProc(kernel, Module32First, 0);
            GetReqW9xProc(kernel, Module32Next, 0);
        }
    }

    // Now we have all the callbacks we need, so get the process information needed
    if (!CreateToolhelp32SnapshotW9x)
    {
        // We're running under NT4
        // Note that I "prefer" using toolhelp32 - it's supposed to show up in NT5...
        HMODULE hModules[512];
        HANDLE hProcess = GetCurrentProcess();
        DWORD imageCount;

        if (!EnumProcessModules(hProcess, hModules, 512 * sizeof(HMODULE), &imageCount))
            return 0;

        imageCount /= sizeof(HMODULE);

        MODULEINFO info;
        for (DWORD i = 0; i < imageCount; i++)
        {
            if (!GetModuleInformation(hProcess, hModules[i], &info, sizeof(MODULEINFO)))
                return 0;
            
            if (!(cur = (ImageInfo *)HeapAlloc(GetProcessHeap(), 0, sizeof(ImageInfo))))
                goto CHOKE;

            cur->hndl = hModules[i];
            cur->BaseAddress = (DWORD)info.lpBaseOfDll;
            cur->BaseSize = info.SizeOfImage;
            cur->imgName = 0;

            cur->next = lImages;
            lImages = cur;       
        }
    } else
    {
        HANDLE snap;
        if ((snap = CreateToolhelp32SnapshotW9x(TH32CS_SNAPMODULE, 0)) == (HANDLE)-1)
            return 0;

        MODULEENTRY32 *info = (MODULEENTRY32*)_alloca(sizeof(MODULEENTRY32));
        info->dwSize = sizeof(MODULEENTRY32);
        if (Module32FirstW9x(snap, info))
        {
            do {
                ImageInfo *newImg;
                
                if (!(newImg = (ImageInfo *)HeapAlloc(GetProcessHeap(), 0, sizeof(ImageInfo))))
                {
                    CloseHandle(snap);
                    goto CHOKE;
                }
                
                newImg->hndl = info->hModule;
                newImg->BaseAddress = (DWORD)info->modBaseAddr;
                newImg->BaseSize = info->modBaseSize;
                newImg->imgName = 0;
            
                newImg->next = lImages;
                lImages = newImg;       

            } while (Module32NextW9x(snap, info));
        }
        CloseHandle(snap);
    }

    for (cur = lImages; cur; cur = cur->next)
    {
        cur->img = ImageNtHeader((void *)cur->BaseAddress);
        cur->sectHdr = IMAGE_FIRST_SECTION(cur->img);
        char *buf = (char*)_alloca(513);
        buf[512] = '\0';
        if (!GetModuleFileName(cur->hndl, buf, 512))
            goto CHOKE;
        int nmLen;
        for (nmLen = 0; buf[nmLen]; nmLen++) {}
        if (!(cur->imgName = (char*)HeapAlloc(GetProcessHeap(), 0, nmLen+1)))
            goto CHOKE;
        nmLen = 0;
        do {
            cur->imgName[nmLen] = buf[nmLen];
        } while (buf[nmLen++]);

    }

    for (res = lImages; res; res = res->next)
    {
        if (res->BaseAddress <= address && address - res->BaseAddress <= res->BaseSize)
            return res;
    }

CHOKE:
    while (lImages) {
        ImageInfo *next = lImages->next;
        
        if (lImages->imgName)
            HeapFree(GetProcessHeap(), 0, lImages->imgName);
        HeapFree(GetProcessHeap(), 0, lImages);
        lImages = next;
    }
    return 0;
}

static HINSTANCE
GetPdbDll()
{
    static BOOL alreadyTried = FALSE;
    // If we already tried to load it, return
    if (alreadyTried)
        return (HINSTANCE)0;
    alreadyTried = TRUE;

    HINSTANCE res;
    if (res = LoadLibrary(mspdbName))
        return res;

    // Load the AdvAPI32.DLL entrypoints
    HINSTANCE advapi32;
    if (!(advapi32 = LoadLibrary("ADVAPI32.DLL")))
        return 0;
    RegOpenKeyExAProc RegOpenKeyExA;
    GetReqProcedure(advapi32, RegOpenKeyExA, 0);
    RegQueryValueExAProc RegQueryValueExA;
    GetReqProcedure(advapi32, RegQueryValueExA, 0);
    RegCloseKeyProc RegCloseKey;
    GetReqProcedure(advapi32, RegCloseKey, 0);

    char *keyname = REGISTRY_KEY_LOCATION;
    BYTE *buf;
    HKEY key1;
    long pos, err;
    DWORD type, len;

    err = RegOpenKeyExA(REGISTRY_KEY_MASTER, keyname, 0, KEY_QUERY_VALUE, &key1);
    if (err != ERROR_SUCCESS)
    {
        FreeLibrary(advapi32);
        return 0;
    }
    
    err = RegQueryValueExA(key1, REGISTRY_KEY_NAME, NULL, &type, 0, &len);
    if (err != ERROR_SUCCESS)
        return 0;
    len += 2 + mspdbNameLen;
    buf = (BYTE*)_alloca(len * sizeof(BYTE));
    err = RegQueryValueExA(key1, REGISTRY_KEY_NAME, NULL, &type, buf, &len);
    RegCloseKey(key1);
    FreeLibrary(advapi32);

    if (err != ERROR_SUCCESS)
        return 0;
    if (buf[len - 2] != '\\')
        buf[len - 1] = '\\';
    else
        len--;

    for (pos = 0; pos <= mspdbNameLen; pos++)
        buf[len + pos] = mspdbName[pos];

    return LoadLibrary((const char *)buf);
}

BOOL
_RTC_GetSrcLine(
    DWORD address,
    char* source,
    int sourcelen,
    int* pline,
    char** moduleName
    )
{
    struct SSrcModuleHdr { 
        WORD cFile; 
        WORD cSeg; 
    };
    struct SStartEnd {
        DWORD start;
        DWORD end;
    };
    SSrcModuleHdr *liHdr;
    ULONG *baseSrcFile; // SSrcModuleHdr.cFile items
    SStartEnd *startEnd; // SSrcModuleHdr.cSeg items
    USHORT *contribSegs; // SSrcModuleHdr.cSeg items (+1 for alignement)
    int i;
    ImageInfo *iInf;

    PDB *ppdb;
    DBI *pdbi;
    Mod *pmod;

    EC err;
    // CB_ERR_MAX from linker is 1024 - not particularly secure, but oh well.
    // This whole thing should be rewritten using DIA instead of MSPDB for next rev...
    char *errname = (char*)_alloca(1024);
    
    OFF imageAddr;
    OFF secAddr;
    OFF offsetRes;
    USHORT sectionIndex;
    USHORT sectionIndexRes;
    long size;
    PB lineBuffer;
    static BOOL PDBOK = FALSE;

    BOOL res = FALSE;
    
    *pline = 0;
    *source = 0;
    *moduleName = 0;

    // First, find the image (DLL/EXE) in which this address occurs
    iInf = GetImageInfo(address);
    
    if (!iInf)
        // We didn't find this address is the list of modules, so quit
        goto DONE0;


    // Now get the Relative virtual address of the address given
    imageAddr = address - iInf->BaseAddress;
    
    *moduleName = iInf->imgName;

    res = TRUE;

    // Try to load the PDB DLL
    if (!PDBOK) 
    {
        // If we already loaded it before, there must be some missing API function
        if (mspdb || !(mspdb = GetPdbDll()))
            goto DONE0;

        GetReqProcedure(mspdb, PDBOpenValidate3, 0);
        GetReqProcedure(mspdb, PDBOpenDBI, 0);
        GetReqProcedure(mspdb, DBIQueryModFromAddr, 0);
        GetReqProcedure(mspdb, ModQueryLines, 0);
        GetReqProcedure(mspdb, ModClose, 0);
        GetReqProcedure(mspdb, DBIClose, 0);
        GetReqProcedure(mspdb, PDBClose, 0);
        PDBOK = TRUE;
    }

    // Now find the section index & section-relative address
    secAddr = -1;
    for (sectionIndex = 0; sectionIndex < iInf->img->FileHeader.NumberOfSections; sectionIndex++)
    {
        if (iInf->sectHdr[sectionIndex].VirtualAddress < (unsigned)imageAddr &&
            imageAddr - iInf->sectHdr[sectionIndex].VirtualAddress < iInf->sectHdr[sectionIndex].SizeOfRawData)
        {
            secAddr = imageAddr - iInf->sectHdr[sectionIndex].VirtualAddress;
            break;
        }
    }

    if (secAddr == -1)
        goto DONE0;

    // Open the PDB for this image
    DWORD fo, cb;
    char *path = (char*)_alloca(MAX_PATH);
    // Rumor has it that I'll need to switch to OV5 instead of OV3 for this call soon...
    if (!PDBOpenValidate3(iInf->imgName, "", &err, errname, path, &fo, &cb, &ppdb))
        goto DONE0;

    // Get the DBI interface for the PDB
    if (!PDBOpenDBI(ppdb, pdbRead, 0, &pdbi))
        goto DONE1;

    // Now get the Mod from the section index & the section-relative address
    if (!DBIQueryModFromAddr(pdbi, ++sectionIndex, secAddr, &pmod, &sectionIndexRes, &offsetRes, &size))
        goto DONE2;

    // Get the size of the buffer we need
    if (!ModQueryLines(pmod, 0, &size) || !size)
        goto DONE3;

    lineBuffer = (PB)HeapAlloc(GetProcessHeap(), 0, size);
    if (!ModQueryLines(pmod, lineBuffer, &size))
        goto DONE3;

    // fill in the number of source files, and their corresponding regions
    liHdr = (SSrcModuleHdr*)lineBuffer;
    baseSrcFile = (ULONG *)(lineBuffer + sizeof(SSrcModuleHdr));
    // I think I can actually ignore the rest of the module header info
    startEnd = (SStartEnd *)&(baseSrcFile[liHdr->cFile]);
    contribSegs = (USHORT *)&(startEnd[liHdr->cSeg]);

    for (i = 0; i < liHdr->cFile; i++)
    {
        BYTE *srcBuff = lineBuffer + baseSrcFile[i];
        USHORT segCount = *(USHORT *)srcBuff;
        ULONG *baseSrcLn = &(((ULONG *)srcBuff)[1]);
        SStartEnd *segStartEnd = (SStartEnd*)&(baseSrcLn[segCount]);
        char *srcName = (char *)&segStartEnd[segCount];

        // Step through the various bunch of segments this src file contributes
        for (int j = 0; j < segCount; j++)
        {
            if (segStartEnd[j].start <= (unsigned)secAddr &&
                (unsigned)secAddr <= segStartEnd[j].end) 
            {
                // If this segment contains the section address, 
                // we've found the right one, so find the closest line number
                BYTE *segLnBuf = &lineBuffer[baseSrcLn[j]];
                USHORT pairCount = *(USHORT*)&(segLnBuf[sizeof(USHORT)]);
                ULONG *offsets = (ULONG *)&(segLnBuf[sizeof(USHORT)*2]);
                USHORT *linNums = (USHORT *)&(offsets[pairCount]);
                int best = -1;
                ULONG dist = 0xFFFFFFFF;
                for (int k = 0; k < pairCount; k++)
                {
                    if (secAddr - offsets[k] < dist)
                    {
                        best = k;
                        dist = secAddr - offsets[k];
                    }
                }
                if (best < 0)
                    // It shoulda been here, but it wasn't...
                    goto DONE4;
                
                *pline = linNums[best];
                for (j = 0; srcName[j] && j < sourcelen; j++)
                    source[j] = srcName[j];
                source[(j < sourcelen) ? j : sourcelen-1] = 0;

                goto DONE4;
            }
        }
    }

DONE4:
    HeapFree(GetProcessHeap(), 0, lineBuffer);
DONE3:
    ModClose(pmod);
DONE2:
    DBIClose(pdbi);
DONE1:
    PDBClose(ppdb);
DONE0:
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\convert.cpp ===
/***
*convert.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   Moved pragma optimize to rtcpriv header
*       05-11-99  KBF   Error if RTC support define not enabled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

char __fastcall 
_RTC_Check_2_to_1(short big)
{
    unsigned bits = big & 0xFF00;
    if (bits && bits != 0xFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

char __fastcall 
_RTC_Check_4_to_1(int big)
{
    unsigned int bits = big & 0xFFFFFF00;
    if (bits && bits != 0xFFFFFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

char __fastcall 
_RTC_Check_8_to_1(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFFFFFFFF00;
    if (bits && bits != 0xFFFFFFFFFFFFFF00)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (char)big;
}

short __fastcall 
_RTC_Check_4_to_2(int big)
{
    unsigned int bits = big & 0xFFFF0000;
    if (bits && bits != 0xFFFF0000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (short)big;
}

short __fastcall 
_RTC_Check_8_to_2(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFFFFFF0000;
    if (bits && bits != 0xFFFFFFFFFFFF0000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (short)big;
}

int __fastcall 
_RTC_Check_8_to_4(__int64 big)
{
    unsigned __int64 bits = big & 0xFFFFFFFF00000000;
    if (bits && bits != 0xFFFFFFFF00000000)
        _RTC_Failure(_ReturnAddress(), _RTC_CVRT_LOSS_INFO);
    return (int)big;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\error.cpp ===
/***
*error.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       11-03-98  KBF   added throw() to eliminate C++ EH code
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Added -RTCu stuff, _RTC_ prefix on all non-statics
*       11-30-99  PML   Compile /Wp64 clean.
*       03-19-01  KBF   Fix buffer overruns (vs7#227306), eliminate all /GS
*                       checks (vs7#224261).
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#pragma intrinsic(strcpy)
#pragma intrinsic(strcat)
#pragma intrinsic(strlen)

#ifdef _XBOX
// for now, we just assume the debugger is always present
#define _IsDebuggerPresent() TRUE
#else
static int __cdecl _IsDebuggerPresent();
#endif // XBOX
int _RTC_ErrorLevels[_RTC_ILLEGAL] = {1,1,1,1};
static const char *_RTC_ErrorMessages[_RTC_ILLEGAL+1] =
{
    "The value of ESP was not properly saved across a function "
        "call.  This is usually a result of calling a function "
        "declared with one calling convention with a function "
        "pointer declared with a different calling convention.\n\r",
    "A cast to a smaller data type has caused a loss of data.  "
        "If this was intentional, you should mask the source of "
        "the cast with the appropriate bitmask.  For example:  \n\r"
        "\tchar c = (i & 0xFF);\n\r"
        "Changing the code in this way will not affect the quality of the resulting optimized code.\n\r",
    "Stack memory was corrupted\n\r",
    "A local variable was used before it was initialized\n\r",
#ifdef _RTC_ADVMEM
    "Referencing invalid memory\n\r",
    "Referencing memory across different blocks\n\r",
#endif
    "Unknown Runtime Check Error\n\r"
};

static const BOOL _RTC_NoFalsePositives[_RTC_ILLEGAL+1] =
{
    TRUE,   // ESP was trashed
    FALSE,  // Shortening convert
    TRUE,   // Stack corruption
    TRUE,   // Uninitialized use
#ifdef _RTC_ADVMEM
    TRUE,   // Invalid memory reference
    FALSE,  // Different memory blocks
#endif
    TRUE    // Illegal
};

#ifdef _XBOX
// Don't have ImageHlp, so need to handle GetSrcLine ourselves.  Rather than simply comment the calls out,
// the function is instead stubbed in case it is decided to try to implement the full functionality later on.
char g_szTempModName[] = "Undefined";
BOOL _RTC_GetSrcLine(DWORD dwAddr, char *szName, int nNameBufLen, int *pnLineNum, char **ppmoduleName)
{
    strcpy(szName, "Undefined");
    nNameBufLen = strlen(szName);
    *pnLineNum = -1;
    *ppmoduleName = (char*)&g_szTempModName;

    return TRUE;
}
#endif

// returns TRUE if debugger understands, FALSE if not
static BOOL
DebuggerProbe( DWORD dwLevelRequired ) throw()
{
    EXCEPTION_VISUALCPP_DEBUG_INFO info;
    BYTE bDebuggerListening = FALSE;

    info.dwType = EXCEPTION_DEBUGGER_PROBE;
    info.DebuggerProbe.dwLevelRequired = dwLevelRequired;
    info.DebuggerProbe.pbDebuggerPresent = &bDebuggerListening;

    __try
    {
        HelloVC( info );
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }

    return (BOOL)bDebuggerListening;
}

// returns TRUE if debugger reported it (or was ignored), FALSE if runtime needs to report it
static int
DebuggerRuntime( DWORD dwErrorNumber, BOOL bRealBug, PVOID pvReturnAddr, LPCWSTR pwMessage ) throw()
{
    EXCEPTION_VISUALCPP_DEBUG_INFO info;
    BYTE bDebuggerListening = FALSE;

    info.dwType = EXCEPTION_DEBUGGER_RUNTIMECHECK;
    info.RuntimeError.dwRuntimeNumber = dwErrorNumber;
    info.RuntimeError.bRealBug = bRealBug;
    info.RuntimeError.pvReturnAddress = pvReturnAddr;
    info.RuntimeError.pbDebuggerPresent = &bDebuggerListening;
    info.RuntimeError.pwRuntimeMessage = pwMessage;

    __try
    {
        HelloVC( info );
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }

    return (BOOL)bDebuggerListening;
}

static void
failwithmessage(void *retaddr, int crttype, int errnum, const char *msg)
{
    _RTC_error_fn fn = _RTC_GetErrorFunc(retaddr);
    bool dobreak;
    if (DebuggerProbe( EXCEPTION_DEBUGGER_RUNTIMECHECK ))
    {
        wchar_t *buf = (wchar_t*)_alloca(sizeof(wchar_t) * (strlen(msg) + 2));
        int i;
        for (i = 0; msg[i]; i++)
            buf[i] = msg[i];
        buf[i] = 0;
        if (DebuggerRuntime(errnum, _RTC_NoFalsePositives[errnum], retaddr, buf))
            return;
        dobreak = false;
    } else
        dobreak = true;
    if (!fn || (dobreak && _IsDebuggerPresent()))
        DebugBreak();
    else
    {
        char *srcName = (char*)_alloca(sizeof(char) * 513);
        int lineNum;
        char *moduleName;
        _RTC_GetSrcLine(((DWORD)(uintptr_t)retaddr)-5, srcName, 512, &lineNum, &moduleName);
        // We're just running - report it like the user setup (or the default way)
        // If we don't recognize this type, it defaults to an error
        if (fn(crttype, srcName, lineNum, moduleName,
               "Run-Time Check Failure #%d - %s", errnum, msg) == 1)
            DebugBreak();
    }
}

void __cdecl
_RTC_Failure(void *retaddr, int errnum)
{
    int crttype;
    const char *msg;

    if (errnum < _RTC_ILLEGAL && errnum >= 0) {
        crttype = _RTC_ErrorLevels[errnum];
        msg = _RTC_ErrorMessages[errnum];
    } else {
        crttype = 1;
        msg = _RTC_ErrorMessages[_RTC_ILLEGAL];
        errnum = _RTC_ILLEGAL;
    }

    // If we're running inside a debugger, raise an exception

    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        failwithmessage(retaddr, crttype, errnum, msg);
    }
}

static
char *IntToString(int i)
{
    static char buf[15];
    bool neg = i < 0;
    int pos = 14;
    buf[14] = 0;
    do {
        buf[--pos] = i % 10 + '0';
        i /= 10;
    } while (i);
    if (neg)
        buf[--pos] = '-';
    return &buf[pos];
}

void __cdecl
_RTC_MemFailure(void *retaddr, int errnum, const void *assign)
{
    char *srcName = (char*)_alloca(sizeof(char) * 513);
    int lineNum;
    char *moduleName;
    int crttype = _RTC_ErrorLevels[errnum];
    if (crttype == _RTC_ERRTYPE_IGNORE)
        return;
    _RTC_GetSrcLine(((DWORD)(uintptr_t)assign)-5, srcName, 512, &lineNum, &moduleName);
    if (!lineNum)
        _RTC_Failure(retaddr, errnum);
    else
    {
        char *msg = (char*)_alloca(strlen(_RTC_ErrorMessages[errnum]) +
                                    strlen(srcName) + strlen(moduleName) +
                                    150);
        strcpy(msg, _RTC_ErrorMessages[errnum]);
        strcat(msg, "Invalid pointer was assigned at\n\rFile:\t");
        strcat(msg, srcName);
        strcat(msg, "\n\rLine:\t");
        strcat(msg, IntToString(lineNum));
        strcat(msg, "\n\rModule:\t");
        strcat(msg, moduleName);
        failwithmessage(retaddr, crttype, errnum, msg);
    }
}

void __cdecl
_RTC_StackFailure(void *retaddr, const char *varname)
{
    int crttype = _RTC_ErrorLevels[_RTC_CORRUPT_STACK];
    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        char *msg = (char*)_alloca(strlen(varname) + 80);
        strcpy(msg, "Stack around the variable '");
        strcat(msg, varname);
        strcat(msg, "' was corrupted.");
        failwithmessage(retaddr, crttype, _RTC_CORRUPT_STACK, msg);
    }
}

void __cdecl
_RTC_UninitUse(const char *varname)
{
    int crttype = _RTC_ErrorLevels[_RTC_UNINIT_LOCAL_USE];
    if (crttype != _RTC_ERRTYPE_IGNORE)
    {
        char *msg = (char*)_alloca(strlen(varname) + 80);
        if (varname)
        {
            strcpy(msg, "The variable '");
            strcat(msg, varname);
            strcat(msg, "' is being used without being defined.");
        } else
        {
            strcpy(msg, "A variable is being used without being defined.");
        }
        failwithmessage(_ReturnAddress(), crttype, _RTC_UNINIT_LOCAL_USE, msg);
    }
}

#ifndef _XBOX

/* The rest of this file just implements "IsDebuggerPresent" functionality */

#pragma pack (push, 1)

typedef struct _TIB {
    PVOID   ExceptionList;
    PVOID   StackLimit;
    PVOID   StackBase;
    PVOID   SubSystemTib;
    PVOID   Something1;
    PVOID   ArbitraryUserPointer;
    struct _TIB*    Self;
    WORD    Flags;
    WORD    Win16MutextCount;
    PVOID   DebugContext;
    DWORD   CurrentPriority;
    DWORD   MessageQueueSelector;
    PVOID*  TlsSlots;       // most likely an array
} TIB;

#pragma pack (pop)

//
// Define function to return the current Thread Environment Block
//  AXPMOD - v-caseyc 9/22/98  We use and intrinsic function _rdteb to get the Thread
//  Information Block

#if defined(_M_ALPHA)
void *_rdteb(void);
#pragma intrinsic(_rdteb)

static _inline TIB* GetCurrentTib() { return (TIB*) _rdteb(); }

#else   // If not _M_ALPHA                  (AXPMOD)

#pragma warning (disable:4035)
#define OffsetTib 0x18
static _inline TIB* GetCurrentTib() { __asm mov eax, fs:[OffsetTib] }
#pragma warning (default:4035)

#endif  // _M_ALPHA                         (End AXPMOD)


#define DLL_NOT_FOUND_EXCEPTION (0xc0000135L)

typedef BOOL (WINAPI* NT_IS_DEBUGGER_PRESENT) ();

static NT_IS_DEBUGGER_PRESENT FnIsDebuggerPresent = NULL;

static PVOID
WinGetDebugContext()
{
    return GetCurrentTib()->DebugContext;
}

// here's the Win95 version of IsDebuggerPresent
static BOOL WINAPI
Win95IsDebuggerPresent()
{
    if (WinGetDebugContext ()) {
        return TRUE;
    } else {
        return FALSE;
    }
}


static BOOL
Initialize()
{
    HINSTANCE       hInst = NULL;

    hInst = LoadLibrary ("Kernel32.dll");

    FnIsDebuggerPresent =
        (NT_IS_DEBUGGER_PRESENT) GetProcAddress (hInst, "IsDebuggerPresent");

    if (!FnIsDebuggerPresent) {
        OSVERSIONINFOA *VersionInfo = (OSVERSIONINFOA*)_alloca(sizeof(OSVERSIONINFOA));
        memset((void*)VersionInfo, 0, sizeof(OSVERSIONINFOA));

        VersionInfo->dwOSVersionInfoSize = sizeof (OSVERSIONINFOA);

        if (GetVersionExA (VersionInfo) &&
            VersionInfo->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
            VersionInfo->dwMajorVersion == 4)
            FnIsDebuggerPresent = Win95IsDebuggerPresent;
    }

    return !!(FnIsDebuggerPresent);
}


// This is a version of IsDebuggerPresent () that works for all Win32 platforms.
static int __cdecl
_IsDebuggerPresent()
{
    static BOOL     fInited = FALSE;

    if (!fInited) {
        if (!Initialize())
            RaiseException (DLL_NOT_FOUND_EXCEPTION, 0, 0, NULL);
        fInited = TRUE;
    }

    return FnIsDebuggerPresent();
}

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\init.cpp ===
/***
*init.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       10-12-98  KBF   Moved _RTC_IsEnabled here from UserAPI, and fixed it
*       10-13-98  KBF   Added _RTC_SetOutOfMemFunc
*       10-28-98  KBF   Added _RTC_Shutdown to prevent locks on FreeLibrary
*       11-03-98  KBF   added throw() to eliminate C++ EH code & improved
*                       termination code
*       11-24-98  KBF   Added additional callback to _RTC_MSPtrMemCheckN
*       11-25-98  KBF   Fixed initialization problem
*       12-03-98  KBF   Added APISet callback, and changed MSPtrMemCheckN
*                       to CheckMem
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   General cleanup - RTClv cut, _RTC_ADVMEM for reenabling
*                       -RTCm later
*       08-03-99  KBF   Fixed some pretty bad handle leaks, code cleanup &
*                       commenting
*       11-30-99  PML   Compile /Wp64 clean.
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"
#pragma intrinsic(memset)

#ifdef _RTC_ADVMEM
// This is the process wide global data struct pointer
// It must maintain backward compatibility at all times!
_RTC_globals                    *_RTC_globptr = 0;
// This is only actually used for shadow memory, but it doesn't really hurt
// And it serves as a placeholder for future work
CRITICAL_SECTION                _RTC_memlock;

    HashTable<_RTC_HeapBlock>   *_RTC_heapblocks    = 0;
    _RTC_Container              *_RTC_memhier       = 0;
    shadowtag                   *_RTC_shadow        = 0;
    index_elem                  *_RTC_pageidx       = 0;
    bool                        *_RTC_pi_array      = 0;
    bool                        _RTC_shadowmemory   = false;
#   define                      FUNCCOUNT           4
#else
#   define                      FUNCCOUNT           1
#endif // _RTC_ADVMEM

#ifdef _RTC_ADVMEM
static _RTC_Funcs   this_image;
static char         name[40]            = "#--------RTCSubsystem";  // scoped name for process wide synchronization
static HANDLE       init_mutex          = INVALID_HANDLE_VALUE;           // mutex for initialization & termination only
static HANDLE       work_mutex          = INVALID_HANDLE_VALUE;           // mutex for all RTC stuff
static HANDLE       sharedmem           = INVALID_HANDLE_VALUE;           // the memory mapped file
static void         *funcs[FUNCCOUNT]   = {                         // List of function pointers that the CRT need hooks too
#                                           ifdef _RTC_ADVMEM
                                                &_RTC_APISet, &_RTC_Allocate, &_RTC_Free, &_RTC_CheckMem_API
#                                           else
                                                0
#                                           endif
                                          };

static _RTC_globals * GetRTCGlobalData() throw();
static void  _RTC_NotifyOfGlobChange() throw();
static void  SetErrors() throw();
static void  InitMemoryTracking(bool advmem) throw();
static void  InitGlobals() throw();
static void  GetGlobals() throw();
static void  SetSMName(char which);
#endif

#if 0
void DBGdumpbin(void *addr, char *buf)
{
    unsigned int x = (unsigned int)addr;
    for (int i = 0; i < 8; i++) 
    {
        buf[7-i] = x & 15;
        if (buf[7-i] < 10)
            buf[7-i] += '0';
        else
            buf[7-i] += 'a' - 10;
        x = x >> 4;
    }
}
#endif


// This initializes the basics of the RTC subsystem
void  __cdecl 
_RTC_InitBase(void)
{
    static bool init = false;
    if (init)
        return;
    init = true;
    _RTC_SetErrorFunc(_CRT_RTC_INIT(0, 0, 0, _RTC_CURRENT_VERSION, 0));
}

void  __cdecl
_RTC_Shutdown(void)
{
    _CRT_RTC_INIT(0, 0, 0, _RTC_CURRENT_VERSION, 1);
}

#ifdef _RTC_ADVMEM
// This initializes the shadow memory subsystem
void  __cdecl
_RTC_InitAdvMem(void)
{
    ACQUIRE(INIT_MUTEX);
    if (_RTC_shadowmemory)
    {
        _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 0));
        return;
    }
    
    ACQUIRE(WORK_MUTEX);

    GetGlobals();
   
    InitGlobals();

    if (_RTC_shadowmemory) 
    {
        _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 0));
        return;
    }

    _RTC_shadowmemory = true;

    if (!_RTC_shadow)
        _RTC_MS_Init();

    InitMemoryTracking(true);

    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
        _RTC_NotifyOthersOfChange((void*)mbi.AllocationBase);

    RELEASE(WORK_MUTEX);
    RELEASE(INIT_MUTEX);
}
#endif
#ifdef _RTC_ADVMEM

// Remove this image from the list of running images...
void  __cdecl
_RTC_Shutdown(void)
{
    static bool run = false;
    MEMORY_BASIC_INFORMATION mbi, img_mbi;
    _RTC_Funcs *curfunc, *prev;
    
    if (!_RTC_globptr || run)
        return;
    run = true;    
    __try 
    {
        if (_RTC_Lock(INIT_MUTEX)) { __try
        {
            if (_RTC_Lock(WORK_MUTEX)) { __try
            {
                _CRT_RTC_INIT(init_mutex, funcs, FUNCCOUNT, _RTC_CURRENT_VERSION, 1);

                curfunc = _RTC_globptr->callbacks;
                prev = 0;

                VirtualQuery(&this_image, &img_mbi, sizeof(img_mbi));

                while (curfunc) 
                {
                    VirtualQuery(curfunc, &mbi, sizeof(mbi));
                    if (mbi.BaseAddress == img_mbi.BaseAddress)
                    {
                        if (prev)
                            prev->next = curfunc->next;
                        else
                            _RTC_globptr->callbacks = curfunc->next;
                    } else if (mbi.State != MEM_COMMIT)
                    {
                        if (prev)
                            prev->next = 0;
                        else
                            _RTC_globptr->callbacks = 0;
                        OutputDebugString("RTC Shutdown problem detected...");
                        break;
                    } else
                        prev = curfunc;
                    curfunc = curfunc->next;
                }
            } __finally { _RTC_Unlock(WORK_MUTEX); } }
        } __finally { _RTC_Unlock(INIT_MUTEX); } }
    } __finally
    {
        CloseHandle(init_mutex);
        CloseHandle(work_mutex);
        if (_RTC_globptr)
            UnmapViewOfFile(_RTC_globptr);
        CloseHandle(sharedmem);
        init_mutex = work_mutex = sharedmem = INVALID_HANDLE_VALUE;
    }
}

static void  
GetGlobals() throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

    // Setup the error types for this instance
    for (int i = 0; i < _RTC_ILLEGAL; i++)
        _RTC_ErrorLevels[i] = 1;

    if (!_RTC_globptr)
        _RTC_globptr = GetRTCGlobalData();
    
    if(_RTC_globptr)
        _RTC_NotifyOfGlobChange();
}


static void  
InitGlobals() throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

#ifdef _RTC_ADVMEM
    if (!_RTC_heap2)
    {
        _RTC_heap2 = new _RTC_SimpleHeap(8);
        _RTC_heap4 = new _RTC_SimpleHeap(16);
        _RTC_heap8 = new _RTC_SimpleHeap(32);
    }
#endif

    // Add this module to the list of callbacks

    MEMORY_BASIC_INFORMATION mbi;
    if (_RTC_globptr && VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
    {
        this_image.err = 0;
        this_image.next = _RTC_globptr->callbacks;
        this_image.notify = &_RTC_NotifyOfGlobChange;
        this_image.allocationBase = mbi.AllocationBase;
#ifdef _RTC_ADVMEM
        this_image.shadowoff = 0;
#endif
        _RTC_globptr->callbacks = &this_image;
    }
}

static void  
InitMemoryTracking(bool advmem) throw()
{
    static bool init = false;
    if (init)
        return;
    init = true;

    // Build the memory block hash table
    void *hbmem = VirtualAlloc(0, 65521 * sizeof(_RTC_HeapBlock*), 
                               MEM_RESERVE | MEM_COMMIT, 
                               PAGE_READWRITE);

    _RTC_heapblocks = new HashTable<_RTC_HeapBlock>(65521, hbmem);

    _RTC_MSAllocShadow((memptr)hbmem, 65521 * sizeof(_RTC_HeapBlock*), IDX_STATE_ILLEGAL);
    
    _RTC_memhier = new _RTC_Container(0);

    _RTC_MSAllocateGlobals();

    _RTC_SetErrorFunc(_CRT_RTC_INIT(init_mutex, funcs, 2 + (advmem ? 2 : 0), _RTC_CURRENT_VERSION, 0));
}
#endif

// This is code to post process wide values...
#ifdef _RTC_ADVMEM

static void  
SetSMName(char which)
{
    name[0] = which;

    if (name[1] != '-')
        return;

    DWORD pid = GetCurrentProcessId();
    char *num = &(name[1]);
    for (int i = 0; i < 8; i++) 
    {
        *num = (char)('A' + (pid & 0xF));
        num++;
        pid >>= 4;
    }
}

bool
_RTC_Lock(int work) // currently work = 1, init = 0
{
    HANDLE mutex = (work == WORK_MUTEX) ? work_mutex : init_mutex;
    char chr = (work == WORK_MUTEX) ? 'W' : 'I';
    if (mutex == INVALID_HANDLE_VALUE)
    {
        SetSMName(chr);
        mutex = CreateMutex(NULL, FALSE, name);
        if (mutex == INVALID_HANDLE_VALUE)
            return false;
    }
    WaitForSingleObject(mutex, INFINITE);
    return true;
}

void  
_RTC_Unlock(int work)
{
    ReleaseMutex((work == WORK_MUTEX) ? work_mutex : init_mutex);
}

static _RTC_globals*  
GetRTCGlobalData() throw()
{
    // Try to open the memory mapped file
    // If it's not created, create it & init it to zeroes

    SetSMName('F');

    sharedmem = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                                  0, _RTC_GLOBALS_SIZE, name);

    if (!sharedmem)
        return 0;
    
    DWORD lastErr = GetLastError();
    _RTC_globals* data = (_RTC_globals *)MapViewOfFile(sharedmem, 
                                                     FILE_MAP_ALL_ACCESS, 
                                                     0, 0, 0);

    if (!data)
        return 0;

    if (lastErr != ERROR_ALREADY_EXISTS)
    {
        memset(data, 0, sizeof(_RTC_globals));
    }

    return data;
}

// This function should be called when data in the global pointer has changed
// This stuff is highly version sensitive!  Be careful!
static void  
_RTC_NotifyOfGlobChange() throw()
{
    _RTC_memlock = _RTC_globptr->memlock;
#ifdef _RTC_ADVMEM
    _RTC_heap2 = _RTC_globptr->heap2;
    _RTC_heap4 = _RTC_globptr->heap4;
    _RTC_heap8 = _RTC_globptr->heap8;
    _RTC_shadow = _RTC_globptr->shadow;
    _RTC_pageidx = _RTC_globptr->pageidx;
    _RTC_pi_array = _RTC_globptr->pi_array;
    _RTC_memhier = _RTC_globptr->memhier;
    _RTC_heapblocks = _RTC_globptr->heapblocks;
    _RTC_shadowmemory = _RTC_globptr->shadowmemory;
#endif
}

// This function should be called when local data has changed 
// and needs copied to global data
// This stuff is highly version sensitive!  Be careful!
void  
_RTC_NotifyOthersOfChange(void *addr)
{
    _RTC_globptr->memlock = _RTC_memlock;
#ifdef _RTC_ADVMEM
    _RTC_globptr->heap2 = _RTC_heap2;
    _RTC_globptr->heap4 = _RTC_heap4;
    _RTC_globptr->heap8 = _RTC_heap8;
    _RTC_globptr->shadow = _RTC_shadow;
    _RTC_globptr->heapblocks = _RTC_heapblocks;
    _RTC_globptr->memhier = _RTC_memhier;
    _RTC_globptr->pageidx = _RTC_pageidx;
    _RTC_globptr->pi_array = _RTC_pi_array;
    _RTC_globptr->shadowmemory = _RTC_shadowmemory;
#endif
    
    for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
        if (f->allocationBase != addr)
            f->notify();
}

void  __cdecl
_RTC_SetOutOfMemFunc(int (*func)(void))
{
    if (!_RTC_Lock())
        return;
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
    {
        for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
        {
            if (f->allocationBase == mbi.AllocationBase)
            {
                f->shadowoff = func;
                _RTC_Unlock();
                return;
            }
        }
    }
    _RTC_Unlock();
}
#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\shadow.cpp ===
/***
*shadow.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       08-13-98  KBF   Changed address cache to be 'invalid' address cache
*       08-13-98  KBF   Turned on optimization, modified address calc functions
*       10-13-98  KBF   Added Shadow-Death notification capabilities
*       11-03-98  KBF   added pragma intrinsic to eliminate CRT code dependence
*       11-03-98  KBF   Also fixed bug with allocating blocks of 4K multiples
*       12-01-98  KBF   Fixed a bug in RTC_MSFreeShadow - MC 11029
*       12-02-98  KBF   Fixed _RTC_MSR0AssignPtr
*       12-03-98  KBF   Added CheckMem_API and APISet functions
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-14-99  KBF   Requires _RTC_ADVMEM (it's been cut for 7.0)
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

#ifdef _RTC_ADVMEM

static const unsigned MEM_SIZE = 0x40000000;
// This tag is valid?
#define MEM_ISVALID(tag) (tag)
// Both tags in this short are valid
#define MEM_SHORTVALID(tag) (((tag) & 0xFF) && ((tag) & 0xFF00))
// All 4 tags in this int are valid
#define MEM_INTVALID(tag) (((tag) & 0xFF) && ((tag) & 0xFF00) && ((tag) & 0xFF0000) && ((tag) & 0xFF000000))
// Given an address, get a shadow memory index
#define MEM_FIXADDR(addr) ((addr) & (MEM_SIZE - 1))
// An int's worth of unused values
static const unsigned int MEM_EMPTYINT = 0;
// An unused value
static const shadowtag MEM_EMPTY = 0;
// An untracked value
static const shadowtag MEM_UNKNOWN = 0xFF;
static const unsigned int MEM_UNKNOWNINT = 0xFFFFFFFF;

#define MEM_NEXT_ID(a) ((shadowtag)((a) % 253 + 1))

static const unsigned int PAGE_SIZE = 4096;

/* Page Index Macros */
static const unsigned int PAGES_PER_ELEM = 1;
static const unsigned int MEM_PER_IDX = PAGE_SIZE; // 4K
static const unsigned int IDX_SIZE = ((MEM_SIZE / MEM_PER_IDX) * sizeof(index_elem)) / PAGES_PER_ELEM;
static const unsigned int IDX_STATE_TRACKED        = 0x2; // bitmask

#define SET_IDX_STATE(idx, st) (_RTC_pageidx[idx]=st)
#define GET_IDX_STATE(idx) (_RTC_pageidx[idx])

// Get the index number for a given address
#define IDX_NUM(addr) (MEM_FIXADDR(addr) / MEM_PER_IDX)

// Index align this address
#define IDX_ALIGN(addr) ((addr) & ~(MEM_PER_IDX - 1))

#ifdef _RTC_DEBUG
// Debugging helper functions
#define show(a, b) unsigned b(unsigned c) { return a(c); }
show(GET_IDX_STATE, get_idx_state)
show(IDX_NUM, idx_num)
show(IDX_ALIGN, idx_align)
#undef show
#endif

// This is the pseudo-address used for REG0 in the cache
#define REG0 ((memref)1)

static shadowtag blockID = 0;

static void KillShadow();

#ifdef __MSVC_RUNTIME_CHECKS
#error Hey dufus, don't compile this file with runtime checks turned on
#endif

#pragma intrinsic(memset)

struct cacheLine
{
    memref pointer;
    memptr value;
    memptr base;
    void *assignment;
};

// Actual Cache Size is 2^CacheSize
// Cache is 8x3 - 24 elements total
#define CACHESIZE     3
#define CACHELINESIZE 3

static cacheLine cache[1<<CACHESIZE][CACHELINESIZE];
static long readlocks[1<<CACHESIZE];
static long writelocks[1<<CACHESIZE];
static long cachePos[1<<CACHESIZE];

#define READ_LOCK(line) \
{\
    while(InterlockedIncrement(&readlocks[line]) <= 0)\
    {\
        InterlockedDecrement(&readlocks[line]);\
        Sleep(0);\
    }\
}
#define READ_UNLOCK(line) InterlockedDecrement(&readlocks[line])

static void WRITE_LOCK(int line) 
{
    while (InterlockedExchange(&writelocks[line], 1))
        Sleep(0);
    long users = InterlockedExchange(&readlocks[line], -2000);
    while (readlocks[line] != -2000-users)
        Sleep(0);
}

#define WRITE_UNLOCK(line) {readlocks[line] = 0; writelocks[line] = 0;}

#define CacheHash(value) (((1 << CACHESIZE) - 1) & (value >> 3))

static void
ClearCacheRange(memptr lo, memptr hi)
{
    // Remove all pointers stored between lo and hi
    // We don't need to use locks, because this stuff is only
    // used for the stack, and if you're running on the same stack
    // you're in serious trouble...
    unsigned size = hi - lo;
    for (int i = 0; i < (1 << CACHESIZE); i++)
    {
        for (int j = 0; j < CACHELINESIZE; j++)
        {
            if (cache[i][j].pointer && 
                (unsigned)cache[i][j].pointer - (unsigned)lo < size)
                cache[i][j].pointer = 0;
        }
    }
}

static void
AddCacheLine(void *retaddr, memref ptr, memptr base, memptr value)
{
    if (!value)
        return;
    
    int loc = CacheHash((int)ptr);

    WRITE_LOCK(loc);
    int prefpos = 0;
    
    for (int i = 0; i < CACHELINESIZE; i++)
    {
        if (cache[loc][i].pointer == ptr)
        {
            prefpos = i+1;
            break;
        } else if (!prefpos && !cache[loc][i].pointer)
            prefpos = i+1;
    }

    if (!prefpos)
        prefpos = cachePos[loc];
    else
        prefpos--;
    
    cache[loc][prefpos].pointer = ptr;
    cache[loc][prefpos].value = value;
    cache[loc][prefpos].base = base;
    cache[loc][prefpos].assignment = retaddr;
    
    if (++prefpos == CACHELINESIZE)
        cachePos[loc] = 0;
    else
        cachePos[loc] = prefpos;
    
    WRITE_UNLOCK(loc);
}

static void
ClearCacheLine(memref ptr)
{
    int loc = CacheHash((int)ptr);

    READ_LOCK(loc);
    for (int i = 0; i < CACHELINESIZE; i++)
    {
        if (cache[loc][i].pointer == ptr)
        {
            READ_UNLOCK(loc);
            WRITE_LOCK(loc);
            cache[loc][i].pointer = 0;
            cachePos[loc] = i;
            WRITE_UNLOCK(loc);
            return;
        }
    }
    READ_UNLOCK(loc);
}

#define GetCacheLine(ptr, dst) {\
    int loc = CacheHash((int)ptr);\
    dst.pointer = 0;\
    READ_LOCK(loc);\
    for (int i = 0; i < CACHELINESIZE; i++)\
    {\
        if (cache[loc][i].pointer == ptr)\
        {\
            dst = cache[loc][i];\
            break;\
        }\
    }\
    READ_UNLOCK(loc);\
}

static void
ClearCache()
{
    for (int loc = 0; loc < 1 << CACHESIZE; loc++)
    {
        for (int i = 0; i < CACHELINESIZE; i++)
            cache[loc][i].pointer = 0;
        readlocks[loc] = writelocks[loc] = 0;
        cachePos[loc] = 0;
    }
}


// This is called before every function to allocate 
// locals in the shadow memory
void __fastcall
_RTC_MSAllocateFrame(memptr frame, _RTC_framedesc *v)
{
    if (!_RTC_shadow)
        return;

    int i;
    int memsize = -v->variables[v->varCount-1].addr + sizeof(int);

    // Next, commit all required pages, initializing all unallocated portions 
    // of newly committed memory to the proper state
    _RTC_MSCommitRange(frame - memsize, memsize, IDX_STATE_PARTIALLY_KNOWN);
    if (!_RTC_shadow)
        return;

    // Now step thru each variable, and allocate it within the shadow memory
    // While allocating, mark the buffer sections as invalid
    for (i = 0; i < v->varCount; i++)
    {
        *(unsigned*)(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr - sizeof(int))]) = MEM_EMPTYINT;
        *(unsigned*)(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr + v->variables[i].size)]) = MEM_EMPTYINT;
        blockID = MEM_NEXT_ID(blockID);
        memset(&_RTC_shadow[MEM_FIXADDR(frame + v->variables[i].addr)], blockID, v->variables[i].size);
    }
}

// Free the stack frame from shadow memory
void __fastcall
_RTC_MSFreeFrame(memptr frame, _RTC_framedesc *v)
{
    // I'm not bothering to attempt to free any shadow memory pages
    // This might cause problems for certain really poorly written programs...
    if (_RTC_shadow)
    {
        int size = (sizeof(int) + sizeof(int) - 1 - v->variables[v->varCount - 1].addr);
        memset(&_RTC_shadow[MEM_FIXADDR(frame-size)], MEM_UNKNOWN, size);

        // Temporary hack until we handle parameters
        ClearCacheRange(frame - size, frame);
    }
    // Cheap Bounds Check, to be sure that no external functions trash the stack
    _RTC_CheckStackVars((void*)frame, v);
}


// The list of global variable descriptors is constructed by dummy
// start and end descriptor here, in sections .rtc$MEA and .rtc$MEZ.
// The compiler emits .rtc$MEB entries for each global, under -RTCm.
// The linker sorts these together into the .rtc section. Note that the
// linker, under /DEBUG, inserts zero padding into the section for
// incremental compilation. We force the alignment of these descriptors,
// and thus the sections, to be the size of the structure, so no odd padding
// is inserted.
//
// The following is how the code *should* look:
//
// __declspec(align(8)) struct global_descriptor {
//     memptr addr;
//     unsigned size;
// };
// 
// #pragma section(".rtc$MEA", read)
// #pragma section(".rtc$MEZ", read)
// 
// __declspec(allocate(".rtc$MEA")) global_descriptor glob_desc_start = {0};
// __declspec(allocate(".rtc$MEZ")) global_descriptor glob_desc_end = {0};
//
// However, __declspec(align()), #pragma section, and __declspec(allocate())
// are all VC 6.1 features. It is a CRT requirement to compile the 6.1 CRT
// using only 6.0 language features (because NT 5 only uses the 6.0 compiler,
// I think). So here's how we do it:

struct global_descriptor
{
    union {
        double ___unused; // only here to force 8-byte alignment
        struct {
            memptr addr;
            unsigned size;
        };
    };
};

#pragma const_seg(".rtc$MEA")
const global_descriptor glob_desc_start = {0};
#pragma const_seg(".rtc$MEZ")
const global_descriptor glob_desc_end = {0};
#pragma const_seg()

// We must start our loop at &glob_desc_start, not &glob_desc_start + 1,
// because the pre-VC 6.1 compiler (specifically, the global optimizer)
// treats &glob_desc_start + 1 as distinct (unaliased) from &glob_desc_end,
// in the loop below. Thus, it gets rid of the loop test at the loop top.
// This is a problem for cases where there are no globals. This is done
// because it is expected that the 6.1 CRT will be compiled by pre-6.1
// compilers.

// Allocate the list of globals in shadow memory
void __cdecl
_RTC_MSAllocateGlobals(void)
{
    if (!_RTC_shadow)
        return;

    // Just step thru every item, and call _RTC_MSAllocShadow
    const global_descriptor *glob = &glob_desc_start;
    for (; glob != &glob_desc_end; glob++)
        _RTC_MSAllocShadow(glob->addr, glob->size, IDX_STATE_PARTIALLY_KNOWN);
}


// This should initialize the shadow memory as appropriate,
// committing all necessary pages
// partial implies that the page is only partially known
// so we need to be sure that all unallocated values on the
// page are set as a single valid block
short
_RTC_MSAllocShadow(memptr real_addr, unsigned real_size, unsigned state)
{
    // Ignore bogus zero address or size, possibly from globals linker padding
    if (!_RTC_shadow || !real_addr || !real_size)
        return 0;

    // Now allocate the shadow memory, if necessary
    if (state & IDX_STATE_TRACKED)
    {
        // Commit the shadow memory, 
        // marking newly committed, but unallocated memory as appropriate
        _RTC_MSCommitRange(real_addr, real_size, state);
        if (!_RTC_shadow)
            return blockID;

        // Now initialize the shadow memory
        blockID = MEM_NEXT_ID(blockID);

        memset(&_RTC_shadow[MEM_FIXADDR(real_addr)], blockID, real_size);
    } else if (state == IDX_STATE_ILLEGAL)
    {
        // Initialize the page index stuff to the correct state
        // ASSERT(state == IDX_STATE_ILLEGAL)

        unsigned idx_start = IDX_NUM(real_addr);
        unsigned idx_end = IDX_NUM(real_addr + real_size - 1);

        for (unsigned i = idx_start; i <= idx_end; i++)
            SET_IDX_STATE(i, state);
    }

    return blockID;
}

// This sets the value of the shadow memory to be the value passed in
void 
_RTC_MSRestoreShadow(memptr addr, unsigned size, short id)
{
    if (!_RTC_shadow)
        return;
    memset(&_RTC_shadow[MEM_FIXADDR(addr)], id, size);
}

// This assigns a new blockID to the shadow memory
// It will NOT be equal to the id passed in
short
_RTC_MSRenumberShadow(memptr addr, unsigned size, short notID)
{
    if (!_RTC_shadow)
        return 0;

    blockID = MEM_NEXT_ID(blockID);
    
    if (blockID == notID)
        blockID = MEM_NEXT_ID(blockID);
    
    memset(&_RTC_shadow[MEM_FIXADDR(addr)], blockID, size);
    return blockID;
}
    

// This should de-initialize shadow memory
// and decommit any unneeded pages
void _RTC_MSFreeShadow(memptr addr, unsigned size)
{
    if (!_RTC_shadow)
        return;

    // Low & Hi are the bounds of the freed memory region
    memptr low = MEM_FIXADDR(addr);
    memptr hi  = (low + size) & ~(sizeof(unsigned)-1);

    // start and end are the page-aligned bounds;
    memptr start = IDX_ALIGN(low);
    memptr end = IDX_ALIGN(low + size + MEM_PER_IDX - 1);

    memptr tmp;

    int used;

    // First, clear the shadow memory that contained this stuff
    memset(&_RTC_shadow[low], 
           (GET_IDX_STATE(IDX_NUM(low)) == IDX_STATE_PARTIALLY_KNOWN) 
            ? MEM_UNKNOWN 
            : MEM_EMPTY, 
           size);

    // Now go thru and release the pages that have
    // been completely eliminated from use
    for (tmp = start, used = 0; !used && tmp < low; tmp += sizeof(unsigned))
    {
        unsigned val = *(unsigned *)&_RTC_shadow[tmp];
        used = val != MEM_EMPTYINT && val != MEM_UNKNOWNINT;
    }

    if (used)
        start += MEM_PER_IDX;

    for (tmp = hi, used = 0; !used && tmp < end; tmp += sizeof(unsigned))
    {
        unsigned val = *(unsigned *)&_RTC_shadow[tmp];
        used = val != MEM_EMPTYINT && val != MEM_UNKNOWNINT;
    }

    if (used)
        end -= MEM_PER_IDX;

    if (start < end)
        // Free the page in memory
        _RTC_MSDecommitRange(start, end-start);

}

void _RTC_MSCommitRange(memptr addr, unsigned size, unsigned state)
{
    // Commit the page range
    if (!VirtualAlloc(&_RTC_shadow[MEM_FIXADDR(addr)], size, MEM_COMMIT, PAGE_READWRITE))
        KillShadow();
    else {
        // Now mark the range as committed in the page tables
        size += (addr - IDX_ALIGN(addr));
        int val = (state == IDX_STATE_PARTIALLY_KNOWN) ? MEM_UNKNOWNINT : MEM_EMPTYINT;
        while (size && !(size & 0x80000000)) 
        {
            // If this is a newly committed page, initialize it to the proper value
            if (GET_IDX_STATE(IDX_NUM(addr)) != state)
            {
                SET_IDX_STATE(IDX_NUM(addr), state);
                int *pg = (int*)&_RTC_shadow[MEM_FIXADDR(IDX_ALIGN(addr))];
                for (int i = 0; i < MEM_PER_IDX / sizeof(int); i++)
                    pg[i] = val;
            }
            addr += MEM_PER_IDX;
            size -= MEM_PER_IDX;
        }
    }
}

void _RTC_MSDecommitRange(memptr addr, unsigned size)
{
    // Decommit the page range
    VirtualFree(&_RTC_shadow[MEM_FIXADDR(addr)], size, MEM_DECOMMIT);

    // Now mark the range as decommited in the page tables
    size += (addr - IDX_ALIGN(addr));
    while (size && !(size & 0x80000000))
    {
        SET_IDX_STATE(IDX_NUM(addr), IDX_STATE_UNKNOWN);
        addr += MEM_PER_IDX;
        size -= MEM_PER_IDX;
    }
}

static shadowtag
GetAddrTag(memptr addr)
{
    shadowtag *loc = &_RTC_shadow[MEM_FIXADDR(addr)];
    if ((memptr)loc == addr)
        return MEM_EMPTY;
    
    if (addr & 0x80000000) 
        return MEM_UNKNOWN;
    switch (GET_IDX_STATE(IDX_NUM(addr)))
    {
    case IDX_STATE_UNKNOWN:
        return MEM_UNKNOWN;
    case IDX_STATE_ILLEGAL:
        return MEM_EMPTY;
    case IDX_STATE_PARTIALLY_KNOWN:
    case IDX_STATE_FULLY_KNOWN:
        return *loc;
    default:
        __assume(0);
    }
}

static void 
MemCheckAdd(void *retaddr, memptr base, int offset, unsigned size)
{
    // If base isn't really the base, don't assume offset is, 
    // just be sure the memory is valid
    shadowtag baseTag;
    if (base < offset) 
        baseTag = GetAddrTag(base + offset);
    else
        baseTag = GetAddrTag(base);
    
    // Step thru ever byte of the memory and verify that they're all the same
    for (unsigned i = 0; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(base + offset + i);
        if (newTag != baseTag || newTag == MEM_EMPTY)
        {
            _RTC_Failure(retaddr, (newTag == MEM_EMPTY) 
                                  ? _RTC_INVALID_MEM 
                                  : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}


static void 
PtrMemCheckAdd(void *retaddr, memref base, int offset, unsigned size)
{
    if (*base < offset)
    {
        // if *base isn't really the base, just do a MemCheckAdd
        MemCheckAdd(retaddr, *base, offset, size);
        return;
    }
    
    shadowtag baseTag;
    cacheLine cl;
    GetCacheLine(base, cl);

    if (cl.pointer && cl.value == *base)
    {
        baseTag = GetAddrTag(cl.base);
    } else
        baseTag = GetAddrTag(*base);

    for (unsigned i = 0; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(*base + offset + i);
        if (newTag != baseTag || newTag == MEM_EMPTY)
        {
            if (cl.pointer && cl.value == *base && cl.base)
                _RTC_MemFailure(retaddr, 
                                (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK,
                                cl.assignment);
            else
                _RTC_Failure(retaddr, 
                             (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}

static void 
PtrMemCheck(void *retaddr, memref base, unsigned size)
{
    shadowtag baseTag = GetAddrTag(*base);
    cacheLine cl;
    GetCacheLine(base, cl);
    if (cl.pointer && cl.value == *base)
        _RTC_MemFailure(retaddr, 
                        (baseTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK,
                        cl.assignment);
    
    else for (unsigned i = 1; i < size; i++)
    {
        shadowtag newTag = GetAddrTag(*base + i);
        if (newTag != baseTag)
        {
            _RTC_Failure(retaddr, (newTag == MEM_EMPTY) ? _RTC_INVALID_MEM : _RTC_DIFF_MEM_BLOCK);
            return;
        }
    }
}

memptr __fastcall 
_RTC_MSPtrPushAdd(memref dstoffset, memref base, int offset)
{
    if (_RTC_shadow)
    {
        memptr src = *base;
        memref dst = dstoffset - 4;

        shadowtag dstTag = GetAddrTag(src + offset);
        shadowtag srcTag = GetAddrTag(src);

        cacheLine cl;
        GetCacheLine(base, cl);
        memptr origBase = src;
    
        if (cl.pointer)
        {
            if (cl.value == src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(base);
        }
        
        if (srcTag != MEM_EMPTY)
        {
            if (dstTag != srcTag)
                AddCacheLine(_ReturnAddress(), dst, origBase, src + offset);
            else
                ClearCacheLine(dst);
        }
    }
    return *base + offset;
}

void __fastcall 
_RTC_MSPtrAssignAdd(memref dst, memref base, int offset)
{
    memptr src = *base;
    *dst = src + offset;
    if (!_RTC_shadow)
        return;

    // First, verify that the address is not in shadow memory
    shadowtag dstTag = GetAddrTag(*dst);
    shadowtag srcTag = GetAddrTag(src);

    cacheLine cl;
    GetCacheLine(base, cl);
    memptr origBase = src;
    
    if (cl.pointer)
    {
        if (cl.value == src)
        {
            srcTag = GetAddrTag(cl.base);
            origBase = cl.base;
        } else
            ClearCacheLine(base);
    }
        
    if (srcTag == MEM_EMPTY)
        return;

    if (dstTag != srcTag)
        AddCacheLine(_ReturnAddress(), dst, origBase, *dst);
    else
        ClearCacheLine(dst);
}

memptr __fastcall 
_RTC_MSPtrAssignR0(memref src)
{
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(src, cl);
        if (cl.pointer)
        {
            if (cl.value == *src)
                AddCacheLine(_ReturnAddress(), REG0, cl.base, *src);
            else
                ClearCacheLine(src);
        }
    }
    return *src;
}

memptr __fastcall 
_RTC_MSPtrAssignR0Add(memref src, int offset)
{
    memptr dst = *src + offset;
    if (_RTC_shadow)
    {
        // First, verify that the address is tolerable 
        shadowtag dstTag = GetAddrTag(dst);
        shadowtag srcTag = GetAddrTag(*src);

        cacheLine cl;
        GetCacheLine(src, cl);
        memptr origBase = *src;

        if (cl.pointer)
        {
            if (cl.value == *src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(src);
        }
        
        if (srcTag != MEM_EMPTY)
        {
            if (dstTag != srcTag)
                AddCacheLine(_ReturnAddress(), REG0, origBase, dst);
            else
                ClearCacheLine(REG0);
        }
    }
    return *src + offset;
}

void __fastcall 
_RTC_MSR0AssignPtr(memref dst, memptr src)
{
    *dst = src;
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(REG0, cl);
        if (cl.pointer)
        {
            if (cl.value == src)
                AddCacheLine(_ReturnAddress(), dst, cl.base, src);
            else
                ClearCacheLine(REG0);
        }
    }
}

void __fastcall 
_RTC_MSR0AssignPtrAdd(memref dst, memptr src, int offset)
{
    *dst = src + offset;
    if (_RTC_shadow)
    {
        shadowtag dstTag = GetAddrTag(*dst);
        shadowtag srcTag = GetAddrTag(src);

        cacheLine cl;
        GetCacheLine(REG0, cl);
        memptr origBase = src;

        if (cl.pointer)
        {
            if (cl.value == src)
            {
                srcTag = GetAddrTag(cl.base);
                origBase = cl.base;
            } else
                ClearCacheLine(REG0);
        }
        
        if (srcTag == MEM_EMPTY)
            return;
        
        if (dstTag != srcTag)
            AddCacheLine(_ReturnAddress(), dst, origBase, *dst);
        else
            ClearCacheLine(dst);
    }
}
    
memptr __fastcall 
_RTC_MSAddrPushAdd(memref dstoffset, memptr base, int offset)
{
    if (_RTC_shadow)
    {
        memref dst = dstoffset - 4;
        // First, verify that the address is not in shadow memory
        shadowtag dstTag = GetAddrTag(base + offset);
        shadowtag srcTag = GetAddrTag(base);

        if (dstTag == MEM_UNKNOWN && 
            (srcTag == MEM_EMPTY || srcTag == MEM_UNKNOWN))
            ClearCacheLine(dst);

        else if (dstTag == MEM_EMPTY ||
                (dstTag == MEM_UNKNOWN && srcTag != MEM_UNKNOWN) ||
                (srcTag == MEM_UNKNOWN && dstTag != MEM_UNKNOWN))
            AddCacheLine(_ReturnAddress(), dst, base, base + offset);
    
        else if (srcTag != MEM_EMPTY)
        {
            if (srcTag != dstTag)
                AddCacheLine(_ReturnAddress(), dst, base, base + offset);
        
            else
                ClearCacheLine(dst);
        }
    }
    return base + offset;
}

void __fastcall 
_RTC_MSAddrAssignAdd(memref dst, memptr base, int offset)
{
    *dst = base + offset;
    if (!_RTC_shadow)
        return;

    // First, verify that the address is not in shadow memory
    shadowtag dstTag = GetAddrTag(*dst);
    shadowtag srcTag = GetAddrTag(base);

    if (dstTag == MEM_UNKNOWN && 
        (srcTag == MEM_EMPTY || srcTag == MEM_UNKNOWN))
        ClearCacheLine(dst);

    else if (dstTag == MEM_EMPTY ||
            (dstTag == MEM_UNKNOWN && srcTag != MEM_UNKNOWN) ||
            (srcTag == MEM_UNKNOWN && dstTag != MEM_UNKNOWN))
        AddCacheLine(_ReturnAddress(), dst, base, *dst);
    
    else if (srcTag == MEM_EMPTY)
        return;

    else if (srcTag != dstTag)
        AddCacheLine(_ReturnAddress(), dst, base, *dst);

    else
        ClearCacheLine(dst);
}

void __fastcall 
_RTC_MSPtrAssign(memref dst, memref src)
{
    *dst = *src;
    if (!_RTC_shadow)
        return;
    cacheLine cl;
    GetCacheLine(src, cl);
    if (cl.pointer)
    {
        if (cl.value == *src)
            AddCacheLine(_ReturnAddress(), dst, cl.base, *src);
        else
            ClearCacheLine(src);
    }
}

memptr __fastcall 
_RTC_MSPtrPush(memref dstoffset, memref src)
{
    if (_RTC_shadow)
    {
        cacheLine cl;
        GetCacheLine(src, cl);
        if (cl.pointer)
        {
            if (cl.value == *src)
                AddCacheLine(_ReturnAddress(), dstoffset - 4, cl.base, *src);
            else
                ClearCacheLine(src);
        }
    }
    return *src;
}

memval1 __fastcall 
_RTC_MSPtrMemReadAdd1(memref base, int offset)
{
    memval1 res;
    __try
    {
        res = *(memval1*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSPtrMemReadAdd2(memref base, int offset)
{
    memval2 res;
    __try
    {
        res = *(memval2*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSPtrMemReadAdd4(memref base, int offset)
{
    memval4 res;
    __try
    {
        res = *(memval4*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSPtrMemReadAdd8(memref base, int offset)
{
    memval8 res;
    __try
    {
        res = *(memval8*)(*base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 8);
    return res;
}

memval1 __fastcall 
_RTC_MSMemReadAdd1(memptr base, int offset)
{
    memval1 res;
    __try
    {
        res = *(memval1*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSMemReadAdd2(memptr base, int offset)
{
    memval2 res;
    __try
    {
        res = *(memval2*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSMemReadAdd4(memptr base, int offset)
{
    memval4 res;
    __try
    {
        res = *(memval4*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSMemReadAdd8(memptr base, int offset)
{
    memval8 res;
    __try
    {
        res = *(memval8*)(base + offset);
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 8);
    return res;
}

memval1 __fastcall 
_RTC_MSPtrMemRead1(memref base)
{
    memval1 res;
    __try
    {
        res = *(memval1*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 1);
    return res;
}

memval2 __fastcall 
_RTC_MSPtrMemRead2(memref base)
{
    memval2 res;
    __try
    {
        res = *(memval2*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 2);
    return res;
}

memval4 __fastcall 
_RTC_MSPtrMemRead4(memref base)
{
    memval4 res;
    __try
    {
        res = *(memval4*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 4);
    return res;
}

memval8 __fastcall 
_RTC_MSPtrMemRead8(memref base)
{
    memval8 res;
    __try
    {
        res = *(memval8*)*base;
    }
    __except(1)
    {
        _RTC_Failure(_ReturnAddress(), _RTC_INVALID_MEM);
    }
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 8);
    return res;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd1(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 1);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd2(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 2);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd4(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 4);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAdd8(memref base, int offset)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, 8);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSPtrMemCheckAddN(memref base, int offset, unsigned size)
{
    if (_RTC_shadow)
        PtrMemCheckAdd(_ReturnAddress(), base, offset, size);
    return *base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd1(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 1);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd2(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 2);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd4(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 4);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAdd8(memptr base, int offset)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, 8);
    return base + offset;
}

memptr  __fastcall 
_RTC_MSMemCheckAddN(memptr base, int offset, unsigned size)
{
    if (_RTC_shadow)
        MemCheckAdd(_ReturnAddress(), base, offset, size);
    return base + offset;
}

memptr __fastcall
_RTC_MSPtrMemCheck1(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 1);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck2(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 2);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck4(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 4);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheck8(memref base)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, 8);
    return *base;
}

memptr __fastcall
_RTC_MSPtrMemCheckN(memref base, unsigned size)
{
    if (_RTC_shadow)
        PtrMemCheck(_ReturnAddress(), base, size);
    return *base;
}

static long enabled = 1;

void __fastcall 
_RTC_CheckMem_API(memref addr, unsigned size)
{
    if (enabled)
        _RTC_MSPtrMemCheckN(addr, size);
}

void __fastcall 
_RTC_APISet(int on_off)
{
    if (on_off)
        InterlockedIncrement(&enabled);
    else
        InterlockedDecrement(&enabled);
}

void _RTC_MS_Init()
{
    _RTC_shadow = (shadowtag *)VirtualAlloc(NULL, MEM_SIZE, MEM_RESERVE, PAGE_READWRITE);
    _RTC_pageidx = (index_elem*)VirtualAlloc(NULL, IDX_SIZE, MEM_COMMIT, PAGE_READWRITE);
    _RTC_MSAllocShadow((memptr)_RTC_pageidx, IDX_SIZE, IDX_STATE_ILLEGAL);
    ClearCache();
}


static void
KillShadow()
{
    // This is called if a call to VirtualAlloc failed - we need to turn off shadow memory
    bool didit = false;
    _RTC_Lock();

    if (_RTC_shadow) 
    {
        VirtualFree(_RTC_shadow, 0, MEM_RELEASE);
        VirtualFree(_RTC_pageidx, 0, MEM_RELEASE);
        _RTC_shadow = 0;
        _RTC_pageidx = 0;

        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery(&_RTC_SetErrorFunc, &mbi, sizeof(mbi)))
            _RTC_NotifyOthersOfChange((void*)mbi.AllocationBase);
        didit = true;
    }
    
    if (didit)
    {
        bool notify = true;
        for (_RTC_Funcs *f = _RTC_globptr->callbacks; f; f = f->next)
            if (f->shadowoff)
                notify = notify && (f->shadowoff()!=0);

        if (notify)
        {
            HINSTANCE user32 = LoadLibrary("USER32.DLL");
            if (!user32)
                return;
            typedef int (*pMsgBoxProc)(HWND,LPCTSTR,LPCTSTR,UINT);
            pMsgBoxProc pMsgBox = (pMsgBoxProc)GetProcAddress(user32, "MessageBoxA");
            if (!pMsgBox)
                return;
            pMsgBox(NULL, "The Advanced Memory Checking subsystem has run out of virtual memory,"
                          " and is now disabled. The checks will no longer occur for this process. "
                          "Try freeing up hard drive space for your swap file.",
                    "RTC Subsystem Failure",
                    MB_OK | MB_ICONWARNING | MB_DEFBUTTON1 | MB_SETFOREGROUND | MB_TOPMOST);
        }
    }
    _RTC_Unlock();
}

#endif // _RTC_ADVMEM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\userapi.cpp ===
/***
*userapi.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       07-30-98  JWM   errnum is now type _RTC_ErrorNumber throughout.
*       10-09-98  KBF   moved _RTC_IsEnabled to init.cpp (it now works for
*                       EXE/DLL combos)
*       05-11-99  KBF   Error if RTC support define not enabled
*       05-26-99  KBF   Updated for -RTCu, -RTClv cancelled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

static const char *_RTC_errlist[_RTC_ILLEGAL] =
{
    "Stack pointer corruption",
    "Cast to smaller type causing loss of data",
    "Stack memory corruption",
    "Local variable used before initialization"
#ifdef _RTC_ADVMEM
    ,
    "Accessing invalid memory",
    "Accessing memory from different heap blocks"
#endif
};

static _RTC_error_fn _RTC_ErrorReportFunc = 0;

int __cdecl 
_RTC_NumErrors(void)
{
    return _RTC_ILLEGAL;
}

const char * __cdecl 
_RTC_GetErrDesc(_RTC_ErrorNumber errnum)
{
    if (errnum < 0 || errnum >= _RTC_ILLEGAL)
        return 0;
    return _RTC_errlist[errnum];
}

int __cdecl 
_RTC_SetErrorType(_RTC_ErrorNumber errnum, int type)
{
    if (errnum >= 0 && errnum < _RTC_ILLEGAL)
    {
        int res = _RTC_ErrorLevels[errnum];
        _RTC_ErrorLevels[errnum] = type;
        return res;
    } else
        return -1;
}


_RTC_error_fn __cdecl 
_RTC_SetErrorFunc(_RTC_error_fn func)
{
    // We've got a global data structure: add this to the error func list
    _RTC_error_fn res;
    res = _RTC_ErrorReportFunc;
    _RTC_ErrorReportFunc = func;
    return res;
}

_RTC_error_fn
_RTC_GetErrorFunc(LPCVOID addr)
{
#ifdef _RTC_ADVMEM
    MEMORY_BASIC_INFORMATION mbi;

    if (!_RTC_globptr || !VirtualQuery(addr, &mbi, sizeof(mbi)))
        return _RTC_ErrorReportFunc;

    for (_RTC_Funcs *fn = _RTC_globptr->callbacks; fn; fn = fn->next)
        if (fn->allocationBase == mbi.AllocationBase)
            return fn->err;
#endif
    return _RTC_ErrorReportFunc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\stack.cpp ===
/***
*stack.cpp - RTC support
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*
*Revision History:
*       07-28-98  JWM   Module incorporated into CRTs (from KFrei)
*       05-11-99  KBF   Error if RTC support define not enabled
*
****/

#ifndef _RTC
#error  RunTime Check support not enabled!
#endif

#include "rtcpriv.h"

/* Stack Checking Calls */
void
#ifndef _M_ALPHA		// AXPMOD - No declspec(naked) for us.
__declspec(naked) 
#endif
_RTC_CheckEsp() 
{
#ifndef _M_ALPHA		// AXPMOD - Disable this until we can get the
						// assembly written for it.
    __asm 
    {
        jne esperror    ; 
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    _RTC_Failure(_ReturnAddress(), _RTC_CHKSTK);

    __asm 
    {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }
#endif
}

void __fastcall 
_RTC_CheckStackVars(void *frame, _RTC_framedesc *v)
{
    int i;
    for (i = 0; i < v->varCount; i++)
    {
        int *head = (int *)(((char *)frame) + v->variables[i].addr + v->variables[i].size);
        int *tail = (int *)(((char *)frame) + v->variables[i].addr - sizeof(int));
        
        if (*tail != 0xcccccccc || *head != 0xcccccccc) 
            _RTC_StackFailure(_ReturnAddress(), v->variables[i].name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\crt0dat.c ===
/***
*crt0dat.c - 32-bit C run-time initialization/termination routines
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the routines _cinit, exit, and _exit
*       for C run-time startup and termination.  _cinit and exit
*       are called from the _astart code in crt0.asm.
*       This module also defines several data variables used by the
*       runtime.
*
*       [NOTE: Lock segment definitions are at end of module.]
*
*Revision History:
*       06-28-89  PHG   Module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling type
*                       explicit (_CALLTYPE1 or _CALLTYPE4). Also, fixed
*                       the copyright.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       05-21-90  GJF   Added #undef _NFILE_ (temporary hack) and fixed the
*                       indents.
*       08-31-90  GJF   Removed 32 from API names.
*       09-25-90  GJF   Merged tree version with local (8-31 and 5-21 changes).
*       10-08-90  GJF   New-style function declarators.
*       10-12-90  GJF   Removed divide by 0 stuff.
*       10-18-90  GJF   Added _pipech[] array.
*       11-05-90  GJF   Added _umaskval.
*       12-04-90  GJF   Added _osfinfo[] definition for Win32 target. Note that
*                       the Win32 support is still incomplete!
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-04-90  SRW   Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*                       (_osfhnd)
*       12-28-90  SRW   Added _CRUISER_ conditional around pack pragmas
*       01-29-91  GJF   ANSI naming.
*       01-29-91  SRW   Added call to GetFileType [_WIN32_]
*       02-18-91  SRW   Removed duplicate defintion of _NFILE_ (see mtdll.h)
*       04-04-91  GJF   Added definitions for _base[version|major|minor]
*                       (_WIN32_).
*       04-08-91  GJF   Temporary hack for Win32/DOS folks - added HeapDestroy
*                       call to doexit to tear down the OS heap used by C
*                       heap.
*       04-09-91  PNT   Added _MAC_ conditional
*       04-26-91  SRW   Removed level 3 warnings
*       07-16-91  GJF   Added fp initialization test-and-call [_WIN32_].
*       07-26-91  GJF   Revised initialization and termination stuff. In
*                       particular, removed need for win32ini.c [_WIN32_].
*       08-07-91  GJF   Added init. for FORTRAN runtime, if present [_WIN32_].
*       08-21-91  GJF   Test _prmtmp against NULL, not _prmtmp().
*       08-21-91  JCR   Added _exitflag, _endstdio, _cpumode, etc.
*       09-09-91  GJF   Revised _doinitterm for C++ init. support and to make
*                       _onexit/atexit compatible with C++ needs.
*       09-16-91  GJF   Must test __onexitend before calling _doinitterm.
*       10-29-91  GJF   Force in floating point initialization for MIPS
*                       compiler [_WIN32_].
*       11-13-91  GJF   FORTRAN needs _onexit/atexit init. before call thru
*                       _pFFinit.
*       12-29-91  RID   MAC module created, based on OS2 version
*       01-10-92  GJF   Merged. Also, added _C_Termination_Done [_WIN32_].
*       02-13-92  GJF   Moved all lowio initialization to ioinit.c for Win32.
*       03-12-92  SKS   Major changes to initialization/termination scheme
*       04-01-92  XY    implemented new intialization/termination schema (MAC)
*       04-16-92  DJM   POSIX support.
*       04-17-92  SKS   Export _initterm() for CRTDLL model
*       05-07-92  DJM   Removed _exit() from POSIX build.
*       06-03-92  GJF   Temporarily restored call to FORTRAN init.
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       08-28-92  GJF   Use unistd.h for POSIX build.
*       09-02-92  SKS   Fix _onexit table traversal to be LIFO.
*                       Since table is built forward (my changes 03-12-92)
*                       the table must be traversed in reverse order.
*       11-12-92  SKS   Remove hard-coded call to FORTRAN initializer
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Change to __declspec(dllexport) for CRT DLL model
*       04-19-93  SKS   Remove obsolete variable _child.
*       04-20-93  SKS   _C_Termination_Done is now used by DLLs in LIBC/LIBCMT
*                       models, not just in MSVCRT10.DLL.
*       07-16-93  SRW   ALPHA Merge
*       09-21-93  CFW   Move _initmbctable call to _cinit().
*       10-19-93  GJF   Merged NT and Cuda versions. Cleaned out a lot of old
*                       Cruiser and Dosx32 support. Replaced MTHREAD with
*                       _MT, _MIPS_ with _M_MRX000, _ALPHA_ with _M_ALPHA.
*       11-09-93  GJF   Moved _initmbctable call back into crt0.c.
*       11-09-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       11-19-93  CFW   Add _wargv, _wpgmptr.
*       11-29-93  CFW   Add _wenviron.
*       12-15-93  CFW   Set _pgmptr, _wpgmptr to NULL (MIPS compiler bug).
*       02-04-94  CFW   Add _[w]initenv.
*       03-25-94  GJF   Made definitions of:
*                           __argc,
*                           __argv,     __wargv,
*                           _C_Termination_Done,
*                           _environ,   _wenviron,
*                           _exitflag,
*                           __initenv,  __winitenv,
*                           __onexitbegin, __onexitend,
*                           _osver,
*                           _pgmptr,    _wpgmptr,
*                           _winmajor,
*                           _winminor
*                           _winver
*                       conditional on ndef DLL_FOR_WIN32S.
*       10-02-94  BWT   Add PPC changes
*       12-03-94  SKS   Clean up OS/2 references
*       02-11-95  CFW   PPC -> _M_MPPC.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       02-24-95  CFW   Call _CrtDumpMemoryLeaks.
*       02-27-95  CFW   Make _CrtDumpMemoryLeaks call conditional
*       04-06-95  CFW   Only check for static libs, avoid infinite loop.
*       07-24-95  CFW   Call _CrtDumpMemoryLeaks for PMac.
*       12-18-95  JWM   doexit() can no longer be called recursively.
*       08-01-96  RDK   For PMac, define _osflagfiles, cleaned up Gestalt test,
*                       and make termination parallel x86 functionality.
*       07-24-97  GJF   Added __env_initialized flag.
*       08-06-97  GJF   Moved __mbctype_initialized flag here from crt0.c.
*       09-26-97  BWT   Fix POSIX
*       10-07-97  RDL   Added IA64.
*       01-16-98  RDL   Removed IA64 from fpinit #if for _fltused support.
*       10-02-98  GJF   Added _osplatform.
*       11-13-98  KBF   Only do an atexit(RTC_Terminate) - moved Init to after
*                       _heap_init
*       02-01-99  GJF   Slight change to terminator execution loop to allow
*                       terminators to register more terminators.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       03-06-00  PML   Add __crtExitProcess for COM+ exit processing.
*       04-28-00  BWT   Fix Posix
*       08-04-00  PML   COM+ -> managed (VS7#117746).
*       03-27-01  PML   .CRT$XI funcs now return an error status (VS7#231220).
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#include <rtcapi.h>
#endif
#ifndef _XBOX
#include <dos.h>
#endif
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <dbgint.h>
#include <sect_attribs.h>

#ifdef _XBOX
__declspec(dllimport) VOID
__stdcall KeBugCheck (
    IN ULONG BugCheckCode
    );
#endif

/* define errno */
#ifndef _MT
int errno = 0;            /* libc error value */
unsigned long _doserrno = 0;  /* OS system error value */
#endif  /* _MT */


/* define umask */
int _umaskval = 0;


/* define version info variables */

#ifndef _XBOX

_CRTIMP unsigned int _osplatform = 0;
_CRTIMP unsigned int _osver = 0;
_CRTIMP unsigned int _winver = 0;
_CRTIMP unsigned int _winmajor = 0;
_CRTIMP unsigned int _winminor = 0;


/* argument vector and environment */

_CRTIMP int __argc = 0;
_CRTIMP char **__argv = NULL;
_CRTIMP wchar_t **__wargv = NULL;
#ifdef  _POSIX_
char **environ = NULL;
#else
_CRTIMP char **_environ = NULL;
_CRTIMP char **__initenv = NULL;
_CRTIMP wchar_t **_wenviron = NULL;
_CRTIMP wchar_t **__winitenv = NULL;
#endif
_CRTIMP char *_pgmptr = NULL;           /* ptr to program name */
_CRTIMP wchar_t *_wpgmptr = NULL;       /* ptr to wide program name */

#endif // XBOX


/* callable exit flag */
char _exitflag = 0;

/*
 * flag indicating if C runtime termination has been done. set if exit,
 * _exit, _cexit or _c_exit has been called. checked when _CRTDLL_INIT
 * is called with DLL_PROCESS_DETACH.
 */
int _C_Termination_Done = FALSE;
int _C_Exit_Done = FALSE;

#ifndef CRTDLL
/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
int __env_initialized;

#endif

#ifdef  _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
int __mbctype_initialized;
#endif  /* _MBCS */


/*
 * NOTE: THE USE OF THE POINTERS DECLARED BELOW DEPENDS ON THE PROPERTIES
 * OF C COMMUNAL VARIABLES. SPECIFICALLY, THEY ARE NON-NULL IFF THERE EXISTS
 * A DEFINITION ELSEWHERE INITIALIZING THEM TO NON-NULL VALUES.
 */

/*
 * pointers to initialization functions
 */

_PVFV _FPinit;          /* floating point init. */

#ifndef _XBOX

/*
 * pointers to initialization sections
 */

extern _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */

#endif // XBOX

extern _CRTALLOC(".CRT$XPA") _PVFV __xp_a[];
extern _CRTALLOC(".CRT$XPZ") _PVFV __xp_z[];    /* C pre-terminators */
extern _CRTALLOC(".CRT$XTA") _PVFV __xt_a[];
extern _CRTALLOC(".CRT$XTZ") _PVFV __xt_z[];    /* C terminators */


#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
/*
 * For MIPS compiler, must explicitly force in and call the floating point
 * initialization.
 */
extern void __cdecl _fpmath(void);
#endif

/*
 * pointers to the start and finish of the _onexit/atexit table
 */
_PVFV *__onexitbegin;
_PVFV *__onexitend;


/*
 * static (internal) functions that walk a table of function pointers,
 * calling each entry between the two pointers, skipping NULL entries
 *
 * _initterm needs to be exported for CRT DLL so that C++ initializers in the
 * client EXE / DLLs can be initialized.
 *
 * _initterm_e calls function pointers that return a nonzero error code to
 * indicate an initialization failed fatally.
 */
#ifdef  CRTDLL
void __cdecl _initterm(_PVFV *, _PVFV *);
#else
static void __cdecl _initterm(_PVFV *, _PVFV *);
#endif
static int  __cdecl _initterm_e(_PIFV *, _PIFV *);


#ifndef _XBOX
/***
*_cinit - C initialization
*
*Purpose:
*       This routine performs the shared DOS and Windows initialization.
*       The following order of initialization must be preserved -
*
*       1.  Check for devices for file handles 0 - 2
*       2.  Integer divide interrupt vector setup
*       3.  General C initializer routines
*
*Entry:
*       No parameters: Called from __crtstart and assumes data
*       set up correctly there.
*
*Exit:
*       Initializes C runtime data.
*       Returns 0 if all .CRT$XI internal initializations succeeded, else
*       the _RT_* fatal error code encountered.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _cinit (
        void
        )
{
        int initret;

        /*
         * initialize floating point package, if present
         */
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
        /*
         * MIPS compiler doesn't emit external reference to _fltused. Therefore,
         * must always force in the floating point initialization.
         */
        _fpmath();
#else
        if ( _FPinit != NULL )
            (*_FPinit)();
#endif

        /*
         * do initializations
         */
        initret = _initterm_e( __xi_a, __xi_z );
        if ( initret != 0 )
            return initret;

#ifdef  _RTC
        atexit(_RTC_Terminate);
#endif
        /*
         * do C++ initializations
         */
        _initterm( __xc_a, __xc_z );

        return 0;
}
#endif // XBOX


/***
*exit(status), _exit(status), _cexit(void), _c_exit(void) - C termination
*
*Purpose:
*
*       Entry points:
*
*           exit(code):  Performs all the C termination functions
*               and terminates the process with the return code
*               supplied by the user.
*
*           _exit(code):  Performs a quick exit routine that does not
*               do certain 'high-level' exit processing.  The _exit
*               routine terminates the process with the return code
*               supplied by the user.
*
*           _cexit():  Performs the same C lib termination processing
*               as exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*           _c_exit():  Performs the same C lib termination processing
*               as _exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*       Termination actions:
*
*           exit(), _cexit():
*
*           1.  call user's terminator routines
*           2.  call C runtime preterminators
*
*           _exit(), _c_exit():
*
*           3.  call C runtime terminators
*           4.  return to DOS or caller
*
*       Notes:
*
*       The termination sequence is complicated due to the multiple entry
*       points sharing the common code body while having different entry/exit
*       sequences.
*
*       Multi-thread notes:
*
*       1. exit() should NEVER be called when mthread locks are held.
*          The exit() routine can make calls that try to get mthread locks.
*
*       2. _exit()/_c_exit() can be called from anywhere, with or without locks held.
*          Thus, _exit() can NEVER try to get locks (otherwise, deadlock
*          may occur).  _exit() should always 'work' (i.e., the process
*          should always terminate successfully).
*
*       3. Only one thread is allowed into the exit code (see _lockexit()
*          and _unlockexit() routines).
*
*Entry:
*       exit(), _exit()
*           int status - exit status (0-255)
*
*       _cexit(), _c_exit()
*           <no input>
*
*Exit:
*       exit(), _exit()
*           <EXIT to DOS>
*
*       _cexit(), _c_exit()
*           Return to caller
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

/* worker routine prototype */
static void __cdecl doexit (int code, int quick, int retcaller);

void __cdecl exit (
        int code
        )
{
        doexit(code, 0, 0); /* full term, kill process */
}

#ifndef _POSIX_

void __cdecl _exit (
        int code
        )
{
        doexit(code, 1, 0); /* quick term, kill process */
}

void __cdecl _cexit (
        void
        )
{
        doexit(0, 0, 1);    /* full term, return to caller */
}

void __cdecl _c_exit (
        void
        )
{
        doexit(0, 1, 1);    /* quick term, return to caller */
}

#endif  /* _POSIX_ */


static void __cdecl doexit (
        int code,
        int quick,
        int retcaller
        )
{
#ifdef  _DEBUG
        static int fExit = 0;
#endif /* _DEBUG */

#ifdef  _MT
        _lockexit();        /* assure only 1 thread in exit path */
#endif

#ifndef _XBOX
#ifndef _POSIX_
        if (_C_Exit_Done == TRUE)                               /* if doexit() is being called recursively */
                TerminateProcess(GetCurrentProcess(),code);     /* terminate with extreme prejudice */
#endif
#endif // XBOX
        _C_Termination_Done = TRUE;

        /* save callable exit flag (for use by terminators) */
        _exitflag = (char) retcaller;  /* 0 = term, !0 = callable exit */

        if (!quick) {

            /*
             * do _onexit/atexit() terminators
             * (if there are any)
             *
             * These terminators MUST be executed in reverse order (LIFO)!
             *
             * NOTE:
             *  This code assumes that __onexitbegin points
             *  to the first valid onexit() entry and that
             *  __onexitend points past the last valid entry.
             *  If __onexitbegin == __onexitend, the table
             *  is empty and there are no routines to call.
             */

            if (__onexitbegin) {
                while ( --__onexitend >= __onexitbegin )
                /*
                 * if current table entry is non-NULL,
                 * call thru it.
                 */
                if ( *__onexitend != NULL )
                    (**__onexitend)();
            }

            /*
             * do pre-terminators
             */
            _initterm(__xp_a, __xp_z);
        }

        /*
         * do terminators
         */
        _initterm(__xt_a, __xt_z);

#ifndef CRTDLL
#ifdef  _DEBUG
        /* Dump all memory leaks */
        if (!fExit && _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
        {
            fExit = 1;
            _CrtDumpMemoryLeaks();
        }
#endif
#endif

        /* return to OS or to caller */

        if (retcaller) {
#ifdef  _MT
            _unlockexit();      /* unlock the exit code path */
#endif
            return;
        }

#ifdef _XBOX

        RIP("exit() unsupported on Xbox");
        KeBugCheck(0);

}
#else
#ifdef  _POSIX_

        _exit(code);
}

#else   /* ndef _POSIX_ */

        _C_Exit_Done = TRUE;

        __crtExitProcess(code);
}

/***
* __crtExitProcess - CRT wrapper for ExitProcess
*
*Purpose:
*       If we're part of a managed app, then call the CorExitProcess,
*       otherwise call ExitProcess.  For managed apps, calling ExitProcess can
*       be problematic, because it doesn't give the managed FinalizerThread a
*       chance to clean up.
*
*       To determine if we're a managed app, we check if mscoree.dll is loaded.
*       Then, if CorExitProcess is available, we call it.
*
*Entry:
*       int status - exit code
*
*Exit:
*       Does not return
*
*Exceptions:
*
*******************************************************************************/

typedef void (WINAPI * PFN_EXIT_PROCESS)(UINT uExitCode);

void __cdecl __crtExitProcess (
        int status
        )
{
        HMODULE hmod;
        PFN_EXIT_PROCESS pfn;

        hmod = GetModuleHandle("mscoree.dll");
        if (hmod != NULL) {
            pfn = (PFN_EXIT_PROCESS)GetProcAddress(hmod, "CorExitProcess");
            if (pfn != NULL) {
                pfn(status);
            }
        }

        /*
         * Either mscoree.dll isn't loaded,
         * or CorExitProcess isn't exported from mscoree.dll,
         * or CorExitProcess returned (should never happen).
         * Just call ExitProcess.
         */

        ExitProcess(status);
}

#endif  /* _POSIX_ */
#endif // XBOX

#ifdef  _MT
/***
* _lockexit - Aquire the exit code lock
*
*Purpose:
*       Makes sure only one thread is in the exit code at a time.
*       If a thread is already in the exit code, it must be allowed
*       to continue.  All other threads must pend.
*
*       Notes:
*
*       (1) It is legal for a thread that already has the lock to
*       try and get it again(!).  That is, consider the following
*       sequence:
*
*           (a) program calls exit()
*           (b) thread locks exit code
*           (c) user onexit() routine calls _exit()
*           (d) same thread tries to lock exit code
*
*       Since _exit() must ALWAYS be able to work (i.e., can be called
*       from anywhere with no regard for locking), we must make sure the
*       program does not deadlock at step (d) above.
*
*       (2) If a thread executing exit() or _exit() aquires the exit lock,
*       other threads trying to get the lock will pend forever.  That is,
*       since exit() and _exit() terminate the process, there is not need
*       for them to unlock the exit code path.
*
*       (3) Note that onexit()/atexit() routines call _lockexit/_unlockexit
*       to protect mthread access to the onexit table.
*
*       (4) The 32-bit OS semaphore calls DO allow a single thread to acquire
*       the same lock multiple times* thus, this version is straight forward.
*
*Entry: <none>
*
*Exit:
*       Calling thread has exit code path locked on return.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockexit (
        void
        )
{
        _mlock(_EXIT_LOCK1);
}

/***
* _unlockexit - Release exit code lock
*
*Purpose:
*       [See _lockexit() description above.]
*
*       This routine is called by _cexit(), _c_exit(), and onexit()/atexit().
*       The exit() and _exit() routines never unlock the exit code path since
*       they are terminating the process.
*
*Entry:
*       Exit code path is unlocked.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlockexit (
        void
        )
{
        _munlock(_EXIT_LOCK1);
}

#endif /* _MT */


/***
* static void _initterm(_PVFV * pfbegin, _PVFV * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

#ifdef  CRTDLL
void __cdecl _initterm (
#else
static void __cdecl _initterm (
#endif
        _PVFV * pfbegin,
        _PVFV * pfend
        )
{
        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend )
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                (**pfbegin)();
            ++pfbegin;
        }
}

/***
* static int  _initterm_e(_PIFV * pfbegin, _PIFV * pfend) - call entries in
*       function pointer table, return error code on any failure
*
*Purpose:
*       Walk a table of function pointers in the same way as _initterm, but
*       here the functions return an error code.  If an error is returned, it
*       will be a nonzero value equal to one of the _RT_* codes.
*
*Entry:
*       _PIFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PIFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

static int __cdecl _initterm_e (
        _PIFV * pfbegin,
        _PIFV * pfend
        )
{
        int ret = 0;

        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend  && ret == 0)
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                ret = (**pfbegin)();
            ++pfbegin;
        }

        return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\rtc\sources.inc ===
MAJORCOMP=crt
MINORCOMP=rtc

TARGETNAME=rtc

!INCLUDE ..\..\crt32.inc

C_DEFINES=$(C_DEFINES) -D_RTC

#removed pdblkup.cpp
SOURCES=\
    ..\bintree.cpp  \
    ..\callsite.cpp \
    ..\chsyheap.cpp \
    ..\contain.cpp  \
    ..\convert.cpp  \
    ..\error.cpp    \
    ..\fileio.cpp   \
    ..\init.cpp     \
    ..\initsect.cpp \
    ..\memory.cpp   \
    ..\shadow.cpp   \
    ..\stack.cpp    \
    ..\userapi.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\crt0init.c ===
/***
*crt0init.c - Initialization segment declarations.
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do initialization segment declarations.
*
*Notes:
*       In the 16-bit C world, the X*B and X*E segments were empty except for
*       a label.  This will not work with COFF since COFF throws out empty
*       sections.  Therefore we must put a zero value in them.  (Zero because
*       the routine to traverse the initializers will skip over zero entries.)
*
*Revision History:
*       03-19-92  SKS   Module created.
*       03-24-92  SKS   Added MIPS support (NO_UNDERSCORE)
*       08-06-92  SKS   Revised to use new section names and macros
*       10-19-93  SKS   Add .DiRECTiVE section for MIPS, too!
*       10-28-93  GJF   Rewritten in C
*       10-28-94  SKS   Add user32.lib as a default library
*       02-27-95  CFW   Remove user32.lib as a default library
*       06-22-95  CFW   Add /disallowlib directives.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       03-27-01  PML   .CRT$XI funcs now return an error status (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <stdio.h>
#include <internal.h>

#ifndef _XBOX

#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PIFV __xi_a[] = { NULL };


#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PIFV __xi_z[] = { NULL };


#pragma data_seg(".CRT$XCA")
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };


#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

#endif // XBOX

#pragma data_seg(".CRT$XPA")
_CRTALLOC(".CRT$XPA") _PVFV __xp_a[] = { NULL };


#pragma data_seg(".CRT$XPZ")
_CRTALLOC(".CRT$XPZ") _PVFV __xp_z[] = { NULL };


#pragma data_seg(".CRT$XTA")
_CRTALLOC(".CRT$XTA") _PVFV __xt_a[] = { NULL };


#pragma data_seg(".CRT$XTZ")
_CRTALLOC(".CRT$XTZ") _PVFV __xt_z[] = { NULL };

#pragma data_seg()  /* reset */

#ifdef  _M_IA64
// BUGBUG: the following should be enabled for ALPHA64 when .CRT is read-only
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#ifdef  NT_BUILD
#pragma comment(linker, "/merge:.CRT=.rdata")
#else
#pragma comment(linker, "/merge:.CRT=.data")
#endif
#endif

#ifndef _XBOX
#pragma comment(linker, "/defaultlib:kernel32.lib")
#endif

#if     !(!defined(_MT) && !defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libc.lib")
#endif
#if     !(!defined(_MT) &&  defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcd.lib")
#endif
#if     !( defined(_MT) && !defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcmt.lib")
#endif
#if     !( defined(_MT) &&  defined(_DEBUG))
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#endif
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\crt0.c ===
/***
*crt0.c - C runtime initialization routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps.  It calls the user's main
*       routine [w]main() or [w]WinMain after performing C Run-Time Library
*       initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrt0.c     the startup routine for console apps with wide chars
*       wincrt0.c   the startup routine for Windows apps
*       wwincrt0.c  the startup routine for Windows apps with wide chars
*
*Revision History:
*       06-27-89  PHG   Module created, based on asm version
*       11-02-89  JCR   Added DOS32QUERYSYSINFO to get osversion
*       04-09-90  GJF   Added #include <cruntime.h>. Put in explicit calling
*                       types (_CALLTYPE1 or _CALLTYPE4) for __crt0(),
*                       inherit(), __amsg_exit() and _cintDIV(). Also, fixed
*                       the copyright and cleaned up the formatting a bit.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       08-08-90  GJF   Added exception handling stuff (needed to support
*                       runtime errors and signal()).
*       08-31-90  GJF   Removed 32 from API names.
*       10-08-90  GJF   New-style function declarators.
*       12-05-90  GJF   Fixed off-by-one error in inherit().
*       12-06-90  GJF   Win32 version of inherit().
*       12-06-90  SRW   Added _osfile back for win32.  Changed _osfinfo from
*                       an array of structures to an array of 32-bit handles
*                       (_osfhnd)
*       01-21-91  GJF   ANSI naming.
*       01-25-91  SRW   Changed Win32 Process Startup [_WIN32_]
*       02-01-91  SRW   Removed usage of PPEB type [_WIN32_]
*       02-05-91  SRW   Changed to pass _osfile and _osfhnd arrays as binary
*                       data to child process.  [_WIN32_]
*       04-02-91  GJF   Need to get version number sooner so it can be used in
*                       _heap_init. Prefixed an '_' onto BaseProcessStartup.
*                       Version info now stored in _os[version|major|minor] and
*                       _base[version|major|minor] (_WIN32_).
*       04-10-91  PNT   Added _MAC_ conditional
*       04-26-91  SRW   Removed level 3 warnings
*       05-14-91  GJF   Turn on exception handling for Dosx32.
*       05-22-91  GJF   Fixed careless errors.
*       07-12-91  GJF   Fixed one more careless error.
*       08-13-91  GJF   Removed definitions of _confh and _coninpfh.
*       09-13-91  GJF   Incorporated Stevewo's startup variations.
*       11-07-91  GJF   Revised try-except, fixed outdated comments on file
*                       handle inheritance [_WIN32_].
*       12-02-91  SRW   Fixed WinMain startup code to skip over first token
*                       plus delimiters for the lpszCommandLine parameter.
*       01-17-92  GJF   Merge of NT and CRT version. Restored Stevewo's scheme
*                       for unhandled exceptions.
*       02-13-92  GJF   For Win32, moved file inheritance stuff to ioinit.c.
*                       Call to inherit() is replace by call to _ioinit().
*       03-23-92  OLM   Created MAC version
*       04-01-92  XY    Add cinit call (MAC)
*       04-16-92  DJM   POSIX support
*       06-10-92  PLM   Added putenv support (MAC)
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       08-26-92  GJF   Deleted version number(s) fetch from POSIX startup (it
*                       involved a Win32 API call).
*       09-30-92  SRW   Call _heap_init before _mtinit
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-01-93  CFW   Change try-except to __try-__except
*       04-05-93  JWM   GUI apps now call MessageBox() from _amsg_exit().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-19-93  SKS   Remove obsolete variable _atopsp
*       04-26-93  SKS   Change _mtinit to return failure
*                       remove a number of OS/2 (CRUISER) ifdefs
*       04-26-93  GJF   Made lpszCommandLine (unsigned char *) to deal with
*                       chars > 127 in the command line.
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-14-93  GJF   Added support for quoted program names.
*       09-08-93  CFW   Added call to _initmbctable.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-21-93  CFW   Move _initmbctable call to _cinit().
*       11-05-93  CFW   Undefine GetEnviromentStrings.
*       11-08-93  GJF   Guard as much init. code as possible with the __try -
*                       __except statement, especially _cinit(). Also,
*                       restored the call to __initmbctable to this module.
*       11-19-93  CFW   Add _wcmdln variable, enable wide char command line
*                       only.
*       11-23-93  CFW   GetEnviromentStrings undef moved to internal.h.
*       11-29-93  CFW   Wide environment.
*       12-21-93  CFW   Fix API failure error handling.
*       01-04-94  CFW   Pass copy of environment to main.
*       01-28-94  CFW   Move environment copying to setenv.c.
*       02-07-94  CFW   POSIXify.
*       03-30-93  CFW   Use __crtXXX calls for Unicode model.
*       04-08-93  CFW   cinit() should be later.
*       04-12-94  GJF   Moved declaration of _[w]initenv to internal.h.
*       04-14-94  GJF   Enclosed whole source in #ifndef CRTDLL - #endif.
*       09-02-94  SKS   Fix inaccurate description in file header comment
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       09-06-94  GJF   Added definitions of __error_mode and __app_type.
*       10-14-94  BWT   try->__try / except->__except for POSIX
*       01-16-95  CFW   Set default debug output for console.
*       02-11-95  CFW   PPC -> _M_MPPC.
*       02-16-95  JWM   Spliced _WIN32 & Mac versions.
*       03-28-95  BWT   Fail if unable to retrieve cmdline or envptr (fixes
*                       stress bug).
*       04-06-95  CFW   Set default debug output for Mac.
*       04-06-95  CFW   Use __crtGetEnvironmentStringsA.
*       04-26-95  CFW   Change default debug output for Mac to debugger.
*       07-04-95  GJF   Interface to __crtGetEnvironmentStrings and _setenvp
*                       changes slightly.
*       07-07-95  CFW   Simplify default report mode scheme.
*       04-22-96  GJF   Check for error on _heap_init.
*       01-17-97  GJF   For _heap_init() or _mtinit() failure, exit the
*                       process without going through _exit().
*       07-24-97  GJF   Moved building of lpszCommandLine to wincmdln.c. Also,
*                       heap_init changed slightly to support option to use
*                       heap running directly on Win32 API.
*       08-06-97  GJF   Moved __mbctype_initialized to crt0dat.c
*       12-23-97  RKP   Corrected posix use of _heap_init()
*       02-27-98  RKP   Added 64 bit support.
*       10-02-98  GJF   Use GetVersionEx instead of GetVersion and store OS ID
*                       in _osplatform.
*       11-13-98  KBF   Moved RTC_Initialize from _cinit to just after
*                       _heap_init
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  RDL   Win64 POSIX warning fix.
*       11-12-99  KBF   Create 4 new COM+ specific entrypoints which return
*                       instead of calling exit().
*       11-16-99  PML   ... and remove them - linker problems mean new
*                       entrypoints don't work.  Instead, look directly at the
*                       COM Descriptor Image Directory entry in the optional
*                       header to see if we are a COM+ app.
*       02-15-00  GB    Changed GetModuleHandle to GetModuleHandleA in
*                       check_complus_app.
*       03-06-00  PML   Call __crtExitProcess instead of ExitProcess.
*       08-04-00  PML   check_complus_app -> check_managed_app (VS7#117746).
*       12-09-00  PML   Tighten up check_managed_app tests (VS7#167293).
*       03-17-01  PML   _alloca the OSVERSIONINFO so /GS can work (vs7#224261)
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*       03-27-01  PML   Call to _amsg_exit on startup failure now pushed up to
*                       this level (vs7#231220)
*
*******************************************************************************/

#ifndef CRTDLL

#include <cruntime.h>
#ifndef _XBOX
#include <dos.h>
#endif
#include <internal.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>
#ifndef _POSIX_
#include <rterr.h>
#include <rtcapi.h>
#else
#include <posix/sys/types.h>
#include <posix/unistd.h>
#include <posix/signal.h>
#endif
#include <windows.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

/*
 * wWinMain is not yet defined in winbase.h. When it is, this should be
 * removed.
 */

int
WINAPI
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd
    );

#ifndef _XBOX

#ifdef  WPRFLAG
_TUCHAR * __cdecl _wwincmdln(void);
#else
_TUCHAR * __cdecl _wincmdln(void);
#endif

/*
 * command line, environment, and a few other globals
 */

#ifdef  WPRFLAG
wchar_t *_wcmdln;           /* points to wide command line */
#else
char *_acmdln;              /* points to command line */
#endif

char *_aenvptr = NULL;      /* points to environment block */
#ifndef _POSIX_
wchar_t *_wenvptr = NULL;   /* points to wide environment block */
#endif

#ifdef  _POSIX_
char *_cmdlin;
#endif

#endif // XBOX

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */

static void __cdecl fast_error_exit(int);   /* Error exit via ExitProcess */

static int __cdecl check_managed_app(void); /* Determine if a managed app */

#ifndef _XBOX
/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
#ifdef  _WINMAIN_
int __app_type = _GUI_APP;
#else
int __app_type = _CONSOLE_APP;
#endif

#ifdef  _POSIX_

/***
*mainCRTStartup(void)
*
*Purpose:
*       This routine does the C runtime initialization, calls main(), and
*       then exits.  It never returns.
*
*Entry:
*
*Exit:
*       This function never returns.
*
*******************************************************************************/

void
mainCRTStartup(
        void
        )
{
        int mainret;
        char **ppch;

        extern char **environ;
        extern char * __PdxGetCmdLine(void);  /* an API in the Posix SS */
        extern main(int,char**);

        _cmdlin = __PdxGetCmdLine();
        ppch = (char **)_cmdlin;
        __argv = ppch;

        // normalize argv pointers

        __argc = 0;
        while (NULL != *ppch) {
            *ppch += (int)(intptr_t)_cmdlin;
            ++__argc;
            ++ppch;
        }
        // normalize environ pointers

        ++ppch;
        environ = ppch;

        while (NULL != *ppch) {
            *ppch = *ppch + (int)(intptr_t)_cmdlin;
            ++ppch;
        }

        /*
         * If POSIX runtime needs to fetch and store POSIX verion info,
         * it should be done here.
         *
         *      Get_and_save_version_info;
         */

#ifdef  _MT
        _heap_init(1);                          /* initialize heap */
#else
        _heap_init(0);                          /* initialize heap */
#endif

        initret = _cinit();                     /* do C data initialize */
        if (initret != 0)
            _amsg_exit(initret);

        __try {
            mainret = main(__argc, __argv);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            switch (GetExceptionCode()) {
            case STATUS_ACCESS_VIOLATION:
                kill(getpid(), SIGSEGV);
                break;
            case STATUS_ILLEGAL_INSTRUCTION:
            case STATUS_PRIVILEGED_INSTRUCTION:
                kill(getpid(), SIGILL);
                break;
            case STATUS_FLOAT_DENORMAL_OPERAND:
            case STATUS_FLOAT_DIVIDE_BY_ZERO:
            case STATUS_FLOAT_INEXACT_RESULT:
            case STATUS_FLOAT_OVERFLOW:
            case STATUS_FLOAT_STACK_CHECK:
            case STATUS_FLOAT_UNDERFLOW:
                kill(getpid(), SIGFPE);
                break;
            default:
                kill(getpid(), SIGKILL);
            }

            mainret = -1;
        }
        exit(mainret);
}
#else   /* ndef _POSIX_ */

/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

#ifdef  _WINMAIN_

#ifdef  WPRFLAG
int wWinMainCRTStartup(
#else
int WinMainCRTStartup(
#endif

#else   /* ndef _WINMAIN_ */

#ifdef  WPRFLAG
int wmainCRTStartup(
#else
int mainCRTStartup(
#endif

#endif  /* _WINMAIN_ */

        void
        )

{
        int initret;
        int mainret;
#ifndef _XBOX   // No need for this on XBox (RAID #1518)
        OSVERSIONINFOA *posvi;
#endif
        int managedapp;
#ifdef  _WINMAIN_
        _TUCHAR *lpszCommandLine;
        STARTUPINFO StartupInfo;
#endif
        /*
         * Dynamically allocate the OSVERSIONINFOA buffer, so we avoid
         * triggering the /GS buffer overrun detection.  That can't be
         * used here, since the guard cookie isn't available until we
         * initialize it from here!
         */
        posvi = (OSVERSIONINFOA *)_alloca(sizeof(OSVERSIONINFOA));

#ifndef _XBOX   // No need for these on XBox (RAID #1518)
        /*
         * Get the full Win32 version
         */
        posvi->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        (void)GetVersionExA(posvi);

        _osplatform = posvi->dwPlatformId;
        _winmajor = posvi->dwMajorVersion;
        _winminor = posvi->dwMinorVersion;

        /*
         * The somewhat bizarre calculations of _osver and _winver are
         * required for backward compatibility (used to use GetVersion)
         */
        _osver = (posvi->dwBuildNumber) & 0x07fff;
        if ( _osplatform != VER_PLATFORM_WIN32_NT )
            _osver |= 0x08000;
        _winver = (_winmajor << 8) + _winminor;
#endif

        /*
         * Determine if this is a managed application
         */
        managedapp = check_managed_app();

#ifdef  _MT
        if ( !_heap_init(1) )               /* initialize heap */
#else
        if ( !_heap_init(0) )               /* initialize heap */
#endif
            fast_error_exit(_RT_HEAPINIT);  /* write message and die */

#ifdef  _MT
        if( !_mtinit() )                    /* initialize multi-thread */
            fast_error_exit(_RT_THREAD);    /* write message and die */
#endif

        /*
         * Initialize the Runtime Checks stuff
         */
#ifdef  _RTC
        _RTC_Initialize();
#endif
        /*
         * Guard the remainder of the initialization code and the call
         * to user's main, or WinMain, function in a __try/__except
         * statement.
         */

        __try {

            if ( _ioinit() < 0 )            /* initialize lowio */
                _amsg_exit(_RT_LOWIOINIT);

#ifdef  WPRFLAG
            /* get wide cmd line info */
            _wcmdln = (wchar_t *)__crtGetCommandLineW();

            /* get wide environ info */
            _wenvptr = (wchar_t *)__crtGetEnvironmentStringsW();

            if ( _wsetargv() < 0 )
                _amsg_exit(_RT_SPACEARG);
            if ( _wsetenvp() < 0 )
                _amsg_exit(_RT_SPACEENV);
#else
            /* get cmd line info */
            _acmdln = (char *)GetCommandLineA();

            /* get environ info */
            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            if ( _setargv() < 0 )
                _amsg_exit(_RT_SPACEARG);
            if ( _setenvp() < 0 )
                _amsg_exit(_RT_SPACEENV);
#endif

            initret = _cinit();                     /* do C data initialize */
            if (initret != 0)
                _amsg_exit(initret);

#ifdef  _WINMAIN_

            StartupInfo.dwFlags = 0;
            GetStartupInfo( &StartupInfo );

#ifdef  WPRFLAG
            lpszCommandLine = _wwincmdln();
            mainret = wWinMain(
#else
            lpszCommandLine = _wincmdln();
            mainret = WinMain(
#endif
                               GetModuleHandleA(NULL),
                               NULL,
                               lpszCommandLine,
                               StartupInfo.dwFlags & STARTF_USESHOWWINDOW
                                    ? StartupInfo.wShowWindow
                                    : SW_SHOWDEFAULT
                             );
#else   /* _WINMAIN_ */

#ifdef  WPRFLAG
            __winitenv = _wenviron;
            mainret = wmain(__argc, __wargv, _wenviron);
#else
            __initenv = _environ;
            mainret = main(__argc, __argv, _environ);
#endif

#endif  /* _WINMAIN_ */

            if ( !managedapp )
                exit(mainret);

            _cexit();

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */

            mainret = GetExceptionCode();

            if ( !managedapp )
                _exit(mainret);

            _c_exit();

        } /* end of try - except */

        return mainret;
}


#endif  /* _POSIX_ */

#endif // XBOX

/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{
#ifndef _XBOX
#ifdef  _WINMAIN_
        if ( __error_mode == _OUT_TO_STDERR )
#else
        if ( __error_mode != _OUT_TO_MSGBOX )
#endif
#endif // XBOX
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);  /* write message */
        _aexit_rtn(255);        /* normally _exit(255) */
}

/***
*fast_error_exit(rterrnum) - Faster exit fatal errors
*
*Purpose:
*       Exit the process with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls ExitProcess (through __crtExitProcess).
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl fast_error_exit (
        int rterrnum
        )
{
#ifndef _XBOX
#ifdef  _WINMAIN_
        if ( __error_mode == _OUT_TO_STDERR )
#else
        if ( __error_mode != _OUT_TO_MSGBOX )
#endif
#endif // XBOX
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);  /* write message */
        __crtExitProcess(255);  /* normally _exit(255) */
}

#ifndef _XBOX

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER32 pNTHeader32;
        PIMAGE_OPTIONAL_HEADER64 pNTHeader64;

        pDOSHeader = (PIMAGE_DOS_HEADER)GetModuleHandleA(NULL);
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        pNTHeader32 = (PIMAGE_OPTIONAL_HEADER32)&pPEHeader->OptionalHeader;
        switch ( pNTHeader32->Magic ) {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            /* PE header */
            if ( pNTHeader32->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader32 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            /* PE+ header */
            pNTHeader64 = (PIMAGE_OPTIONAL_HEADER64)pNTHeader32;
            if ( pNTHeader64->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader64 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        }

        /* Not PE or PE+, so not managed */
        return 0;
}

#endif // XBOX

#ifndef WPRFLAG

#ifdef  _POSIX_

/***
*RaiseException() - stub for posix FP routines
*
*Purpose:
*       Stub of a Win32 API that posix can't call
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    const ULONG_PTR * lpArguments
    )
{
}

#endif  /* _POSIX_ */

#endif  /* WPRFLAG */

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\crt0fp.c ===
/***
*crt0fp.asm - floating point not loaded trap
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	To trap certain cases where certain necessary floating-point
*	software is not loaded.  Two specific cases are when no emulator
*	is linked in but no coprocessor is present, and when floating
*	point i/o conversions are done, but no floating-point variables
*	or expressions are used in the program.
*
*Revision History:
*	06-29-89  PHG	module created, based on asm version
*	04-09-90  GJF	Added #include <cruntime.h>. Made calling type
*			_CALLTYPE1. Also, fixed the copyright.
*	04-10-90  GJF	Fixed compiler warnings (-W3).
*	10-08-90  GJF	New-style function declarator.
*	10-11-90  GJF	Changed _amsg_exit() interface.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>

/***
*_fptrap - trap for missing floating-point software
*
*Purpose:
*	Catches these cases of incomplete f.p. software linked into a program.
*
*	(1) no coprocessor present, and no emulator linked in
*
*	(2) "%e", "%f", and "%g" i/o conversion formats specified, but
*	    not all conversion software has been linked in, because the
*	    program did not use any floating-point variables or expressions.
*
*Entry:
*	None.
*
*Exit:
*	Never returns.
*
*Exceptions:
*	Transfers control to _amsg_exit which ...
*	- Writes error message to standard error:  "floating point not loaded"
*	- Terminates the program by calling _exit().
*******************************************************************************/

void __cdecl _fptrap(
	void
	)
{
	_amsg_exit(_RT_FLOAT);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\sources.inc ===
MAJORCOMP=crt
MINORCOMP=startup

TARGETNAME=startup

!INCLUDE ..\..\crt32.inc

NTTARGETFILE1=
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)_setargv.c: $(SRCDIR)stdargv.c

$(SRCDIR)wincrt0.c: $(SRCDIR)crt0.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\dllmain.c ===
/***
*dllmain.c - Dummy DllMain for user DLLs that have no notification handler
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into LIBC.LIB and LIBCMT.LIB and MSVCRT.LIB for use
*       when linking a DLL with one of the three models of C run-time library.
*       If the user does not provide a DllMain notification routine, this
*       dummy handler will be linked in.  It always returns TRUE (success).
*
*Revision History:
*       04-14-93  SKS   Initial version
*       02-22-95  JCF   Spliced _WIN32 & Mac versions.
*       04-06-95  SKS   In LIBC.LIB and MSVCRT.LIB models, turn off thread
*                       attach and detach notifications to the current DLL.
*       05-17-99  PML   Remove all Macintosh support.
*
******************************************************************************/

#include <oscalls.h>
#define _DECL_DLLMAIN   /* include prototype of _pRawDllMain */
#include <process.h>

/***
*DllMain - dummy version DLLs linked with all 3 C Run-Time Library models
*
*Purpose:
*       The routine DllMain is always called by _DllMainCrtStartup.  If
*       the user does not provide a routine named DllMain, this one will
*       get linked in so that _DllMainCRTStartup has something to call.
*
*       For the LIBC.LIB and MSVCRT.LIB models, the CRTL does not need
*       per-thread notifications so if the user is ignoring them (default
*       DllMain and _pRawDllMain == NULL), just turn them off.  (WIN32-only)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
******************************************************************************/

BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
#if !defined(_MT) || defined(CRTDLL)
        if ( dwReason == DLL_PROCESS_ATTACH && ! _pRawDllMain )
                DisableThreadLibraryCalls(hDllHandle);
#endif
        return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\crt0msg.c ===
/***
*crt0msg.c - startup error messages
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prints out banner for runtime error messages.
*
*Revision History:
*       06-27-89  PHG   Module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling type
*                       _CALLTYPE1. Also, fixed the copyright.
*       04-10-90  GJF   Fixed compiler warnings (-W3).
*       06-04-90  GJF   Revised to be more compatible with old scheme.
*                       nmsghdr.c merged in.
*       10-08-90  GJF   New-style function declarators.
*       10-11-90  GJF   Added _RT_ABORT, _RT_FLOAT, _RT_HEAP.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       02-04-91  SRW   Changed to call WriteFile (_WIN32_)
*       02-25-91  MHL   Adapt to ReadFile/WriteFile changes (_WIN32_)
*       04-10-91  PNT   Added _MAC_ conditional
*       09-09-91  GJF   Added _RT_ONEXIT error.
*       09-18-91  GJF   Added 3 math errors, also corrected comments for
*                       errors that were changed in rterr.h, cmsgs.h.
*       03-31-92  DJM   POSIX support.
*       10-23-92  GJF   Added _RT_PUREVIRT.
*       04-05-93  JWM   Added _GET_RTERRMSG().
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-29-93  GJF   Removed rterrs[] entries for _RT_STACK, _RT_INTDIV,
*                       _RT_NONCONT and _RT_INVALDISP.
*       09-06-94  CFW   Remove Cruiser support.
*       09-06-94  GJF   Revised to use MessageBox for GUI apps.
*       01-10-95  JCF   Remove __app_type and __error_mode check for _MAC_.
*       02-14-95  CFW   write -> _write, error messages to debug reporting.
*       02-15-95  CFW   Make all CRT message boxes look alike.
*       02-24-95  CFW   Use __crtMessageBoxA.
*       02-27-95  CFW   Change __crtMessageBoxA params.
*       03-07-95  GJF   Added _RT_STDIOINIT.
*       03-21-95  CFW   Add _CRT_ASSERT report type.
*       06-06-95  CFW   Remove _MB_SERVICE_NOTIFICATION.
*       06-19-95  CFW   Avoid STDIO calls.
*       06-20-95  GJF   Added _RT_LOWIOINIT.
*       04-23-96  GJF   Added _RT_HEAPINIT. Also, revised _NMSG_WRITE to
*                       allow for ioinit() having not been invoked.
*       05-05-97  GJF   Changed call to WriteFile, in _NMSG_WRITE, so that 
*                       it does not reference _pioinfo. Also, a few cosmetic
*                       changes.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       01-24-99  PML   Fix buffer overrun in _NMSG_WRITE.
*       05-10-00  GB    Fix call of _CrtDbgReport for _RT_BANNER in _NMSG_WRITE
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <rterr.h>
#include <cmsgs.h>
#include <awint.h>
#include <windows.h>
#include <dbgint.h>

#ifdef  _POSIX_
#include <posix\sys\types.h>
#include <posix\unistd.h>
#endif

/* struct used to lookup and access runtime error messages */

struct rterrmsgs {
        int rterrno;        /* error number */
        char *rterrtxt;     /* text of error message */
};

/* runtime error messages */

static struct rterrmsgs rterrs[] = {

        /* 2 */
        { _RT_FLOAT, _RT_FLOAT_TXT },

        /* 8 */
        { _RT_SPACEARG, _RT_SPACEARG_TXT },

        /* 9 */
        { _RT_SPACEENV, _RT_SPACEENV_TXT },

        /* 10 */
        { _RT_ABORT, _RT_ABORT_TXT },

        /* 16 */
        { _RT_THREAD, _RT_THREAD_TXT },

        /* 17 */
        { _RT_LOCK, _RT_LOCK_TXT },

        /* 18 */
        { _RT_HEAP, _RT_HEAP_TXT },

        /* 19 */
        { _RT_OPENCON, _RT_OPENCON_TXT },

        /* 22 */
        /* { _RT_NONCONT, _RT_NONCONT_TXT }, */

        /* 23 */
        /* { _RT_INVALDISP, _RT_INVALDISP_TXT }, */

        /* 24 */
        { _RT_ONEXIT, _RT_ONEXIT_TXT },

        /* 25 */
        { _RT_PUREVIRT, _RT_PUREVIRT_TXT },

        /* 26 */
        { _RT_STDIOINIT, _RT_STDIOINIT_TXT },

        /* 27 */
        { _RT_LOWIOINIT, _RT_LOWIOINIT_TXT },

        /* 28 */
        { _RT_HEAPINIT, _RT_HEAPINIT_TXT },

        /* 120 */
        { _RT_DOMAIN, _RT_DOMAIN_TXT },

        /* 121 */
        { _RT_SING, _RT_SING_TXT },

        /* 122 */
        { _RT_TLOSS, _RT_TLOSS_TXT },

        /* 252 */
        { _RT_CRNL, _RT_CRNL_TXT },

        /* 255 */
        { _RT_BANNER, _RT_BANNER_TXT }

};

/* number of elements in rterrs[] */

#define _RTERRCNT   ( sizeof(rterrs) / sizeof(struct rterrmsgs) )

/* For C, _FF_DBGMSG is inactive, so _adbgmsg is
   set to null
   For FORTRAN, _adbgmsg is set to point to
   _FF_DBGMSG in dbginit initializer in dbgmsg.asm  */

void (*_adbgmsg)(void) = NULL;

/***
*_FF_MSGBANNER - writes out first part of run-time error messages
*
*Purpose:
*       This routine writes "\r\nrun-time error " to standard error.
*
*       For FORTRAN $DEBUG error messages, it also uses the _FF_DBGMSG
*       routine whose address is stored in the _adbgmsg variable to print out
*       file and line number information associated with the run-time error.
*       If the value of _adbgmsg is found to be null, then the _FF_DBGMSG
*       routine won't be called from here (the case for C-only programs).
*
*Entry:
*       No arguments.
*
*Exit:
*       Nothing returned.
*
*Exceptions:
*       None handled.
*
*******************************************************************************/

void __cdecl _FF_MSGBANNER (
        void
        )
{

#ifndef _XBOX
        if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
               _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
#endif
        {
            _NMSG_WRITE(_RT_CRNL);  /* new line to begin error message */
            if (_adbgmsg != 0)
                _adbgmsg(); /* call __FF_DBGMSG for FORTRAN */
            _NMSG_WRITE(_RT_BANNER); /* run-time error message banner */
        }
}


/***
*__NMSGWRITE(message) - write a given message to handle 2 (stderr)
*
*Purpose:
*       This routine writes the message associated with rterrnum
*       to stderr.
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

void __cdecl _NMSG_WRITE (
        int rterrnum
        )
{
        int tblindx;
#if     !defined(_POSIX_)
        DWORD bytes_written;            /* bytes written */
#endif

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                break;

        if ( rterrnum == rterrs[tblindx].rterrno )
        {
#ifdef  _DEBUG
            /*
             * Report error.
             *
             * If _CRT_ERROR has _CRTDBG_REPORT_WNDW on, and user chooses
             * "Retry", call the debugger.
             *
             * Otherwise, continue execution.
             *
             */

            if (rterrnum != _RT_CRNL && rterrnum != _RT_BANNER)
            {
                if (1 == _CrtDbgReport(_CRT_ERROR, NULL, 0, NULL, rterrs[tblindx].rterrtxt))
                    _CrtDbgBreak();
            }
#endif

#ifdef _XBOX
        OutputDebugStringA(rterrs[tblindx].rterrtxt);
#else
#if     !defined(_POSIX_)
            if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
                   _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
            {
                WriteFile( GetStdHandle(STD_ERROR_HANDLE),
                           rterrs[tblindx].rterrtxt,
                           (unsigned long)strlen(rterrs[tblindx].rterrtxt),
                           &bytes_written,
                           NULL );
            }
            else if (rterrnum != _RT_CRNL)
            {
                #define MAXLINELEN 60
                char * pch;
                char progname[MAX_PATH + 1];
                char * outmsg;

                progname[MAX_PATH] = '\0';
                if (!GetModuleFileName(NULL, progname, MAX_PATH))
                    strcpy(progname, "<program name unknown>");

                pch = (char *)progname;

                if (strlen(pch) + 1 > MAXLINELEN)
                {
                    pch += strlen(progname) + 1 - MAXLINELEN;
                    strncpy(pch, "...", 3);
                }

                #define MSGTEXTPREFIX "Runtime Error!\n\nProgram: "
                outmsg = (char *)_alloca(sizeof(MSGTEXTPREFIX)
                                         + strlen(pch)
                                         + 2
                                         + strlen(rterrs[tblindx].rterrtxt));

                strcpy(outmsg, MSGTEXTPREFIX);
                strcat(outmsg, pch);
                strcat(outmsg, "\n\n");
                strcat(outmsg, rterrs[tblindx].rterrtxt);

                __crtMessageBoxA(outmsg,
                        "Microsoft Visual C++ Runtime Library",
                        MB_OK|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
            }

#else   /* !_POSIX_ */

            write(STDERR_FILENO,rterrs[tblindx].rterrtxt,
            strlen(rterrs[tblindx].rterrtxt));

#endif  /* !_POSIX_ */
#endif // XBOX

        }
}


/***
*_GET_RTERRMSG(message) - returns ptr to error text for given runtime error
*
*Purpose:
*       This routine returns the message associated with rterrnum
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

char * __cdecl _GET_RTERRMSG (
        int rterrnum
        )
{
        int tblindx;

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                break;

        if ( rterrnum == rterrs[tblindx].rterrno )
            return rterrs[tblindx].rterrtxt;
        else
            return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\dllcrt0.c ===
/***
*dllcrt0.c - C runtime initialization routine for a DLL with linked-in C R-T
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This the startup routine for a DLL which is linked with its own
*       C run-time code.  It is similar to the routine _mainCRTStartup()
*       in the file CRT0.C, except that there is no main() in a DLL.
*
*Revision History:
*       05-04-92  SKS   Based on CRT0.C (start-up code for EXE's)
*       08-26-92  SKS   Add _osver, _winver, _winmajor, _winminor
*       09-16-92  SKS   This module used to be enabled only in LIBCMT.LIB,
*                       but it is now enabled for LIBC.LIB as well!
*       09-29-92  SKS   _CRT_INIT needs to be WINAPI, not cdecl
*       10-16-92  SKS   Call _heap_init before _mtinit (fix copied from CRT0.C)
*       10-24-92  SKS   Call to _mtdeletelocks() must be under #ifdef MTHREAD!
*       03-20-93  SKS   Remove obsolete variables _osmode, _cpumode, etc.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  SKS   _DllMainCRTStartup replaces _CRT_INIT.  Also, call
*                       _mtterm instead of _mtdeletelocks on PROCESS_DETACH
*                       to do all multi-thread cleanup (e.g. free up TLS index)
*       04-19-93  SKS   Remove obsolete variable _atopsp
*       04-20-93  SKS   Call _cexit on DLL detach
*       04-20-93  SKS   Restore _CRT_INIT, must co-exist with DllMainCRTStartup
*       04-26-93  SKS   _mtinit now returns 0 or 1, no longer calls _amsg_exit
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       05-06-93  SKS   Add call to _heap_term to free up all allocated memory
*                       *and* address space.  This must be the last thing done.
*       06-08-93  GJF   Added __proc_attached flag.
*       06-08-93  SKS   Clean up failure handling in _CRT_INIT
*       11-05-93  CFW   Undefine GetEnviromentStrings.
*       11-09-93  GJF   Added call to __initmbctable (must happen before args
*                       and env strings are processed).
*       11-09-93  GJF   Added (restored) support for NT SDK builds. Also,
*                       replaced MTHREAD with _MT.
*       11-20-93  CFW   Wide char enable.
*       11-23-93  CFW   GetEnviromentStrings undef moved to internal.h.
*       11-29-93  CFW   Wide environment.
*       12-06-93  CFW   Wide char enable.
*       12-13-93  SKS   Free up per-thread CRT data on DLL_THREAD_DETACH
*                       using a call to _freeptd() in _CRT_INIT()
*       03-30-93  CFW   Use __crtXXX calls for Unicode model.
*       04-08-93  CFW   Move __crtXXX calls past initialization.
*       06-08-94  SKS   Add functn pointer _pRawDllMain, called around DllMain.
*       09-06-94  CFW   Remove _MBCS_OS switch.
*       09-06-94  GJF   Added __error_mode and __app_type.
*       09-15-94  SKS   Move #ifndef directives to after file header comment
*       12-27-94  CFW   Remove unused _wDll support.
*       01-16-95  CFW   Set default debug output for console.
*       02-22-95  JCF   Spliced _WIN32 & Mac versions.
*       03-10-95  JCF   Return the user error from DllInit instead of noErr.
*       03-28-95  BWT   Fail if unable to retrieve cmdline or envptr (fixes
*                       stress bug).
*       04-06-95  CFW   Set default debug output for Mac, dump leaks for user
*                       DLL.
*       04-06-95  CFW   Use __crtGetEnvironmentStringsA.
*       04-12-95  CFW   __crtGetEnvironmentStringsA must be after mtinit().
*       04-14-95  CFW   env, arg test must also be.
*       04-26-95  CFW   Change default debug output for Mac to debugger.
*       05-23-95  CFW   Dump memory leaks before mtterm().
*       06-27-95  CFW   Always set __app_type.
*       06-28-95  GJF    Added call to _ioterm() to clean up lowio at DLL
*                       unload time.
*       07-04-95  GJF   Interface to __crtGetEnvironmentStrings and _setenvp
*                       changes slightly.
*       07-07-95  CFW   Simplify default report mode scheme.
*       04-23-96  GJF   Check for failure of heap initialization.
*       05-14-96  GJF   Changed how failure during process attach is handled.
*       02-18-97  GJF   Removed obsolete Win32s and PharLap TNT support. Also,
*                       some cosmetic changes.
*       07-24-97  GJF   Minor changes to support stubbing out arg and env 
*                       processing, and our heap manager.
*       10-02-98  GJF   Use GetVersionEx instead of GetVersion and store OS ID
*                       in _osplatform.
*       11-13-98  KBF   Moved RTC_Initialize from _cinit to after _heap_init.
*       05-11-99  KBF   Wrap RTC support in #ifdef.
*       05-17-99  PML   Remove all Macintosh support.
*       02-02-00  GB    Added ATTACH_THREAD support for _CRT_INIT where we
*                       initialise per thread data so that in case where we
*                       are short of memory, we don't have to kill the whole
*                       process for inavailablity of space.
*       08-22-00  GB    Fixed potentia leak of ptd in CRT_INIT
*       03-16-01  PML   _alloca the OSVERSIONINFO so /GS can work (vs7#224261)
*       03-26-01  PML   Use GetVersionExA, not GetVersionEx (vs7#230286)
*       03-27-01  PML   Fail DLL load instead of calling _amsg_exit (vs7#231220)
*
*******************************************************************************/

#ifndef _POSIX_         /* not built for POSIX */
#ifndef CRTDLL          /* not built for CRTDLL */

#include <cruntime.h>
#include <dos.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <rterr.h>
#include <oscalls.h>
#define _DECL_DLLMAIN   /* enable prototypes for DllMain and _CRT_INIT */
#include <process.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>
#include <rtcapi.h>

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;

/*
 * command line, environment, and a few other globals
 */
char *_acmdln;              /* points to command line */

char *_aenvptr = NULL;      /* points to environment block */
wchar_t *_wenvptr = NULL;   /* points to wide environment block */

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */

/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
int __app_type = _UNKNOWN_APP;

/*
 * User routine DllMain is called on all notifications
 */
extern BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        ) ;

/* _pRawDllMain MUST be a common variable, not extern nor initialized! */

BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);

/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination.
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine must be the entry point for the DLL.
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        /*
         * Start-up code only gets executed when the process is initialized
         */

        if ( dwReason == DLL_PROCESS_ATTACH )
        {
            /*
             * Dynamically allocate the OSVERSIONINFOA buffer, so we avoid
             * triggering the /GS buffer overrun detection.  That can't be
             * used here, since the guard cookie isn't available until we
             * initialize it from here!
             */
            OSVERSIONINFOA *posvi =
                (OSVERSIONINFOA *)_alloca(sizeof(OSVERSIONINFOA));

            /*
             * Get the full Win32 version
             */
            posvi->dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            if ( !GetVersionExA(posvi) )
                return FALSE;

            _osplatform = posvi->dwPlatformId;
            _winmajor = posvi->dwMajorVersion;
            _winminor = posvi->dwMinorVersion;

            /*
             * The somewhat bizarre calculations of _osver and _winver are 
             * required for backward compatibility (used to use GetVersion)
             */
            _osver = (posvi->dwBuildNumber) & 0x07fff;
            if ( _osplatform != VER_PLATFORM_WIN32_NT )
                _osver |= 0x08000;
            _winver = (_winmajor << 8) + _winminor;

#ifdef  _MT
            if ( !_heap_init(1) )   /* initialize heap */
#else
            if ( !_heap_init(0) )   /* initialize heap */
#endif
                return FALSE;       /* fail to load DLL */

#ifdef  _MT
            if(!_mtinit())          /* initialize multi-thread */
            {
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }
#endif  /* _MT */

            /*
             * Initialize the Runtime Checks stuff
             */
#ifdef  _RTC
            _RTC_Initialize();
#endif
            _acmdln = (char *)GetCommandLineA();
            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            if (_ioinit() < 0) {    /* initialize lowio */
#ifdef  _MT
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
#endif  /* _MT */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            if (_setargv() < 0 ||   /* get cmd line info */
                _setenvp() < 0 ||   /* get environ info */
                _cinit() != 0)      /* do C data initialize */
            {
                _ioterm();          /* shut down lowio */
#ifdef  _MT
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
#endif  /* _MT */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            /*
             * increment flag to indicate process attach notification
             * has been received
             */
            __proc_attached++;
        }

        else if ( dwReason == DLL_PROCESS_DETACH )
        {
            if ( __proc_attached > 0 ) 
            {
                __proc_attached--;

                /*
                 * Any basic clean-up code that goes here must be duplicated
                 * below in _DllMainCRTStartup for the case where the user's
                 * DllMain() routine fails on a Process Attach notification.
                 * This does not include calling user C++ destructors, etc.
                 */

                if ( _C_Termination_Done == FALSE )
                    _cexit();

#ifdef  _DEBUG
                /* Dump all memory leaks */
                if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
                    _CrtDumpMemoryLeaks();
#endif

                /* Shut down lowio */
                _ioterm();

#ifdef  _MT
                _mtterm();
#endif

                /* This should be the last thing the C run-time does */
                _heap_term();   /* heap is now invalid! */
            }
            else
                /* no prior process attach, just return */
                return FALSE;
        }
#ifdef  _MT
        else if ( dwReason == DLL_THREAD_ATTACH )
        {
            _ptiddata ptd;
            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL))
            {
                if (TlsSetValue(__tlsindex, (LPVOID)ptd) ) {
                    /*
                     * Initialize of per-thread data
                     */
                    _initptd(ptd);
                    
                    ptd->_tid = GetCurrentThreadId();
                    ptd->_thandle = (uintptr_t)(-1);
                } else
                {
                    _free_crt(ptd);
                    return FALSE;
                }
            } else
            {
                return FALSE;
            }
        }
        else if ( dwReason == DLL_THREAD_DETACH )
        {
            _freeptd(NULL);         /* free up per-thread CRT data */
        }
#endif

        return TRUE ;
}

/***
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination
*       and then calls the user code notification handler "DllMain".
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine is the preferred entry point. _CRT_INIT may also be
*       used, or the user may supply his/her own entry and call _CRT_INIT
*       from within it, but this is not the preferred method.
*
*******************************************************************************/

BOOL WINAPI _DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        BOOL retcode = TRUE;

        /*
         * If this is a process detach notification, check that there has
         * has been a prior process attach notification.
         */
        if ( (dwReason == DLL_PROCESS_DETACH) && (__proc_attached == 0) ) 
            /*
             * no prior process attach notification. just return
             * without doing anything.
             */
            return FALSE;

        if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH )
        {
            if ( _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);

            if ( retcode )
                retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);

            if ( !retcode )
                return FALSE;
        }

        retcode = DllMain(hDllHandle, dwReason, lpreserved);

        if ( (dwReason == DLL_PROCESS_ATTACH) && !retcode )
            /*
             * The user's DllMain routine returned failure, the C runtime
             * needs to be cleaned up. Do this by calling _CRT_INIT again, 
             * this time imitating DLL_PROCESS_DETACH. Note this will also
             * clear the __proc_attached flag so the cleanup will not be 
             * repeated upon receiving the real process detach notification.
             */
            _CRT_INIT(hDllHandle, DLL_PROCESS_DETACH, lpreserved);

        if ( (dwReason == DLL_PROCESS_DETACH) || 
             (dwReason == DLL_THREAD_DETACH) )
        {
            if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE )
                retcode = FALSE ;

            if ( retcode && _pRawDllMain )
                retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);
        }

        return retcode ;
}


/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{
        if ( (__error_mode == _OUT_TO_STDERR) || ((__error_mode ==
               _OUT_TO_DEFAULT) && (__app_type == _CONSOLE_APP)) )
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);      /* write message */
        _aexit_rtn(255);        /* normally _exit(255) */
}


#endif  /* CRTDLL */
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\tidprint.c ===
/***
*tidprint.c - Dislpay thread data
*
*	Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Display the per thread data table.
*
*	[NOTE: This module is NOT included in the C runtime libraries but
*	is maintained for debugging analysis.]
*
*Revision History:
*	11-17-88  JCR	Module created.
*	04-03-89  JCR	Added _stackalloc to tid table
*	06-06-89  JCR	386 version
*	06-09-89  JCR	386: Added values to _tiddata struc (for _beginthread)
*	04-09-90  GJF	Added #include <cruntime.h>. Made the calling type
*			_CALLTYPE1. Also, fixed the copyright.
*	04-10-90  GJF	Removed #include <dos.h>.
*	08-16-90  SBM	Made _terrno and _tdoserrno int, not unsigned
*	10-08-90  GJF	New-style function declarators.
*	10-09-90  GJF	Thread ids are of type unsigned long!
*	12-18-90  GJF	Use real thread id, not thread id - 1.
*	08-01-91  GJF	Adapted for Win32 [_WIN32_].
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	12-07-93  CFW   Rip out Cruiser, add _wasctimebuf.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <mtdll.h>

void __cdecl _print_tiddata(unsigned long);
void __cdecl _print_tiddata1(_ptiddata);

/***
*void _print_tiddata(unsigned long) - Display data for a thread
*
*Purpose:
*	This routine displays the per thread data for a specific, or all,
*	active threads in the _ptd[] table.
*
*Entry:
*	unsigned long = <n> = ID of the thread to display
*		      = -1  = Display thread data for all threads
*
*Exit:
*	<void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _print_tiddata (
	unsigned long tid
	)
{
	int i;			/* loop index */
	int threadcnt;		/* number of active threads */

	/*
	 * lock the _ptd[] table.
	 */
	_mlock(_THREADDATA_LOCK);

	/*
	 * see if caller want's all threads or just a specific one.
	 */
	if (tid == (unsigned long) -1L) {
		/*
		 * caller want's all threads!
		 */
		for ( i = threadcnt = 0 ; i < 1024 ; i++ )
			/*
			 * print out the fields of *_ptd[i] for each entry
			 * bound to an active thread (i.e., for each i st
			 * _ptd[i] non-NULL). also, count up the total number
			 * of active threads.
			 */
			if ( _ptd[i] != NULL ) {
				threadcnt++;
				_print_tiddata1(_ptd[i]);
			}

		printf("\nTHERE ARE %d CURRENTLY ACTIVE THREADS!\n", threadcnt);
	}
	else {
		/*
		 * caller just interested in a particular thread. search
		 * the _ptd[] table inline because a call to _getptd[] would
		 * have unpleasant side effects if tid is not (or no longer)
		 * valid.
		 */
		for ( i = 0 ; (i < 1024) && ((_ptd[i] == NULL) ||
		    (_ptd[i] == (_ptiddata)1L) || (_ptd[i]->_tid != tid)) ;
		    i++ ) ;

		if ( i < 1024 )
			_print_tiddata1(_ptd[i]);
		else
			printf("\nTID INVALID OR THREAD HAS TERMINATED!\n");
	}

	/*
	 * unlock the _ptd[] table.
	 */
	_munlock(_THREADDATA_LOCK);

}


/***
* void _print_tiddata1(_ptiddata ptd) - print out _tiddata structure
*
*Purpose:
*	Given a pointer to a thread data structure, print out its contents
*
*Entry:
*	ptd = pointer to thread's data area
*
*Exit:
*	<void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _print_tiddata1 (
	_ptiddata ptd
	)
{
	printf("\t_tid            = %lu\n",  ptd->_tid );
	printf("\t_thandle        = %lu\n",  ptd->_thandle );
	printf("\t_terrno         = %d\n",   ptd->_terrno);
	printf("\t_tdoserrno      = %d\n",   ptd->_tdoserrno);
	printf("\t_fpds           = %#x\n",  ptd->_fpds);
	printf("\t_holdrand       = %u\n",   ptd->_holdrand);
	printf("\t_token          = %p\n",   ptd->_token);
	printf("\t_errmsg         = %p\n",   ptd->_errmsg);
	printf("\t_namebuf        = %p\n",   ptd->_namebuf);
	printf("\t_asctimebuf     = %p\n",   ptd->_asctimebuf);
	printf("\t_wasctimebuf    = %p\n",   ptd->_wasctimebuf);
	printf("\t_gmtimebuf      = %p\n",   ptd->_gmtimebuf);
	printf("\t_initaddr       = %p\n",   ptd->_initaddr);
	printf("\t_initarg        = %p\n",   ptd->_initarg);
	printf("\t_pxcptacttab    = %p\n",   ptd->_pxcptacttab);
	printf("\t_tpxcptinfoptrs = %p\n",   ptd->_tpxcptinfoptrs);
	printf("\t_tfpecode       = %p\n\n", ptd->_tfpecode);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\stdargv.c ===
/***
*stdargv.c - standard & wildcard _setargv routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line, with or without wildcard expansion
*
*Revision History:
*       06-27-89  PHG   module created, based on asm version
*       04-09-90  GJF   Added #include <cruntime.h>. Made calling types
*                       explicit (_CALLTYPE1 or _CALLTYPE4). Also, fixed the
*                       copyright.
*       06-04-90  GJF   Changed error message interface.
*       08-31-90  GJF   Removed 32 from API names.
*       09-25-90  GJF   Merged tree version with local version (8-31 change
*                       with 6-4 change).
*       10-08-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-25-91  SRW   Include oscalls.h if _WIN32_ OR WILDCARD defined
*       01-25-91  SRW   Changed Win32 Process Startup [_WIN32_]
*       01-25-91  MHL   Fixed bug in Win32 Process Startup [_WIN32_]
*       01-28-91  GJF   Fixed call to DOSFINDFIRST (removed last arg).
*       01-31-91  MHL   Changed to call GetModuleFileName instead of
*                       NtCurrentPeb() [_WIN32_]
*       02-18-91  SRW   Fixed command line parsing bug [_WIN32_]
*       03-11-91  GJF   Fixed check of FindFirstFile return [_WIN32_].
*       03-12-91  SRW   Add FindClose call to _find [_WIN32_]
*       04-16-91  SRW   Fixed quote parsing logic for arguments.
*       03-31-92  DJM   POSIX support.
*       05-12-92  DJM   ifndefed for POSIX.
*       06-02-92  SKS   Add #include <dos.h> for CRTDLL definition of _pgmptr
*       04-19-93  GJF   Change test in the do-while loop in parse_cmdline to
*                       NOT terminate on chars with high bit set.
*       05-14-93  GJF   Added support for quoted program names.
*       05-28-93  KRS   Added MBCS support under _MBCS switches.
*       06-04-93  KRS   Added more MBCS logic.
*       11-17-93  CFW   Rip out Cruiser.
*       11-19-93  CFW   Gratuitous whitespace cleanup.
*       11-20-93  CFW   Enable wide char, move _find to wild.c.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       04-15-94  GJF   Made definition of _pgmname conditional on
*                       DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       06-30-97  GJF   Added explicit, conditional init. of multibyte ctype
*                       table. Also, detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*       09-05-00  GB    Fixed parse_cmdline to return "c:\test\"foo.c as one
*                       argument.
*       09-07-00  GB    Fixed parse_cmdline to del double quotes in
*                       c:"\test\"foo.c.
*       03-24-01  PML   Protect against null _[aw]cmdln (vs7#229081)
*       03-27-01  PML   Return error instead of calling amsg_exit (vs7#231220)
*       03-28-01  PML   Protect against GetModuleFileName overflow (vs7#231284)
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>
#include <dos.h>
#include <oscalls.h>
#ifdef  _MBCS
#include <mbctype.h>
#endif
#include <tchar.h>
#include <dbgint.h>

#define NULCHAR    _T('\0')
#define SPACECHAR  _T(' ')
#define TABCHAR    _T('\t')
#define DQUOTECHAR _T('\"')
#define SLASHCHAR  _T('\\')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#ifdef  WPRFLAG
static void __cdecl wparse_cmdline(wchar_t *cmdstart, wchar_t **argv, wchar_t *args,
        int *numargs, int *numchars);
#else
static void __cdecl parse_cmdline(char *cmdstart, char **argv, char *args,
        int *numargs, int *numchars);
#endif

/***
*_setargv, __setargv - set up "argc" and "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line,
*       pointed to by _acmdln.
*
*Exit:
*       Returns 0 if successful, -1 if memory allocation failed.
*       "argv" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is an argument from the command line.
*       "argc" is the number of arguments.  The strings are copied from
*       the environment segment into space allocated on the heap/stack.
*       The list of pointers is also located on the heap or stack.
*       _pgmptr points to the program name.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

#ifdef  WILDCARD

#ifdef  WPRFLAG
int __cdecl __wsetargv (
#else
int __cdecl __setargv (
#endif  /* WPRFLAG */

#else   /* WILDCARD */

#ifdef  WPRFLAG
int __cdecl _wsetargv (
#else
int __cdecl _setargv (
#endif  /* WPRFLAG */

#endif  /* WILDCARD */
    void
    )
{
        _TSCHAR *p;
        _TSCHAR *cmdstart;                  /* start of command line to parse */
        int numargs, numchars;

        static _TSCHAR _pgmname[ MAX_PATH + 1 ];

#if     !defined(CRTDLL) && defined(_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        /* Get the program name pointer from Win32 Base */

        _pgmname[ MAX_PATH ] = '\0';
        GetModuleFileName( NULL, _pgmname, MAX_PATH );
#ifdef  WPRFLAG
        _wpgmptr = _pgmname;
#else
        _pgmptr = _pgmname;
#endif

        /* if there's no command line at all (won't happen from cmd.exe, but
           possibly another program), then we use _pgmptr as the command line
           to parse, so that argv[0] is initialized to the program name */

#ifdef  WPRFLAG
        cmdstart = (_wcmdln == NULL || *_wcmdln == NULCHAR)
                   ? _wpgmptr : _wcmdln;
#else
        cmdstart = (_acmdln == NULL || *_acmdln == NULCHAR)
                   ? _pgmptr : _acmdln;
#endif

        /* first find out how much space is needed to store args */
#ifdef  WPRFLAG
        wparse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#else
        parse_cmdline(cmdstart, NULL, NULL, &numargs, &numchars);
#endif

        /* allocate space for argv[] vector and strings */
        p = _malloc_crt(numargs * sizeof(_TSCHAR *) + numchars * sizeof(_TSCHAR));
        if (p == NULL)
            return -1;

        /* store args and argv ptrs in just allocated block */

#ifdef  WPRFLAG
        wparse_cmdline(cmdstart, (wchar_t **)p, (wchar_t *)(((char *)p) + numargs * sizeof(wchar_t *)), &numargs, &numchars);
#else
        parse_cmdline(cmdstart, (char **)p, p + numargs * sizeof(char *), &numargs, &numchars);
#endif

        /* set argv and argc */
        __argc = numargs - 1;
#ifdef  WPRFLAG
        __wargv = (wchar_t **)p;
#else
        __argv = (char **)p;
#endif /* WPRFLAG */

#ifdef  WILDCARD

        /* call _[w]cwild to expand wildcards in arg vector */
#ifdef  WPRFLAG
        if (_wcwild())
#else   /* WPRFLAG */
        if (_cwild())
#endif  /* WPRFLAG */
            return -1;                  /* out of space */

#endif  /* WILDCARD */

        return 0;
}


/***
*static void parse_cmdline(cmdstart, argv, args, numargs, numchars)
*
*Purpose:
*       Parses the command line and sets up the argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, args
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only coujting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numchars has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       _TSCHAR *cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       _TSCHAR **argv - where to build argv array; NULL means don't
*                       build array
*       _TSCHAR *args - where to place argument text; NULL means don't
*                       store text
*
*Exit:
*       no return value
*       int *numargs - returns number of argv entries created
*       int *numchars - number of characters used in args buffer
*
*Exceptions:
*
*******************************************************************************/

#ifdef  WPRFLAG
static void __cdecl wparse_cmdline (
#else
static void __cdecl parse_cmdline (
#endif
    _TSCHAR *cmdstart,
    _TSCHAR **argv,
    _TSCHAR *args,
    int *numargs,
    int *numchars
    )
{
        _TSCHAR *p;
        _TUCHAR c;
        int inquote;                    /* 1 = inside quotes */
        int copychar;                   /* 1 = copy char to *args */
        unsigned numslash;              /* num of backslashes seen */

        *numchars = 0;
        *numargs = 1;                   /* the program name at least */

        /* first scan the program name, copy it, and count the bytes */
        p = cmdstart;
        if (argv)
            *argv++ = args;

#ifdef  WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* A quoted program name is handled here. The handling is much
           simpler than for other arguments. Basically, whatever lies
           between the leading double-quote and next one, or a terminal null
           character is simply accepted. Fancier handling is not required
           because the program name must be a legal NTFS/HPFS file name.
           Note that the double-quote characters are not copied, nor do they
           contribute to numchars. */
        inquote = FALSE;
        do {
            if (*p == DQUOTECHAR )
            {
                inquote = !inquote;
                c = (_TUCHAR) *p++;
                continue;
            }
            ++*numchars;
            if (args)
                *args++ = *p;

            c = (_TUCHAR) *p++;
#ifdef  _MBCS
            if (_ismbblead(c)) {
                ++*numchars;
                if (args)
                    *args++ = *p;   /* copy 2nd byte too */
                p++;  /* skip over trail byte */
            }
#endif

        } while ( (c != NULCHAR && (inquote || (c !=SPACECHAR && c != TABCHAR))) );

        if ( c == NULCHAR ) {
            p--;
        } else {
            if (args)
                *(args-1) = NULCHAR;
        }

        inquote = 0;

        /* loop on each argument */
        for(;;) {

            if ( *p ) {
                while (*p == SPACECHAR || *p == TABCHAR)
                    ++p;
            }

            if (*p == NULCHAR)
                break;              /* end of args */

            /* scan an argument */
            if (argv)
                *argv++ = args;     /* store ptr to arg */
            ++*numargs;

#ifdef  WILDCARD
        /* To handle later wild card expansion, we prefix each entry by
        it's first character before quote handling.  This is done
        so _[w]cwild() knows whether to expand an entry or not. */
        if (args)
            *args++ = *p;
        ++*numchars;

#endif  /* WILDCARD */

        /* loop through scanning one argument */
        for (;;) {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == SLASHCHAR) {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == DQUOTECHAR) {
                /* if 2N backslashes before, start/end quote, otherwise
                    copy literally */
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == DQUOTECHAR)
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    } else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--) {
                if (args)
                    *args++ = SLASHCHAR;
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == NULCHAR || (!inquote && (*p == SPACECHAR || *p == TABCHAR)))
                break;

            /* copy character into argument */
#ifdef  _MBCS
            if (copychar) {
                if (args) {
                    if (_ismbblead(*p)) {
                        *args++ = *p++;
                        ++*numchars;
                    }
                    *args++ = *p;
                } else {
                    if (_ismbblead(*p)) {
                        ++p;
                        ++*numchars;
                    }
                }   
                ++*numchars;
            }
            ++p;
#else 
            if (copychar) {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
#endif 
            }

            /* null-terminate the argument */

            if (args)
                *args++ = NULCHAR;          /* terminate string */
            ++*numchars;
        }

        /* We put one last argument in -- a null ptr */
        if (argv)
            *argv++ = NULL;
        ++*numargs;
}


#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\mlock.c ===
/***
*mlock.c - Multi-thread locking routines
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-07-90  JCR   Module created.
*       06-04-90  GJF   Changed error message interface.
*       08-08-90  GJF   Removed 32 from API names.
*       08-08-90  SBM   _lockmap no longer 8 times required size
*       10-08-90  GJF   New-style function declarators. Removed questionable
*                       return statements from void functions (weren't needed
*                       and the compiler was bitching).
*       10-09-90  GJF   Thread ids are unsigned longs.
*       06-06-91  GJF   Adapted for Win32 [_WIN32_].
*       09-29-91  GJF   Fixed infinite recursion problem with DEBUG version
*                       of _lock [_WIN32_].
*       03-06-92  GJF   Removed _[un]lock_fh() and _[un]lock_stream for Win32
*                       targets.
*       05-28-92  GJF   Added _mtdeletelocks() for Win32 for DLLs with contain
*                       the C runtime (e.g., crtdll.dll).
*       10-06-92  SRW   Make _locktable an array of PCRITICAL_SECTION pointers
*                       instead of structures.  Allocate each critical section
*                       as it is needed.
*       02-25-93  GJF   Substantially revised. Restored static critical section
*                       structures for some locks. Replaced bit-array scheme
*                       of keeping track of locks. Removed Cruiser support and
*                       replaced obsolete DEBUG code.
*       03-03-93  GJF   Made CRITICAL_SECTION structure for _HEAP_LOCK static.
*       03-08-93  SKS   Fix ptr use error in DEBUG version of _mtdeletelocks
*       03-08-93  SKS   Fix deletion of the special critical sections,
*                       especially the heap lock.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-05-93  GJF   Turned DEBUG code off.
*       06-03-93  SRW   Disable FPO optimizations for this file so it can call
*                       CriticalSection routines on a checked build even though
*                       the C Runtimes are compiled free.
*       10-19-93  GJF   Merged in NT SDK version. Enclosed #pragma-s in
*                       #ifdef _M_IX86 / #endif. Replaced MTHREAD with _MT.
*       04-12-94  GJF   Made into empty functions for the Win32s version of
*                       msvcrt*.dll.
*       01-10-95  CFW   Debug CRT allocs.
*       01-30-95  GJF   Made CRITICAL_SECTION structure for _SIGNAL_LOCK
*                       static.
*       03-06-95  GJF   Added _[un]lock_file[2] to lock stdio files (__piob[]
*                       entries).
*       03-23-95  BWT   Store the critsec in the locktable *after* it's
*                       initialized.
*       10-03-95  GJF   Added comments to the effect that the _LC_*_LOCK
*                       locks are obsolete.
*       11-15-95  JWM   Correct syntax error in 2nd '#pragma optimize()'.
*       06-19-97  GJF   Moved _[un]lock_file[2]() to stdio\_file.c to improve 
*                       granularity.
*       05-13-99  PML   Remove Win32s
*       10-14-99  PML   Replace InitializeCriticalSection with wrapper function
*                       __crtInitCritSecAndSpinCount
*       12-10-99  GB    Added a new Lock _UNDNAME_LOCK for critical section in
*                       unDName().
*       03-06-00  PML   Call __crtExitProcess instead of ExitProcess.
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       03-07-01  PML   vs7#221122 Release preallocated locks after heap ones,
*                       so _HEAP_LOCK is around while we're still freeing mem.
*       03-22-01  PML   Add _DEBUG_LOCK for _CrtSetReportHook2 (vs7#124998)
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <rterr.h>
#include <stddef.h>
#include <malloc.h>
#include <limits.h>
#include <stdio.h>
#include <dbgint.h>
#include <errno.h>


/*
 * Local routines
 */
void __cdecl _lockerr_exit(char *);


/*
 * Global Data
 */

/*
 * Statically allocated critical section structures for all preallocated locks.
 * These are most of the named locks before _STREAM_LOCKS, along with the locks
 * for stdin/stdout/stderr.  These must be preallocated so we do not hit fatal
 * memory conditions on failing to initialize a critical section, except at
 * runtime startup, since these locks may be taken where we have no good way
 * to return a non-fatal error.
 */
#define NUM_STD_FILE_LOCKS     3
#define NUM_NON_PREALLOC_LOCKS 5
#define NUM_PREALLOC_LOCKS \
        ( _STREAM_LOCKS + NUM_STD_FILE_LOCKS - NUM_NON_PREALLOC_LOCKS )
static CRITICAL_SECTION lclcritsects[NUM_PREALLOC_LOCKS];

/*
 * Lock Table
 * This table contains a pointer to the critical section management structure
 * for each lock.
 *
 * Locks marked lkPrealloc have their critical sections statically allocated
 * and initialized at startup in _mtinitlocks.  Locks marked lkNormal must
 * be allocated when first used, via a call to _mtinitlocknum.
 */
static struct {
        PCRITICAL_SECTION lock;
        enum { lkNormal = 0, lkPrealloc, lkDeleted } kind;
} _locktable[_TOTAL_LOCKS] = {
        { NULL, lkPrealloc }, /* 0  == _SIGNAL_LOCK      */
        { NULL, lkPrealloc }, /* 1  == _IOB_SCAN_LOCK    */
        { NULL, lkNormal   }, /* 2  == _TMPNAM_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 3  == _CONIO_LOCK       */
        { NULL, lkPrealloc }, /* 4  == _HEAP_LOCK        */
        { NULL, lkNormal   }, /* 5  == _UNDNAME_LOCK     - not preallocated */
        { NULL, lkPrealloc }, /* 6  == _TIME_LOCK        */
        { NULL, lkPrealloc }, /* 7  == _ENV_LOCK         */
        { NULL, lkPrealloc }, /* 8  == _EXIT_LOCK1       */
        { NULL, lkNormal   }, /* 9  == _POPEN_LOCK       - not preallocated */
        { NULL, lkPrealloc }, /* 10 == _LOCKTAB_LOCK     */
        { NULL, lkNormal   }, /* 11 == _OSFHND_LOCK      - not preallocated */
        { NULL, lkPrealloc }, /* 12 == _SETLOCALE_LOCK   */
        { NULL, lkPrealloc }, /* 13 == _MB_CP_LOCK       */
        { NULL, lkPrealloc }, /* 14 == _TYPEINFO_LOCK    */
        { NULL, lkNormal   }, /* 15 == _DEBUG_LOCK       - not preallocated */
        { NULL, lkPrealloc }, /* 16 == _STREAM_LOCKS+0 - stdin  */
        { NULL, lkPrealloc }, /* 17 == _STREAM_LOCKS+1 - stdout */
        { NULL, lkPrealloc }, /* 18 == _STREAM_LOCKS+2 - stderr */
/*      { NULL, lkNormal   }, /* ... */
};

#ifndef NT_BUILD
#ifdef  _M_IX86
#pragma optimize("y",off)
#endif
#endif

/***
*_mtinitlocks() - Initialize multi-thread lock scheme
*
*Purpose:
*       Perform whatever initialization is required for the multi-thread
*       locking (synchronization) scheme. This routine should be called
*       exactly once, during startup, and this must be before any requests
*       are made to assert locks.
*
*       NOTES: In Win32, the multi-thread locks are created individually,
*       each upon its first use. That is when any particular lock is asserted
*       for the first time, the underlying critical section is then allocated,
*       initialized and (finally) entered. This allocation and initialization
*       is protected under _LOCKTAB_LOCK. It is _mtinitlocks' job to set up
*       _LOCKTAB_LOCK.
*
*       All other named (non-FILE) locks are also preallocated in _mtinitlocks.
*       That is because a failure to allocate a lock on its first use in _lock
*       triggers a fatal error, which cannot be permitted since that can bring
*       down a long-lived app without warning.
*
*Entry:
*       <none>
*
*Exit:
*       returns FALSE on failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocks (
        void
        )
{
        int locknum;
        int idxPrealloc = 0;

        /*
         * Scan _locktable[] and allocate all entries marked lkPrealloc.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
#ifdef  DEBUG
            if ( _locktable[locknum].lock != NULL )
                _lockerr_exit("fatal error in _mtinitlocks #1\n");
#endif  /* DEBUG */
            if ( _locktable[locknum].kind == lkPrealloc ) {
                _locktable[locknum].lock = &lclcritsects[idxPrealloc++];
                if ( !__crtInitCritSecAndSpinCount( _locktable[locknum].lock,
                                                    _CRT_SPINCOUNT ))
                    return FALSE;
            }
        }

#ifdef  DEBUG
        if ( idxPrealloc != NUM_PREALLOC_LOCKS )
            _lockerr_exit("fatal error in _mtinitlocks #2\n");
#endif  /* DEBUG */

        return TRUE;
}


/***
*_mtdeletelocks() - Delete all initialized locks
*
*Purpose:
*       Walks _locktable[] and _lockmap, and deletes every 'lock' (i.e.,
*       critical section) which has been initialized.
*
*       This function is intended for use in DLLs containing the C runtime
*       (i.e., crtdll.dll and user DLLs built using libcmt.lib and the
*       special startup objects). It is to be called from within the DLL's
*       entrypoint function when that function is called with
*       DLL_PROCESS_DETACH.
*
*Entry:
*       <none>
*
*Exit:
*
*Exceptions:
*       behavior undefined/unknown if a lock is being held when this routine
*       is called.
*
*******************************************************************************/

void __cdecl _mtdeletelocks(
        void
        )
{
        int locknum;

        /*
         * Delete and free all normal locks that have been created.
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind != lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);

                /*
                 * Free the memory for the CritSect after deleting it.
                 */
#ifdef  DEBUG
                /* check that it's an undeleted normal lock */
                if ( _locktable[locknum].kind != lkNormal )
                    _lockerr_exit("fatal error in _mtdeletelocks #1\n");

                /* mark as deleted */
                _locktable[locknum].kind = lkDeleted;
#endif  /* DEBUG */

                _free_crt(pcs);
                _locktable[locknum].lock = NULL;
            }
        }

        /*
         * Delete all preallocated locks after all normal ones are
         * freed (so preallocated _HEAP_LOCK outlives all heap usages).
         */
        for ( locknum = 0 ; locknum < _TOTAL_LOCKS ; locknum++ ) {
            if ( _locktable[locknum].lock != NULL &&
                 _locktable[locknum].kind == lkPrealloc )
            {
                PCRITICAL_SECTION pcs = _locktable[locknum].lock;

                DeleteCriticalSection(pcs);
            }
        }
}

/***
* _mtinitlocknum - Allocate a non-preallocated multi-thread lock
*
*Purpose:
*       Allocate a new, non-preallocated multi-thread lock.  This should be
*       used whenever a new lock is known to be needed, so that failure to
*       allocate can return an error, instead of allowing _lock() to issue
*       a fatal _RT_LOCK instead.
*
*       It is not an error to call this on a normal lock which has already
*       been allocated.  It is used to ensure that certain named locks which
*       are not preallocated are available.
*
*       It is also called by _lock, in case any other paths exist which call
*       _lock without calling _mtinitlocknum first.  This is not expected,
*       and can allow fatal _RT_LOCK errors to be issued.
*
*       Since a failure sets errno to ENOMEM, this should only be called
*       after the per-thread data has been set up (after _mtinit).
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*       Returns FALSE on failure, and sets errno to ENOMEM.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _mtinitlocknum (
        int locknum
        )
{
        PCRITICAL_SECTION pcs;

#ifdef  DEBUG
        if ( _locktable[locknum].kind != lkNormal )
            _lockerr_exit("fatal error in _mtinitlocknum #1\n");
#endif  /* DEBUG */

        if ( _locktable[locknum].lock != NULL )
            return TRUE;

        if ( (pcs = _malloc_crt(sizeof(CRITICAL_SECTION))) == NULL ) {
            errno = ENOMEM;
            return FALSE;
        }

        _mlock(_LOCKTAB_LOCK);

        if ( _locktable[locknum].lock == NULL ) {
            if ( !__crtInitCritSecAndSpinCount(pcs, _CRT_SPINCOUNT) ) {
                _free_crt(pcs);
                _munlock(_LOCKTAB_LOCK);
                errno = ENOMEM;
                return FALSE;
            }
            _locktable[locknum].lock = pcs;
        }
        else {
            _free_crt(pcs);
        }

        _munlock(_LOCKTAB_LOCK);

        return TRUE;
}


/***
* _lock - Acquire a multi-thread lock
*
*Purpose:
*       Acquire a multi-thread lock.  If the lock has not already been
*       allocated, do so, but that is an internal CRT error, since all locks
*       should be allocated before first being acquired, either in
*       _mtinitlocks or individually in _mtinitlocknum.
*
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to aquire
*
*Exit:
*
*Exceptions:
*       A failure to allocate a new lock results in a fatal _RT_LOCK error.
*
*******************************************************************************/

void __cdecl _lock (
        int locknum
        )
{
#ifdef  DEBUG
        if ( _locktable[locknum].kind != lkNormal &&
             _locktable[locknum].kind != lkPrealloc )
            _lockerr_exit("fatal error in _lock #1\n");
#endif  /* DEBUG */

        /*
         * Create/open the lock, if necessary
         */
        if ( _locktable[locknum].lock == NULL ) {
#ifdef  DEBUG
            if ( _locktable[locknum].kind != lkNormal )
                _lockerr_exit("fatal error in _lock #2\n");

            /*
             * All locks should be allocated before first being acquired.
             * Failure to do so is an internal CRT error, which we silently
             * allow in a production CRT, but that can lead to fatal _RT_LOCK
             * errors which result in an ExitProcess call.
             */
            _lockerr_exit("fatal error in _lock #3\n");
#endif  /* DEBUG */

            if ( !_mtinitlocknum(locknum) )
                _amsg_exit( _RT_LOCK );
        }

        /*
         * Enter the critical section.
         */

        EnterCriticalSection( _locktable[locknum].lock );
}


/***
* _unlock - Release multi-thread lock
*
*Purpose:
*       Note that it is legal for a thread to aquire _EXIT_LOCK1
*       multiple times.
*
*Entry:
*       locknum = number of the lock to release
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock (
        int locknum
        )
{
        /*
         * leave the critical section.
         */
        LeaveCriticalSection( _locktable[locknum].lock );
}


#ifndef NT_BUILD
#ifdef  _M_IX86
#pragma optimize("y",on)
#endif
#endif

/***
*_lockerr_exit() - Write error message and die
*
*Purpose:
*       Attempt to write out the unexpected lock error message, then terminate
*       the program by a direct API call.  This function is used in place of
*       amsg_exit(_RT_LOCK) when it is judged unsafe to allow further lock
*       or unlock calls.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockerr_exit (
        char *msg
        )
{
#ifdef _XBOX
        OutputDebugStringA(msg);
        _exit(255);
#else
        FatalAppExit(0, msg);       /* Die with message box */
        __crtExitProcess(255);      /* Just die */
#endif // XBOX
}


#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\thread.c ===
/***
*thread.c - Begin and end a thread
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This source contains the _beginthread() and _endthread()
*       routines which are used to start and terminate a thread.
*
*Revision History:
*       05-09-90  JCR   Translated from ASM to C
*       07-25-90  SBM   Removed '32' from API names
*       10-08-90  GJF   New-style function declarators.
*       10-09-90  GJF   Thread ids are of type unsigned long.
*       10-19-90  GJF   Added code to set _stkhqq properly in stub().
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       06-03-91  GJF   Win32 version [_WIN32_].
*       07-18-91  GJF   Fixed many silly errors [_WIN32_].
*       08-19-91  GJF   Allow for newly created thread terminating before
*                       _beginthread returns
*       09-30-91  GJF   Add per-thread initialization and termination calls
*                       for floating point.
*       01-18-92  GJF   Revised try - except statement.
*       02-25-92  GJF   Initialize _holdrand field to 1.
*       09-30-92  SRW   Add WINAPI keyword to _threadstart routine
*       10-30-92  GJF   Error ret for CreateThread is 0 (NULL), not -1.
*       02-13-93  GJF   Revised to use TLS API. Also, purged Cruiser support.
*       03-26-93  GJF   Fixed horribly embarrassing bug: ptd->pxcptacttab
*                       must be initialized to _XcptActTab!
*       04-01-93  CFW   Change try-except to __try-__except
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  GJF   Removed support for _RT_STACK, _RT_INTDIV,
*                       _RT_INVALDISP and _RT_NONCONT.
*       10-26-93  GJF   Replaced PF with _PVFV (defined in internal.h).
*       12-13-93  SKS   Free up per-thread data using a call to _freeptd()
*       01-06-94  GJF   Free up _tiddata struct upon failure in _beginthread.
*                       Also, set errno on failure.
*       01-10-95  CFW   Debug CRT allocs.
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       05-02-95  SKS   Call _initptd for initialization of per-thread data.
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       02-02-00  GB    Modified threadstart() to prevent leaking of ptd
*                       allocated during call to getptd while ATTACHing THREAD 
*                       in dlls.
*       08-04-00  PML   Set EINVAL error if thread start address null in
*                       _beginthread (VS7#118688).
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <malloc.h>
#include <process.h>
#include <stddef.h>
#include <rterr.h>
#include <dbgint.h>
#include <errno.h>

/*
 * Startup code for new thread.
 */
static unsigned long WINAPI _threadstart(void *);

/*
 * declare pointers to per-thread FP initialization and termination routines
 */
_PVFV _FPmtinit;
_PVFV _FPmtterm;


/***
*_beginthread() - Create a child thread
*
*Purpose:
*       Create a child thread.
*
*Entry:
*       initialcode = pointer to thread's startup code address
*       stacksize = size of stack
*       argument = argument to be passed to new thread
*
*Exit:
*       success = handle for new thread if successful
*
*       failure = (unsigned long) -1L in case of error, errno and _doserrno
*                 are set
*
*Exceptions:
*
*******************************************************************************/

uintptr_t __cdecl _beginthread (
        void (__cdecl * initialcode) (void *),
        unsigned stacksize,
        void * argument
        )
{
        _ptiddata ptd;                  /* pointer to per-thread data */
        uintptr_t thdl;                 /* thread handle */
        unsigned long errcode = 0L;     /* Return from GetLastError() */

        if ( initialcode == NULL ) {
            errno = EINVAL;
            return( (uintptr_t)(-1) );
        }

        /*
         * Allocate and initialize a per-thread data structure for the to-
         * be-created thread.
         */
        if ( (ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL )
                goto error_return;

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_initaddr = (void *) initialcode;
        ptd->_initarg = argument;

        /*
         * Create the new thread. Bring it up in a suspended state so that
         * the _thandle and _tid fields are filled in before execution
         * starts.
         */
        if ( (ptd->_thandle = thdl = (uintptr_t)
              CreateThread( NULL,
                            stacksize,
                            _threadstart,
                            (LPVOID)ptd,
                            CREATE_SUSPENDED,
                            (LPDWORD)&(ptd->_tid) ))
             == (uintptr_t)0 )
        {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Start the new thread executing
         */
        if ( ResumeThread( (HANDLE)thdl ) == (DWORD)(-1) ) {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Good return
         */
        return(thdl);

        /*
         * Error return
         */
error_return:
        /*
         * Either ptd is NULL, or it points to the no-longer-necessary block
         * calloc-ed for the _tiddata struct which should now be freed up.
         */
        _free_crt(ptd);

        /*
         * Map the error, if necessary.
         */
        if ( errcode != 0L )
                _dosmaperr(errcode);

        return( (uintptr_t)(-1) );
}


/***
*_threadstart() - New thread begins here
*
*Purpose:
*       The new thread begins execution here.  This routine, in turn,
*       passes control to the user's code.
*
*Entry:
*       void *ptd       = pointer to _tiddata structure for this thread
*
*Exit:
*       Never returns - terminates thread!
*
*Exceptions:
*
*******************************************************************************/

static unsigned long WINAPI _threadstart (
        void * ptd
        )
{
        _ptiddata _ptd;                  /* pointer to per-thread data */
        
        /* 
         * Check if ptd is initialised during THREAD_ATTACH call to dll mains
         */
#ifdef _XBOX
        if ( (_ptd = __ptd_cur) == NULL)
            __ptd_cur = ptd;
#else
        if ( (_ptd = TlsGetValue(__tlsindex)) == NULL)
        {
            /*
             * Stash the pointer to the per-thread data stucture in TLS
             */
            if ( !TlsSetValue(__tlsindex, ptd) )
                _amsg_exit(_RT_THREAD);
        }
#endif // XBOX
        else
        {
            _ptd->_initaddr = ((_ptiddata) ptd)->_initaddr;
            _ptd->_initarg =  ((_ptiddata) ptd)->_initarg;
            _ptd->_thandle =  ((_ptiddata) ptd)->_thandle;
            _free_crt(ptd);
            ptd = _ptd;
        }

#ifndef _XBOX
        /*
         * Call fp initialization, if necessary
         */
        if ( _FPmtinit != NULL )
                (*_FPmtinit)();
#endif

        /*
         * Guard call to user code with a _try - _except statement to
         * implement runtime errors and signal support
         */
        __try {
                ( (void(__cdecl *)(void *))(((_ptiddata)ptd)->_initaddr) )
                    ( ((_ptiddata)ptd)->_initarg );

                _endthread();
        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
                /*
                 * Should never reach here
                 */
                _exit( GetExceptionCode() );

        } /* end of _try - _except */

        /*
         * Never executed!
         */
        return(0L);
}


/***
*_endthread() - Terminate the calling thread
*
*Purpose:
*
*Entry:
*       void
*
*Exit:
*       Never returns!
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _endthread (
        void
        )
{
        _ptiddata ptd;           /* pointer to thread's _tiddata struct */

#ifndef _XBOX
        /*
         * Call fp termination, if necessary
         */
        if ( _FPmtterm != NULL )
                (*_FPmtterm)();
#endif // XBOX

        if ( (ptd = _getptd()) == NULL )
                _amsg_exit(_RT_THREAD);

        /*
         * Close the thread handle (if there was one)
         */
        if ( ptd->_thandle != (uintptr_t)(-1) )
                (void) CloseHandle( (HANDLE)(ptd->_thandle) );

#ifndef _XBOX
        /*
         * Free up the _tiddata structure & its subordinate buffers
         *      _freeptd() will also clear the value for this thread
         *      of the TLS variable __tlsindex.
         */
        _freeptd(ptd);
#endif // XBOX

        /*
         * Terminate the thread
         */
        ExitThread(0);

}

#ifdef _XBOX

/***
*_mtxthreadnotification() - Xapi Thread Notification Function
*
*Purpose:
*
*Entry:
*   fCreate - TRUE if thread is being created
*
*Exit:
*   void
*
*Exceptions:
*
*******************************************************************************/

void __stdcall _mtxthreadnotification (
    int fCreate
    )
{
    if ( fCreate )
    {
        /*
         * Call fp initialization, if necessary
         */
        if ( _FPmtinit != NULL )
            (*_FPmtinit)();
    }
    else
    {
        /*
         * Call fp termination, if necessary
         */
        if ( _FPmtterm != NULL )
            (*_FPmtterm)();

        /*
         * Free up the _tiddata structure & its subordinate buffers
         *   _freeptd() will also clear the value for this thread
         *   of the TLS variable __tlsindex.
         */
        _freeptd(NULL);
    }
}

#endif // _XBOX

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\stdenvp.c ===
/***
*stdenvp.c - standard _setenvp routine
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module is called by the C start-up routine to set up "_environ".
*       Its sets up an array of pointers to strings in the environment.
*       The global symbol "_environ" is set to point to this array.
*
*Revision History:
*       11-07-84  GFW   initial version
*       01-08-86  SKS   Modified for OS/2
*       05-21-86  SKS   Call _stdalloc to get memory for strings
*       09-04-86  SKS   Added check to skip the "*C_FILE_INFO" string
*       10-21-86  SKS   Improved check for "*C_FILE_INFO"/"_C_FILE_INFO"
*       02-19-88  SKS   Handle case where environment starts with a single null
*       05-10-88  JCR   Modified code to accept far pointer from _stdalloc
*       06-01-88  PHG   Merged DLL and normal versions
*       07-12-88  JCR   Largely re-written: (1) split mem allocation into two
*                       seperate malloc() calls to help simplify putenv(),
*                       (2) stdalloc() no longer robs from stack, (3) cProc/cEnd
*                       sequence, (4) misc cleanup
*       09-20-88  WAJ   Initial 386 version
*       12-13-88  JCR   Use rterr.inc parameters for runtime errors
*       04-09-90  GJF   Added #include <cruntime.h>. Made the calling type
*                       _CALLTYPE1. Also, fixed the copyright and cleaned up
*                       up the formatting a bit.
*       06-05-90  GJF   Changed error message interface.
*       10-08-90  GJF   New-style function declarator.
*       10-31-90  GJF   Fixed statement appending the final NULL (Stevewo
*                       found the bug).
*       12-11-90  SRW   Changed to include <oscalls.h> and setup _environ
*                       correctly for Win32
*       01-21-91  GJF   ANSI naming.
*       02-07-91  SRW   Change _WIN32_ specific code to allocate static copy
*       02-18-91  SRW   Change _WIN32_ specific code to allocate copy of
*                       variable strings as well [_WIN32_]
*       07-25-91  GJF   Changed strupr to _strupr.
*       03-31-92  DJM   POSIX support.
*       04-20-92  GJF   Removed conversion to upper-case code for Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-24-93  CFW   Rip out Cruiser and filter out "=c:\foo" type.
*       11-29-93  CFW   Remove unused POSIX stuff, wide char enable.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       01-10-95  CFW   Debug CRT allocs.
*       04-07-95  CFW   Free environment block on demand.
*       07-03-95  GJF   Always free environment block.
*       02-20-96  SKS   Set _aenvptr/_wenvptr to NULL after freeing what it
*                       points to (a copy of environment strings).
*       06-30-97  GJF   Added explicit, conditional init. of the mbctype table.
*                       Set __env_initialized flag. Also detab-ed.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       03-05-01  PML   Don't AV if _aenvptr is NULL (vs7#174755).
*       03-27-01  PML   Return error instead of calling amsg_exit (vs7#231220)
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <rterr.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

#ifndef CRTDLL

#ifdef  _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

#endif

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif

/***
*_setenvp - set up "envp" for C programs
*
*Purpose:
*       Reads the environment and build the envp array for C programs.
*
*Entry:
*       The environment strings occur at _aenvptr.
*       The list of environment strings is terminated by an extra null
*       byte.  Thus two null bytes in a row indicate the end of the
*       last environment string and the end of the environment, resp.
*
*Exit:
*       "environ" points to a null-terminated list of pointers to ASCIZ
*       strings, each of which is of the form "VAR=VALUE".  The strings
*       are copied from the environment area. This array of pointers will
*       be malloc'ed.  The block pointed to by _aenvptr is deallocated.
*
*Uses:
*       Allocates space on the heap for the environment pointers.
*
*Exceptions:
*       If space cannot be allocated, program is terminated.
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wsetenvp (
#else
int __cdecl _setenvp (
#endif
        void
        )
{
        _TSCHAR *p;
        _TSCHAR **env;              /* _environ ptr traversal pointer */
        int numstrings;             /* number of environment strings */
        int cchars;

#if     !defined(CRTDLL) && defined(_MBCS)
        /* If necessary, initialize the multibyte ctype table. */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        numstrings = 0;

#ifdef WPRFLAG
        p = _wenvptr;
#else
        p = _aenvptr;
#endif

        /*
         * We called __crtGetEnvironmentStrings[AW] just before this,
         * so if _[aw]envptr is NULL, we failed to get the environment.
         * Return an error.
         */
        if (p == NULL)
            return -1;

        /*
         * NOTE: starting with single null indicates no environ.
         * Count the number of strings. Skip drive letter settings
         * ("=C:=C:\foo" type) by skipping all environment variables
         * that begin with '=' character.
         */

        while (*p != _T('\0')) {
            /* don't count "=..." type */
            if (*p != _T('='))
                ++numstrings;
            p += _tcslen(p) + 1;
        }

        /* need pointer for each string, plus one null ptr at end */
        if ( (_tenviron = env = (_TSCHAR **)
            _malloc_crt((numstrings+1) * sizeof(_TSCHAR *))) == NULL )
            return -1;

        /* copy strings to malloc'd memory and save pointers in _environ */
#ifdef WPRFLAG
        for ( p = _wenvptr ; *p != L'\0' ; p += cchars )
#else
        for ( p = _aenvptr ; *p != '\0' ; p += cchars )
#endif
        {
            cchars = (int)_tcslen(p) + 1;
            /* don't copy "=..." type */
            if (*p != _T('=')) {
                if ( (*env = (_TSCHAR *)_malloc_crt(cchars * sizeof(_TSCHAR))) 
                     == NULL )
                {
                    _free_crt(_tenviron);
                    _tenviron = NULL;
                    return -1;
                }
                _tcscpy(*env, p);
                env++;
            }
        }

#ifdef WPRFLAG
        _free_crt(_wenvptr);
        _wenvptr = NULL;
#else
        _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif

        /* and a final NULL pointer */
        *env = NULL;

#ifndef CRTDLL
        /*
         * Set flag for getenv() and _putenv() to know the environment
         * has been set up.
         */
        __env_initialized = 1;
#endif

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\tidtable.c ===
/***
*tidtable.c - Access thread data table
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the following routines for multi-thread
*       data support:
*
*       _mtinit     = Initialize the mthread data
*       _getptd     = get the pointer to the per-thread data structure for
*                       the current thread
*       _freeptd    = free up a per-thread data structure and its
*                       subordinate structures
*       __threadid  = return thread ID for the current thread
*       __threadhandle = return pseudo-handle for the current thread
*
*Revision History:
*       05-04-90  JCR   Translated from ASM to C for portable 32-bit OS/2
*       06-04-90  GJF   Changed error message interface.
*       07-02-90  GJF   Changed __threadid() for DCR 1024/2012.
*       08-08-90  GJF   Removed 32 from API names.
*       10-08-90  GJF   New-style function declarators.
*       10-09-90  GJF   Thread ids are of type unsigned long! Also, fixed a
*                       bug in __threadid().
*       10-22-90  GJF   Another bug in __threadid().
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-31-91  GJF   Win32 version [_WIN32_].
*       07-18-91  GJF   Fixed many silly errors [_WIN32_].
*       09-29-91  GJF   Conditionally added _getptd_lk/_getptd1_lk so that
*                       DEBUG version of mlock doesn't infinitely recurse
*                       the first time _THREADDATA_LOCK is asserted [_WIN32_].
*       01-30-92  GJF   Must init. _pxcptacttab field to _XcptActTab.
*       02-25-92  GJF   Initialize _holdrand field to 1.
*       02-13-93  GJF   Revised to use TLS API. Also, purged Cruiser support.
*       03-26-93  GJF   Initialize ptd->_holdrand to 1L (see thread.c).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-13-93  SKS   Add _mtterm to do multi-thread termination
*                       Set freed __tlsindex to -1 again to prevent mis-use
*       04-26-93  SKS   _mtinit now returns 0 or 1, no longer calls _amsg_exit
*       12-13-93  SKS   Add _freeptd(), which frees up the per-thread data
*                       maintained by the C run-time library.
*       04-12-94  GJF   Made definition of __tlsindex conditional on ndef
*                       DLL_FOR_WIN32S. Also, replaced MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       04-12-95  DAK   Added NT kernel support for C++ exceptions
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       04-25-95  DAK   More Kernel EH support
*       05-02-95  SKS   add _initptd() to do initialization of per-thread data
*       05-24-95  CFW   Add _defnewh.
*       06-12-95  JWM   _getptd() now preserves LastError.
*       01-17-97  GJF   _freeptd() must free the thread's copy of the
*                       exception-action table.
*       09-26-97  BWT   Fix NTSUBSET
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       04-27-98  GJF   Added support for per-thread mbc information.
*       07-28-98  JWM   Initialize __pceh (new per-thread data for comerr support).
*       09-03-98  GJF   Added support for per-thread locale information.
*       12-04-98  JWM   Pulled all comerr support.
*       12-08-98  GJF   In _freeptd, fixed several errors in cleaning up the 
*                       threadlocinfo.
*       12-18-98  GJF   Fixed one more error in _freeptd.
*       01-18-99  GJF   Take care not to free up __ptlocinfo when a thread 
*                       exits.
*       03-16-99  GJF   threadlocinfo incorporates more reference counters
*       04-24-99  PML   Added __lconv_intl_refcount
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       11-03-99  RDL   Win64 _NTSUBSET_ warning fix.
*       06-08-00  PML   No need to keep per-thread mbcinfo in circular linked
*                       list.  Also, don't free mbcinfo if it's also the global
*                       info (vs7#118174).
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*
*******************************************************************************/

#if defined(_MT) || defined(_NTSUBSET_)

# if defined(_NTSUBSET_) || defined(_XBOX)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <ntos.h>
#ifndef _XBOX
#include <fsrtl.h>
#endif

# endif /* _NTSUBSET_ */

#include <sect_attribs.h>
#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <memory.h>
#include <msdos.h>
#include <rterr.h>
#include <stdlib.h>
#include <stddef.h>
#include <dbgint.h>

#ifdef  _MT
extern pthreadmbcinfo __ptmbcinfo;

#ifndef _XBOX
extern threadlocinfo __initiallocinfo;
extern pthreadlocinfo __ptlocinfo;

void __cdecl __freetlocinfo(pthreadlocinfo);
#endif // XBOX
#endif

#ifndef _XBOX
unsigned long __tlsindex = 0xffffffff;
#endif

#if !defined(_NTSUBSET_) && defined(_XBOX)
__declspec(thread) _ptiddata __ptd_cur;
_ptiddata __ptd_glob;
static XTHREAD_NOTIFICATION g_XThreadNotification;
#endif // !defined(_NTSUBSET_) && defined(_XBOX)

#if defined(_NTSUBSET_)

#define BEGIN_NONPAGED_CODE code_seg(".text")
#define END_NONPAGED_CODE   code_seg("PAGE")

static _ptiddata   pTheKernelExceptionContextPool;
static KSPIN_LOCK  TheKernelExceptionContextPoolLock;

/****
*_initKernelExceptionContextPool() - creates kernel-mode exception context pool
*
*Purpose:
*   (1) Initializes spin-lock used to serialize access to pool
*
*Entry:
*   <NONE>
*Exit:
*   <NONE>
*
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
void __cdecl _initKernelExceptionContextPool(void)
{
    KeInitializeSpinLock( &TheKernelExceptionContextPoolLock );
}
#pragma END_NONPAGED_CODE


/****
*  Tell the linker to insert a call to this function into the CRT runtime
*  startup.
*
*  The segment .CRT$XCA is the first data segment bounding the array
*  of CRT startup functions.  We therefore insert our function between
*  the first (.CRT$XCA) and the last (.CRT$XCZ).
*
*******************************************************************************/
#pragma data_seg(".CRT$XCAA")
typedef void (__cdecl *PFStartup)(void);
_CRTALLOC(".CRT$XCAA") PFStartup _KernelECPool = _initKernelExceptionContextPool;
#pragma data_seg(".CRT$XCZ")

#pragma data_seg()


/****
*_emptyKernelExceptionContextPool() - empties kernel-mode exception context pool
*
*Purpose:
*   (1) Deletes all entries in the pool
*
*Entry:
*   <NONE>
*Exit:
*   <NONE>
*
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
void _emptyKernelExceptionContextPool()
{
        while ( pTheKernelExceptionContextPool != 0 ) {
            _ptiddata ptd = pTheKernelExceptionContextPool;
            pTheKernelExceptionContextPool = pTheKernelExceptionContextPool->_next;

            ExFreePool( ptd );
        }
}
#pragma END_NONPAGED_CODE


/****
*_newKernelTid() - Creates, initializes and sets the current thread's
* OfsChain to _tiddata;
*
*Purpose:
*   (1) Creates a new kernel-mode _tiddata
*   (2) Initializes fields in new _tiddata
*   (3) Sets current thread's OfsChain to new _tiddata
*
*   NOTES:
*   (1) Can not fail; the memory allocation will cause a fatal system
*       trap if memory can not be allocated
*
*Entry:
*   <NONE>
*Exit:
*   _ptiddata
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
static _ptiddata _newKernelTid(void)
{
        /*
         * Pop an entry from the pool of _ptiddata's
         */

        _ptiddata ptd;
        PSINGLE_LIST_ENTRY entry;

        entry = ExInterlockedPopEntryList((PSINGLE_LIST_ENTRY) & pTheKernelExceptionContextPool,
                                                               & TheKernelExceptionContextPoolLock );

        /*
         *  If none are available, create a new one.
         */

        if ( 0 == entry ) {
#ifdef _XBOX
            ptd = ExAllocatePoolWithTag(
#else
            ptd = FsRtlAllocatePoolWithTag( NonPagedPoolMustSucceed,
#endif // XBOX
                                          sizeof(struct _tiddata),
                                          ' dtp' );

        } else {
            ptd = CONTAINING_RECORD( entry, struct _tiddata, _next );
        }

#ifdef _XBOX
        if(!ptd)
            KeBugCheck(MUST_SUCCEED_POOL_EMPTY);
        ptd->_tid          = (unsigned long) (uintptr_t) PsGetCurrentThread()->UniqueThread;
#else // XBOX
        ptd->_tid          = (unsigned long) (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread;
#endif // XBOX
        ptd->_terminate    = 0;
        ptd->_unexpected   = 0;
        ptd->_translator   = SystemExceptionTranslator;
        ptd->_curexception = 0;
        ptd->_curcontext   = 0;

#ifndef _XBOX
        PsGetCurrentThread()->OfsChain = ptd;
#endif // XBOX

        return ptd;
}
#pragma END_NONPAGED_CODE


/****
*_freeKernelTid() - appends the _tiddata to the pool
*
*Entry:
*   _ptiddata
*Exit:
*
*******************************************************************************/
#pragma BEGIN_NONPAGED_CODE
static void _freeKernelTid(_ptiddata ptd)
{
        /*
         *  Return the entry to the kernel pool
         */
        ExInterlockedPushEntryList( (PSINGLE_LIST_ENTRY) &pTheKernelExceptionContextPool,
                                (PSINGLE_LIST_ENTRY) &ptd->_next,
                                &TheKernelExceptionContextPoolLock );
}
#pragma END_NONPAGED_CODE
#endif /* _NTSUBSET_ */

/****
*_mtinit() - Init multi-thread data bases
*
*Purpose:
*       (1) Call _mtinitlocks to create/open all lock semaphores.
*       (2) Allocate a TLS index to hold pointers to per-thread data
*           structure.
*
*       NOTES:
*       (1) Only to be called ONCE at startup
*       (2) Must be called BEFORE any mthread requests are made
*
*Entry:
*       <NONE>
*Exit:
*       returns FALSE on failure
*
*Uses:
*       <any registers may be modified at init time>
*
*Exceptions:
*
*******************************************************************************/
#if defined(_NTSUBSET_)
#pragma BEGIN_NONPAGED_CODE
#endif

int __cdecl _mtinit (
        void
        )
{
        _ptiddata ptd;

#if defined(_NTSUBSET_)
        ptd = _newKernelTid();
#else

        /*
         * Initialize the mthread lock data base
         */

        if ( !_mtinitlocks() )
            return FALSE;       /* fail to load DLL */

#ifdef _XBOX
        if ( ((__ptd_cur = ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL))
#else
        /*
         * Allocate a TLS index to maintain pointers to per-thread data
         */
        if ( (__tlsindex = TlsAlloc()) == 0xffffffff )
            return FALSE;       /* fail to load DLL */

        /*
         * Create a per-thread data structure for this (i.e., the startup)
         * thread.
         */
        if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL) ||
             !TlsSetValue(__tlsindex, (LPVOID)ptd) )
#endif // XBOX
            return FALSE;       /* fail to load DLL */

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_tid = GetCurrentThreadId();
        ptd->_thandle = (uintptr_t)(-1);

#ifdef _XBOX
        g_XThreadNotification.pfnNotifyRoutine = _mtxthreadnotification;
        XRegisterThreadNotifyRoutine(&g_XThreadNotification, TRUE);
#endif // XBOX

#endif /* _NTSUBSET_ */

#ifdef _XBOX
        return 0;
#else
        return TRUE;
#endif
}


/****
*_mtterm() - Clean-up multi-thread data bases
*
*Purpose:
*       (1) Call _mtdeletelocks to free up all lock semaphores.
*       (2) Free up the TLS index used to hold pointers to
*           per-thread data structure.
*
*       NOTES:
*       (1) Only to be called ONCE at termination
*       (2) Must be called AFTER all mthread requests are made
*
*Entry:
*       <NONE>
*Exit:
*       returns
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _mtterm (
        void
        )
{

#if defined(_NTSUBSET_)

        _freeKernelTid( PsGetCurrentThread()->OfsChain );
        PsGetCurrentThread()->OfsChain = 0;

#else   /* _NTSUBSET_ */

        /*
         * Clean up the mthread lock data base
         */

        _mtdeletelocks();

#ifndef _XBOX
        /*
         * Free up the TLS index
         *
         * (Set the variable __tlsindex back to the unused state (-1L).)
         */

        if ( __tlsindex != 0xffffffff ) {
            TlsFree(__tlsindex);
            __tlsindex = 0xffffffff;
        }
#endif // XBOX
#endif  /* _NTSUBSET_ */
}



#if !defined(_NTSUBSET_)

/***
*void _initptd(_ptiddata ptd) - initialize a per-thread data structure
*
*Purpose:
*       This routine handles all of the per-thread initialization
*       which is common to _beginthread, _beginthreadex, _mtinit
*       and _getptd.
*
*Entry:
*       pointer to a per-thread data block
*
*Exit:
*       the common fields in that block are initialized
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _initptd (
        _ptiddata ptd
        )
{
        ptd->_pxcptacttab = (void *)_XcptActTab;
        ptd->_holdrand = 1L;
#ifdef ANSI_NEW_HANDLER
        ptd->_newh = _defnewh;
#endif /* ANSI_NEW_HANDLER */

#ifdef _M_MRX000
        /*
         * MIPS per-thread data
         */
        ptd->_MipsPtdDelta =
        ptd->_MipsPtdEpsilon = -1L ;
#endif
}

#endif      /* _NTSUBSET_ */


/***
*_ptiddata _getptd(void) - get per-thread data structure for the current thread
*
*Purpose:
*
*Entry:
*       unsigned long tid
*
*Exit:
*       success = pointer to _tiddata structure for the thread
*       failure = fatal runtime exit
*
*Exceptions:
*
*******************************************************************************/

_ptiddata __cdecl _getptd (
        void
        )
{
        _ptiddata ptd;
        DWORD   TL_LastError;

#if defined(_NTSUBSET_)
        ptd = PsGetCurrentThread()->OfsChain;

        if ( ptd == 0 ) {
            ptd = _newKernelTid();
        }
#else   /* _NTSUBSET_ */

#ifdef _XBOX
        _ptiddata *pptd;
        if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
            KeBugCheck(IRQL_NOT_LESS_OR_EQUAL);
        pptd = KeGetCurrentThread()->TlsData ?
            &__ptd_cur : &__ptd_glob;
        if( (ptd = *pptd) == NULL)
#else
        TL_LastError = GetLastError();
        if ( (ptd = TlsGetValue(__tlsindex)) == NULL )
#endif // XBOX
        {
            /*
             * no per-thread data structure for this thread. try to create
             * one.
             */
            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL)
#ifndef _XBOX
                && TlsSetValue(__tlsindex, (LPVOID)ptd)
#endif
                )
            {

                /*
                 * Initialize of per-thread data
                 */
#ifdef _XBOX
                *pptd = ptd;
#endif

                _initptd(ptd);

                ptd->_tid = GetCurrentThreadId();
                ptd->_thandle = (uintptr_t)(-1);
            }
            else
                _amsg_exit(_RT_THREAD); /* write message and die */
            }

#ifndef _XBOX
        SetLastError(TL_LastError);
#endif

#endif  /* _NTSUBSET_ */

        return(ptd);
}


/***
*void _freeptd(_ptiddata) - free up a per-thread data structure
*
*Purpose:
*       Called from _endthread and from a DLL thread detach handler,
*       this routine frees up the per-thread buffer associated with a
*       thread that is going away.  The tiddata structure itself is
*       freed, but not until its subordinate buffers are freed.
*
*Entry:
*       pointer to a per-thread data block (malloc-ed memory)
*       If NULL, the pointer for the current thread is fetched.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _freeptd (
        _ptiddata ptd
        )
{

#if defined(_NTSUBSET_)

        if ( 0 == ptd ) {
            ptd = PsGetCurrentThread()->OfsChain;
        } else {
            ASSERT( ptd == PsGetCurrentThread()->OfsChain );
        }

        _freeKernelTid( ptd );
        PsGetCurrentThread()->OfsChain = 0;

#else   /* _NTSUBSET_ */

        pthreadmbcinfo ptmbci;
        pthreadlocinfo ptloci;

#ifdef _XBOX
        _ptiddata *pptd;
        if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
            KeBugCheck(IRQL_NOT_LESS_OR_EQUAL);
        pptd = KeGetCurrentThread()->TlsData ?
            &__ptd_cur : &__ptd_glob;
#else
        /*
         * Do nothing unless per-thread data has been allocated for this module!
         */

        if ( __tlsindex != 0xFFFFFFFF )
#endif // XBOX
        {
            /*
             * if parameter "ptd" is NULL, get the per-thread data pointer
             * Must NOT call _getptd because it will allocate one if none exists!
             */

            if ( ! ptd )
#ifdef _XBOX
                ptd = *pptd;
#else
                ptd = TlsGetValue(__tlsindex );
#endif

            /*
             * Free up the _tiddata structure & its malloc-ed buffers.
             */

            if ( ptd ) {
                if(ptd->_errmsg)
                    _free_crt((void *)ptd->_errmsg);

                if(ptd->_namebuf0)
                    _free_crt((void *)ptd->_namebuf0);

                if(ptd->_namebuf1)
                    _free_crt((void *)ptd->_namebuf1);

                if(ptd->_asctimebuf)
                    _free_crt((void *)ptd->_asctimebuf);

                if(ptd->_gmtimebuf)
                    _free_crt((void *)ptd->_gmtimebuf);

                if(ptd->_cvtbuf)
                    _free_crt((void *)ptd->_cvtbuf);

                if (ptd->_pxcptacttab != _XcptActTab)
                    _free_crt((void *)ptd->_pxcptacttab);

                _mlock(_MB_CP_LOCK);
                __try {
                    if ( ((ptmbci = ptd->ptmbcinfo) != NULL) && 
                         (--(ptmbci->refcount) == 0) &&
                         (ptmbci != __ptmbcinfo) )
                        _free_crt(ptmbci);
                }
                __finally {
                    _munlock(_MB_CP_LOCK);
                }

#ifndef _XBOX
                _mlock(_SETLOCALE_LOCK);

                __try {
                    if ( (ptloci = ptd->ptlocinfo) != NULL )
                    {
                        (ptloci->refcount)--;

                        if ( ptloci->lconv_intl_refcount != NULL )
                            (*(ptloci->lconv_intl_refcount))--;

                        if ( ptloci->lconv_mon_refcount != NULL )
                            (*(ptloci->lconv_mon_refcount))--;

                        if ( ptloci->lconv_num_refcount != NULL )
                            (*(ptloci->lconv_num_refcount))--;

                        if ( ptloci->ctype1_refcount != NULL )
                            (*(ptloci->ctype1_refcount))--;

                        (ptloci->lc_time_curr->refcount)--;

                        if ( (ptloci != __ptlocinfo) &&
                             (ptloci != &__initiallocinfo) &&
                             (ptloci->refcount == 0) )
                            __freetlocinfo(ptloci);
                    }
                }
                __finally {
                    _munlock(_SETLOCALE_LOCK);
                }
#endif // XBOX

                _free_crt((void *)ptd);
            }

            /*
             * Zero out the one pointer to the per-thread data block
             */

#ifdef _XBOX
            *pptd = NULL;
#else
            TlsSetValue(__tlsindex, (LPVOID)0);
#endif
        }

#endif  /* _NTSUBSET_ */

}

#if defined(_NTSUBSET_)
#pragma END_NONPAGED_CODE
#endif


/***
*__threadid()     - Returns current thread ID
*__threadhandle() - Returns "pseudo-handle" for current thread
*
*Purpose:
*       The two function are simply do-nothing wrappers for the corresponding
*       Win32 APIs (GetCurrentThreadId and GetCurrentThread, respectively).
*
*Entry:
*       void
*
*Exit:
*       thread ID value
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP unsigned long __cdecl __threadid (
        void
        )
{
#if defined(_NTSUBSET_)
#ifdef _XBOX
        return( (unsigned long) (uintptr_t) PsGetCurrentThread()->UniqueThread );
#else
        return( (unsigned long) (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread );
#endif // XBOX
#else // NTSUBSET
        return( GetCurrentThreadId() );
#endif
}

_CRTIMP uintptr_t __cdecl __threadhandle(
        void
        )
{
#if defined(_NTSUBSET_)
#ifdef _XBOX
        return( (uintptr_t) PsGetCurrentThread()->UniqueThread );
#else
        return( (uintptr_t) PsGetCurrentThread()->Cid.UniqueThread );
#endif // XBOX
#else // NTSUBSET
        return( (uintptr_t)GetCurrentThread() );
#endif
}

#if defined(_XBOX) && !defined(_NTSUBSET_)
#pragma data_seg(".CRT$RII10")
_PIFV __pmtinit = _mtinit;
#pragma data_seg()
#endif // XBOX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\threadex.c ===
/***
*threadex.c - Extended versions of Begin (Create) and End (Exit) a Thread
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This source contains the _beginthreadex() and _endthreadex()
*       routines which are used to start and terminate a thread.  These
*       routines are more like the Win32 APIs CreateThread() and ExitThread() 
*       than the original functions _beginthread() & _endthread() were.
*
*Revision History:
*       02-16-94  SKS   Original version, based on thread.c which contains
*                       _beginthread() and _endthread().
*       02-17-94  SKS   Changed error return from -1 to 0, fix some comments.
*       06-10-94  SKS   Pass the thrdaddr value directly to CreateThread().
*                       Do *NOT* store the thread handle into the per-thread
*                       data block of the child thread.  (It is not needed.)
*                       The thread data structure may have been freed by the
*                       child thread before the parent thread returns from the
*                       call to CreateThread().  Watch that synchronization!
*       01-10-95  CFW   Debug CRT allocs.
*       04-18-95  SKS   Add 5 MIPS per-thread variables.
*       05-02-95  SKS   Call _initptd for initialization of per-thread data.
*       02-03-98  GJF   Changes for Win64: use uintptr_t type for anything with
*                       a HANDLE value.
*       02-02-00  GB    Modified threadstartex() to prevent leaking of ptd
*                       allocated during call to getptd while ATTACHing THREAD 
*                       in dlls.
*       05-31-00  PML   Don't pass NULL thrdaddr into CreateThread, since a
*                       non-NULL lpThreadId is required on Win9x.
*       08-04-00  PML   Set EINVAL error if thread start address null in
*                       _beginthreadex (VS7#118688).
*
*******************************************************************************/

#ifdef  _MT

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <malloc.h>
#include <process.h>
#include <stddef.h>
#include <rterr.h>
#include <dbgint.h>
#include <errno.h>

/*
 * Startup code for new thread.
 */
static unsigned long WINAPI _threadstartex(void *);

/*
 * declare pointers to per-thread FP initialization and termination routines
 */
_PVFV _FPmtinit;
_PVFV _FPmtterm;


/***
*_beginthreadex() - Create a child thread
*
*Purpose:
*       Create a child thread.
*
*Entry:
*       *** Same parameters as the Win32 API CreateThread() ***
*       security = security descriptor for the new thread
*       stacksize = size of stack
*       initialcode = pointer to thread's startup code address
*               must be a __stdcall function returning an unsigned.
*       argument = argument to be passed to new thread
*       createflag = flag to create thread in a suspended state
*       thrdaddr = points to an int to receive the ID of the new thread
*
*Exit:
*       *** Same as the Win32 API CreateThread() ***
*
*       success = handle for new thread if successful
*
*       failure = 0 in case of error, errno and _doserrno are set
*
*Exceptions:
*
*Notes:
*       This routine is more like the Win32 API CreateThread() than it
*       is like the C run-time routine _beginthread().  Ditto for
*       _endthreadex() and the Win32 API ExitThread() versus _endthread().
*
*       Differences between _beginthread/_endthread and the "ex" versions:
*
*         1)  _beginthreadex takes the 3 extra parameters to CreateThread
*             which are lacking in _beginthread():
*               A) security descriptor for the new thread
*               B) initial thread state (running/asleep)
*               C) pointer to return ID of newly created thread
*
*         2)  The routine passed to _beginthread() must be __cdecl and has
*             no return code, but the routine passed to _beginthreadex()
*             must be __stdcall and returns a thread exit code.  _endthread
*             likewise takes no parameter and calls ExitThread() with a
*             parameter of zero, but _endthreadex() takes a parameter as
*             thread exit code.
*
*         3)  _endthread implicitly closes the handle to the thread, but
*             _endthreadex does not!
*
*         4)  _beginthread returns -1 for failure, _beginthreadex returns
*             0 for failure (just like CreateThread).
*
*******************************************************************************/

uintptr_t __cdecl _beginthreadex (
        void *security,
        unsigned stacksize,
        unsigned (__stdcall * initialcode) (void *),
        void * argument,
        unsigned createflag,
        unsigned *thrdaddr
        )
{
        _ptiddata ptd;                  /* pointer to per-thread data */
        uintptr_t thdl;                 /* thread handle */
        unsigned long errcode = 0L;     /* Return from GetLastError() */
        unsigned dummyid;               /* dummy returned thread ID */

        if ( initialcode == NULL ) {
            errno = EINVAL;
            return( (uintptr_t)0 );
        }

        /*
         * Allocate and initialize a per-thread data structure for the to-
         * be-created thread.
         */
        if ( (ptd = _calloc_crt(1, sizeof(struct _tiddata))) == NULL )
                goto error_return;

        /*
         * Initialize the per-thread data
         */

        _initptd(ptd);

        ptd->_initaddr = (void *) initialcode;
        ptd->_initarg = argument;
        ptd->_thandle = (uintptr_t)(-1);

        /*
         * Make sure non-NULL thrdaddr is passed to CreateThread
         */
        if ( thrdaddr == NULL )
                thrdaddr = &dummyid;

        /*
         * Create the new thread using the parameters supplied by the caller.
         */
        if ( (thdl = (uintptr_t)
              CreateThread( security,
                            stacksize,
                            _threadstartex,
                            (LPVOID)ptd,
                            createflag,
                            thrdaddr))
             == (uintptr_t)0 )
        {
                errcode = GetLastError();
                goto error_return;
        }

        /*
         * Good return
         */
        return(thdl);

        /*
         * Error return
         */
error_return:
        /*
         * Either ptd is NULL, or it points to the no-longer-necessary block
         * calloc-ed for the _tiddata struct which should now be freed up.
         */
        _free_crt(ptd);

        /*
         * Map the error, if necessary.
         *
         * Note: this routine returns 0 for failure, just like the Win32
         * API CreateThread, but _beginthread() returns -1 for failure.
         */
        if ( errcode != 0L )
                _dosmaperr(errcode);

        return( (uintptr_t)0 );
}


/***
*_threadstartex() - New thread begins here
*
*Purpose:
*       The new thread begins execution here.  This routine, in turn,
*       passes control to the user's code.
*
*Entry:
*       void *ptd       = pointer to _tiddata structure for this thread
*
*Exit:
*       Never returns - terminates thread!
*
*Exceptions:
*
*******************************************************************************/

static unsigned long WINAPI _threadstartex (
        void * ptd
        )
{
        _ptiddata _ptd;                  /* pointer to per-thread data */

        /*
         * Check if ptd is initialised during THREAD_ATTACH call to dll mains
         */
#ifdef _XBOX
        if ( (_ptd = __ptd_cur) == NULL)
            __ptd_cur = ptd;
#else
        if ( ( _ptd = TlsGetValue(__tlsindex)) == NULL)
        {
            /*
             * Stash the pointer to the per-thread data stucture in TLS
             */
            if ( !TlsSetValue(__tlsindex, ptd) )
                _amsg_exit(_RT_THREAD);
            /*
             * Set the thread ID field -- parent thread cannot set it after
             * CreateThread() returns since the child thread might have run
             * to completion and already freed its per-thread data block!
             */
            ((_ptiddata) ptd)->_tid = GetCurrentThreadId();
        }
#endif // XBOX
        else
        {
            _ptd->_initaddr = ((_ptiddata) ptd)->_initaddr;
            _ptd->_initarg =  ((_ptiddata) ptd)->_initarg;
            _free_crt(ptd);
            ptd = _ptd;
        }


#ifndef _XBOX
        /*
         * Call fp initialization, if necessary
         */
        if ( _FPmtinit != NULL )
                (*_FPmtinit)();
#endif // XBOX

        /*
         * Guard call to user code with a _try - _except statement to
         * implement runtime errors and signal support
         */
        __try {
                _endthreadex (
                    ( (unsigned (WINAPI *)(void *))(((_ptiddata)ptd)->_initaddr) )
                    ( ((_ptiddata)ptd)->_initarg ) ) ;
        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
                /*
                 * Should never reach here
                 */
                _exit( GetExceptionCode() );

        } /* end of _try - _except */

        /*
         * Never executed!
         */
        return(0L);
}


/***
*_endthreadex() - Terminate the calling thread
*
*Purpose:
*
*Entry:
*       Thread exit code
*
*Exit:
*       Never returns!
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _endthreadex (
        unsigned retcode
        )
{
#ifndef _XBOX

        _ptiddata ptd;           /* pointer to thread's _tiddata struct */

        /*
         * Call fp termination, if necessary
         */
        if ( _FPmtterm != NULL )
                (*_FPmtterm)();

        if ( (ptd = _getptd()) == NULL )
                _amsg_exit(_RT_THREAD);

        /*
         * Free up the _tiddata structure & its subordinate buffers
         *      _freeptd() will also clear the value for this thread
         *      of the TLS variable __tlsindex.
         */
        _freeptd(ptd);

#endif // XBOX

        /*
         * Terminate the thread
         */
        ExitThread(retcode);

}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\tlssup.c ===
/***
*tlssup.c - Thread Local Storage run-time support module
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-19-93  SKS   Original Version from Chuck Mitchell
*       11-16-93  GJF   Enclosed in #ifdef _MSC_VER
*       02-17-94  SKS   Add "const" to declaration of _tls_used
*                       to work around problems with MIPS compiler.
*                       Also added a canonical file header comment.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       03-04-98  JWM   Modified for WIN64 - uses _IMAGE_TLS_DIRECTORY64
*       04-03-98  JWM   _tls_start & _tls_end are no longer initialized.
*       01-21-99  GJF   Added a couple ULONGLONG casts.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       09-06-00  PML   _tls_start/_tls_end can be 1 byte long (vs7#154062)
*       03-24-01  PML   callback array starts at __xl_a+1, not __xl_a.
*
****/

#ifdef  _MSC_VER

#include <sect_attribs.h>
#include <windows.h>

/* Thread Local Storage index for this .EXE or .DLL */

ULONG _tls_index = 0;

/* Special symbols to mark start and end of Thread Local Storage area. */

#pragma data_seg(".tls")

_CRTALLOC(".tls") char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

_CRTALLOC(".tls$ZZZ") char _tls_end = 0;

/* Start and end sections for Threadl Local Storage CallBack Array.
 * Actual array is constructed using .CRT$XLA, .CRT$XLC, .CRT$XLL,
 * .CRT$XLU, .CRT$XLZ similar to the way global
 *         static initializers are done for C++.
 */

#pragma data_seg(".CRT$XLA")

_CRTALLOC(".CRT$XLA") PIMAGE_TLS_CALLBACK __xl_a = 0;

#pragma data_seg(".CRT$XLZ")

_CRTALLOC(".CRT$XLZ") PIMAGE_TLS_CALLBACK __xl_z = 0;


#pragma data_seg(".rdata$T")

#ifndef IMAGE_SCN_SCALE_INDEX
#define IMAGE_SCN_SCALE_INDEX                0x00000001  // Tls index is scaled
#endif

#ifdef _WIN64

__declspec(allocate(".rdata$T")) const IMAGE_TLS_DIRECTORY64 _tls_used =
{
        (ULONGLONG) &_tls_start,        // start of tls data
        (ULONGLONG) &_tls_end,          // end of tls data
        (ULONGLONG) &_tls_index,        // address of tls_index
        (ULONGLONG) (&__xl_a+1),        // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
        (ULONG) 0                       // characteristics
};


#else

const IMAGE_TLS_DIRECTORY _tls_used =
{
        (ULONG)(ULONG_PTR) &_tls_start, // start of tls data
        (ULONG)(ULONG_PTR) &_tls_end,   // end of tls data
        (ULONG)(ULONG_PTR) &_tls_index, // address of tls_index
        (ULONG)(ULONG_PTR) (&__xl_a+1), // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
#if defined(_M_MRX000)
        (ULONG)IMAGE_SCN_SCALE_INDEX    // characteristics
#else
        (ULONG) 0                       // characteristics
#endif
};

#endif


#endif  /* _MSC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wstdenvp.c ===
/***
*wstdenvp.c - standard _setenvp routine (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This module is called by the C start-up routine to set up "_wenviron".
*	Its sets up an array of pointers to strings in the environment.
*	The global symbol "_wenviron" is set to point to this array.
*
*Revision History:
*	11-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stdenvp.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wstdargv.c ===
/***
*wstdargv.c - standard & wildcard _setargv routine (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	processes program command line, with or without wildcard expansion
*
*Revision History:
*	11-19-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "stdargv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wcrt0.c ===
/***
*wcrt0.c - C runtime console EXE start-up routine, wchar_t version
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for console apps using wide
*       characters.  It calls the user's main routine wmain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       11-19-93  CFW   Module created.
*       02-04-94  CFW   POSIX? NOT!
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "crt0.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wwincrt0.c ===
/***
*wwincrt0.c - C runtime Windows EXE start-up routine, wchar_t version
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps using wide
*       characters.  It calls the user's main routine wWinMain() after
*       performing C Run-Time Library initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*       10-28-94  SKS   Remove user32.lib as a default library -- it is now
*                       specified in crt0init.obj along with kernel32.lib.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define _WINMAIN_
#include "crt0.c"

#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wincrt0.c ===
/***
*wincrt0.c - C runtime Windows EXE start-up routine
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*Revision History:
*       ??-??-??  ???   Module created.
*       09-01-94  SKS   Module commented.
*       10-28-94  SKS   Remove user32.lib as a default library -- it is now
*                       specified in crt0init.obj along with kernel32.lib.
*
*******************************************************************************/

#ifndef _POSIX_

#define _WINMAIN_
#include "crt0.c"

#endif  /* ndef _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wwild.c ===
/***
*wwild.c - wildcard expander (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	 expands wildcards in argv
*
*	 handles L'*' (none or more of any char) and L'?' (exactly one char)
*
*Revision History:
*	11-19-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "wild.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wincmdln.c ===
/***
*wincmdln.c - process command line for WinMain
*
*       Copyright (c) 1997-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to [w]WinMain.
*
*Revision History:
*       06-23-97  GJF   Module created by extracting the code from crt0.c
*       03-24-01  PML   Protect against null _[aw]cmdln (vs7#229081)
*
*******************************************************************************/

#include <internal.h>
#include <tchar.h>

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
extern int __mbctype_initialized;

/***
*_[w]wincmdln
*
*Purpose:
*       Extract the command line tail to be passed to WinMain.
*
*       Be warned! This code was originally implemented by the NT group and 
*       has remained pretty much unchanged since 12-91. It should be changed
*       only with extreme care since there are undoubtedly many apps which
*       depend on its historical behavior.
*
*Entry:
*       The global variable _[a|w]cmdln is set to point at the complete
*       command line.
*
*Exit:
*       Returns a pointer to the command line tail.
*
*Exceptions:
*
*******************************************************************************/

_TUCHAR * __cdecl
#ifdef  WPRFLAG
_wwincmdln(
#else
_wincmdln(
#endif
        void
        )
{
        _TUCHAR *lpszCommandLine;

#ifdef  _MBCS
        /*
         * If necessary, initialize the multibyte ctype table
         */
        if ( __mbctype_initialized == 0 )
            __initmbctable();
#endif

        /*
         * Skip past program name (first token in command line).
         * Check for and handle quoted program name.
         */
#ifdef  WPRFLAG
        lpszCommandLine = _wcmdln == NULL ? L"" : (wchar_t *)_wcmdln;
#else
        lpszCommandLine = _acmdln == NULL ? "" : (unsigned char *)_acmdln;
#endif

        if ( *lpszCommandLine == DQUOTECHAR ) {
            /*
             * Scan, and skip over, subsequent characters until
             * another double-quote or a null is encountered.
             */

            while ( (*(++lpszCommandLine) != DQUOTECHAR)
                    && (*lpszCommandLine != _T('\0')) ) 
            {
#ifdef  _MBCS
                if (_ismbblead(*lpszCommandLine))
                    lpszCommandLine++;
#endif
            }

            /*
             * If we stopped on a double-quote (usual case), skip
             * over it.
             */
            if ( *lpszCommandLine == DQUOTECHAR )
                lpszCommandLine++;
        }
        else {
            while (*lpszCommandLine > SPACECHAR)
                lpszCommandLine++;
        }

        /*
         * Skip past any white space preceeding the second token.
         */
        while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR))
            lpszCommandLine++;

        return lpszCommandLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wild.c ===
/***
*wild.c - wildcard expander
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*        expands wildcards in argv
*
*        handles '*' (none or more of any char) and '?' (exactly one char)
*
*Revision History:
*       05-21-84  RN    initial version
*       06-07-85  TDC   since dos accepts forward slash, added
*                       code to accept forward slash in a manner consistent
*                       with reverse slash.
*       09-20-86  SKS   Modified for OS/2
*                       All argument strings to this function have a
*                       leading flag character. If the flag is a quote,
*                       that argument string was quoted on the command
*                       line and should have not wildcard expansion.  In all
*                       cases the leading flag character is removed from
*                       the string.
*       11-11-86  JMB   Added Kanji support under KANJI switch.
*       09-21-88  WAJ   initial 386 version
*       04-09-90  GJF   Added #include <cruntime.h> and removed #include
*                       <register.h>. Made calling types explicit (_CALLTYPE1
*                       or _CALLTYPE4). Also, fixed the copyright.
*       04-10-90  GJF   Added #include <internal.h> and fixed compiler warnings
*                       (-W3).
*       07-03-90  SBM   Compiles cleanly with -W3 under KANJI, removed
*                       redundant includes, removed #include <internal.h>
*                       to keep wild.c free of private stuff, should we
*                       decide to release it
*       09-07-90  SBM   put #include <internal.h> back in, reason for
*                       removing it discovered to be horribly bogus
*       10-08-90  GJF   New-style function declarators.
*       01-18-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*                       Remove explicit declarations of __argc & __argv.
*                       They are declared in <stdlib.h>
*       05-05-93  SKS   Filename sorting should be case-insensitive
*       06-09-93  KRS   Update _MBCS support.
*       10-20-93  GJF   Merged in NT version.
*       11-23-93  CFW   Wide char enable, grab _find from stdargv.c.
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       04-22-94  GJF   Made defintions of arghead, argend, _WildFindHandle
*                       and findbuf conditional on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Must replace _tcsdup with _malloc_crt/_tcscpy for
*                       _DEBUG build.
*       02-04-98  GJF   Changes for Win64: use intptr_t and ptrdiff_t casts
*                       where appropriate.
*       02-19-01  GB    added check for return value of malloc in find.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>

#ifdef _MBCS
#include <mbdata.h>
#include <mbstring.h>
#endif
#include <dbgint.h>

/*
** these are the data structures
**
**     __argv
**     -------     ------
**     |     |---->|    |---->"arg0"
**     -------     ------
**                 |    |---->"arg1"
**                 ------
**                  ....
**                 ------
**                 |    |---->"argn"
**                 ------
**                 |NULL|
**                 ------
**                                       argend
**                                       -------
**     -------                           |     |
**     |     | __argc                    -------
**     -------                              |
**                                          |
**  arghead                                 V
**  ------     ---------                ----------
**  |    |---->|   |   |----> .... ---->|   |NULL|
**  ------     ---------                ----------
**               |                        |
**               V                        V
**            "narg0"                  "nargn"
*/

#define ERRORHANDLE ((HANDLE)(intptr_t)(-1))

/* local function tchars */
#ifdef WPRFLAG
#define tmatch  wmatch
#define tadd    wadd
#define tsort   wsort
#define tfind   wfind
#else
#define tmatch  match
#define tadd    add
#define tsort   sort
#define tfind   find
#endif

#define SLASHCHAR       _T('\\')
#define FWDSLASHCHAR    _T('/')
#define COLONCHAR       _T(':')
#define QUOTECHAR       _T('"')

#define SLASH           _T("\\")
#define FWDSLASH        _T("/")
#define STAR            _T("*.*")
#define DOT             _T(".")
#define DOTDOT          _T("..")

#define WILDSTRING      _T("*?")

struct argnode {
    _TSCHAR *argptr;
    struct argnode *nextnode;
};

static struct argnode *arghead;
static struct argnode *argend;

#ifdef WPRFLAG
static int __cdecl wmatch(wchar_t *, wchar_t *);
static int __cdecl wadd(wchar_t *);
static void __cdecl wsort(struct argnode *);
static wchar_t * __cdecl wfind (wchar_t *pattern);
#else
static int __cdecl match(char *, char *);
static int __cdecl add(char *);
static void __cdecl sort(struct argnode *);
static char * __cdecl find (char *pattern);
#endif

/***
*int _cwild() - wildcard expander
*
*Purpose:
*       expands wildcard in file specs in argv
*
*       handles '*' (none or more of any char), '?' (exactly one char), and
*       '[string]' (chars which match string chars or between n1 and n2
*       if 'n1-n2' in string inclusive)
*
*Entry:
*
*Exit:
*       returns 0 if successful, -1 if any malloc() calls fail
*       if problems with malloc, the old argc and argv are not touched
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wcwild (
#else
int __cdecl _cwild (
#endif
        void
        )
{
#ifdef WPRFLAG
        REG1 wchar_t **argv = __wargv;
#else
        REG1 char **argv = __argv;
#endif
        REG2 struct argnode *nodeptr;
        REG3 int argc;
        REG4 _TSCHAR **tmp;
        _TSCHAR *wchar;

        arghead = argend = NULL;

#ifdef WPRFLAG
        for (argv = __wargv; *argv; argv++) /* for each arg... */
#else
        for (argv = __argv; *argv; argv++)  /* for each arg... */
#endif
            if ( *(*argv)++ == QUOTECHAR )
                /* strip leading quote from quoted arg */
            {
                if (tadd(*argv))
                    return(-1);
            }
            else if (wchar = _tcspbrk( *argv, WILDSTRING )) {
                /* attempt to expand arg with wildcard */
                if (tmatch( *argv, wchar ))
                    return(-1);
            }
            else if (tadd( *argv )) /* normal arg, just add */
                return(-1);

        /* count the args */
        for (argc = 0, nodeptr = arghead; nodeptr;
                nodeptr = nodeptr->nextnode, argc++)
            ;

        /* try to get new arg vector */
        if (!(tmp = (_TSCHAR **)_malloc_crt(sizeof(_TSCHAR *)*(argc+1))))
            return(-1);

        /* the new arg vector... */
#ifdef WPRFLAG
        __wargv = tmp;
#else
        __argv = tmp;
#endif

        /* the new arg count... */
        __argc = argc;

        /* install the new args */
        for (nodeptr = arghead; nodeptr; nodeptr = nodeptr->nextnode)
            *tmp++ = nodeptr->argptr;

        /* the terminal NULL */
        *tmp = NULL;

        /* free up local data */
        for (nodeptr = arghead; nodeptr; nodeptr = arghead) {
            arghead = arghead->nextnode;
            _free_crt(nodeptr);
        }

        /* return success */
        return(0);
}


/***
*match(arg, ptr) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wmatch (
#else
static int __cdecl match (
#endif
        REG4 _TSCHAR *arg,
        REG1 _TSCHAR *ptr
        )
{
        REG2 _TSCHAR *new;
        REG3 int length = 0;
        _TSCHAR *all;
        REG5 struct argnode *first;
        REG6 int gotone = 0;

        while (ptr != arg && *ptr != SLASHCHAR && *ptr != FWDSLASHCHAR
            && *ptr != COLONCHAR) {
            /* find first slash or ':' before wildcard */
#ifdef _MBCS
            if (--ptr > arg)
                ptr = _mbsdec(arg,ptr+1);
#else
            ptr--;
#endif
        }

        if (*ptr == COLONCHAR && ptr != arg+1) /* weird name, just add it as is */
            return(tadd(arg));

        if (*ptr == SLASHCHAR || *ptr == FWDSLASHCHAR
            || *ptr == COLONCHAR) /* pathname */
            length = (int)(ptrdiff_t)(ptr - arg + 1); /* length of dir prefix */

        if (new = tfind(arg)) { /* get the first file name */
            first = argend;

            do  { /* got a file name */
                if (_tcscmp(new, DOT) && _tcscmp(new, DOTDOT)) {
                    if (*ptr != SLASHCHAR && *ptr != COLONCHAR
                        && *ptr != FWDSLASHCHAR ) {
                        /* current directory; don't need path */
#ifdef  _DEBUG
                        if (!(arg=_malloc_crt((_tcslen(new)+1)*sizeof(_TSCHAR)))
                            || tadd(_tcscpy(arg,new)))
#else   /* ndef _DEBUG */
                        if (!(arg = _tcsdup(new)) || tadd(arg))
#endif  /* _DEBUG */
                            return(-1);
                    }
                    else    /* add full pathname */
                        if (!(all=_malloc_crt((length+_tcslen(new)+1)*sizeof(_TSCHAR)))
                            || tadd(_tcscpy(_tcsncpy(all,arg,length)+length,new)
                            - length))
                            return(-1);

                    gotone++;
                }

            }
            while (new = tfind(NULL));  /* get following files */

            if (gotone) {
                tsort(first ? first->nextnode : arghead);
                return(0);
            }
        }

        return(tadd(arg)); /* no match */
}

/***
*add(arg) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static int __cdecl wadd (
#else
static int __cdecl add (
#endif
    _TSCHAR *arg
    )
{
        REG1 struct argnode *nodeptr;

        if (!(nodeptr = (struct argnode *)_malloc_crt(sizeof(struct argnode))))
            return(-1);

        nodeptr->argptr = arg;
        nodeptr->nextnode = NULL;

        if (arghead)
            argend->nextnode = nodeptr;
        else
            arghead = nodeptr;

        argend = nodeptr;
        return(0);
}


/***
*sort(first) - [STATIC]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static void __cdecl wsort (
#else
static void __cdecl sort (
#endif
        REG2 struct argnode *first
        )
{
        REG1 struct argnode *nodeptr;
        REG3 _TSCHAR *temp;

        if (first) /* something to sort */
            while (nodeptr = first->nextnode) {
                do  {
#ifdef _POSIX_
                    if (_tcscmp(nodeptr->argptr, first->argptr) < 0) {
#else
                    if (_tcsicmp(nodeptr->argptr, first->argptr) < 0) {
#endif /* _POSIX_ */
                        temp = first->argptr;
                        first->argptr = nodeptr->argptr;
                        nodeptr->argptr = temp;
                    }
                }
                while (nodeptr = nodeptr->nextnode);

                first = first->nextnode;
            }
}


/***
*find(pattern) - find matching filename
*
*Purpose:
*       if argument is non-null, do a DOSFINDFIRST on that pattern
*       otherwise do a DOSFINDNEXT call.  Return matching filename
*       or NULL if no more matches.
*
*Entry:
*       pattern = pointer to pattern or NULL
*           (NULL means find next matching filename)
*
*Exit:
*       returns pointer to matching file name
*           or NULL if no more matches.
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
static wchar_t * __cdecl wfind (
#else
static char * __cdecl find (
#endif /* WPRFLAG */
    _TSCHAR *pattern
    )
{
        _TSCHAR *retval;

        static HANDLE _WildFindHandle;
        static LPWIN32_FIND_DATA findbuf;

        if (pattern) {
            if (findbuf == NULL)
                if ((findbuf = (LPWIN32_FIND_DATA)_malloc_crt(MAX_PATH + sizeof(*findbuf))) == NULL)
                    return NULL;

            if (_WildFindHandle != NULL) {
                (void)FindClose( _WildFindHandle );
                _WildFindHandle = NULL;
            }

            _WildFindHandle = FindFirstFile( (LPTSTR)pattern, findbuf );
            if (_WildFindHandle == ERRORHANDLE)
                return NULL;
        }
        else if (!FindNextFile( _WildFindHandle, findbuf )) {
            (void)FindClose( _WildFindHandle );
            _WildFindHandle = NULL;
            return NULL;
        }

        retval = findbuf->cFileName;

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\_setargv.c ===
/***
*_setargv.c - Wildcard argv[] expansion
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	_setargv performs wildcard argv[] expansion
*
*	NOTE:  This stub module scheme is compatible with NT build
*	procedure.
*
*Revision History:
*	09-25-91  JCR	Stub module created.
*
*******************************************************************************/

#define WILDCARD 1
#include "stdargv.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\i386\fp8.c ===
/***
* fp8.c - Set default FP precision to 53 bits (8-byte double)
*
*	Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*   03-23-93  JWM	created file
*
*******************************************************************************/
#include <float.h>

void  _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 53 bits.
 */
 
void _setdefaultprecision()
{
	_controlfp(_PC_53, _MCW_PC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\_wstargv.c ===
/***
*_wstargv.c - Wildcard argv[] expansion (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	_wsetargv performs wildcard argv[] expansion
*
*	NOTE:  This stub module scheme is compatible with NT build
*	procedure.
*
*Revision History:
*	11-23-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#define WILDCARD 1

#include "stdargv.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\wwncmdln.c ===
/***
*wwncmdln.c - process command line for wWinMain
*
*       Copyright (c) 1997-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prepare command line to be passed to wWinMain.
*
*Revision History:
*       06-26-97  GJF   Module created.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG     1

#ifndef _UNICODE    /* CRT flag */
#define _UNICODE    1
#endif

#ifndef UNICODE     /* NT flag */
#define UNICODE     1
#endif

#undef  _MBCS       /* UNICODE not _MBCS */

#include "wincmdln.c"

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\i386\chkstk.asm ===
page    ,132
        title   chkstk - C stack checking routine
;***
;chkstk.asm - C stack checking routine
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Provides support for automatic stack checking in C procedures
;       when stack checking is enabled.
;
;Revision History:
;       04-21-87  SKS   Added conditional assembly switch for STKHQQ = 0
;       07-23-87  MAG   [1] Added run-time CS:IP error processing for QC
;       08-17-87  JLS   [2] Remove all references to DGROUP
;       08-25-87  JLS   [3] Shift include files
;       11-13-87  SKS   OS/2 Reentrant version, add thread ID check
;       11-18-87  SKS   Make STKHQQ an array (oops!)
;       12-14-87  SKS   add .286p to allow PUSH immediate value
;       02-19-88  SKS   Change minimum bottom limit to STACKSLOP, not 0
;       06-01-88  PHG   Merge DLL and normal versions
;       09-21-88  WAJ   initial 386 version
;       10-18-88  JCR   Chkstk was trashing bx... not good on 386
;       06-06-89  JCR   386 mthread support
;       06-20-89  JCR   386: Removed _LOAD_DGROUP code
;       04-06-90  GJF   Fixed the copyright.
;       06-21-90  GJF   Rewritten to probe pages
;       10-15-90  GJF   Restored _end and STKHQQ.
;       03-19-91  GJF   Revised to preserve all registers except eax. Note
;                       this is _rchkstk functionality so there is no longer
;                       a separate _rchkstk routine.
;       08-01-91  GJF   Got rid of _end and STKHQQ, except for Cruiser
;                       (probably not needed for Cruiser either) [_WIN32_].
;       09-27-91  JCR   Merged Stevewo' changes from NT tree
;       09-06-94  CFW   Nuke Cruiser.
;       12-03-94  SKS   Remove include of obsolete file msdos.inc
;       12-13-94  GJF   Better version from Intel (old jmp eax method of
;                       returning is too expensive on P6).
;       09-11-98  GJF   Fixed handling of very small frames.
;       12-10-99  GB    Changed both _chkstk and _alloca_probe to procedure
;
;*******************************************************************************

.xlist
        include cruntime.inc
.list

; size of a page of memory

_PAGESIZE_      equ     1000h


        CODESEG

page
;***
;_chkstk - check stack upon procedure entry
;
;Purpose:
;       Provide stack checking on procedure entry. Method is to simply probe
;       each page of memory required for the stack in descending order. This
;       causes the necessary pages of memory to be allocated via the guard
;       page scheme, if possible. In the event of failure, the OS raises the
;       _XCPT_UNABLE_TO_GROW_STACK exception.
;
;       NOTE:  Currently, the (EAX < _PAGESIZE_) code path falls through
;       to the "lastpage" label of the (EAX >= _PAGESIZE_) code path.  This
;       is small; a minor speed optimization would be to special case
;       this up top.  This would avoid the painful save/restore of
;       ecx and would shorten the code path by 4-6 instructions.
;
;Entry:
;       EAX = size of local frame
;
;Exit:
;       ESP = new stackframe, if successful
;
;Uses:
;       EAX
;
;Exceptions:
;       _XCPT_GUARD_PAGE_VIOLATION - May be raised on a page probe. NEVER TRAP
;                                    THIS!!!! It is used by the OS to grow the
;                                    stack on demand.
;       _XCPT_UNABLE_TO_GROW_STACK - The stack cannot be grown. More precisely,
;                                    the attempt by the OS memory manager to
;                                    allocate another guard page in response
;                                    to a _XCPT_GUARD_PAGE_VIOLATION has
;                                    failed.
;
;*******************************************************************************

public _alloca_probe 

_chkstk proc

_alloca_probe    =  _chkstk

        test    eax, eax                ; any space to make?
        jz      done
        neg     eax                     ; compute new stack pointer in eax
        add     eax,esp
        add     eax,4
        xchg    eax,esp
        mov     eax,dword ptr [eax]
        push    eax
done:
	    ret

_chkstk endp
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\i386\atlssup.asm ===
page	,132
	title	atlssup - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Defines the symbol [_]_tls_array which is the offset into the
;	TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;	03-19-93  SKS	Initial version (from ChuckM)
;	03-22-93  SKS	One less leading underscore with new include file 
;	10-06-94  SKS	Added header file comment
;
;*******************************************************************************

.xlist
include cruntime.inc
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

		public	_tls_array 
ifdef _XBOX
_tls_array 	equ	04h	  ; TIB.StackBase
else
_tls_array 	equ	2Ch	  ; TEB.ThreadLocalStoragePointer
endif

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\startup\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\delop2.cpp ===
// delop2 -- operator delete(void *, nothrow_t) REPLACEABLE
#include <new>

void __cdecl operator delete(void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete(ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\delaop2_s.cpp ===
//  delaop2_s.cpp - version of delaop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delaop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\cout.cpp ===
// cout -- initialize standard output stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf fout(_cpp_stdout);
_CRTIMP2 ostream cout(&fout);

		// INITIALIZATION CODE
struct _Init_cout
	{	// ensures that cout is initialized
	_Init_cout()
		{	// initialize cout
		_Ptr_cout = &cout;
		if (_Ptr_cin != 0)
			_Ptr_cin->tie(_Ptr_cout);
		if (_Ptr_cerr != 0)
			_Ptr_cerr->tie(_Ptr_cout);
		if (_Ptr_clog != 0)
			_Ptr_clog->tie(_Ptr_cout);
		}
	};
static _Init_cout init_cout;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\delop2_s.cpp ===
//  delop2_s.cpp - version of delop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "delop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\cin.cpp ===
// cin -- initialize standard input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf fin(_cpp_stdin);
_CRTIMP2 istream cin(&fin);

		// INITIALIZATION CODE
struct _Init_cin
	{	// ensures that cin is initialized
	_Init_cin()
		{	// initialize cin
		_Ptr_cin = &cin;
		cin.tie(_Ptr_cout);
		}
	};
static _Init_cin init_cin;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\cerr.cpp ===
// cerr -- initialize standard error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf ferr(_cpp_stderr);
_CRTIMP2 ostream cerr(&ferr);

		// INITIALIZATION CODE
struct _Init_cerr
	{	// ensures that cerr is initialized
	_Init_cerr()
		{	// initialize cerr
		_Ptr_cerr = &cerr;
		cerr.tie(_Ptr_cout);
		cerr.setf(ios_base::unitbuf);
		}
	};
static _Init_cerr init_cerr;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\clog.cpp ===
// clog -- initialize standard log stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static filebuf flog(_cpp_stderr);
_CRTIMP2 ostream clog(&flog);

		// INITIALIZATION CODE
struct _Init_clog
	{	// ensures that clog is initialized
	_Init_clog()
		{	// initialize clog
		_Ptr_clog = &clog;
		clog.tie(_Ptr_cout);
		}
	};
static _Init_clog init_clog;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\delaop2.cpp ===
// delaop2 -- operator delete[](void *, nothrow_t) REPLACEABLE
#include <new>

void __cdecl operator delete[](void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete[](ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\libcpver.h ===
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <xboxverp.h>

#pragma data_seg(".XBLD$V")

#ifdef _MT
#if DBG
#pragma comment(linker, "/include:_LibcpBuildNumberMTD")
__declspec(selectany) unsigned short LibcpBuildNumberMTD[8] = { 'IL', 'CB', 'MP', 'DT',
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_LibcpBuildNumberMT")
__declspec(selectany) unsigned short LibcpBuildNumberMT[8] = { 'IL', 'CB', 'MP', 'T',
    VER_PRODUCTVERSION | 0x4000
#endif // DBG
#else  // _MT
#if DBG
#pragma comment(linker, "/include:_LibcpBuildNumberD")
__declspec(selectany) unsigned short LibcpBuildNumberD[8] = { 'IL', 'CB', 'DP', 0,
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_LibcpBuildNumber")
__declspec(selectany) unsigned short LibcpBuildNumber[8] = { 'IL', 'CB', 'P', 0,
    VER_PRODUCTVERSION | 0x4000
#endif // DBG
#endif // _MT
};

#pragma data_seg()

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\instances.cpp ===
// instances -- force DLL instances for Microsoft
#define __FORCE_INSTANCE

#include <complex>
#include <fstream>
#include <ios>
#include <istream>
#include <limits>
#include <locale>
#include <ostream>
#include <sstream>
#include <streambuf>
#include <xlocale>
#include <xlocmes>
#include <xlocmon>
#include <xlocnum>
#include <xloctime>
#include <xstring>

_STD_BEGIN

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, signed char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, signed char&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, unsigned char&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short *);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, unsigned short&);
#endif

template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const signed char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, signed char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const unsigned char *);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, unsigned char);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, wchar_t);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, unsigned short);
#endif

template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const char, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_string<char, char_traits<char>, allocator<char> > __cdecl operator+(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator==(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const char *, const basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<char, char_traits<char>, allocator<char> >&, const char *);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&);
template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl getline(
        basic_istream<char, char_traits<char> >&,
        basic_string<char, char_traits<char>, allocator<char> >&, const char);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&,
        const basic_string<char, char_traits<char>, allocator<char> >&);

template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const wchar_t, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > __cdecl operator+(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator==(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const wchar_t *, const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t *);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl getline(
        basic_istream<wchar_t, char_traits<wchar_t> >&,
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&, const wchar_t);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&,
        const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const unsigned short, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> > __cdecl operator+(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator==(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator==(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator!=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator<=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const unsigned short *, const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 bool __cdecl operator>=(
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short *);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl getline(
        basic_istream<unsigned short, char_traits<unsigned short> >&,
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&, const unsigned short);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&,
        const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<float>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<float>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<float>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<float>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<float>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<float>&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<double>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<double>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<double>&);
#endif

template _CRTIMP2 basic_istream<char, char_traits<char> >& __cdecl operator>>(
        basic_istream<char, char_traits<char> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<char, char_traits<char> >& __cdecl operator<<(
        basic_ostream<char, char_traits<char> >&, const complex<long double>&);
template _CRTIMP2 basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
        basic_istream<wchar_t, char_traits<wchar_t> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
        basic_ostream<wchar_t, char_traits<wchar_t> >&, const complex<long double>&);
#ifdef _NATIVE_WCHAR_T_DEFINED
template _CRTIMP2 basic_istream<unsigned short, char_traits<unsigned short> >& __cdecl operator>>(
        basic_istream<unsigned short, char_traits<unsigned short> >&, complex<long double>&);
template _CRTIMP2 basic_ostream<unsigned short, char_traits<unsigned short> >& __cdecl operator<<(
        basic_ostream<unsigned short, char_traits<unsigned short> >&, const complex<long double>&);
#endif

template _CRTIMP2 float __cdecl imag(const complex<float>&);
template _CRTIMP2 float __cdecl real(const complex<float>&);
template _CRTIMP2 float __cdecl _Fabs(const complex<float>&, int *);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator+(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator-(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator*(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator*(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator*(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator/(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator/(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl operator/(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator+(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl operator-(const complex<float>&);
template _CRTIMP2 bool __cdecl operator==(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator==(const complex<float>&, const float&);
template _CRTIMP2 bool __cdecl operator==(const float&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<float>&, const complex<float>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<float>&, const float&);
template _CRTIMP2 bool __cdecl operator!=(const float&, const complex<float>&);
template _CRTIMP2 float __cdecl abs(const complex<float>&);
template _CRTIMP2 float __cdecl arg(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl conj(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl cos(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl cosh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl exp(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl log(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl log10(const complex<float>&);
template _CRTIMP2 float __cdecl norm(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl polar(const float&, const float&);
template _CRTIMP2 complex<float> __cdecl polar(const float&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, const float&);
template _CRTIMP2 complex<float> __cdecl pow(const complex<float>&, int);
template _CRTIMP2 complex<float> __cdecl pow(const float&, const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sin(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sinh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl sqrt(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl tanh(const complex<float>&);
template _CRTIMP2 complex<float> __cdecl tan(const complex<float>&);

template _CRTIMP2 double __cdecl imag(const complex<double>&);
template _CRTIMP2 double __cdecl real(const complex<double>&);
template _CRTIMP2 double __cdecl _Fabs(const complex<double>&, int *);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator+(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator-(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator*(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator*(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator*(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator/(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator/(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl operator/(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator+(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl operator-(const complex<double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<double>&, const double&);
template _CRTIMP2 bool __cdecl operator==(const double&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<double>&, const complex<double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<double>&, const double&);
template _CRTIMP2 bool __cdecl operator!=(const double&, const complex<double>&);
template _CRTIMP2 double __cdecl abs(const complex<double>&);
template _CRTIMP2 double __cdecl arg(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl conj(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl cos(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl cosh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl exp(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl log(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl log10(const complex<double>&);
template _CRTIMP2 double __cdecl norm(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl polar(const double&, const double&);
template _CRTIMP2 complex<double> __cdecl polar(const double&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, const double&);
template _CRTIMP2 complex<double> __cdecl pow(const complex<double>&, int);
template _CRTIMP2 complex<double> __cdecl pow(const double&, const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sin(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sinh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl sqrt(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl tanh(const complex<double>&);
template _CRTIMP2 complex<double> __cdecl tan(const complex<double>&);

template _CRTIMP2 long double __cdecl imag(const complex<long double>&);
template _CRTIMP2 long double __cdecl real(const complex<long double>&);
template _CRTIMP2 long double __cdecl _Fabs(const complex<long double>&, int *);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator+(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator-(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator*(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator*(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator*(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator/(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator/(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl operator/(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator+(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl operator-(const complex<long double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator==(const complex<long double>&, const long double&);
template _CRTIMP2 bool __cdecl operator==(const long double&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 bool __cdecl operator!=(const complex<long double>&, const long double&);
template _CRTIMP2 bool __cdecl operator!=(const long double&, const complex<long double>&);
template _CRTIMP2 long double __cdecl abs(const complex<long double>&);
template _CRTIMP2 long double __cdecl arg(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl conj(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl cos(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl cosh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl exp(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl log(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl log10(const complex<long double>&);
template _CRTIMP2 long double __cdecl norm(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl polar(const long double&, const long double&);
template _CRTIMP2 complex<long double> __cdecl polar(const long double&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, const long double&);
template _CRTIMP2 complex<long double> __cdecl pow(const complex<long double>&, int);
template _CRTIMP2 complex<long double> __cdecl pow(const long double&, const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sin(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sinh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl sqrt(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl tanh(const complex<long double>&);
template _CRTIMP2 complex<long double> __cdecl tan(const complex<long double>&);

template<> const basic_string<char, char_traits<char>, allocator<char> >::size_type
        basic_string<char, char_traits<char>, allocator<char> >::npos =
		(size_type)(-1);
template<> const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::size_type
        basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::npos =
		(size_type)(-1);
#ifdef _NATIVE_WCHAR_T_DEFINED
template<> const basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >::size_type
        basic_string<unsigned short, char_traits<unsigned short>, allocator<unsigned short> >::npos =
		(size_type)(-1);
#endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\iomanip.cpp ===
// iomanip -- instantiations of iomanip
#include <iomanip>
_STD_BEGIN

		// FUNCTION resetiosflags
static void __cdecl rsfun(ios_base& iostr, ios_base::fmtflags mask)
	{	// reset specified format flags
	iostr.setf(ios_base::_Fmtzero, mask);
	}

		// FUNCTION setiosflags
static void __cdecl sifun(ios_base& iostr, ios_base::fmtflags mask)
	{	// set specified format flags
	iostr.setf(ios_base::_Fmtmask, mask);
	}

		// FUNCTION setbase
static void __cdecl sbfun(ios_base& iostr, int base)
	{	// set base
	iostr.setf(base == 8 ? ios_base::oct
		: base == 10 ? ios_base::dec
		: base == 16 ? ios_base::hex
		: ios_base::_Fmtzero,
			ios_base::basefield);
	}

		// FUNCTION setprecision
static void __cdecl spfun(ios_base& iostr, streamsize prec)
	{	// set precision
	iostr.precision(prec);
	}

		// FUNCTION setw
static void __cdecl swfun(ios_base& iostr, streamsize wide)
	{	// set width
	iostr.width(wide);
	}

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl resetiosflags(ios_base::fmtflags mask)
	{	// manipulator to reset format flags
	return (_Smanip<ios_base::fmtflags>(&rsfun, mask));
	}

_CRTIMP2 _Smanip<ios_base::fmtflags>
	__cdecl setiosflags(ios_base::fmtflags mask)
	{	// manipulator to set format flags
	return (_Smanip<ios_base::fmtflags>(&sifun, mask));
	}

_CRTIMP2 _Smanip<int> __cdecl setbase(int base)
	{	// manipulator to set base
	return (_Smanip<int>(&sbfun, base));
	}

_CRTIMP2 _Smanip<streamsize> __cdecl setprecision(streamsize prec)
	{	// manipulator to set precision
	return (_Smanip<streamsize>(&spfun, prec));
	}

_CRTIMP2 _Smanip<streamsize> __cdecl setw(streamsize wide)
	{	// manipulator to set width
	return (_Smanip<streamsize>(&swfun, wide));
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\fiopen.cpp ===
// fiopen -- _Fiopen(const char *, ios_base::openmode)
#include <fstream>
_STD_BEGIN

_CRTIMP2 FILE *__cdecl _Fiopen(const char *filename, ios_base::openmode mode)
	{	// open a file
	static const char *mods[] =
		{	// fopen mode strings corresponding to valid[i]
		"r", "w", "w", "a", "rb", "wb", "wb", "ab",
		"r+", "w+", "a+", "r+b", "w+b", "a+b", 0};

	static const int valid[] =
		{	// valid combinations of open flags
		ios_base::in,
		ios_base::out,
		ios_base::out | ios_base::trunc,
		ios_base::out | ios_base::app,
		ios_base::in | ios_base::binary,
		ios_base::out | ios_base::binary,
		ios_base::out | ios_base::trunc | ios_base::binary,
		ios_base::out | ios_base::app | ios_base::binary,
		ios_base::in | ios_base::out,
		ios_base::in | ios_base::out | ios_base::trunc,
		ios_base::in | ios_base::out | ios_base::app,
		ios_base::in | ios_base::out | ios_base::binary,
		ios_base::in | ios_base::out | ios_base::trunc
			| ios_base::binary,
		ios_base::in | ios_base::out | ios_base::app
			| ios_base::binary,
		0};

	FILE *fp;
	int n;
	ios_base::openmode atendflag = mode & ios_base::ate;

	mode &= ~ios_base::ate;
	for (n = 0; valid[n] != 0 && valid[n] != mode; ++n)
		;	// look for a valid mode

	if (valid[n] == 0 || (fp = fopen(filename, mods[n])) == 0)
		return (0);	// no valid mode or open failed

	if (!atendflag || fseek(fp, 0, SEEK_END) == 0)
		return (fp);	// no need to seek to end, or seek succeeded

	fclose(fp);	// can't position at end
	return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\iosptrs.cpp ===
// iosptrs -- iostream object pointers for Microsoft
#include <iostream>
_STD_BEGIN

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

		// OBJECT DECLARATIONS
_CRTIMP2 istream *_Ptr_cin = 0;
_CRTIMP2 ostream *_Ptr_cout = 0;
_CRTIMP2 ostream *_Ptr_cerr = 0;
_CRTIMP2 ostream *_Ptr_clog = 0;

		// WIDE OBJECTS
_CRTIMP2 wistream *_Ptr_wcin = 0;
_CRTIMP2 wostream *_Ptr_wcout = 0;
_CRTIMP2 wostream *_Ptr_wcerr = 0;
_CRTIMP2 wostream *_Ptr_wclog = 0;
_STD_END

_C_STD_BEGIN
		// FINALIZATION CODE
_EXTERN_C
#define NATS	10	/* fclose, xgetloc, locks, facet free, etc. */

		/* static data */
static void (*atfuns[NATS])(void) = {0};
static size_t atcount = {NATS};

_CRTIMP2 void __cdecl _Atexit(void (__cdecl *pf)())
	{	// add to wrapup list
	if (atcount == 0)
		abort();	/* stack full, give up */
	else
		atfuns[--atcount] = pf;
	}
_END_EXTERN_C

struct _Init_atexit
	{	// controller for atexit processing
	~_Init_atexit()
		{	// process wrapup functions
		while (atcount < NATS)
			(*atfuns[atcount++])();
		}
	};

static std::_Init_locks initlocks;
static _Init_atexit init_atexit;

char _PJP_CPP_Copyright[] =
	"Copyright (c) 1992-2001 by P.J. Plauger,"
	" licensed by Dinkumware, Ltd."
	" ALL RIGHTS RESERVED.";
_C_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ios.cpp ===
// ios_base -- ios_base basic members
#include <new>
#include <xiosbase>
#include <xdebug>
_STD_BEGIN

#define NSTDSTR	8	/* cin, wcin, cout, wcout, cerr, wcerr, clog, wclog */

extern _CRTIMP2 const streamoff
	_BADOFF = -1;	// initialize constant for bad file offset
_CRTIMP2 fpos_t _Fpz = {0};	// initialize constant for beginning of file

int ios_base::_Index = 0;	// initialize source of unique indexes
bool ios_base::_Sync = true;	// initialize synchronization flag

static ios_base *stdstr[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold pointers to standard streams
static char stdopens[NSTDSTR + 2] =
	{0};	// [1, NSTDSTR] hold open counts for standard streams

void ios_base::clear(iostate state, bool reraise)
	{	// set state, possibly reraise exception
	_Mystate = (iostate)(state & _Statmask);
	if ((_Mystate & _Except) == 0)
		;
	else if (reraise)
		_RERAISE;
	else if (_Mystate & _Except & badbit)
		_THROW(failure, "ios_base::badbit set");
	else if (_Mystate & _Except & failbit)
		_THROW(failure, "ios_base::failbit set");
	else
		_THROW(failure, "ios_base::eofbit set");
	}

ios_base& ios_base::copyfmt(const ios_base& right)
	{	// copy format stuff
	if (this != &right)
		{	// copy all but _Mystate
		_Tidy();
		*_Ploc = *right._Ploc;
		_Fmtfl = right._Fmtfl;
		_Prec = right._Prec;
		_Wide = right._Wide;
		_Iosarray *p = right._Arr;

		for (_Arr = 0; p != 0; p = p->_Next)
			if (p->_Lo != 0 || p->_Vp != 0)
				{	// copy over nonzero array values
				iword(p->_Index) = p->_Lo;
				pword(p->_Index) = p->_Vp;
				}

		for (_Fnarray *q = right._Calls; q != 0; q = q->_Next)
			register_callback(q->_Pfn, q->_Index);	// copy callbacks

		_Callfns(copyfmt_event);	// call callbacks
		exceptions(right._Except);	// cause any throw at end
		}
	return (*this);
	}

locale ios_base::imbue(const locale& loc)
	{	// set locale to argument
	locale oldlocale = *_Ploc;
	*_Ploc = loc;
	_Callfns(imbue_event);
	return (oldlocale);
	}

void ios_base::register_callback(event_callback pfn, int idx)
	{	// register event handler
	_Calls = _NEW_CRT _Fnarray(idx, pfn, _Calls);
	}

ios_base::~ios_base()
	{	// destroy the object
	if (0 < _Stdstr && 0 < --stdopens[_Stdstr])
		return;
	_Tidy();
	_DELETE_CRT(_Ploc);
	}

void ios_base::_Callfns(event ev)
	{	// call all event handlers, reporting event
	for (_Fnarray *p = _Calls; p != 0; p = p->_Next)
		(*p->_Pfn)(ev, *this, p->_Index);
	}

ios_base::_Iosarray& ios_base::_Findarr(int idx)
	{	// locate or make a variable array element
	static _Iosarray stub(0, 0);
	_Iosarray *p, *q;

	if (idx < 0)
		{	// handle bad index
		setstate(badbit);
		return (stub);
		}

	for (p = _Arr, q = 0; p != 0; p = p->_Next)
		if (p->_Index == idx)
			return (*p);	// found element, return it
		else if (q == 0 && p->_Lo == 0 && p->_Vp == 0)
			q = p;	// found recycling candidate

	if (q != 0)
		{	// recycle existing element
		q->_Index = idx;
		return (*q);
		}

	_Arr = _NEW_CRT _Iosarray(idx, _Arr);	// make a new element
	return (*_Arr);
	}

void ios_base::_Addstd()
	{	// add standard stream to destructor list
	_Lockit lock(_LOCK_STREAM);

	for (; ++_Stdstr < NSTDSTR; )
		if (stdstr[_Stdstr] == 0 || stdstr[_Stdstr] == this)
			break;	// found a candidate

	stdstr[_Stdstr] = this;
	++stdopens[_Stdstr];
	}

void ios_base::_Init()
	{	// initialize a new ios_base
	_Ploc = _NEW_CRT locale;
	_Except = goodbit;
	_Fmtfl = skipws | dec;
	_Prec = 6;
	_Wide = 0;
	_Arr = 0;
	_Calls = 0;
	clear(goodbit);
	}

void ios_base::_Tidy()
	{	// discard storage for an ios_base
	_Callfns(erase_event);
	_Iosarray *q1, *q2;

	for (q1 = _Arr; q1 != 0; q1 = q2)
		q2 = q1->_Next, _DELETE_CRT(q1);	// delete array elements
	_Arr = 0;

	_Fnarray *q3, *q4;
	for (q3 = _Calls; q3 != 0; q3 = q4)
		q4 = q3->_Next, _DELETE_CRT(q3);	// delete callback elements
	_Calls = 0;
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\locale.cpp ===
// locale -- class locale member functions
#include <cstdlib>
#include <istream>
#include <locale>
#include <xdebug>
#include <dbgint.h>

_C_STD_BEGIN
_EXTERN_C
std::locale::_Locimp *__cdecl _Getgloballocale();

void __cdecl _Setgloballocale(void *);
_END_EXTERN_C
_C_STD_END

_STD_BEGIN

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

locale::locale(const locale& loc, const locale& other, category cat)
	: _Ptr(_NEW_CRT _Locimp(*loc._Ptr))
	{	// construct a locale by copying named facets
	_TRY_BEGIN
	_Locinfo _Lobj(loc._Ptr->_Catmask, loc._Ptr->_Name.c_str());
	_Locimp::_Makeloc(_Lobj._Addcats(cat & other._Ptr->_Catmask,
		other._Ptr->_Name.c_str()), cat, _Ptr, &other);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

locale::locale(const char *locname, category cat)
	: _Ptr(_NEW_CRT _Locimp)
	{	// construct a locale with named facets
	_TRY_BEGIN
	_Init();
	_Locinfo _Lobj(cat, locname);

	if (_Lobj._Getname().compare("*") == 0)
		_THROW(runtime_error, "bad locale name");
	_Locimp::_Makeloc(_Lobj, cat, _Ptr, 0);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

locale::locale(const locale& loc, const char *locname, category cat)
	: _Ptr(_NEW_CRT _Locimp(*loc._Ptr))
	{	// construct a locale by copying, replacing named facets
	_TRY_BEGIN
	_Locinfo _Lobj(loc._Ptr->_Catmask, loc._Ptr->_Name.c_str());
	bool _Hadname = _Lobj._Getname().compare("*") != 0;
	_Lobj._Addcats(cat, locname);

	if (_Hadname && _Lobj._Getname().compare("*") == 0)
		_THROW(runtime_error, "bad locale name");
	_Locimp::_Makeloc(_Lobj, cat, _Ptr, 0);
	_CATCH_ALL
	_DELETE_CRT(_Ptr->_Decref());
	_RERAISE;
	_CATCH_END
	}

_DEPRECATED locale& locale::_Addfac(facet *fac, size_t id, size_t catmask)
	{	// add a facet, copying on write
	if (1 < _Ptr->_Refs)
		{	// shared, make private copy before altering
		_Ptr->_Decref();
		_Ptr = _NEW_CRT _Locimp(*_Ptr);
		}
	_Ptr->_Addfac(fac, id);

	if (catmask != 0)
		_Ptr->_Name = "*";
	return (*this);
	}

locale __cdecl locale::global(const locale& loc)
	{	// change global locale
	locale _Oldglobal;
	_Lockit lock(_LOCK_LOCALE);
	locale::_Locimp *_Ptr = ::_Getgloballocale();

	if (_Ptr != loc._Ptr)
		{	// set new global locale
		_DELETE_CRT(_Ptr->_Decref());
		::_Setgloballocale(_Ptr = loc._Ptr);
		_Ptr->_Incref();
		category _Cmask = _Ptr->_Catmask & all;
		if (_Cmask == all)
			setlocale(LC_ALL, _Ptr->_Name.c_str());
		else
			for (int catindex = 0; catindex <= _X_MAX; ++catindex)
				if ((_CATMASK(catindex) & _Cmask) != 0)
					setlocale(catindex, _Ptr->_Name.c_str());
		}
	return (_Oldglobal);
	}

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

typedef ctype<char> _T1;
typedef num_get<char, _Initer> _T2;
typedef num_put<char, _Outiter> _T3;
typedef numpunct<char> _T4;
// others moved to wlocale and xlocale to ease subsetting
typedef codecvt<char, char, mbstate_t> _Tc1;

_TEMPLATE_STAT locale::id ctype<char>::id;


locale::_Locimp *__cdecl locale::_Locimp::_Makeloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup a new locale
	ADDFAC(_T1, cat, ptrimp, ptrloc);
	ADDFAC(_T2, cat, ptrimp, ptrloc);
	ADDFAC(_T3, cat, ptrimp, ptrloc);
	ADDFAC(_T4, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tc1, cat, ptrimp, ptrloc);

	_Locimp::_Makexloc(lobj, cat, ptrimp, ptrloc);
	_Locimp::_Makewloc(lobj, cat, ptrimp, ptrloc);
#ifdef _NATIVE_WCHAR_T_DEFINED
	_Locimp::_Makeushloc(lobj, cat, ptrimp, ptrloc);
#endif
	ptrimp->_Catmask |= cat;
	ptrimp->_Name = lobj._Getname();
	return (ptrimp);
	}

locale::_Locimp::_Locimp(const locale::_Locimp& imp)
	: locale::facet(1), _Facetvec(0), _Facetcount(imp._Facetcount),
		_Catmask(imp._Catmask), _Xparent(imp._Xparent), _Name(imp._Name)
	{	// construct a _Locimp from a copy
	if (&imp == _Clocptr)
		_Makeloc(_Locinfo(), locale::all, this, 0);
	else
		{	// lock to keep facets from disappearing
		_Lockit lock(_LOCK_LOCALE);
		if (0 < _Facetcount)
			{	// copy over nonempty facet vector
			if ((_Facetvec = (locale::facet **)_malloc_crt(
				_Facetcount * sizeof (locale::facet *))) == 0)
				_Nomemory();
			for (size_t count = _Facetcount; 0 < count; )
				{	// copy over facet pointers
				locale::facet *ptrfac = imp._Facetvec[--count];
				if ((_Facetvec[count] = ptrfac) != 0)
					ptrfac->_Incref();
				}
			}
		}
	}

void locale::_Locimp::_Addfac(locale::facet *ptrfac, size_t id)
	{	// add a facet to a locale
	_Lockit lock(_LOCK_LOCALE);
	const size_t MINCAT = 40;	// minimum number of facets in a locale

	if (_Facetcount <= id)
		{	// make facet vector larger
		size_t count = id + 1;
		if (count < MINCAT)
			count = MINCAT;
		locale::facet **ptrnewvec = (locale::facet **)_realloc_crt(_Facetvec,
			count * sizeof (locale::facet **));
		if (ptrnewvec == 0)
			_Nomemory();

		_Facetvec = ptrnewvec;
		for (; _Facetcount < count; ++_Facetcount)
			_Facetvec[_Facetcount] = 0;
		}

	ptrfac->_Incref();
	if (_Facetvec[id] != 0)
		_DELETE_CRT(_Facetvec[id]->_Decref());
	_Facetvec[id] = ptrfac;
	}

_CRTIMP2 _Locinfo::_Locinfo(int cat, const char *locname)
	: _Lock(_LOCK_LOCALE)
	{	// capture a named locale
	_Oldlocname = setlocale(LC_ALL, 0);
	_Addcats(cat, locname);
	}

_CRTIMP2 _Locinfo& _Locinfo::_Addcats(int cat, const char *locname)
	{	// merge in another named locale
	const char *oldlocname = 0;
	if (locname[0] == '*' && locname[1] == '\0')
		;
	else if (cat == 0)
		oldlocname = setlocale(LC_ALL, 0);
	else if (cat == _M_ALL)
		oldlocname = setlocale(LC_ALL, locname);
	else
		{	// alter selected categories
		for (int catindex = 0; catindex <= _X_MAX; ++catindex)
			if ((_CATMASK(catindex) & cat) != 0)
				setlocale(catindex, locname);
		oldlocname = setlocale(LC_ALL, locname);
		}
	if (oldlocname == 0)
		_Newlocname = "*";
	else if (_Newlocname.compare("*") != 0)
		_Newlocname = oldlocname;
	return (*this);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\iostream.cpp ===
// iostream -- ios::Init members, dummy for MS
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
int ios_base::Init::_Init_cnt = -1;

_CRTIMP2 ios_base::Init::Init()
	{	// initialize standard streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2 ios_base::Init::~Init()
	{	// flush standard streams last time
	if (--_Init_cnt == 0)
		{	// flush standard streams
		if (_Ptr_cerr != 0)
			_Ptr_cerr->flush();
		if (_Ptr_clog != 0)
			_Ptr_clog->flush();
		if (_Ptr_cout != 0)
			_Ptr_cout->flush();
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newaop.cpp ===
// newaop -- operator new[](size_t) REPLACEABLE
#include <new>

 #if !_VC6SP2 || _DLL
void *__cdecl operator new[](size_t count) _THROW1(std::bad_alloc)
	{	// try to allocate count bytes for an array
	return (operator new(count));
	}
 #endif /* !_VC6SP2 || _DLL */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newaop2_s.cpp ===
//  newaop2_s.cpp - version of newaop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newaop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newop2_s.cpp ===
//  newop2_s.cpp - version of newop2.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newop2.cpp ===
// newop2 operator new(size_t, const nothrow_t&) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t count) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__cdecl operator new(size_t count,
	const std::nothrow_t&) _THROW0()
	{	// try to allocate count bytes
	void *p;
	_TRY_BEGIN
	while ((p = malloc(count)) == 0)
		{	// buy more memory or return null pointer
		if (_callnewh(count) == 0)
			break;
		}
	_CATCH_ALL
	p = 0;
	_CATCH_END
	return (p);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newop.cpp ===
// newop operator new(size_t) for Microsoft C++
#include <cstdlib>
#include <new>

_C_LIB_DECL
int __cdecl _callnewh(size_t size) _THROW1(_STD bad_alloc);
_END_C_LIB_DECL

void *__cdecl operator new(size_t size) _THROW1(_STD bad_alloc)
	{	// try to allocate size bytes
	void *p;
	while ((p = malloc(size)) == 0)
		if (_callnewh(size) == 0)
			_STD _Nomemory();
	return (p);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V2.3:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newaop2.cpp ===
// newaop2 -- operator new[](size_t, const nothrow_t&) REPLACEABLE
#include <new>

void *__cdecl operator new[](::size_t count, const std::nothrow_t& x)
	_THROW0()
	{	// try to allocate count bytes for an array
	return (operator new(count, x));
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\locale0.cpp ===
// locale0 -- class locale basic member functions
#include <climits>
#include <locale>
#include <xdebug>

struct _Fac_node
	{	// node for lazy facet recording
	_Fac_node(_Fac_node *_Nextarg, std::locale::facet *_Facptrarg)
		: _Next(_Nextarg), _Facptr(_Facptrarg)
		{	// construct a node with value
		}

	~_Fac_node()
		{	// destroy a facet
		_DELETE_CRT(_Facptr->_Decref());
		}

	_Fac_node *_Next;
	std::locale::facet *_Facptr;
	};

static _Fac_node *_Fac_head = 0;

_C_STD_BEGIN
_EXTERN_C
void __cdecl _Fac_tidy()
	{	// destroy lazy facets
	std::_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	for (; _Fac_head != 0; )
		{	// destroy a lazy facet node
		_Fac_node *nodeptr = _Fac_head;
		_Fac_head = nodeptr->_Next;
		_DELETE_CRT(nodeptr);
		}
	}

void __cdecl _Deletegloballocale(void *ptr)
	{	// delete a global locale reference
	std::locale::_Locimp *locptr = *(std::locale::_Locimp **)ptr;
	if (locptr != 0)
		_DELETE_CRT(locptr->_Decref());
	}

static std::locale::_Locimp *global_locale = 0;	// pointer to current locale

static void __cdecl tidy_global()
	{	// delete static global locale reference
	std::_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	_Deletegloballocale(&global_locale);
	}

std::locale::_Locimp *__cdecl _Getgloballocale()
	{	// return pointer to current locale
	return (global_locale);
	}

void __cdecl _Setgloballocale(void *ptr)
	{	// alter pointer to current locale
	static bool registered = false;

	if (!registered)
		{	// register cleanup first time
		registered = true;
		::_Atexit(&tidy_global);
		}
	global_locale = (std::locale::_Locimp *)ptr;
	}
_END_EXTERN_C
_C_STD_END

_STD_BEGIN

 #pragma warning(disable: 4786)

static locale classic_locale(_Noinit);	// "C" locale object, uninitialized
locale::_Locimp *locale::_Locimp::_Clocptr = 0;	// pointer to classic_locale
int locale::id::_Id_cnt = 0;	// unique id counter for facets

_TEMPLATE_STAT const size_t ctype<char>::table_size =
	1 << CHAR_BIT;	// size of ctype mapping table, typically 256

locale::locale() _THROW0()
	: _Ptr(_Init())
	{	// construct from current locale
	::_Getgloballocale()->_Incref();
	}

const locale& __cdecl locale::classic()
	{	// get reference to "C" locale
	_Init();
	return (classic_locale);
	}

locale __cdecl locale::empty()
	{	// make empty transparent locale
	_Init();
	return (locale(_NEW_CRT _Locimp(true)));
	}

const locale::facet *locale::_Getfacet(size_t id) const
	{	// look up a facet in locale object
	const facet *facptr = id < _Ptr->_Facetcount
		? _Ptr->_Facetvec[id] : 0;	// null if id off end
	if (facptr != 0 || !_Ptr->_Xparent)
		return (facptr);	// found facet or not transparent, return pointer
	else
		{	// look in current locale
		locale::_Locimp *_Ptr = ::_Getgloballocale();
		return (id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[id]	// get from current locale
			: 0);	// no entry in current locale
		}
	}

bool locale::operator==(const locale& loc) const
	{	// compare locales for equality
	return (_Ptr == loc._Ptr
		|| name().compare("*") != 0 && name().compare(loc.name()) == 0);
	}

locale::_Locimp *__cdecl locale::_Init()
	{	// setup global and "C" locales
	locale::_Locimp *_Ptr = ::_Getgloballocale();
	if (_Ptr == 0)
		{	// lock and test again
		_Lockit lock(_LOCK_LOCALE);	// prevent double initialization

		_Ptr = ::_Getgloballocale();
		if (_Ptr == 0)
			{	// create new locales
			::_Setgloballocale(_Ptr = _NEW_CRT _Locimp);
			_Ptr->_Catmask = all;	// set current locale to "C"
			_Ptr->_Name = "C";

			_Locimp::_Clocptr = _Ptr;	// set classic to match
			_Locimp::_Clocptr->_Incref();
			new (&classic_locale) locale(_Locimp::_Clocptr);
			}
		}
	return (_Ptr);
	}

void locale::facet::_Register()
	{	// queue up lazy facet for destruction
	if (_Fac_head == 0)
		::_Atexit(&_Fac_tidy);
	
	_Fac_head = _NEW_CRT _Fac_node(_Fac_head, this);
	}

locale::_Locimp::_Locimp(bool transparent)
	: locale::facet(1), _Facetvec(0), _Facetcount(0),
		_Catmask(none), _Xparent(transparent), _Name("*")
	{	// construct an empty _Locimp
	}

locale::_Locimp::~_Locimp()
	{	// destruct a _Locimp
	_Lockit lock(_LOCK_LOCALE);	// prevent double delete
	for (size_t count = _Facetcount; 0 < count; )
		if (_Facetvec[--count] != 0)
			_DELETE_CRT(_Facetvec[count]->_Decref());
	free(_Facetvec);
	}

_Locinfo::_Locinfo(const char *locname)
	: _Lock(_LOCK_LOCALE)
	{	// switch to a named locale
	_Oldlocname = setlocale(LC_ALL, 0);
	_Newlocname = locname == 0
		|| (locname = setlocale(LC_ALL, locname)) == 0
			? "*" : locname;
	}

_Locinfo::~_Locinfo()
	{	// destroy a _Locinfo object, revert locale
	if (0 < _Oldlocname.size())
		setlocale(LC_ALL, _Oldlocname.c_str());
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newaop_s.cpp ===
//  newaop_s.cpp - version of newaop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newaop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\newop_s.cpp ===
//  newop_s.cpp - version of newop.cpp for DLL library

#undef	CRTDLL2
#define	CRTDLL

#include "newop.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\nomemory.cpp ===
// nomemory -- report out of memory
#include <new>
_STD_BEGIN

_CRTIMP2 void __cdecl _Nomemory()
	{	// report out of memory
	static const bad_alloc nomem;
	_RAISE(nomem);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\nothrow.cpp ===
// nothrow -- define nothrow object
#include <new>
_STD_BEGIN

const nothrow_t nothrow = nothrow_t();	// define nothrow
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\raisehan.cpp ===
// raisehan -- pointer to raise handler
#include <exception>
_STD_BEGIN

_CRTIMP2 _Prhand _Raise_handler = 0;	// define raise handler pointer as null

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ushcerr.cpp ===
// wcerr -- initialize standard wide error stream
// This wcerr is unsigned short version of wcerr
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcerr.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ushcin.cpp ===
// wcin -- initialize standard wide error stream
// This wcin is unsigned short version of wcin
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcin.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\uncaught.cpp ===
// uncaught -- uncaught_exception for Microsoft
 #if 1300 <= _MSC_VER
  #include <eh.h>
  #include <exception>
_STD_BEGIN

_CRTIMP2 bool __cdecl uncaught_exception()
	{	// report if handling a throw
	return (__uncaught_exception());
	}

_STD_END
 #else /* 1300 <= _MSC_VER */
  #include <exception>
_STD_BEGIN

_CRTIMP2 bool __cdecl uncaught_exception()
	{	// report if handling a throw -- dummy
	return (false);
	}

_STD_END
 #endif /* 1300 <= _MSC_VER */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\stdthrow.cpp ===
// throw -- terminate on thrown exception REPLACEABLE
#include <cstdio>
#include <cstdlib>
#include <exception>
_STD_BEGIN

_CRTIMP2 void __cdecl _Throw(const exception& ex)
	{	// report error and die
	const char *s2 = ex.what();
	fputs("exception: ", _cpp_stderr);
	fputs(s2 != 0 ? s2 : "unknown", _cpp_stderr);
	fputs("\n", _cpp_stderr);
	abort();
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\stdhndlr.cpp ===
// handler.cpp -- set_new_handler for Microsoft
#include <new>

typedef int (__cdecl *new_hand)(size_t);
new_hand _set_new_handler(new_hand);

_STD_BEGIN
static new_handler _New_handler;

int __cdecl _New_handler_interface(size_t) _THROW1(bad_alloc)
	{	// interface to existing Microsoft _callnewh mechanism
	_New_handler();
	return (1);
	}

_CRTIMP2 new_handler __cdecl set_new_handler(new_handler pnew) _THROW0()
	{	// remove current handler
	_Lockit _Lock(_LOCK_MALLOC);	// lock thread to ensure atomicity
	new_handler pold = _New_handler;
	_New_handler = pnew;
	_set_new_handler(pnew ? _New_handler_interface : 0);
	return (pold);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\strstrea.cpp ===
// strstreambuf -- strstreambuf basic members
#include <climits>
#include <cstdlib>
#include <cstring>
#include <strstream>
#include <xdebug>

 #pragma warning(disable:4244 4097)
_STD_BEGIN

_CRTIMP2 istrstream::~istrstream()
	{	// destroy an istrstream
	}

_CRTIMP2 ostrstream::ostrstream(char *ptr, streamsize count,
	ios_base::openmode mode)
	: ostream(&_Mysb),
	_Mysb(ptr, count, ptr == 0 || (mode & app) == 0 ? ptr : ptr + strlen(ptr))
	{	// construct with [ptr, ptr + count)
	}

_CRTIMP2 ostrstream::~ostrstream()
	{	// destroy an ostrstream
	}

_CRTIMP2 strstream::strstream(char *ptr, streamsize count,
	ios_base::openmode mode)
	: iostream(&_Mysb),
	_Mysb(ptr, count, ptr == 0 || (mode & app) == 0 ? ptr : ptr + strlen(ptr))
	{	// construct with [ptr, ptr + count)
	}

_CRTIMP2 strstream::~strstream()
	{	// destroy a strstream
	}

_CRTIMP2 strstreambuf::~strstreambuf()
	{	// destroy a strstreambuf
	_Tidy();
	}

_CRTIMP2 void strstreambuf::freeze(bool freezeit)
	{	// freeze or unfreeze writing
	if (freezeit && !(_Strmode & _Frozen))
		{	// disable writing
		_Strmode |= _Frozen;
		_Pendsave = epptr();
		setp(pbase(), pptr(), eback());
		}
	else if (!freezeit && _Strmode & _Frozen)
		{	// re-enable writing
		_Strmode &= ~_Frozen;
		setp(pbase(), pptr(), _Pendsave);
		}
	}

_CRTIMP2 int strstreambuf::overflow(int meta)
	{	// try to extend write area
	if (meta == EOF)
		return (0);	// nothing to write
	else if (pptr() != 0 && pptr() < epptr())
		return ((unsigned char)(*_Pninc() = (unsigned long)meta));	// room in buffer
	else if (!(_Strmode & _Dynamic)
		|| _Strmode & (_Constant | _Frozen))
		return (EOF);	// can't extend
	else
		{	// okay to extend
		int oldsize = gptr() == 0 ? 0 : epptr() - eback();
		int newsize = oldsize;
		int inc = newsize / 2 < _Minsize
			? _Minsize : newsize / 2;	// grow by 50 per cent if possible
		_Minsize = _MINSIZE;	// back to default for future growth
		char *ptr = 0;

		while (0 < inc && INT_MAX - inc < newsize)
			inc /= 2;	// reduce growth increment if too big
		if (0 < inc)
			{	// room to grow, increase size
			newsize += inc;
			ptr = _Palloc != 0 ? (char *)(*_Palloc)(newsize)
				: _NEW_CRT char[newsize];
			}
		if (ptr == 0)
			return (EOF);	// couldn't grow, return failure

		if (0 < oldsize)
			memcpy(ptr, eback(), oldsize);	// copy existing buffer
		if (!(_Strmode & _Allocated))
			;	// no buffer to free
		else if (_Pfree != 0)
			(*_Pfree)(eback());	// free with function call
		else
			_DELETE_CRT_VEC(eback());	// free by deleting array

		_Strmode |= _Allocated;
		if (oldsize == 0)
			{	// set up new buffer
			_Seekhigh = ptr;
			setp(ptr, ptr + newsize);
			setg(ptr, ptr, ptr);
			}
		else
			{	// revise old pointers
			_Seekhigh = _Seekhigh - eback() + ptr;
			setp(pbase() - eback() + ptr, pptr() - eback() + ptr,
				ptr + newsize);
			setg(ptr, gptr() - eback() + ptr, pptr() + 1);
			}

		return ((unsigned char)(*_Pninc() = (unsigned long)meta));
		}
	}

_CRTIMP2 int strstreambuf::pbackfail(int meta)
	{	// try to putback a character
	if (gptr() == 0 || gptr() <= eback() || meta != EOF
			&& (unsigned char)meta != (unsigned char)gptr()[-1]
			&& _Strmode & _Constant)
		return (EOF);	// can't put it back
	else
		{	// safe to back up
		gbump(-1);
		return (meta == EOF ? 0 : (unsigned char)(*gptr() = (unsigned long)meta));
		}
	}

_CRTIMP2 int strstreambuf::underflow()
	{	// read if read position available
	if (gptr() == 0)
		return (EOF);	// no read buffer
	else if (gptr() < egptr())
		return ((unsigned char)*gptr());	// char in buffer, read it
	else if (pptr() == 0 || pptr() <= gptr() && _Seekhigh <= gptr())
		return (EOF);	// no write buffer to read
	else
		{	// update _Seekhigh and expand read region
		if (_Seekhigh < pptr())
			_Seekhigh = pptr();
		setg(eback(), gptr(), _Seekhigh);
		return ((unsigned char)*gptr());
		}
	}

_CRTIMP2 streampos strstreambuf::seekoff(streamoff off,
	ios_base::seekdir way, ios_base::openmode which)
	{	// seek by specified offset
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();	// update high water mark

	if (which & ios_base::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (way == ios_base::end)
			off += _Seekhigh - eback();	// seek from end
		else if (way == ios_base::cur
			&& !(which & ios_base::out))
			off += gptr() - eback();	// seek from current position
		else if (way != ios_base::beg || off == _BADOFF)
			off = _BADOFF;	// invalid seek
		if (0 <= off && off <= _Seekhigh - eback())
			{	// seek from beginning, set one or two pointers
			gbump(eback() - gptr() + off);
			if (which & ios_base::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;	// invalid seek from beginning
		}
	else if (which & ios_base::out && pptr() != 0)
		{	// set only output pointer
		if (way == ios_base::end)
			off += _Seekhigh - eback();	// seek from end
		else if (way == ios_base::cur)
			off += pptr() - eback();	// seek from current position
		else if (way != ios_base::beg || off == _BADOFF)
			off = _BADOFF;	// invalid seek
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);	// seek from beginning
		else
			off = _BADOFF;	// invalid seek from beginning
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 streampos strstreambuf::seekpos(streampos sp,
		ios_base::openmode which)
	{	// seek to memorized position
	streamoff off = (streamoff)sp;
	if (pptr() != 0 && _Seekhigh < pptr())
		_Seekhigh = pptr();	// update high water mark

	if (off == _BADOFF)
		;	// invalid seek
	else if (which & ios_base::in && gptr() != 0)
		{	// set input (and maybe output) pointer
		if (0 <= off && off <= _Seekhigh - eback())
			{	// set valid offset
			gbump(eback() - gptr() + off);
			if (which & ios_base::out && pptr() != 0)
				setp(pbase(), gptr(), epptr());
			}
		else
			off = _BADOFF;	// offset invalid, don't seek
		}
	else if (which & ios_base::out && pptr() != 0)
		{	// set output pointer
		if (0 <= off && off <= _Seekhigh - eback())
			pbump(eback() - pptr() + off);
		else
			off = _BADOFF;	// offset invalid, don't seek
		}
	else	// nothing to set
		off = _BADOFF;
	return (streampos(off));
	}

_CRTIMP2 void strstreambuf::_Init(streamsize count, char *gp, char *pp,
	_Strstate mode)
	{	// initialize with possibly static buffer
	streambuf::_Init();
	_Minsize = _MINSIZE;
	_Pendsave = 0;
	_Seekhigh = 0;
	_Palloc = 0;
	_Pfree = 0;
	_Strmode = mode;

	if (gp == 0)
		{	// make dynamic
		_Strmode |= _Dynamic;
		if (_Minsize < count)
			_Minsize = count;
		}
	else
		{	// make static
		int size = count < 0 ? INT_MAX : count == 0 ? (int)strlen(gp) : count;
		_Seekhigh = gp + size;

		if (pp == 0)
			setg(gp, gp, gp + size);	// set read pointers only
		else
			{	// make writable too
			if (pp < gp)
				pp = gp;
			else if (gp + size < pp)
				pp = gp + size;
			setp(pp, gp + size);
			setg(gp, gp, pp);
			}
		}
	}

_CRTIMP2 void strstreambuf::_Tidy()
	{	// free any allocated storage
	if ((_Strmode & (_Allocated | _Frozen)) != _Allocated)
		;	// no buffer to free
	else if (_Pfree != 0)
		(*_Pfree)(eback());	// free with function call
	else
		_DELETE_CRT_VEC(eback());	// free by deleting array

	_Seekhigh = 0;
	_Strmode &= ~(_Allocated | _Frozen);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\string.cpp ===
// string -- template string support functions
#include <istream>
_STD_BEGIN


_CRTIMP2 void _String_base::_Xlen() const
	{	// report a length_error
	_THROW(length_error, "string too long");
	}

_CRTIMP2 void _String_base::_Xran() const
	{	// report an out_of_range error
	_THROW(out_of_range, "invalid string position");
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\sources.inc ===
MAJORCOMP=crt
MINORCOMP=stdcpp

TARGETNAME=stdcpp

!INCLUDE ..\..\crt32.inc

INCLUDES=$(INCLUDES);$(CRTBASE)\crtw32\stdhpp

C_DEFINES=$(C_DEFINES) /D_BUILD_LIBCP /FIlibcpver.h

SOURCES= \
    ..\cerr.cpp      \
    ..\cin.cpp       \
    ..\clog.cpp      \
    ..\cout.cpp      \
    ..\delaop2.cpp   \
    ..\delop2.cpp    \
    ..\fiopen.cpp    \
    ..\iomanip.cpp   \
    ..\ios.cpp       \
    ..\iosptrs.cpp   \
    ..\iostream.cpp  \
    ..\locale.cpp    \
    ..\locale0.cpp   \
    ..\newaop.cpp    \
    ..\newaop2.cpp   \
    ..\newop.cpp     \
    ..\newop2.cpp    \
    ..\nomemory.cpp  \
    ..\nothrow.cpp   \
    ..\raisehan.cpp  \
    ..\stdhndlr.cpp  \
    ..\stdthrow.cpp  \
    ..\string.cpp    \
    ..\strstrea.cpp  \
    ..\uncaught.cpp  \
    ..\ushcerr.cpp   \
    ..\ushcout.cpp   \
    ..\ushcin.cpp    \
    ..\ushclog.cpp   \
    ..\ushiostr.cpp  \
    ..\wcerr.cpp     \
    ..\wcin.cpp      \
    ..\wclog.cpp     \
    ..\wcout.cpp     \
    ..\wctrans.c     \
    ..\wctype.c      \
    ..\wiostrea.cpp  \
    ..\wlocale.cpp   \
    ..\xcosh.c       \
    ..\xdateord.cpp  \
    ..\xdebug.cpp    \
    ..\xdnorm.c      \
    ..\xdscale.c     \
    ..\xdtest.c      \
    ..\xexp.c        \
    ..\xfcosh.c      \
    ..\xfdnorm.c     \
    ..\xfdscale.c    \
    ..\xfdtest.c     \
    ..\xferaise.c    \
    ..\xfexp.c       \
    ..\xfsinh.c      \
    ..\xfvalues.c    \
    ..\xgetwctype.c  \
    ..\xlcosh.c      \
    ..\xldnorm.c     \
    ..\xldscale.c    \
    ..\xldtest.c     \
    ..\xlexp.c       \
    ..\xlocale.cpp   \
    ..\xlock.cpp     \
    ..\xlpoly.c      \
    ..\xlsinh.c      \
    ..\xlvalues.c    \
    ..\xmbtowc.c     \
    ..\xmtx.c        \
    ..\xmutex.cpp    \
    ..\xpoly.c       \
    ..\xsinh.c       \
    ..\xstod.c       \
    ..\xstrcoll.c    \
    ..\xstrxfrm.c    \
    ..\xtowlower.c   \
    ..\xtowupper.c   \
    ..\xvalues.c     \
    ..\xwcscoll.c    \
    ..\xwcsxfrm.c    \
    ..\xwctomb.c     \
    ..\_tolower.c    \
    ..\_toupper.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ushclog.cpp ===
// wclog -- initialize standard wide error stream
// This wclog is unsigned short version of wclog
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wclog.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wclog.cpp ===
// wclog -- initialize standard wide log stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks  initlocks;
static wfilebuf wflog(_cpp_stderr);
_CRTIMP2 wostream wclog(&wflog);

		// INITIALIZATION CODE
struct _Init_wclog
	{	// ensures that wclog is initialized
	_Init_wclog()
		{	// initialize wclog
		_Ptr_wclog = &wclog;
		wclog.tie(_Ptr_wcout);
		}
	};
static _Init_wclog init_wclog;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wcin.cpp ===
// wcin -- initialize standard wide input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wfin(_cpp_stdin);
_CRTIMP2 wistream wcin(&wfin);

		// INITIALIZATION CODE
struct _Init_wcin
	{	// ensures that wcin is initialized
	_Init_wcin()
		{	// initialize wcin
		_Ptr_wcin = &wcin;
		wcin.tie(_Ptr_wcout);
		}
	};
static _Init_wcin init_wcin;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ushiostr.cpp ===
// ushiostream -- _UShinit members, dummy for Microsoft
// unsigned short version for wiostram
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>

_STD_BEGIN
_CRTIMP2 wistream *_Ptr_wcin = 0;
_CRTIMP2 wostream *_Ptr_wcout = 0;
_CRTIMP2 wostream *_Ptr_wcerr = 0;
_CRTIMP2 wostream *_Ptr_wclog = 0;
_STD_END
#include "wiostrea.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wcout.cpp ===
// wcout -- initialize standard wide output stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wfout(_cpp_stdout);
_CRTIMP2 wostream wcout(&wfout);

		// INITIALIZATION CODE
struct _Init_wcout
	{	// ensures that wcout is initialized
	_Init_wcout()
		{	// initialize wcout
		_Ptr_wcout = &wcout;
		if (_Ptr_wcin != 0)
			_Ptr_wcin->tie(_Ptr_wcout);
		if (_Ptr_wcerr != 0)
			_Ptr_wcerr->tie(_Ptr_wcout);
		if (_Ptr_wclog != 0)
			_Ptr_wclog->tie(_Ptr_wcout);
		}
	};
static _Init_wcout init_wcout;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\ushcout.cpp ===
// wcout -- initialize standard wide error stream
// This wcout is unsigned short version of wcout
#ifdef _NATIVE_WCHAR_T_DEFINED
#include <fstream>
#include <istream>
#define wistream    ushistream
#define wostream    ushostream
#define wfilebuf    ushfilebuf
#define _Init_wcerr _Init_ushcerr
#define _Init_wcout _Init_ushcout
#define _Init_wclog _Init_ushclog
#define _Init_wcin  _Init_ushcin
#define _Winit      _UShinit
#include <iostream>
#include "wcout.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wctrans.c ===
/* towctrans/wctrans functions for Microsoft */
#include <string.h>
#ifndef _YVALS
#include <yvals.h>
#endif
 #pragma warning(disable:4244)

 #ifndef _WCTYPE_T_DEFINED
typedef wchar_t wint_t;
typedef wchar_t wctype_t;
 #endif

typedef wchar_t wctrans_t;
_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"tolower", 0},
	{"toupper", 1},
	{(const char *)0, 0}};

_CRTIMP2 wint_t (__cdecl towctrans)(wint_t c, wctrans_t val)
	{	/* translate wide character */
	return (val == 1 ? towupper(c) : towlower(c));
	}

_CRTIMP2 wctrans_t (__cdecl wctrans)(const char *name)
	{	/* find translation for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wcerr.cpp ===
// wcerr -- initialize standard wide error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

_STD_BEGIN
		// OBJECT DECLARATIONS
static _Init_locks initlocks;
static wfilebuf wferr(_cpp_stderr);
_CRTIMP2 wostream wcerr(&wferr);

		// INITIALIZATION CODE
struct _Init_wcerr
	{	// ensures that wcerr is initialized
	_Init_wcerr()
		{	// initialize wcerr
		_Ptr_wcerr = &wcerr;
		wcerr.tie(_Ptr_wcout);
		wcerr.setf(ios_base::unitbuf);
		}
	};
static _Init_wcerr init_wcerr;

_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wiostrea.cpp ===
// wiostream -- _Winit members, dummy for Microsoft
#include <iostream>
_STD_BEGIN

		// OBJECT DECLARATIONS
int _Winit::_Init_cnt = -1;

_CRTIMP2 _Winit::_Winit()
	{	// initialize standard wide streams first time
	if (0 <= _Init_cnt)
		++_Init_cnt;
	else
		_Init_cnt = 1;
	}

_CRTIMP2 _Winit::~_Winit()
	{	// flush standard wide streams last time
	if (--_Init_cnt == 0)
		{	// flush standard wide streams
		if (_Ptr_wcout != 0)
			_Ptr_wcout->flush();
		if (_Ptr_wcerr != 0)
			_Ptr_wcerr->flush();
		if (_Ptr_wclog != 0)
			_Ptr_wclog->flush();
		}
_STD_END
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xcosh.c ===
/* _Cosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double __cdecl _Cosh(double x, double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			return (y * (x + 0.25 / x));
			}
		switch (_Exp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wlocale.cpp ===
// wlocale -- class locale wide member functions
#include <istream>
#include <locale>
#include <xdebug>
_STD_BEGIN

 #pragma warning(disable: 4786)

typedef char_traits<wchar_t> _Wtraits;
typedef istreambuf_iterator<wchar_t, _Wtraits> _Winiter;
typedef ostreambuf_iterator<wchar_t, _Wtraits> _Woutiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef ctype<wchar_t> _Tw1;
typedef num_get<wchar_t, _Winiter> _Tw2;
typedef num_put<wchar_t, _Woutiter> _Tw3;
typedef numpunct<wchar_t> _Tw4;
typedef collate<wchar_t> _Tw5;
typedef messages<wchar_t> _Tw6;
typedef money_get<wchar_t, _Winiter> _Tw7;
typedef money_put<wchar_t, _Woutiter> _Tw9;
typedef moneypunct<wchar_t, false> _Tw11;
typedef moneypunct<wchar_t, true> _Tw12;
typedef time_get<wchar_t, _Winiter> _Tw13;
typedef time_put<wchar_t, _Woutiter> _Tw14;
//....
typedef codecvt<wchar_t, char, mbstate_t> _Twc1;

_TEMPLATE_STAT locale::id ctype<wchar_t>::id;
_TEMPLATE_STAT locale::id codecvt<wchar_t, char, mbstate_t>::id;
_TEMPLATE_STAT locale::id time_put<wchar_t>::id;

void __cdecl locale::_Locimp::_Makewloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tw1, cat, ptrimp, ptrloc);
	ADDFAC(_Tw2, cat, ptrimp, ptrloc);
	ADDFAC(_Tw3, cat, ptrimp, ptrloc);
	ADDFAC(_Tw4, cat, ptrimp, ptrloc);
	ADDFAC(_Tw5, cat, ptrimp, ptrloc);
	ADDFAC(_Tw6, cat, ptrimp, ptrloc);
	ADDFAC(_Tw7, cat, ptrimp, ptrloc);
	ADDFAC(_Tw9, cat, ptrimp, ptrloc);
	ADDFAC(_Tw11, cat, ptrimp, ptrloc);
	ADDFAC(_Tw12, cat, ptrimp, ptrloc);
	ADDFAC(_Tw13, cat, ptrimp, ptrloc);
	ADDFAC(_Tw14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Twc1, cat, ptrimp, ptrloc);
	}

#ifdef _NATIVE_WCHAR_T_DEFINED
typedef char_traits<unsigned short> _UShtraits;
typedef istreambuf_iterator<unsigned short, _UShtraits> _UShiniter;
typedef ostreambuf_iterator<unsigned short, _UShtraits> _UShoutiter;


// moved from locale to ease subsetting
typedef ctype<unsigned short> _Tush1;
typedef num_get<unsigned short, _UShiniter> _Tush2;
typedef num_put<unsigned short, _UShoutiter> _Tush3;
typedef numpunct<unsigned short> _Tush4;
typedef collate<unsigned short> _Tush5;
typedef messages<unsigned short> _Tush6;
typedef money_get<unsigned short, _UShiniter> _Tush7;
typedef money_put<unsigned short, _UShoutiter> _Tush9;
typedef moneypunct<unsigned short, false> _Tush11;
typedef moneypunct<unsigned short, true> _Tush12;
typedef time_get<unsigned short, _UShiniter> _Tush13;
typedef time_put<unsigned short, _UShoutiter> _Tush14;
//....
typedef codecvt<unsigned short, char, mbstate_t> _Tushc1;

_TEMPLATE_STAT locale::id ctype<unsigned short>::id;
_TEMPLATE_STAT locale::id codecvt<unsigned short, char, mbstate_t>::id;
_TEMPLATE_STAT locale::id time_put<unsigned short>::id;

void __cdecl locale::_Locimp::_Makeushloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup wide part of a new locale
	ADDFAC(_Tush1, cat, ptrimp, ptrloc);
	ADDFAC(_Tush2, cat, ptrimp, ptrloc);
	ADDFAC(_Tush3, cat, ptrimp, ptrloc);
	ADDFAC(_Tush4, cat, ptrimp, ptrloc);
	ADDFAC(_Tush5, cat, ptrimp, ptrloc);
	ADDFAC(_Tush6, cat, ptrimp, ptrloc);
	ADDFAC(_Tush7, cat, ptrimp, ptrloc);
	ADDFAC(_Tush9, cat, ptrimp, ptrloc);
	ADDFAC(_Tush11, cat, ptrimp, ptrloc);
	ADDFAC(_Tush12, cat, ptrimp, ptrloc);
	ADDFAC(_Tush13, cat, ptrimp, ptrloc);
	ADDFAC(_Tush14, cat, ptrimp, ptrloc);
	//...
	ADDFAC(_Tushc1, cat, ptrimp, ptrloc);
	}
#endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\wctype.c ===
/* wctype function for Microsoft */
#include <string.h>
#include <wctype.h>
#ifndef _YVALS
#include <yvals.h>
#endif
_STD_BEGIN

static const struct wctab {
	const char *s;
	wctype_t val;
	} tab[] = {
	{"alnum", _ALPHA|_DIGIT},
	{"alpha", _ALPHA},
	{"cntrl", _CONTROL},
	{"digit", _DIGIT},
	{"graph", _PUNCT|_ALPHA|_DIGIT},
	{"lower", _LOWER},
	{"print", _BLANK|_PUNCT|_ALPHA|_DIGIT},
	{"punct", _PUNCT},
	{"space", _SPACE},
	{"upper", _UPPER},
	{"xdigit", _HEX},
	{(const char *)0, 0}};

#pragma warning(disable:4273)	/* inconsistent with Microsoft header */
_CRTIMP2 wctype_t (__cdecl wctype)(const char *name)
	{	/* find classification for wide character */
	int n;

	for (n = 0; tab[n].s != 0; ++n)
		if (strcmp(tab[n].s, name) == 0)
			return (tab[n].val);
	return (0);
	}
#pragma warning(default:4273)
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xdateord.cpp ===
// xdateord -- look up date ordering for Microsoft
#include <cruntime.h>
#include <locale>
#include <setlocal.h>
#include <tchar.h>

_STD_BEGIN
extern "C" int __cdecl _Getdateorder()
	{	// return date order for current locale
#ifdef _XBOX
    return std::time_base::mdy;
#else
	_TCHAR buf[2] = {0};
	GetLocaleInfo(___lc_handle_func()[LC_TIME], LOCALE_ILDATE,
		buf, sizeof (buf) / sizeof (buf[0]));
	return (buf[0] == _T('0') ? std::time_base::mdy
		: buf[0] == _T('1') ? std::time_base::dmy
		: buf[0] == _T('2') ? std::time_base::ymd
		: std::time_base::no_order);
#endif // XBOX
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xdebug.cpp ===
// new and delete operators for debug CRT heap use by C++ Library
#if defined(_DEBUG)

#include <xdebug>
#include <crtdbg.h>

void *operator new(size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW1(std::bad_alloc)
	{
	void *p = _malloc_dbg(sz, tag._Type, file, line);
	if (p == 0)
		std::_Nomemory();
	return p;
	}

void *operator new[](size_t sz, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW1(std::bad_alloc)
	{
	return operator new(sz, tag, file, line);
	}

void operator delete(void *p, const std::_DebugHeapTag_t &tag, char *, int)
	_THROW0()
	{
		_free_dbg(p, tag._Type);
	}

void operator delete[](void *p, const std::_DebugHeapTag_t &tag,
	char *file, int line) _THROW0()
	{
		operator delete(p, tag, file, line);
	}

_STD_BEGIN
const _DebugHeapTag_t _DebugHeapTag = { _CRT_BLOCK };
_STD_END

#endif	/* _DEBUG */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xdscale.c ===
/* _Dscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dscale(double *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (short)((ps[_D0] & _DMASK) >> _DOFF);

	if (xchar == _DMAX)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _Dnorm(ps)))
		return (0);
	lexp += xchar;
	if (_DMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_D0] & _DSIGN ? -_Inf._Double : _Inf._Double;
		return (_INFCODE);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_D0] = ps[_D0] & ~_DMASK | (short)lexp << _DOFF;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_D0] & _DSIGN;

		ps[_D0] = (unsigned short)(1 << _DOFF
			| ps[_D0] & _DFRAC);
		if (--lexp < -(48+_DOFF))
			{	/* underflow, return +/-0 */
			ps[_D0] = sign, ps[_D1] = 0;
			ps[_D2] = 0, ps[_D3] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = (short)lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_D3] = ps[_D2], ps[_D2] = ps[_D1];
				ps[_D1] = ps[_D0], ps[_D0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_D3] = ps[_D3] >> xexp
					| ps[_D2] << (16 - xexp);
				ps[_D2] = ps[_D2] >> xexp
					| ps[_D1] << (16 - xexp);
				ps[_D1] = ps[_D1] >> xexp
					| ps[_D0] << (16 - xexp);
				ps[_D0] >>= xexp;
				}
			ps[_D0] |= sign;
			return (_FINITE);
			}
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xdtest.c ===
/* _Dtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dtest(double *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_D0] & _DMASK) == _DMAX << _DOFF)
		return ((ps[_D0] & _DFRAC) != 0 || ps[_D1] != 0
			|| ps[_D2] != 0 || ps[_D3] != 0 ? _NANCODE : _INFCODE);
	else if ((ps[_D0] & ~_DSIGN) != 0 || ps[_D1] != 0
		|| ps[_D2] != 0 || ps[_D3] != 0)
		return (_FINITE);
	else
		return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xdnorm.c ===
/* _Dnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _Dnorm(unsigned short *ps)
	{	/* normalize double fraction */
	short xchar;
	unsigned short sign = ps[_D0] & _DSIGN;

	xchar = 1;
	if ((ps[_D0] &= _DFRAC) != 0 || ps[_D1]
		|| ps[_D2] || ps[_D3])
		{	/* nonzero, scale */
		for (; ps[_D0] == 0; xchar -= 16)
			{	/* shift left by 16 */
			ps[_D0] = ps[_D1], ps[_D1] = ps[_D2];
			ps[_D2] = ps[_D3], ps[_D3] = 0;
			}
		for (; ps[_D0] < 1 << _DOFF; --xchar)
			{	/* shift left by 1 */
			ps[_D0] = ps[_D0] << 1 | ps[_D1] >> 15;
			ps[_D1] = ps[_D1] << 1 | ps[_D2] >> 15;
			ps[_D2] = ps[_D2] << 1 | ps[_D3] >> 15;
			ps[_D3] <<= 1;
			}
		for (; 1 << (_DOFF + 1) <= ps[_D0]; ++xchar)
			{	/* shift right by 1 */
			ps[_D3] = ps[_D3] >> 1 | ps[_D2] << 15;
			ps[_D2] = ps[_D2] >> 1 | ps[_D1] << 15;
			ps[_D1] = ps[_D1] >> 1 | ps[_D0] << 15;
			ps[_D0] >>= 1;
			}
		ps[_D0] &= _DFRAC;
		}
	ps[_D0] |= sign;
	return (xchar);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xexp.c ===
/* _Exp function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
static const double p[] = {	/* courtesy Dr. Tim Prince */
	1.0,
	420.30235984910635,
	15132.70094680474802};
static const double q[] = {	/* courtesy Dr. Tim Prince */
	30.01511290683317,
	3362.72154416553028,
	30265.40189360949691};
static const double c1 = 22713.0 / 32768.0;
static const double c2 = 1.4286068203094172321214581765680755e-6;
static const double hugexp = HUGE_EXP;
static const double invln2 = 1.4426950408889634073599246810018921;

_CRTIMP2 short __cdecl _Exp(double *px, double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0)
		{	/* certain underflow */
		*px = 0.0;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _Inf._Double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		double g = *px * invln2;
		short xexp = (short)(g + (g < 0.0 ? - 0.5 : + 0.5));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_Eps._Double < g && g < _Eps._Double)
			*px = y;
		else
			{	/* g*g worth computing */
			const double z = g * g;
			const double w = (q[0] * z + q[1]) * z + q[2];

			g *= (z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0 * y;
			--xexp;
			}
		return (_Dscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfcosh.c ===
/* _FCosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 float __cdecl _FCosh(float x, float y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			return (y * (x + 0.25F / x));
			}
		switch (_FExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xferaise.c ===
/* _Feraise function */
#include <errno.h>
	#if _IS_C9X
#include <fenv.h>
#include <math.h>
	#else /* _IS_C9X */
#include <ymath.h>
	#endif /* _IS_C9X */
_STD_BEGIN
#undef except

void (_Feraise)(int except)
	{	/* report floating-point exception */
	#if _IS_C9X
	if (math_errhandling == MATH_ERREXCEPT)
		feraiseexcept(except);

	if (math_errhandling != MATH_ERRNO)
		;
	else if ((except & (_FE_DIVBYZERO | _FE_INVALID)) != 0)
		errno = EDOM;
	else if ((except & (_FE_UNDERFLOW | _FE_OVERFLOW)) != 0)
		errno = ERANGE;
	#else /* _IS_C9X */
	if ((except & (_FE_DIVBYZERO | _FE_INVALID)) != 0)
		errno = EDOM;
	else if ((except & (_FE_UNDERFLOW | _FE_OVERFLOW)) != 0)
		errno = ERANGE;
	#endif /* _IS_C9X */
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfdtest.c ===
/* _FDtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDtest(float *px)
	{	/* categorize *px */
	unsigned short *ps = (unsigned short *)px;

	if ((ps[_F0] & _FMASK) == _FMAX << _FOFF)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE);
	else if ((ps[_F0] & ~_FSIGN) != 0 || ps[_F1] != 0)
		return (_FINITE);
	else
		return (0);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfdnorm.c ===
/* _FDnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDnorm(unsigned short *ps)
	{	/* normalize float fraction */
	short xchar;
	unsigned short sign = ps[_F0] & _FSIGN;

	xchar = 1;
	if ((ps[_F0] &= _FFRAC) != 0 || ps[_F1])
		{	/* nonzero, scale */
		if (ps[_F0] == 0)
			ps[_F0] = ps[_F1], ps[_F1] = 0, xchar -= 16;
		for (; ps[_F0] < 1 << _FOFF; --xchar)
			{	/* shift left by 1 */
			ps[_F0] = ps[_F0] << 1 | ps[_F1] >> 15;
			ps[_F1] <<= 1;
			}
		for (; 1 << (_FOFF + 1) <= ps[_F0]; ++xchar)
			{	/* shift right by 1 */
			ps[_F1] = ps[_F1] >> 1 | ps[_F0] << 15;
			ps[_F0] >>= 1;
			}
		ps[_F0] &= _FFRAC;
		}
	ps[_F0] |= sign;
	return (xchar);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfdscale.c ===
/* _FDscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 short __cdecl _FDscale(float *px, long lexp)
	{	/* scale *px by 2^xexp with checking */
	unsigned short *ps = (unsigned short *)px;
	short xchar = (short)((ps[_F0] & _FMASK) >> _FOFF);

	if (xchar == _FMAX)
		return ((ps[_F0] & _FFRAC) != 0 || ps[_F1] != 0
			? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _FDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_FMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_F0] & _FSIGN ? -_FInf._Float : _FInf._Float;
		return (_INFCODE);
		}
	else if (0 < lexp)
		{	/* finite result, repack */
		ps[_F0] = ps[_F0] & ~_FMASK | (short)lexp << _FOFF;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_F0] & _FSIGN;

		ps[_F0] = (unsigned short)(1 << _FOFF
			| ps[_F0] & _FFRAC);
		if (--lexp < -(16+_FOFF))
			{	/* underflow, return +/-0 */
			ps[_F0] = sign, ps[_F1] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp = (short)lexp;
			if (xexp <= -16)
				ps[_F1] = ps[_F0], ps[_F0] = 0, xexp += 16;
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_F1] = ps[_F1] >> xexp
					| ps[_F0] << (16 - xexp);
				ps[_F0] >>= xexp;
				}
			ps[_F0] |= sign;
			return (_FINITE);
			}
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xgetwctype.c ===
/* _Getwctype -- return character classification flags for wide character */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>

_STD_BEGIN
_CRTIMP2 short __cdecl _Getwctype(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* return character classification flags for _Ch */
#ifndef _XBOX
	short _Mask;
	return ((short)(__crtGetStringTypeW(CT_CTYPE1, &_Ch, 1,
		(LPWORD)&_Mask, _Ctype->_Page, _Ctype->_Hand) == 0
		? 0 : _Mask));
#else
    return (short)iswctype(_Ch, -1);
#endif // XBOX
	}

_CRTIMP2 const wchar_t * __cdecl _Getwctypes(
	const wchar_t *_First, const wchar_t *_Last,
		short *_Dest, const _Ctypevec *_Ctype)
	{	/* get mask sequence for elements in [_First, _Last) */
#ifndef _XBOX
	__crtGetStringTypeW(CT_CTYPE1, _First, (int)(_Last - _First),
		(LPWORD)_Dest, _Ctype->_Page, _Ctype->_Hand);
#else
    while(_First < _Last)
        *_Dest++ = (short)iswctype(*_First++, -1);
#endif
	return (_Last);		
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlcosh.c ===
/* _LCosh function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double __cdecl _LCosh(long double x, long double y)
	{	/* compute y * cosh(x), |y| <= 1 */
	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
	case _INFCODE:
		return (x);
	case 0:
		return (y);
	default:	/* finite */
		if (y == 0.0L)
			return (y);
		if (x < 0.0)
			x = -x;
		if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			return (y * (x + 0.25L / x));
			}
		switch (_LExp(&x, y, -1))
			{	/* report over/underflow */
		case 0:
			_Feraise(_FE_UNDERFLOW);
			break;
		case _INFCODE:
			_Feraise(_FE_OVERFLOW);
			}
		return (x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfsinh.c ===
/* _FSinh function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const float p[] = {	/* courtesy Dr. Tim Prince */
	0.00020400F,
	0.00832983F,
	0.16666737F,
	0.99999998F};

_CRTIMP2 float __cdecl _FSinh(float x, float y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_FDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0F ? x : FSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0F)
			return (x < 0.0F ? -y : y);
		if (x < 0.0F)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _FRteps._Float)
			x *= y;	/* x tiny */
		else if (x < 1.0F)
			{
			float w = x * x;

			x += ((p[0] * w + p[1]) * w + p[2]) * w * x;
			x *= y;
			}
		else if (x < _FXbig)
			{	/* worth adding in exp(-x) */
			_FExp(&x, 1.0F, -1);
			x = y * (x - 0.25F / x);
			}
		else
			switch (_FExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xldnorm.c ===
/* _LDnorm function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
	/* not needed -- 64-bit */

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 80-bit */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 0;
	for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
		xchar -= 16)
		{	/* shift left by 16 */
		ps[_L0] = ps[_L1];
		ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
		ps[_L3] = ps[_L4], ps[_L4] = 0;
		}
	if (ps[_L0] == 0)
		for (; ps[_L1] < (1U << _LOFF); --xchar)
			{	/* shift left by 1 */
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] <<= 1;
			}
	for (; ps[_L0] != 0; ++xchar)
		{	/* shift right by 1 */
		ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
		ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
		ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
		ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
		ps[_L0] >>= 1;
		}
	ps[_L0] = sign;
	return (xchar);
	}

 #else	/* 1 < _DLONG */
_CRTIMP2 short __cdecl _LDnorm(unsigned short *ps)
	{	/* normalize long double fraction -- 128-bit SPARC */
	short xchar;
	unsigned short sign = ps[_L0];

	xchar = 1;
	if (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
		|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
		|| ps[_L7] != 0)
		{	/* nonzero, scale */
		for (ps[_L0] = 0; ps[_L0] == 0 && ps[_L1] < 0x100;
			xchar -= 16)
			{	/* shift left by 16 */
			ps[_L0] = ps[_L1];
			ps[_L1] = ps[_L2], ps[_L2] = ps[_L3];
			ps[_L3] = ps[_L4], ps[_L4] = ps[_L5];
			ps[_L5] = ps[_L6], ps[_L6] = ps[_L7];
			ps[_L7] = 0;
			}
		for (; ps[_L0] == 0; --xchar)
			{	/* shift left by 1 */
			ps[_L0] = ps[_L0] << 1 | ps[_L1] >> 15;
			ps[_L1] = ps[_L1] << 1 | ps[_L2] >> 15;
			ps[_L2] = ps[_L2] << 1 | ps[_L3] >> 15;
			ps[_L3] = ps[_L3] << 1 | ps[_L4] >> 15;
			ps[_L4] = ps[_L4] << 1 | ps[_L5] >> 15;
			ps[_L5] = ps[_L5] << 1 | ps[_L6] >> 15;
			ps[_L6] = ps[_L6] << 1 | ps[_L7] >> 15;
			ps[_L7] <<= 1;
			}
		for (; 1 < ps[_L0]; ++xchar)
			{	/* shift right by 1 */
			ps[_L7] = ps[_L7] >> 1 | ps[_L6] << 15;
			ps[_L6] = ps[_L6] >> 1 | ps[_L5] << 15;
			ps[_L5] = ps[_L5] >> 1 | ps[_L4] << 15;
			ps[_L4] = ps[_L4] >> 1 | ps[_L3] << 15;
			ps[_L3] = ps[_L3] >> 1 | ps[_L2] << 15;
			ps[_L2] = ps[_L2] >> 1 | ps[_L1] << 15;
			ps[_L1] = ps[_L1] >> 1 | ps[_L0] << 15;
			ps[_L0] >>= 1;
			}
		}
	ps[_L0] = sign;
	return (xchar);
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xldscale.c ===
/* _LDscale function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 64-bit */
	return (_Dscale((double *)px, lexp));
	}

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 80-bit */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && ps[_L1] == 0 && ps[_L2] == 0
		&& ps[_L3] == 0 && ps[_L4] == 0)
		return (0);
	lexp += xchar + _LDnorm(ps);
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		ps[_L0] &= _LSIGN;
		if (lexp <= -64)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0;
			ps[_L3] = 0, ps[_L4] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L4] = ps[_L3], ps[_L3] = ps[_L2];
				ps[_L2] = ps[_L1], ps[_L1] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] >>= xexp;
				}
			return (_FINITE);
			}
		}
	}
 #else	/*	1 < _DLONG */
_CRTIMP2 short __cdecl _LDscale(long double *px, long lexp)
	{	/* scale *px by 2^lexp with checking -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (xchar == 0 && 0 < (xchar = _LDnorm(ps)))
		return (0);
	lexp += xchar;
	if (_LMAX <= lexp)
		{	/* overflow, return +/-INF */
		*px = ps[_L0] & _LSIGN ? -_LInf._Long_double
			: _LInf._Long_double;
		return (_INFCODE);
		}
	else if (0 <= lexp)
		{	/* finite result, repack */
		ps[_L0] = ps[_L0] & _LSIGN | (short)lexp;
		return (_FINITE);
		}
	else
		{	/* denormalized, scale */
		unsigned short sign = ps[_L0] & _LSIGN;

		ps[_L0] = 1;
		if (--lexp <= -112)
			{	/* underflow, return +/-0 */
			ps[_L1] = 0, ps[_L2] = 0, ps[_L3] = 0, ps[_L4] = 0;
			ps[_L5] = 0, ps[_L6] = 0, ps[_L7] = 0;
			return (0);
			}
		else
			{	/* nonzero, align fraction */
			short xexp;
			for (xexp = lexp; xexp <= -16; xexp += 16)
				{	/* scale by words */
				ps[_L7] = ps[_L6], ps[_L6] = ps[_L5];
				ps[_L5] = ps[_L4], ps[_L4] = ps[_L3];
				ps[_L3] = ps[_L2], ps[_L2] = ps[_L1];
				ps[_L1] = ps[_L0], ps[_L0] = 0;
				}
			if ((xexp = -xexp) != 0)
				{	/* scale by bits */
				ps[_L7] = ps[_L7] >> xexp
					| ps[_L6] << 16 - xexp;
				ps[_L6] = ps[_L6] >> xexp
					| ps[_L5] << 16 - xexp;
				ps[_L5] = ps[_L5] >> xexp
					| ps[_L4] << 16 - xexp;
				ps[_L4] = ps[_L4] >> xexp
					| ps[_L3] << 16 - xexp;
				ps[_L3] = ps[_L3] >> xexp
					| ps[_L2] << 16 - xexp;
				ps[_L2] = ps[_L2] >> xexp
					| ps[_L1] << 16 - xexp;
				ps[_L1] = ps[_L1] >> xexp
					| ps[_L0] << 16 - xexp;
				}
			ps[_L0] = sign;
			return (_FINITE);
			}
		}
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xldtest.c ===
/* _LDtest function -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 64-bit */
	return (_Dtest((double *)px));
	}

 #elif _DLONG == 1
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 80-bit */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return ((ps[_L1] & 0x7fff) != 0 || ps[_L2] != 0
			|| ps[_L3] != 0 || ps[_L4] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] != 0 || ps[_L2] || ps[_L3]
		|| ps[_L4])
		return (_FINITE);
	else
		return (0);
	}

 #else	/*	1 < _DLONG */
_CRTIMP2 short __cdecl _LDtest(long double *px)
	{	/* categorize *px -- 128-bit SPARC */
	unsigned short *ps = (unsigned short *)px;
	short xchar = ps[_L0] & _LMASK;

	if (xchar == _LMAX)
		return (ps[_L1] != 0 || ps[_L2] != 0 || ps[_L3] != 0
			|| ps[_L4] != 0 || ps[_L5] != 0 || ps[_L6] != 0
			|| ps[_L7] != 0 ? _NANCODE : _INFCODE);
	else if (0 < xchar || ps[_L1] || ps[_L2] || ps[_L3]
		|| ps[_L4] || ps[_L5] || ps[_L6] || ps[_L7])
		return (_FINITE);
	else
		return (0);
	}
 #endif
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfvalues.c ===
/* values used by math functions -- IEEE 754 float version */
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(16 + _FOFF)
 #if _D0 == 0
  #define INIT(w0)		{w0, 0}
  #define INIT2(w0, w1)	{w0, w1}
 #else
  #define INIT(w0)		{0, w0}
  #define INIT2(w0, w1)	{w1, w0}
 #endif

		/* static data */
_CRTIMP2 const _Dconst _FDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _FEps = {INIT((_FBIAS - NBITS - 1) << _FOFF)};
_CRTIMP2 const _Dconst _FInf = {INIT(_FMAX << _FOFF)};
_CRTIMP2 const _Dconst _FNan = {INIT(_FSIGN | (_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
_CRTIMP2 const _Dconst _FSnan = {INIT(_FSIGN | (_FMAX << _FOFF)
	| (1 << (_FOFF - 1)))};
_CRTIMP2 const _Dconst _FRteps = {INIT((_FBIAS - NBITS / 2) << _FOFF)};

_CRTIMP2 const float _FXbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const float _FZero = 0.0F;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xfexp.c ===
/* _FExp function */
#include "xmath.h"
_STD_BEGIN

static const float p[] = {	/* courtesy Dr. Tim Prince */
	1.0F,
	60.09114349F};
static const float q[] = {	/* courtesy Dr. Tim Prince */
	12.01517514F,
	120.18228722F};
static const float c1 = (22713.0F / 32768.0F);
static const float c2 = 1.4286068203094172321214581765680755e-6F;
static const float hugexp = FHUGE_EXP;
static const float invln2 = 1.4426950408889634073599246810018921F;

_CRTIMP2 short __cdecl _FExp(float *px, float y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0F)
		{	/* certain underflow */
		*px = 0.0F;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _FInf._Float;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		float g = *px * invln2;
		short xexp = (short)(g + (g < 0.0F ? - 0.5F : + 0.5F));

		g = xexp;
		g = (float)((*px - g * c1) - g * c2);
		if (-_FEps._Float < g && g < _FEps._Float)
			*px = y;
		else
			{	/* g*g worth computing */
			const float z = g * g;
			const float w = q[0] * z + q[1];

			g *= z + p[1];
			*px = (w + g) / (w - g) * 2.0F * y;
			--xexp;
			}
		return (_FDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

		/* return values for _Stopfx/_Stoflt */
#define FL_ERR	0
#define FL_DEC	1
#define FL_HEX	2
#define FL_INF	3
#define FL_NAN	4
#define FL_NEG	8

_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double __cdecl _Atan(double, int);
_CRTIMP2 short __cdecl _Dint(double *, short);
_CRTIMP2 short __cdecl _Dnorm(unsigned short *);
_CRTIMP2 short __cdecl _Dscale(double *, long);
_CRTIMP2 double __cdecl _Dtento(double, long);
_CRTIMP2 short __cdecl _Dunscale(short *, double *);
_CRTIMP2 double __cdecl _Poly(double, const double *, int);

_CRTIMP2 int __cdecl _Stoflt(const char *, char **, long[], int);

extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;

		/* float declarations */
_CRTIMP2 float __cdecl _FAtan(float, int);
_CRTIMP2 short __cdecl _FDint(float *, short);
_CRTIMP2 short __cdecl _FDnorm(unsigned short *);
_CRTIMP2 short __cdecl _FDscale(float *, long);
_CRTIMP2 float __cdecl _FDtento(float, long);
_CRTIMP2 short __cdecl _FDunscale(short *, float *);
_CRTIMP2 float __cdecl _FPoly(float, const float *, int);

extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;

		/* long double functions */
_CRTIMP2 long double __cdecl _LAtan(long double, int);
_CRTIMP2 short __cdecl _LDint(long double *, short);
_CRTIMP2 short __cdecl _LDnorm(unsigned short *);
_CRTIMP2 short __cdecl _LDscale(long double *, long);
_CRTIMP2 long double __cdecl _LDtento(long double, long);
_CRTIMP2 short __cdecl _LDunscale(short *, long double *);
_CRTIMP2 long double __cdecl _LPoly(long double, const long double *, int);

extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlpoly.c ===
/* _LPoly function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 long double __cdecl _LPoly(long double x,
	const long double *tab, int n)
	{	/* compute polynomial */
	long double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlock.cpp ===
// xlock.cpp -- global lock for locales, etc.
#include <stdlib.h>
#include <yvals.h>

 #if _MULTI_THREAD
  #include "xmtx.h"
_STD_BEGIN

  #define MAX_LOCK	4	/* must be power of two */

static _Rmtx mtx[MAX_LOCK];
static long init = -1;

_Init_locks::_Init_locks()
	{	// initialize locks
	if (InterlockedIncrement(&init) == 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxinit(&mtx[count]);
	}

_Init_locks::~_Init_locks()
	{	// clean up locks
	if (InterlockedDecrement(&init) < 0)
		for (int count = 0; count < MAX_LOCK; ++count)
			_Mtxdst(&mtx[count]);
	}

static _Init_locks initlocks;

_Lockit::_Lockit()
	: _Locktype(0)
	{	// lock default mutex
	_Mtxlock(&mtx[0]);
	}

_Lockit::_Lockit(int kind)
	: _Locktype(kind & (MAX_LOCK - 1))
	{	// lock the mutex
	_Mtxlock(&mtx[_Locktype]);
	}

_Lockit::~_Lockit()
	{	// unlock the mutex
	_Mtxunlock(&mtx[_Locktype]);
	}
_STD_END
 #endif	// _MULTI_THREAD

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlsinh.c ===
/* _LSinh function */
#include "xmath.h"
_STD_BEGIN

	/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)

 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000000000028486835L,
	0.0000000000007646464279L,
	0.0000000001605905091647L,
	0.0000000250521083436962L,
	0.0000027557319224130455L,
	0.0001984126984126956009L,
	0.0083333333333333336073L,
	0.1666666666666666666564L,
	1.0000000000000000000001L};
 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	0.00000000000000000000000006506911776L,
	0.00000000000000000000003867997525529L,
	0.00000000000000000001957294395545097L,
	0.00000000000000000822063524350084984L,
	0.00000000000000281145725434779709982L,
	0.00000000000076471637318198050919003L,
	0.00000000016059043836821614638343470L,
	0.00000002505210838544171877496283537L,
	0.00000275573192239858906525574505191L,
	0.00019841269841269841269841269726379L,
	0.00833333333333333333333333333338555L,
	0.16666666666666666666666666666666573L,
	1.0L};
 #endif

_CRTIMP2 long double __cdecl _LSinh(long double x, long double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_LDtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0L ? x : LSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0L)
			return (x < 0.0L ? -y : y);
		if (x < 0.0L)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _LRteps._Long_double)
			x *= y;	/* x tiny */
		else if (x < 1.0L)
			{
			long double w = x * x;

			x += x * w * _LPoly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _LXbig)
			{	/* worth adding in exp(-x) */
			_LExp(&x, 1.0L, -1);
			x = y * (x - 0.25L / x);
			}
		else
			switch (_LExp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlocale.cpp ===
// xlocale -- class locale exotic char member functions
#include <istream>
#include <locale>
#include <xdebug>
_STD_BEGIN

 #pragma warning(disable: 4786)

typedef char_traits<char> _Traits;
typedef istreambuf_iterator<char, _Traits> _Initer;
typedef ostreambuf_iterator<char, _Traits> _Outiter;

	// facets associated with C categories
#define ADDFAC(Facet, cat, ptrimp, ptrloc) \
	if ((_CATMASK(Facet::_Getcat()) & cat) == 0) \
		; \
	else if (ptrloc == 0) \
		ptrimp->_Addfac(_NEW_CRT Facet(lobj), Facet::id); \
	else \
		ptrimp->_Addfac((locale::facet *)&_USE(*ptrloc, Facet), Facet::id);

// moved from locale to ease subsetting
typedef collate<char> _T5;
typedef messages<char> _T6;
typedef money_get<char, _Initer> _T7;
typedef money_put<char, _Outiter> _T9;
typedef moneypunct<char, false> _T11;
typedef moneypunct<char, true> _T12;
typedef time_get<char, _Initer> _T13;
typedef time_put<char, _Outiter> _T14;


void __cdecl locale::_Locimp::_Makexloc(const _Locinfo& lobj,
	locale::category cat, _Locimp *ptrimp, const locale *ptrloc)
	{	// setup exotic char part of a new locale
	ADDFAC(_T5, cat, ptrimp, ptrloc);
	ADDFAC(_T6, cat, ptrimp, ptrloc);
	ADDFAC(_T7, cat, ptrimp, ptrloc);
	ADDFAC(_T9, cat, ptrimp, ptrloc);
	ADDFAC(_T11, cat, ptrimp, ptrloc);
	ADDFAC(_T12, cat, ptrimp, ptrloc);
	ADDFAC(_T13, cat, ptrimp, ptrloc);
	ADDFAC(_T14, cat, ptrimp, ptrloc);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlvalues.c ===
/* values used by math functions -- IEEE 754 long version */
#include "xmath.h"
_STD_BEGIN

 #if _DLONG == 0
		/* macros -- 64-bit */
  #define NBITS	(48 + _DOFF)
  #if _D0 == 0
   #define INIT(w0)		{w0, 0, 0, 0}
   #define INIT2(w0, w1)	{w0, 0, 0, w1}
  #else
   #define INIT(w0)		{0, 0, 0, w0}
   #define INIT2(w0, w1)	{w1, 0, 0, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _LInf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _LNan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _LRteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};

 #elif _DLONG == 1
		/* macros -- 80-bit */
  #define NBITS	64
  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, wn}
  #else
   #define INIT(w0, w1)		{0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, w1, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT3(0, 0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT(_LBIAS - NBITS - 1, 0x8000)};
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0xc000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LRteps = {INIT(_LBIAS - NBITS / 2, 0x8000)};

 #else /* 1 < _DLONG */
		/* macros -- 128-bit SPARC */
  #define NBITS	128
  #if _D0 == 0
   #define INIT(w0, w1)		{w0, w1, 0, 0, 0, 0, 0, 0}
   #define INIT3(w0, w1, wn)	{w0, w1, 0, 0, 0, 0, 0, wn}
  #else
   #define INIT(w0, w1)		{0, 0, 0, 0, 0, 0, w1, w0}
   #define INIT3(w0, w1, wn)	{wn, 0, 0, 0, 0, 0, w1, w0}
  #endif

		/* static data */
_CRTIMP2 const _Dconst _LDenorm = {INIT3(0, 0, 1)};
_CRTIMP2 const _Dconst _LEps = {INIT(_LBIAS - NBITS - 1, 0x8000)};
_CRTIMP2 const _Dconst _LInf = {INIT(_LMAX, 0)};
_CRTIMP2 const _Dconst _LNan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LSnan = {INIT(_LSIGN | _LMAX, 0x8000)};
_CRTIMP2 const _Dconst _LRteps = {INIT(_LBIAS - NBITS / 2, 0x8000)};
 #endif

_CRTIMP2 const long double _LXbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const long double _LZero = 0.0L;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xmbtowc.c ===
/***
*xmbtowc.c - Convert multibyte char to wide char.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a multibyte character into the equivalent wide character.
*
*Revision History:
*       12-XX-95  PJP   Created from mbtowc.c December 1995 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Made mbrlen, mbrtowc and mbsrtowcs multithread safe.
*       09-17-97  JWM   Added "return MB_CUR_MAX" to "if (*pst != 0)" branch.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <dbgint.h>
#include <ctype.h>
#include <limits.h>              /* for INT_MAX */
#include <stdio.h>               /* for EOF */
#include <xlocinfo.h>            /* for _Cvtvec, _Mbrtowc */
#include <internal.h>
#include <locale.h>
#include <setlocal.h>

#ifndef _MT
#define _Mbrtowc_lk _Mbrtowc
#endif

/***
*int _Mbrtowc() - Convert multibyte char to wide character.
*
*Purpose:
*       Convert a multi-byte character into the equivalent wide character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       wchar_t  *pwc = pointer to destination wide character
*       const char *s = pointer to multibyte character
*       size_t      n = maximum length of multibyte character to consider
*               mbstate_t *pst          = pointer to state
*       const _Cvtvec *     = pointer to locale info
*
*Exit:
*       If s = NULL, returns 0, indicating we only use state-independent
*       character encodings.
*       If s != NULL, returns:  0 (if *s = null char)
*                               -1 (if the next n or fewer bytes not valid mbc)
*                               number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
static int __cdecl _Mbrtowc_lk
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        );

int _CRTIMP2 __cdecl _Mbrtowc(
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(pwc, s, n, pst, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */
#ifdef _MT
static int __cdecl _Mbrtowc_lk
#else  /* _MT */
int _CRTIMP2 __cdecl _Mbrtowc
#endif  /* _MT */
        (
        wchar_t  *pwc,
        const char *s,
        size_t n,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        _ASSERTE (___mb_cur_max_func() == 1 || ___mb_cur_max_func() == 2);

        if ( !s || n == 0 )
            /* indicate do not have state-dependent encodings,
               handle zero length string */
            return 0;

        if ( !*s )
        {
            /* handle NULL char */
            if (pwc)
                *pwc = 0;
            return 0;
        }

#ifndef _XBOX

        {   /* perform locale-dependent parse */
            LCID handle;
            UINT codepage;

            if (ploc == 0)
            {
                handle = ___lc_handle_func()[LC_CTYPE];
                codepage = ___lc_codepage_func(); 
            }
            else
            {
                handle = ploc->_Hand;
                codepage = ploc->_Page; 
            }

            if ( handle == _CLOCALEHANDLE )
            {
                if (pwc)
                    *pwc = (wchar_t)(unsigned char)*s;
                return sizeof(char);
            }

            if (*pst != 0)
            {   /* complete two-byte multibyte character */
                ((char *)pst)[1] = *s;
                if (___mb_cur_max_func() <= 1 || (MultiByteToWideChar(codepage,
                    MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                    (char *)pst, 2, pwc, (pwc) ? 1 : 0) == 0))
                {   /* translation failed */
                    *pst = 0;
                    errno = EILSEQ;
                    return -1;
                }
                *pst = 0;
                return ___mb_cur_max_func();
            }
            else if ( _cpp_isleadbyte((unsigned char)*s) )
            {
                /* multi-byte char */
                if (n < (size_t)___mb_cur_max_func())
                {   /* save partial multibyte character */
                    ((char *)pst)[0] = *s;
                    return (-2);
                }
                else if ( ___mb_cur_max_func() <= 1 ||
                          (MultiByteToWideChar( codepage, 
                                                MB_PRECOMPOSED |
                                                    MB_ERR_INVALID_CHARS,
                                                s, 
                                                ___mb_cur_max_func(), 
                                                pwc, 
                                                (pwc) ? 1 : 0) == 0) )
                {
                    /* validate high byte of mbcs char */
                    if (!*(s+1))
                    {
                        *pst = 0;
                        errno = EILSEQ;
                        return -1;
                    }
/*                  else translation failed with no complaint? [pjp] */
                }
                return ___mb_cur_max_func();
            }
            else {
                /* single byte char */

                if ( MultiByteToWideChar( codepage, 
                                          MB_PRECOMPOSED|MB_ERR_INVALID_CHARS,
                                          s, 
                                          1, 
                                          pwc, 
                                          (pwc) ? 1 : 0) == 0 )
                {
                    errno = EILSEQ;
                    return -1;
                }

                return sizeof(char);
            }
        }
#else // XBOX

        /* stuck the "C" locale again */
        if (pwc)
            *pwc = (wchar_t)(unsigned char)*s;
        return sizeof(char);

#endif // XBOX
}


/***
*wint_t btowc(c) - translate single byte to wide char 
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

wint_t _CRTIMP2 __cdecl btowc (
        int c
        )
{
        if (c == EOF)
            return (WEOF);
        else
        {   /* convert as one-byte string */
            char ch = (char)c;
            mbstate_t mbst = 0;
            wchar_t wc;
            return (_Mbrtowc(&wc, &ch, 1, &mbst, 0) < 0 ? WEOF : wc);
        }
}


/***
*size_t mbrlen(s, n, pst) - determine next multibyte code, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrlen (
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = _Mbrtowc_lk(0, s != 0 ? s : 0, n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;
}


/***
*size_t mbrtowc(pwc, s, n, pst) - translate multibyte to wchar_t, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbrtowc (
        wchar_t *pwc, 
        const char *s, 
        size_t n, 
        mbstate_t *pst
        )
{
#ifdef  _MT
        int local_lock_flag;
#endif
        size_t retval;

        static mbstate_t mbst = {0};

        _lock_locale( local_lock_flag )
        retval = (s != 0) ? _Mbrtowc_lk(pwc, s, n, pst ? pst : &mbst, 0)
                 : _Mbrtowc_lk(0, "", n, pst ? pst : &mbst, 0);
        _unlock_locale( local_lock_flag )

        return retval;    
}


/***
*size_t mbsrtowcs(wcs, ps, n, pst) - translate multibyte string to wide, 
*       restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

size_t _CRTIMP2 __cdecl mbsrtowcs (
        wchar_t *wcs, 
        const char **ps, 
        size_t n, 
        mbstate_t *pst
        )
{
        const char *s = *ps;
        int i;
        size_t nwc = 0;
#ifdef  _MT
        int local_lock_flag;
#endif
        static mbstate_t mbst = {0};

        if (pst == 0)
            pst = &mbst;

        _lock_locale( local_lock_flag )

        if (wcs == 0)
            for (; ; ++nwc, s += i)
            {   /* translate but don't store */
                wchar_t wc;
                if ((i = _Mbrtowc_lk(&wc, s, INT_MAX, pst, 0)) < 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (i == 0) {
                    _unlock_locale( local_lock_flag )
                    return (nwc);
                }
            }

        for (; 0 < n; ++nwc, s += i, ++wcs, --n)
        {   /* translate and store */
            if ((i = _Mbrtowc_lk(wcs, s, INT_MAX, pst, 0)) < 0)
            {   /* encountered invalid sequence */
                nwc = (size_t)-1;
                break;
            }
            else if (i == 0)
            {   /* encountered terminating null */
                s = 0;
                break;
            }
        }

        *ps = s;

        _unlock_locale( local_lock_flag )

        return (nwc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xlexp.c ===
/* _LExp function */
#include "xmath.h"
_STD_BEGIN

	/* coefficients */
 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	42.038913947607355L,
	10096.353102778762831L,
	333228.767219512631062L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	1.0L,
	841.167880526530790L,
	75730.834075476293976L,
	666457.534439025262146L};
 #else	/* assume IEEE 754 16 byte */
static const long double p[] = {	/* courtesy Dr. Tim Prince */
	2.9807566520819951922553427799e-12L,
	1.77137207816625148450390487465e-8L,
	1.5047926518149448268177793026372e-5L,
	3.611828913847589925056132680618007e-3L,
	2.3684088648142335389097476188945590e-1L};
static const long double q[] = {	/* courtesy Dr. Tim Prince */
	3.279723985560247033712687707263e-10L,
	6.1415060072086450089090888123384e-7L,
	2.708775201978218837374512615596512e-4L,
	3.5087109907378343612154047611394786e-2L};
 #endif

static const long double c1 = (22713.0L / 32768.0L);
static const long double c2 = 1.4286068203094172321214581765680755e-6L;
static const long double hugexp = LHUGE_EXP;
static const long double invln2 = 1.4426950408889634073599246810018921L;

_CRTIMP2 short __cdecl _LExp(long double *px, long double y, short eoff)
	{	/* compute y*e^(*px), (*px) finite, |y| not huge */
	if (*px < -hugexp || y == 0.0L)
		{	/* certain underflow */
		*px = 0.0L;
		return (0);
		}
	else if (hugexp < *px)
		{	/* certain overflow */
		*px = _LInf._Long_double;
		return (_INFCODE);
		}
	else
		{	/* xexp won't overflow */
		long double g = *px * invln2;
		short xexp = (short)(g + (g < 0 ? - 0.5L : + 0.5L));

		g = xexp;
		g = (*px - g * c1) - g * c2;
		if (-_LEps._Long_double < g && g < _LEps._Long_double)
			*px = y;
		else
			{	/* g*g worth computing */
 #if _DLONG <= 1	/* assume IEEE 754 10 byte */
			const long double z = g * g;
			const long double w = ((z + q[1]) * z + q[2]) * z + q[3];

			g *= (p[0] * z + p[1]) * z + p[2];
			*px = (w + g) / (w - g) * 2.0L * y;
			--xexp;
 #else	/* assume IEEE 754 16 byte */
			const long double z = g * g;
			const long double w = ((q[0] * z + q[1]) * z + q[2]) * z + q[3];
			const long double v = (((p[0] * z + p[1]) * z + p[2])
				* z + p[3]) * z + p[4];
			const long double u = g * w - v;

			*px = g * (g + z * (w + w + u)) / (2.0L - (g + z * u)) + g + 1.0;
			*px *= y;
 #endif
			}
		return (_LDscale(px, (long)xexp + eoff));
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xmtx.h ===
/* xmtx.h internal header */
#pragma once
#ifndef _XMTX
#define _XMTX
#include <stdlib.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

_C_LIB_DECL
  #include <windows.h>
typedef CRITICAL_SECTION _Rmtx;

void _Mtxinit(_Rmtx *);
void _Mtxdst(_Rmtx *);
void _Mtxlock(_Rmtx *);
void _Mtxunlock(_Rmtx *);

 #if !_MULTI_THREAD
  #define _Mtxinit(mtx)
  #define _Mtxdst(mtx)
  #define _Mtxlock(mtx)
  #define _Mtxunlock(mtx)

typedef char _Once_t;

  #define _Once(cntrl, func)	if (*(cntrl) == 0) (func)(), *(cntrl) = 2
  #define _ONCE_T_INIT	0

 #else
typedef long _Once_t;

void __cdecl _Once(_Once_t *, void (*)(void));
  #define _ONCE_T_INIT	0

 #endif /* _MULTI_THREAD */
_END_C_LIB_DECL
#endif /* _XMTX */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xmutex.cpp ===
//	xmutex.cpp -- implement mutex lock for iostreams
#include <yvals.h>
#include <xdebug>

 #if _MULTI_THREAD
  #include "xmtx.h"
_STD_BEGIN

_Mutex::_Mutex()
	: _Mtx(_NEW_CRT _Rmtx)
	{	// initialize recursive mutex object
	_Mtxinit((_Rmtx*)_Mtx);
	}

_Mutex::~_Mutex()
	{	// release resources allocated to mutex object
	_Mtxdst((_Rmtx*)_Mtx);
	_DELETE_CRT((_Rmtx*)_Mtx);
	}

void _Mutex::_Lock()
	{	// lock mutex
	_Mtxlock((_Rmtx*)_Mtx);
	}

void _Mutex::_Unlock()
	{	// unlock mutex
	_Mtxunlock((_Rmtx*)_Mtx);
	}
_STD_END
 #endif	/* _MULTI_THREAD */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xmtx.c ===
/*	xmtx.c -- mutex support for VC++ */
#include "xmtx.h"

 #if !_MULTI_THREAD

 #else /* !_MULTI_THREAD */
/* Win32 critical sections are recursive, but
   Win32 does not have once-function */

void _Once(_Once_t *_Cntrl, void (*_Func)(void))
	{	/* execute _Func exactly one time */
	_Once_t old;
	if (*_Cntrl == 2)
		;
	else if ((old = InterlockedExchange(_Cntrl, 1)) == 0)
		{	/* execute _Func, mark as executed */
		_Func();
		*_Cntrl = 2;
		}	
	else if (old == 2)
		*_Cntrl = 2;
	else
		while (*_Cntrl != 2)
			Sleep(1);
		}

void _Mtxinit(_Rmtx *_Mtx)
	{	/* initialize mutex */
	InitializeCriticalSection(_Mtx);
	}

void _Mtxdst(_Rmtx *_Mtx)
	{	/* delete mutex */
	DeleteCriticalSection(_Mtx);
	}

void _Mtxlock(_Rmtx *_Mtx)
	{	/* lock mutex */
	EnterCriticalSection(_Mtx);
	}

void _Mtxunlock(_Rmtx *_Mtx)
	{	/* unlock mutex */
	LeaveCriticalSection(_Mtx);
	}
 #endif /* !_MULTI_THREAD */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xpoly.c ===
/* _Poly function */
#include "xmath.h"
_STD_BEGIN

_CRTIMP2 double __cdecl _Poly(double x, const double *tab, int n)
	{	/* compute polynomial */
	double y;

	for (y = *tab; 0 <= --n; )
		y = y * x + *++tab;
	return (y);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xsinh.c ===
/* _Sinh function */
#include "xmath.h"
_STD_BEGIN

/* coefficients */
#define NP	(sizeof (p) / sizeof (p[0]) - 1)
static const double p[] = {	/* courtesy Dr. Tim Prince */
	0.0000000001632881,
	0.0000000250483893,
	0.0000027557344615,
	0.0001984126975233,
	0.0083333333334816,
	0.1666666666666574,
	1.0000000000000001};

_CRTIMP2 double __cdecl _Sinh(double x, double y)
	{	/* compute y*sinh(x), |y| <= 1 */
	short neg;

	switch (_Dtest(&x))
		{	/* test for special codes */
	case _NANCODE:
		return (x);
	case _INFCODE:
		return (y != 0.0 ? x : DSIGN(x) ? -y : y);
	case 0:
		return (x * y);
	default:	/* finite */
		if (y == 0.0)
			return (x < 0.0 ? -y : y);
		if (x < 0.0)
			x = -x, neg = 1;
		else
			neg = 0;

		if (x < _Rteps._Double)
			x *= y;	/* x tiny */
		else if (x < 1.0)
			{
			double w = x * x;

			x += x * w * _Poly(w, p, NP - 1);
			x *= y;
			}
		else if (x < _Xbig)
			{	/* worth adding in exp(-x) */
			_Exp(&x, 1.0, -1);
			x = y * (x - 0.25 / x);
			}
		else
			switch (_Exp(&x, y, -1))
				{	/* report over/underflow */
			case 0:
				_Feraise(_FE_UNDERFLOW);
				break;
			case _INFCODE:
				_Feraise(_FE_OVERFLOW);
				}
		return (neg ? -x : x);
		}
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xstod.c ===
/* xstod.c -- dummies for _Sto* */
#include <stdlib.h>
 #ifndef _CRTIMP2
  #ifdef  CRTDLL2
   #define _CRTIMP2 __declspec(dllexport)
  #else   /* ndef CRTDLL2 */
   #ifdef  _DLL
    #define _CRTIMP2 __declspec(dllimport)
   #else   /* ndef _DLL */
    #define _CRTIMP2
   #endif  /* _DLL */
  #endif  /* CRTDLL2 */
 #endif  /* _CRTIMP2 */

_CRTIMP2 double __cdecl _Stod(const char *s, char **endptr, long pten)
	{	/* convert string to double */
	double x = strtod(s, endptr);
	for (; 0 < pten; --pten)
		x *= 10.0;
	for (; pten < 0; ++pten)
		x /= 10.0;
	return (x);
	}

_CRTIMP2 float __cdecl _Stof(const char *s, char **endptr, long pten)
	{	/* convert string to float */
	return ((float)_Stod(s, endptr, pten));
	}

_CRTIMP2 long double __cdecl _Stold(const char *s, char **endptr, long pten)
	{	/* convert string to long double */
	return ((long double)_Stod(s, endptr, pten));
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xtowlower.c ===
/* _Towlower -- convert wchar_t to lower case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <setlocal.h>

_STD_BEGIN
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* convert element to lower case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'A' <= _Ch && _Ch <= L'Z')
			_Res = (wchar_t)(_Ch - L'A' + L'a');
		}
#ifndef _XBOX
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_LOWERCASE,
			&_Ch, 1, &_Res, 1, _Ctype->_Page) == 0)
		_Res = _Ch;
#endif // XBOX
	return (_Res);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xtowupper.c ===
/* _Towupper -- convert wchar_t to upper case for Microsoft */
#include <xlocinfo.h>
#include <wchar.h>
#include <awint.h>
#include <setlocal.h>

_STD_BEGIN
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t _Ch,
	const _Ctypevec *_Ctype)
	{	/* convert element to upper case */
	wchar_t _Res = _Ch;

	if (_Ch == WEOF)
		;
	else if (_Ctype->_Hand == _CLOCALEHANDLE && _Ch < 256)
		{	/* handle ASCII character in C locale */
		if (L'a' <= _Ch && _Ch <= L'z')
			_Res = (wchar_t)(_Ch - L'a' + L'A');
		}
#ifndef _XBOX
	else if (__crtLCMapStringW(_Ctype->_Hand, LCMAP_UPPERCASE,
			&_Ch, 1, &_Res, 1, _Ctype->_Page) == 0)
		_Res = _Ch;
#endif // XBOX
	return (_Res);
	}
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xstrcoll.c ===
/***
*xstrcoll.c - Collate locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  PJP   Created from strcoll.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       05-14-96  JWM   Bug fix to _Strcoll(): error path failed to unlock.
*       09-26-96  GJF   Made _GetColl() multithread safe.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-11-99  PML   Win64 fix: cast ptr diff to int
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strcoll */
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*int _Strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1b = pointer to beginning of the first string
*       const char *s1e = pointer past end of the first string
*       const char *s2b = pointer to beginning of the second string
*       const char *s1e = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

_CRTIMP2 int __cdecl _Strcoll (
        const char *_string1,
        const char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;
#endif
        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);

        _lock_locale( local_lock_flag )

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = memcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

#ifndef _XBOX
        if ( 0 == (ret = __crtCompareStringA( handle,
                                              0,
                                              _string1,
                                              n1,
                                              _string2,
                                              n2,
                                              ___lc_collate_cp_func() )) )
            goto error_cleanup;

        _unlock_locale( local_lock_flag )
        return (ret - 2);

error_cleanup:

#endif // XBOX

        _unlock_locale( local_lock_flag )
        errno = EINVAL;
        return _NLSCMPERROR;
}


/***
*_Collvec _Getcoll() - get collation info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Collvec __cdecl _Getcoll()
{
        _Collvec coll;
#ifdef  _MT
        int local_lock_flag;
#endif
        _lock_locale( local_lock_flag )
        coll._Hand = ___lc_handle_func()[LC_COLLATE];
        coll._Page = ___lc_collate_cp_func();
        _unlock_locale( local_lock_flag )

        return (coll);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xstrxfrm.c ===
/***
*xstrxfrm.c - Transform a string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from strxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <xlocinfo.h>   /* for _Collvec, _Strxfrm */
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#ifdef  CRTDLL2
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#ifdef  _DLL
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP2
#endif  /* _DLL */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/***
*size_t _Strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _end1 - _string1 characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*               1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, _Strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = pointer to beginning of result string
*       char *_end1          = pointer past end of result string
*       const char *_string2 = pointer to beginning of source string
*       const char *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl _Strxfrm (
        char *_string1,
        char *_end1,
        const char *_string2,
        const char *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int dstlen;
        int retval = INT_MAX;   /* NON-ANSI: default if OM or API error */
        LCID handle;
        UINT codepage;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_COLLATE];
            codepage = ___lc_collate_cp_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ((handle == _CLOCALEHANDLE) &&
            (codepage == _CLOCALECP)) 
        {
            _unlock_locale( local_lock_flag )
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2);
            return _n2;
        }

#ifndef _XBOX

        /* Inquire size of dst string in BYTES */
        if (0 == (dstlen = __crtLCMapStringA(handle,
                                             LCMAP_SORTKEY, 
                                             _string2, 
                                             (int)_n2, 
                                             NULL, 
                                             0, 
                                             codepage,
                                             TRUE)))
                goto error_cleanup;

        retval = dstlen;

        /* if not enough room, return amount needed */
        if (dstlen > (int)(_n1))
            goto error_cleanup;

        /* Map src string to dst string */
        if (0 == __crtLCMapStringA(handle,
                                   LCMAP_SORTKEY, 
                                   _string2, 
                                   (int)_n2, 
                                   _string1, 
                                   (int)_n1, 
                                   codepage,
                                   TRUE))
            goto error_cleanup;

error_cleanup:

#else // XBOX

        retval = 0;

#endif // XBOX

        _unlock_locale( local_lock_flag )
        return (size_t)retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xvalues.c ===
/* values used by math functions -- IEEE 754 version */
#include "xmath.h"
_STD_BEGIN

		/* macros */
#define NBITS	(48 + _DOFF)
 #if _D0 == 0
  #define INIT(w0)		{w0, 0, 0, 0}
  #define INIT2(w0, w1)	{w0, 0, 0, w1}
 #else
  #define INIT(w0)		{0, 0, 0, w0}
  #define INIT2(w0, w1)	{w1, 0, 0, w0}
 #endif

		/* static data */
_CRTIMP2 const _Dconst _Denorm = {INIT2(0, 1)};
_CRTIMP2 const _Dconst _Eps = {INIT((_DBIAS - NBITS - 1) << _DOFF)};
_CRTIMP2 const _Dconst _Hugeval = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Inf = {INIT(_DMAX << _DOFF)};
_CRTIMP2 const _Dconst _Nan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};
_CRTIMP2 const _Dconst _Rteps = {INIT((_DBIAS - NBITS / 2) << _DOFF)};
_CRTIMP2 const _Dconst _Snan = {INIT(_DSIGN | (_DMAX << _DOFF)
	| (1 << (_DOFF - 1)))};

_CRTIMP2 const double _Xbig = (NBITS + 1) * 347L / 1000;
_CRTIMP2 const double _Zero = 0.0;
_STD_END

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xwctomb.c ===
/***
*xwctomb.c - Convert wide character to multibyte character, with locale.
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Convert a wide character into the equivalent multibyte character.
*
*Revision History:
*       12-XX-95  PJP   Created from wctomb.c December 1995 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-26-96  GJF   Made _Getcvt() and wcsrtombs() multithread safe.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <stdlib.h>
#include <mtdll.h>
#include <errno.h>
#include <limits.h>             /* for MB_LEN_MAX */
#include <string.h>             /* for memcpy */
#include <stdio.h>              /* for EOF */
#include <xlocinfo.h>           /* for _Cvtvec, _Wcrtomb */
#include <locale.h>
#include <setlocal.h>

#ifndef _MT
#define __Wcrtomb_lk    _Wcrtomb
#endif

/***
*int _Wcrtomb() - Convert wide character to multibyte character.
*
*Purpose:
*       Convert a wide character into the equivalent multi-byte character,
*       according to the specified LC_CTYPE category, or the current locale.
*       [ANSI].
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*              Non-C locale support now available under _INTL switch.
*Entry:
*       char *s             = pointer to multibyte character
*       wchar_t wchar       = source wide character
*       mbstate_t *pst      = pointer to state (not used)
*       const _Cvtvec *ploc = pointer to locale info
*
*Exit:
*       Returns:
*      -1 (if error) or number of bytes comprising converted mbc
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
        (
        char *s,
        wchar_t wchar,
        mbstate_t *,
        const _Cvtvec *ploc
        );

_CRTIMP2 int __cdecl _Wcrtomb
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
        int retval;
        int local_lock_flag;

        _lock_locale( local_lock_flag )
        retval = __Wcrtomb_lk(s, wchar, 0, ploc);
        _unlock_locale( local_lock_flag )
        return retval;
}
#endif  /* _MT */

#ifdef _MT
_CRTIMP2 int __cdecl __Wcrtomb_lk
#else  /* _MT */
_CRTIMP2 int __cdecl _Wcrtomb
#endif  /* _MT */
        (
        char *s,
        wchar_t wchar,
        mbstate_t *pst,
        const _Cvtvec *ploc
        )
{
#ifndef _XBOX
        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if ( handle == _CLOCALEHANDLE )
        {
            if ( wchar > 255 )  /* validate high byte */
            {
                errno = EILSEQ;
                return -1;
            }

            *s = (char) wchar;
            return sizeof(char);
        } else {
            int size;
            BOOL defused = 0;

            if ( ((size = WideCharToMultiByte(codepage,
                                              0,
                                              &wchar, 
                                              1,
                                              s, 
                                              ___mb_cur_max_func(), 
                                              NULL, 
                                              &defused)) == 0) || 
                 (defused) )
            {
                errno = EILSEQ;
                return -1;
            }

            return size;
        }
#else // XBOX

        if ( wchar > 255 )  /* validate high byte */
        {
            errno = EILSEQ;
            return -1;
        }

        *s = (char) wchar;
        return sizeof(char);

#endif // XBOX
}


/***
*_Cvtvec _Getcvt() - get conversion info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Cvtvec __cdecl _Getcvt()
{
        _Cvtvec cvt;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )
        cvt._Hand = ___lc_handle_func()[LC_CTYPE];
        cvt._Page = ___lc_codepage_func();
        _unlock_locale( local_lock_flag )

        return (cvt);
}


/***
*size_t wcrtomb(s, wchar, pst) - translate wchar_t to multibyte, restartably
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcrtomb(
        char *s, 
        wchar_t wchar, 
        mbstate_t *pst
        )
{
        return (s == 0 ? 1 : _Wcrtomb(s, wchar, 0, 0));
}


/***
*size_t wcsrtombs(s, pwcs, n, pst) - translate wide char string to multibyte 
*       string
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 size_t __cdecl wcsrtombs(
        char *s, 
        const wchar_t **pwcs, 
        size_t n, 
        mbstate_t *pst
        )
{
        char buf[MB_LEN_MAX];
        int i;
        size_t nc = 0;
        const wchar_t *wcs = *pwcs;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        if (s == 0)
            for (; ; nc += i, ++wcs)
            {   /* translate but don't store */
                if ((i = __Wcrtomb_lk(buf, *wcs, 0, 0)) <= 0) {
                    _unlock_locale( local_lock_flag )
                    return ((size_t)-1);
                }
                else if (buf[i - 1] == '\0') {
                    _unlock_locale( local_lock_flag )
                    return (nc + i - 1);
                }
            }

        for (; 0 < n; nc += i, ++wcs, s += i, n -= i)
        {   /* translate and store */
            char *t;

            if (n < (size_t)___mb_cur_max_func())
                t = buf;
            else
                t = s;

            if ((i = __Wcrtomb_lk(t, *wcs, 0, 0)) <= 0)
            {   /* encountered invalid sequence */
                nc = (size_t)-1;
                break;
            }

            if (s == t)
                ;
            else if (n < (size_t)i)
                break;  /* won't all fit */
            else
                memcpy(s, buf, i);

            if (s[i - 1] == '\0')
            {   /* encountered terminating null */
                *pwcs = 0;
                _unlock_locale( local_lock_flag )
                return (nc + i - 1);
            }
        }

        _unlock_locale( local_lock_flag )

        *pwcs = wcs;
        return (nc);
}


/***
*int wctob(wchar) - translate wint_t to one-byte multibyte
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 int __cdecl wctob(
        wint_t wchar
        )
{  
        if (wchar == WEOF)
            return (EOF);
        else
        {   /* check for one-byte translation */
            char buf[MB_LEN_MAX];
            return (_Wcrtomb(buf, wchar, 0, 0) == 1 ? buf[0] : EOF);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\_toupper.c ===
/***
*_toupper.c - convert character to uppercase
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Toupper()
*
*Revision History:.
*       01-XX-96  PJP   Created from toupper.c January 1996 by P.J. Plauger
*       04-17-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in
*                       msvcprt.lib to work with STATIC_CPPLIB
*       03-12-01  PML   Use supplied locale to check case VS7#190902
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>

/* remove macro definitions of _toupper() and toupper()
 */
#undef  _toupper
#undef  toupper

/***
*int _toupper(c) - convert character to uppercase
*
*Purpose:
*       _toupper() is a version of toupper with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of uppercase representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Toupper (
        int c,
        const _Ctypevec *ploc
        )
{
#ifndef _XBOX
#ifdef _MT

        LCID handle;
        int local_lock_flag;

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_CTYPE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'a') && (c <= 'z') )
                c = c - ('a' - 'A');
            return c;
        }

        _lock_locale( local_lock_flag )

        c = _Toupper_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;
}

/***
*int _toupper_lk(c) - convert character to uppercase
*
*Purpose:
*       Multi-thread function only! Non-locking version of toupper.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _Toupper_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'a') && (c <= 'z') )
                c = c - ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!islower(c))
                {
                    return c;
                }
            }
            else
            {
                if (!ploc->_Table[c] & _LOWER)
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (_cpp_isleadbyte(c >> 8 & 0xff))
        {
            inbuffer[0] = (c >> 8 & 0xff); 
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to uppercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_UPPERCASE,
            inbuffer, size, outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else // XBOX

        return(islower(c) ? toupper(c) : c);

#endif // XBOX
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL && !STATIC_CPPLIB
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL && !STATIC_CPPLIB

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xwcsxfrm.c ===
/***
*xwcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*               
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       01-XX-96  PJP   Created from wcsxfrm.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcsxfrm */

/***
*size_t _Wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _end1 - _string1 wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = pointer to beginning of result string
*       wchar_t *_end1          = pointer past end of result string
*       const wchar_t *_string2 = pointer to beginning of source string
*       const wchar_t *_end2    = pointer past end of source string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       Length of the transformed string.
*       If the value returned is too big, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl _Wcsxfrm (
        wchar_t *_string1,
        wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{
        size_t _n1 = _end1 - _string1;
        size_t _n2 = _end2 - _string2;
        int size = INT_MAX;
        unsigned char *bbuffer;
        LCID handle;
#ifdef _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            _unlock_locale( local_lock_flag )
            if (_n2 <= _n1)
                memcpy(_string1, _string2, _n2 * sizeof (wchar_t));
                return _n2;
        }

#ifndef _XBOX

        /*
         * When using LCMAP_SORTKEY, LCMapStringW handles BYTES not wide
         * chars. We use a byte buffer to hold bytes and then convert the
         * byte string to a wide char string and return this so it can be
         * compared using wcscmp(). User's buffer is _n1 wide chars, so
         * use an internal buffer of _n1 bytes.
         */

        if (NULL == (bbuffer = (unsigned char *)_malloc_crt(_n1)))
            goto error_cleanup;

        if (0 == (size = __crtLCMapStringW(handle, 
                                           LCMAP_SORTKEY,
                                           _string2,
                                           (int)_n2,
                                           (wchar_t *)bbuffer,
                                           (int)_n1,
                                           ___lc_collate_cp_func())))
        {
            /* buffer not big enough, get size required. */

            if (0 == (size = __crtLCMapStringW(handle,
                                               LCMAP_SORTKEY,
                                               _string2,
                                               (int)_n2,
                                               NULL,
                                               0,
                                               ___lc_collate_cp_func())))
                size = INT_MAX; /* default error */

        } else {
            int i;
            /* string successfully mapped, convert to wide char */

            for (i = 0; i < size; i++)
                _string1[i] = (wchar_t)bbuffer[i];
        }

error_cleanup:
        _unlock_locale( local_lock_flag )
        _free_crt(bbuffer);

#else // XBOX

        _unlock_locale( local_lock_flag )
        size = 0;

#endif // XBOX

        return (size_t)size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\STL.H ===
// stl.h supplemental header
#pragma once
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque
		: public deque<_Ty, allocator<_Ty> >
	{	// wrap new deque as old
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Deque()
		: deque<_Ty, _Alloc>()
		{	// construct empty deque
		}

	explicit Deque(size_type _Count)
		: deque<_Ty, _Alloc>(_Count, _Ty())
		{	// construct deque from _Count * _Ty()
		}

	Deque(size_type _Count, const _Ty& _Val)
		: deque<_Ty, _Alloc>(_Count, _Val)
		{	// construct deque from _Count * _Val
		}

	typedef const_iterator _Iter;

	Deque(_Iter _First, _Iter _Last)
		: deque<_Ty, _Alloc>(_First, _Last)
		{	// construct deque from [_First, _Last)
		}
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List
		: public list<_Ty, allocator<_Ty> >
	{	// wrap new list as old
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	List()
		: list<_Ty, _Alloc>()
		{	// construct empty list
		}

	explicit List(size_type _Count)
		: list<_Ty, _Alloc>(_Count, _Ty())
		{	// construct list from _Count * _Ty()
		}

	List(size_type _Count, const _Ty& _Val)
		: list<_Ty, _Alloc>(_Count, _Val)
		{	// construct list from _Count * _Val
		}

	typedef const_iterator _Iter;

	List(_Iter _First, _Iter _Last)
		: list<_Ty, _Alloc>(_First, _Last)
		{	// construct list from [_First, _Last)
		}
	};

		// TEMPLATE CLASS Map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Map
		: public map<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new map as old
public:
	typedef Map<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Map()
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Map(const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Map(_Iter _First, _Iter _Last)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Map(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Multimap
		: public multimap<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new multimap as old
public:
	typedef Multimap<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Multimap()
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Multimap(const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Multimap(_Iter _First, _Iter _Last)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Multimap(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Set
template<class _Kty,
	class _Pr = less<_Kty> >
	class Set
		: public set<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new set as old
public:
	typedef Set<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Set()
		: set<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Set(const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Set(_Iter _First, _Iter _Last)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Set(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multiset
template<class _Kty,
	class _Pr = less<_Kty> >
	class Multiset
		: public multiset<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new multiset as old
public:
	typedef Multiset<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Multiset()
		: multiset<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Multiset(const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Multiset(_Iter _First, _Iter _Last)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Multiset(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector
		: public vector<_Ty, allocator<_Ty> >
	{	// wrap new vector as old
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Vector()
		: vector<_Ty, _Alloc>()
		{	// construct empty vector
		}

	explicit Vector(size_type _Count)
		: vector<_Ty, _Alloc>(_Count, _Ty())
		{	// construct vector from _Count * _Ty()
		}

	Vector(size_type _Count, const _Ty& _Val)
		: vector<_Ty, _Alloc>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	Vector(_Iter _First, _Iter _Last)
		: vector<_Ty, _Alloc>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// CLASS bit_vector
class bit_vector
	: public vector<_Bool, _Bool_allocator>
	{	// wrap new vector<bool> as old
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _Alloc;
	typedef bit_vector _Myt;

	bit_vector()
		: vector<_Bool, _Bool_allocator>()
		{	// construct empty vector
		}

	explicit bit_vector(size_type _Count, const _Ty& _Val = _Ty())
		: vector<_Bool, _Bool_allocator>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	bit_vector(_Iter _First, _Iter _Last)
		: vector<_Bool, _Bool_allocator>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// TEMPLATE CLASS priority_queue
template<class _Container,
	class _Pr = less<_Container::value_type> >
	class Priority_queue
		: public priority_queue<_Container::value_type, _Container, _Pr>
	{	// wrap new priority_queue as old
public:
	typedef typename _Container::value_type _Ty;

	Priority_queue()
		: priority_queue<_Ty, _Container, _Pr>(_Pr())
		{	// construct empty queue from defaults
		}

	explicit Priority_queue(const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_Pred)
		{	// construct empty queue from comparator
		}

	typedef const _Ty *_Iter;

	Priority_queue(_Iter _First, _Iter _Last)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pr())
		{	// construct queue from [_First, _Last)
		}

	Priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS queue
template<class _Container>
	class Queue
		: public queue<_Container::value_type, _Container>
	{	// wrap new queue as old
	};

		// TEMPLATE CLASS stack
template<class _Container>
	class Stack
		: public stack<_Container::value_type, _Container>
	{	// wrap new stack as old
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif /* _STL_H_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\_tolower.c ===
/***
*_tolower.c - convert character to lower case
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _Tolower().
*
*Revision History:
*       01-xx-96  PJP   Created from tolower.c, January 1996 by P.J. Plauger
*       04-16-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       09-25-96  GJF   Added locale locking to _Getctype.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in
*                       msvcprt.lib to work with STATIC_CPPLIB
*       03-12-01  PML   Use supplied locale to check case VS7#190902
*       04-03-01  PML   Reverse lead/trail bytes in composed char (vs7#232853)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <stddef.h>
#include <xlocinfo.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <stdlib.h>
#include <dbgint.h>

/* remove macro definitions of _tolower() and tolower()
 */
#undef  _tolower
#undef  tolower

/***
*int _tolower(c) - convert character to lower case
*
*Purpose:
*       _tolower() is a version of tolower with a locale argument.
*
*Entry:
*       c - int value of character to be converted
*       const _Ctypevec * = pointer to locale info
*
*Exit:
*       returns int value of lower case representation of c
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT
int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        );
#endif

_CRTIMP2 int __cdecl _Tolower (
        int c,
        const _Ctypevec *ploc
        )
{
#ifndef _XBOX
#ifdef _MT

        LCID handle;
        int local_lock_flag;

        if (ploc == 0)
            handle = ___lc_handle_func()[LC_CTYPE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'A') && (c <= 'Z') )
                c = c + ('a' - 'A');
            return c;
        }

        _lock_locale( local_lock_flag )

        c = _Tolower_lk(c, ploc);

        _unlock_locale( local_lock_flag )

        return c;
}

/***
*int _tolower_lk(c) - convert character to lower case
*
*Purpose:
*       Multi-thread function only! Non-locking version of tolower.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _Tolower_lk (
        int c,
        const _Ctypevec *ploc
        )
{

#endif  /* _MT */

        int size;
        unsigned char inbuffer[3];
        unsigned char outbuffer[3];

        LCID handle;
        UINT codepage;

        if (ploc == 0)
        {
            handle = ___lc_handle_func()[LC_CTYPE];
            codepage = ___lc_codepage_func();
        }
        else
        {
            handle = ploc->_Hand;
            codepage = ploc->_Page;
        }

        if (handle == _CLOCALEHANDLE)
        {
            if ( (c >= 'A') && (c <= 'Z') )
                c = c + ('a' - 'A');
            return c;
        }

        /* if checking case of c does not require API call, do it */
        if ((unsigned)c < 256)
        {
            if (ploc == 0)
            {
                if (!isupper(c))
                {
                    return c;
                }
            }
            else
            {
                if (!ploc->_Table[c] & _UPPER)
                {
                    return c;
                }
            }
        }

        /* convert int c to multibyte string */
        if (_cpp_isleadbyte(c >> 8 & 0xff))
        {
            inbuffer[0] = (c >> 8 & 0xff); 
            inbuffer[1] = (unsigned char)c;
            inbuffer[2] = 0;
            size = 2;
        } else {
            inbuffer[0] = (unsigned char)c;
            inbuffer[1] = 0;
            size = 1;
        }

        /* convert wide char to lowercase */
        if (0 == (size = __crtLCMapStringA(handle, LCMAP_LOWERCASE,
            inbuffer, size, outbuffer, 3, codepage, TRUE)))
        {
            return c;
        }

        /* construct integer return value */
        if (size == 1)
            return ((int)outbuffer[0]);
        else
            return ((int)outbuffer[1] | ((int)outbuffer[0] << 8));

#else // XBOX

        return(isupper(c) ? tolower(c) : c);

#endif // XBOX
}


/***
*_Ctypevec _Getctype() - get ctype info for current locale
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP2 _Ctypevec __cdecl _Getctype()
{       
        /* get ctype info for current locale */
        _Ctypevec ctype;
#ifdef  _MT
        int local_lock_flag;
#endif

        _lock_locale( local_lock_flag )

        ctype._Hand = ___lc_handle_func()[LC_COLLATE];
        ctype._Page = ___lc_codepage_func();
        ctype._Table = _malloc_crt(256 * sizeof (*__pctype_func()));
        if (ctype._Table != 0)
        {
            memcpy((void *)ctype._Table, __pctype_func(), 256 * sizeof (*__pctype_func()));
            ctype._Delfl = 1; 
        }
        else
        {
            ctype._Table = (const short *)__pctype_func();
            ctype._Delfl = 0; 
        }

        _unlock_locale( local_lock_flag )

        return (ctype);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdcpp\xwcscoll.c ===
/***
*xwcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*Revision History:
*       01-XX-96  GJF   Created from wcscoll.c January 1996 by P.J. Plauger
*       04-18-96  GJF   Updated for current locale locking. Also, reformatted
*                       and made several cosmetic changes.
*       12-02-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       01-05-99  GJF   Changes for 64-bit size_t.
*       05-11-99  PML   Win64 fix: cast ptr diff to int
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>
#include <xlocinfo.h>   /* for _Collvec, _Wcscoll */

/***
*static int _Wmemcmp(s1, s2, n) - compare wchar_t s1[n], s2[n]
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static int _Wmemcmp(
        const wchar_t *s1, 
        const wchar_t *s2, 
        int n
        )
{
        for (; 0 < n; ++s1, ++s2, --n)
             if (*s1 != *s2)
               return (*s1 < *s2 ? -1 : +1);
        return (0);
}

/***
*int _Wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *_string1 = pointer to beginning of the first string
*       const wchar_t *_end1    = pointer past end of the first string
*       const wchar_t *_string2 = pointer to beginning of the second string
*       const wchar_t *_end2    = pointer past end of the second string
*       const _Collvec *ploc = pointer to locale info
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _Wcscoll (
        const wchar_t *_string1,
        const wchar_t *_end1,
        const wchar_t *_string2,
        const wchar_t *_end2,
        const _Collvec *ploc
        )
{

        int n1 = (int)(_end1 - _string1);
        int n2 = (int)(_end2 - _string2);
        int ret;
        LCID handle;
#ifdef  _MT
        int local_lock_flag;

        _lock_locale( local_lock_flag )
#endif
        if (ploc == 0)
            handle = ___lc_handle_func()[LC_COLLATE];
        else
            handle = ploc->_Hand;

        if (handle == _CLOCALEHANDLE) {
            int ans;
            _unlock_locale( local_lock_flag )
            ans = _Wmemcmp(_string1, _string2, n1 < n2 ? n1 : n2);
            return ans != 0 || n1 == n2 ? ans : n1 < n2 ? -1 : +1;
        }

#ifndef _XBOX

        if (0 == (ret = __crtCompareStringW(handle, 
                                            0, 
                                            _string1, 
                                            n1,
                                            _string2, 
                                            n2, 
                                            ___lc_collate_cp_func())))
        {
            _unlock_locale( local_lock_flag )
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        _unlock_locale( local_lock_flag )
        return (ret - 2);

#else // XBOX

        errno = EINVAL;
        return _NLSCMPERROR;

#endif // XBOX
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __cdecl _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Log(double, int);
_CRTIMP2 double __cdecl _Sin(double, unsigned int);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FLog(float, int);
_CRTIMP2 float __cdecl _FSin(float, unsigned int);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LLog(long double, int);
_CRTIMP2 long double __cdecl _LSin(long double, unsigned int);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
_CRTIMP2 extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
_C_STD_END
#endif /* _YMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\cscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the keyboard.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#ifndef _XBSTRICT

#define CPRFLAG 1
#include "input.c"

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\cwprintf.c ===
/***
*cwprintf.c - Conio version of wprintf
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the console.
*
*Revision History:
*       02-11-00  GB    Stub module created.
*
*******************************************************************************/

#ifndef _XBSTRICT

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#define CPRFLAG 1
#include "output.c"

#endif /* _POSIX_ */

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\cprintf.c ===
/***
*cprintf.c - Conio version of printf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the console.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#ifndef _XBSTRICT

#define CPRFLAG 1
#include "output.c"

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\clearerr.c ===
/***
*clearerr.c - clear error and eof flags
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines clearerr() - clear error and eof flags from a stream
*
*Revision History:
*       11-30-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-01-88  JCR   Clear lowio flags as well as stdio flags
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <internal.h>
#ifndef _POSIX_
#include <msdos.h>
#endif

/***
*void clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       No return value.
*       changes the _flag field of the FILE struct.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl clearerr (
        FILE *stream
        )
{
        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        /* Clear stdio level flags */
        stream->_flag &= ~(_IOERR|_IOEOF);

        /* Clear lowio level flags */

#ifndef _POSIX_
        _osfile_safe(_fileno(stream)) &= ~(FEOFLAG);
#endif

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX 
#define _X_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGE	_CATMASK(_X_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2 int __cdecl _Getdateorder();
_CRTIMP2 char *__cdecl _Getdays();
_CRTIMP2 char *__cdecl _Getmonths();
_CRTIMP2 void *__cdecl _Gettnames();

_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2 float __cdecl _Stof(const char *, char **, long);
_CRTIMP2 double __cdecl _Stod(const char *, char **, long);
_CRTIMP2 long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\closeall.c ===
/***
*closeall.c - close all open files
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fcloseall() - closes all open files except stdin, stdout
*       stdprn, stderr, and stdaux.
*
*Revision History:
*       09-19-83  RN    initial version
*       06-26-87  JCR   Stream search starts with _iob[3] for OS/2
*       11-02-87  JCR   Multi-thread support
*       11-08-87  SKS   Changed PROTMODE to OS2
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Added check that OS2 is defined whenever M_I386 is.
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       03-25-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       03-06-95  GJF   Converted to walk the __piob[] table (rather than
*                       the _iob[] table).
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int _fcloseall() - close all open streams
*
*Purpose:
*       Closes all streams currently open except for stdin/out/err/aux/prn.
*       tmpfile() files are among those closed.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed if OK
*       returns EOF if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fcloseall (
        void
        )
{
        REG2 int count = 0;
        REG1 i;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 3 ; i < _nstream ; i++ ) {

            if ( __piob[i] != NULL ) {
                /*
                 * if the stream is in use, close it
                 */
                if ( inuse( (FILE *)__piob[i] ) && (fclose( __piob[i] ) !=
                     EOF) )
                        count++;

                /*
                 * if stream is part of a _FILEX we allocated, free it.
                 */
                if ( i >= _IOB_ENTRIES ) {

#ifdef  _MT
                    DeleteCriticalSection( &(((_FILEX *)__piob[i])->lock) );
#endif
                    _free_crt( __piob[i] );
                    __piob[i] = NULL;
                }
            }
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#define _CPPLIB_VER	310

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	_MT	/* nontrivial locks if multithreaded */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */
 #else
  #define _TLS_QUAL
 #endif

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif

 #define _HAS_TEMPLATE_PARTIAL_ORDERING	0

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
  #ifdef  CRTDLL2
   #define _CRTIMP2	__declspec(dllexport)
  #else   /* ndef CRTDLL2 */
   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)
   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */
  #endif  /* CRTDLL2 */
 #endif  /* _CRTIMP2 */

 #ifndef _INTERNAL_IFSTRIP_
 /* These functions are for enabling STATIC_CPPLIB functionality */
    #define _cpp_stdin  (&(__iob_func())[0])
    #define _cpp_stdout (&(__iob_func())[1])
    #define _cpp_stderr (&(__iob_func())[2])
    #define _cpp_isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
 #endif
 #if defined(_DLL) && !defined(_STATIC_CPPLIB)
  #define _DLL_CPPLIB
 #endif

 #ifndef _INTERNAL_IFSTRIP_
/* Define _CRTBLD_NATIVE_WCHAR_T */
 #if defined(_CRTBLD) && defined(__cplusplus)
  #ifndef _NATIVE_WCHAR_T_DEFINED
   #error Native wchar_t must be defined
  #else
   #define _CRTBLD_NATIVE_WCHAR_T
  #endif /* _NATIVE_WCHAR_T_DEFINED */
 #endif /* defined(_CRTBLD) && defined(__cplusplus) */
 #endif

 #if (1300 <= _MSC_VER)
  #define _DEPRECATED	__declspec(deprecated)
 #else
  #define _DEPRECATED
 #endif

		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}

  #define _CSTD			::
   #define _C_STD_BEGIN	/* match _STD_BEGIN/END if *.c compiled as C++ */
   #define _C_STD_END

  #define _C_LIB_DECL	extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL }
  #define _EXTERN_C		extern "C" {
  #define _END_EXTERN_C }

 #else /* __cplusplus */
  #define _STD
  #define _STD_BEGIN
  #define _STD_END

  #define _CSTD
  #define _C_STD_BEGIN
  #define _C_STD_END

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _MAX_LOCK		3	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit
class _CRTIMP2 _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD
	explicit _Lockit();	// set default lock
	explicit _Lockit(int);	// set the lock
	~_Lockit();	// clear the lock

private:
	_Lockit(const _Lockit&);				// not defined
	_Lockit& operator=(const _Lockit&);	// not defined

	int _Locktype;
  #else /* _MULTI_THREAD */
   #define _LOCKIT(x)
	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2 _Mutex
	{	// lock under program control
public:
  #if _MULTI_THREAD
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	void *_Mtx;
  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
	_Init_locks();
	~_Init_locks();
 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */ 
	};
_STD_END
 #endif /* __cplusplus */


		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_EXTERN_C
_CRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));
_END_EXTERN_C

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#endif /* _YVALS */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdhpp\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else   /* ndef CRTDLL2 */
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* CRTDLL2 */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\cwscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Perform formatted i/o directly to the keyboard.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#ifndef _XBSTRICT

#define CPRFLAG 1
#include "winput.c"

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fclose.c ===
/***
*fclose.c - close a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fclose() - close an open file
*
*Revision History:
*       09-02-83  RN    initial version
*       05-14-87  SKS   error return from fflush must not be clobbered
*       08-10-87  JCR   Added code to support P_tmpdir with or without trailing '\'
*       11-01-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       03-11-92  GJF   For Win32, revised temporary file cleanup.
*       03-25-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       01-13-93  GJF   Don't need/want to remove() tmp files on Windows NT
*                       (file is removed by the OS when handle is closed).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Remove Cruiser support.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version. Removed some useless #ifdef-s.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       05-12-95  CFW   Paranoia: set _tmpfname field to NULL.
*       02-25-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <string.h>
#include <io.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int fclose(stream) - close a stream
*
*Purpose:
*       Flushes and closes a stream and frees any buffer associated
*       with that stream, unless it was set with setbuf.
*
*Entry:
*       FILE *stream - stream to close
*
*Exit:
*       returns 0 if OK, EOF if fails (can't _flush, not a FILE, not open, etc.)
*       closes the file -- affecting FILE structure
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT      /* multi-thread; define both fclose and _fclose_lk */

int __cdecl fclose (
        FILE *stream
        )
{
        int result = EOF;

        _ASSERTE(stream != NULL);

        /* If stream is a string, simply clear flag and return EOF */
        if (stream->_flag & _IOSTRG)
                stream->_flag = 0;  /* IS THIS REALLY NEEDED ??? */

        /* Stream is a real file. */
        else {
                _lock_str(stream);
                __try {
                        result = _fclose_lk(stream);
                }
                __finally {
                        _unlock_str(stream);
                }
        }

        return(result);
}

/***
*int _fclose_lk() - close a stream (lock already held)
*
*Purpose:
*       Core fclose() routine; assumes caller has stream lock held.
*
*       [See fclose() above for more information.]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fclose_lk (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int result = EOF;

        /* Init near stream pointer */
        stream = str;

#else       /* non multi-thread; just define fclose() */

int __cdecl fclose (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int result = EOF;

        /* Init near stream pointer */
        stream = str;

        if (stream->_flag & _IOSTRG) {
                stream->_flag = 0;
                return(EOF);
        }

#endif

        _ASSERTE(str != NULL);

        if (inuse(stream)) {

                /* Stream is in use:
                       (1) flush stream
                       (2) free the buffer
                       (3) close the file
                       (4) delete the file if temporary
                */

                result = _flush(stream);
                _freebuf(stream);

#ifdef _POSIX_
                if (close(fileno(stream)) <0)
#else
                if (_close(_fileno(stream)) < 0)
#endif
                        result = EOF;

                else if ( stream->_tmpfname != NULL ) {
                        /*
                         * temporary file (i.e., one created by tmpfile()
                         * call). delete, if necessary (don't have to on
                         * Windows NT because it was done by the system when
                         * the handle was closed). also, free up the heap
                         * block holding the pathname.
                         */
#ifdef _POSIX_
                        if ( unlink(stream->_tmpfname) )
                                result = EOF;
#endif

                        _free_crt(stream->_tmpfname);
                stream->_tmpfname = NULL;
                }

        }

        stream->_flag = 0;
        return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fdopen.c ===
/***
*fdopen.c - open a file descriptor as stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fdopen() - opens a file descriptor as a stream, thus allowing
*       buffering, etc.
*
*Revision History:
*       09-02-83  RN    initial version
*       03-02-87  JCR   added support for 'b' and 't' embedded in mode strings
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-03-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       11-20-89  GJF   Fixed copyright, indents. Added const to type of mode.
*       02-15-90  GJF   _iob[], _iob2[] merge.
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-24-90  SBM   Added support for 'c' and 'n' flags
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       05-01-92  DJM   Replaced _nfile with OPEN_MAX for POSIX.
*       08-03-92  GJF   Function name must be "fdopen" for POSIX.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       10-20-95  GJF   Added checks to passed supplied handle is open (for
*                       Win32 and Mac builds) (Olympus0 10153).
*       09-26-97  BWT   Fix POSIX
*       02-26-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*
*******************************************************************************/

#include <cruntime.h>
#include <msdos.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#ifdef  _POSIX_
#include <limits.h>
#endif
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fdopen(filedes, mode) - open a file descriptor as a stream
*
*Purpose:
*       associates a stream with a file handle, thus allowing buffering, etc.
*       The mode must be specified and must be compatible with the mode
*       the file was opened with in the low level open.
*
*Entry:
*       int filedes - handle referring to open file
*       _TSCHAR *mode - file mode to use ("r", "w", "a", etc.)
*
*Exit:
*       returns stream pointer and sets FILE struct fields if successful
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfdopen (
        int filedes,
        REG2 const _TSCHAR *mode
        )
{
        REG1 FILE *stream;
        int whileflag, tbflag, cnflag;

        _ASSERTE(mode != NULL);

#if     !defined(_POSIX_)

        _ASSERTE((unsigned)filedes < (unsigned)_nhandle);
        _ASSERTE(_osfile(filedes) & FOPEN);

        if ( ((unsigned)filedes >= (unsigned)_nhandle) ||
             !(_osfile(filedes) & FOPEN) )
            return(NULL);

#else

        _ASSERTE((unsigned)filedes < OPEN_MAX);

        if ((unsigned)filedes >= OPEN_MAX)
            return(NULL);

#endif  /* !_POSIX_ */


        /* Find a free stream; stream is returned 'locked'. */

        if ((stream = _getstream()) == NULL) {
            errno = EMFILE;
            return(NULL);
        }

#ifdef  _MT
        __try {
#endif

        /* First character must be 'r', 'w', or 'a'. */

        switch (*mode) {
            case _T('r'):
                stream->_flag = _IOREAD;
                break;
            case _T('w'):
            case _T('a'):
                stream->_flag = _IOWRT;
                break;
            default:
                stream = NULL;  /* error */
                goto done;
                break;
        }

        /* There can be up to three more optional characters:
           (1) A single '+' character,
           (2) One of 'b' and 't' and
           (3) One of 'c' and 'n'.

           Note that currently, the 't' and 'b' flags are syntax checked
           but ignored.  'c' and 'n', however, are correctly supported.
        */

        whileflag=1;
        tbflag=cnflag=0;
        stream->_flag |= _commode;

        while(*++mode && whileflag)
            switch(*mode) {

                case _T('+'):
                    if (stream->_flag & _IORW)
                        whileflag=0;
                    else {
                        stream->_flag |= _IORW;
                        stream->_flag &= ~(_IOREAD | _IOWRT);
                    }
                    break;

                case _T('b'):
                case _T('t'):
                    if (tbflag)
                        whileflag=0;
                    else
                        tbflag=1;
                    break;

                case _T('c'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        stream->_flag |= _IOCOMMIT;
                    }
                    break;

                case _T('n'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        stream->_flag &= ~_IOCOMMIT;
                    }
                    break;

                default:
                    whileflag=0;
                    break;
            }

#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */

        stream->_file = filedes;

/* Common return */

done:
#ifdef  _MT
        ; }
        __finally {
            _unlock_str(stream);
        }
#endif
        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetc.c ===
/***
*fgetc.c - get a character from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetc() and getc() - read  a character from a stream
*
*Revision History:
*       09-01-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-21-89  PHG   Added getc() function
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to fgetwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       07-20-97  GJF   Made getc() identical to fgetc(). Also, detab-ed.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fgetc(stream), getc(stream) - read a character from a stream
*
*Purpose:
*       reads a character from the given stream
*
*Entry:
*       FILE *stream - stream to read character from
*
*Exit:
*       returns the character read
*       returns EOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fgetc (
        REG1 FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getc_lk(stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#undef getc

int __cdecl getc (
        FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getc_lk(stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetpos.c ===
/***
*fgetpos.c - Contains the fgetpos runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Get file position (in an internal format).
*
*Revision History:
*       01-16-87  JCR   Module created.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-15-90  GJF   Fixed copyright and indents
*       03-16-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-23-94  GJF   Use 64-bit file position (_ftelli64) for non-_MAC_.
*       01-05-94  GJF   Temporarily commented out above change due to MFC/IDE
*                       bugs.
*       01-24-95  GJF   Restored 64-bit fpos_t support.
*       06-28-96  SKS   Enable 64-bit fpos_t support for the MAC
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fgetpos(stream,pos) - Get file position (internal format)
*
*Purpose:
*       Fgetpos gets the current file position for the file identified by
*       [stream].  The file position is returned in the object pointed to
*       by [pos] and is in internal format; that is, the user is not supposed
*       to interpret the value but simply use it in the fsetpos call.  Our
*       implementation simply uses fseek/ftell.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file position value
*
*Exit:
*       Successful fgetpos call returns 0.
*       Unsuccessful fgetpos call returns non-zero (!0) value and sets
*       ERRNO (this is done by ftell and passed back by fgetpos).
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl fgetpos (
        FILE *stream,
        fpos_t *pos
        )
{
#ifdef _POSIX_
        if ( (*pos = ftell(stream)) != -1L )
#else
        if ( (*pos = _ftelli64(stream)) != -1i64 )
#endif
                return(0);
        else
                return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fflush.c ===
/***
*fflush.c - flush a stream buffer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fflush() - flush the buffer on a stream
*               _flushall() - flush all stream buffers
*
*Revision History:
*       09-01-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merge DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       11-29-89  GJF   Added support for fflush(NULL) (per ANSI). Merged in
*                       flushall().
*       01-24-90  GJF   Fixed fflush(NULL) functionality to comply with ANSI
*                       (must only call fflush() for output streams)
*       03-16-90  GJF   Made calling type  _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Made flsall() _CALLTYPE4.
*       05-09-90  SBM   _fflush_lk became _flush, added new [_]fflush[_lk]
*       07-11-90  SBM   Commit mode on a per stream basis
*       10-02-90  GJF   New-style function declarators.
*       12-12-90  GJF   Fixed mis-placed paran in ternary expr commiting the
*                       buffers.
*       01-16-91  SRW   Reversed test of _commit return value
*       01-21-91  GJF   ANSI naming.
*       06-05-91  GJF   On a successful _flush of a read/write stream in write
*                       mode, clear _IOWRT so that the next operation can be a
*                       read. ANSI requirement (C700 bug #2531).
*       07-30-91  GJF   Added support for termination scheme used on
*                       non-Cruiser targets [_WIN32_].
*       08-19-91  JCR   Added _exitflag, _endstdio
*       03-16-92  SKS   Moved _cflush to the initializer module (in assembler)
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       03-18-93  CFW   fflush_lk returns 0 before exit.
*       03-19-93  GJF   Revised flsall() so that, in multi-thread models,
*                       unused streams are not locked unnecessarily.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-10-93  GJF   Purged ftell call accidently checked in 3/10/93.
*       10-29-93  GJF   Define entry for termination section (used to be in
*                       in i386\cinitstd.asm). Also, replaced MTHREAD with
*                       _MT.
*       04-05-94  GJF   #ifdef-ed out _cflush definition for msvcrt*.dll, it
*                       is unnecessary.
*       08-18-94  GJF   Moved terminator stuff (including _cflush def) to
*                       _file.c
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       03-07-95  GJF   Changed flsall() to iterate over the __piob[] table.
*                       Also, changed to locks based on __piob.
*       12-28-95  GJF   Repaced reference to _NSTREAM_ with _nstream (users
*                       may change the max. number of supported streams).
*       08-01-96  RDK   Change termination pointer data type to static.
*       02-13-98  GJF   Changes for Win64: added int cast to pointer diff.
*       02-27-98  GJF   Exception-safe locking.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <fcntl.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <mtdll.h>
#include <internal.h>


/* Values passed to flsall() to distinguish between _flushall() and
 * fflush(NULL) behavior
 */
#define FLUSHALL        1
#define FFLUSHNULL      0

/* Core routine for fflush(NULL) and flushall()
 */
static int __cdecl flsall(int);


/***
*int fflush(stream) - flush the buffer on a stream
*
*Purpose:
*       if file open for writing and buffered, flush the buffer. if problems
*       flushing the buffer, set the stream flag to error
*       Always flushes the stdio stream and forces a commit to disk if file
*       was opened in commit mode.
*
*Entry:
*       FILE *stream - stream to flush
*
*Exit:
*       returns 0 if flushed successfully, or no buffer to flush
*       returns EOF and sets file error flag if fails.
*       FILE struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT

int __cdecl fflush (
        REG1 FILE *stream
        )
{
        int rc;

        /* if stream is NULL, flush all streams
         */
        if ( stream == NULL )
                return(flsall(FFLUSHNULL));

        _lock_str(stream);

        __try {
                rc = _fflush_lk(stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(rc);
}


/***
*_fflush_lk() - Flush the buffer on a stream (stream is already locked)
*
*Purpose:
*       Core flush routine; assumes stream lock is held by caller.
*
*       [See fflush() above for more information.]
*
*Entry:
*       [See fflush()]
*Exit:
*       [See fflush()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fflush_lk (
        REG1 FILE *str
        )
{

#else   /* non multi-thread */

int __cdecl fflush (
        REG1 FILE *str
        )
{

        /* if stream is NULL, flush all streams */
        if ( str == NULL ) {
                return(flsall(FFLUSHNULL));
        }

#endif  /* rejoin common code */

        if (_flush(str) != 0) {
                /* _flush failed, don't attempt to commit */
                return(EOF);
        }

        /* lowio commit to ensure data is written to disk */
#ifndef _POSIX_
        if (str->_flag & _IOCOMMIT) {
                return (_commit(_fileno(str)) ? EOF : 0);
        }
#endif
        return 0;
}


/***
*int _flush(stream) - flush the buffer on a single stream
*
*Purpose:
*       If file open for writing and buffered, flush the buffer.  If
*       problems flushing the buffer, set the stream flag to error.
*       Multi-thread version assumes stream lock is held by caller.
*
*Entry:
*       FILE* stream - stream to flush
*
*Exit:
*       Returns 0 if flushed successfully, or if no buffer to flush.,
*       Returns EOF and sets file error flag if fails.
*       File struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flush (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int rc = 0; /* assume good return */
        REG3 int nchar;

        /* Init pointer to stream */
        stream = str;

#ifdef _POSIX_

        /*
         * Insure that EBADF is returned whenever the underlying
         * file descriptor is closed.
         */

        if (-1 == fcntl(fileno(stream), F_GETFL))
                return(EOF);

        /*
         * Posix ignores read streams to insure that the result of
         * ftell() is the same before and after fflush(), and to
         * avoid seeking on pipes, ttys, etc.
         */

        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOREAD) {
                return 0;
        }

#endif /* _POSIX_ */

        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOWRT && bigbuf(stream)
                && (nchar = (int)(stream->_ptr - stream->_base)) > 0)
        {
#ifdef _POSIX_
                if ( write(fileno(stream), stream->_base, nchar) == nchar ) {
#else
                if ( _write(_fileno(stream), stream->_base, nchar) == nchar ) {
#endif
                        /* if this is a read/write file, clear _IOWRT so that
                         * next operation can be a read
                         */
                        if ( _IORW & stream->_flag )
                                stream->_flag &= ~_IOWRT;
                }
                else {
                        stream->_flag |= _IOERR;
                        rc = EOF;
                }
        }

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return(rc);
}


/***
*int _flushall() - flush all output buffers
*
*Purpose:
*       flushes all the output buffers to the file, clears all input buffers.
*
*Entry:
*       None.
*
*Exit:
*       returns number of open streams
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flushall (
        void
        )
{
        return(flsall(FLUSHALL));
}


/***
*static int flsall(flushflag) - flush all output buffers
*
*Purpose:
*       Flushes all the output buffers to the file and, if FLUSHALL is passed,
*       clears all input buffers. Core routine for both fflush(NULL) and
*       flushall().
*
*       MTHREAD Note: All the locking/unlocking required for both fflush(NULL)
*       and flushall() is performed in this routine.
*
*Entry:
*       int flushflag - flag indicating the exact semantics, there are two
*                       legal values: FLUSHALL and FFLUSHNULL
*
*Exit:
*       if flushflag == FFLUSHNULL then flsbuf returns:
                0, if successful
*               EOF, if an error occurs while flushing one of the streams
*
*       if flushflag == FLUSHALL then flsbuf returns the number of streams
*       successfully flushed
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl flsall (
        int flushflag
        )
{
        REG1 int i;
        int count = 0;
        int errcode = 0;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 0 ; i < _nstream ; i++ ) {

                if ( (__piob[i] != NULL) && (inuse((FILE *)__piob[i])) ) {

#ifdef  _MT
                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);

                        __try {
                                /*
                                 * if the stream is STILL in use (it may have been
                                 * closed before the lock was asserted), see about
                                 * flushing it.
                                 */
                                if ( inuse((FILE *)__piob[i]) ) {
#endif

                        if ( flushflag == FLUSHALL ) {
                                /*
                                 * FLUSHALL functionality: fflush the read or
                                 * write stream and, if successful, update the
                                 * count of flushed streams
                                 */
                                if ( _fflush_lk(__piob[i]) != EOF )
                                        /* update count of successfully flushed
                                         * streams
                                         */
                                        count++;
                        }
                        else if ( (flushflag == FFLUSHNULL) &&
                                  (((FILE *)__piob[i])->_flag & _IOWRT) ) {
                                /*
                                 * FFLUSHNULL functionality: fflush the write
                                 * stream and kept track of the error, if one
                                 * occurs
                                 */
                                if ( _fflush_lk(__piob[i]) == EOF )
                                        errcode = EOF;
                        }

#ifdef  _MT
                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
#endif
                }
        }

#ifdef  _MT
        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }
#endif

        if ( flushflag == FLUSHALL )
                return(count);
        else
                return(errcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetwc.c ===
/***
*fgetwc.c - get a wide character from a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetwc() - read a wide character from a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from fgetc.c.
*       05-03-93  CFW   Add getwc function.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       09-14-93  CFW   Fix EOF cast bug.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT.
*       10-22-93  CFW   Test for invalid MB chars using global preset flag.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call mbtowc().
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       04-18-97  JWM   Explicit cast added to avoid new C4242 warnings.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>

#ifdef _MT      /* multi-thread; define both fgetwc and _getwc_lk */

/***
*wint_t fgetwc(stream) - read a wide character from a stream
*
*Purpose:
*       reads a wide character from the given stream
*
*Entry:
*       FILE *stream - stream to read wide character from
*
*Exit:
*       returns the wide character read
*       returns WEOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fgetwc (
        REG1 FILE *stream
        )
{
        wint_t retval;

        _ASSERTE(stream != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _getwc_lk(stream);

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

/***
*_getwc_lk() -  getwc() core routine (locked version)
*
*Purpose:
*       Core getwc() routine; assumes stream is already locked.
*
*       [See getwc() above for more info.]
*
*Entry: [See getwc()]
*
*Exit:  [See getwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _getwc_lk (
        REG1 FILE *stream
        )
{

#else   /* non multi-thread; just define fgetwc */

wint_t __cdecl fgetwc (
        REG1 FILE *stream
        )
{

#endif  /* rejoin common code */

#ifndef _NTSUBSET_
        if (!(stream->_flag & _IOSTRG) && (_osfile_safe(_fileno(stream)) & 
              FTEXT))
        {
                int size = 1;
                int ch;
                char mbc[4];
                wchar_t wch;
                
                /* text (multi-byte) mode */
                if ((ch = _getc_lk(stream)) == EOF)
                        return WEOF;

                mbc[0] = (char)ch;

                if (isleadbyte((unsigned char)mbc[0]))
                {
                        if ((ch = _getc_lk(stream)) == EOF)
                        {
                                ungetc(mbc[0], stream);
                                return WEOF;
                        }
                        mbc[1] = (char)ch;
                        size = 2;
                }
                if (mbtowc(&wch, mbc, size) == -1)
                {
                        /*
                         * Conversion failed! Set errno and return
                         * failure.
                         */
                        errno = EILSEQ;
                        return WEOF;
                }
                return wch;
        }
#endif
        /* binary (Unicode) mode */
        if ((stream->_cnt -= sizeof(wchar_t)) >= 0)
                return *((wchar_t *)(stream->_ptr))++;
        else
                return (wint_t) _filwbuf(stream);
}

#undef getwc

wint_t __cdecl getwc (
        FILE *stream
        )
{
        return fgetwc(stream);
}


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgets.c ===
/***
*fgets.c - get string from a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgets() - read a string from a file
*
*Revision History:
*       09-02-83  RN    initial version
*       04-16-87  JCR   changed count from an unsigned int to an int (ANSI)
*                       and modified comparisons accordingly
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and added #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-01-93  CFW   Enable for fgetws().
*       12-07-93  CFW   Change _TCHAR to _TSCHAR.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*char *fgets(string, count, stream) - input string from a stream
*
*Purpose:
*       get a string, up to count-1 chars or '\n', whichever comes first,
*       append '\0' and put the whole thing into string. the '\n' IS included
*       in the string. if count<=1 no input is requested. if EOF is found
*       immediately, return NULL. if EOF found after chars read, let EOF
*       finish the string as '\n' would.
*
*Entry:
*       char *string - pointer to place to store string
*       int count - max characters to place at string (include \0)
*       FILE *stream - stream to read from
*
*Exit:
*       returns string with text read from file in it.
*       if count <= 0 return NULL
*       if count == 1 put null string in string
*       returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
wchar_t * __cdecl fgetws (
#else
char * __cdecl fgets (
#endif
        _TSCHAR *string,
        int count,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 _TSCHAR *pointer = string;
        _TSCHAR *retval = string;
        int ch;

        _ASSERTE(string != NULL);
        _ASSERTE(str != NULL);

        if (count <= 0)
                return(NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (--count)
        {
#ifdef _UNICODE
                if ((ch = _getwc_lk(stream)) == WEOF)
#else
                if ((ch = _getc_lk(stream)) == EOF)
#endif               
                {
                        if (pointer == string) {
                                retval=NULL;
                                goto done;
                        }

                        break;
                }

                if ((*pointer++ = (_TSCHAR)ch) == _T('\n'))
                        break;
        }

        *pointer = _T('\0');

/* Common return */
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetchar.c ===
/***
*fgetchar.c - get a character from stdin
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fgetchar() and getchar() - read a character from stdin
*	defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*Revision History:
*	11-20-83  RN	initial version
*	11-09-87  JCR	Multi-thread support
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-31-88  PHG	Merged DLL and normal versions
*	06-21-89  PHG	Added getchar() function
*	02-15-90  GJF	Fixed copyright and indents
*	03-16-90  GJF	Replaced _LOAD_DS with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-03-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	04-26-93  CFW	Wide char enable.
*	04-30-93  CFW	Move wide char support to fgetwchr.c.
*	03-15-95  GJF	Deleted #include <tchar.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fgetchar(), getchar() - read a character from stdin
*
*Purpose:
*	Reads the next character from stdin.  Function version of
*	getchar() macro.
*
*Entry:
*	None.
*
*Exit:
*	Returns character read or EOF if at end-of-file or an error occured,
*	in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fgetchar (
	void
	)
{
	return(getc(stdin));
}

#undef getchar

int __cdecl getchar (
	void
	)
{
	return _fgetchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetwchr.c ===
/***
*fgetwchr.c - get a wide character from stdin
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*Revision History:
*	04-26-93  CFW	Module created.
*	05-03-93  CFW	Bring wide char support from fgetwchr.c.
*	06-02-93  CFW	Wide get/put use wint_t.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fgetwchar(), getwchar() - read a wide character from stdin
*
*Purpose:
*	Reads the next wide character from stdin.  Function version of
*	getwchar() macro.
*
*Entry:
*	None.
*
*Exit:
*	Returns wide character read or WEOF if at end-of-file or an error occured,
*	in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fgetwchar (
	void
	)
{
	return(getwc(stdin));
}

#undef getwchar

wint_t __cdecl getwchar (
	void
	)
{
	return(_fgetwchar());
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\feoferr.c ===
/***
*feoferr.c - defines feof() and ferror()
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines feof() (test for end-of-file on a stream) and ferror() (test
*	for error on a stream).
*
*Revision History:
*	03-13-89  GJF	Module created
*	03-27-89  GJF	Moved to 386 tree
*	02-15-90  GJF	Fixed copyright
*	03-16-90  GJF	Made calling type  _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-02-90  GJF	New-style function declarators.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/* remove macro definitions for feof() and ferror()
 */
#undef	feof
#undef	ferror

/***
*int feof(stream) - test for end-of-file on stream
*
*Purpose:
*	Tests whether or not the given stream is at end-of-file. Normally
*	feof() is a macro, but it must also be available as a true function
*	for ANSI.
*
*Entry:
*	FILE *stream - stream to test
*
*Exit:
*	returns nonzero (_IOEOF to be more precise) if and only if the stream
*	is at end-of-file
*
*Exceptions:
*
*******************************************************************************/

int __cdecl feof (
	FILE *stream
	)
{
	return( ((stream)->_flag & _IOEOF) );
}


/***
*int ferror(stream) - test error indicator on stream
*
*Purpose:
*	Tests the error indicator for the given stream. Normally, feof() is
*	a macro, but it must also be available as a true function for ANSI.
*
*Entry:
*	FILE *stream - stream to test
*
*Exit:
*	returns nonzero (_IOERR to be more precise) if and only if the error
*	indicator for the stream is set.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl ferror (
	FILE *stream
	)
{
	return( ((stream)->_flag & _IOERR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\files.c ===
/* Initial Version of FILES.C -- Users can recompile this file to increase
 * (or decrease) the number of low-level I/O file handles or standard I/O
 * (stdio) FILE * streams available when linking with LIBC.LIB or LIBCMT.LIB.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fgetws.c ===
/***
*fgetws.c - get wide string from a file
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines fgetws() - read a wide string from a file
*
*Revision History:
*	04-26-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

/***
*wchar_t *fgetws(string, count, stream) - input string from a stream
*
*Purpose:
*	get a string, up to count-1 wide chars or L'\n', whichever comes first,
*	append L'\0' and put the whole thing into string. the L'\n' IS included
*	in the string. if count<=1 no input is requested. if WEOF is found
*	immediately, return NULL. if WEOF found after chars read, let WEOF
*	finish the string as L'\n' would.
*
*Entry:
*	wchar_t *string - pointer to place to store string
*	int count - max characters to place at string (include \0)
*	FILE *stream - stream to read from
*
*Exit:
*	returns wide string with text read from file in it.
*	if count <= 0 return NULL
*	if count == 1 put null string in string
*	returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "fgets.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fileno.c ===
/***
*fileno.c - defines _fileno()
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines fileno() - return the file handle for the specified stream
*
*Revision History:
*	03-13-89  GJF	Module created
*	03-27-89  GJF	Moved to 386 tree
*	02-15-90  GJF	_file is now an int. Also, fixed copyright.
*	03-19-90  GJF	Made calling type _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-02-90  GJF	New-style function declarator.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/* remove macro definition for fileno()
 */
#undef	_fileno

/***
*int _fileno(stream) - return the file handle for stream
*
*Purpose:
*	Returns the file handle for the given stream is. Normally fileno()
*	is a macro, but it is also available as a true function (for
*	consistency with ANSI, though it is not required).
*
*Entry:
*	FILE *stream - stream to fetch handle for
*
*Exit:
*	returns the file handle for the given stream
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fileno (
	FILE *stream
	)
{
	return( stream->_file );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputs.c ===
/***
*fputs.c - write a string to a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputs() - writes a string to a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       08-31-84  RN    modified to use the new, fast fwrite.
*       04-13-87  JCR   added const to declaration
*       06-30-87  JCR   made fputs return values conform to ANSI [MSC only]
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-18-88  JCR   Error return = EOF
*       05-27-88  PHG   Merged DLL and normal versions
*       09-22-88  GJF   Include internal.h to get prototypes for _[s|f]tbuf()
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputs(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the '\0' or
*       supply a '\n'.  Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       char *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputs (
        const char *string,
        FILE *stream
        )
{
        REG2 int buffing;
        REG1 size_t length;
        REG3 size_t ndone;

        _ASSERTE(string != NULL);
        _ASSERTE(stream != NULL);

        length = strlen(string);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        ndone = _fwrite_lk(string,1,length,stream);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(ndone == length ? 0 : EOF);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputchar.c ===
/***
*fputchar.c - write a character to stdout
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fputchar(), putchar() - write a character to stdout, function version
*	defines _fputwchar(), putwchar() - write a wide character to stdout, function version
*
*Revision History:
*	11-30-83  RN	initial version
*	11-09-87  JCR	Multi-thread support
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-31-88  PHG	Merged DLL and normal versions
*	06-21-89  PHG	Added putchar() function
*	02-15-90  GJF	Fixed copyright and indents
*	03-19-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h> and removed #include <register.h>.
*	10-02-90  GJF	New-style function declarators.
*	01-21-91  GJF	ANSI naming.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	04-26-93  CFW	Wide char enable.
*	04-30-93  CFW	Move wide char support to fputwchr.c.
*	03-15-95  GJF	Deleted #include <tchar.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fputchar(ch), putchar() - put a character to stdout
*
*Purpose:
*	Puts the given characters to stdout.  Function version of macro
*	putchar().
*
*Entry:
*	int ch - character to output
*
*Exit:
*	returns character written if successful
*	returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fputchar (
	REG1 int ch
	)
{
	return(putc(ch, stdout));
}

#undef putchar

int __cdecl putchar (
	int ch
	)
{
	return _fputchar(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fopen.c ===
/***
*fopen.c - open a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fopen() and _fsopen() - open a file as a stream and open a file
*       with a specified sharing mode as a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declarations
*       11-01-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       11-14-88  GJF   Added _fsopen().
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-26-92  DJM   POSIX support
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <file2.h>
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fsopen(file, mode, shflag) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode. shflag determines the
*       sharing mode. Values are the same as for sopen().
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfsopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
#ifndef _POSIX_
        ,int shflag
#endif
        )
{
        REG1 FILE *stream;
        REG2 FILE *retval;

        _ASSERTE(file != NULL);
        _ASSERTE(*file != _T('\0'));
        _ASSERTE(mode != NULL);
        _ASSERTE(*mode != _T('\0'));

        /* Get a free stream */
        /* [NOTE: _getstream() returns a locked stream.] */

        if ((stream = _getstream()) == NULL) {
                errno = EMFILE;
                return(NULL);
        }

#ifdef  _MT
        __try {
#endif

        /* open the stream */
#ifdef _POSIX_
#ifdef _UNICODE
        retval = _wopenfile(file,mode, stream);
#else
        retval = _openfile(file,mode, stream);
#endif
#else
#ifdef _UNICODE
        retval = _wopenfile(file,mode,shflag,stream);
#else
        retval = _openfile(file,mode,shflag,stream);
#endif
#endif

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

  
/***
*FILE *fopen(file, mode) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
        )
{
#ifdef _POSIX_
        return( _tfsopen(file, mode) );
#else
        return( _tfsopen(file, mode, _SH_DENYNO) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputc.c ===
/***
*fputc.c - write a character to an output stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputc() - writes a character to a stream
*       defines fputwc() - writes a wide character to a stream
*
*Revision History:
*       09-01-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       06-21-89  PHG   Added putc() function
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   Fixed copyright and indents.
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to fputwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-20-97  GJF   Removed unnecessary local from fputc(). Made putc() 
*                       identical to fputc(). Also, detab-ed.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputc(ch, stream) - write a character to a stream
*
*Purpose:
*       Writes a character to a stream.  Function version of putc().
*
*Entry:
*       int ch - character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the character if successful
*       returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputc (
        int ch,
        FILE *str
        )
{
        int retval;

        _ASSERTE(str != NULL);

#ifdef  _MT
        _lock_str(str);
        __try {
#endif

        retval = _putc_lk(ch,str);

#ifdef  _MT
        }
        __finally {
            _unlock_str(str);
        }
#endif

        return(retval);
}

#undef putc

int __cdecl putc (
        int ch,
        FILE *str
        )
{
        int retval;

        _ASSERTE(str != NULL);

#ifdef  _MT
        _lock_str(str);
        __try {
#endif

        retval = _putc_lk(ch,str);

#ifdef  _MT
        }
        __finally {
            _unlock_str(str);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fprintf.c ===
/***
*fprintf.c - print formatted data to stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fprintf() - print formatted data to stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-05-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       char *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fprintf (
        FILE *str,
        const char *format,
        ...
        )
/*
 * 'F'ile (stream) 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval;

        va_start(arglist, format);

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream,format,arglist);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fread.c ===
/***
*fread.c - read from a stream
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Read from the specified stream into the user's buffer.
*
*Revision History:
*       06-23-89  PHG   Module created, based on asm version
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       06-22-92  GJF   Must return 0 if EITHER size-of-item or number-of-
*                       item arguments is 0 (TNT Bug #523)
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       10-22-93  GJF   Fix divide-by-0 error in unbuffered case. Also,
*                       replaced MTHREAD with _MT.
*       12-30-94  GJF   _MAC_ merge.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <file2.h>

/***
*size_t fread(void *buffer, size_t size, size_t count, FILE *stream) -
*       read from specified stream into the specified buffer.
*
*Purpose:
*       Read 'count' items of size 'size' from the specified stream into
*       the specified buffer. Return when 'count' items have been read in
*       or no more items can be read from the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       size    - size of the item to read in
*       count   - number of items to read
*       stream  - stream to read from
*
*Exit:
*       Returns the number of (whole) items that were read into the buffer.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fread will attempt to buffer the stream (side effect of the _filbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be read in at a time by a call to
*       read(). Further, read() does not handle huge buffers. Therefore,
*       in large data models, the read request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fread() call in a small data model (by a
*       call to _nfread()).
*
*       MTHREAD/DLL - Handled in three layers. fread() handles the locking
*       and DS saving/loading/restoring (if required) and calls _fread_lk()
*       to do the work. _fread_lk() is the same as the single-thread,
*       large data model version of fread(). It breaks up the read request
*       into digestible chunks and calls _nfread() to do the actual work.
*
*       386/MTHREAD/DLL - Handled in just the two layers since it is small
*       data model. The outer layer, fread(), takes care of the stream locking
*       and calls _fread_lk() to do the actual work. _fread_lk() is the same
*       as the single-thread version of fread().
*
*******************************************************************************/


#ifdef  _MT
/* define locking/unlocking version */
size_t __cdecl fread (
        void *buffer,
        size_t size,
        size_t count,
        FILE *stream
        )
{
        size_t retval;

        _lock_str(stream);              /* lock stream */
        __try {
                /* do the read */
                retval = _fread_lk(buffer, size, count, stream);
        }
        __finally {
                _unlock_str(stream);    /* unlock stream */
        }

        return retval;
}
#endif

/* define the normal version */
#ifdef  _MT
size_t __cdecl _fread_lk (
#else
size_t __cdecl fread (
#endif
        void *buffer,
        size_t size,
        size_t num,
        FILE *stream
        )
{
        char *data;                     /* point to where should be read next */
        size_t total;                   /* total bytes to read */
        size_t count;                   /* num bytes left to read */
        unsigned bufsize;               /* size of stream buffer */
        unsigned nbytes;                /* how much to read now */
        unsigned nread;                 /* how much we did read */
        int c;                          /* a temp char */

        /* initialize local vars */
        data = buffer;

        if ( (count = total = size * num) == 0 )
                return 0;

        if (anybuf(stream))
                /* already has buffer, use its size */
                bufsize = stream->_bufsiz;
        else
                /* assume will get _INTERNAL_BUFSIZ buffer */
                bufsize = _INTERNAL_BUFSIZ;

        /* here is the main loop -- we go through here until we're done */
        while (count != 0) {
                /* if the buffer exists and has characters, copy them to user
                   buffer */
                if (anybuf(stream) && stream->_cnt != 0) {
                        /* how much do we want? */
                        nbytes = (count < (size_t)stream->_cnt) ? (unsigned)count : stream->_cnt;
                        memcpy(data, stream->_ptr, nbytes);

                        /* update stream and amt of data read */
                        count -= nbytes;
                        stream->_cnt -= nbytes;
                        stream->_ptr += nbytes;
                        data += nbytes;
                }
                else if (count >= bufsize) {
                        /* If we have more than bufsize chars to read, get data
                           by calling read with an integral number of bufsiz
                           blocks.  Note that if the stream is text mode, read
                           will return less chars than we ordered. */

                        /* calc chars to read -- (count/bufsize) * bufsize */
                        nbytes = ( bufsize ? (unsigned)(count - count % bufsize) :
                                   (unsigned)count );

#ifdef  _POSIX_
                        nread = read(fileno(stream), data, nbytes);
#else
                        nread = _read(_fileno(stream), data, nbytes);
#endif
                        if (nread == 0) {
                                /* end of file -- out of here */
                                stream->_flag |= _IOEOF;
                                return (total - count) / size;
                        }
                        else if (nread == (unsigned)-1) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }

                        /* update count and data to reflect read */
                        count -= nread;
                        data += nread;
                }
                else {
                        /* less than bufsize chars to read, so call _filbuf to
                           fill buffer */
                        if ((c = _filbuf(stream)) == EOF) {
                                /* error or eof, stream flags set by _filbuf */
                                return (total - count) / size;
                        }

                        /* _filbuf returned a char -- store it */
                        *data++ = (char) c;
                        --count;

                        /* update buffer size */
                        bufsize = stream->_bufsiz;
                }
        }

        /* we finished successfully, so just return num */
        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputwchr.c ===
/***
*fputwchr.c - write a wide character to stdout
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _fputwchar(), putwchar() - write a wide character to stdout,
*	function version
*
*Revision History:
*	04-26-93  CFW	Module created.
*	04-30-93  CFW	Bring wide char support from fputchar.c.
*	06-02-93  CFW	Wide get/put use wint_t.
*       02-07-94  CFW   POSIXify.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fputwchar(ch), putwchar() - put a wide character to stdout
*
*Purpose:
*	Puts the given wide character to stdout.  Function version of macro
*	putwchar().
*
*Entry:
*	wchar_t ch - character to output
*
*Exit:
*	returns character written if successful
*	returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fputwchar (
	REG1 wchar_t ch
	)
{
	return(putwc(ch, stdout));
}

#undef putwchar

wint_t __cdecl putwchar (
	REG1 wchar_t ch
	)
{
	return(_fputwchar(ch));
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fscanf.c ===
/***
*fscanf.c - read formatted data from stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fscanf() - reads formatted data from stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE2 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Added #include <internal.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fscanf (
        FILE *stream,
        const char *format,
        ...
        )
/*
 * 'F'ile (stream) 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(stream != NULL);
        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = (_input(stream,format,arglist));

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputwc.c ===
/***
*fputwc.c - write a wide character to an output stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputwc() - writes a wide character to a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from fputc.c.
*       05-03-93  CFW   Add putwc function.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       07-16-93  SRW   ALPHA Merge
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       11-05-93  GJF   Merged with NT SDK version (fix to a cast expr).
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call wctomb().
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       04-18-97  JWM   Explicit cast added to avoid new C4242 warnings.
*       02-27-98  GJF   Exception-safe locking.
*       12-16-99  GB    Modified for the case when return value from wctomb is
*                       greater then 2.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>

#ifdef  _MT     /* multi-thread; define both fputwc and _putwc_lk */

/***
*wint_t fputwc(ch, stream) - write a wide character to a stream
*
*Purpose:
*       Writes a wide character to a stream.  Function version of putwc().
*
*Entry:
*       wchar_t ch - wide character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the wide character if successful
*       returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fputwc (
        wchar_t ch,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 wint_t retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = _putwc_lk(ch,stream);

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}

/***
*_putwc_lk() -  putwc() core routine (locked version)
*
*Purpose:
*       Core putwc() routine; assumes stream is already locked.
*
*       [See putwc() above for more info.]
*
*Entry: [See putwc()]
*
*Exit:  [See putwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _putwc_lk (
        wchar_t ch,
        FILE *str
        )
{

#else   /* non multi-thread; just define fputwc */

wint_t __cdecl fputwc (
        wchar_t ch,
        FILE *str
        )
{

#endif  /* rejoin common code */

#ifndef _NTSUBSET_
        if (!(str->_flag & _IOSTRG) && (_osfile_safe(_fileno(str)) & FTEXT))
        {
                int size, i;
                char mbc[MB_LEN_MAX];
        
                /* text (multi-byte) mode */
                if ((size = wctomb(mbc, ch)) == -1)
                {
                        /*
                         * Conversion failed! Set errno and return
                         * failure.
                         */
                        errno = EILSEQ;
                        return WEOF;
                }
                for ( i = 0; i < size; i++)
                {
                        if (_putc_lk(mbc[i], str) == EOF)
                                return WEOF;
                }
                return (wint_t)(0xffff & ch);
        }
#endif
        /* binary (Unicode) mode */
        if ( (str->_cnt -= sizeof(wchar_t)) >= 0 )
                return (wint_t) (0xffff & (*((wchar_t *)(str->_ptr))++ = (wchar_t)ch));
        else
                return (wint_t) _flswbuf(ch, str);
}

#undef putwc

wint_t __cdecl putwc (
        wchar_t ch,
        FILE *str
        )
{
        return fputwc(ch, str);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fputws.c ===
/***
*fputws.c - write a string to a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputws() - writes a string to a stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       02-27-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#ifndef _POSIX_

#include <file2.h>
#include <internal.h>
#include <stdio.h>
#include <mtdll.h>
#include <tchar.h>
#include <wchar.h>
#include <dbgint.h>

/***
*int fputws(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the L'\0' or
*       supply a L'\n'. Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       wchar_t *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = WEOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputws (
        const wchar_t *string,
        FILE *stream
        )
{
        size_t length;
        int retval = 0;

        _ASSERTE(string != NULL);
        _ASSERTE(stream != NULL);

        length = wcslen(string);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (length--)
        {
            if (_putwc_lk(*string++, stream) == WEOF)
            {
                retval = -1;
                break;
            }
        }

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fseeki64.c ===
/***
*fseeki64.c - reposition file pointer on a stream
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fseeki64() - move the file pointer to new place in file
*
*Revision History:
*       12-15-94  GJF   Module created. Derived from fseek.c.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _fseeki64(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*Entry:
*       FILE *stream  - file to reposition file pointer on
*       _int64 offset - offset to seek to
*       int whence    - origin offset is measured from (0=beg, 1=current pos,
*                       2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT     /* multi-thread; define both fseek() and _lk_fseek() */

int __cdecl _fseeki64 (
        FILE *stream,
        __int64 offset,
        int whence
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _fseeki64_lk (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseeki64_lk() - Core _fseeki64() routine (stream is locked)
*
*Purpose:
*       Core _fseeki64() routine; assumes that caller has the stream locked.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseeki64_lk (

#else   /* non multi-thread; just define fseek() */

int __cdecl _fseeki64 (

#endif  /* rejoin common code */

        FILE *str,
        __int64 offset,
        int whence
        )
{


        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream) || ((whence != SEEK_SET) && (whence != SEEK_CUR) &&
            (whence != SEEK_END)) ) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftelli64_lk(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

        _flush(stream);

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

        return(_lseeki64(_fileno(stream), offset, whence) == -1i64 ? -1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\freopen.c ===
/***
*freopen.c - close a stream and assign it to a new file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines freopen() - close and reopen file, typically used to redirect
*       stdin/out/err/prn/aux.
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declarations
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       11-14-88  GJF   _openfile() now takes a file sharing flag, also some
*                       cleanup (now specific to the 386)
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant.
*       01-17-94  GJF   Ignore possible failure of _fclose_lk (ANSI 4.9.5.4)
*       04-11-94  CFW   Remove unused 'done' label to avoid warnings.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*FILE *freopen(filename, mode, stream) - reopen stream as new file
*
*Purpose:
*       Closes the file associated with stream and assigns stream to a new
*       file with current mode.  Usually used to redirect a standard file
*       handle.
*
*Entry:
*       char *filename - new file to open
*       char *mode - new file mode, as in fopen()
*       FILE *stream - stream to close and reassign
*
*Exit:
*       returns stream if successful
*       return NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfreopen (
        const _TSCHAR *filename,
        const _TSCHAR *mode,
        FILE *str
        )
{
        REG1 FILE *stream;
        FILE *retval;

        _ASSERTE(filename != NULL);
        _ASSERTE(*filename != _T('\0'));
        _ASSERTE(mode != NULL);
        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        /* If the stream is in use, try to close it. Ignore possible
         * error (ANSI 4.9.5.4). */
        if ( inuse(stream) )
                _fclose_lk(stream);

        stream->_ptr = stream->_base = NULL;
        stream->_cnt = stream->_flag = 0;
#ifdef _POSIX_
#ifdef _UNICODE
        retval = _wopenfile(filename,mode,stream);
#else
        retval = _openfile(filename,mode,stream);
#endif
#else
#ifdef _UNICODE
        retval = _wopenfile(filename,mode,_SH_DENYNO,stream);
#else
        retval = _openfile(filename,mode,_SH_DENYNO,stream);
#endif
#endif

#ifdef  _MT
        }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fseek.c ===
/***
*fseek.c - reposition file pointer on a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fseek() - move the file pointer to new place in file
*
*Revision History:
*       10-13-83  RN    initial version
*       06-26-85  TC    added code to allow variable buffer lengths
*       02-10-87  BCM   fixed '%' mistakenly used for '/'
*       03-04-87  JCR   added errno settings
*       04-16-87  JCR   added _IOUNGETC support for bug fix and changes whence
*                       from unsigned int to int (ANSI conformance)
*       04-17-87  JCR   fseek() now clears end-of-file indicator flag _IOEOF
*                       (for ANSI conformance)
*       04-21-87  JCR   be smart about lseek'ing to the end of the file and
*                       back
*       09-17-87  SKS   handle case of '\n' at beginning of buffer (FCRLF flag)
*       09-24-87  JCR   fixed an incorrect access to flag _IOEOF
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       09-30-87  JCR   Fixed buffer allocation bug, now use _getbuf()
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       03-04-88  JCR   Return value from read() must be treated as unsigned
*                       value
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2[] references
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       12-02-88  JCR   Added _IOCTRLZ support (fixes bug pertaining to ^Z at
*                       eof)
*       04-12-89  JCR   Ripped out all of the special read-only code.  See the
*                       comments in the routine header for more information.
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-08-92  GJF   Use seek method constants!
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-24-93  GJF   If the stream was opened for read-access-only, reduce
*                       _bufsiz after flushing the stream. This should reduce
*                       the expense of the next _filbuf call, and the overall
*                       burden of seek-and-do-small-reads patterns of file
*                       input.
*       06-22-93  GJF   Check _flag for _IOSETVBUF (new) before changing
*                       buffer size.
*       11-05-93  GJF   Merged with NT SDK version. Also, replaced MTHREAD
*                       with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#ifndef _POSIX_
#include <mtdll.h>
#endif

/***
*int fseek(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*                       - - - - - - - - - - - - -
*
*       [NOTE: We used to bend over backwards to try and preserve the current
*       buffer and maintain disk block alignment.  This ended up making our
*       code big and slow and complicated, and slowed us down quite a bit.
*       Some of the things pertinent to the old implimentation:
*
*       (1) Read-only: We only did the special code path if the file was
*       opened read-only (_IOREAD).  If the file was writable, we didn't
*       try to optimize.
*
*       (2) Buffering:  We'd assign a buffer, if necessary, since the
*       later code might need it (i.e., call _getbuf).
*
*       (3) Ungetc: Fseek had to be careful NOT to save the buffer if
*       an ungetc had ever been done on the buffer (flag _IOUNGETC).
*
*       (4) Control ^Z: Fseek had to deal with ^Z after reading a
*       new buffer's worth of data (flag _IOCTRLZ).
*
*       (5) Seek-to-end-and-back: To determine if the new seek was within
*       the current buffer, we had to 'normalize' the desired location.
*       This means that we sometimes had to seek to the end of the file
*       and back to determine what the 0-relative offset was.  Two extra
*       lseek() calls hurt performance.
*
*       (6) CR/LF accounting - When trying to seek within a buffer that
*       is in text mode, we had to go account for CR/LF expansion.  This
*       required us to look at every character up to the new offset and
*       see if it was '\n' or not.  In addition, we had to check the
*       FCRLF flag to see if the new buffer started with '\n'.
*
*       Again, all of these notes are for the OLD implimentation just to
*       remind folks of some of the issues involving seeking within a buffer
*       and maintaining buffer alignment.  As an aside, I think this may have
*       been a big win in the 'old days' on floppy-based systems but on newer
*       fast hard disks, the extra code/complexity overwhelmed any gain.
*
*                       - - - - - - - - - - - - -
*
*Entry:
*       FILE *stream - file to reposition file pointer on
*       long offset - offset to seek to
*       int whence - origin offset is measured from (0=beg, 1=current pos,
*                    2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _MT     /* multi-thread; define both fseek() and _lk_fseek() */

int __cdecl fseek (
        FILE *stream,
        long offset,
        int whence
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _fseek_lk (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseek_lk() - Core fseek() routine (stream is locked)
*
*Purpose:
*       Core fseek() routine; assumes that caller has the stream locked.
*
*       [See fseek() for more info.]
*
*Entry: [See fseek()]
*
*Exit:  [See fseek()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseek_lk (

#else   /* non multi-thread; just define fseek() */

int __cdecl fseek (

#endif  /* rejoin common code */

        FILE *str,
        long offset,
        int whence
        )
{


        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream) || ((whence != SEEK_SET) && (whence != SEEK_CUR) &&
            (whence != SEEK_END)) ) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftell_lk(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

#ifdef  _POSIX_
        /*
         * If the stream was last read, we throw away the buffer so
         * that a possible subsequent write will encounter a clean
         * buffer.  (The Win32 version of fflush() throws away the
         * buffer if it's read.)  Write buffers must be flushed.
         */
        
        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOREAD) {
                stream->_ptr = stream->_base;
                stream->_cnt = 0;
        } else {
                _flush(stream);
        }
#else
        _flush(stream);
#endif

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

#ifdef  _POSIX_
        return(lseek(fileno(stream), offset, whence) == -1L ? -1 : 0);
#else
        return(_lseek(_fileno(stream), offset, whence) == -1L ? -1 : 0);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fwprintf.c ===
/***
*fwprintf.c - print formatted data to stream
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwprintf() - print formatted data to stream
*
*Revision History:
*       05-16-92  KRS   Created from fprintf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fwprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       wchar_t *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fwprintf (
        FILE *str,
        const wchar_t *format,
        ...
        )
/*
 * 'F'ile (stream) 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream,format,arglist);
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fsetpos.c ===
/***
*fsetpos.c - Contains fsetpos runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Fsetpos sets the file position using an internal value returned by an
*       earlier fgetpos call.
*
*Revision History:
*       01-16-87  JCR   Module created
*       04-13-87  JCR   Added const to declaration
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-15-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       10-02-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-23-94  GJF   Use 64-bit file position (_fseeki64) for non-_MAC_.
*       01-05-94  GJF   Temporarily commented out above change due to MFC/IDE
*                       bugs.
*       01-24-95  GJF   Restored 64-bit fpos_t support.
*       06-28-96  SKS   Enable 64-bit fpos_t support for the MAC
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fsetpos(stream,pos) - Set file positioning
*
*Purpose:
*       Fsetpos sets the file position for the file indicated by [stream] to
*       the position indicated by [pos].  The [pos] value is defined to be in
*       an internal format (not to be interpreted by the user) and has been
*       generated by an earlier fgetpos call.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file positioning value
*
*Exit:
*       Successful call returns 0.
*       Unsuccessful call returns non-zero (!0).
*
*Exceptions:
*       None.
*******************************************************************************/

int __cdecl fsetpos (
        FILE *stream,
        const fpos_t *pos
        )
{
#ifdef _POSIX_
        return( fseek(stream, *pos, SEEK_SET) );
#else
        return( _fseeki64(stream, *pos, SEEK_SET) );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fwrite.c ===
/***
*fwrite.c - read from a stream
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Write to the specified stream from the user's buffer.
*
*Revision History:
*       06-23-89  PHG   Module created, based on asm version
*       01-18-90  GJF   Must call _fflush_lk() rather than fflush().
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>. Also, fixed compiler warning.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-26-90  SBM   Added #include <internal.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       10-22-93  GJF   Fix divide-by-0 error in unbuffered case. Also,
*                       replaced MTHREAD with _MT.
*       12-30-94  GJF   _MAC_ merge.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       05-24-95  CFW   Return 0 if none to write.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <file2.h>
#include <internal.h>

/***
*size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream) -
*       write to the specified stream from the specified buffer.
*
*Purpose:
*       Write 'count' items of size 'size' to the specified stream from
*       the specified buffer. Return when 'count' items have been written
*       or no more items can be written to the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       size    - size of the item to write
*       count   - number of items to write
*       stream  - stream to write to
*
*Exit:
*       Returns the number of (whole) items that were written to the stream.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fwrite will attempt to buffer the stream (side effect of the _flsbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be written out at a time by a call to
*       write(). Further, write() does not handle huge buffers. Therefore,
*       in large data models, the write request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fwrite() call in a small data model (by a
*       call to _nfwrite()).
*
*       This code depends on _iob[] being a near array.
*
*       MTHREAD/DLL - Handled in just two layers since it is small data
*       model. The outer layer, fwrite(), handles stream locking/unlocking
*       and calls _fwrite_lk() to do the work. _fwrite_lk() is the same as
*       the single-thread, small data model version of fwrite().
*
*******************************************************************************/


#ifdef  _MT
/* define locking/unlocking version */
size_t __cdecl fwrite (
        const void *buffer,
        size_t size,
        size_t count,
        FILE *stream
        )
{
        size_t retval;

        _lock_str(stream);                      /* lock stream */

        __try {
                /* do the read */
                retval = _fwrite_lk(buffer, size, count, stream);
        }
        __finally {
                _unlock_str(stream);            /* unlock stream */
        }

        return retval;
}
#endif

/* define the normal version */
#ifdef  _MT
size_t __cdecl _fwrite_lk (
#else
size_t __cdecl fwrite (
#endif
        const void *buffer,
        size_t size,
        size_t num,
        FILE *stream
        )
{
        const char *data;               /* point to where data comes from next */
        size_t total;                   /* total bytes to write */
        size_t count;                   /* num bytes left to write */
        unsigned bufsize;               /* size of stream buffer */
        unsigned nbytes;                /* number of bytes to write now */
        unsigned nwritten;              /* number of bytes written */
        int c;                          /* a temp char */

        /* initialize local vars */
        data = buffer;
        count = total = size * num;
        if (0 == count)
            return 0;

        if (anybuf(stream))
                /* already has buffer, use its size */
                bufsize = stream->_bufsiz;
        else
                /* assume will get _INTERNAL_BUFSIZ buffer */
                bufsize = _INTERNAL_BUFSIZ;

        /* here is the main loop -- we go through here until we're done */
        while (count != 0) {
                /* if the buffer is big and has room, copy data to buffer */
                if (bigbuf(stream) && stream->_cnt != 0) {
                        /* how much do we want? */
                        nbytes = (count < (unsigned)stream->_cnt) ? (unsigned)count : stream->_cnt;
                        memcpy(stream->_ptr, data, nbytes);

                        /* update stream and amt of data written */
                        count -= nbytes;
                        stream->_cnt -= nbytes;
                        stream->_ptr += nbytes;
                        data += nbytes;
                }
                else if (count >= bufsize) {
                        /* If we have more than bufsize chars to write, write
                           data by calling write with an integral number of
                           bufsiz blocks.  If we reach here and we have a big
                           buffer, it must be full so _flush it. */

                        if (bigbuf(stream)) {
                                if (_flush(stream)) {
                                        /* error, stream flags set -- we're out
                                           of here */
                                        return (total - count) / size;
                                }
                        }

                        /* calc chars to read -- (count/bufsize) * bufsize */
                        nbytes = ( bufsize ? (unsigned)(count - count % bufsize) :
                                   (unsigned)count );

#ifdef  _POSIX_
                        nwritten = write(fileno(stream), data, nbytes);
#else
                        nwritten = _write(_fileno(stream), data, nbytes);
#endif
                        if (nwritten == (unsigned)EOF) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }

                        /* update count and data to reflect write */

                        count -= nwritten;
                        data += nwritten;

                        if (nwritten < nbytes) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }
                }
                else {
                        /* buffer full and not enough chars to do direct write,
                           so do a _flsbuf. */
                        c = *data;  /* _flsbuf write one char, this is it */
                        if (_flsbuf(c, stream) == EOF) {
                                /* error or eof, stream flags set by _flsbuf */
                                return (total - count) / size;
                        }

                        /* _flsbuf wrote a char -- update count */
                        ++data;
                        --count;

                        /* update buffer size */
                        bufsize = stream->_bufsiz > 0 ? stream->_bufsiz : 1;
                }
        }

        /* we finished successfully, so just return num */
        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\fwscanf.c ===
/***
*fwscanf.c - read formatted data from stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwscanf() - reads formatted data from stream
*
*Revision History:
*       05-16-92  KRS   Created from fscanf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fwscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       wchar_t *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fwscanf (
        FILE *stream,
        const wchar_t *format,
        ...
        )
/*
 * 'F'ile (stream) 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(stream != NULL);
        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        retval = (_winput(stream,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\ftell.c ===
/***
*ftell.c - get current file position
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ftell() - find current current position of file pointer
*
*Revision History:
*       09-02-83  RN    initial version
*       ??-??-??  TC    added code to allow variable buffer sizes
*       05-22-86  TC    added code to seek to send if last operation was a
*                       write and append mode specified
*       11-20-86  SKS   do not seek to end of file in append mode
*       12-01-86  SKS   fix off-by-1 problem in text mode when last byte in
*                       buffer was a '\r', and it was followed by a '\n'. Since
*                       the \n was pushed back and the \r was discarded, we
*                       must adjust the computed position for the \r.
*       02-09-87  JCR   Added errno set code (if flag (_IORW not set)
*       09-09-87  JCR   Optimized to eliminate two lseek() calls in binary mode.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-04-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Use _iob2_ macro instead of _iob_index
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       07-27-88  JCR   Changed some variables from int to unsigned (bug fix)
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       12-05-88  JCR   Added _IOCTRLZ support (fixes bug pertaining to ^Z at
*                       eof)
*       08-17-89  GJF   Cleanup, now specific to OS/2 2.0 (i.e., 386 flat
*                       model), also fixed copyright
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-02-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       09-01-92  GJF   Fixed POSIX support (was returning -1 for all except
*                       read-write streams).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-29-93  GJF   Fixed bug related to variable buffer sizing (Cuda
*                       #5456).
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       02-27-98  RKP   Add 64 bit support.
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <stddef.h>
#include <io.h>
#include <internal.h>
#ifndef _POSIX_
#include <mtdll.h>
#endif

/***
*long ftell(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1L and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT      /* multi-thread; define both ftell() and _lk_ftell() */

long __cdecl ftell (
        FILE *stream
        )
{
        long retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ftell_lk (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftell_lk() - Ftell() core routine (assumes stream is locked).
*
*Purpose:
*       Core ftell() routine; assumes caller has aquired stream lock).
*
*       [See ftell() above for more info.]
*
*Entry: [See ftell()]
*
*Exit:  [See ftell()]
*
*Exceptions:
*
*******************************************************************************/

long __cdecl _ftell_lk (

#else   /* non multi-thread; define only ftell() */

long __cdecl ftell (

#endif  /* rejoin common code */

        FILE *str
        )
{
        REG1 FILE *stream;
        unsigned int offset;
        long filepos;
#if     !defined(_POSIX_)
        REG2 char *p;
        char *max;
#endif
        int fd;
        unsigned int rdcnt;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;
#ifdef _POSIX_
        fd = fileno(stream);
#else
        fd = _fileno(stream);
#endif

        if (stream->_cnt < 0)
            stream->_cnt = 0;

#ifdef _POSIX_
        if ((filepos = lseek(fd, 0L, SEEK_CUR)) < 0L)
#else
        if ((filepos = _lseek(fd, 0L, SEEK_CUR)) < 0L)
#endif
            return(-1L);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
            return(filepos - stream->_cnt);

        offset = (unsigned)(stream->_ptr - stream->_base);

#ifndef _POSIX_
        if (stream->_flag & (_IOWRT|_IOREAD)) {
            if (_osfile(fd) & FTEXT)
                for (p = stream->_base; p < stream->_ptr; p++)
                    if (*p == '\n')  /* adjust for '\r' */
                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
            errno=EINVAL;
            return(-1L);
        }
#endif

        if (filepos == 0L)
            return((long)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

            if (stream->_cnt == 0)  /* filepos holds correct location */
                offset = 0;

            else {

                /* Subtract out the number of unread bytes left in the buffer.
                   [We can't simply use _iob[]._bufsiz because the last read
                   may have hit EOF and, thus, the buffer was not completely
                   filled.] */

                rdcnt = stream->_cnt + (unsigned)(stream->_ptr - stream->_base);

#if  !defined(_POSIX_)
                /* If text mode, adjust for the cr/lf substitution. If binary
                   mode, we're outta here. */
                if (_osfile(fd) & FTEXT) {
                    /* (1) If we're not at eof, simply copy _bufsiz onto rdcnt
                       to get the # of untranslated chars read. (2) If we're at
                       eof, we must look through the buffer expanding the '\n'
                       chars one at a time. */

                    /* [NOTE: Performance issue -- it is faster to do the two
                       _lseek() calls than to blindly go through and expand the
                       '\n' chars regardless of whether we're at eof or not.] */

                    if (_lseek(fd, 0L, 2) == filepos) {

                        max = stream->_base + rdcnt;
                        for (p = stream->_base; p < max; p++)
                            if (*p == '\n')
                                /* adjust for '\r' */
                                rdcnt++;

                        /* If last byte was ^Z, the lowio read didn't tell us
                           about it. Check flag and bump count, if necessary. */

                        if (stream->_flag & _IOCTRLZ)
                            ++rdcnt;
                    }

                    else {

                        _lseek(fd, filepos, 0);

                        /* We want to set rdcnt to the number of bytes
                           originally read into the stream buffer (before
                           crlf->lf translation). In most cases, this will
                           just be _bufsiz. However, the buffer size may have
                           been changed, due to fseek optimization, at the
                           END of the last _filbuf call. */

                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                             (stream->_flag & _IOMYBUF) &&
                             !(stream->_flag & _IOSETVBUF) )
                        {
                            /* The translated contents of the buffer is small
                               and we are not at eof. The buffer size must have
                               been set to _SMALL_BUFSIZ during the last
                               _filbuf call. */

                            rdcnt = _SMALL_BUFSIZ;
                        }
                        else
                            rdcnt = stream->_bufsiz;

                        /* If first byte in untranslated buffer was a '\n',
                           assume it was preceeded by a '\r' which was
                           discarded by the previous read operation and count
                           the '\n'. */
                        if  (_osfile(fd) & FCRLF)
                            ++rdcnt;
                    }

                } /* end if FTEXT */
#endif

                filepos -= (long)rdcnt;

            } /* end else stream->_cnt != 0 */

        return(filepos + (long)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\getw.c ===
/***
*getw.c - read a binary word from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getw() - gets a binary integer from a stream
*
*Revision History:
*       09-02-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*                       Fixed bug if EOF occurs in middle of word being read
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-24-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-13-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _getw(stream) - read an int from a stream
*
*Purpose:
*       get n bytes (n=sizeof(int)); OR them together in proper order; high
*       byte first. check for EOF between getc's.
*       this routine should be machine independent.
*
*Entry:
*       FILE *stream - stream to read integer from
*
*Exit:
*       returns the int read from the stream
*       returns EOF if fails (but this is a legit int value, so
*       should test feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getw (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int bytecount = sizeof(int);
        int word;
        char *byteptr = (char *)&word;
        int retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (bytecount--)
            *byteptr++ = (char)_getc_lk(stream);
        retval = ((feof(stream) || ferror(stream)) ? EOF : word);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\ftelli64.c ===
/***
*ftelli64.c - get current file position
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _ftelli64() - find current current position of file pointer
*
*Revision History:
*       12-22-94  GJF   Module created. Derived from ftell.c
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-23-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       03-02-98  GJF   Exception-safe locking.
*       03-04-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#include <msdos.h>
#include <stddef.h>
#include <io.h>
#include <internal.h>
#include <mtdll.h>

/***
*__int64 _ftelli64(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1i64 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _MT

__int64 __cdecl _ftelli64 (
        FILE *stream
        )
{
        __int64 retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
               retval = _ftelli64_lk (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftelli64_lk() - _ftelli64() core routine (assumes stream is locked).
*
*Purpose:
*       Core _ftelli64() routine (assumes caller has aquired stream lock).
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

__int64 __cdecl _ftelli64_lk (

#else   /* mdef _MT */

__int64 __cdecl _ftelli64 (

#endif  /* _MT */

        FILE *str
        )
{
        REG1 FILE *stream;
        size_t offset;
        __int64 filepos;
        REG2 char *p;
        char *max;
        int fd;
        size_t rdcnt;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;
        fd = _fileno(stream);

        if (stream->_cnt < 0)
                stream->_cnt = 0;

        if ((filepos = _lseeki64(fd, 0i64, SEEK_CUR)) < 0L)
                return(-1i64);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
                return(filepos - stream->_cnt);

        offset = (size_t)(stream->_ptr - stream->_base);

        if (stream->_flag & (_IOWRT|_IOREAD)) {
                if (_osfile(fd) & FTEXT)
                        for (p = stream->_base; p < stream->_ptr; p++)
                                if (*p == '\n')  /* adjust for '\r' */
                                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
                errno=EINVAL;
                return(-1i64);
        }

        if (filepos == 0i64)
                return((__int64)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

                if (stream->_cnt == 0)  /* filepos holds correct location */
                        offset = 0;

                else {

                        /* Subtract out the number of unread bytes left in the
                           buffer. [We can't simply use _iob[]._bufsiz because
                           the last read may have hit EOF and, thus, the buffer
                           was not completely filled.] */

                        rdcnt = stream->_cnt + (size_t)(stream->_ptr - stream->_base);

                        /* If text mode, adjust for the cr/lf substitution. If
                           binary mode, we're outta here. */
                        if (_osfile(fd) & FTEXT) {
                                /* (1) If we're not at eof, simply copy _bufsiz
                                   onto rdcnt to get the # of untranslated
                                   chars read. (2) If we're at eof, we must
                                   look through the buffer expanding the '\n'
                                   chars one at a time. */

                                /* [NOTE: Performance issue -- it is faster to
                                   do the two _lseek() calls than to blindly go
                                   through and expand the '\n' chars regardless
                                   of whether we're at eof or not.] */

                                if (_lseeki64(fd, 0i64, SEEK_END) == filepos) {

                                        max = stream->_base + rdcnt;
                                        for (p = stream->_base; p < max; p++)
                                                if (*p == '\n')
                                                        /* adjust for '\r' */
                                                        rdcnt++;

                                        /* If last byte was ^Z, the lowio read
                                           didn't tell us about it.  Check flag
                                           and bump count, if necessary. */

                                        if (stream->_flag & _IOCTRLZ)
                                                ++rdcnt;
                                }

                                else {

                                        _lseeki64(fd, filepos, SEEK_SET);

                                        /* We want to set rdcnt to the number
                                           of bytes originally read into the
                                           stream buffer (before crlf->lf
                                           translation). In most cases, this
                                           will just be _bufsiz. However, the
                                           buffer size may have been changed,
                                           due to fseek optimization, at the
                                           END of the last _filbuf call. */

                                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                                             (stream->_flag & _IOMYBUF) &&
                                             !(stream->_flag & _IOSETVBUF) )
                                        {
                                                /* The translated contents of
                                                   the buffer is small and we
                                                   are not at eof. The buffer
                                                   size must have been set to
                                                   _SMALL_BUFSIZ during the
                                                   last _filbuf call. */

                                                rdcnt = _SMALL_BUFSIZ;
                                        }
                                        else
                                                rdcnt = stream->_bufsiz;


                                        /* If first byte in untranslated buffer
                                           was a '\n', assume it was preceeded
                                           by a '\r' which was discarded by the
                                           previous read operation and count
                                           the '\n'. */
                                        if  (_osfile(fd) & FCRLF)
                                                ++rdcnt;
                                }

                        } /* end if FTEXT */

                        filepos -= (__int64)rdcnt;

                } /* end else stream->_cnt != 0 */

        return(filepos + (__int64)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\gets.c ===
/***
*gets.c - read a line from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines gets() and getws() - read a line from stdin into buffer
*
*Revision History:
*       09-02-83  RN    initial version
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       02-15-90  GJF   Fixed copyright, indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-24-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-31-94  CFW   Unicode enable.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <tchar.h>

/***
*char *gets(string) - read a line from stdin
*
*Purpose:
*       Gets a string from stdin terminated by '\n' or EOF; don't include '\n';
*       append '\0'.
*
*Entry:
*       char *string - place to store read string, assumes enough room.
*
*Exit:
*       returns string, filled in with the line of input
*       null string if \n found immediately
*       NULL if EOF found immediately
*
*Exceptions:
*
*******************************************************************************/

_TCHAR * __cdecl _getts (
        _TCHAR *string
        )
{
        int ch;
        _TCHAR *pointer = string;
        _TCHAR *retval = string;

        _ASSERTE(string != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

#ifdef _UNICODE
        while ((ch = _getwchar_lk()) != L'\n')
#else
        while ((ch = _getchar_lk()) != '\n')
#endif
        {
                if (ch == _TEOF)
                {
                        if (pointer == string)
                        {
                                retval = NULL;
                                goto done;
                        }

                        break;
                }

                *pointer++ = (_TCHAR)ch;
        }

        *pointer = _T('\0');

/* Common return */
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)cprintf.c: $(SRCDIR)output.c

$(SRCDIR)cscanf.c: $(SRCDIR)input.c

$(SRCDIR)snprintf.c: $(SRCDIR)sprintf.c

$(SRCDIR)vsnprint.c: $(SRCDIR)vsprintf.c

$(SRCDIR)woutput.c: $(SRCDIR)output.c

$(SRCDIR)snwprint.c: $(SRCDIR)swprintf.c

$(SRCDIR)vsnwprnt.c: $(SRCDIR)vswprint.c

$(SRCDIR)_flswbuf.c: $(SRCDIR)_flsbuf.c

$(SRCDIR)_filwbuf.c: $(SRCDIR)_filbuf.c

$(SRCDIR)cwprintf.c: $(SRCDIR)woutput.c

$(SRCDIR)cwscanf.c: $(SRCDIR)input.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\maketab.c ===
/* make the lookup table for output.asm */

#define TABLESIZE  ('x' - ' ' + 1)


/* possible states to be in */
#define NORMAL	  0 /* normal character to be output */
#define PERCENT   1 /* just read percent sign */
#define FLAG	  2 /* just read a flag character */
#define WIDTH	  3 /* just read a width specification character */
#define DOT	  4 /* just read a dot between width and precision */
#define PRECIS	  5 /* just read a precision specification character */
#define SIZE	  6 /* just read a size specification character */
#define TYPE	  7 /* just read a conversion specification character */
#define BOGUS	  0 /* bogus state - print the character literally */

#define NUMSTATES 8

/* possible types of characters to read */
#define CH_OTHER   0   /* character with no special meaning */
#define CH_PERCENT 1   /* '%' */
#define CH_DOT	   2   /* '.' */
#define CH_STAR    3   /* '*' */
#define CH_ZERO    4   /* '0' */
#define CH_DIGIT   5   /* '1'..'9' */
#define CH_FLAG    6   /* ' ', '+', '-', '#' */
#define CH_SIZE    7   /* 'h', 'l', 'L', 'N', 'F', 'w' */
#define CH_TYPE    8   /* conversion specified character */

#define NUMCHARS 9

unsigned char table[TABLESIZE];   /* the table we build */



/* this is the state table */

int statetable[NUMSTATES][NUMCHARS] = {
/* state,	other	    %	    .	    *	    0	    digit   flag    size    type  */

/* NORMAL */  { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL },
/* PERCENT */ { BOGUS,	  NORMAL,   DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* FLAG */    { BOGUS,	  BOGUS,    DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* WIDTH */   { BOGUS,	  BOGUS,    DOT,    BOGUS,  WIDTH,  WIDTH,  BOGUS,  SIZE,   TYPE },
/* DOT */     { BOGUS,	  BOGUS,    BOGUS,  PRECIS, PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* PRECIS */  { BOGUS,	  BOGUS,    BOGUS,  BOGUS,  PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* SIZE */    { BOGUS,	  BOGUS,    BOGUS,  BOGUS,  BOGUS,  BOGUS,  BOGUS,  SIZE,   TYPE },
/* TYPE */    { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL }
};

/* this determines what type of character ch is */

static int chartype (
	int ch
	)
{
    if (ch < ' ' || ch > 'z')
	return CH_OTHER;
    if (ch == '%')
	return CH_PERCENT;
    if (ch == '.')
	return CH_DOT;
    if (ch == '*')
	return CH_STAR;
    if (ch == '0')
	return CH_ZERO;
    if (strchr("123456789", ch))
	return CH_DIGIT;
    if (strchr(" +-#", ch))
	return CH_FLAG;
    if (strchr("hlLNFw", ch))
	return CH_SIZE;
    if (strchr("diouxXfeEgGcspnCSZ", ch))
	return CH_TYPE;
    return CH_OTHER;
}


main()
{
	int ch;
	int state, class;
	int i;

	for (ch = ' '; ch <= 'x'; ++ch) {
		table[ch-' '] = chartype(ch);
	}

	for (state = NORMAL; state <= TYPE; ++state)
		for (class = CH_OTHER; class <= CH_TYPE; ++class)
			table[class*8+state] |= statetable[state][class]<<4;

	for (i = 0; i < TABLESIZE; ++i) {
		if (i % 8 == 0)
			printf("\ndb\t %.2xh", table[i]);
		else
			printf(", %.2xh", table[i]);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\maketabc.c ===
/***
*maketabc.c - program to generate printf format specifier lookup table for
*             output.c
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This program writes to stdout the lookuptable values needed by
*       output.c
*
*Revision History:
*       06-01-89  PHG   Module created
*        1-16-91  SRW   Added extra format codes (_WIN32_)
*        1-16-91  SRW   Fixed output loop to put trailing comma on a line
*       03-11-94  GJF   Recognize 'I' as size modifier.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       02-24-95  GJF   Don't recognize 'I' for non-Win32 (Mac merge).
*       07-14-96  RDK   Allow 'I' for Mac size specifier.
*
*******************************************************************************/

#define TABLESIZE  ('x' - ' ' + 1)


/* possible states to be in */
#define NORMAL    0 /* normal character to be output */
#define PERCENT   1 /* just read percent sign */
#define FLAG      2 /* just read a flag character */
#define WIDTH     3 /* just read a width specification character */
#define DOT       4 /* just read a dot between width and precision */
#define PRECIS    5 /* just read a precision specification character */
#define SIZE      6 /* just read a size specification character */
#define TYPE      7 /* just read a conversion specification character */
#define BOGUS     0 /* bogus state - print the character literally */

#define NUMSTATES 8

/* possible types of characters to read */
#define CH_OTHER   0   /* character with no special meaning */
#define CH_PERCENT 1   /* '%' */
#define CH_DOT     2   /* '.' */
#define CH_STAR    3   /* '*' */
#define CH_ZERO    4   /* '0' */
#define CH_DIGIT   5   /* '1'..'9' */
#define CH_FLAG    6   /* ' ', '+', '-', '#' */
#define CH_SIZE    7   /* 'h', 'l', 'L', 'N', 'F' */
#define CH_TYPE    8   /* conversion specified character */

#define NUMCHARS 9

unsigned char table[TABLESIZE];   /* the table we build */



/* this is the state table */

int statetable[NUMSTATES][NUMCHARS] = {
/* state,       other       %       .       *       0       digit   flag    size    type  */

/* NORMAL */  { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL },
/* PERCENT */ { BOGUS,    NORMAL,   DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* FLAG */    { BOGUS,    BOGUS,    DOT,    WIDTH,  FLAG,   WIDTH,  FLAG,   SIZE,   TYPE },
/* WIDTH */   { BOGUS,    BOGUS,    DOT,    BOGUS,  WIDTH,  WIDTH,  BOGUS,  SIZE,   TYPE },
/* DOT */     { BOGUS,    BOGUS,    BOGUS,  PRECIS, PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* PRECIS */  { BOGUS,    BOGUS,    BOGUS,  BOGUS,  PRECIS, PRECIS, BOGUS,  SIZE,   TYPE },
/* SIZE */    { BOGUS,    BOGUS,    BOGUS,  BOGUS,  BOGUS,  BOGUS,  BOGUS,  SIZE,   TYPE },
/* TYPE */    { NORMAL,   PERCENT,  NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL, NORMAL }
};

/* this determines what type of character ch is */

static int chartype (
        int ch
        )
{
    if (ch < ' ' || ch > 'z')
        return CH_OTHER;
    if (ch == '%')
        return CH_PERCENT;
    if (ch == '.')
        return CH_DOT;
    if (ch == '*')
        return CH_STAR;
    if (ch == '0')
        return CH_ZERO;
    if (strchr("123456789", ch))
        return CH_DIGIT;
    if (strchr(" +-#", ch))
        return CH_FLAG;
    if (strchr("hIlLNF", ch))
        return CH_SIZE;
    if (strchr("diouxXfeEgGcspn", ch))
        return CH_TYPE;
#ifdef  _WIN32
    /* Win32 supports three additional format codes for debugging purposes */

    if (strchr("BCS", ch))
        return CH_TYPE;
#endif  /* _WIN32 */

    return CH_OTHER;
}


main()
{
        int ch;
        int state, class;
        int i;

        for (ch = ' '; ch <= 'x'; ++ch) {
                table[ch-' '] = chartype(ch);
        }

        for (state = NORMAL; state <= TYPE; ++state)
                for (class = CH_OTHER; class <= CH_TYPE; ++class)
                        table[class*8+state] |= statetable[state][class]<<4;

        for (i = 0; i < TABLESIZE; ++i) {
                if (i % 8 == 0) {
                        if (i != 0)
                                printf(",");

                        printf("\n\t 0x%.2X", table[i]);
                }
                else
                        printf(", 0x%.2X", table[i]);
        }
        printf("\n");

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\getws.c ===
/***
*getws.c - read a line from stdin (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines getws() - read a line from stdin into buffer
*
*Revision History:
*	01-31-94  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "gets.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\output.c ===
/***
*output.c - printf style output to a FILE
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the code that does all the work for the
*       printf family of functions.  It should not be called directly, only
*       by the *printf functions.  We don't make any assumtions about the
*       sizes of ints, longs, shorts, or long doubles, but if types do overlap,
*       we also try to be efficient.  We do assume that pointers are the same
*       size as either ints or longs.
*       If CPRFLAG is defined, defines _cprintf instead.
*       **** DOESN'T CURRENTLY DO MTHREAD LOCKING ****
*
*Revision History:
*       06-01-89  PHG   Module created
*       08-28-89  JCR   Added cast to get rid of warning (no object changes)
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Changed LOCAL macro to incorporate _CALLTYPE4. Placed
*                       prototype for _output() in internal.h and #include-d
*                       it.
*       08-01-90  SBM   Compiles cleanly with -W3, moved _cfltcvt_tab and
*                       typedefs DOUBLE and LONGDOUBLE to new header
*                       <fltintrn.h>, formerly named <struct.h>
*       09-05-90  SBM   First attempt at adding CPRFLAG and code to generate
*                       cprintf.  Anything in #ifdef CPRFLAG untested.
*                       Still needs to have locking added for MTHREAD case.
*       10-03-90  GJF   New-style function declarators.
*       01-02-91  SRW   Added _WIN32_ conditional for 'C' and 'S' format chars.
*       01-16-91  GJF   ANSI naming.
*       01-16-91  SRW   Added #include of maketabc.out (_WIN32_)
*       04-09-91  PNT   Use the _CRUISER_ mapping for _MAC_
*       04-16-91  SRW   Fixed #include of maketabc.out (_WIN32_)
*       04-25-91  SRW   Made nullstring static
*       05-20-91  GJF   Moved state table for Win32 inline (_WIN32_).
*       09-12-91  JCR   Bumped conversion buffer size to be ANSI-compliant
*       09-17-91  IHJ   Add partial UNICODE (%ws, %wc) support
*       09-28-91  GJF   Merged with crt32 and crtdll versions. For now, 9-17-91
*                       change is built only for Win32, not Dosx32 (_WIN32_).
*       10-22-91  ETC   Complete wchar_t/mb support under _INTL.  For now,
*                       9-28-91 change is additionally under !_INTL.  Bug fix:
*                       ints and pointers are longs.
*       11-19-91  ETC   Added support for _wsprintf, _vwsprintf with WPRFLAG;
*                       added %tc %ts (generic string handling).
*       12-05-91  GDP   Bug fix: va_arg was used inconsistently for double
*       12-19-91  ETC   Added some comments on wsprintf optimization, undones;
*                       check return on malloc.
*       03-25-92  DJM   POSIX support
*       04-16-92  KRS   Support new ISO {s|f}wprintf with Unicode format string.
*       06-08-92  SRW   Modified to not use free and malloc for mbtowc conversion.
*       06-10-92  KRS   Fix glitch in previous change.
*       07-17-92  KRS   Fix typo which broke WPRFLAG support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-16-93  SKS   Fix bug in 'S' option logic.
*       04-26-93  CFW   Wide char enable.
*       07-14-93  TVB   Added Alpha support (quad stuff).
*       07-16-93  SRW   ALPHA Merge
*       07-26-93  GJF   Fixed write_multichar and write_string so that they
*                       stop looping when an error occurs. This generalizes
*                       and supplants the fix MattBr made for POSIX only.
*       08-17-93  CFW   Avoid mapping tchar macros incorrectly if _MBCS
*                       defined.
*       11-10-93  GJF   Merged in NT SDK version. Deleted Cruiser support
*                       and references to _WIN32_ (the former is obsolete and
*                       the later is assumed).
*       03-10-94  GJF   Added support for I64 size modifier.
*       03-25-94  GJF   Rebuilt __lookuptable[].
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       10-02-94  BWT   Add _M_PPC definition.
*       10-19-94  BWT   Reenable %Z and %ws/%wc for NT_BUILD only.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-23-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also, replaced
*                       WPRFLAG with _UNICODE.
*       05-03-96  GJF   Removed NT_BUILD. The extensions for NT (i.e., the 'Z'
*                       descriptor and 'w' modifier) are now in the retail
*                       build. Fixed textlen calculation for %ws. Also, 
*                       detab-ed.
*       07-25-96  SKS   Added initialization of textlen for cases where no valid
*                       format character is found after the % character.
*       08-01-96  RDK   Add support for %I64 for PMac.
*       09-09-96  JWM   Local struct "string" renamed to "_count_string" (Orion
*                       8710).
*       02-27-98  RKP   Added 64 bit support.
*       03-05-98  RKP   Expanded pointers to 64 bits on AXP64 and IA64.
*       09-17-98  GJF   Added support for %I32 and %I modifiers.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  GB    VS7#5431. Fixed output() for the case when L format
*                       specifier is used with wprintf
*       11-30-99  PML   Compile /Wp64 clean.
*       02-11-00  GB    Added support for unicode console output function
*                       (_cwprintf).
*       03-10-00  GB    Modified write_char for NULL pointer string in
*                       sprintf.
*       11-22-00  PML   Wide-char *putwc* functions take a wchar_t, not wint_t.
*
*******************************************************************************/

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define DOUBLE double
#endif


/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif


#include <cruntime.h>
#include <limits.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdarg.h>
#include <cvt.h>
#include <conio.h>
#include <internal.h>
#include <fltintrn.h>
#include <stdlib.h>
#include <ctype.h>
#include <dbgint.h>

/* inline keyword is non-ANSI C7 extension */
#if     !defined(_MSC_VER) || defined(__STDC__)
#define __inline static
#else
/* UNDONE: compiler is broken */
#define __inline static
#endif

#ifdef  _MBCS   /* always want either Unicode or SBCS for tchar.h */
#undef  _MBCS
#endif
#include <tchar.h>

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type> near. */
#define LOCAL(x) static x __cdecl

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
#define LONG_IS_INT      1      /* 1 means long is same size as int */
#define SHORT_IS_INT     0      /* 1 means short is same size as int */
#define LONGDOUBLE_IS_DOUBLE 1  /* 1 means long double is same as double */
#if     defined (_WIN64)
#define PTR_IS_INT       0      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      0      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     1      /* 1 means ptr is same size as int64 */
#else
#define PTR_IS_INT       1      /* 1 means ptr is same size as int */
#define PTR_IS_LONG      1      /* 1 means ptr is same size as long */
#define PTR_IS_INT64     0      /* 1 means ptr is same size as int64 */
#endif

#if     LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _UNICODE
#if SHORT_IS_INT
    #define get_short_arg(x) (short)get_int_arg(x)
#endif
#endif

#if     PTR_IS_INT
    #define get_ptr_arg(x) (void *)(intptr_t)get_int_arg(x)
#elif   PTR_IS_LONG
    #define get_ptr_arg(x) (void *)(intptr_t)get_long_arg(x)
#elif   PTR_IS_INT64
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif



/* CONSTANTS */

/* size of conversion buffer (ANSI-specified minimum is 509) */

#define BUFFERSIZE    512

#if     BUFFERSIZE < CVTBUFSIZE /*IFSTRIP=IGN*/
#error Conversion buffer too small for max double.
#endif

/* flag definitions */
#define FL_SIGN       0x00001   /* put plus or minus in front */
#define FL_SIGNSP     0x00002   /* put space or minus in front */
#define FL_LEFT       0x00004   /* left justify */
#define FL_LEADZERO   0x00008   /* pad with leading zeros */
#define FL_LONG       0x00010   /* long value given */
#define FL_SHORT      0x00020   /* short value given */
#define FL_SIGNED     0x00040   /* signed data given */
#define FL_ALTERNATE  0x00080   /* alternate form requested */
#define FL_NEGATIVE   0x00100   /* value is negative */
#define FL_FORCEOCTAL 0x00200   /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x00400   /* long double value given */
#define FL_WIDECHAR   0x00800   /* wide characters */
#define FL_I64        0x08000   /* __int64 value given */

/* state definitions */
enum STATE {
    ST_NORMAL,          /* normal state; outputting literal chars */
    ST_PERCENT,         /* just read '%' */
    ST_FLAG,            /* just read flag character */
    ST_WIDTH,           /* just read width specifier */
    ST_DOT,             /* just read '.' */
    ST_PRECIS,          /* just read precision specifier */
    ST_SIZE,            /* just read size specifier */
    ST_TYPE             /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,           /* character with no special meaning */
    CH_PERCENT,         /* '%' */
    CH_DOT,             /* '.' */
    CH_STAR,            /* '*' */
    CH_ZERO,            /* '0' */
    CH_DIGIT,           /* '1'..'9' */
    CH_FLAG,            /* ' ', '+', '-', '#' */
    CH_SIZE,            /* 'h', 'l', 'L', 'N', 'F', 'w' */
    CH_TYPE             /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
#ifdef _XBOX
#if     defined(_UNICODE) || defined(CPRFLAG)
extern char __nullstring[];  /* string to print on null ptr */
extern wchar_t __wnullstring[];  /* string to print on null ptr */
#else   /* _UNICODE || CPRFLAG */
#pragma data_seg(push)
#pragma data_seg(".rdata")
char __nullstring[] = "(null)";  /* string to print on null ptr */
wchar_t __wnullstring[] = L"(null)";/* string to print on null ptr */
#pragma data_seg(pop)
#endif  /* _UNICODE || CPRFLAG */
#else
#if     defined(_UNICODE) || defined(CPRFLAG)
extern char *__nullstring;  /* string to print on null ptr */
extern wchar_t *__wnullstring;  /* string to print on null ptr */
#else   /* _UNICODE || CPRFLAG */
char *__nullstring = "(null)";  /* string to print on null ptr */
wchar_t *__wnullstring = L"(null)";/* string to print on null ptr */
#endif  /* _UNICODE || CPRFLAG */
#endif  // XBOX

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketabc.c -- use this program to make       */
/* changes.                                                               */

#if     defined(_UNICODE) || defined(CPRFLAG)

extern const char __lookuptable[];

#else   /* _UNICODE/CPRFLAG */

/* Table generated by maketabc.c built with -D_WIN32_. Defines additional */
/* format code %Z for counted string.                                     */

const char __lookuptable[] = {
         0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
         0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
         0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
         0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
         0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
         0x00, 0x37, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
         0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
         0x08, 0x60,
         0x68, /* 'Z' (extension for NT development) */
                           0x60, 0x60, 0x60, 0x60, 0x00,
         0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
         0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
         0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00,
         0x07, /* 'w' (extension for NT development) */
         0x08
};

#endif  /* _UNICODE || CPRFLAG */

#define find_char_class(c)      \
        ((c) < _T(' ') || (c) > _T('x') ? \
            CH_OTHER            \
            :               \
        __lookuptable[(c)-_T(' ')] & 0xF)

#define find_next_state(class, state)   \
        (__lookuptable[(class) * NUMSTATES + (state)] >> 4)


/*
 * Note: CPRFLAG and _UNICODE cases are currently mutually exclusive.
 */

/* prototypes */

#ifdef  CPRFLAG

#define WRITE_CHAR(ch, pnw)         write_char(ch, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, pnw)

LOCAL(void) write_char(_TCHAR ch, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, int *numwritten);

#else

#define WRITE_CHAR(ch, pnw)         write_char(ch, stream, pnw)
#define WRITE_MULTI_CHAR(ch, num, pnw)  write_multi_char(ch, num, stream, pnw)
#define WRITE_STRING(s, len, pnw)   write_string(s, len, stream, pnw)
#define WRITE_WSTRING(s, len, pnw)  write_wstring(s, len, stream, pnw)

LOCAL(void) write_char(_TCHAR ch, FILE *f, int *pnumwritten);
LOCAL(void) write_multi_char(_TCHAR ch, int num, FILE *f, int *pnumwritten);
LOCAL(void) write_string(_TCHAR *string, int len, FILE *f, int *numwritten);
LOCAL(void) write_wstring(wchar_t *string, int len, FILE *f, int *numwritten);

#endif

__inline int __cdecl get_int_arg(va_list *pargptr);

#ifndef _UNICODE
#if     !SHORT_IS_INT
__inline short __cdecl get_short_arg(va_list *pargptr);
#endif
#endif

#if     !LONG_IS_INT
__inline long __cdecl get_long_arg(va_list *pargptr);
#endif

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
__inline __int64 __cdecl get_int64_arg(va_list *pargptr);
#endif

#ifdef  CPRFLAG
LOCAL(int) output(const _TCHAR *, va_list);

/***
*int _cprintf(format, arglist) - write formatted output directly to console
*
*Purpose:
*   Writes formatted data like printf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of characters written
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
int __cdecl _cwprintf (
#else
int __cdecl _cprintf (
#endif
        const _TCHAR * format,
        ...
        )
{
        va_list arglist;

        va_start(arglist, format);

        return output(format, arglist);
}

#endif  /* CPRFLAG */


/***
*int _output(stream, format, argptr), static int output(format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, _output assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   FILE *stream   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*ifdef _UNICODE
*   The wide-character flavour returns the number of wide-characters written.
*endif
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG
LOCAL(int) output (
#else

#ifdef  _UNICODE
int __cdecl _woutput (
    FILE *stream,
#else
int __cdecl _output (
    FILE *stream,
#endif

#endif
    const _TCHAR *format,
    va_list argptr
    )
{
    int hexadd;     /* offset to add to number to get 'a'..'f' */
    TCHAR ch;       /* character just read */
    int flags;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;      /* current conversion radix */
    int charsout;   /* characters currently written so far, -1 = IO error */
    int fldwidth;   /* selected field width -- 0 means default */
    int precision;  /* selected precision  -- -1 means default */
    TCHAR prefix[2];    /* numeric prefix -- up to two characters */
    int prefixlen;  /* length of prefix -- 0 means no prefix */
    int capexp;     /* non-zero = 'E' exponent signifient, zero = 'e' */
    int no_output;  /* non-zero = prodcue no output for this specifier */
    union {
        char *sz;   /* pointer text to be printed, not zero terminated */
        wchar_t *wz;
        } text;

    int textlen;    /* length of the text in bytes/wchars to be printed.
                       textlen is in multibyte or wide chars if _UNICODE */
    union {
        char sz[BUFFERSIZE];
#ifdef  _UNICODE
        wchar_t wz[BUFFERSIZE];
#endif
        } buffer;
    wchar_t wchar;      /* temp wchar_t */
    int bufferiswide;   /* non-zero = buffer contains wide chars already */

    textlen = 0;        /* no text yet */
    charsout = 0;       /* no characters written yet */
    state = ST_NORMAL;  /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != _T('\0') && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:

        NORMAL_STATE:

            /* normal state -- just write character */
#ifdef  _UNICODE
            bufferiswide = 1;
#else
            bufferiswide = 0;
#if !defined(_XBOX) || !defined(_NTSUBSET_)
            if (isleadbyte((int)(unsigned char)ch)) {
                WRITE_CHAR(ch, &charsout);
                ch = *format++;
                _ASSERTE (ch != _T('\0')); /* UNDONE: don't fall off format string */
            }
#endif  /* !_XBOX || !_NTSUBSET_ */
#endif  /* !_UNICODE */
            WRITE_CHAR(ch, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            bufferiswide = 0;   /* default */
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case _T('-'):
                flags |= FL_LEFT;   /* '-' => left justify */
                break;
            case _T('+'):
                flags |= FL_SIGN;   /* '+' => force sign indicator */
                break;
            case _T(' '):
                flags |= FL_SIGNSP; /* ' ' => force sign or space */
                break;
            case _T('#'):
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case _T('0'):
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == _T('*')) {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - _T('0'));
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == _T('*')) {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1; /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - _T('0'));
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
            case _T('l'):
                flags |= FL_LONG;   /* 'l' => long int or wchar_t */
                break;
#if     !LONGDOUBLE_IS_DOUBLE || defined(_M_ALPHA)
            /*
             * Alpha has native 64-bit integer registers and operations.
             * The int and long types are 32 bits and an Alpha specific
             * __int64 type is 64 bits.  We also use the 'L' flag for
             * integer arguments to indicate 64-bit conversions (%Lx).
             */

            case _T('L'):
                flags |= FL_I64;    /* 'L' => __int64 */
                break;
#endif

            case _T('I'):
                /*
                 * In order to handle the I, I32, and I64 size modifiers, we
                 * depart from the simple deterministic state machine. The
                 * code below scans for characters following the 'I',
                 * and defaults to 64 bit on WIN64 and 32 bit on WIN32
                 */
#if     PTR_IS_INT64
                flags |= FL_I64;    /* 'I' => __int64 on WIN64 systems */
#endif
                if ( (*format == _T('6')) && (*(format + 1) == _T('4')) )
                {
                    format += 2;
                    flags |= FL_I64;    /* I64 => __int64 */
                }
                else if ( (*format == _T('3')) && (*(format + 1) == _T('2')) )
                {
                    format += 2;
                    flags &= ~FL_I64;   /* I32 => __int32 */
                }
                else if ( (*format == _T('d')) ||
                          (*format == _T('i')) ||
                          (*format == _T('o')) ||
                          (*format == _T('u')) ||
                          (*format == _T('x')) ||
                          (*format == _T('X')) )
                {
                   /*
                    * Nothing further needed.  %Id (et al) is
                    * handled just like %d, except that it defaults to 64 bits
                    * on WIN64.  Fall through to the next iteration.
                    */
                }
                else {
                    state = ST_NORMAL;
                    goto NORMAL_STATE;
                }
                break;

            case _T('h'):
                flags |= FL_SHORT;  /* 'h' => short int or char */
                break;

/* UNDONE: support %wc and %ws for now only for compatibility */
            case _T('w'):
                flags |= FL_WIDECHAR;  /* 'w' => wide character */
                break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is done in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case _T('C'):   /* ISO wide character */
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
#ifdef  _UNICODE
                    flags |= FL_SHORT;
#else
                    flags |= FL_WIDECHAR;   /* ISO std. */
#endif
                /* fall into 'c' case */

            case _T('c'): {
                /* print a single character specified by int argument */
#ifdef  _UNICODE
                bufferiswide = 1;
                wchar = (wchar_t) get_int_arg(&argptr);
                if (flags & FL_SHORT) {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    char tempchar[2];
#ifdef  _OUT
                    if (isleadbyte(wchar >> 8)) {
                        tempchar[0] = (wchar >> 8);
                        tempchar[1] = (wchar & 0x00ff);
                    }
                    else
#endif  /* _OUT */
                    {
                        tempchar[0] = (char)(wchar & 0x00ff);
                        tempchar[1] = '\0';
                    }

                    if (mbtowc(buffer.wz,tempchar,MB_CUR_MAX) < 0) {
                        /* ignore if conversion was unsuccessful */
                        no_output = 1;
                    }
                } else {
                    buffer.wz[0] = wchar;
                }
                text.wz = buffer.wz;
                textlen = 1;    /* print just a single character */
#else   /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    wchar = (wchar_t) get_short_arg(&argptr);
                    /* convert to multibyte character */
                    textlen = wctomb(buffer.sz, wchar);

                    /* check that conversion was successful */
                    if (textlen < 0)
                        no_output = 1;
                } else {
                    /* format multibyte character */
                    /* this is an extension of ANSI */
                    unsigned short temp;
                    temp = (unsigned short) get_int_arg(&argptr);
#ifdef  _OUT
                    if (isleadbyte(temp >> 8)) {
                        buffer.sz[0] = temp >> 8;
                        buffer.sz[1] = temp & 0x00ff;
                        textlen = 2;
                    } else
#endif  /* _OUT */
                    {
                        buffer.sz[0] = (char) temp;
                        textlen = 1;
                    }
                }
                text.sz = buffer.sz;
#endif  /* _UNICODE */
            }
            break;

            case _T('Z'): {
                /* print a Counted String

                int i;
                char *p;       /* temps */
                struct _count_string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text.sz = __nullstring;
                    textlen = (int)strlen(text.sz);
                } else {
                    if (flags & FL_WIDECHAR) {
                        text.wz = (wchar_t *)pstr->Buffer;
                        textlen = pstr->Length / (int)sizeof(wchar_t);
                        bufferiswide = 1;
                    } else {
                        bufferiswide = 0;
                        text.sz = pstr->Buffer;
                        textlen = pstr->Length;
                    }
                }
            }
            break;

            case _T('S'):   /* ISO wide character string */
#ifndef _UNICODE
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_WIDECHAR;
#else
                if (!(flags & (FL_SHORT|FL_LONG|FL_WIDECHAR)))
                    flags |= FL_SHORT;
#endif

            case _T('s'): {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */
                wchar_t *pwch;

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;
                text.sz = get_ptr_arg(&argptr);

/* UNDONE: handle '#' case properly */
                /* scan for null upto i characters */
#ifdef  _UNICODE
                if (flags & FL_SHORT) {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    for (textlen=0; textlen<i && *p; textlen++) {
                        if (isleadbyte((int)*p))
                            ++p;
                        ++p;
                    }
                    /* textlen now contains length in multibyte chars */
                } else {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz;
                    while (i-- && *pwch)
                        ++pwch;
                    textlen = (int)(pwch - text.wz);       /* in wchar_ts */
                    /* textlen now contains length in wide chars */
                }
#else   /* _UNICODE */
                if (flags & (FL_LONG|FL_WIDECHAR)) {
                    if (text.wz == NULL) /* NULL passed, use special string */
                        text.wz = __wnullstring;
                    bufferiswide = 1;
                    pwch = text.wz; 
                    while ( i-- && *pwch )
                        ++pwch;
                    textlen = (int)(pwch - text.wz);
                    /* textlen now contains length in wide chars */
                } else {
                    if (text.sz == NULL) /* NULL passed, use special string */
                        text.sz = __nullstring;
                    p = text.sz;
                    while (i-- && *p)
                        ++p;
                    textlen = (int)(p - text.sz);    /* length of the string */
                }

#endif  /* _UNICODE */
            }
            break;


            case _T('n'): {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if     !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if     !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#if defined(_XBOX) && defined(_NTSUBSET_)
            case _T('E'):
            case _T('G'):
            case _T('e'):
            case _T('f'):
            case _T('g'): {
#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    LONGDOUBLE tmp;
                    tmp=va_arg(argptr, LONGDOUBLE);
                } else
#endif
                {
                    DOUBLE tmp;
                    tmp=va_arg(argptr, DOUBLE);
                }
            }
            break;
#else
            case _T('E'):
            case _T('G'):
                capexp = 1;                 /* capitalize exponent */
                ch += _T('a') - _T('A');    /* convert format char to lower */
                /* DROP THROUGH */
            case _T('e'):
            case _T('f'):
            case _T('g'): {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text.sz = buffer.sz;        /* put result in buffer */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;          /* default precision: 6 */
                else if (precision == 0 && ch == _T('g'))
                    precision = 1;          /* ANSI specified */

#if     !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    LONGDOUBLE tmp;
                    tmp=va_arg(argptr, LONGDOUBLE);
                    /* Note: assumes ch is in ASCII range */
                    _cldcvt(&tmp, text.sz, (char)ch, precision, capexp);
                } else
#endif
                {
                    DOUBLE tmp;
                    tmp=va_arg(argptr, DOUBLE);
                    /* Note: assumes ch is in ASCII range */
                    _cfltcvt(&tmp,text.sz, (char)ch, precision, capexp);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text.sz);

                /* 'g' format means crop zero unless '#' given */
                if (ch == _T('g') && !(flags & FL_ALTERNATE))
                    _cropzeros(text.sz);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text.sz == '-') {
                    flags |= FL_NEGATIVE;
                    ++text.sz;
                }

                textlen = (int)strlen(text.sz);     /* compute length of text */
            }
            break;
#endif  /* _XBOX && _NTSUBSET_ */

            case _T('d'):
            case _T('i'):
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case _T('u'):
                radix = 10;
                goto COMMON_INT;

            case _T('p'):
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if     PTR_IS_INT64
                flags |= FL_I64;                    /* assume we're converting an int64 */
#elif   !PTR_IS_INT
                flags |= FL_LONG;                   /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case _T('X'):
                /* unsigned upper hex output */
                hexadd = _T('A') - _T('9') - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case _T('x'):
                /* unsigned lower hex output */
                hexadd = _T('a') - _T('9') - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = _T('0');
                    prefix[1] = (TCHAR)(_T('x') - _T('a') + _T('9') + 1 + hexadd);  /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case _T('o'):
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                unsigned __int64 number;    /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;              /* temp long value */
#else
                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */
#endif

                /* 1. read argument into l, sign extend as needed */
#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                if (flags & FL_I64)
                    l = get_int64_arg(&argptr);
                else
#endif

#if     !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if     !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                } else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                } else {
                    number = l;
                }

#if     _INTEGRAL_MAX_BITS >= 64        /*IFSTRIP=IGN*/
                if ( (flags & FL_I64) == 0 ) {
                    /*
                     * Unless printing a full 64-bit value, insure values
                     * here are not in cananical longword format to prevent
                     * the sign extended upper 32-bits from being printed.
                     */
                    number &= 0xffffffff;
                }
#endif

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;  /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text.sz = &buffer.sz[BUFFERSIZE-1];    /* last digit at end of buffer */

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;                /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text.sz-- = (char)digit;       /* store the digit */
                }

                textlen = (int)((char *)&buffer.sz[BUFFERSIZE-1] - text.sz); /* compute length of number */
                ++text.sz;          /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text.sz[0] != '0' || textlen == 0)) {
                    *--text.sz = '0';
                    ++textlen;      /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = _T('-');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = _T('+');
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = _T(' ');
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* write prefix */
                WRITE_STRING(prefix, prefixlen, &charsout);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    WRITE_MULTI_CHAR(_T('0'), padding, &charsout);
                }

                /* write text */
#ifndef _UNICODE
                if (bufferiswide && (textlen > 0)) {
                    wchar_t *p;
                    int retval, count;
                    char buffer[MB_LEN_MAX+1];

                    p = text.wz;
                    count = textlen;
                    while (count--) {
                        retval = wctomb(buffer, *p++);
                        if (retval <= 0)
                            break;
                        WRITE_STRING(buffer, retval, &charsout);
                    }
                } else {
                    WRITE_STRING(text.sz, textlen, &charsout);
                }
#else
                if (!bufferiswide && textlen > 0) {
                    char *p;
                    int retval, count;

                    p = text.sz;
                    count = textlen;
                    while (count-- > 0) {
                        retval = mbtowc(&wchar, p, MB_CUR_MAX);
                        if (retval <= 0)
                            break;
                        WRITE_CHAR(wchar, &charsout);
                        p += retval;
                    }
                } else {
                    WRITE_STRING(text.wz, textlen, &charsout);
                }
#endif  /* _UNICODE */

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    WRITE_MULTI_CHAR(_T(' '), padding, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}

/*
 *  Future Optimizations for swprintf:
 *  - Don't free the memory used for converting the buffer to wide chars.
 *    Use realloc if the memory is not sufficient.  Free it at the end.
 */

/***
*void write_char(char ch, int *pnumwritten)
*ifdef _UNICODE
*void write_char(wchar_t ch, FILE *f, int *pnumwritten)
*endif
*void write_char(char ch, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a single character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented; otherwise, *pnumwritten is set
*   to -1.
*
*Entry:
*   _TCHAR ch        - character to write
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG

LOCAL(void) write_char (
    _TCHAR ch,
    int *pnumwritten
    )
{
#ifdef  _UNICODE
    if (_putwch_lk(ch) == WEOF)
#else
    if (_putch_lk(ch) == EOF)
#endif  //_UNICODE
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#else

LOCAL(void) write_char (
    _TCHAR ch,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        ++(*pnumwritten);
        return;
    }
#ifdef  _UNICODE
    if (_putwc_lk(ch, f) == WEOF)
#else
    if (_putc_lk(ch, f) == EOF)
#endif  //_UNICODE
        *pnumwritten = -1;
    else
        ++(*pnumwritten);
}

#endif

/***
*void write_multi_char(char ch, int num, int *pnumwritten)
*ifdef _UNICODE
*void write_multi_char(wchar_t ch, int num, FILE *f, int *pnumwritten)
*endif
*void write_multi_char(char ch, int num, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes num copies of a character to the given file/console.  If no error occurs,
*   then *pnumwritten is incremented by num; otherwise, *pnumwritten is set
*   to -1.  If num is negative, it is treated as zero.
*
*Entry:
*   _TCHAR ch        - character to write
*   int num          - number of times to write the characters
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG
LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#else   /* CPRFLAG */

LOCAL(void) write_multi_char (
    _TCHAR ch,
    int num,
    FILE *f,
    int *pnumwritten
    )
{
    while (num-- > 0) {
        write_char(ch, f, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#endif  /* CPRFLAG */

/***
*void write_string(char *string, int len, int *pnumwritten)
*void write_string(char *string, int len, FILE *f, int *pnumwritten)
*ifdef _UNICODE
*void write_string(wchar_t *string, int len, FILE *f, int *pnumwritten)
*endif
*void write_wstring(wchar_t *string, int len, int *pnumwritten)
*void write_wstring(wchar_t *string, int len, FILE *f, int *pnumwritten)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pnumwritten is incremented by len; otherwise, *pnumwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   _TCHAR *string   - string to write (NOT null-terminated)
*   int len          - length of string
*   FILE *f          - file to write to
*   int *pnumwritten - pointer to integer to update with total chars written
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  CPRFLAG

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    int *pnumwritten
    )
{
    while (len-- > 0) {
        write_char(*string++, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}

#else   /* CPRFLAG */

LOCAL(void) write_string (
    _TCHAR *string,
    int len,
    FILE *f,
    int *pnumwritten
    )
{
    if ( (f->_flag & _IOSTRG) && f->_base == NULL)
    {
        (*pnumwritten) += len;
        return;
    }
    while (len-- > 0) {
        write_char(*string++, f, pnumwritten);
        if (*pnumwritten == -1)
            break;
    }
}
#endif  /* CPRFLAG */


/***
*int get_int_arg(va_list *pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

__inline int __cdecl get_int_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list *pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if     !LONG_IS_INT
__inline long __cdecl get_long_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, long);
}
#endif

#if     _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
__inline __int64 __cdecl get_int64_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, __int64);
}
#endif

#ifndef _UNICODE
/***
*short get_short_arg(va_list *pargptr)
*
*Purpose:
*   Gets a short argument off the given argument list and updates *pargptr.
*   *** CURRENTLY ONLY USED TO GET A WCHAR_T, IFDEF _INTL ***
*
*Entry:
*   va_list *pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the short argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

#if     !SHORT_IS_INT
__inline short __cdecl get_short_arg (
    va_list *pargptr
    )
{
    return va_arg(*pargptr, short);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\input.c ===
/***
*input.c - C formatted input, used by scanf, etc.
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _input() to do formatted input; called from scanf(),
*       etc. functions.  This module defines _cscanf() instead when
*       CPRFLAG is defined.  The file cscanf.c defines that symbol
*       and then includes this file in order to implement _cscanf().
*
*Revision History:
*       09-26-83  RN    author
*       11-01-85  TC    added %F? %N? %?p %n %i
*       11-20-86  SKS   enlarged "table" to 256 bytes, to support chars > 0x7F
*       12-12-86  SKS   changed "s_in()" to pushback whitespace or other delimiter
*       03-24-87  BCM   Evaluation Issues:
*                       SDS - needs #ifdef SS_NE_DS for the "number" buffer
*                           (for S/M models only)
*                       GD/TS : (not evaluated)
*                       other INIT : (not evaluated)
*                           needs _cfltcvt_init to have been called if
*                           floating-point i/o conversions are being done
*                       TERM - nothing
*       06-25-87  PHG   added check_stack pragma
*       08-31-87  JCR   Made %n conform to ANSI standard: (1) %n is supposed to
*                       return the # of chars read so far by the current scanf(),
*                       NOT the total read on the stream since open; (2) %n is NOT
*                       supposed to affect the # of items read that is returned by
*                       scanf().
*       09-24-87  JCR   Made cscanf() use the va_ macros (fixes cl warnings).
*       11-04-87  JCR   Multi-thread support
*       11-16-87  JCR   Cscanf() now gets _CONIO_LOCK
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       02-25-88  JCR   If burn() char hits EOF, only return EOF if count==0.
*       05-31-88  WAJ   Now suports %Fs and %Ns
*       06-01-88  PHG   Merged DLL and normal versions
*       06-08-88  SJM   %D no longer means %ld.  %[]ABC], %[^]ABC] work.
*       06-14-88  SJM   Fixed %p, and %F? and %N? code.
*                 SJM   Complete re-write of input/_input for 6.00
*       09-15-88  JCR   If we match a field but it's not assigned, then are
*                       terminated by EOF, we must return 0 not EOF (ANSI).
*       09-25-88  GJF   Initial adaption for the 386
*       10-04-88  JCR   386: Removed 'far' keyword
*       11-30-88  GJF   Cleanup, now specific to 386
*       06-09-89  GJF   Propagated fixes of 03-06-89 and 04-05-89
*       11-20-89  GJF   Added const attribute to type of format. Also, fixed
*                       copyright.
*       12-21-89  GJF   Allow null character in scanset
*       02-14-90  KRS   Fix suppressed-assignment pattern matching.
*       03-20-90  GJF   Made _cscanf() _CALLTYPE2 and _input() _CALLTYPE1. Added
*                       #include <cruntime.h> and #include <register.h>.
*       03-26-90  GJF   Made static functions _CALLTYPE4. Placed prototype for
*                       _input() in internal.h and #include-d it. Changed type of
*                       arglist from void ** to va_list (to get rid of annoying
*                       warnings). Added #include <string.h>. Elaborated prototypes
*                       of static functions to get rid of compiler warnings.
*       05-21-90  GJF   Fixed stack checking pragma syntax.
*       07-23-90  SBM   Compiles cleanly with -W3, replaced <assertm.h> by
*                       <assert.h>, moved _cfltcvt_tab to new header
*                       <fltintrn.h>, formerly named <struct.h>
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       08-27-90  SBM   Minor cleanup to agree with CRT7 version
*       10-02-90  GJF   New-style function declarators. Also, rewrote expr. to
*                       avoid using casts as lvalues.
*       10-22-90  GJF   Added arglistsave, used to save and restore arglist pointer
*                       without using pointer arithmetic.
*       12-28-90  SRW   Added _CRUISER_ conditional around check_stack pragma
*       01-16-91  GJF   ANSI naming.
*       03-14-91  GJF   Fix to allow processing of %n, even at eof. Fix devised by
*                       DanK of PSS.
*       06-19-91  GJF   Fixed execution of string, character and scan-set format
*                       directives to avoid problem with line-buffered devices
*                       (C700 bug 1441).
*       10-22-91  ETC   Int'l dec point; Under _INTL: wchar_t/mb support; fix bug
*                       under !ALLOW_RANGE (never compiled).
*       11-15-91  ETC   Fixed bug with %f %lf %Lf (bad handling of longone).
*       11-19-91  ETC   Added support for _wsscanf with WPRFLAG; added %tc %ts.
*       06-09-92  KRS   Rip out %tc/%ts; conform to new ISO spec.
*       08-17-92  KRS   Further ISO changes:  Add %lc/%ls/%hc/%hs/%C/%S.
*       12-23-92  SKS   Needed to handle %*n (suppressed storage of byte count)
*       02-16-93  CFW   Added wide character output for [] scanset.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       08-17-93  CFW   Avoid mapping tchar macros incorrectly if _MBCS defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       11-08-93  GJF   Merged in NT SDK version (use __unaligned pointer
*                       casts on MIPS and Alpha. Also, fixed #elif WPRFLAG to
*                       be #elif defined(WPRFLAG), and removed old CRUISER
*                       support.
*       12-16-93  CFW   Get rid of spurious compiler warnings.
*       03-15-94  GJF   Added support for I64 size modifier.
*       04-21-94  GJF   Must reinitialize integer64 flag.
*       09-05-94  SKS   Remove include of obsolete 16-bit file <sizeptr.h>
*       12-14-94  GJF   Changed test for (hex) digits so that when WPRFLAG is
*                       defined, only zero-extended (hex) digits are
*                       recognized. This way, the familar arithmetic to convert
*                       from character rep. to binary integer value will work.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also, replaced
*                       WPRFLAG with _UNICODE.
*       08-01-96  RDK   For PMac, added __int64 support for _input.
*       02-27-98  RKP   Added 64 bit support.
*       07-07-98  RKP   Corrected %P formatting for 64 bit.
*       09-21-98  GJF   Added support for %I and %I32 modifiers.
*       05-17-99  PML   Remove all Macintosh support.
*       10-28-99  PML   vs7#10705 Win64 %p was totally busted
*       04-25-00  GB    Adding support for _cwprintf.
*       05-31-00  GB    Changed scanf to match with standards. problem was
*                       reading octal or hexa while %d was specified.
*       10-20-00  GB    Changed input not to use %[] case for %c and %s.
*       02-19-01  GB    Added check for return value of malloc.
*       03-13-01  PML   Fix heap leak on multiple %[] specs (vs7#224990)
*
*******************************************************************************/


#define ALLOW_RANGE /* allow "%[a-z]"-style scansets */


/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif


#include <cruntime.h>
#include <stdio.h>
#include <ctype.h>
#include <cvt.h>
#include <conio.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <fltintrn.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <nlsint.h>
#include <dbgint.h>

#ifdef _MBCS    /* always want either Unicode or SBCS for tchar.h */
#undef _MBCS
#endif
#include <tchar.h>

#define HEXTODEC(chr)   _hextodec(chr)
#define LEFT_BRACKET    ('[' | ('a' - 'A')) /* 'lowercase' version */

#ifdef _UNICODE
static wchar_t __cdecl _hextodec(wchar_t);
#else
static int __cdecl _hextodec(int);
#endif /* _UNICODE */

#ifdef CPRFLAG

#define INC()           (++charcount, _inc())
#define UN_INC(chr)     (--charcount, _un_inc(chr))
#define EAT_WHITE()     _whiteout(&charcount)

#ifndef _UNICODE
static int __cdecl _inc(void);
static void __cdecl _un_inc(int);
static int __cdecl _whiteout(int *);
#else /* _UNICODE */
static wchar_t __cdecl _inc(void);
static void __cdecl _un_inc(wchar_t);
static wchar_t __cdecl _whiteout(int *);
#endif /* _UNICODE */

#else /* CPRFLAG */

#define INC()           (++charcount, _inc(stream))
#define UN_INC(chr)     (--charcount, _un_inc(chr, stream))
#define EAT_WHITE()     _whiteout(&charcount, stream)

#ifndef _UNICODE
static int __cdecl _inc(FILE *);
static void __cdecl _un_inc(int, FILE *);
static int __cdecl _whiteout(int *, FILE *);
#else /* _UNICODE */
static wchar_t __cdecl _inc(FILE *);
static void __cdecl _un_inc(wchar_t, FILE *);
static wchar_t __cdecl _whiteout(int *, FILE *);
#endif /* _UNICODE */

#endif /* CPRFLAG */


#ifndef _UNICODE
#define _ISDIGIT(chr)   isdigit(chr)
#define _ISXDIGIT(chr)  isxdigit(chr)
#else
#define _ISDIGIT(chr)   ( !(chr & 0xff00) && isdigit( chr & 0x00ff ) )
#define _ISXDIGIT(chr)  ( !(chr & 0xff00) && isxdigit( chr & 0x00ff ) )
#endif



#ifdef CPRFLAG
#ifndef _UNICODE
static int __cdecl input(const unsigned char *, va_list);
#else
static int __cdecl input(const wchar_t *, va_list);
#endif


/***
*int _cscanf(format, arglist) - read formatted input direct from console
*
*Purpose:
*   Reads formatted data like scanf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of successfully matched data items (from input)
*
*Exceptions:
*
*******************************************************************************/

#ifndef _UNICODE
int __cdecl _cscanf (
    const char *format,
#else /* _UNICODE */
int __cdecl _cwscanf (
    const wchar_t *format,
#endif /* _UNICODE */
    ...
    )
{
    va_list arglist;

    va_start(arglist, format);

    _ASSERTE(format != NULL);

    return input(format,arglist);   /* get the input */
}

#endif  /* CPRFLAG */


#define ASCII       32           /* # of bytes needed to hold 256 bits */

#define SCAN_SHORT     0         /* also for FLOAT */
#define SCAN_LONG      1         /* also for DOUBLE */
#define SCAN_L_DOUBLE  2         /* only for LONG DOUBLE */

#define SCAN_NEAR    0
#define SCAN_FAR     1

#ifndef _UNICODE
#define TABLESIZE    ASCII
#else
#define TABLESIZE    (ASCII * 256)
#endif


/***
*int _input(stream, format, arglist), static int input(format, arglist)
*
*Purpose:
*   get input items (data items or literal matches) from the input stream
*   and assign them if appropriate to the items thru the arglist. this
*   function is intended for internal library use only, not for the user
*
*   The _input entry point is for the normal scanf() functions
*   The input entry point is used when compiling for _cscanf() [CPRFLAF
*   defined] and is a static function called only by _cscanf() -- reads from
*   console.
*
*Entry:
*   FILE *stream - file to read from
*   char *format - format string to determine the data to read
*   arglist - list of pointer to data items
*
*Exit:
*   returns number of items assigned and fills in data items
*   returns EOF if error or EOF found on stream before 1st data item matched
*
*Exceptions:
*
*******************************************************************************/

#ifdef CPRFLAG

#ifndef _UNICODE
static int __cdecl input (
    const unsigned char *format,
    va_list arglist
    )
#else
static int __cdecl input (
    const wchar_t *format,
    va_list arglist
    )
#endif /* _UNICODE */ 
#else
#if defined(_UNICODE)

int __cdecl _winput (
    FILE *stream,
    const wchar_t *format,
    va_list arglist
    )
#else

int __cdecl _input (
    FILE *stream,
    const unsigned char *format,
    va_list arglist
    )
#endif /* _UNICODE */ 
#endif /* CPRFLAG */

{
#ifndef _UNICODE
    char floatstring[CVTBUFSIZE + 1];   /* ASCII buffer for floats           */
#else
    wchar_t floatstring[CVTBUFSIZE + 1];
#endif

    unsigned long number;               /* temp hold-value                   */
    char *table = NULL;                 /* which chars allowed for %[]       */
    int malloc_flag = 0;                /* is "table" allocated on the heap? */
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
    unsigned __int64 num64;             /* temp for 64-bit integers          */
#endif
    void *pointer;                      /* points to user data receptacle    */
    void *start;                        /* indicate non-empty string         */


#ifdef _UNICODE
    wchar_t *scanptr;                   /* for building "table" data         */
REG2 wchar_t ch = 0;
#else
    wchar_t wctemp;
    unsigned char *scanptr;             /* for building "table" data         */
REG2 int ch = 0;
#endif
    int charcount;                      /* total number of chars read        */
REG1 int comchr;                        /* holds designator type             */
    int count;                          /* return value.  # of assignments   */

    int started;                        /* indicate good number              */
    int width;                          /* width of field                    */
    int widthset;                       /* user has specified width          */

/* Neither coerceshort nor farone are need for the 386 */


    char done_flag;                     /* general purpose loop monitor      */
    char longone;                       /* 0 = SHORT, 1 = LONG, 2 = L_DOUBLE */
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
    int integer64;                      /* 1 for 64-bit integer, 0 otherwise */
#endif
    signed char widechar;               /* -1 = char, 0 = ????, 1 = wchar_t  */
    char reject;                        /* %[^ABC] instead of %[ABC]         */
    char negative;                      /* flag for '-' detected             */
    char suppress;                      /* don't assign anything             */
    char match;                         /* flag: !0 if any fields matched    */
    va_list arglistsave;                /* save arglist value                */

    char fl_wchar_arg;                  /* flags wide char/string argument   */
#ifdef _UNICODE
#ifdef ALLOW_RANGE
    wchar_t rngch;              /* used while scanning range         */
#endif
    wchar_t last;               /* also for %[a-z]                   */
    wchar_t prevchar;           /* for %[a-z]                        */
    wchar_t wdecimal;                   /* wide version of decimal point     */
    wchar_t *wptr;                      /* pointer traverses wide floatstring*/
#else
#ifdef ALLOW_RANGE
    unsigned char rngch;                /* used while scanning range         */
#endif
    unsigned char last;                 /* also for %[a-z]                   */
    unsigned char prevchar;             /* for %[a-z]                        */
#endif

    _ASSERTE(format != NULL);

#ifndef CPRFLAG
    _ASSERTE(stream != NULL);
#endif

    /*
    count = # fields assigned
    charcount = # chars read
    match = flag indicating if any fields were matched

    [Note that we need both count and match.  For example, a field
    may match a format but have assignments suppressed.  In this case,
    match will get set, but 'count' will still equal 0.  We need to
    distinguish 'match vs no-match' when terminating due to EOF.]
    */

    count = charcount = match = 0;

    while (*format) {

        if (_istspace((_TUCHAR)*format)) {

            UN_INC(EAT_WHITE()); /* put first non-space char back */

            while ((_istspace)(*++format)); /* NULL */
            /* careful: isspace macro may evaluate argument more than once! */
            continue;

        }

        if (_T('%') == *format) {

            number = 0;
            prevchar = 0;
            width = widthset = started = 0;
            fl_wchar_arg = done_flag = suppress = negative = reject = 0;
            widechar = 0;

            longone = 1;

            integer64 = 0;

            while (!done_flag) {

                comchr = *++format;
                if (_ISDIGIT((_TUCHAR)comchr)) {
                    ++widthset;
                    width = MUL10(width) + (comchr - _T('0'));
                } else
                    switch (comchr) {
                        case _T('F') :
                        case _T('N') :   /* no way to push NEAR in large model */
                            break;  /* NEAR is default in small model */
                        case _T('h') :
                            /* set longone to 0 */
                            --longone;
                            --widechar;         /* set widechar = -1 */
                            break;

#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        case _T('I'):
                            if ( (*(format + 1) == _T('6')) &&
                                 (*(format + 2) == _T('4')) )
                            {
                                format += 2;
                                ++integer64;
                                num64 = 0;
                                break;
                            }
                            else if ( (*(format + 1) == _T('3')) &&
                                      (*(format + 2) == _T('2')) )
                            {
                                format += 2;
                                break;
                            }
                            else if ( (*(format + 1) == _T('d')) ||
                                      (*(format + 1) == _T('i')) ||
                                      (*(format + 1) == _T('o')) ||
                                      (*(format + 1) == _T('x')) ||
                                      (*(format + 1) == _T('X')) )
                            {
                                if (sizeof(void*) == sizeof(__int64))
                                {
                                    ++integer64;
                                    num64 = 0;
                                }
                                break;
                            }
                            if (sizeof(void*) == sizeof(__int64))
                            {
                                    ++integer64;
                                    num64 = 0;
                            }
                            goto DEFAULT_LABEL;
#endif

                        case _T('L') :
                        /*  ++longone;  */
                            ++longone;
                            break;

                        case _T('l') :
                            ++longone;
                                    /* NOBREAK */
                        case _T('w') :
                            ++widechar;         /* set widechar = 1 */
                            break;

                        case _T('*') :
                            ++suppress;
                            break;

                        default:
DEFAULT_LABEL:
                            ++done_flag;
                            break;
                    }
            }

            if (!suppress) {
                arglistsave = arglist;
                pointer = va_arg(arglist,void *);
            }

            done_flag = 0;

            if (!widechar) {    /* use case if not explicitly specified */
                if ((*format == _T('S')) || (*format == _T('C')))
#ifdef _UNICODE
                    --widechar;
                else
                    ++widechar;
#else
                    ++widechar;
                else
                    --widechar;
#endif
            }

            /* switch to lowercase to allow %E,%G, and to
               keep the switch table small */

            comchr = *format | (_T('a') - _T('A'));

            if (_T('n') != comchr)
                if (_T('c') != comchr && LEFT_BRACKET != comchr)
                    ch = EAT_WHITE();
                else
                    ch = INC();

#ifdef _POSIX_
            if (_T('n') != comchr)
            {
                if (EOF == ch)
                    goto error_return;
            }
#endif

            if (!widthset || width) {

                switch(comchr) {

                    case _T('c'):
                /*  case _T('C'):  */
                        if (!widthset) {
                            ++widthset;
                            ++width;
                        }
                        if (widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case _T('s'):
                /*  case _T('S'):  */
                        if(widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case LEFT_BRACKET :   /* scanset */
                        if (widechar>0)
                            fl_wchar_arg++;
                        scanptr = (_TCHAR *)(++format);

                        if (_T('^') == *scanptr) {
                            ++scanptr;
                            --reject; /* set reject to 255 */
                        }

                        /* Allocate "table" on first %[] spec */
                        if (table == NULL) {
                            __try {
                                table = _alloca(TABLESIZE);
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER) {
                                _resetstkoflw();
                                table = _malloc_crt(TABLESIZE);
                                if ( table == NULL)
                                    goto error_return;
                                malloc_flag = 1;
                            }
                        }

                        memset(table, 0, TABLESIZE);

#ifdef ALLOW_RANGE

                        if (LEFT_BRACKET == comchr)
                            if (_T(']') == *scanptr) {
                                prevchar = _T(']');
                                ++scanptr;

                                table[ _T(']') >> 3] = 1 << (_T(']') & 7);

                            }

                        while (_T(']') != *scanptr) {

                            rngch = *scanptr++;

                            if (_T('-') != rngch ||
                                 !prevchar ||           /* first char */
                                 _T(']') == *scanptr) /* last char */

                                table[(prevchar = rngch) >> 3] |= 1 << (rngch & 7);

                            else {  /* handle a-z type set */

                                rngch = *scanptr++; /* get end of range */

                                if (prevchar < rngch)  /* %[a-z] */
                                    last = rngch;
                                else {              /* %[z-a] */
                                    last = prevchar;
                                    prevchar = rngch;
                                }
                                for (rngch = prevchar; rngch <= last; ++rngch)
                                    table[rngch >> 3] |= 1 << (rngch & 7);

                                prevchar = 0;

                            }
                        }


#else
                        if (LEFT_BRACKET == comchr)
                            if (_T(']') == *scanptr) {
                                ++scanptr;
                                table[(prevchar = _T(']')) >> 3] |= 1 << (_T(']') & 7);
                            }

                        while (_T(']') != *scanptr) {
                            table[scanptr >> 3] |= 1 << (scanptr & 7);
                            ++scanptr;
                        }
                        /* code under !ALLOW_RANGE is probably never compiled */
                        /* and has probably never been tested */
#endif
                        if (!*scanptr)
                            goto error_return;      /* trunc'd format string */

                        /* scanset completed.  Now read string */

                        if (LEFT_BRACKET == comchr)
                            format = scanptr;

scanit:
                        start = pointer;

                        /*
                         * execute the format directive. that is, scan input
                         * characters until the directive is fulfilled, eof
                         * is reached, or a non-matching character is
                         * encountered.
                         *
                         * it is important not to get the next character
                         * unless that character needs to be tested! other-
                         * wise, reads from line-buffered devices (e.g.,
                         * scanf()) would require an extra, spurious, newline
                         * if the first newline completes the current format
                         * directive.
                         */
                        UN_INC(ch);

                        while ( !widthset || width-- ) {

                            ch = INC();
                            if (
#ifndef CPRFLAG
#ifndef _UNICODE
                                 (EOF != ch) &&
#else
                                 (WEOF != ch) &&
#endif /* _UNICODE */
#endif
                                   // char conditions
                                 ( ( comchr == _T('c')) ||
                                   // string conditions !isspace()
                                   ( ( comchr == _T('s') &&
                                       (!(ch >= _T('\t') && ch <= _T('\r')) && 
                                       ch != _T(' ')))) ||
                                   // BRACKET conditions
                                   ( (comchr == LEFT_BRACKET) &&
                                     ((table[ch >> 3] ^ reject) & (1 << (ch & 7)))
                                     )
                                   )
                                )
                            {
                                if (!suppress) {
#ifndef _UNICODE
                                    if (fl_wchar_arg) {
                                        char temp[2];
                                        temp[0] = (char) ch;
                                        if (isleadbyte(ch))
                                            temp[1] = (char) INC();
                                        mbtowc(&wctemp, temp, MB_CUR_MAX);
                                        *(wchar_t UNALIGNED *)pointer =
                                          wctemp;
                                        /* do nothing if mbtowc fails */
                                        pointer = (wchar_t *)pointer + 1;
                                    } else
#else
                                    if (fl_wchar_arg) {
                                        *(wchar_t UNALIGNED *)pointer = ch;
                                        pointer = (wchar_t *)pointer + 1;
                                    } else
#endif
                                    {
#ifndef _UNICODE
                                    *(char *)pointer = (char)ch;
                                    pointer = (char *)pointer + 1;
#else
                                    int temp;
                                    /* convert wide to multibyte */
                                    temp = wctomb((char *)pointer, ch);
                                    /* do nothing if wctomb fails */
                                    pointer = (char *)pointer + temp;
#endif
                                    }
                                } /* suppress */
                                else {
                                    /* just indicate a match */
                                    start = (_TCHAR *)start + 1;
                                }
                            }
                            else  {
                                UN_INC(ch);
                                break;
                            }
                        }

                        /* make sure something has been matched and, if
                           assignment is not suppressed, null-terminate
                           output string if comchr != c */

                        if (start != pointer) {
                            if (!suppress) {
                                ++count;
                                if ('c' != comchr) /* null-terminate strings */
                                    if (fl_wchar_arg)
                                        *(wchar_t UNALIGNED *)pointer = L'\0';
                                    else
                                    *(char *)pointer = '\0';
                            } else /*NULL*/;
                        }
                        else
                            goto error_return;

                        break;

                    case _T('i') :      /* could be d, o, or x */

                        comchr = _T('d'); /* use as default */

                    case _T('x'):

                        if (_T('-') == ch) {
                            ++negative;

                            goto x_incwidth;

                        } else if (_T('+') == ch) {
x_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

                        if (_T('0') == ch) {

                            if (_T('x') == (_TCHAR)(ch = INC()) || _T('X') == (_TCHAR)ch) {
                                ch = INC();
                                if (widthset) {
                                    width -= 2;
                                    if (width < 1)
                                        ++done_flag;
                                }
                                comchr = _T('x');
                            } else {
                                ++started;
                                if (_T('x') != comchr) {
                                    if (widthset && !--width)
                                        ++done_flag;
                                    comchr = _T('o');
                                }
                                else {
                                    /* scanning a hex number that starts */
                                    /* with a 0. push back the character */
                                    /* currently in ch and restore the 0 */
                                    UN_INC(ch);
                                    ch = _T('0');
                                }
                            }
                        }
                        goto getnum;

                        /* NOTREACHED */

                    case _T('p') :
                        /* force %hp to be treated as %p */
                        longone = 1;
#ifdef  _WIN64
                        /* force %p to be 64 bit in WIN64 */
                        ++integer64;
                        num64 = 0;
#endif
                    case _T('o') :
                    case _T('u') :
                    case _T('d') :

                        if (_T('-') == ch) {
                            ++negative;

                            goto d_incwidth;

                        } else if (_T('+') == ch) {
d_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

getnum:
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        if ( integer64 ) {

                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        num64 <<= 4;
                                        ch = HEXTODEC(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                                num64 <<= 3;
                                        else {
                                                ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        num64 = MUL10(num64);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    num64 += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                num64 = (unsigned __int64 )(-(__int64)num64);
                        }
                        else {
#endif
                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        number = (number << 4);
                                        ch = HEXTODEC(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                            number = (number << 3);
                                        else {
                                            ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        number = MUL10(number);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    number += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC();
                                } else
                                    UN_INC(ch);

                            } /* end of WHILE loop */

                            if (negative)
                                number = (unsigned long)(-(long)number);
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                        }
#endif
                        if (_T('F')==comchr) /* expected ':' in long pointer */
                            started = 0;

                        if (started)
                            if (!suppress) {

                                ++count;
assign_num:
#if _INTEGRAL_MAX_BITS >= 64    /*IFSTRIP=IGN*/
                                if ( integer64 )
                                    *(__int64 UNALIGNED *)pointer = (unsigned __int64)num64;
                                else
#endif
                                if (longone)
                                    *(long UNALIGNED *)pointer = (unsigned long)number;
                                else
                                    *(short UNALIGNED *)pointer = (unsigned short)number;

                            } else /*NULL*/;
                        else
                            goto error_return;

                        break;

                    case _T('n') :      /* char count, don't inc return value */
                        number = charcount;
                        if(!suppress)
                            goto assign_num; /* found in number code above */
                        break;


                    case _T('e') :
                 /* case _T('E') : */
                    case _T('f') :
                    case _T('g') : /* scan a float */
                 /* case _T('G') : */

#ifndef _UNICODE
                        scanptr = floatstring;

                        if (_T('-') == ch) {
                            *scanptr++ = _T('-');
                            goto f_incwidth;

                        } else if (_T('+') == ch) {
f_incwidth:
                            --width;
                            ch = INC();
                        }

                        if (!widthset || width > CVTBUFSIZE)              /* must watch width */
                            width = CVTBUFSIZE;


                        /* now get integral part */

                        while (_ISDIGIT(ch) && width--) {
                            ++started;
                            *scanptr++ = (char)ch;
                            ch = INC();
                        }

                        /* now check for decimal */

                        if (*___decimal_point == (char)ch && width--) {
                            ch = INC();
                            *scanptr++ = *___decimal_point;

                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *scanptr++ = (char)ch;
                                ch = INC();
                            }
                        }

                        /* now check for exponent */

                        if (started && (_T('e') == ch || _T('E') == ch) && width--) {
                            *scanptr++ = 'e';

                            if (_T('-') == (ch = INC())) {

                                *scanptr++ = '-';
                                goto f_incwidth2;

                            } else if (_T('+') == ch) {
f_incwidth2:
                                if (!width--)
                                    ++width;
                                else
                                    ch = INC();
                            }


                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *scanptr++ = (char)ch;
                                ch = INC();
                            }

                        }

                        UN_INC(ch);

                        if (started)
                            if (!suppress) {
                                ++count;
                                *scanptr = '\0';
                                _fassign( longone-1, pointer , floatstring);
                            } else /*NULL */;
                        else
                            goto error_return;

#else /* _UNICODE */
                        wptr = floatstring;

                        if (L'-' == ch) {
                            *wptr++ = L'-';
                            goto f_incwidthw;

                        } else if (L'+' == ch) {
f_incwidthw:
                            --width;
                            ch = INC();
                        }

                        if (!widthset || width > CVTBUFSIZE)
                            width = CVTBUFSIZE;


                        /* now get integral part */

                        while (_ISDIGIT(ch) && width--) {
                            ++started;
                            *wptr++ = ch;
                            ch = INC();
                        }

                        /* now check for decimal */

                        /* convert decimal point to wide-char */
                        /* assume result is single wide-char */
                        mbtowc (&wdecimal, ___decimal_point, MB_CUR_MAX);

                        if (wdecimal == ch && width--) {
                            ch = INC();
                            *wptr++ = wdecimal;

                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *wptr++ = ch;
                                ch = INC();
                            }
                        }

                        /* now check for exponent */

                        if (started && (L'e' == ch || L'E' == ch) && width--) {
                            *wptr++ = L'e';

                            if (L'-' == (ch = INC())) {

                                *wptr++ = L'-';
                                goto f_incwidth2w;

                            } else if (L'+' == ch) {
f_incwidth2w:
                                if (!width--)
                                    ++width;
                                else
                                    ch = INC();
                            }


                            while (_ISDIGIT(ch) && width--) {
                                ++started;
                                *wptr++ = ch;
                                ch = INC();
                            }

                        }

                        UN_INC(ch);

                        if (started)
                            if (!suppress) {
                                ++count;
                                *wptr = '\0';
                                {
                                /* convert floatstring to char string */
                                /* and do the conversion */
                                size_t cfslength;
                                char *cfloatstring;
                                cfslength =(size_t)(wptr-floatstring+1)*sizeof(wchar_t);
                                if ((cfloatstring = (char *)_malloc_crt (cfslength)) == NULL)
                                    goto error_return;
                                wcstombs (cfloatstring, floatstring, cfslength);
                                _fassign( longone-1, pointer , cfloatstring);
                                _free_crt (cfloatstring);
                                }
                            } else /*NULL */;
                        else
                            goto error_return;

#endif /* _UNICODE */
                        break;


                    default:    /* either found '%' or something else */

                        if ((int)*format != (int)ch) {
                            UN_INC(ch);
                            goto error_return;
                            }
                        else
                            match--; /* % found, compensate for inc below */

                        if (!suppress)
                            arglist = arglistsave;

                } /* SWITCH */

                match++;        /* matched a format field - set flag */

            } /* WHILE (width) */

            else {  /* zero-width field in format string */
                UN_INC(ch);  /* check for input error */
                goto error_return;
            }

            ++format;  /* skip to next char */

        } else  /*  ('%' != *format) */
            {

            if ((int)*format++ != (int)(ch = INC()))
                {
                UN_INC(ch);
                goto error_return;
                }
#ifndef _UNICODE
            if (isleadbyte(ch))
                {
                int ch2;
                if ((int)*format++ != (ch2=INC()))
                    {
                    UN_INC(ch2);
                    UN_INC(ch);
                    goto error_return;
                    }

                    --charcount; /* only count as one character read */
                }
#endif
            }

#ifndef CPRFLAG
        if ( (EOF == ch) && ((*format != '%') || (*(format + 1) != 'n')) )
            break;
#endif

    }  /* WHILE (*format) */

error_return:
    if (malloc_flag == 1)
        _free_crt(table);

#ifndef CPRFLAG
    if (EOF == ch)
        /* If any fields were matched or assigned, return count */
        return ( (count || match) ? count : EOF);
    else
#endif
        return count;

}

/* _hextodec() returns a value of 0-15 and expects a char 0-9, a-f, A-F */
/* _inc() is the one place where we put the actual getc code. */
/* _whiteout() returns the first non-blank character, as defined by isspace() */

#ifndef _UNICODE
static int __cdecl _hextodec (
    int chr
    )
{
    return _ISDIGIT(chr) ? chr : (chr & ~(_T('a') - _T('A'))) - _T('A') + 10 + _T('0');
}
#else
static _TCHAR __cdecl _hextodec (
    _TCHAR chr
    )
{
    if (_ISDIGIT(chr))
        return chr;
    if (_istlower(chr))
        return (_TCHAR)(chr - _T('a') + 10 + _T('0'));
    else
        return (_TCHAR)(chr - _T('A') + 10 + _T('0'));
}
#endif


#ifdef CPRFLAG

#ifndef _UNICODE
static int __cdecl _inc (
    void
    )
{
    return(_getche_lk());
}

static void __cdecl _un_inc (
    int chr
    )
{
    if (EOF != chr)
        _ungetch_lk(chr);
}

static int __cdecl _whiteout (
    REG1 int *counter
    )
{
    REG2 int ch;

    while((_istspace)(ch = (++*counter, _inc())));
    return ch;
}
#else /* _UNICODE */
static wchar_t __cdecl _inc (
    void
    )
{
    return(_getwche_lk());
}

static void __cdecl _un_inc (
    wchar_t chr
    )
{
    if (WEOF != chr)
        _ungetwch_lk(chr);
}

static wchar_t __cdecl _whiteout (
    REG1 int *counter
    )
{
    REG2 wchar_t ch;

    while((iswspace)(ch = (++*counter, _inc())));
    return ch;
}
#endif

#else /* CPRFLAG */

#ifdef _UNICODE
/*
 * Manipulate wide-chars in a file.
 * A wide-char is hard-coded to be two chars for efficiency.
 */

static wchar_t __cdecl _inc (
    REG1 FILE *fileptr
    )
{
    return(_getwc_lk(fileptr));
}

static void __cdecl _un_inc (
    wchar_t chr,
    FILE *fileptr
    )
{
    if (WEOF != chr)
        _ungetwc_lk(chr, fileptr);
}

static wchar_t __cdecl _whiteout (
    REG1 int *counter,
    REG3 FILE *fileptr
    )
{
    REG2 wchar_t ch;

    while((iswspace)(ch = (++*counter, _inc(fileptr))));
    return ch;
}

#else /* _UNICODE */

static int __cdecl _inc (
    REG1 FILE *fileptr
    )
{
    return(_getc_lk(fileptr));
}

static void __cdecl _un_inc (
    int chr,
    FILE *fileptr
    )
{
    if (EOF != chr)
        _ungetc_lk(chr, fileptr);
}

static int __cdecl _whiteout (
    REG1 int *counter,
    REG3 FILE *fileptr
    )
{
    REG2 int ch;

    while((_istspace)(ch = (++*counter, _inc(fileptr))));
    return ch;
}

#endif /* _UNICODE */
#endif /* CPRFLAG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\ncommode.c ===
/***
*ncommode.c - set global file commit mode flag to nocommit
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to nocommit.  This is the default.
*
*Revision History:
*       07-11-90  SBM   Module created, based on asm version.
*       04-05-94  GJF   Added conditional so this definition doesn't make it
*                       into the msvcrt*.dll for Win32s.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>

/* set default file commit mode to nocommit */
int _commode = 0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\printf.c ===
/***
*printf.c - print formatted
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines printf() - print formatted data
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made printf conform to ANSI prototype and use the
*                       va_ macros; (2) removed SS_NE_DS conditionals.
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       char *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl printf (
        const char *format,
        ...
        )
/*
 * stdout 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

        retval = _output(stdout,format,arglist);

        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\putws.c ===
/***
*putws.c - put a string to stdout (wchar_t version)
*
*	Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _putws() - put a string to stdout
*
*Revision History:
*	01-31-94  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "puts.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\putw.c ===
/***
*putw.c - put a binary int to output stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _putw() - puts a binary int to an output stream
*
*Revision History:
*       09-02-83  RN    initial version
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-13-88  JCR   Removed unnecessary calls to mthread fileno/feof/ferror
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _putw(word, stream) - write a binary int to an output stream
*
*Purpose:
*       Writes sizeof(int) bytes to the output stream, high byte first.
*       This routine should be machine independent.
*
*Entry:
*       int word - integer to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the word put to the stream
*       returns EOF if error, but this is a legit int value, so should
*       test with feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putw (
        int word,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG3 int bytecount = sizeof(int);
        REG2 char *byteptr = (char *)&word;
        int retval;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        while (bytecount--)
        {
            _putc_lk(*byteptr,stream);
            ++byteptr;
        }
        retval = (ferror(stream) ? EOF : word);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\popen.c ===
/***
*popen.c - initiate a pipe and a child command
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _popen() and _pclose().
*
*Revision History:
*       01-06-89  GJF   Initial version (I plead temporary insanity).
*       01-09-89  GJF   Fixed several bugs.
*       01-10-89  GJF   Implemented several improvements from Trapper.
*       01-12-89  GJF   Added underscores to function names. Also, in _pclose,
*                       pstream must be close before the cwait call if it is
*                       attached to the write handle of the pipe (otherwise,
*                       may get a deadlock).
*       01-13-89  GJF   Added multi-thread/dll support.
*       02-09-89  GJF   Prevent child process from inheriting unwanted handles.
*                       Also, always close pstream before doing the cwait.
*       05-10-89  GJF   Ported to 386 (OS/2 2.0)
*       08-14-89  GJF   Use DOSCALLS.H for API prototypes, fixed _rotl call
*                       in _pclose (rotate 24 bits for 386!), re-tested.
*       11-16-89  GJF   Changed DOS32SETFILEHSTATE to DOS32SETFHSTATE
*       11-20-89  GJF   Added const attribute to types of _popen()'s args.
*                       Also, fixed copyright.
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Made ibtab() and setinherit() _CALLTYPE4.
*       07-25-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variables), removed '32' from API names
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       10-03-90  GJF   New-style function declarators.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-18-91  GJF   ANSI naming.
*       02-25-91  SRW   Renamed _get_free_osfhnd to be _alloc_osfhnd [_WIN32_]
*       09-29-91  GJF   Picked up NT implementation (_WIN32_).
*       04-06-92  SRW   Fixed to not rely on setinherit function (_WIN32_).
*       04-28-92  DJM   ifndef for POSIX
*       05-06-92  GJF   Set _osfile[stddup] so that _get_osfhandle knows it's
*                       open (bug found by Markl).
*       05-15-92  GJF   Fixed regression Markl found - _close(stddup) to ensure
*                       that _osfile[] entry is cleared.
*       01-07-93  GJF   Substantially revised: purged Cruiser support, removed
*                       needlessly repeated API calls, closed down a pipe
*                       handle accidently left open at end of _popen, removed
*                       reduntant CloseHandle call from _pclose, tried to clean
*                       up the format and reduce the number of silly casts,
*                       and added or revised many comments.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-10-93  GJF   Removed redundant close of child process handle in
*                       _pclose().
*       12-07-93  CFW   Wide char enable.
*       07-26-94  CFW   Bug fix #14666, make data global so _wpopen sees it.
*       01-10-95  CFW   Debug CRT allocs.
*       01-16-95  SKS   Assume command.com for Win95, but cmd.exe for Win. NT.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       06-12-95  GJF   Replaced _osfile[] and _osfhnd[] with _osfile() and
*                       _osfhnd() (macros referencing fields in the ioinfo
*                       struct).
*       02-17-98  GJF   Changes for Win64:removed so long casts
*       02-25-98  GJF   Exception-safe locking.
*       01-19-00  GB    Made popen 100% multithreaded.
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*       02-19-01  GB    Added check for return value of malloc.
*
*******************************************************************************/

#ifndef _XBSTRICT

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <process.h>
#include <io.h>
#include <fcntl.h>
#include <internal.h>
#include <errno.h>
#include <msdos.h>
#include <mtdll.h>
#include <oscalls.h>
#include <tchar.h>
#include <dbgint.h>

/* size for pipe buffer
 */
#define PSIZE     1024

#define STDIN     0
#define STDOUT    1

#define SLASH _T("\\")
#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')
#define DELIMITER _T(";")



/* definitions for table of stream pointer - process handle pairs. the table
 * is created, maintained and accessed by the idtab function. _popen and
 * _pclose gain access to table entries only by calling idtab. Note that the
 * table is expanded as necessary (by idtab) and free table entries are reused
 * (an entry is free if its stream field is NULL), but the table is never
 * contracted.
 */

typedef struct {
        FILE *stream;
        intptr_t prochnd;
} IDpair;

/* number of entries in idpairs table
 */
#ifndef _UNICODE
unsigned __idtabsiz = 0;
#else
extern unsigned __idtabsiz;
#endif

/* pointer to first table entry
 */
#ifndef _UNICODE
IDpair *__idpairs = NULL;
#else
extern IDpair *__idpairs;
#endif

/* function to find specified table entries. also, creates and maintains
 * the table.
 */
static IDpair * __cdecl idtab(FILE *);


/***
*FILE *_popen(cmdstring,type) - initiate a pipe and a child command
*
*Purpose:
*       Creates a pipe and asynchronously executes a child copy of the command
*       processor with cmdstring (see system()). If the type string contains
*       an 'r', the calling process can read child command's standard output
*       via the returned stream. If the type string contains a 'w', the calling
*       process can write to the child command's standard input via the
*       returned stream.
*
*Entry:
*       _TSCHAR *cmdstring - command to be executed
*       _TSCHAR *type   - string of the form "r|w[b|t]", determines the mode
*                         of the returned stream (i.e., read-only vs write-only,
*                         binary vs text mode)
*
*Exit:
*       If successful, returns a stream associated with one end of the created
*       pipe (the other end of the pipe is associated with either the child
*       command's standard input or standard output).
*
*       If an error occurs, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tpopen (
        const _TSCHAR *cmdstring,
        const _TSCHAR *type
        )
{
#ifndef _XBOX

        int phdls[2];             /* I/O handles for pipe */
        int ph_open[2];           /* flags, set if correspond phdls is open */
        int i1;                   /* index into phdls[] */
        int i2;                   /* index into phdls[] */

        int tm = 0;               /* flag indicating text or binary mode */

        int stdhdl;               /* either STDIN or STDOUT */

        HANDLE newhnd;            /* ...in calls to DuplicateHandle API */

        FILE *pstream = NULL;     /* stream to be associated with pipe */

        HANDLE prochnd;           /* handle for current process */

        _TSCHAR *cmdexe;          /* pathname for the command processor */
        intptr_t childhnd;        /* handle for child process (cmd.exe) */

        IDpair *locidpair;        /* pointer to IDpair table entry */
        _TSCHAR *buf = NULL, *pfin, *env;
        _TSCHAR *CommandLine;

        /* Info for spawning the child. */
        STARTUPINFO StartupInfo;  /* Info for spawning a child */
        BOOL childstatus = 0;
        PROCESS_INFORMATION ProcessInfo; /* child process information */

#ifdef  _MT
        int fh_lock_held = 0;
        int popen_lock_held = 0;
#endif

        /* first check for errors in the arguments
         */
        if ( (cmdstring == NULL) || (type == NULL) || ((*type != 'w') &&
             (*type != _T('r'))) )
                goto error1;

        /* do the _pipe(). note that neither of the resulting handles will
         * be inheritable.
         */

        if ( *(type + 1) == _T('t') )
                tm = _O_TEXT;
        else if ( *(type + 1) == _T('b') )
                tm = _O_BINARY;

        tm |= _O_NOINHERIT;

        if ( _pipe( phdls, PSIZE, tm ) == -1 )
                goto error1;

        /* test *type and set stdhdl, i1 and i2 accordingly.
         */
        if ( *type == _T('w') ) {
                stdhdl = STDIN;
                i1 = 0;
                i2 = 1;
        }
        else {
                stdhdl = STDOUT;
                i1 = 1;
                i2 = 0;
        }

#ifdef  _MT
        /* ASSERT LOCK FOR IDPAIRS HERE!!!!
         */
        if ( !_mtinitlocknum( _POPEN_LOCK )) {
            _close( phdls[0] );
            _close( phdls[1] );
            return NULL;
        }
        _mlock( _POPEN_LOCK );
        __try
        {
#endif

        /* set flags to indicate pipe handles are open. note, these are only
         * used for error recovery.
         */
        ph_open[ 0 ] = ph_open[ 1 ] = 1;


        /* get the process handle, it will be needed in some API calls
         */
        prochnd = GetCurrentProcess();



        if ( !DuplicateHandle( prochnd,
                               (HANDLE)_osfhnd( phdls[i1] ),
                               prochnd,
                               &newhnd,
                               0L,
                               TRUE,                    /* inheritable */
                               DUPLICATE_SAME_ACCESS )
        ) {
                goto error2;
        }
        (void)_close( phdls[i1] );
        ph_open[ i1 ] = 0;

        /* associate a stream with phdls[i2]. note that if there are no
         * errors, pstream is the return value to the caller.
         */
        if ( (pstream = _tfdopen( phdls[i2], type )) == NULL )
                goto error2;

        /* next, set locidpair to a free entry in the idpairs table.
         */
        if ( (locidpair = idtab( NULL )) == NULL )
                goto error3;


        /* Find what to use. command.com or cmd.exe */
        if ( ((cmdexe = _tgetenv(_T("COMSPEC"))) == NULL &&
              ((errno == ENOENT) || (errno == EACCES))) )
            cmdexe = ( _osver & 0x8000 ) ? _T("command.com") : _T("cmd.exe");

        /*
         * Initialise the variable for passing to CreateProcess
         */

        memset(&StartupInfo, 0, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        /* Used by os for duplicating the Handles. */
        
        StartupInfo.dwFlags = STARTF_USESTDHANDLES;
        StartupInfo.hStdInput = stdhdl == STDIN ? (HANDLE) newhnd
                                                : (HANDLE) _osfhnd(0);
        StartupInfo.hStdOutput = stdhdl == STDOUT ? (HANDLE) newhnd
                                                  : (HANDLE) _osfhnd(1);
        StartupInfo.hStdError = (HANDLE) _osfhnd(2);


        if ((CommandLine = _malloc_crt( (_tcslen(cmdexe) + _tcslen(_T(" /c ")) + (_tcslen(cmdstring)) +1) * sizeof(_TSCHAR))) == NULL)
            goto error3;
        _tcscpy(CommandLine, cmdexe);
        _tcscat(CommandLine, _T(" /c "));
        _tcscat(CommandLine, cmdstring);


        /* Check if cmdexe can be accessed. If yes CreateProcess else try
         * Searching Path.
         */
        if (_taccess(cmdexe, 0) != -1) {
            childstatus = CreateProcess( (LPTSTR) cmdexe,
                                         (LPTSTR) CommandLine,
                                         NULL,
                                         NULL,
                                         TRUE,
                                         0,
                                         NULL,
                                         NULL,
                                         &StartupInfo,
                                         &ProcessInfo
                                         );
        }
        else {
            env = _tgetenv(_T("PATH"));
            if ((buf = _malloc_crt(_MAX_PATH * sizeof(_TSCHAR))) == NULL)
            {
                _free_crt(CommandLine);
                goto error3;
            }
#ifdef  WPRFLAG
            while ( (env = _wgetpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#else
            while ( (env = _getpath(env, buf, _MAX_PATH -1)) && (*buf) ) {
#endif
                pfin = buf + _tcslen(buf) -1;
                
#ifdef  _MBCS
                if (*pfin == SLASHCHAR) {
                    if (pfin != _mbsrchr(buf, SLASHCHAR))
                        strcat(buf, SLASH);
                }
                else if (*pfin != XSLASHCHAR)
                    strcat(buf, SLASH);
                
#else   /* _MBCS */
                if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                    _tcscat(buf, SLASH);
#endif
                /* check that the final path will be of legal size. if so,
                 * build it. otherwise, return to the caller (return value
                 * and errno rename set from initial call to _spawnve()).
                 */
                if ( (_tcslen(buf) + _tcslen(cmdexe)) < _MAX_PATH )
                    _tcscat(buf, cmdexe);
                else
                    break;
            
                /* Check if buf can be accessed. If yes CreateProcess else try
                 * again.
                 */
                if (_taccess(buf, 0) != -1) {
                    childstatus = CreateProcess( (LPTSTR) buf,
                                                 CommandLine,
                                                 NULL,
                                                 NULL,
                                                 TRUE,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 &StartupInfo,
                                                 &ProcessInfo
                                                 );
                    break;
                }
            }
            _free_crt(buf);
        }
        _free_crt(CommandLine);
        CloseHandle((HANDLE)newhnd);

        /* check if the CreateProcess was sucessful.
         */
        if ( childstatus)
            childhnd = (intptr_t)ProcessInfo.hProcess;
        else
            goto error4;
        locidpair->prochnd = childhnd;
        locidpair->stream = pstream;

        /* success, return the stream to the caller
         */
        goto done;

        /**
         * error handling code. all detected errors end up here, entering
         * via a goto one of the labels. note that the logic is currently
         * a straight fall-thru scheme (e.g., if entered at error4, the
         * code for error4, error3,...,error1 is all executed).
         **********************************************************************/

error4:         /* make sure locidpair is reusable
                 */
                locidpair->stream = NULL;

error3:         /* close pstream (also, clear ph_open[i2] since the stream
                 * close will also close the pipe handle)
                 */
                (void)fclose( pstream );
                ph_open[ i2 ] = 0;
                pstream = NULL;

error2:         /* close handles on pipe (if they are still open)
                 */

                if ( ph_open[i1] )
                        _close( phdls[i1] );
                if ( ph_open[i2] )
                        _close( phdls[i2] );
done:

#ifdef  _MT
        ;}
        __finally {
            _munlock(_POPEN_LOCK);
        }
#endif

                
error1:
        return pstream;
#else // XBOX
    RIP("popen() not supported on Xbox");
    return NULL;
#endif // XBOX
}

#ifndef _UNICODE

/***
*int _pclose(pstream) - wait on a child command and close the stream on the
*   associated pipe
*
*Purpose:
*       Closes pstream then waits on the associated child command. The
*       argument, pstream, must be the return value from a previous call to
*       _popen. _pclose first looks up the process handle of child command
*       started by that _popen and does a cwait on it. Then, it closes pstream
*       and returns the exit status of the child command to the caller.
*
*Entry:
*       FILE *pstream - file stream returned by a previous call to _popen
*
*Exit:
*       If successful, _pclose returns the exit status of the child command.
*       The format of the return value is that same as for cwait, except that
*       the low order and high order bytes are swapped.
*
*       If an error occurs, -1 is returned.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _pclose (
        FILE *pstream
        )
{
        IDpair *locidpair;        /* pointer to entry in idpairs table */
        int termstat;             /* termination status word */
        int retval = -1;          /* return value (to caller) */

#ifdef  _MT
        if (!_mtinitlocknum(_POPEN_LOCK))
            return -1;
        _mlock(_POPEN_LOCK);
        __try {
#endif

        if ( (pstream == NULL) || ((locidpair = idtab(pstream)) == NULL) )
                /* invalid pstream, exit with retval == -1
                 */
                goto done;

        /* close pstream
         */
        (void)fclose(pstream);

        /* wait on the child (copy of the command processor) and all of its
         * children.
         */
        if ( (_cwait(&termstat, locidpair->prochnd, _WAIT_GRANDCHILD) != -1) ||
             (errno == EINTR) )
                retval = termstat;

        /* Mark the IDpairtable entry as free (note: prochnd was closed by the
         * preceding call to _cwait).
         */
        locidpair->stream = NULL;
        locidpair->prochnd = 0;

        /* only return path!
         */
        done:

#ifdef  _MT
        ; }
        __finally {
            _munlock(_POPEN_LOCK);
        }
#endif
        return(retval);
}

#endif /* _UNICODE */

/***
* static IDpair * idtab(FILE *pstream) - find an idpairs table entry
*
*Purpose:
*   Find an entry in the idpairs table.  This function finds the entry the
*   idpairs table entry corresponding to pstream. In the case where pstream
*   is NULL, the entry being searched for is any free entry. In this case,
*   idtab will create the idpairs table if it doesn't exist, or expand it (by
*   exactly one entry) if there are no free entries.
*
*   [MTHREAD NOTE:  This routine assumes that the caller has acquired the
*   idpairs table lock.]
*
*Entry:
*   FILE *pstream - stream corresponding to table entry to be found (if NULL
*                   then find any free table entry)
*
*Exit:
*   if successful, returns a pointer to the idpairs table entry. otherwise,
*   returns NULL.
*
*Exceptions:
*
*******************************************************************************/

static IDpair * __cdecl idtab (
        FILE *pstream
        )
{

        IDpair * pairptr;       /* ptr to entry */
        IDpair * newptr;        /* ptr to newly malloc'd memory */


        /* search the table. if table is empty, appropriate action should
         * fall out automatically.
         */
        for ( pairptr = __idpairs ; pairptr < (__idpairs+__idtabsiz) ; pairptr++ )
                if ( pairptr->stream == pstream )
                        break;

        /* if we found an entry, return it.
         */
        if ( pairptr < (__idpairs + __idtabsiz) )
                return(pairptr);

        /* did not find an entry in the table.  if pstream was NULL, then try
         * creating/expanding the table. otherwise, return NULL. note that
         * when the table is created or expanded, exactly one new entry is
         * produced. this must not be changed unless code is added to mark
         * the extra entries as being free (i.e., set their stream fields to
         * to NULL).
         */
        if ( (pstream != NULL) || ((newptr = (IDpair *)_realloc_crt((void *)__idpairs,
             (__idtabsiz + 1)*sizeof(IDpair))) == NULL) )
                /* either pstream was non-NULL or the attempt to create/expand
                 * the table failed. in either case, return a NULL to indicate
                 * failure.
                 */
                return( NULL );

        __idpairs = newptr;             /* new table ptr */
        pairptr = newptr + __idtabsiz;  /* first new entry */
        __idtabsiz++;                   /* new table size */

        return( pairptr );

}


#endif  /* _POSIX_ */

#endif // XBSTRICT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\rmtmp.c ===
/***
*rmtmp.c - remove temporary files created by tmpfile.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       09-15-83  TC    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged normal and DLL versions
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       07-30-91  GJF   Added support for termination scheme used on
*                       non-Cruiser targets [_WIN32_].
*       03-11-92  GJF   Replaced _tmpnum(stream) with stream->_tmpfname for
*                       Win32.
*       03-17-92  GJF   Got rid of definition of _tmpoff.
*       03-31-92  GJF   Merged with Stevesa's changes.
*       04-16-92  GJF   Merged with Darekm's changes.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-29-93  GJF   Define entry for termination section (used to be in
*                       i386\cinittmp.asm). Also, replaced MTHREAD with _MT
*                       and deleted old Cruiser support.
*       04-04-94  GJF   #ifdef-ed out definition _tmpoff for msvcrt*.dll, it
*                       is unnecessary. Made definitions of _tempoff and
*                       _old_pfxlen conditional on ndef DLL_FOR_WIN32S.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   Converted to walk the __piob[] table (rather than
*                       the _iob[] table).
*       03-16-95  GJF   Must be sure __piob[i]!=NULL before trying to lock it!
*       03-28-95  SKS   Fix declaration of _prmtmp (__cdecl goes BEFORE the *)
*       08-01-96  RDK   For PMac, change termination pointer data type to static.
*       03-02-98  GJF   Exception-safe locking.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       02-19-01  PML   Avoid allocating unnecessary locks in _rmtmp, part of
*                       vs7#172586.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

#pragma data_seg(".CRT$XPX")
_CRTALLOC(".CRT$XPX") static _PVFV pterm = _rmtmp;

#pragma data_seg()

/*
 * Definitions for _tmpoff, _tempoff and _old_pfxlen. These will cause this
 * module to be linked in whenever the termination code needs it.
 */
#ifndef CRTDLL
unsigned _tmpoff = 1;
#endif  /* CRTDLL */

unsigned _tempoff = 1;
unsigned _old_pfxlen = 0;


/***
*int _rmtmp() - closes and removes temp files created by tmpfile
*
*Purpose:
*       closes and deletes all open files that were created by tmpfile.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _rmtmp (
        void
        )
{
        REG2 int count = 0;
        REG1 int i;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        for ( i = 0 ; i < _nstream ; i++)

                if ( __piob[i] != NULL && inuse( (FILE *)__piob[i] )) {

#ifdef  _MT
                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);
                        __try {
                                /*
                                 * if the stream is STILL in use (it may have
                                 * been closed before the lock was asserted),
                                 * see about flushing it.
                                 */
                                if ( inuse( (FILE *)__piob[i] )) {
#endif

                        if ( ((FILE *)__piob[i])->_tmpfname != NULL )
                        {
                                _fclose_lk( __piob[i] );
                                count++;
                        }

#ifdef  _MT
                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
#endif
                }

#ifdef  _MT
        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\puts.c ===
/***
*puts.c - put a string to stdout
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines puts() and _putws() - put a string to stdout
*
*Revision History:
*       09-02-83  RN    initial version
*       08-31-84  RN    modified to use new, blazing fast fwrite
*       07-01-87  JCR   made return values conform to ANSI [MSC only]
*       09-24-87  JCR   Added 'const' to declaration [ANSI]
*       11-05-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-18-88  JCR   Error return = EOF
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       01-31-94  CFW   Unicode enable.
*       02-04-94  CFW   Use _putwchar_lk.
*       04-18-94  CFW   Get rid of those pesky warnings.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-22-95  GJF   Replaced WPRFLAG with _UNICODE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*int puts(string) - put a string to stdout with newline
*
*Purpose:
*       Write a string to stdout; don't include '\0' but append '\n'.  Uses
*       temporary buffering for efficiency on stdout if unbuffered.
*
*Entry:
*       char *string - string to output
*
*Exit:
*       Good return = 0
*       Error return = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _putts (
        const _TCHAR *string
        )
{
        int buffing;
#ifndef _UNICODE
        size_t length;
        size_t ndone;
#endif
        int retval = _TEOF; /* error */

        _ASSERTE(string != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

#ifdef  _UNICODE
        while (*string) {
            if (_putwchar_lk(*string++) == WEOF)
                goto done;
        }
        if (_putwchar_lk(L'\n') != WEOF)
            retval = 0;     /* success */
#else       
        length = strlen(string);
        ndone = _fwrite_lk(string,1,length,stdout);

        if (ndone == length) {
            _putc_lk('\n',stdout);
            retval = 0;     /* success */
        }
#endif

#ifdef  _UNICODE
done:
#endif
        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\scanf.c ===
/***
*scanf.c - read formatted data from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from stdin
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macro.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int scanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl scanf (
        const char *format,
        ...
        )
/*
 * stdin 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

        retval = (_input(stdin,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\rewind.c ===
/***
*rewind.c - rewind a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines rewind() - rewinds a stream to the beginning.
*
*
*Revision History:
*       09-02-83  RN    initial version
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL/normal versions
*       06-01-88  JCR   Clear lowio flags as well as stdio flags
*       06-14-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-09-93  GJF   Merged in NT SDK version (a fix for POSIX bug).
*                       Replaced MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-25-95  GJF   Replaced _osfile() with _osfile_safe().
*       03-02-98  GJF   Exception-safe locking.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <io.h>
#include <mtdll.h>
#ifdef  _POSIX_
#include <unistd.h>
#else
#include <msdos.h>
#endif
#include <internal.h>

/***
*void rewind(stream) - rewind a string
*
*Purpose:
*       Back up a stream to the beginning (if not terminal).  First flush it.
*       If read/write, allow next i/o operation to set mode.
*
*Entry:
*       FILE *stream - file to rewind
*
*Exit:
*       returns 0 if success
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

void __cdecl rewind (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int fd;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _POSIX_
        fd = fileno(stream);
#else
        fd = _fileno(stream);
#endif

#ifdef  _MT
        /* Lock the file */
        _lock_str(stream);
        __try {
#endif

        /* Flush the stream */
        _flush(stream);

        /* Clear errors */
        stream->_flag &= ~(_IOERR|_IOEOF);
#ifndef _POSIX_
        _osfile_safe(fd) &= ~(FEOFLAG);
#endif

        /* Set flags */
        /* [note: _flush set _cnt=0 and _ptr=_base] */
        if (stream->_flag & _IORW)
            stream->_flag &= ~(_IOREAD|_IOWRT);

        /* Position to beginning of file */
#ifdef  _POSIX_
        /* [note: posix _flush doesn't discard buffer */

        stream->_ptr = stream->_base;
        stream->_cnt = 0;
        lseek(fd,0L,0);
#else
        _lseek(fd,0L,0);
#endif

#ifdef  _MT
        }
        __finally {
            /* unlock stream */
            _unlock_str(stream);
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\setbuf.c ===
/***
*setbuf.c - give new file buffer
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines setbuf() - given a buffer to a stream or make it unbuffered
*
*Revision History:
*	09-19-83  RN	initial version
*	09-28-87  JCR	Corrected _iob2 indexing (now uses _iob_index() macro).
*	11-02-87  JCR	Re-wrote to use setvbuf()
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-27-88  PHG	Merged DLL and normal versions
*	02-15-90  GJF	Fixed copyright and indents
*	03-19-90  GJF	Replaced _LOAD_DS with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	07-23-90  SBM	Replaced <assertm.h> by <assert.h>
*	10-03-90  GJF	New-style function declarator.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	05-11-93  GJF	Added comments.
*	02-06-94  CFW	assert -> _ASSERTE.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>

/***
*void setbuf(stream, buffer) - give a buffer to a stream
*
*Purpose:
*	Allow user to assign his/her own buffer to a stream.
*		if buffer is not NULL, it must be BUFSIZ in length.
*		if buffer is NULL, stream will be unbuffered.
*
*	Since setbuf()'s functionality is a subset of setvbuf(), simply
*	call the latter routine to do the actual work.
*
*	NOTE: For compatibility reasons, setbuf() uses BUFSIZ as the
*	buffer size rather than _INTERNAL_BUFSIZ. The reason for this,
*	and for the two BUFSIZ constants, is to allow stdio to use larger
*	buffers without breaking (already) compiled code.
*
*Entry:
*	FILE *stream - stream to be buffered or unbuffered
*	char *buffer - buffer of size BUFSIZ or NULL
*
*Exit:
*	None.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl setbuf (
	FILE *stream,
	char *buffer
	)
{
	_ASSERTE(stream != NULL);

	if (buffer == NULL)
		setvbuf(stream, NULL, _IONBF, 0);
	else
		setvbuf(stream, buffer, _IOFBF, BUFSIZ);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\snscanf.c ===
/***
*snscanf.c - read formatted data from string of given length
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snscanf() - reads formatted data from string of given length
*
*Revision History:
*       09-12-00  GB    initial version
*
*******************************************************************************/
#ifndef _POSIX_
#define _SNSCANF
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\snprintf.c ===
/***
*snprintf.c - "Count" version of sprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _snprintf() flavor takes a count argument that is
*	the max number of bytes that should be written to the
*	user's buffer.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define _COUNT_ 1
#include "sprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\setvbuf.c ===
/***
*setvbuf.c - set buffer size for a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines setvbuf() - set the buffering mode and size for a stream.
*
*Revision History:
*       09-19-83  RN    initial version
*       06-26-85  TC    modified to allow user defined buffers of various sizes
*       06-24-86  DFW   kludged to fix incompatability with Xenix values of
*                       _IOFBF, _IOLBF
*       02-09-87  JCR   added "buffer=&(_iob2[fileno(stream)]._charbuf);"
*                       to handle _IONBF case
*       02-25-87  JCR   added support for default buffer and IBMC20-condition
*                       code
*       04-13-87  JCR   changed type of szie from int to size_t (unsigned int)
*                       and changed a related comparison
*       06-29-87  JCR   Took out the _OLD_IOFBF/_OLD_IOLBF kludge for MSC.
*                       Should be taken out for IBM too...
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-02-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       06-14-88  JCR   Use near pointer to reference _iob[] entries
*       08-09-88  JCR   Buffer size can't be greater than INT_MAX
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, cleanup, a little tuning
*                       and fixed copyright.
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  CFW   Change _IONBF size to 2 bytes to hold wide char.
*       06-22-93  GJF   Set _IOSETVBUF (new) to indicate user-specified
*                       buffering (in addition to setting  _IOYOURBUF or
*                       _IOMYBUF).
*       11-12-93  GJF   Return failure if size == 1 (instead of putting
*                       0 into stream->_bufsiz, preventing any i/o)
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-20-95  GJF   Merged in Mac version.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <mtdll.h>
#include <limits.h>
#include <dbgint.h>

/***
*int setvbuf(stream, buffer, type, size) - set buffering for a file
*
*Purpose:
*       Controls buffering and buffer size for the specified stream.  The
*       array pointed to by buf is used as a buffer, unless NULL, in which
*       case we'll allocate a buffer automatically. type specifies the type
*       of buffering: _IONBF = no buffer, _IOFBF = buffered, _IOLBF = same
*       as _IOFBF.
*
*Entry:
*       FILE *stream - stream to control buffer on
*       char *buffer - pointer to buffer to use (NULL means auto allocate)
*       int type     - type of buffering (_IONBF, _IOFBF or _IOLBF)
*       size_t size  - size of buffer
*
*Exit:
*       return 0 if successful
*       returns non-zero if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl setvbuf (
        FILE *str,
        char *buffer,
        int type,
        size_t size
        )
{
        REG1 FILE *stream;
        int retval=0;   /* assume good return */

        _ASSERTE(str != NULL);

        /*
         * (1) Make sure type is one of the three legal values.
         * (2) If we are buffering, make sure size is greater than 0.
         */
        if ( (type != _IONBF) && ((size < 2) || (size > INT_MAX) ||
             ((type != _IOFBF) && (type != _IOLBF))) )
                return(-1);

        /*
         * force size to be even by masking down to the nearest multiple
         * of 2
         */
        size &= (size_t)~1;

        /*
         * Init stream pointers
         */
        stream = str;

#ifdef  _MT
        /*
         * Lock the file
         */
        _lock_str(stream);
        __try {
#endif

        /*
         * Flush the current buffer and free it, if it is ours.
         */
        _flush(stream);
        _freebuf(stream);

        /*
         * Clear a bunch of bits in stream->_flag (all bits related to
         * buffering and those which used to be in stream2->_flag2). Most
         * of these should never be set when setvbuf() is called, but it
         * doesn't cost anything to be safe.
         */
        stream->_flag &= ~(_IOMYBUF | _IOYOURBUF | _IONBF |
                           _IOSETVBUF | _IOFEOF | _IOFLRTN | _IOCTRLZ);

        /*
         * CASE 1: No Buffering.
         */
        if (type & _IONBF) {
                stream->_flag |= _IONBF;
                buffer = (char *)&(stream->_charbuf);
                size = 2;
        }

        /*
         * NOTE: Cases 2 and 3 (below) cover type == _IOFBF or type == _IOLBF
         * Line buffering is treated as the same as full buffering, so the
         * _IOLBF bit in stream->_flag is never set. Finally, since _IOFBF is
         * defined to be 0, full buffering is simply assumed whenever _IONBF
         * is not set.
         */

        /*
         * CASE 2: Default Buffering -- Allocate a buffer for the user.
         */
        else if ( buffer == NULL ) {
                if ( (buffer = _malloc_crt(size)) == NULL ) {
#ifndef CRTDLL
                        /*
                         * force library pre-termination procedure (placed here
                         * because the code path should almost never be hit)
                         */
                        _cflush++;
#endif  /* CRTDLL */
                        retval = -1;
                        goto done;
                }
                stream->_flag |= _IOMYBUF | _IOSETVBUF;
        }

        /*
         * CASE 3: User Buffering -- Use the buffer supplied by the user.
         */
        else {
                stream->_flag |= _IOYOURBUF | _IOSETVBUF;
        }

        /*
         * Common return for all cases.
         */
        stream->_bufsiz = (int)size;
        stream->_ptr = stream->_base = buffer;
        stream->_cnt = 0;
done:

#ifdef  _MT
        ; }
        __finally {
                _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\setmaxf.c ===
/***
*setmaxf.c - Set the maximum number of streams
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _setmaxstdio(), a function which changes the maximum number
*       of streams (stdio-level files) which can be open simultaneously.
*
*Revision History:
*       03-08-95  GJF   Module defined (reluctantly)
*       12-28-95  GJF   Major rewrite of _setmaxstio (several bugs). Added
*                       the _getmaxstdio() function.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <malloc.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*int _setmaxstdio(maxnum) - sets the maximum number of streams to maxnum
*
*Purpose:
*       Sets the maximum number of streams which may be simultaneously open
*       to maxnum. This is done by resizing the __piob[] array and updating
*       _nstream. Note that maxnum may be either larger or smaller than the
*       current _nstream value.
*
*Entry:
*       maxnum = new maximum number of streams
*
*Exit:
*       Returns maxnum, if successful, and -1 otherwise.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _setmaxstdio (
        int maxnum
        )
{
        void **newpiob;
        int i;
        int retval;

        /* 
         * Make sure the request is reasonable.
         */
        if ( (maxnum < _IOB_ENTRIES) || (maxnum > _NHANDLE_) )
            return -1;

#ifdef  _MT
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        /*
         * Try to reallocate the __piob array.
         */
        if ( maxnum > _nstream ) {
            if ( (newpiob = _realloc_crt( __piob, maxnum * sizeof(void *) ))
                 != NULL )
            {
                /*
                 * Initialize new __piob entries to NULL
                 */
                for ( i = _nstream ; i < maxnum ; i++ ) 
                    newpiob[i] = NULL;

                retval = _nstream = maxnum;
                __piob = newpiob;
            }
            else
                retval = -1;
        }
        else if ( maxnum == _nstream )
            retval = _nstream;
        else {  /* maxnum < _nstream */
            retval = maxnum;
            /*
             * Clean up the portion of the __piob[] to be freed.
             */
            for ( i = _nstream - 1 ; i >= maxnum ; i-- ) 
                /*
                 * If __piob[i] is non-NULL, free up the _FILEX struct it
                 * points to. 
                 */
                if ( __piob[i] != NULL )
                    if ( !inuse( (FILE *)__piob[i] ) ) {
                        _free_crt( __piob[i] );
                    }
                    else {
                        /*
                         * _FILEX is still inuse! Don't free any anything and
                         * return failure to the caller.
                         */
                        retval = -1;
                        break;
                    }

            if ( retval != -1 )
                if ( (newpiob = _realloc_crt( __piob, maxnum * sizeof(void *) ))
                     != NULL ) 
                {
                    _nstream = maxnum;      /* retval already set to maxnum */
                    __piob = newpiob;
                }
                else
                    retval = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return retval;
}


/***
*int _getmaxstdio() - gets the maximum number of stdio files
*
*Purpose:
*       Returns the maximum number of simultaneously open stdio-level files.
*       This is the current value of _nstream.
*
*Entry:
*
*Exit:
*       Returns current value of _nstream.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getmaxstdio (
        void
        )
{
        return _nstream;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\sources.inc ===
MAJORCOMP=crt
MINORCOMP=stdio

TARGETNAME=stdio

!INCLUDE ..\..\crt32.inc

NTTARGETFILE1=
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\snwprint.c ===
/***
*snwprintf.c - "Count" version of swprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _snwprintf() flavor takes a count argument that is
*	the max number of wide characters that should be written to
*	the user's buffer.
*
*Revision History:
*	05-16-92   KRS	Created from snprintf.c.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define _COUNT_ 1
#include "swprintf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\snwscanf.c ===
/***
*snwscanf.c - read formatted data from string of given length
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines snwscanf() - reads formatted data from string of given length
*
*Revision History:
*       09-12-00  GB    initial version
*
*******************************************************************************/
#ifndef _POSIX_
#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif
#define _SNSCANF
#include <wchar.h>
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\swprintf.c ===
/***
*swprintf.c - print formatted to string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines swprintf() and _snwprintf() - print formatted data to string
*
*Revision History:
*       05-16-92  KRS   Created from sprintf.c
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-16-00  GB    Added _scwprintf()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int swprintf(string, format, ...) - print formatted data to string
*else
*int _snwprintf(string, cnt, format, ...) - print formatted data to string
*endif
*
*Purpose:
*       Prints formatted data to the using the format string to
*       format data and getting as many arguments as called for
*       Sets up a FILE so file i/o operations can be used, make
*       string look like a huge buffer to it, but _flsbuf will
*       refuse to flush it if it fills up.  Appends '\0' to make
*       it a true string. _output does the real work here
*
*       Allocate the 'fake' _iob[] entry statically instead of on
*       the stack so that other routines can assume that _iob[]
*       entries are in are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _snwprintf() flavor takes a count argument that is
*       the max number of wide characters that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must
*       never try to get the stream lock (i.e., there is no stream
*       lock either). (2) Also, since there is only one statically
*       allocated 'fake' iob, we must lock/unlock to prevent collisions.
*
*Entry:
*       wchar_t *string - pointer to place to put output
*ifdef _COUNT_
*       size_t count - max number of wide characters to put in buffer
*endif
*       wchar_t *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl swprintf (
        wchar_t *string,
        const wchar_t *format,
        ...
        )
#else

int __cdecl _snwprintf (
        wchar_t *string,
        size_t count,
        const wchar_t *format,
        ...
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = (char *) string;
#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)(count*sizeof(wchar_t));
#endif

        retval = _woutput(outfile,format,arglist);

        _putc_lk('\0',outfile); /* no-lock version */
        _putc_lk('\0',outfile); /* 2nd null byte for wchar_t version */

        return(retval);
}


/***
* _scwprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       wchar_t *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_
int __cdecl _scwprintf (
        const wchar_t *format,
        ...
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _woutput(outfile,format,arglist);
        return(retval);
}
#endif
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\sscanf.c ===
/***
*sscanf.c - read formatted data from string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines scanf() - reads formatted data from string
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       06-13-88  JCR   Fake _iob entry is now static so that other routines can
*                       assume _iob entries are in DGROUP.
*       06-06-89  JCR   386 mthread support -- threads share one locked iob.
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed indents.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <string.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*int sscanf(string, format, ...) - read formatted data from string
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
/***
*int snscanf(string, size, format, ...) - read formatted data from string of 
*    given length
*
*Purpose:
*       Reads formatted data from string into arguments.  _input does the real
*       work here.  Sets up a FILE so file i/o operations can be used, makes
*       string look like a huge buffer to it, but _filbuf will refuse to refill
*       it if it is exhausted.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - string to read data from
*       size_t count - length of string
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
#ifdef _SNSCANF
int __cdecl _snwscanf (
#else
int __cdecl swscanf (
#endif
#else
#ifdef _SNSCANF
int __cdecl _snscanf (
#else
int __cdecl sscanf (
#endif
#endif
        REG2 const _TCHAR *string,
#ifdef _SNSCANF
        size_t count,
#endif
        const _TCHAR *format,
        ...
        )
/*
 * 'S'tring 'SCAN', 'F'ormatted
 */
{
        va_list arglist;
        FILE str;
        REG1 FILE *infile = &str;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        infile->_flag = _IOREAD|_IOSTRG|_IOMYBUF;
        infile->_ptr = infile->_base = (char *) string;
#ifdef _SNSCANF
        infile->_cnt = (int)count*sizeof(_TCHAR);
#else
        infile->_cnt = ((int)_tcslen(string))*sizeof(_TCHAR);
#endif
#ifdef  _UNICODE
        retval = (_winput(infile,format,arglist));
#else
        retval = (_input(infile,format,arglist));
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\stream.c ===
/***
*stream.c - find a stream not in use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getstream() - find a stream not in use
*
*Revision History:
*       09-02-83  RN    initial version
*       11-01-87  JCR   Multi-thread support
*       05-24-88  PHG   Merged DLL and normal versions
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-17-89  GJF   Removed _NEAR_, fixed copyright and indenting.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       10-03-90  GJF   New-style function declarator.
*       12-31-91  GJF   Improved multi-thread lock usage [_WIN32_].
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       03-07-95  GJF   Changes to manage streams via __piob[], rather than
*                       _iob[].
*       05-12-95  CFW   Bug fix: set _tmpfname field to NULL.
*       03-02-98  GJF   Exception-safe locking.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       10-14-99  PML   Replace InitializeCriticalSection with wrapper function
*                       __crtInitCritSecAndSpinCount
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>

/***
*FILE *_getstream() - find a stream not in use
*
*Purpose:
*       Find a stream not in use and make it available to caller. Intended
*       for use inside library only
*
*Entry:
*       None. Scans __piob[]
*
*Exit:
*       Returns a pointer to a free stream, or NULL if all are in use.  A
*       stream becomes allocated if the caller decided to use it by setting
*       any r, w, r/w mode.
*
*       [Multi-thread note: If a free stream is found, it is returned in a
*       LOCKED state.  It is the caller's responsibility to unlock the stream.]
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _getstream (
        void
        )
{
        REG2 FILE *retval = NULL;
        REG1 int i;

#ifdef  _MT
        /* Get the iob[] scan lock */
        _mlock(_IOB_SCAN_LOCK);
        __try {
#endif

        /*
         * Loop through the __piob table looking for a free stream, or the
         * first NULL entry.
         */
        for ( i = 0 ; i < _nstream ; i++ ) {

            if ( __piob[i] != NULL ) {
                /*
                 * if the stream is not inuse, return it.
                 */
                if ( !inuse( (FILE *)__piob[i] ) ) {
#ifdef  _MT
		    /*
		     * Allocate the FILE lock, in case it hasn't already been
		     * allocated (only necessary for the first _IOB_ENTRIES
		     * locks, not including stdin/stdout/stderr).  Return
		     * failure if lock can't be allocated.
		     */
		    if ( i > 2 && i < _IOB_ENTRIES )
			if ( !_mtinitlocknum( _STREAM_LOCKS + i ) )
			    break;

                    _lock_str2(i, __piob[i]);

                    if ( inuse( (FILE *)__piob[i] ) ) {
                        _unlock_str2(i, __piob[i]);
                        continue;
                    }
#endif
                    retval = (FILE *)__piob[i];
                    break;
                }
            }
            else {
                /*
                 * allocate a new _FILEX, set _piob[i] to it and return a
                 * pointer to it.
                 */
                if ( (__piob[i] = _malloc_crt( sizeof(_FILEX) )) != NULL ) {

#if     defined(_MT)
                    if ( !__crtInitCritSecAndSpinCount(
                         &(((_FILEX *)__piob[i])->lock), _CRT_SPINCOUNT ))
                    {
                        /*
                         * Failed to initialize the critical section because
                         * of lack of memory, clean up and return failure.
                         */
			_free_crt( __piob[i] );
			__piob[i] = NULL;
                        break;
                    }

                    EnterCriticalSection( &(((_FILEX *)__piob[i])->lock) );
#endif
                    retval = (FILE *)__piob[i];
                }

                break;
            }
        }

        /*
         * Initialize the return stream.
         */
        if ( retval != NULL ) {
            retval->_flag = retval->_cnt = 0;
            retval->_tmpfname = retval->_ptr = retval->_base = NULL;
            retval->_file = -1;
        }

#ifdef  _MT
        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\swscanf.c ===
/***
*swscanf.c - read formatted data from wide-character string
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _swscanf() - reads formatted data from wide-character string
*
*Revision History:
*       11-21-91  ETC   Created from sscanf.c
*       05-16-92  KRS   Revised for new ISO spec.  format is wchar_t * now.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       09-12-00  GB    Merged with sscanf.c
*
*******************************************************************************/

#ifndef _POSIX_
#ifndef _UNICODE
#define _UNICODE
#endif
#ifndef UNICODE
#define UNICODE
#endif
#include <wchar.h>
#include "sscanf.c"
#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines sprintf() and _snprintf() - print formatted data to string
*
*Revision History:
*       09-02-83  RN    initial version
*       04-13-87  JCR   added const to declaration
*       06-24-87  JCR   (1) Made declaration conform to ANSI prototype and use
*                       the va_ macros; (2) removed SS_NE_DS conditionals.
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-19-90  GJF   Made calling type _CALLTYPE2, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       09-24-91  JCR   Added _snprintf()
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-10-00  GB    Added support for knowing the length of formatted
*                       string by passing NULL for input string.
*       03-16-00  GB    Added _scprintf()
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int sprintf(string, format, ...) - print formatted data to string
*else
*int _snprintf(string, cnt, format, ...) - print formatted data to string
*endif
*
*Purpose:
*       Prints formatted data to the using the format string to
*       format data and getting as many arguments as called for
*       Sets up a FILE so file i/o operations can be used, make
*       string look like a huge buffer to it, but _flsbuf will
*       refuse to flush it if it fills up.  Appends '\0' to make
*       it a true string. _output does the real work here
*
*       Allocate the 'fake' _iob[] entry statically instead of on
*       the stack so that other routines can assume that _iob[]
*       entries are in are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _snprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must
*       never try to get the stream lock (i.e., there is no stream
*       lock either). (2) Also, since there is only one statically
*       allocated 'fake' iob, we must lock/unlock to prevent collisions.
*
*Entry:
*       char *string - pointer to place to put output
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl sprintf (
        char *string,
        const char *format,
        ...
        )
#else

int __cdecl _snprintf (
        char *string,
        size_t count,
        const char *format,
        ...
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);
        _ASSERTE(string != NULL);

#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)count;
#endif
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = string;

        retval = _output(outfile,format,arglist);

        if (string != NULL)
            _putc_lk('\0',outfile); /* no-lock version */

        return(retval);
}

/***
* _scprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/


#ifndef _COUNT_
int __cdecl _scprintf (
        const char *format,
        ...
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        va_list arglist;
        REG2 int retval;

        va_start(arglist, format);

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _output(outfile,format,arglist);
        return(retval);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\tmpfile.c ===
/***
*tmpfile.c - create unique file name or file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines tmpnam() and tmpfile().
*
*Revision History:
*       ??-??-??  TC    initial version
*       04-17-86  JMB   tmpnam - brought semantics in line with System V
*                       definition as follows: 1) if tmpnam paramter is NULL,
*                       store name in static buffer (do NOT use malloc); (2)
*                       use P_tmpdir as the directory prefix to the temp file
*                       name (do NOT use current working directory)
*       05-26-87  JCR   fixed bug where tmpnam was modifying errno
*       08-10-87  JCR   Added code to support P_tmpdir with or without trailing
*                       '\'.
*       11-09-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-22-88  JCR   Added per thread static namebuf area (mthread bug fix)
*       05-27-88  PHG   Merged DLL/normal versions
*       11-14-88  GJF   _openfile() now takes a file sharing flag, also some
*                       cleanup (now specific to the 386)
*       06-06-89  JCR   386 mthread support
*       11-28-89  JCR   Added check to _tmpnam so it can't loop forever
*       02-16-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-26-90  GJF   Added #include <io.h>.
*       10-03-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       07-22-91  GJF   Multi-thread support for Win32 [_WIN32_].
*       03-17-92  GJF   Completely rewrote Win32 version.
*       03-27-92  DJM   POSIX support.
*       05-02-92  SRW   Use _O_TEMPORARY flag for tmpfile routine.
*       05-04-92  GJF   Force cinittmp.obj in for Win32.
*       08-26-92  GJF   Fixed POSIX build.
*       08-28-92  GJF   Oops, forgot about getpid...
*       11-06-92  GJF   Use '/' for POSIX, '\\' otherwise, as the path
*                       separator. Also, backed out JHavens' bug fix of 6-14,
*                       which was itself a bug (albeit a less serious one).
*       02-26-93  GJF   Put in per-thread buffers, purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Replace access() with ANSI-conforming _access()
*       04-22-93  GJF   Fixed bug in multi-thread - multiple threads calling
*                       tmpnam would get the same names. Also, went to static
*                       namebufX buffers since failing due to a failed malloc
*                       would violate ANSI.
*       04-29-93  GJF   Multi-thread bug in tmpnam() - forgot to copy the
*                       generated name to the per-thread buffer.
*       12-07-93  CFW   Wide char enable.
*       04-01-94  GJF   #ifdef-ed out __inc_tmpoff for msvcrt*.dll, it's
*                       unnecessary.
*       04-22-94  GJF   Made definitions of namebuf0 and namebuf1 conditional
*                       on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       01-18-95  GJF   Must replace _tcsdup with _malloc_crt/_tcscpy for
*                       _DEBUG build.
*       02-21-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also replaced WPRFLAG
*                       with _UNICODE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       08-08-97  GJF   Removed initialized-but-unused local variable from 
*                       tmpfile(). Also, detab-ed.
*       03-03-98  GJF   Exception-safe locking.
*       05-13-99  PML   Remove Win32s
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Set errno EMFILE when out of streams.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <errno.h>
#include <process.h>
#include <fcntl.h>
#include <io.h>
#include <mtdll.h>
#include <share.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <file2.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>
#ifdef _XBOX
#include <oscalls.h>
#endif

/*
 * Buffers used by tmpnam() and tmpfile() to build filenames.
 */
static _TSCHAR namebuf0[L_tmpnam] = { 0 };      /* used by tmpnam()  */
static _TSCHAR namebuf1[L_tmpnam] = { 0 };      /* used by tmpfile() */

/*
 * Initializing function for namebuf0 and namebuf1.
 */
#ifdef _UNICODE
static void __cdecl winit_namebuf(int);
#else
static void __cdecl init_namebuf(int);
#endif

/*
 * Generator function that produces temporary filenames
 */
#ifdef _UNICODE
static int __cdecl wgenfname(wchar_t *);
#else
static int __cdecl genfname(char *);
#endif


/***
*_TSCHAR *tmpnam(_TSCHAR *s) - generate temp file name
*
*Purpose:
*       Creates a file name that is unique in the directory specified by
*       _P_tmpdir in stdio.h.  Places file name in string passed by user or
*       in static mem if pass NULL.
*
*Entry:
*       _TSCHAR *s - ptr to place to put temp name
*
*Exit:
*       returns pointer to constructed file name (s or address of static mem)
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _ttmpnam (
        _TSCHAR *s
        )
{
        _TSCHAR *pfnam = NULL;
#ifdef  _MT
        _ptiddata ptd;

        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;

        _mlock(_TMPNAM_LOCK);

        __try {
#endif

        /*
         * Initialize namebuf0, if needed. Otherwise, call genfname() to
         * generate the next filename.
         */
        if ( *namebuf0 == 0 ) {
#ifdef _UNICODE
                winit_namebuf(0);
#else
                init_namebuf(0);
#endif
        }
#ifdef _UNICODE
        else if ( wgenfname(namebuf0) )
#else
        else if ( genfname(namebuf0) )
#endif
                goto tmpnam_err;

        /*
         * Generate a filename that doesn't already exist.
         */
        while ( _taccess(namebuf0, 0) == 0 )
#ifdef _UNICODE
                if ( wgenfname(namebuf0) )
#else
                if ( genfname(namebuf0) )
#endif
                        goto tmpnam_err;

        /*
         * Filename has successfully been generated.
         */
        if ( s == NULL )
#ifdef  _MT
        {
                /*
                 * Use a per-thread buffer to hold the generated file name.
                 * If there isn't one, and one cannot be created, just use
                 * namebuf0.
                 */
                ptd = _getptd();
#ifdef _UNICODE
                if ( (ptd->_wnamebuf0 != NULL) || ((ptd->_wnamebuf0 =
                      _malloc_crt(L_tmpnam * sizeof(wchar_t))) != NULL) )
                {
                        s = ptd->_wnamebuf0;
                        wcscpy(s, namebuf0);
                }
#else
                if ( (ptd->_namebuf0 != NULL) || ((ptd->_namebuf0 =
                      _malloc_crt(L_tmpnam)) != NULL) )
                {
                        s = ptd->_namebuf0;
                        strcpy(s, namebuf0);
                }
#endif
                else
                        s = namebuf0;
        }
#else
                s = namebuf0;
#endif
        else
                _tcscpy(s, namebuf0);

        pfnam = s;

        /*
         * All errors come here.
         */
tmpnam_err:

#ifdef  _MT
        ; }
        __finally {
                _munlock(_TMPNAM_LOCK);
        }
#endif

        return pfnam;
}

#ifndef _UNICODE

/***
*FILE *tmpfile() - create a temporary file
*
*Purpose:
*       Creates a temporary file with the file mode "w+b".  The file
*       will be automatically deleted when closed or the program terminates
*       normally.
*
*Entry:
*       None.
*
*Exit:
*       Returns stream pointer to opened file.
*       Returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl tmpfile (
        void
        )
{
        FILE *stream;
        FILE *return_stream = NULL;
        int fh;

#ifdef  _MT
        int stream_lock_held = 0;

        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;

        _mlock(_TMPNAM_LOCK);

        __try {
#endif

        /*
         * Initialize namebuf1, if needed. Otherwise, call genfname() to
         * generate the next filename.
         */
        if ( *namebuf1 == 0 ) {
                init_namebuf(1);
        }
        else if ( genfname(namebuf1) )
                goto tmpfile_err;

        /*
         * Get a free stream.
         *
         * Note: In multi-thread models, the stream obtained below is locked!
         */
        if ( (stream = _getstream()) == NULL ) {
                errno = EMFILE;
                goto tmpfile_err;
        }

#ifdef  _MT
        stream_lock_held = 1;
#endif
        /*
         * Create a temporary file.
         *
         * Note: The loop below will only create a new file. It will NOT
         * open and truncate an existing file. Either behavior is probably
         * legal under ANSI (4.9.4.3 says tmpfile "creates" the file, but
         * also says it is opened with mode "wb+"). However, the behavior
         * implemented below is compatible with prior versions of MS-C and
         * makes error checking easier.
         */
#ifdef  _POSIX_
        while ( ((fh = open(namebuf1,
                             O_CREAT | O_EXCL | O_RDWR,
                             S_IRUSR | S_IWUSR
                             ))
            == -1) && (errno == EEXIST) )
#else
        while ( ((fh = _sopen(namebuf1,
                              _O_CREAT | _O_EXCL | _O_RDWR | _O_BINARY |
                                _O_TEMPORARY,
                              _SH_DENYNO,
                              _S_IREAD | _S_IWRITE
                             ))
            == -1) && (errno == EEXIST) )
#endif
                if ( genfname(namebuf1) )
                        break;

        /*
         * Check that the loop above did indeed create a temporary
         * file.
         */
        if ( fh == -1 )
                goto tmpfile_err;

        /*
         * Initialize stream
         */
#ifdef  _DEBUG
        if ( (stream->_tmpfname = _malloc_crt( (_tcslen( namebuf1 ) + 1) *
               sizeof(_TSCHAR) )) == NULL )
#else   /* ndef _DEBUG */
        if ( (stream->_tmpfname = _tcsdup( namebuf1 )) == NULL )
#endif  /* _DEBUG */
        {
                /* close the file, then branch to error handling */
#ifdef  _POSIX_
                close(fh);
#else
                _close(fh);
#endif
                goto tmpfile_err;
        }
#ifdef  _DEBUG
        _tcscpy( stream->_tmpfname, namebuf1 );
#endif  /* _DEBUG */
        stream->_cnt = 0;
        stream->_base = stream->_ptr = NULL;
        stream->_flag = _commode | _IORW;
        stream->_file = fh;

        return_stream = stream;

        /*
         * All errors branch to the label below.
         */
tmpfile_err:

#ifdef  _MT
        ; }
        __finally {
                if ( stream_lock_held )
                        _unlock_str(stream);
                _munlock(_TMPNAM_LOCK);
        }
#endif

        return return_stream;
}

#endif /* _UNICODE */

/***
*static void init_namebuf(flag) - initializes the namebuf arrays
*
*Purpose:
*       Called once each for namebuf0 and namebuf1, to initialize
*       them.
*
*Entry:
*       int flag            - flag set to 0 if namebuf0 is to be initialized,
*                             non-zero (1) if namebuf1 is to be initialized.
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
static void __cdecl winit_namebuf(
#else
static void __cdecl init_namebuf(
#endif
        int flag
        )
{
        _TSCHAR *p, *q;

        if ( flag == 0 )
            p = namebuf0;
        else
            p = namebuf1;

        /*
         * Put in the path prefix. Make sure it ends with a slash or
         * backslash character.
         */
#ifdef _UNICODE
        wcscpy(p, _wP_tmpdir);
#else
        strcpy(p, _P_tmpdir);
#endif
        q = p + sizeof(_P_tmpdir) - 1;      /* same as p + _tcslen(p) */

#ifdef _POSIX_
        if  ( *(q - 1) != _T('/') )
                *(q++) = _T('/');
#else
        if  ( (*(q - 1) != _T('\\')) && (*(q - 1) != _T('/')) )
                *(q++) = _T('\\');
#endif

        /*
         * Append the leading character of the filename.
         */
        if ( flag )
                /* for tmpfile() */
                *(q++) = _T('t');
        else
                /* for tmpnam() */
                *(q++) = _T('s');

        /*
         * Append the process id, encoded in base 32. Note this makes
         * p back into a string again (i.e., terminated by a '\0').
         */
#ifdef _XBOX
        _ultot((unsigned long)GetCurrentThreadId(), q, 32);
#elif defined( _POSIX_)
        _ultot((unsigned long)getpid(), q, 32);
#else
        _ultot((unsigned long)_getpid(), q, 32);
#endif
        _tcscat(p, _T("."));
}


/***
*static int genfname(_TSCHAR *fname) -
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
static int __cdecl wgenfname (
#else
static int __cdecl genfname (
#endif
        _TSCHAR *fname
        )
{
        _TSCHAR *p;
        _TSCHAR pext[4];
        unsigned long extnum;

        p = _tcsrchr(fname, _T('.'));

        p++;

        if ( (extnum = _tcstoul(p, NULL, 32) + 1) >= (unsigned long)TMP_MAX )
                return -1;

        _tcscpy(p, _ultot(extnum, pext, 32));

        return 0;
}

#if     !defined(_UNICODE) && !defined(CRTDLL)

/***
*void __inc_tmpoff(void) - force external reference for _tmpoff
*
*Purpose:
*       Forces an external reference to be generate for _tmpoff, which is
*       is defined in cinittmp.obj. This has the forces cinittmp.obj to be
*       pulled in, making a call to rmtmp part of the termination.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


extern int _tmpoff;

void __inc_tmpoff(
        void
        )
{
        _tmpoff++;
}

#endif  /* _UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\test_out.c ===
/***
*test_out.c - test output.c
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains a small test suite for output.c.  Although
*       it is certainly not comprehensive, it should catch most major bugs.
*
*Revision History:
*       06-05-89  PHG   Module created
*       03-19-90  GJF   Fixed copyright.
*       10-03-90  GJF   New-style function declarator.
*       06-08-92  KRS   Updated for 32-bit sizes and wchar_t specifiers.
*       02-24-95  GJF   Appended Mac version (probably just an old version)
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

void test (
        char *shouldbe,
        char *format,
        ...
        )
{
        va_list argptr;
        char buffer[500];

        va_start(argptr, format);

        vsprintf(buffer, format, argptr);
        if (strcmp(shouldbe, buffer) != 0)
                printf("Was:       \"%s\"\nShould be: \"%s\"\n", buffer, shouldbe);
}

main()
{
        int i;
        long l;

        /* normal */
        test("Hello, world!", "Hello, world!");

        /* test %s */
        test("Hello, world!", "%s", "Hello, world!");
        test("Hello, world!", "%.20s", "Hello, world!");
        test("Hello", "%.5s", "Hello, world!");
        test("", "%.s", "Hello, world!");
        test("(null)", "%s", NULL);
        test("       Hello, world!", "%20s", "Hello, world!");
        test("Hello, world!       ", "%-20s", "Hello, world!");
        test("               Hello", "%20.5s", "Hello, world!");
        test("Hello               ", "%-20.5s", "Hello, world!");
        test("Hello", "%3.5s", "Hello, world!");
        test("Hello", "%-3.5s", "Hello, world!");
        test("Hello, world!", "%-8s", "Hello, world!");
        test("Hello, world!", "%8s", "Hello, world!");

        /* test %ws, %ls, %Zi (should be %S) */
        test("Hello, world!", "%ws", L"Hello, world!");
        test("Hello, world!", "%.20Z", L"Hello, world!");
        test("Hello", "%.5ls", L"Hello, world!");
        test("", "%.ws", L"Hello, world!");
        test("(null)", "%ls", NULL);
        test("(null)", "%ws", NULL);
        test("(null)", "%Z", NULL);
        test("       Hello, world!", "%20ls", L"Hello, world!");
        test("Hello, world!       ", "%-20ws", L"Hello, world!");
        test("               Hello", "%20.5Z", L"Hello, world!");
        test("Hello               ", "%-20.5ls", L"Hello, world!");
        test("Hello", "%3.5ws", L"Hello, world!");
        test("Hello", "%-3.5Z", L"Hello, world!");
        test("Hello, world!", "%-8ls", L"Hello, world!");
        test("Hello, world!", "%8ws", L"Hello, world!");


        /* test %wc, %lc, should also add %C */
        test("H", "%lc", L'H');
        test("    H", "%5lc", L'H');
        test("H    ", "%-5lc", L'H');
        test("H", "%wc", L'H');
        test("    H", "%5wc", L'H');
        test("H    ", "%-5wc", L'H');

        /* test %d/%u */
        test("54", "%d", 54);
        test("-42", "%i", -42);
        test("  -102", "%6d", -102);
        test("0     ", "%-6d", 0);
        test("00000", "%.5d", 0);
        test("-0345", "%.4d", -345);
        test("-345", "%.3d", -345);
        test("00345", "%.5d", 345);
        test("00345", "%05d", 345);
        test("345  ", "%-05d", 345);
        test("    -00055", "%10.5d", -55);
        test("-00055    ", "%-10.5d", -55);
        test("     ", "%5.0d", 0);
        test("12345678", "%ld", 12345678);
        test("+123", "%+d", 123);
        test("-123", "%+d", -123);
        test("+000123", "%+07d", 123);
        test(" 000123", "% 07d", 123);
        test("+123   ", "%+-7d", 123);
        test("  +0123", "%+7.4i", 123);
        test("-1", "%d", 0xFFFFFFFF);
        test("65535", "%u", 0xFFFF);

        /* test %x */
        test("DEF", "%X", 0xdef);
        test("14d   ", "%-6x", 0x14d);
        test(" 0X14D", "%#6X", 0x14d);
        test("0x00014d  ", "%#-10.6x", 0x14d);
        test("0", "%#x", 0);
        test("", "%.0x", 0);
        test("  ", "%#2.0X", 0);
        test("000000014d", "%010x", 0x14d);
        test("14d       ", "%-010x", 0x14d);
        test("0x0000014d", "%#010x", 0x14d);
        test("FFFF", "%X", 0xffff);

        /* temp: %B/%C should go away */
        test("DEF", "%B", 0xdef);
        test("14D   ", "%-6C", 0x14d);
        test(" 0X14D", "%#6B", 0x14d);
        test("0X00014D  ", "%#-10.6C", 0x14d);
        test("0", "%#B", 0);
        test("", "%.0C", 0);
        test("  ", "%#2.0B", 0);
        test("000000014D", "%010C", 0x14d);
        test("14D       ", "%-010B", 0x14d);
        test("0X0000014D", "%#010C", 0x14d);
        test("FFFF", "%B", 0xffff);

        /* test %o */
        test("703", "%o", 0703);
        test("   703", "%6o", 0703);
        test("  0703", "%#6o", 0703);
        test("0703  ", "%#-6o", 0703);
        test("000703", "%06o", 0703);
        test("00703 ", "%-#6.5o", 0703);
        test("0703  ", "%-#06o", 0703);
        test(" 00703", "%#6.5o", 0703);
        test("0", "%#.0o", 0);
        test("", "%.0o", 0);
        test("177777", "%o", 0xFFFF);

        /* test %p */
        test("000000FE", "%p", (char *)0x00fe);
        test("00003DFE  ", "%-10p", (char *)0x3dfe);
        test("    00009DF4", "%12p", (char *)0x9df4);

        /* test %n */
        test("Hello, world", "Hello, world%n", &i);
        test("12", "%i", i);
        test("This is 423 characters ", "This is %d characters %ln", 423, &l);
        test("23", "%ld", l);
        test("0x0003f", "%#.5x%n", 0x3f, &i);
        test("7", "%d", i);

        /* test multiple specifiers */
        test("24 43", "%d %d", 24, 43);
        test("24 43", "%ld %ld", 24l, 43L);
        test("00004ABC 43", "%p %d", (char *)0x4abc, 43);
        test("43", "%n%d", &i, 43);
        test("43", "%ln%d", &l, 43);

        printf("Completed all non-FP format specifiers\n");

        printf("Processing %%e\n");

        /* test %e */
        test("-4.000000e+000", "%e", -4.0);
        test("4.000000E+000", "%E", 4.0);
        test("-7E+001", "%.0E", -68.5);
        test("-7.E+001", "%#.0E", -74.5);
        test(" 6.78e+004  ", "% -12.2e", 67844.324);
        test("  +6.78e+004", "%+12.2e", 67844.324);
        test("    0.000000e+000", "%17e", 0.0);
        test("-00007.467e-001", "%015.3e", -0.74673);

        printf("Processing %%f\n");

        /* test %f */
        test("-4.000000", "%f", -4.0);
        test("4.000000", "%f", 4.0);
        test("0.400000", "%f", 0.4);
        test("-69", "%.0f", -68.7);
        test("-74.", "%#.0f", -74.3);
        test(" 67844.32   ", "% -12.2f", 67844.324);
        test("   +67844.32", "%+12.2f", 67844.324);
        test("         0.000000", "%17f", 0.0);
        test("-0000000000.747", "%015.3f", -0.74673);

        printf("Processing %%g\n");

        /* test %g */
        test("3.14159E-005", "%G", 0.000031415926535);
        test("0.000314159", "%g", 0.00031415926535);
        test("0.00314159", "%g", 0.0031415926535);
        test("0.0314159", "%g", 0.031415926535);
        test("0.314159", "%g", 0.31415926535);
        test("3.14159", "%g", 3.1415926535);
        test("31.4159", "%g", 31.415926535);
        test("314.159", "%g", 314.15926535);
        test("3141.59", "%g", 3141.5926535);
        test("31415.9", "%g", 31415.926535);
        test("314159", "%g", 314159.26535);
        test("3.14159e+006" , "%g", 3141592.6535);
        test("3", "%g", 3.0);
        test("3e+006", "%g", 3000000.0);
        test("   3.14", "%7.4g", 3.1402);
        test(" 3.14  ", "% -7.4g", 3.1402);
        test("+0023.000", "%+#09.5g", 23.0);
        test("23.", "%#.2g", 23.0);
        test("23", "%.2g", 23.0);

        /* more multiples */
        test("3.1 43", "%g %d", 3.1, 43);
        test("3.1 43", "%Lg %d", (long double)3.1, 43);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\tempnam.c ===
/***
*tempnam.c - generate unique file name
*
*       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       ??-??-??  TC    initial version
*       04-17-86  JMB   changed directory of last resort from \tmp to tmp.
*                       eliminated use of L_tmpnam (it was incoorectly defined
*                       in stdio.h and should not be used in tempnam; see
*                       System V definition of tempnam.
*       04-23-86  TC    changed last try directory from tmp to current directory
*       04-29-86  JMB   bug fix: pfxlength was being set from strlen(pfx)
*                       even if pfx was NULL.  Fixed to set pfxlength to zero
*                       if pfx is NULL, strlen(pfx) otherwise.
*       05-28-86  TC    changed stat's to access's, and optimized code a bit
*       12-01-86  JMB   added support for Kanji file names until KANJI switch
*       12-15-86  JMB   free malloced memory if (++_tmpoff == first)
*       07-15-87  JCR   Re-init _tempoff based on length of pfx (fixes infinate
*                       loop bug; also, tempnam() now uses _tempoff instead of
*                       _tmpoff (used by tmpnam()).
*       10-16-87  JCR   Fixed bug in _tempoff re-init code if pfx is NULL.
*       11-09-87  JCR   Multi-thread version
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-09-89  GJF   Propagated MT's change of 05-17-89 (Kanji)
*       02-16-90  GJF   Fixed copyright and indents
*       03-19-90  GJF   Replaced _LOAD_DS and _CALLTYPE1 and added #include
*                       <cruntime.h>.
*       03-26-90  GJF   Added #include <io.h>.
*       08-13-90  SBM   Compiles cleanly with -W3, replaced explicit register
*                       declarations by REGn references
*       10-03-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       08-19-91  JCR   Allow quotes in TMP variable path
*       08-27-91  JCR   ANSI naming
*       08-25-92  GJF   Don't build for POSIX.
*       11-30-92  KRS   Generalize KANJI support to MBCS. Port 16-bit bug fix.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       12-07-93  CFW   Wide char enable.
*       01-10-95  CFW   Debug CRT allocs.
*       01-23-95  CFW   Debug: tempnam return freed by user.
*       02-21-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s. Also replaced WPRFLAG
*                       with _UNICODE.
*       03-10-95  CFW   Made _tempnam() parameters const.
*       03-14-95  JCF   Made pfin _TSCHAR for the Mac.
*       07-30-96  GJF   Allow longer file names and changed the way we ensure 
*                       a file name is not too long. In particular, this
*                       corrects the absurdly long loop (appeared infinite to
*                       to users) which occurred when the user supplied prefix 
*                       was too long. Also, cleaned up the format a bit.
*       03-04-98  GJF   Exception-safe locking.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-00  PML   Fix double-free of qptr when _stripquote succeeds but
*                       result isn't a valid directory (vs7#5416).
*       02-20-01  PML   vs7#172586 Avoid _RT_LOCK by preallocating all locks
*                       that will be required, and returning failure back on
*                       inability to allocate a lock.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <malloc.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>
#include <dbgint.h>

#ifdef  _MBCS
#include <mbstring.h>
#endif

/* local tchar */
#ifdef  _UNICODE
#define _tP_tmpdir _wP_tmpdir
#else
#define _tP_tmpdir _P_tmpdir
#endif

#ifdef  _UNICODE
static wchar_t * _wstripquote (wchar_t *);
#else
static char * _stripquote (char *);
#endif

/***
*_TSCHAR *_tempnam(dir, prefix) - create unique file name
*
*Purpose:
*       Create a file name that is unique in the specified directory.
*       The semantics of directory specification is as follows:
*       Use the directory specified by the TMP environment variable
*       if that exists, else use the dir argument if non-NULL, else
*       use _P_tmpdir if that directory exists, else use the current
*       working directory), else return NULL.
*
*Entry:
*       _TSCHAR *dir - directory to be used for temp file if TMP env var
*                   not set
*       _TSCHAR *prefix - user provided prefix for temp file name
*
*Exit:
*       returns ptr to constructed file name if successful
*       returns NULL if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _ttempnam (
        const _TSCHAR *dir,
        const _TSCHAR *pfx
        )
{
        REG1 _TSCHAR *ptr;
        REG2 unsigned int pfxlength = 0;
        _TSCHAR *s;
        _TSCHAR *pfin;
        unsigned int first;
        unsigned int bufsz;
        _TSCHAR * qptr = NULL;  /* ptr to TMP path with quotes stripped out */

#ifdef _XBOX
        ptr = NULL;
#else
#ifdef  _MT
        if ( !_mtinitlocknum( _TMPNAM_LOCK ))
                return NULL;
#endif

        /* try TMP path */
        if ( ( ptr = _tgetenv( _T("TMP") ) ) && ( _taccess( ptr, 0 ) != -1 ) )
                dir = ptr;

        /* try stripping quotes out of TMP path */
#ifdef  _UNICODE
        else if ( (ptr != NULL) && (qptr = _wstripquote(ptr)) &&
#else
        else if ( (ptr != NULL) && (qptr = _stripquote(ptr)) &&
#endif
                  (_taccess(qptr, 0) != -1 ) )
                dir = qptr;
        else
#endif // XBOX

        /* TMP path not available, use alternatives */
        if (!( dir != NULL && ( _taccess( dir, 0 ) != -1 ) ) )
        /* do not "simplify" this depends on side effects!! */
        {
                if ( _taccess( _tP_tmpdir, 0 ) != -1 )
                    dir = _tP_tmpdir;
                else
                    dir = _T(".");
        }


        if (pfx)
                pfxlength = (unsigned)_tcslen(pfx);

        if ( ((bufsz = (unsigned)_tcslen(dir) + pfxlength + 12) > FILENAME_MAX) ||
             ((s = malloc(bufsz * sizeof(_TSCHAR))) == NULL) )
                /* the 12 above allows for a backslash, 10 char temp string and
                   a null terminator */
        {
                goto done2;
        }

        *s = _T('\0');
        _tcscat( s, dir );
        pfin = (_TSCHAR *)&(dir[ _tcslen( dir ) - 1 ]);

#ifdef  _MBCS
        if (*pfin == '\\') {
                if (pfin != _mbsrchr(dir,'\\'))
                        /* *pfin is second byte of a double-byte char */
                        strcat( s, "\\" );
        }
        else if (*pfin != '/')
                strcat( s, "\\" );
#else
        if ( ( *pfin != _T('\\') ) && ( *pfin != _T('/') ) )
        {
                _tcscat( s, _T("\\") );
        }
#endif

        if ( pfx != NULL )
        {
                _tcscat( s, pfx );
        }
        ptr = &s[_tcslen( s )];

        /*
        Re-initialize _tempoff if necessary.  If we don't re-init _tempoff, we
        can get into an infinate loop (e.g., (a) _tempoff is a big number on
        entry, (b) prefix is a long string (e.g., 8 chars) and all tempfiles
        with that prefix exist, (c) _tempoff will never equal first and we'll
        loop forever).

        [NOTE: To avoid a conflict that causes the same bug as that discussed
        above, _tempnam() uses _tempoff; tmpnam() uses _tmpoff]
        */

#ifdef  _MT
        _mlock(_TMPNAM_LOCK);   /* Lock access to _old_pfxlen and _tempoff */
        __try {
#endif

        if (_old_pfxlen < pfxlength)
                _tempoff = 1;
        _old_pfxlen = pfxlength;

        first = _tempoff;

        do {
                if ( (++_tempoff - first) > TMP_MAX ) {
                        free(s);
                        s = NULL;
                        goto done1;
                }
                /* the maximum length string returned by _ultot is 10 chars
                   (assuming 32-bit unsigned long) so there is enough room in
                   the tail of s (pointed to by ptr) for it */
                _ultot( (unsigned long)_tempoff, ptr, 10 );
        }
        while ( (_taccess( s, 0 ) == 0 ) || (errno == EACCES) );


        /* Common return */
done1:

#ifdef  _MT
        ; }
        __finally {
                _munlock(_TMPNAM_LOCK);     /* release tempnam lock */
        }
#endif

done2:
        _free_crt(qptr);            /* free temp ptr, if non-NULL */
        return(s);
}



/***
*_stripquote() - Strip quotes out of a string
*
*Purpose:
*       This routine strips quotes out of a string.  This is necessary
*       in the case where a file/path name has embedded quotes (i.e.,
*       new file system.)
*
*       For example,
*                       c:\tmp\"a b c"\d --> c:\tmp\a b d\d
*
*       NOTE:  This routine makes a copy of the string since it may be
*       passed a pointer to an environment variable that shouldn't be
*       changed.  It is up to the caller to free up the memory (if the
*       return value is non-NULL).
*
*Entry:
*       _TSCHAR * ptr = pointer to string
*
*Exit:
*       _TSCHAR * ptr = pointer to copy of string with quotes gone.
*       NULL = no quotes in string.
*
*Exceptions:
*
*******************************************************************************/

#ifdef  _UNICODE
static wchar_t * _wstripquote (
#else
static char * _stripquote (
#endif
        _TSCHAR * src
        )
{
        _TSCHAR * dst;
        _TSCHAR * ret;
        unsigned int q = 0;


        /* get a buffer for the new string */

        if ((dst = _malloc_crt((_tcslen(src)+1) * sizeof(_TSCHAR))) == NULL)
                return(NULL);

        /* copy the string stripping out the quotes */

        ret = dst;          /* save base ptr */

        while (*src) {

                if (*src == _T('\"')) {
                        src++; q++;
                }
                else
                        *dst++ =  *src++;
        }

        if (q) {
                *dst = _T('\0');        /* final nul */
                return(ret);
        }
        else {
                _free_crt(ret);
                return(NULL);
        }

}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\ungetc.c ===
/***
*ungetc.c - unget a character from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ungetc() - pushes a character back onto an input stream
*
*Revision History:
*       09-02-83  RN    initial version
*       04-16-87  JCR   added support for _IOUNGETC flag
*       08-04-87  JCR   (1) Added _IOSTRG check before setting _IOUNGETC flag.
*                       (2) Allow an ugnetc() before a read has occurred (get a
*                       buffer (ANSI).  [MSC only]
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-04-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-25-88  JCR   Allow an ungetc() before read for file opened "r+".
*       05-31-88  PHG   Merged DLL and normal versions
*       06-06-88  JCR   Optimized _iob2 references
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       04-11-89  JCR   Removed _IOUNGETC flag, fseek() no longer needs it
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-13-90  SBM   Compiles cleanly with -W3
*       10-03-90  GJF   New-style function declarators.
*       11-07-92  SRW   Dont modify buffer if stream opened by sscanf
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       04-30-93  CFW   Remove wide char support to ungetwc.c.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>

#ifdef _MT      /* multi-thread; define both ungetc and _lk_ungetc */

/***
*int ungetc(ch, stream) - put a character back onto a stream
*
*Purpose:
*       Guaranteed one char pushback on a stream as long as open for reading.
*       More than one char pushback in a row is not guaranteed, and will fail
*       if it follows an ungetc which pushed the first char in buffer. Failure
*       causes return of EOF.
*
*Entry:
*       char ch - character to push back
*       FILE *stream - stream to push character onto
*
*Exit:
*       returns ch
*       returns EOF if tried to push EOF, stream not opened for reading or
*       or if we have already ungetc'd back to beginning of buffer.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl ungetc (
        REG2 int ch,
        REG1 FILE *stream
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ungetc_lk (ch, stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*_ungetc_lk() -  Ungetc() core routine (locked version)
*
*Purpose:
*       Core ungetc() routine; assumes stream is already locked.
*
*       [See ungetc() above for more info.]
*
*Entry: [See ungetc()]
*
*Exit:  [See ungetc()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _ungetc_lk (
        REG2 int ch,
        FILE *str
        )

{

#else   /* non multi-thread; just define ungetc */

int __cdecl ungetc (
        REG2 int ch,
        FILE *str
        )

{

#endif  /* rejoin common code */

        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;

        /* Stream must be open for read and can NOT be currently in write mode.
           Also, ungetc() character cannot be EOF. */

        if (
              (ch == EOF) ||
              !(
                (stream->_flag & _IOREAD) ||
                ((stream->_flag & _IORW) && !(stream->_flag & _IOWRT))
               )
           )
                return(EOF);

        /* If stream is unbuffered, get one. */

        if (stream->_base == NULL)
                _getbuf(stream);

        /* now we know _base != NULL; since file must be buffered */

        if (stream->_ptr == stream->_base) {
                if (stream->_cnt)
                        /* my back is against the wall; i've already done
                         * ungetc, and there's no room for this one
                         */
                        return(EOF);

                stream->_ptr++;
        }

        if (stream->_flag & _IOSTRG) {
            /* If stream opened by sscanf do not modify buffer */
                if (*--stream->_ptr != (char)ch) {
                        ++stream->_ptr;
                        return(EOF);
                }
        } else
                *--stream->_ptr = (char)ch;

        stream->_cnt++;
        stream->_flag &= ~_IOEOF;
        stream->_flag |= _IOREAD;       /* may already be set */

        return(0xff & ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vfprintf.c ===
/***
*vfprintf.c - fprintf from variable arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vfprintf() - print formatted output, but take args from
*       a stdargs pointer.
*
*Revision History:
*       09-02-83  RN    original fprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vfprintf
*       04-13-87  JCR   added const to declaration
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfprintf(stream, format, ap) - print to file from varargs
*
*Purpose:
*       Performs formatted output to a file.  The arg list is a variable
*       argument list pointer.
*
*Entry:
*       FILE *stream - stream to write data to
*       char *format - format string containing data format
*       va_list ap - variable arg list pointer
*
*Exit:
*       returns number of correctly output characters
*       returns negative number if error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfprintf (
        FILE *str,
        const char *format,
        va_list ap
        )
/*
 * 'V'ariable argument 'F'ile (stream) 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream,format,ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vfwprint.c ===
/***
*vfwprintf.c - fwprintf from variable arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vfwprintf() - print formatted output, but take args from
*       a stdargs pointer.
*
*Revision History:
*       05-16-92  KRS   Created from vfprintf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfwprintf(stream, format, ap) - print to file from varargs
*
*Purpose:
*       Performs formatted output to a file.  The arg list is a variable
*       argument list pointer.
*
*Entry:
*       FILE *stream - stream to write data to
*       wchar_t *format - format string containing data format
*       va_list ap - variable arg list pointer
*
*Exit:
*       returns number of correctly output wide characters
*       returns negative number if error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfwprintf (
        FILE *str,
        const wchar_t *format,
        va_list ap
        )
/*
 * 'V'ariable argument 'F'ile (stream) 'W'char_t 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(str != NULL);
        _ASSERTE(format != NULL);

        /* Init stream pointer */
        stream = str;

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream,format,ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\ungetwc.c ===
/***
*ungetwc.c - unget a wide character from a stream
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ungetwc() - pushes a wide character back onto an input stream
*
*Revision History:
*       04-26-93  CFW   Module created.
*       04-30-93  CFW   Bring wide char support from ungetc.c.
*       05-10-93  CFW   Optimize, fix error handling.
*       06-02-93  CFW   Wide get/put use wint_t.
*       07-16-93  SRW   ALPHA Merge
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       10-01-93  CFW   Test only for TEXT, update comments.
*       10-28-93  CFW   Test for both IOSTRG and TEXT.
*       11-10-93  GJF   Merged in NT SDK version (picked up fix to a cast
*                       expression). Also replaced MTHREAD with _MT.
*       02-07-94  CFW   POSIXify.
*       08-31-94  CFW   Fix for "C" locale, call wctomb().
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-28-95  GJF   Replaced _osfile() with _osfile_safe().
*       03-02-98  GJF   Exception-safe locking.
*       11-05-08  GJF   Don't push back characters onto strings (i.e., when
*                       called by swscanf).
*       12-16-99  GB    Modified for the case when return value from wctomb is
*                       greater then 2.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <setlocal.h>

#ifdef  _MT     /* multi-thread; define both ungetwc and _lk_ungetwc */

/***
*wint_t ungetwc(ch, stream) - put a wide character back onto a stream
*
*Purpose:
*       Guaranteed one char pushback on a stream as long as open for reading.
*       More than one char pushback in a row is not guaranteed, and will fail
*       if it follows an ungetc which pushed the first char in buffer. Failure
*       causes return of WEOF.
*
*Entry:
*       wint_t ch - wide character to push back
*       FILE *stream - stream to push character onto
*
*Exit:
*       returns ch
*       returns WEOF if tried to push WEOF, stream not opened for reading or
*       or if we have already ungetc'd back to beginning of buffer.
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl ungetwc (
        REG2 wint_t ch,
        REG1 FILE *stream
        )
{
        wint_t retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _ungetwc_lk (ch, stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*_ungetwc_lk() -  Ungetwc() core routine (locked version)
*
*Purpose:
*       Core ungetwc() routine; assumes stream is already locked.
*
*       [See ungetwc() above for more info.]
*
*Entry: [See ungetwc()]
*
*Exit:  [See ungetwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _ungetwc_lk (
        wint_t ch,
        FILE *str
        )
{

#else   /* non multi-thread; just define ungetc */

wint_t __cdecl ungetwc (
        wint_t ch,
        FILE *str
        )
{

#endif  /* rejoin common code */

        _ASSERTE(str != NULL);

        /*
         * Requirements for success:
         *
         * 1. Character to be pushed back on the stream must not be WEOF.
         *
         * 2. The stream must currently be in read mode, or must be open for
         *    update (i.e., read/write) and must NOT currently be in write
         *    mode.
         */
        if ( (ch != WEOF) &&
             ( (str->_flag & _IOREAD) || ((str->_flag & _IORW) &&
                !(str->_flag & _IOWRT))
             )
           )
        {
                /* If stream is unbuffered, get one. */
                if (str->_base == NULL)
                        _getbuf(str);

#ifndef _NTSUBSET_
                if (!(str->_flag & _IOSTRG) && (_osfile_safe(_fileno(str)) & 
                    FTEXT))
                {
                        /*
                         * Text mode, sigh... Convert the wc to a mbc.
                         */
                        int size, i;
                        char mbc[MB_LEN_MAX];

                        if ((size = wctomb(mbc, ch)) == -1)
                        {
                                /*
                                 * Conversion failed! Set errno and return
                                 * failure.
                                 */
                                errno = EILSEQ;
                                return WEOF;
                        }

                        /* we know _base != NULL; since file is buffered */
                        if (str->_ptr < str->_base + size)
                        {
                                if (str->_cnt)
                                    /* my back is against the wall; i've already done
                                     * ungetwc, and there's no room for this one
                                     */
                                    return WEOF;
                                if (size > str->_bufsiz)
                                    return WEOF;
                                str->_ptr = size + str->_base;
                        }

                        for ( i = size -1; i >= 0; i--)
                        {
                                *--str->_ptr = mbc[i];
                        }
                        str->_cnt += size;

                        str->_flag &= ~_IOEOF;
                        str->_flag |= _IOREAD;  /* may already be set */
                        return (wint_t) (0x0ffff & ch);
                }
#endif
                /*
                 * Binary mode or a string (from swscanf) - push back the wide 
                 * character
                 */

                /* we know _base != NULL; since file is buffered */
                if (str->_ptr < str->_base + sizeof(wchar_t))
                {
                        if (str->_cnt)
                                /* my back is against the wall; i've already done
                                 * ungetc, and there's no room for this one
                                 */
                                return WEOF;
                        if (sizeof(wchar_t) > str->_bufsiz)
                            return WEOF;
                        str->_ptr = sizeof(wchar_t) + str->_base;
                }

                if (str->_flag & _IOSTRG) {
                        /* If stream opened by swscanf do not modify buffer */
                        if (*--((wchar_t *)(str->_ptr)) != (wchar_t)ch) {
                                ++((wchar_t *)(str->_ptr));
                                return WEOF;
                        }
                } else
                        *--((wchar_t *)(str->_ptr)) = (wchar_t)(ch & 0xffff);

                str->_cnt += sizeof(wchar_t);

                str->_flag &= ~_IOEOF;
                str->_flag |= _IOREAD;  /* may already be set */

                return (wint_t)(ch & 0xffff);

        }
        return WEOF;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vsnwprnt.c ===
/***
*vsnwprnt.c - "Count" version of vswprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _vsnwprintf() flavor takes a count argument that is
*	the max number of wide characters that should be written to the
*	user's buffer.
*
*Revision History:
*	05-16-91   KRS	Created from vsnprint.c
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define _COUNT_ 1
#include "vswprint.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wfdopen.c ===
/***
*wfdopen.c - open a file descriptor as stream (wchar_t version)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfdopen() - opens a file descriptor as a stream, thus allowing
*	buffering, etc.
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fdopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vsnprint.c ===
/***
*vsnprintf.c - "Count" version of vsprintf
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	The _vsnprintf() flavor takes a count argument that is
*	the max number of bytes that should be written to the
*	user's buffer.
*
*Revision History:
*	09-25-91   JCR	Stub module created.
*
*******************************************************************************/

#define _COUNT_ 1
#include "vsprintf.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vwprintf.c ===
/***
*vwprintf.c - wprintf from a var args pointer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vwprintf() - print formatted data from an argument list pointer
*
*Revision History:
*       05-16-92  KRS   Created from vprintf.c
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>

/***
*int vwprintf(format, ap) - print formatted data from an argument list pointer
*
*Purpose:
*       Prints formatted data items to stdout.  Uses a pointer to a
*       variable length list of arguments instead of an argument list.
*
*Entry:
*       wchar_t *format - format string, describes data format to write
*       va_list ap - pointer to variable length arg list
*
*Exit:
*       returns number of wide characters written
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vwprintf (
        const wchar_t *format,
        va_list ap
        )
/*
 * stdout 'V'ariable, 'W'char_t 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream = stdout;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _woutput(stream, format, ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vprintf.c ===
/***
*vprintf.c - printf from a var args pointer
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vprintf() - print formatted data from an argument list pointer
*
*Revision History:
*       09-02-83  RN    original printf
*       06-17-85  TC    rewrote to use new varargs macros to be vprintf
*       04-13-87  JCR   added const to declaration
*       11-06-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-31-88  PHG   Merged DLL and normal versions
*       06-15-88  JCR   Near reference to _iob[] entries; improve REG variables
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   _[un]lock_str macros now take FILE * arg.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <file2.h>
#include <mtdll.h>

/***
*int vprintf(format, ap) - print formatted data from an argument list pointer
*
*Purpose:
*       Prints formatted data items to stdout.  Uses a pointer to a
*       variable length list of arguments instead of an argument list.
*
*Entry:
*       char *format - format string, describes data format to write
*       va_list ap - pointer to variable length arg list
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vprintf (
        const char *format,
        va_list ap
        )
/*
 * stdout 'V'ariable, 'PRINT', 'F'ormatted
 */
{
        REG1 FILE *stream = stdout;
        REG2 int buffing;
        REG3 int retval;

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str(stream);
        __try {
#endif

        buffing = _stbuf(stream);
        retval = _output(stream, format, ap );
        _ftbuf(buffing, stream);

#ifdef  _MT
        }
        __finally {
            _unlock_str(stream);
        }
#endif

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vswprint.c ===
/***
*vswprint.c - print formatted data into a string from var arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vswprintf() and _vsnwprintf() - print formatted output to
*       a string, get the data from an argument ptr instead of explicit
*       arguments.
*
*Revision History:
*       05-16-92  KRS   Created from vsprintf.c.
*       02-18-93  SRW   Make FILE a local and remove lock usage.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-16-00  GB    Added _vscwprintf()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int vswprintf(string, format, ap) - print formatted data to string from arg ptr
*else
*int _vsnwprintf(string, cnt, format, ap) - print formatted data to string from arg ptr
*endif
*
*Purpose:
*       Prints formatted data, but to a string and gets data from an argument
*       pointer.
*       Sets up a FILE so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _vsnwprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       wchar_t *string - place to put destination string
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       wchar_t *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of wide characters in string
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl vswprintf (
        wchar_t *string,
        const wchar_t *format,
        va_list ap
        )
#else

int __cdecl _vsnwprintf (
        wchar_t *string,
        size_t count,
        const wchar_t *format,
        va_list ap
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(string != NULL);
        _ASSERTE(format != NULL);

        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = (char *) string;
#ifndef _COUNT_
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)(count*sizeof(wchar_t));
#endif

        retval = _woutput(outfile,format,ap );
        _putc_lk('\0',outfile);     /* no-lock version */
        _putc_lk('\0',outfile);     /* 2nd byte for wide char version */

        return(retval);
}


/***
* _vscwprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       wchar_t *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/


#ifndef _COUNT_
int __cdecl _vscwprintf (
        const wchar_t *format,
        va_list ap
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _woutput(outfile,format,ap);
        return(retval);
}
#endif
#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\vsprintf.c ===
/***
*vsprintf.c - print formatted data into a string from var arg list
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines vsprintf() and _vsnprintf() - print formatted output to
*       a string, get the data from an argument ptr instead of explicit
*       arguments.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-25-90  SBM   Replaced <assertm.h> by <assert.h>, <varargs.h> by
*                       <stdarg.h>
*       10-03-90  GJF   New-style function declarator.
*       09-24-91  JCR   Added _vsnprintf()
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       02-06-94  CFW   assert -> _ASSERTE.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       03-10-00  GB    Added support for knowing the length of formatted
*                       string by passing NULL for input string.
*       03-16-00  GB    Added _vscprintf()
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <internal.h>
#include <limits.h>
#include <mtdll.h>

#define MAXSTR INT_MAX


/***
*ifndef _COUNT_
*int vsprintf(string, format, ap) - print formatted data to string from arg ptr
*else
*int _vsnprintf(string, cnt, format, ap) - print formatted data to string from arg ptr
*endif
*
*Purpose:
*       Prints formatted data, but to a string and gets data from an argument
*       pointer.
*       Sets up a FILE so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Allocate the 'fake' _iob[] entryit statically instead of on
*       the stack so that other routines can assume that _iob[] entries are in
*       are in DGROUP and, thus, are near.
*
*ifdef _COUNT_
*       The _vsnprintf() flavor takes a count argument that is
*       the max number of bytes that should be written to the
*       user's buffer.
*endif
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *string - place to put destination string
*ifdef _COUNT_
*       size_t count - max number of bytes to put in buffer
*endif
*       char *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters in string
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_

int __cdecl vsprintf (
        char *string,
        const char *format,
        va_list ap
        )
#else

int __cdecl _vsnprintf (
        char *string,
        size_t count,
        const char *format,
        va_list ap
        )
#endif

{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

#ifndef _COUNT_
        _ASSERTE(string != NULL);
        outfile->_cnt = MAXSTR;
#else
        outfile->_cnt = (int)count;
#endif
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = string;

        retval = _output(outfile,format,ap );
        if ( string!=NULL)
            _putc_lk('\0',outfile);

        return(retval);
}

/***
* _vscprintf() - counts the number of character needed to print the formatted
* data
*
*Purpose:
*       Counts the number of characters in the fotmatted data.
*
*Entry:
*       char *format - format string, describes format of data
*       va_list ap - varargs argument pointer
*
*Exit:
*       returns number of characters needed to print formatted data.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _COUNT_
int __cdecl _vscprintf (
        const char *format,
        va_list ap
        )
{
        FILE str;
        REG1 FILE *outfile = &str;
        REG2 int retval;

        _ASSERTE(format != NULL);

        outfile->_cnt = MAXSTR;
        outfile->_flag = _IOWRT|_IOSTRG;
        outfile->_ptr = outfile->_base = NULL;

        retval = _output(outfile,format,ap);
        return(retval);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wfopen.c ===
/***
*wfopen.c - open a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfopen() and _wfsopen() - open a file as a stream and open a file
*	with a specified sharing mode as a stream
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "fopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wfreopen.c ===
/***
*wfreope.c - close a stream and assign it to a new file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wfreopen() - close and reopen file, typically used to redirect
*	stdin/out/err/prn/aux.
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "freopen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wtempnam.c ===
/***
*wtempnam.c - generate unique file name (wchar_t version)
*
*	Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-21-95  GJF	Deleted obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "tempnam.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\woutput.c ===
/***
*woutput.c - wprintf style output to a FILE (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the symbol UNICODE and then #includes the file
*	"output.c" in order to implement _woutput(), the helper for the
*	wide character versions of *wprintf() family of functions.
*
*Revision History:
*	04-27-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "output.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wpopen.c ===
/***
*wpopen.c - initiate a pipe and a child command (wchar_t version)
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines _wpopen().
*
*Revision History:
*	12-07-93  CFW	Module created.
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#define WPRFLAG 1

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "popen.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\winput.c ===
/***
*winput.c - wscanf style input from a FILE (wchar_t version)
*
*	Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the symbol UNICODE and then #includes the file
*	"input.c" in order to implement _winput(), the helper for the
*	wide character versions of the *wscanf() family of functions.
*
*Revision History:
*	04-27-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-22-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "input.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wtmpfile.c ===
/***
*wtmpfile.c - create unique file name or file (wchar_t version)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wtmpnam().
*
*Revision History:
*	12-07-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-21-95  GJF	Deleted obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "tmpfile.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wscanf.c ===
/***
*wscanf.c - read formatted data from stdin
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wscanf() - reads formatted data from stdin
*
*Revision History:
*       05-16-92  KRS   Created from scanf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-94  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macro.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int wscanf(format, ...) - read formatted data from stdin
*
*Purpose:
*       Reads formatted data from stdin into arguments.  _input does the real
*       work here.
*
*Entry:
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wscanf (
        const wchar_t *format,
        ...
        )
/*
 * stdin 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        va_list arglist;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(0, stdin);
        __try {
#endif

        retval = (_winput(stdin,format,arglist));

#ifdef  _MT
        }
        __finally {
            _unlock_str2(0, stdin);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\wprintf.c ===
/***
*wprintf.c - print formatted
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wprintf() - print formatted data
*
*Revision History:
*       05-16-92  KRS   Created from printf.c.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       02-06-95  CFW   assert -> _ASSERTE.
*       03-07-95  GJF   Use _[un]lock_str2 instead of _[un]lock_str. Also,
*                       removed useless local and macros.
*       03-02-98  GJF   Exception-safe locking.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int wprintf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on stdout using the format string to
*       format data and getting as many arguments as called for
*       Uses temporary buffering to improve efficiency.
*       _output does the real work here
*
*Entry:
*       wchar_t *format - format string to control data format/number of arguments
*       followed by list of arguments, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wprintf (
        const wchar_t *format,
        ...
        )
/*
 * stdout 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list arglist;
        int buffing;
        int retval;

// UNDONE: make va_start work with wchar_t format string
        va_start(arglist, format);

        _ASSERTE(format != NULL);

#ifdef  _MT
        _lock_str2(1, stdout);
        __try {
#endif

        buffing = _stbuf(stdout);

        retval = _woutput(stdout,format,arglist);

        _ftbuf(buffing, stdout);

#ifdef  _MT
        }
        __finally {
            _unlock_str2(1, stdout);
        }
#endif

        return(retval);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_filbuf.c ===
/***
*_filbuf.c - fill buffer and get character
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filbuf() - fill buffer and read first character, allocate
*       buffer if there is none.  Used from getc().
*       defines _filwbuf() - fill buffer and read first wide character, allocate
*       buffer if there is none.  Used from getwc().
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to handle variable length buffers
*       04-16-87  JCR   added _IOUNGETC support
*       08-04-87  JCR   added _getbuff routine
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-06-87  JCR   Multi-thread support; also, split _getbuf() off
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-11-88  JCR   Merged mthread version into normal code
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       03-04-88  JCR   Read() return value must be considered unsigned, not
*                       signed
*       06-06-88  JCR   Optimized _iob2 references
*       06-13-88  JCR   Use near pointer to reference _iob[] entries
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       06-20-89  PHG   Re-activate C version, propogated fixes
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       alignment.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       03-27-90  GJF   Added #include <io.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       05-06-93  CFW   Optimize wide char conversion.
*       05-24-93  GJF   Detect small buffer size (_SMALL_BUFSIZ) resulting
*                       from fseek call on read-access-only stream and
*                       restore the larger size (_INTERNAL_BUFSIZ) for the
*                       next _filbuf call.
*       06-22-93  GJF   Check _IOSETVBUF (new) before changing buffer size.
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       10-17-94  BWT   Move wchar.h to non-POSIX build (ino_t definitions conflict)
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-27-95  GJF   Replaced _osfile() with _osfile_safe().
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#include <internal.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <errno.h>
#else
#include <msdos.h>
#include <wchar.h>
#endif
#ifdef  _MT
#include <mtdll.h>
#endif
#include <tchar.h>

#ifndef _UNICODE

/***
*int _filbuf(stream) - fill buffer and get first character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first character from buffer (next character to be read)
*       returns EOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filbuf (
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _filwbuf(stream) - fill buffer and get first wide character
*
*Purpose:
*       get a buffer if the file doesn't have one, read into it, return first
*       char. try to get a buffer, if a user buffer is not assigned. called
*       only from getc; intended for use only within library. assume no input
*       stream is to remain unbuffered when memory is available unless it is
*       marked _IONBF. at worst, give it a single char buffer. the need for a
*       buffer, no matter how small, becomes evident when we consider the
*       ungetc's necessary in scanf
*
*       [NOTE: Multi-thread - _filwbuf() assumes that the caller has aquired
*       the stream lock, if needed.]
*
*Entry:
*       FILE *stream - stream to read from
*
*Exit:
*       returns first wide character from buffer (next character to be read)
*       returns WEOF if the FILE is actually a string, or not open for reading,
*       or if open for writing or if no more chars to read.
*       all fields in FILE structure may be changed except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _filwbuf (
        FILE *str
        )

#endif  /* _UNICODE */

{
#ifdef  _NTSUBSET_

        return(_TEOF);

#else   /* ndef _NTSUBSET_ */

        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init pointer to _iob2 entry. */
        stream = str;

        if (!inuse(stream) || stream->_flag & _IOSTRG)
                return(_TEOF);

        if (stream->_flag & _IOWRT) {
#ifdef  _POSIX_
                errno = EBADF;
#endif
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        stream->_flag |= _IOREAD;

        /* Get a buffer, if necessary. */

        if (!anybuf(stream))
                _getbuf(stream);
        else
                stream->_ptr = stream->_base;

#ifdef  _POSIX_
        stream->_cnt = read(fileno(stream), stream->_base, stream->_bufsiz);
#else
        stream->_cnt = _read(_fileno(stream), stream->_base, stream->_bufsiz);
#endif

#ifndef _UNICODE
        if ((stream->_cnt == 0) || (stream->_cnt == -1)) {
#else /* _UNICODE */
        if ((stream->_cnt == 0) || (stream->_cnt == 1) || stream->_cnt == -1) {
#endif /* _UNICODE */
                stream->_flag |= stream->_cnt ? _IOERR : _IOEOF;
                stream->_cnt = 0;
                return(_TEOF);
        }

#ifndef _POSIX_
        if (  !(stream->_flag & (_IOWRT|_IORW)) &&
              ((_osfile_safe(_fileno(stream)) & (FTEXT|FEOFLAG)) == 
                (FTEXT|FEOFLAG)) )
                stream->_flag |= _IOCTRLZ;
#endif
        /* Check for small _bufsiz (_SMALL_BUFSIZ). If it is small and
           if it is our buffer, then this must be the first _filbuf after
           an fseek on a read-access-only stream. Restore _bufsiz to its
           larger value (_INTERNAL_BUFSIZ) so that the next _filbuf call,
           if one is made, will fill the whole buffer. */
        if ( (stream->_bufsiz == _SMALL_BUFSIZ) && (stream->_flag &
              _IOMYBUF) && !(stream->_flag & _IOSETVBUF) )
        {
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }
#ifndef _UNICODE
        stream->_cnt--;
        return(0xff & *stream->_ptr++);
#else   /* _UNICODE */
        stream->_cnt -= sizeof(wchar_t);
        return (0xffff & *((wchar_t *)(stream->_ptr))++);
#endif  /* _UNICODE */

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_flswbuf.c ===
/***
*_flswbuf.c - flush buffer and output wide character.
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _flswbuf() - flush a file buffer and output a wide character.
*	If no buffer, make one.
*
*Revision History:
*	04-27-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-16-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_


#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_flsbuf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_filwbuf.c ===
/***
*_filwbuf.c - fill buffer and get wide character
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _filwbuf() - fill buffer and read first character, allocate
*	buffer if there is none.  Used from getwc().
*
*Revision History:
*	04-27-93  CFW	Module Created.
*	02-07-94  CFW	POSIXify.
*	02-16-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_


#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_filbuf.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_freebuf.c ===
/***
*_freebuf.c - release a buffer from a stream
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _freebuf() - release a buffer from a stream
*
*Revision History:
*       09-19-83  RN    initial version
*       02-15-90  GJF   Fixed copyright, alignment.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       02-14-92  GJF   Replaced _nfile with _nhandle for Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-22-93  GJF   Clear _IOSETVBUF flag (new).
*       09-05-94  SKS   Change "#ifdef" inside comments to "*ifdef" to avoid
*                       problems with CRTL source release process.
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-04-95  GJF   _WIN32_ -> _WIN32.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Merged in Mac version.
*       09-06-95  GJF   Removed inappropriate ASSERTE()-s.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <stdlib.h>

/***
*void _freebuf(stream) - release a buffer from a stream
*
*Purpose:
*       free a buffer if at all possible. free() the space if malloc'd by me.
*       forget about trying to free a user's buffer for him; it may be static
*       memory (not from malloc), so he has to take care of it. this function
*       is not intended for use outside the library.
*
*ifdef _MT
*       Multi-thread notes:
*       _freebuf() does NOT get the stream lock; it is assumed that the
*       caller has already done this.
*endif
*
*Entry:
*       FILE *stream - stream to free bufer on
*
*Exit:
*       Buffer may be freed.
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _freebuf (
        REG1 FILE *stream
        )
{
        _ASSERTE(stream != NULL);

        if (inuse(stream) && mbuf(stream))
        {
                _free_crt(stream->_base);

                stream->_flag &= ~(_IOMYBUF | _IOSETVBUF);
                stream->_base = stream->_ptr = NULL;
                stream->_cnt = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_getbuf.c ===
/***
*_getbuf.c - Get a stream buffer
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Allocate a buffer and init stream data bases.
*
*Revision History:
*       11-06-87  JCR   Initial version (split off from _filbuf.c)
*       01-11-88  JCR   Moved from mthread/dll only to main code
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       07-27-88  GJF   Added _cflush++ to force pre-terminator (necessary in
*                       case stdout has been redirected to a file and acquires
*                       a buffer here, and pre-terminator has not already been
*                       forced).
*       08-25-88  GJF   Don't use FP_OFF() macro for the 386
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Replaced near cdecl with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-27-93  CFW   Change _IONBF size to 2 bytes to hold wide char.
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       11-04-93  SRW   Dont call malloc in _NTSUBSET_ version
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <malloc.h>
#include <internal.h>
#include <dbgint.h>

/***
*_getbuf() - Allocate a buffer and init stream data bases
*
*Purpose:
*       Allocates a buffer for a stream and inits the stream data bases.
*
*       [NOTE  1: This routine assumes the caller has already checked to make
*       sure the stream needs a buffer.
*
*       [NOTE 2: Multi-thread - Assumes caller has aquired stream lock, if
*       needed.]
*
*Entry:
*       FILE *stream = stream to allocate a buffer for
*
*Exit:
*       void
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _getbuf (
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(str != NULL);

#if     !defined(_NTSUBSET_) && !defined(CRTDLL)
        /* force library pre-termination procedure */
        _cflush++;
#endif

        /* Init pointers */
        stream = str;

#ifndef _NTSUBSET_

        /* Try to get a big buffer */
        if (stream->_base = _malloc_crt(_INTERNAL_BUFSIZ))
        {
                /* Got a big buffer */
                stream->_flag |= _IOMYBUF;
                stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        else {

#endif  /* _NTSUBSET_ */

                /* Did NOT get a buffer - use single char buffering. */
                stream->_flag |= _IONBF;
                stream->_base = (char *)&(stream->_charbuf);
                stream->_bufsiz = 2;

#ifndef _NTSUBSET_
        }
#endif  /* _NTSUBSET_ */

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_flsbuf.c ===
/***
*_flsbuf.c - flush buffer and output character.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _flsbuf() - flush a file buffer and output a character.
*       defines _flswbuf() - flush a file buffer and output a wide character.
*       If no buffer, make one.
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to handle variable length buffers
*       06-08-87  JCR   When buffer is allocated or when first write to buffer
*                       occurs, if stream is in append mode, then position file
*                       pointer to end.
*       07-20-87  SKS   Change first parameter "ch" from (char) to (int)
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-05-87  JCR   Re-wrote for simplicity and for new stderr/stdout
*                       handling
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-11-88  JCR   Merged mthread version into normal code
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       06-06-88  JCR   Optimized _iob2 references
*       06-13-88  JCR   Use near pointer to reference _iob[] entries
*       06-28-88  JCR   Support for dynamic buffer allocation for stdout/stderr
*       07-28-88  GJF   Set stream->_cnt to 0 if _IOREAD is set.
*       08-25-88  GJF   Added checked that OS2 is defined whenever M_I386 is.
*       06-20-89  PHG   Removed FP_OFF macro call.
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Replaced cdecl _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit support.
*       03-27-90  GJF   Added #include <io.h>.
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       08-07-90  SBM   Restored descriptive text in assertion
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-25-91  DJM   POSIX support
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-26-93  CFW   Wide char enable.
*       05-06-93  CFW   Optimize wide char conversion.
*       11-05-93  GJF   Merged with NT SDK version (picked up _NTSUBSET_
*                       stuff).
*       10-17-94  BWT   Move wchar.h to non-POSIX build (ino_t definitions conflict)
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-16-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       06-12-95  GJF   Replaced _osfile[] with _osfile() (macro referencing
*                       field in ioinfo struct).
*       07-25-95  GJF   Replaced _osfile()with _osfile_safe().
*       12-07-95  SKS   Fix misspelling of _NTSUBSET_ (final _ was missing)
*       02-27-98  RKP   Added 64 bit support.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <malloc.h>
#ifdef  _POSIX_
#include <unistd.h>
#include <errno.h>
#else
#include <msdos.h>
#include <wchar.h>
#endif
#include <internal.h>
#ifdef  _MT
#include <mtdll.h>
#endif
#include <tchar.h>

#ifndef _UNICODE

/***
*int _flsbuf(ch, stream) - flush buffer and output character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flsbuf (
        int ch,
        FILE *str
        )

#else  /* _UNICODE */

/***
*int _flswbuf(ch, stream) - flush buffer and output wide character.
*
*Purpose:
*       flush a buffer if this stream has one. if not, try to get one. put the
*       next output wide char (ch) into the buffer (or output it immediately if this
*       stream can't have a buffer). called only from putwc. intended for use
*       only within library.
*
*       [NOTE: Multi-thread - It is assumed that the caller has aquired
*       the stream lock.]
*
*Entry:
*       FILE *stream - stream to flish and write on
*       int ch - wide character to output.
*
*Exit:
*       returns -1 if FILE is actually a string, or if can't write ch to
*       unbuffered file, or if we flush a buffer but the number of wide chars
*       written doesn't agree with buffer size.  Otherwise returns ch.
*       all fields in FILE struct can be affected except _file.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flswbuf (
        int ch,
        FILE *str
        )

#endif  /* _UNICODE */

{
#ifdef  _NTSUBSET_

        str->_flag |= _IOERR;
        return(_TEOF);

#else   /* ndef _NTSUBSET_ */

        REG1 FILE *stream;
        REG2 int charcount;
        REG3 int written;
        int fh;

        _ASSERTE(str != NULL);

        /* Init file handle and pointers */
        stream = str;
#ifdef  _POSIX_
        fh = fileno(stream);
#else
        fh = _fileno(stream);
#endif

        if (!(stream->_flag & (_IOWRT|_IORW)) || (stream->_flag & _IOSTRG)) {
#ifdef  _POSIX_
                errno = EBADF;
#endif
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

        /* Check that _IOREAD is not set or, if it is, then so is _IOEOF. Note
           that _IOREAD and IOEOF both being set implies switching from read to
           write at end-of-file, which is allowed by ANSI. Note that resetting
           the _cnt and _ptr fields amounts to doing an fflush() on the stream
           in this case. Note also that the _cnt field has to be reset to 0 for
           the error path as well (i.e., _IOREAD set but _IOEOF not set) as
           well as the non-error path. */

        if (stream->_flag & _IOREAD) {
                stream->_cnt = 0;
                if (stream->_flag & _IOEOF) {
                        stream->_ptr = stream->_base;
                        stream->_flag &= ~_IOREAD;
                }
                else {
                        stream->_flag |= _IOERR;
                        return(_TEOF);
                }
        }

        stream->_flag |= _IOWRT;
        stream->_flag &= ~_IOEOF;
        written = charcount = stream->_cnt = 0;

        /* Get a buffer for this stream, if necessary. */
        if (!anybuf(stream)) {

                /* Do NOT get a buffer if (1) stream is stdout/stderr, and
                   (2) stream is NOT a tty.
                   [If stdout/stderr is a tty, we do NOT set up single char
                   buffering. This is so that later temporary buffering will
                   not be thwarted by the _IONBF bit being set (see
                   _stbuf/_ftbuf usage).]
                */
                if (!( ((stream==stdout) || (stream==stderr))
#ifdef  _POSIX_
                && (isatty(fh)) ))
#else
                && (_isatty(fh)) ))
#endif

                        _getbuf(stream);

        } /* end !anybuf() */

        /* If big buffer is assigned to stream... */
        if (bigbuf(stream)) {

                _ASSERTE(("inconsistent IOB fields", stream->_ptr - stream->_base >= 0));

                charcount = (int)(stream->_ptr - stream->_base);
                stream->_ptr = stream->_base + sizeof(TCHAR);
                stream->_cnt = stream->_bufsiz - (int)sizeof(TCHAR);

                if (charcount > 0)
#ifdef  _POSIX_
                        written = write(fh, stream->_base, charcount);
#else
                        written = _write(fh, stream->_base, charcount);
#endif
                else
#ifdef  _POSIX_
                        if (stream->_flag & _IOAPPEND)
                            lseek(fh,0l,SEEK_END);
#else
                        if (_osfile_safe(fh) & FAPPEND)
                                _lseek(fh,0L,SEEK_END);
#endif

#ifndef _UNICODE
                *stream->_base = (char)ch;
#else   /* _UNICODE */
                *(wchar_t *)(stream->_base) = (wchar_t)(ch & 0xffff);
#endif  /* _UNICODE */
        }

    /* Perform single character output (either _IONBF or no buffering) */
        else {
                charcount = sizeof(TCHAR);
#ifndef _UNICODE
#ifdef  _POSIX_
                written = write(fh, &ch, charcount);
#else
                written = _write(fh, &ch, charcount);
#endif
#else   /* _UNICODE */
                {
                        char mbc[4];

                        *(wchar_t *)mbc = (wchar_t)(ch & 0xffff);
#ifdef  _POSIX_
                        written = write(fh, mbc, charcount);
#else
                        written = _write(fh, mbc, charcount);
#endif
                }
#endif  /* _UNICODE */
        }

        /* See if the _write() was successful. */
        if (written != charcount) {
                stream->_flag |= _IOERR;
                return(_TEOF);
        }

#ifndef _UNICODE
        return(ch & 0xff);
#else   /* _UNICODE */
        return(ch & 0xffff);
#endif  /* _UNICODE */

#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_file.c ===
/***
*_file.c - Definition of _iob[], initializer and terminator.
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _iob[], the array of stdio control structures, the initializer
*       and terminator routines, and the multithread locking for stdio.
*
*Revision History:
*       04-18-84  RN    initial version
*       ??-??-??  TC    added field _bifsiz to iob2 to allow variable
*                       length buffers
*       10-02-86  SKS   _NFILE_ is now different for real-mode and prot-mode
*                       _NFILE_ must be defined by compiler -D directory
*       05-27-87  JCR   Protected mode now uses only 3 pre-defined file handles,
*                       not 5.  Added PM (prot mode) to conditionalize handles.
*       06-24-87  SKS   Make "_bufin[]" and "_bufout[]" near for Compact/Large
*                       models (MS real-mode version only)
*       07-01-87  PHG   Changed PM switch to PROTMODE
*       11-05-87  JCR   Added _buferr and modified stderr entry
*       11-09-87  SKS   Removed IBMC20 switch, Changed PROTMODE to OS2
*       01-04-88  JCR   Moved _NFILE_ definition from command line to file
*       01-11-88  JCR   Merged Mthread version into standard version
*       01-21-88  JCR   Removed reference to internal.h and added _NEAR_
*                       (thus, internal.h doesn't get released in startup
*                       sources even though _file.c does).
*       06-28-88  JCR   Remove static stdout/stderr buffers
*       07-06-88  JCR   Corrected _bufin declaration so it's always in BSS
*       08-24-88  GJF   Added check that OS2 is defined whenever M_I386 is.
*       06-08-89  GJF   Propagated SKS's fix of 02-08-89, and fixed copyright.
*       07-25-89  GJF   Cleanup (deleted DOS specific and OS/2 286 specific
*                       stuff). Now specific to the 386.
*       01-09-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright
*       03-16-90  GJF   Added #include <cruntime.h> and removed some (now)
*                       useless preprocessor stuff.
*       03-26-90  GJF   Replaced _cdecl with _VARTYPE1.
*       02-14-92  GJF   Replaced _NFILE_ with _NSTREAM_ for Win32, with _NFILE
*                       for non-Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       04-04-94  GJF   #ifndef-ed out for Win32S version of msvcrt*.dll.
*                       Also, deleted old conditionals for non-Win32 support.
*       08-18-94  GJF   Moved stdio terminator stuff from fflush.c to here
*                       and added an initializer which fixes the _file field
*                       of _iob[0], _iob[1] and _iob[2] when the underlying
*                       entries in _osfhnd[0], _osfhnd[1], _osfhnd[2] are
*                       invalid (0 or -1).
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       03-01-95  GJF   Changes to manage streams via __piob[], rather than
*                       _iob[].
*       06-12-95  GJF   Replaced _osfhnd[] with _osfhnd() (macro referencing
*                       field in ioinfo struct).
*       06-19-97  GJF   Moved _[un]lock_file[2]() here from startup\mlock.c.
*       02-13-98  GJF   Changes for Win32: changed long cast to intptr_t.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       09-26-97  BWT   Fix POSIX
*       05-17-99  PML   Remove all Macintosh support.
*       01-29-01  GB    Added _func function version of data variable used in msvcprt.lib
*                       to work with STATIC_CPPLIB
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <rterr.h>
#include <dbgint.h>
#include <mtdll.h>

#ifndef _XBOX
/*
 * Buffer for stdin.
 */

char _bufin[_INTERNAL_BUFSIZ];
#endif

/*
 * FILE descriptors; preset for stdin/out/err (note that the __tmpnum field
 * is not initialized)
 */
FILE _iob[_IOB_ENTRIES] = {
        /* _ptr, _cnt, _base,  _flag, _file, _charbuf, _bufsiz */

        /* stdin (_iob[0]) */

#ifdef _XBOX
        { NULL, 0, NULL, _IOREAD, 0, 0, 0 },
#else
        { _bufin, 0, _bufin, _IOREAD | _IOYOURBUF, 0, 0, _INTERNAL_BUFSIZ },
#endif // XBOX

        /* stdout (_iob[1]) */

        { NULL, 0, NULL, _IOWRT, 1, 0, 0 },

        /* stderr (_iob[3]) */

        { NULL, 0, NULL, _IOWRT, 2, 0, 0 },

};


/* These functions are for enabling STATIC_CPPLIB functionality */
_CRTIMP FILE * __cdecl __iob_func(void)
{
    return _iob;
}


/*
 * Pointer to array of FILE * or _FILEX * structures.
 */
void ** __piob;

/*
 * Number of open streams (set to _NSTREAM by default)
 */
#ifdef  CRTDLL
int _nstream = _NSTREAM_;
#else
int _nstream;
#endif


/*
 * Initializer and terminator for stdio
 */
int  __cdecl __initstdio(void);
void __cdecl __endstdio(void);

#ifdef  _MSC_VER

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __initstdio;

#pragma data_seg(".CRT$XPX")
_CRTALLOC(".CRT$XPX") static _PVFV pterm = __endstdio;

#pragma data_seg()

#endif  /* _MSC_VER */

#ifndef CRTDLL
/*
 * _cflush is a dummy variable used to pull in _endstdio() when any STDIO
 * routine is included in the user program.
 */
int _cflush = 0;
#endif  /* CRTDLL */


/***
* __initstdio - Initialize the stdio system
*
*Purpose:
*       Create and initialize the __piob array.
*
*Entry: <void>
*
*Exit:  Returns _RT_STDIOINIT if error encountered.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __initstdio(void)
{
        int i;

#ifndef CRTDLL
        /*
         * If the user has not supplied a definition of _nstream, set it
         * to _NSTREAM_. If the user has supplied a value that is too small
         * set _nstream to the minimum acceptable value (_IOB_ENTRIES).
         */
        if ( _nstream ==  0 )
            _nstream = _NSTREAM_;
        else if ( _nstream < _IOB_ENTRIES )
            _nstream = _IOB_ENTRIES;
#endif

        /*
         * Allocate the __piob array. Try for _nstream entries first. If this
         * fails then reset _nstream to _IOB_ENTRIES and try again. If it
         * still fails, bail out with an RTE.
         */
        if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) )) ==
             NULL ) {
            _nstream = _IOB_ENTRIES;
            if ( (__piob = (void **)_calloc_crt( _nstream, sizeof(void *) ))
                 == NULL )
                return _RT_STDIOINIT;
        }

        /*
         * Initialize the first _IOB_ENTRIES to point to the corresponding
         * entries in _iob[].
         */
        for ( i = 0 ; i < _IOB_ENTRIES ; i++ )
            __piob[i] = (void *)&_iob[i];

#ifndef _POSIX_
        for ( i = 0 ; i < 3 ; i++ ) {
            if ( (_osfhnd(i) == (intptr_t)INVALID_HANDLE_VALUE) ||
                 (_osfhnd(i) == 0) )
            {
                _iob[i]._file = -1;
            }
        }
#endif

        return 0;
}


/***
* __endstdio - Terminate the stdio system
*
*Purpose:
*       Terminate the stdio system
*
*       (1) Flush all streams.  (Do this even if we're going to
*       call fcloseall since that routine won't do anything to the
*       std streams.)
*
*       (2) If returning to caller, close all streams.  This is
*       not necessary if the exe is terminating because the OS will
*       close the files for us (much more efficiently, too).
*
*Entry: <void>
*
*Exit:  <void>
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __endstdio(void)
{
        /* flush all streams */
        _flushall();

        /* if in callable exit, close all streams */
        if (_exitflag)
                _fcloseall();
}


#ifdef  _MT

/***
* _lock_file - Lock a FILE
*
*Purpose:
*       Assert the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file (
        void *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is locked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= (void *)_iob) && (pf <= (void *)(&_iob[_IOB_ENTRIES-1])) )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + (int)((FILE *)pf - _iob) );
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _lock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Assert the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _lock( _STREAM_LOCKS + i );
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            EnterCriticalSection( &(((_FILEX *)s)->lock) );
}


/***
* _unlock_file - Unlock a FILE
*
*Purpose:
*       Release the lock for a stdio-level file
*
*Entry:
*       pf = __piob[] entry (pointer to a FILE or _FILEX)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file (
        void *pf
        )
{
        /*
         * The way the FILE (pointed to by pf) is unlocked depends on whether
         * it is part of _iob[] or not
         */
        if ( (pf >= (void *)_iob) && (pf <= (void *)(&_iob[_IOB_ENTRIES-1])) )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _unlock( _STREAM_LOCKS + (int)((FILE *)pf - _iob) );
        else
            /*
             * Not part of _iob[]. Therefore, *pf is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)pf)->lock) );
}


/***
* _unlock_file2(i, s) - Lock the FILE
*
*Purpose:
*       Release the lock for a stdio-level file given by s == __piob[i].
*
*Entry:
*       s == __piob[i]
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlock_file2 (
        int i,
        void *s
        )
{
        /*
         * The way the FILE is locked depends on whether it is part of _iob[]
         * _iob[] or not
         */
        if ( i < _IOB_ENTRIES )
            /*
             * FILE lies in _iob[] so the lock lies in _locktable[].
             */
            _unlock( _STREAM_LOCKS + i );
        else
            /*
             * Not part of _iob[]. Therefore, *s is a _FILEX and the
             * lock field of the struct is an initialized critical
             * section.
             */
            LeaveCriticalSection( &(((_FILEX *)s)->lock) );
}

#endif  /* _MT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_wopen.c ===
/***
*_wopen.c - open a stream, with string mode (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wopenfile() - opens a stream, with string arguments for mode
*
*Revision History:
*	10-29-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-20-95  GJF	Removed obsolete WPRFLAG.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#include "_open.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memccpy.c ===
/***
*memccpy.c - copy bytes until a character is found
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memccpy() - copies bytes until a specifed character
*       is found, or a maximum number of characters have been copied.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright. Also, fixed compiler warning.
*       08-14-90   SBM  Compiles cleanly with -W3, removed now redundant
*                       #include <stddef.h>
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       01-17-91   GJF  ANSI naming.
*       09-01-93   GJF  Replaced _CALLTYPE1 with __cdecl.
*       10-27-99   PML  Win64 fix: unsigned int -> size_t
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_memccpy(dest, src, c, count) - copy bytes until character found
*
*Purpose:
*       Copies bytes from src to dest until count bytes have been
*       copied, or up to and including the character c, whichever
*       comes first.
*
*Entry:
*       void *dest - pointer to memory to receive copy
*       void *src  - source of bytes
*       int  c     - character to stop copy at
*       size_t count - max number of bytes to copy
*
*Exit:
*       returns pointer to byte immediately after c in dest
*       returns NULL if c was never found
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _memccpy (
        void * dest,
        const void * src,
        int c,
        size_t count
        )
{
        while ( count && (*((char *)(dest = (char *)dest + 1) - 1) =
        *((char *)(src = (char *)src + 1) - 1)) != (char)c )
                count--;

        return(count ? dest : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\makefile.inc ===
!if "$(SRCDIR)" == ""
SRCDIR = .^\
!endif

$(SRCDIR)strcspn.c: $(SRCDIR)strspn.c

$(SRCDIR)strpbrk.c: $(SRCDIR)strspn.c

$(SRCDIR)i386\memmove.asm: $(SRCDIR)i386\memcpy.asm

$(SRCDIR)i386\strcspn.asm: $(SRCDIR)i386\strspn.asm

$(SRCDIR)i386\strpbrk.asm: $(SRCDIR)i386\strspn.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_sftbuf.c ===
/***
*_sftbuf.c - temporary buffering initialization and flushing
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       temporary buffering initialization and flushing. if stdout/err is
*       unbuffered, buffer it temporarily so that string is sent to kernel as
*       a batch of chars, not char-at-a-time. if appropriate, make buffering
*       permanent.
*
*       [NOTE 1: These routines assume that the temporary buffering is only
*       used for output.  In particular, note that _stbuf() sets _IOWRT.]
*
*       [NOTE 2: It is valid for this module to assign a value directly to
*       _flag instead of simply twiddling bits since we are initializing the
*       buffer data base.]
*
*Revision History:
*       09-01-83  RN    initial version
*       06-26-85  TC    added code to _stbuf to allow variable buffer lengths
*       ??-??-??  TC    fixed case in _flbuf where flag is off, but a temporary
*                       buffer still needs to be fflushed.
*       05-27-87  JCR   protect mode does not know about stdprn.
*       06-26-87  JCR   Conditionalized out code in _ftbuf that caused
*                       redirected stdout to be flushed on every call.
*       07-01-87  JCR   Put in code to support re-entrant calling from
*                       interrupt level (MSC only).
*       08-06-87  JCR   Fixed a _ftbuf() problem pertaining to stderr/stdprn
*                       when _bufout is being used by stdout.
*       08-07-87  JCR   (1) When assigning _bufout to an _iob, we now set the
*                       _IOWRT flag.  This fixes a bug involving freopen()
*                       issued against one of the std handles.
*                       (2) Removed some annoying commented out code.
*       08-13-87  JCR   _ftbuf() does NOT clear _IOWRT now.  Fixes a bug where
*                       _getstream() would reassign stdout because none of the
*                       flags were set.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       11-05-87  JCR   Re-written for multi-thread support and simplicity
*       01-11-88  JCR   Merged mthread version into normal version
*       01-13-88  SKS   Changed bogus "_fileno_lk" to "fileno"
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       06-27-88  JCR   Added stdprn temporary buffering support (DOS only),
*                       and made buffer allocation dynamic; also added _IOFLRTN
*                       (flush stream on per routine basis).
*       08-25-88  GJF   Modified to also work for the 386 (small model only).
*       06-20-89  PHG   Changed return value to void
*       08-28-89  JCR   Removed _NEAR_ for 386
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright and
*                       indents.
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>. Also,
*                       removed some leftover 16-bit DOS support.
*       03-27-90  GJF   Added #include <io.h>.
*       05-29-90  SBM   Use _flush, not [_]fflush[_lk]
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-22-91  GJF   ANSI naming.
*       03-27-92  DJM   POSIX support.
*       08-26-92  GJF   Include unistd.h for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-11-93  GJF   Replaced BUFSIZ with _INTERNAL_BUFSIZ.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary. Also, replaced MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Merged in Mac version.
*       02-07-97  GJF   Changed _stbuf() to use _charbuf when malloc fails.
*                       Also, detab-ed.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#ifdef  _POSIX_
#include <unistd.h>
#endif
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <internal.h>
#include <malloc.h>
#ifdef  _MT
#include <mtdll.h>
#endif
#include <dbgint.h>

/* Buffer pointers for stdout and stderr */
void *_stdbuf[2] = { NULL, NULL};

/***
*int _stbuf(stream) - set temp buffer on stdout, stdprn, stderr
*
*Purpose:
*       if stdout/stderr is still unbuffered, buffer it.
*       this function works intimately with _ftbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only.
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       FILE *stream - stream to temp buffer
*
*Exit:
*       returns 1 if buffer initialized, 0 if not
*       sets fields in stdout or stderr to indicate buffering
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _stbuf (
        FILE *str
        )
{
        REG1 FILE *stream;
        int index;

        _ASSERTE(str != NULL);

        /* Init near stream pointer */
        stream = str;

        /* do nothing if not a tty device */
#ifdef _POSIX_
        if (!isatty(fileno(stream)))
#else
        if (!_isatty(_fileno(stream)))
#endif
                return(0);

        /* Make sure stream is stdout/stderr and init _stdbuf index */
        if (stream == stdout)
                index = 0;
        else if (stream == stderr)
                index = 1;
        else
                return(0);

#ifndef CRTDLL
        /* force library pre-termination procedure */
        _cflush++;
#endif  /* CRTDLL */

        /* Make sure the stream is not already buffered. */
        if (anybuf(stream))
                return(0);

        /* Allocate a buffer for this stream if we haven't done so yet. */
        if ( (_stdbuf[index] == NULL) &&
             ((_stdbuf[index]=_malloc_crt(_INTERNAL_BUFSIZ)) == NULL) ) {
                /* Cannot allocate buffer. Use _charbuf this time */
                stream->_ptr = stream->_base = (void *)&(stream->_charbuf);
                stream->_cnt = stream->_bufsiz = 2;
        }
        else {
                /* Set up the buffer */
                stream->_ptr = stream->_base = _stdbuf[index];
                stream->_cnt = stream->_bufsiz = _INTERNAL_BUFSIZ;
        }

        stream->_flag |= (_IOWRT | _IOYOURBUF | _IOFLRTN);

        return(1);
}


/***
*void _ftbuf(flag, stream) - take temp buffering off a stream
*
*Purpose:
*       If stdout/stderr is being buffered and it is a device, _flush and
*       dismantle the buffer. if it's not a device, leave the buffering on.
*       This function works intimately with _stbuf, and accompanies it in
*       bracketing normally unbuffered output. these functions intended for
*       library use only
*
*       Multi-thread: It is assumed that the caller has already aquired the
*       stream lock.
*
*Entry:
*       int flag     - a flag to tell whether to dismantle temp buffering on a
*                      stream
*       FILE *stream - the stream
*
*Exit:
*       no return value
*       sets fields in stdout/stderr
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _ftbuf (
        int flag,
        FILE *str
        )
{
        REG1 FILE *stream;

        _ASSERTE(flag == 0 || flag == 1);

        /* Init near stream pointers */
        stream = str;

        if (flag) {

                if (stream->_flag & _IOFLRTN) {

                        /* Flush the stream and tear down temp buffering. */
                        _flush(stream);
                        stream->_flag &= ~(_IOYOURBUF | _IOFLRTN);
                        stream->_bufsiz = 0;
                        stream->_base = stream->_ptr = NULL;
                }

                /* Note: If we expand the functionality of the _IOFLRTN bit to
                include other streams, we may want to clear that bit here under
                an 'else' clause (i.e., clear bit in the case that we leave the
                buffer permanently assigned.  Given our current use of the bit,
                the extra code is not needed. */

        } /* end flag = 1 */

#ifndef _MT
/* NOTE: Currently, writing to the same string at interrupt level does not
   work in multi-thread programs. */

/* The following code is needed if an interrupt occurs between calls
   to _stbuf/_ftbuf and the interrupt handler also calls _stbuf/_ftbuf. */

        else
                if (stream->_flag & _IOFLRTN)
                        _flush(stream);

#endif  /* _MT */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\stdio\_open.c ===
/***
*_open.c - open a stream, with string mode
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _openfile() - opens a stream, with string arguments for mode
*
*Revision History:
*       09-02-83  RN    initial version
*       03-02-87  JCR   made _openfile recognize "wb+" as equal to "w+b", etc.
*                       got rid of intermediate _openfile flags (internal) and
*                       now go straight from mode string to open system call
*                       and system->_flags.
*       09-28-87  JCR   Corrected _iob2 indexing (now uses _iob_index() macro).
*       02-21-88  SKS   Removed #ifdef IBMC20
*       06-06-88  JCR   Optimized _iob2 references
*       06-10-88  JCR   Use near pointer to reference _iob[] entries
*       08-19-88  GJF   Initial adaption for the 386.
*       11-14-88  GJF   Added shflag (file sharing flag) parameter, also some
*                       cleanup (now specific to the 386).
*       08-17-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-15-90  GJF   _iob[], _iob2[] merge. Also, fixed copyright.
*       03-16-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and removed #include <register.h>.
*       03-27-90  GJF   Added const qualifier to types of filename and mode.
*                       Added #include <io.h>.
*       07-11-90  SBM   Added support for 'c' and 'n' flags
*       07-23-90  SBM   Replaced <assertm.h> by <assert.h>
*       10-03-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       03-11-92  GJF   Replaced __tmpnum field with _tmpfname field for
*                       Win32.
*       03-25-92  DJM   POSIX support.
*       08-26-92  GJF   Fixed POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       05-24-93  PML   Added support for 'D', 'R', 'S' and 'T' flags
*       11-01-93  CFW   Enable Unicode variant, rip out CRUISER.
*       04-05-94  GJF   #ifdef-ed out _cflush reference for msvcrt*.dll, it
*                       is unnecessary.
*       02-06-94  CFW   assert -> _ASSERTE.
*       02-17-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <fcntl.h>
#include <file2.h>
#include <io.h>
#include <dbgint.h>
#include <internal.h>
#include <tchar.h>

#define CMASK   0644    /* rw-r--r-- */
#define P_CMASK 0666    /* different for Posix */

/***
*FILE *_openfile(filename, mode, shflag, stream) - open a file with string
*       mode and file sharing flag.
*
*Purpose:
*       parse the string, looking for exactly one of {rwa}, at most one '+',
*       at most one of {tb}, at most one of {cn}, at most one of {SR}, at most
*       one 'T', and at most one 'D'. pass the result on as an int containing
*       flags of what was found. open a file with proper mode if permissions
*       allow. buffer not allocated until first i/o call is issued. intended
*       for use inside library only
*
*Entry:
*       char *filename - file to open
*       char *mode - mode to use (see above)
*       int shflag - file sharing flag
*       FILE *stream - stream to use for file
*
*Exit:
*       set stream's fields, and causes system file management by system calls
*       returns stream or NULL if fails
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
FILE * __cdecl _wopenfile (
#else
FILE * __cdecl _openfile (
#endif
        const _TSCHAR *filename,
        REG3 const _TSCHAR *mode,
#ifndef _POSIX_
        int shflag,
#endif
        FILE *str
        )
{
        REG2 int modeflag;
#ifdef _POSIX_
        int streamflag = 0;
#else
        int streamflag = _commode;
        int commodeset = 0;
        int scanset    = 0;
#endif
        int whileflag;
        int filedes;
        REG1 FILE *stream;

        _ASSERTE(filename != NULL);
        _ASSERTE(mode != NULL);
        _ASSERTE(str != NULL);

        /* Parse the user's specification string as set flags in
               (1) modeflag - system call flags word
               (2) streamflag - stream handle flags word. */

        /* First mode character must be 'r', 'w', or 'a'. */

        switch (*mode) {
        case _T('r'):
#ifdef _POSIX_
                modeflag = O_RDONLY;
#else
                modeflag = _O_RDONLY;
#endif
                streamflag |= _IOREAD;
                break;
        case _T('w'):
#ifdef _POSIX_
                modeflag = O_WRONLY | O_CREAT | O_TRUNC;
#else
                modeflag = _O_WRONLY | _O_CREAT | _O_TRUNC;
#endif
                streamflag |= _IOWRT;
                break;
        case _T('a'):
#ifdef _POSIX_
                modeflag = O_WRONLY | O_CREAT | O_APPEND;
                streamflag |= _IOWRT | _IOAPPEND;
#else
                modeflag = _O_WRONLY | _O_CREAT | _O_APPEND;
                streamflag |= _IOWRT;
#endif
                break;
        default:
                return(NULL);
                break;
        }

        /* There can be up to three more optional mode characters:
           (1) A single '+' character,
           (2) One of 't' and 'b' and
           (3) One of 'c' and 'n'.
        */

        whileflag=1;

        while(*++mode && whileflag)
                switch(*mode) {

                case _T('+'):
#ifdef  _POSIX_
                        if (modeflag & O_RDWR)
                                whileflag=0;
                        else {
                                modeflag |= O_RDWR;
                                modeflag &= ~(O_RDONLY | O_WRONLY);
#else
                        if (modeflag & _O_RDWR)
                                whileflag=0;
                        else {
                                modeflag |= _O_RDWR;
                                modeflag &= ~(_O_RDONLY | _O_WRONLY);
#endif
                                streamflag |= _IORW;
                                streamflag &= ~(_IOREAD | _IOWRT);
                        }
                        break;

                case _T('b'):
#ifndef _POSIX_
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_BINARY;
#endif
                        break;

#ifndef _POSIX_
                case _T('t'):
                        if (modeflag & (_O_TEXT | _O_BINARY))
                                whileflag=0;
                        else
                                modeflag |= _O_TEXT;
                        break;

                case _T('c'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag |= _IOCOMMIT;
                        }
                        break;

                case _T('n'):
                        if (commodeset)
                                whileflag=0;
                        else {
                                commodeset = 1;
                                streamflag &= ~_IOCOMMIT;
                        }
                        break;

                case _T('S'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_SEQUENTIAL;
                        }
                        break;

                case _T('R'):
                        if (scanset)
                                whileflag=0;
                        else {
                                scanset = 1;
                                modeflag |= _O_RANDOM;
                        }
                        break;

                case _T('T'):
                        if (modeflag & _O_SHORT_LIVED)
                                whileflag=0;
                        else
                                modeflag |= _O_SHORT_LIVED;
                        break;

                case _T('D'):
                        if (modeflag & _O_TEMPORARY)
                                whileflag=0;
                        else
                                modeflag |= _O_TEMPORARY;
                        break;
#endif

                default:
                        whileflag=0;
                        break;
                }

        /* Try to open the file.  Note that if neither 't' nor 'b' is
           specified, _sopen will use the default. */

#ifdef _POSIX_
        if ((filedes = _topen(filename, modeflag, P_CMASK)) < 0)
#else
        if ((filedes = _tsopen(filename, modeflag, shflag, CMASK)) < 0)
#endif
                return(NULL);

        /* Set up the stream data base. */
#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */
        /* Init pointers */
        stream = str;

        stream->_flag = streamflag;
        stream->_cnt = 0;
        stream->_tmpfname = stream->_base = stream->_ptr = NULL;

        stream->_file = filedes;

        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memchr.c ===
/***
*memchr.c - search block of memory for a given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines memchr() - search memory until a character is
*	found or a limit is reached.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-01-90   GJF	New-style function declarator. Also, rewrote expr. to
*			avoid using cast as an lvalue.
*	04-26-91   SRW	Removed level 3 warnings
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	03-15-95   GJF	Unified PMAC and Win32 versions, elimating bug in
*			PMAC version in the process
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *memchr(buf, chr, cnt) - search memory for given character.
*
*Purpose:
*	Searches at buf for the given character, stopping when chr is
*	first found or cnt bytes have been searched through.
*
*Entry:
*	void *buf  - memory buffer to be searched
*	int chr    - character to search for
*	size_t cnt - max number of bytes to search
*
*Exit:
*	returns pointer to first occurence of chr in buf
*	returns NULL if chr not found in the first cnt bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memchr (
	const void * buf,
	int chr,
	size_t cnt
	)
{
	while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
		buf = (unsigned char *)buf + 1;
		cnt--;
	}

	return(cnt ? (void *)buf : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memcmp.c ===
/***
*memcmp.c - compare two blocks of memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines memcmp() - compare two memory blocks lexically and
*	find their order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator. Also, rewrote expr. to
*			avoid using cast as an lvalue.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93  GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(memcmp)
#endif

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*	Compares count bytes of memory starting at buf1 and buf2
*	and find if equal or which one is first in lexical order.
*
*Entry:
*	void *buf1, *buf2 - pointers to memory sections to compare
*	size_t count - length of sections to compare
*
*Exit:
*	returns < 0 if buf1 < buf2
*	returns  0  if buf1 == buf2
*	returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
	const void * buf1,
	const void * buf2,
	size_t count
	)
{
	if (!count)
		return(0);

	while ( --count && *(char *)buf1 == *(char *)buf2 ) {
		buf1 = (char *)buf1 + 1;
		buf2 = (char *)buf2 + 1;
	}

	return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memcpy.c ===
/***
*memcpy.c - contains memcpy routine
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are not treated specially, so propogation may occur.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       04-01-91   SRW  Add #pragma function for i386 _WIN32_ and _CRUISER_
*                       builds
*       04-05-91   GJF  Speed up for large buffers by moving int-sized chunks
*                       as much as possible.
*       08-06-91   GJF  Backed out 04-05-91 change. Pointers would have to be
*                       dword-aligned for this to work on MIPS.
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       12-03-93   GJF  Turn on #pragma function for all MS front-ends (esp.,
*                       Alpha compiler).
*       10-02-94   BWT  Add PPC support.
*       10-07-97   RDL  Added IA64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef  _MSC_VER
#pragma function(memcpy)
#endif

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else
        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }
#endif

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memicmp.c ===
/***
*memicmp.c - compare memory, ignore case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _memicmp() - compare two blocks of memory for lexical
*       order.  Case is ignored in the comparison.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright. Also, fixed compiler warnings.
*       10-01-90  GJF   New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       01-17-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       09-01-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       10-18-94  GJF   Sped up, especially for C locale. Also, made multi-
*                       thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-08-98  GJF   Split out ASCII-only version.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  PML   Win64 fix: unsigned int -> size_t
*       26-01-00  GB    Modified memicmp for performance.
*       09-03-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <ctype.h>
#include <setlocal.h>
#include <locale.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int _memicmp(first, last, count) - compare two blocks of memory, ignore case
*
*Purpose:
*       Compares count bytes of the two blocks of memory stored at first
*       and last.  The characters are converted to lowercase before
*       comparing (not permanently), so case is ignored in the search.
*
*Entry:
*       char *first, *last - memory buffers to compare
*       size_t count - maximum length to compare
*
*Exit:
*       returns < 0 if first < last
*       returns 0 if first == last
*       returns > 0 if first > last
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
        int f = 0, l = 0;
        const char *dst = first, *src = last;
#if     !defined(_NTSUBSET_)
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
#endif  /* !_NTSUBSET_ */
            return __ascii_memicmp(first, last, count);
#if     !defined(_NTSUBSET_)
        }
        else {
            while (count-- && f==l)
            {
#ifdef  _MT
                f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                f = tolower( (unsigned char)(*(dst++)) );
                l = tolower( (unsigned char)(*(src++)) );
#endif
            }
        }
#endif  /* !_NTSUBSET_ */

        return ( f - l );
}


#ifndef _M_IX86

int __cdecl __ascii_memicmp (
        const void * first,
        const void * last,
        size_t count
        )
{
        int f = 0;
        int l = 0;
        while ( count-- )
        {
            if ( (*(unsigned char *)first == *(unsigned char *)last) ||
                 ((f = __ascii_tolower( *(unsigned char *)first )) ==
                  (l = __ascii_tolower( *(unsigned char *)last ))) )
            {
                    first = (char *)first + 1;
                    last = (char *)last + 1;
            }
            else
                break;
        }
        return ( f - l );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\sources.inc ===
MAJORCOMP=crt
MINORCOMP=string

TARGETNAME=string

!INCLUDE ..\..\crt32.inc

INCLUDES=$(INCLUDES);..

SOURCES=\
    ..\strcoll.c   \
    ..\stricoll.c  \
    ..\strlwr.c    \
    ..\strncoll.c  \
    ..\strnicol.c  \
    ..\strtok.c    \
    ..\strupr.c    \
    ..\strxfrm.c   \
    ..\wcscat.c    \
    ..\wcschr.c    \
    ..\wcscmp.c    \
    ..\wcscoll.c   \
    ..\wcscspn.c   \
    ..\wcsdup.c    \
    ..\wcsicmp.c   \
    ..\wcsicoll.c  \
    ..\wcslen.c    \
    ..\wcslwr.c    \
    ..\wcsncat.c   \
    ..\wcsncmp.c   \
    ..\wcsncoll.c  \
    ..\wcsncpy.c   \
    ..\wcsnicmp.c  \
    ..\wcsnicol.c  \
    ..\wcsnset.c   \
    ..\wcspbrk.c   \
    ..\wcsrchr.c   \
    ..\wcsrev.c    \
    ..\wcsset.c    \
    ..\wcsspn.c    \
    ..\wcsstr.c    \
    ..\wcstok.c    \
    ..\wcsupr.c    \
    ..\wcsxfrm.c
    
i386_SOURCES=\
    ..\memcpy.asm    \
    ..\memchr.asm    \
    ..\memcmp.asm    \
    ..\memccpy.asm   \
    ..\_memicmp.asm  \
    ..\memmove.asm   \
    ..\memset.asm    \
    ..\strcat.asm    \
    ..\strchr.asm    \
    ..\strcmp.asm    \
    ..\strcspn.asm   \
    ..\strdup.asm    \
    ..\_stricmp.asm  \
    ..\strlen.asm    \
    ..\strncat.asm   \
    ..\strncmp.asm   \
    ..\strncpy.asm   \
    ..\_strnicm.asm  \
    ..\strnset.asm   \
    ..\strpbrk.asm   \
    ..\strrchr.asm   \
    ..\strrev.asm    \
    ..\strset.asm    \
    ..\strspn.asm    \
    ..\strstr.asm    \
    ..\memicmp.c   \
    ..\stricmp.c   \
    ..\strnicmp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strchr.c ===
/***
*strchr.c - search a string for a given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strchr() - search a string for a character
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-01-90   GJF	New-style function declarator.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strchr(string, c) - search a string for a character
*
*Purpose:
*	Searches a string for a given character, which may be the
*	null character '\0'.
*
*Entry:
*	char *string - string to search in
*	char c - character to search for
*
*Exit:
*	returns pointer to the first occurence of c in string
*	returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strchr (
	const char * string,
	int ch
	)
{
	while (*string && *string != (char)ch)
		string++;

	if (*string == (char)ch)
		return((char *)string);
	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strcmp.c ===
/***
*strcmp.c - routine to compare two strings (for equal, less, or greater)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Compares two string, determining their lexical order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(strcmp)
#endif

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*	STRCMP compares two strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done byte by byte on an UNSIGNED basis, which is to
*	say that Null (0) is less than any other character (1-255).
*
*Entry:
*	const char * src - string for left-hand side of comparison
*	const char * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strcmp (
	const char * src,
	const char * dst
	)
{
	int ret = 0 ;

	while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strcat.c ===
/***
*strcat.c - contains strcat() and strcpy()
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Strcpy() copies one string onto another.
*
*	Strcat() concatenates (appends) a copy of the source string to the
*	end of the destination string, returning the destination string.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-01-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	04-05-91   GJF	Speed up strcat() a bit (got rid of call to strcpy()).
*	09-01-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*	12-30-94   JCF	Turn off #pragma function for MAC.
*	02-30-95   JCF	Add _MBSCAT check.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifndef _MBSCAT
#ifdef	_MSC_VER
#pragma function(strcat,strcpy)
#endif
#endif

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	char *dst - string to which "src" is to be appended
*	const char *src - string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strcat (
	char * dst,
	const char * src
	)
{
	char * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*char *strcpy(dst, src) - copy one string over another
*
*Purpose:
*	Copies the string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	char * dst - string over which "src" is to be copied
*	const char * src - string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

char * __cdecl strcpy(char * dst, const char * src)
{
	char * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strcoll.c ===
/***
*strcoll.c - Collate locale strings
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90  GJF   New-style function declarator.
*       10-01-91  ETC   Non-C locale support under _INTL switch.
*       12-09-91  ETC   Updated api; added multithread.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-16-92  KRS   Optimize for CompareStringW by using -1 for string len.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-10-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int strcoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       [ANSI].
*
*       Non-C locale support available under _INTL switch.
*       In the C locale, strcoll() simply resolves to strcmp().
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl strcoll (
        const char *_string1,
        const char *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
                return strcmp(_string1, _string2);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return strcmp(_string1,_string2);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memmove.c ===
/***
*memmove.c - contains memmove routine
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       memmove() copies a source memory buffer to a destination buffer.
*       Overlapping buffers are treated specially, to avoid propogation.
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       12-28-90   SRW  Added cast of void * to char * for Mips C Compiler
*       04-09-91   GJF  Speed up a little for large buffers.
*       08-06-91   GJF  Backed out 04-09-91 change. Pointers would have to be
*                       dword-aligned for this to work on MIPS.
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       10-02-94   BWT  Add function pragma for Alpha and PPC support
*       10-07-97   RDL  Added IA64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#if defined(_M_ALPHA)
#pragma function(memmove)
#endif

/***
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propogation.
*       For cases where propogation is not a problem, memcpy() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memmove (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else
        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                /*
                 * Non-Overlapping Buffers
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
#endif

        return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\memset.c ===
/***
*memset.c - set a section of memory to all one byte
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the memset() routine
*
*Revision History:
*       05-31-89   JCR  C version created.
*       02-27-90   GJF  Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       08-14-90   SBM  Compiles cleanly with -W3
*       10-01-90   GJF  New-style function declarator. Also, rewrote expr. to
*                       avoid using cast as an lvalue.
*       04-01-91   SRW  Add #pragma function for i386 _WIN32_ and _CRUISER_
*                       builds
*       07-16-93   SRW  ALPHA Merge
*       09-01-93   GJF  Merged NT SDK and Cuda versions.
*       11-12-93   GJF  Replace _MIPS_ and _ALPHA_ with _M_MRX000 and
*                       _M_ALPHA (resp.).
*       11-17-93   CFW  Fix RtlFillMemory prototype typo.
*       12-03-93   GJF  Turn on #pragma function for all MS front-ends (esp.,
*                       Alpha compiler).
*       10-02-94   BWT  Add PPC support.
*       10-07-97   RDL  Added IA64.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef  _MSC_VER
#pragma function(memset)
#endif

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
        {
        extern void RtlFillMemory( void *, size_t count, char );

        RtlFillMemory( dst, count, (char)val );
        }
#else
        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }
#endif

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strlen.c ===
/***
*strlen.c - contains strlen() routine
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	strlen returns the length of a null-terminated string,
*	not including the null byte itself.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	04-01-91   SRW	Add #pragma function for i386 _WIN32_ and _CRUISER_
*			builds
*	04-05-91   GJF	Speed up just a little bit.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	12-03-93   GJF	Turn on #pragma function for all MS front-ends (esp.,
*			Alpha compiler).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#ifdef	_MSC_VER
#pragma function(strlen)
#endif

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*	Finds the length in bytes of the given string, not including
*	the final null character.
*
*Entry:
*	const char * str - string whose length is to be computed
*
*Exit:
*	length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
	const char * str
	)
{
	const char *eos = str;

	while( *eos++ ) ;

	return( (int)(eos - str - 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\stricmp.c ===
/***
*stricmp.c - contains case-insensitive string comp routine _stricmp/_strcmpi
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _stricmp(), also known as _strcmpi()
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       07-25-90  SBM   Added #include <ctype.h>
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       11-08-91  GJF   Fixed compiler warning.
*       09-02-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       09-21-93  CFW   Avoid cast bug.
*       10-18-94  GJF   Sped up C locale. Also, made multi-thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-10-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       08-26-98  GJF   Split out ASCII-only version.
*       09-17-98  GJF   Silly errors in __ascii_stricmp (found by DEC folks)
*       05-17-99  PML   Remove all Macintosh support.
*       01-26-00  GB    Modified stricmp for performance.
*       03-09-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*       08-22-00  GB    Self included this file so as that stricmp and strcmpi
*                       have same code.
*
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <setlocal.h>
#include <ctype.h>
#include <locale.h>

#ifdef _XBOX
#undef _MT
#endif



/***
*int _strcmpi(dst, src), _strcmpi(dst, src) - compare strings, ignore case
*
*Purpose:
*       _stricmp/_strcmpi perform a case-insensitive string comparision.
*       For differences, upper case letters are mapped to lower case.
*       Thus, "abc_" < "ABCD" since "_" < "d".
*
*Entry:
*       char *dst, *src - strings to compare
*
*Return:
*       <0 if dst < src
*        0 if dst = src
*       >0 if dst > src
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _stricmp (
        const char * dst,
        const char * src
        )
{

#if     !defined(_NTSUBSET_)
        int f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* !_NTSUBSET_ */
            return __ascii_stricmp(dst, src);
#if     !defined(_NTSUBSET_)
        }
        else {
            do {   
#ifdef  _MT
                f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                f = tolower( (unsigned char)(*(dst++)) );
                l = tolower( (unsigned char)(*(src++)) );
#endif
            } while ( f && (f == l) );
        }

        return(f - l);
#endif  /* !_NTSUBSET_ */
}

#ifndef _M_IX86

int __cdecl __ascii_stricmp (
        const char * dst,
        const char * src
        )
{
        int f, l;

        do {
            if ( ((f = (unsigned char)(*(dst++))) >= 'A') &&
                 (f <= 'Z') )
                f -= 'A' - 'a';
            if ( ((l = (unsigned char)(*(src++))) >= 'A') &&
                 (l <= 'Z') )
                l -= 'A' - 'a';
        } while ( f && (f == l) );

        return(f - l);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strncat.c ===
/***
*strncat.c - append n chars of string to new string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncat() - appends n characters of string onto
*	end of other string
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strncat(front, back, count) - append count chars of back onto front
*
*Purpose:
*	Appends at most count characters of the string back onto the
*	end of front, and ALWAYS terminates with a null character.
*	If count is greater than the length of back, the length of back
*	is used instead.  (Unlike strncpy, this routine does not pad out
*	to count characters).
*
*Entry:
*	char *front - string to append onto
*	char *back - string to append
*	unsigned count - count of max characters to append
*
*Exit:
*	returns a pointer to string appended onto (front).
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strncat (
	char * front,
	const char * back,
	size_t count
	)
{
	char *start = front;

	while (*front++)
		;
	front--;

	while (count--)
		if (!(*front++ = *back++))
			return(start);

	*front = '\0';
	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strcspn.c ===
/***
*strcspn.c - Defines the strcspn function.
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The function strcspn is mostly common code with strspn in strspn.c.
*
*Revision History:
*	??-??-??  ???	Module created.
*	09-01-94  SKS	Module commented.
*
*******************************************************************************/

#define SSTRCSPN
#include "strspn.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strdup.c ===
/***
*strdup.c - duplicate a string in malloc'd memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strdup() - grab new memory, and duplicate the string into it.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <string.h>

/***
*char *_strdup(string) - duplicate string into malloc'd memory
*
*Purpose:
*	Allocates enough storage via malloc() for a copy of the
*	string, copies the string into the new memory, and returns
*	a pointer to it.
*
*Entry:
*	char *string - string to copy into new memory
*
*Exit:
*	returns a pointer to the newly allocated storage with the
*	string in it.
*
*	returns NULL if enough memory could not be allocated, or
*	string was NULL.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strdup (
	const char * string
	)
{
	char *memory;

	if (!string)
		return(NULL);

	if (memory = malloc(strlen(string) + 1))
		return(strcpy(memory,string));

	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strncmp.c ===
/***
*strncmp.c - compare first n characters of two strings
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncmp() - compare first n characters of two strings
*	for lexical order.
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	10-11-91   GJF	Bug fix! Comparison of final bytes must use unsigned
*			chars.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*int strncmp(first, last, count) - compare first count chars of strings
*
*Purpose:
*	Compares two strings for lexical order.  The comparison stops
*	after: (1) a difference between the strings is found, (2) the end
*	of the strings is reached, or (3) count characters have been
*	compared.
*
*Entry:
*	char *first, *last - strings to compare
*	unsigned count - maximum number of characters to compare
*
*Exit:
*	returns <0 if first < last
*	returns  0 if first == last
*	returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strncmp (
	const char * first,
	const char * last,
	size_t count
	)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return( *(unsigned char *)first - *(unsigned char *)last );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\stricoll.c ===
/***
*stricoll.c - Collate locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*
*Revision History:
*       10-16-91  ETC   Created from strcoll.c
*       12-08-91  ETC   Remove availability under !_INTL; updated api; add mt.
*       04-06-92  KRS   Make work without _INTL switches too.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-16-92  KRS   Optimize for CompareStringW  by using -1 for string len.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       11-25-95  BWT   stricmp simply calls strcmpi... Use strcmpi instead.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _stricoll() - Collate locale strings without regard to case
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information
*       without regard to case.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _stricoll (
        const char *_string1,
        const char *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return _stricmp(_string1, _string2);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _strcmpi(_string1, _string2);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strlwr.c ===
/***
*strlwr.c - routine to map upper-case characters in a string to lower-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the upper case characters in a string to lower case,
*       in place.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-18-91  ETC   Locale support under _INTL switch.
*       12-08-91  ETC   Updated nlsapi; added multithread.
*       08-19-92  KRS   Activated NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building
*                       ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for recovery from stack overflow around
*                       _alloca().
*       05-01-00  BWT   Fix Posix.
*       03-13-01  PML   Fix memory leak if _alloca failed (vs7#224860)
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <limits.h>     /* for INT_MAX */
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*char *_strlwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*       _strlwr() converts upper-case characters in a null-terminated string
*       to their lower-case equivalents.  Conversion is done in place and
*       characters other than upper-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x41 through 0x5A ('A' through 'Z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to lower case
*
*Exit:
*       input string address
*
*Exceptions:
*       The original string is returned unchanged on any error.
*
*******************************************************************************/

char * __cdecl _strlwr (
        char * string
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        int dstlen;                 /* len of dst string, with null  */
        unsigned char *dst;         /* destination string */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            char *cp;       /* traverses string for C locale conversion */

            for ( cp = string ; *cp ; ++cp )
                if ( ('A' <= *cp) && (*cp <= 'Z') )
                    *cp -= 'A' - 'a';

            return(string);
        }   /* C locale */

        /* Inquire size of dst string */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                               LCMAP_LOWERCASE,
                                               string,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_codepage,
#else
                                               __lc_codepage,
#endif
                                               TRUE )) )
            return(string);

        /* Allocate space for dst */
        __try {
            dst = (unsigned char *)_alloca(dstlen * sizeof(unsigned char));
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            _resetstkoflw();
            dst = NULL;
        }

        if ( dst == NULL ) {
            dst = (unsigned char *)_malloc_crt(dstlen * sizeof(unsigned char));
            malloc_flag++;
        }

        /* Map src string to dst string in alternate case */
        if ( (dst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_LOWERCASE,
                                 string,
                                 -1,
                                 dst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage,
#else
                                 __lc_codepage,
#endif
                                 TRUE ) != 0) )
            /* copy dst string to return string */
            strcpy(string, dst);

        if ( malloc_flag )
            _free_crt(dst);

        return(string);

#else

        char * cp;

        for (cp=string; *cp; ++cp)
        {
            if ('A' <= *cp && *cp <= 'Z')
                *cp += 'a' - 'A';
        }

        return(string);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strpbrk.c ===
/***
*strpbrk.c - Defines the strpbrk function.
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The function strpbrk is mostly common code with strspn in strspn.c.
*
*Revision History:
*	??-??-??  ???	Module created.
*	09-01-94  SKS	Module commented.
*
*******************************************************************************/

#define SSTRPBRK
#include "strspn.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strncpy.c ===
/***
*strncpy.c - copy at most n characters of string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strncpy() - copy at most n characters of string
*
*Revision History:
*	05-31-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	09-02-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strncpy(dest, source, count) - copy at most n characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count.
*
*
*Entry:
*	char *dest - pointer to destination
*	char *source - source string for copy
*	unsigned count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strncpy (
	char * dest,
	const char * source,
	size_t count
	)
{
	char *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = '\0';

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strncoll.c ===
/***
*strncoll.c - Collate locale strings
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       05-09-94  CFW   Created from strnicol.c.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _strncoll() - Collate locale strings
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _strncoll (
        const char *_string1,
        const char *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( !count )
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return strncmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return strncmp(_string1, _string2, count);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strnicol.c ===
/***
*strnicoll.c - Collate locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       01-13-94  CFW   Created from stricoll.c.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       05-09-94  CFW   Fix !_INTL case.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _strnicoll() - Collate locale strings without regard to case
*
*Purpose:
*       Compare two strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*
*Entry:
*       const char *s1 = pointer to the first string
*       const char *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       Less than 0    = first string less than second string
*       0              = strings are equal
*       Greater than 0 = first string greater than second string
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _strnicoll (
        const char *_string1,
        const char *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return _strnicmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringA( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              (int)count,
                                              _string2, 
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _strnicmp(_string1, _string2, count);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strrchr.c ===
/***
*strrchr.c - find last occurrence of character in string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strrchr() - find the last occurrence of a given character
*	in a string.
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3, removed now redundant
*			#include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strrchr(string, ch) - find last occurrence of ch in string
*
*Purpose:
*	Finds the last occurrence of ch in string.  The terminating
*	null character is used as part of the search.
*
*Entry:
*	char *string - string to search in
*	char ch - character to search for
*
*Exit:
*	returns a pointer to the last occurrence of ch in the given
*	string
*	returns NULL if ch does not occurr in the string
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strrchr (
	const char * string,
	int ch
	)
{
	char *start = (char *)string;

	while (*string++)			/* find end of string */
		;
						/* search towards front */
	while (--string != start && *string != (char)ch)
		;

	if (*string == (char)ch)		/* char found ? */
		return( (char *)string );

	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strnset.c ===
/***
*strnset.c - set first n characters to single character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strnset() - sets at most the first n characters of a string
*	to a given character.
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Compiles cleanly with -W3
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_strnset(string, val, count) - set at most count characters to val
*
*Purpose:
*	Sets the first count characters of string the character value.
*	If the length of string is less than count, the length of
*	string is used in place of n.
*
*Entry:
*	char *string - string to set characters in
*	char val - character to fill with
*	unsigned count - count of characters to fill
*
*Exit:
*	returns string, now filled with count copies of val.
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strnset (
	char * string,
	int val,
	size_t count
	)
{
	char *start = string;

	while (count-- && *string)
		*string++ = (char)val;

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strrev.c ===
/***
*strrev.c - reverse a string in place
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _strrev() - reverse a string in place (not including
*	'\0' character)
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	10-02-90   GJF	New-style function declarator.
*	01-18-91   GJF	ANSI naming.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *_strrev(string) - reverse a string in place
*
*Purpose:
*	Reverses the order of characters in the string.  The terminating
*	null character remains in place.
*
*Entry:
*	char *string - string to reverse
*
*Exit:
*	returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strrev (
	char * string
	)
{
	char *start = string;
	char *left = string;
	char ch;

	while (*string++)		  /* find end of string */
		;
	string -= 2;

	while (left < string)
	{
		ch = *left;
		*left++ = *string;
		*string-- = ch;
	}

	return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strnicmp.c ===
/***
*strnicmp.c - compare n chars of strings, ignoring case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _strnicmp() - Compares at most n characters of two strings,
*       without regard to case.
*
*Revision History:
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       10-11-91  GJF   Bug fix! Comparison of final bytes must use unsigned
*                       chars.
*       09-03-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       09-21-93  CFW   Avoid cast bug.
*       01-13-94  CFW   Fix Comments.
*       10-19-94  GJF   Sped up C locale. Also, made multi-thread safe.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       11-15-95  BWT   Fix _NTSUBSET_
*       08-11-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       09-08-98  GJF   Split out ASCII-only version.
*       05-17-99  PML   Remove all Macintosh support.
*       26-01-00  GB    Modified strnicmp for performance.
*       09-03-00  GB    Moved the performance code to toupper and tolower.
*                       restored the original file.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <mtdll.h>
#include <ctype.h>
#include <setlocal.h>
#include <locale.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int _strnicmp(first, last, count) - compares count char of strings, ignore case
*
*Purpose:
*       Compare the two strings for lexical order.  Stops the comparison
*       when the following occurs: (1) strings differ, (2) the end of the
*       strings is reached, or (3) count characters have been compared.
*       For the purposes of the comparison, upper case characters are
*       converted to lower case.
*
*Entry:
*       char *first, *last - strings to compare
*       size_t count - maximum number of characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns 0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _strnicmp (
        const char * dst,
        const char * src,
        size_t count
        )
{
        int f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        if ( count )
        {
#if     !defined(_NTSUBSET_)
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* !_NTSUBSET_ */
                return __ascii_strnicmp(dst, src, count);
#if     !defined(_NTSUBSET_)
            }
            else {
                do {
#ifdef  _MT
                    f = __tolower_mt( ptloci, (unsigned char)(*(dst++)) );
                    l = __tolower_mt( ptloci, (unsigned char)(*(src++)) );
#else
                    f = tolower( (unsigned char)(*(dst++)) );
                    l = tolower( (unsigned char)(*(src++)) );
#endif
                } while (--count && f && (f == l) );
            }
#endif  /* !_NTSUBSET_ */

            return( f - l );
        }

        return( 0 );
}


#ifndef _M_IX86

int __cdecl __ascii_strnicmp (
        const char * first,
        const char * last,
        size_t count
        )
{
        int f, l;

        do {

            if ( ((f = (unsigned char)(*(first++))) >= 'A') &&
                 (f <= 'Z') )
                f -= 'A' - 'a';

            if ( ((l = (unsigned char)(*(last++))) >= 'A') &&
                 (l <= 'Z') )
                l -= 'A' - 'a';

        } while ( --count && f && (f == l) );

        return ( f - l );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strstr.c ===
/***
*strstr.c - search for one string inside another
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strstr() - search for one string inside another
*
*Revision History:
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarator.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*	03-14-94   GJF	If string2 is empty, return string1.
*	12-30-94   CFW	Avoid 'const' warning.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

/***
*char *strstr(string1, string2) - search for string2 in string1
*
*Purpose:
*	finds the first occurrence of string2 in string1
*
*Entry:
*	char *string1 - string to search in
*	char *string2 - string to search for
*
*Exit:
*	returns a pointer to the first occurrence of string2 in
*	string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strstr (
	const char * str1,
	const char * str2
	)
{
	char *cp = (char *) str1;
	char *s1, *s2;

	if ( !*str2 )
	    return((char *)str1);

	while (*cp)
	{
		s1 = cp;
		s2 = (char *) str2;

		while ( *s1 && *s2 && !(*s1-*s2) )
			s1++, s2++;

		if (!*s2)
			return(cp);

		cp++;
	}

	return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strspn.c ===
/***
*strspn.c - find length of initial substring of chars from a control string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strspn() - finds the length of the initial substring of
*	a string consisting entirely of characters from a control string.
*
*	defines strcspn()- finds the length of the initial substring of
*	a string consisting entirely of characters not in a control string.
*
*	defines strpbrk()- finds the index of the first character in a string
*	that is not in a control string
*
*Revision History:
*	06-01-89   JCR	C version created.
*	02-27-90   GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90   SBM	Removed now redundant #include <stddef.h>
*	10-02-90   GJF	New-style function declarators.
*	12-04-90   SRW	Made it default to compiling for strspn
*	05-21-93   GJF	Used unsigned char pointers to access control and
*			source strings.
*	09-03-93   GJF	Replaced _CALLTYPE1 with __cdecl.
*
*******************************************************************************/

/* Determine which routine we're compiling for (default to STRSPN) */

#define _STRSPN 	1
#define _STRCSPN	2
#define _STRPBRK	3

#if defined(SSTRCSPN)
#define ROUTINE _STRCSPN
#elif defined(SSTRPBRK)
#define ROUTINE _STRPBRK
#else
#define ROUTINE _STRSPN
#endif

#include <cruntime.h>
#include <string.h>

/***
*int strspn(string, control) - find init substring of control chars
*
*Purpose:
*	Finds the index of the first character in string that does belong
*	to the set of characters specified by control.	This is
*	equivalent to the length of the initial substring of string that
*	consists entirely of characters from control.  The '\0' character
*	that terminates control is not considered in the matching process.
*
*Entry:
*	char *string - string to search
*	char *control - string containing characters not to search for
*
*Exit:
*	returns index of first char in string not in control
*
*Exceptions:
*
*******************************************************************************/

/***
*int strcspn(string, control) - search for init substring w/o control chars
*
*Purpose:
*	returns the index of the first character in string that belongs
*	to the set of characters specified by control.	This is equivalent
*	to the length of the length of the initial substring of string
*	composed entirely of characters not in control.  Null chars not
*	considered.
*
*Entry:
*	char *string - string to search
*	char *control - set of characters not allowed in init substring
*
*Exit:
*	returns the index of the first char in string
*	that is in the set of characters specified by control.
*
*Exceptions:
*
*******************************************************************************/

/***
*char *strpbrk(string, control) - scans string for a character from control
*
*Purpose:
*	Finds the first occurence in string of any character from
*	the control string.
*
*Entry:
*	char *string - string to search in
*	char *control - string containing characters to search for
*
*Exit:
*	returns a pointer to the first character from control found
*	in string.
*	returns NULL if string and control have no characters in common.
*
*Exceptions:
*
*******************************************************************************/



/* Routine prototype */
#if ROUTINE == _STRSPN /*IFSTRIP=IGN*/
size_t __cdecl strspn (
#elif ROUTINE == _STRCSPN /*IFSTRIP=IGN*/
size_t __cdecl strcspn (
#else /* ROUTINE == STRPBRK */
char * __cdecl strpbrk (
#endif
	const char * string,
	const char * control
	)
{
	const unsigned char *str = string;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

	/* Clear out bit map */
	for (count=0; count<32; count++)
		map[count] = 0;

	/* Set bits in control map */
	while (*ctrl)
	{
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
		ctrl++;
	}

#if ROUTINE == _STRSPN /*IFSTRIP=IGN*/

	/* 1st char NOT in control map stops search */
	if (*str)
	{
		count=0;
		while (map[*str >> 3] & (1 << (*str & 7)))
		{
			count++;
			str++;
		}
		return(count);
	}
	return(0);

#elif ROUTINE == _STRCSPN /*IFSTRIP=IGN*/

	/* 1st char in control map stops search */
	count=0;
	map[0] |= 1;	/* null chars not considered */
	while (!(map[*str >> 3] & (1 << (*str & 7))))
	{
		count++;
		str++;
	}
	return(count);

#else /* (ROUTINE == _STRPBRK) */

	/* 1st char in control map stops search */
	while (*str)
	{
		if (map[*str >> 3] & (1 << (*str & 7)))
			return((char *)str);
		str++;
	}
	return(NULL);

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strupr.c ===
/***
*strupr.c - routine to map lower-case characters in a string to upper-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the lower case characters in a string to upper case,
*       in place.
*
*Revision History:
*       05-31-89  JCR   C version created.
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-18-91  ETC   Locale support under _INTL switch.
*       12-08-91  ETC   Updated nlsapi; added multithread.
*       08-19-92  KRS   Activated NLS Support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building
*                       ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       03-10-93  CFW   Remove UNDONE comment.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-01-93  CFW   Simplify "C" locale test.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       10-07-93  CFW   Fix macro name.
*       11-09-93  CFW   Add code page for __crtxxx().
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt.
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for recovery from stack overflow around
*                       _alloca().
*       05-01-00  BWT   Fix Posix.
*       03-13-01  PML   Pass per-thread cp to __crtLCMapStringA (vs7#224974).
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <limits.h>     /* for INT_MAX */
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*char *_strupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*       _strupr() converts lower-case characters in a null-terminated string
*       to their upper-case equivalents.  Conversion is done in place and
*       characters other than lower-case letters are not modified.
*
*       In the C locale, this function modifies only 7-bit ASCII characters
*       in the range 0x61 through 0x7A ('a' through 'z').
*
*       If the locale is not the 'C' locale, LCMapString() is used to do
*       the work.  Assumes enough space in the string to hold result.
*
*Entry:
*       char *string - string to change to upper case
*
*Exit:
*       input string address
*
*Exceptions:
*       The original string is returned unchanged on any error.
*
*******************************************************************************/

char * __cdecl _strupr (
        char * string
        )
{
#if     !defined(_NTSUBSET_) && !defined(_POSIX_)

        int dstlen;                 /* len of dst string, with null  */
        unsigned char *dst;         /* destination string */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE )
#endif
        {
            char *cp;       /* traverses string for C locale conversion */

            for ( cp = string ; *cp ; ++cp )
                if ( ('a' <= *cp) && (*cp <= 'z') )
                    *cp -= 'a' - 'A';

            return(string);
        }   /* C locale */

        /* Inquire size of dst string */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                               LCMAP_UPPERCASE,
                                               string,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_codepage,
#else
                                               __lc_codepage,
#endif
                                               TRUE )) )
            return(string);

        /* Allocate space for dst */
        __try {
            dst = (unsigned char *)_alloca(dstlen * sizeof(unsigned char));
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            _resetstkoflw();
            dst = NULL;
        }

        if ( dst == NULL ) {
            dst = (unsigned char *)_malloc_crt(dstlen * sizeof(unsigned char));
            malloc_flag++;
        }

        /* Map src string to dst string in alternate case */
        if ( (dst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringA( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringA( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_UPPERCASE,
                                 string,
                                 -1,
                                 dst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage,
#else
                                 __lc_codepage,
#endif
                                 TRUE ) != 0) )
            /* copy dst string to return string */
            strcpy(string, dst);

        if ( malloc_flag )
            _free_crt(dst);

        return(string);

#else

        char * cp;

        for (cp=string; *cp; ++cp)
        {
            if ('a' <= *cp && *cp <= 'z')
                *cp += 'A' - 'a';
        }

        return(string);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strset.c ===
/***
*strset.c - sets all characters of string to given character
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _strset() - sets all of the characters in a string (except
*       the '\0') equal to a given character.
*
*Revision History:
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       08-14-90  SBM   Compiles cleanly with -W3
*       10-02-90  GJF   New-style function declarator.
*       01-18-91  GJF   ANSI naming.
*       09-03-93  GJF   Replaced _CALLTYPE1 with __cdecl.
*       12-03-93  GJF   _strset is an intrinsic in Alpha compiler!
*       03-01-94  GJF   Evidently on MIPS too (change taken from crt32, made
*                       there by Jeff Havens).
*       10-02-94  BWT   Add PPC support.
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>

#if     defined(_M_ALPHA) || defined(_M_MRX000) || defined(_M_PPC) || defined(_M_IA64)
#pragma function(_strset)
#endif

/***
*char *_strset(string, val) - sets all of string to val
*
*Purpose:
*       Sets all of characters in string (except the terminating '/0'
*       character) equal to val.
*
*
*Entry:
*       char *string - string to modify
*       char val - value to fill string with
*
*Exit:
*       returns string -- now filled with val's
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl _strset (
        char * string,
        int val
        )
{
        char *start = string;

        while (*string)
                *string++ = (char)val;

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strtok.c ===
/***
*strtok.c - tokenize a string with given delimiters
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines strtok() - breaks string into series of token
*	via repeated calls.
*
*Revision History:
*	06-01-89  JCR	C version created.
*	02-27-90  GJF	Fixed calling type, #include <cruntime.h>, fixed
*			copyright.
*	08-14-90  SBM	Removed now redundant #include <stddef.h>
*	10-02-90  GJF	New-style function declarator.
*	07-17-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	10-26-91  GJF	Fixed nasty bug - search for end-of-token could run
*			off the end of the string.
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	05-25-93  GJF	Revised to use unsigned char * pointers to access
*			the token and delimiter strings.
*	09-03-93  GJF	Replaced MTHREAD with _MT.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#ifdef	_MT
#include <mtdll.h>
#endif

/***
*char *strtok(string, control) - tokenize string with delimiter in control
*
*Purpose:
*	strtok considers the string to consist of a sequence of zero or more
*	text tokens separated by spans of one or more control chars. the first
*	call, with string specified, returns a pointer to the first char of the
*	first token, and will write a null char into string immediately
*	following the returned token. subsequent calls with zero for the first
*	argument (string) will work thru the string until no tokens remain. the
*	control string may be different from call to call. when no tokens remain
*	in string a NULL pointer is returned. remember the control chars with a
*	bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*	char *string - string to tokenize, or NULL to get next token
*	char *control - string of characters to use as delimiters
*
*Exit:
*	returns pointer to first token in string, or if string
*	was NULL, to next token
*	returns NULL when no more tokens remain.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strtok (
	char * string,
	const char * control
	)
{
	unsigned char *str;
	const unsigned char *ctrl = control;

	unsigned char map[32];
	int count;

#ifdef	_MT
	_ptiddata ptd = _getptd();
#else
	static char *nextoken;
#endif

	/* Clear control map */
	for (count = 0; count < 32; count++)
		map[count] = 0;

	/* Set bits in delimiter table */
	do {
		map[*ctrl >> 3] |= (1 << (*ctrl & 7));
	} while (*ctrl++);

	/* Initialize str. If string is NULL, set str to the saved
	 * pointer (i.e., continue breaking tokens out of the string
	 * from the last strtok call) */
	if (string)
		str = string;
	else
#ifdef	_MT
		str = ptd->_token;
#else
		str = nextoken;
#endif

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets str to point to the terminal
	 * null (*str == '\0') */
	while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
		str++;

	string = str;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *str ; str++ )
		if ( map[*str >> 3] & (1 << (*str & 7)) ) {
			*str++ = '\0';
			break;
		}

	/* Update nextoken (or the corresponding field in the per-thread data
	 * structure */
#ifdef	_MT
	ptd->_token = str;
#else
	nextoken = str;
#endif

	/* Determine if a token has been found. */
	if ( string == str )
		return NULL;
	else
		return string;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcscat.c ===
/***
*wcscat.c - contains wcscat() and wcscpy()
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcscat() appends one wchar_t string onto another.
*	wcscpy() copies one wchar_t string into another.
*
*	wcscat() concatenates (appends) a copy of the source string to the
*	end of the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*	wcscpy() copies the source string to the spot pointed to be
*	the destination string, returning the destination string.
*	Strings are wide-character strings.
*
*Revision History:
*	09-09-91  ETC	Created from strcat.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcscat(dst, src) - concatenate (append) one wchar_t string to another
*
*Purpose:
*	Concatenates src onto the end of dest.	Assumes enough
*	space in dest.
*
*Entry:
*	wchar_t *dst - wchar_t string to which "src" is to be appended
*	const wchar_t *src - wchar_t string to be appended to the end of "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcscat (
	wchar_t * dst,
	const wchar_t * src
	)
{
	wchar_t * cp = dst;

	while( *cp )
		cp++;			/* find end of dst */

	while( *cp++ = *src++ ) ;	/* Copy src to end of dst */

	return( dst );			/* return dst */

}


/***
*wchar_t *wcscpy(dst, src) - copy one wchar_t string over another
*
*Purpose:
*	Copies the wchar_t string src into the spot specified by
*	dest; assumes enough room.
*
*Entry:
*	wchar_t * dst - wchar_t string over which "src" is to be copied
*	const wchar_t * src - wchar_t string to be copied over "dst"
*
*Exit:
*	The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * __cdecl wcscpy(wchar_t * dst, const wchar_t * src)
{
	wchar_t * cp = dst;

	while( *cp++ = *src++ )
		;		/* Copy src over dst */

	return( dst );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcschr.c ===
/***
*wcschr.c - search a wchar_t string for a given wchar_t character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcschr() - search a wchar_t string for a wchar_t character
*
*Revision History:
*	09-09-91  ETC	Created from strchr.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcschr(string, c) - search a string for a wchar_t character
*
*Purpose:
*	Searches a wchar_t string for a given wchar_t character,
*	which may be the null character L'\0'.
*
*Entry:
*	wchar_t *string - wchar_t string to search in
*	wchar_t c - wchar_t character to search for
*
*Exit:
*	returns pointer to the first occurence of c in string
*	returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcschr (
	const wchar_t * string,
	wchar_t ch
	)
{
	while (*string && *string != (wchar_t)ch)
		string++;

	if (*string == (wchar_t)ch)
		return((wchar_t *)string);
	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\strxfrm.c ===
/***
*strxfrm.c - Transform a string using locale information
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       03-21-89  JCR   Module created.
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       02-27-90  GJF   Fixed calling type, #include <cruntime.h>, fixed
*                       copyright.
*       10-02-90  GJF   New-style function declarator.
*       10-02-91  ETC   Non-C locale support under _INTL switch.
*       12-09-91  ETC   Updated api; added multithread.
*       12-18-91  ETC   Don't convert output of LCMapString.
*       08-18-92  KRS   Activate NLS API.  Fix behavior.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-11-92  SKS   Need to handle count=0 in non-INTL code
*       12-15-92  KRS   Handle return value according to ANSI.
*       01-18-93  CFW   Removed unreferenced variable "dummy".
*       03-10-93  CFW   Remove UNDONE comment.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       09-06-94  CFW   Remove _INTL switch.
*       10-24-94  GJF   Sped up C locale, multi-thread case.
*       12-29-94  CFW   Merge non-Win32.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       03-17-97  RDK   Added error flag to __crtLCMapStringA.
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <malloc.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*size_t strxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the string pointer to by _string2 and place the
*       resulting string into the array pointer to by _string1.
*       No more than _count characters are place into the
*       resulting string (including the null).
*
*       The transformation is such that if strcmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of strcoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*       [ANSI]
*
*       The value of the following expression is the size of the array
*       needed to hold the transformation of the source string:
*
*           1 + strxfrm(NULL,string,0)
*
*       NOTE:  Currently, the C libraries support the "C" locale only.
*       Thus, strxfrm() simply resolves to strncpy()/strlen().
*
*Entry:
*       char *_string1       = result string
*       const char *_string2 = source string
*       size_t _count        = max chars to move
*
*       [If _count is 0, _string1 is permitted to be NULL.]
*
*Exit:
*       Length of the transformed string (not including the terminating
*       null).  If the value returned is >= _count, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl strxfrm (
        char *_string1,
        const char *_string2,
        size_t _count
        )
{
#ifdef  _NTSUBSET_
        if (_string1)
            strncpy(_string1, _string2, _count);
        return strlen(_string2);
#else
        int dstlen;
        int retval = INT_MAX;   /* NON-ANSI: default if OM or API error */
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( _count > INT_MAX )
            return (size_t)retval;

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( (ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE) &&
             (ptloci->lc_collate_cp == _CLOCALECP) )
#else

        if ( (__lc_handle[LC_COLLATE] == _CLOCALEHANDLE) &&
             (__lc_collate_cp == _CLOCALECP) )
#endif
        {
            strncpy(_string1, _string2, _count);
            return strlen(_string2);
        }

        /* Inquire size of dst string in BYTES */
#ifdef  _MT
        if ( 0 == (dstlen = __crtLCMapStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (dstlen = __crtLCMapStringA( __lc_handle[LC_COLLATE],
#endif
                                               LCMAP_SORTKEY,
                                               _string2,
                                               -1,
                                               NULL,
                                               0,
#ifdef  _MT
                                               ptloci->lc_collate_cp,
#else
                                               __lc_collate_cp,
#endif
                                               TRUE )) )
            goto error_cleanup;

        retval = dstlen;

        /* if not enough room, return amount needed */
        if ( dstlen > (int)_count )
            goto error_cleanup;

        /* Map src string to dst string */
#ifdef  _MT
        if ( 0 == __crtLCMapStringA( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == __crtLCMapStringA( __lc_handle[LC_COLLATE],
#endif
                                     LCMAP_SORTKEY,
                                     _string2,
                                     -1,
                                     _string1,
                                     (int)_count,
#ifdef  _MT
                                     ptloci->lc_collate_cp,
#else
                                     __lc_collate_cp,
#endif
                                     TRUE ) )
            retval = INT_MAX;

error_cleanup:
        return (size_t)retval;
#endif  /* _NTSUBSET_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcscspn.c ===
/***
*wcscspn.c - find length of initial substring of wide characters
*        not in a control string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcscspn()- finds the length of the initial substring of
*       a string consisting entirely of characters not in a control string
*       (wide-character strings).
*
*Revision History:
*       11-04-91  ETC   Created with source from crtdll.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-27-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*size_t wcscspn(string, control) - search for init substring w/o control wchars
*
*Purpose:
*       returns the index of the first character in string that belongs
*       to the set of characters specified by control.  This is equivalent
*       to the length of the length of the initial substring of string
*       composed entirely of characters not in control.  Null chars not
*       considered (wide-character strings).
*
*Entry:
*       wchar_t *string - string to search
*       wchar_t *control - set of characters not allowed in init substring
*
*Exit:
*       returns the index of the first wchar_t in string
*       that is in the set of characters specified by control.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcscspn (
        const wchar_t * string,
        const wchar_t * control
        )
{
        wchar_t *str = (wchar_t *) string;
        wchar_t *wcset;

        /* 1st char in control string stops search */
        while (*str) {
            for (wcset = (wchar_t *)control; *wcset; wcset++) {
                if (*wcset == *str) {
                    return (size_t)(str - string);
                }
            }
            str++;
        }
        return (size_t)(str - string);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsdup.c ===
/***
*wcsdup.c - duplicate a wide-character string in malloc'd memory
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsdup() - grab new memory, and duplicate the string into it
*	(wide-character).
*
*Revision History:
*	09-09-91  ETC	Created from strdup.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <malloc.h>
#include <string.h>

/***
*wchar_t *_wcsdup(string) - duplicate string into malloc'd memory
*
*Purpose:
*	Allocates enough storage via malloc() for a copy of the
*	string, copies the string into the new memory, and returns
*	a pointer to it (wide-character).
*
*Entry:
*	wchar_t *string - string to copy into new memory
*
*Exit:
*	returns a pointer to the newly allocated storage with the
*	string in it.
*
*	returns NULL if enough memory could not be allocated, or
*	string was NULL.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsdup (
	const wchar_t * string
	)
{
	wchar_t *memory;

	if (!string)
		return(NULL);

	if (memory = (wchar_t *) malloc((wcslen(string)+1) * sizeof(wchar_t)))
		return(wcscpy(memory,string));

	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsicmp.c ===
/***
*wcsicmp.c - contains case-insensitive wide string comp routine _wcsicmp
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wcsicmp()
*
*Revision History:
*       09-09-91  ETC   Created from stricmp.c.
*       12-09-91  ETC   Use C for neutral locale.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       08-19-92  KRS   Actived use of CompareStringW.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-15-92  KRS   Added robustness to non-_INTL code.  Optimize.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Remove locale-sensitive portion.
*       02-07-94  CFW   POSIXify.
*       10-25-94  GJF   Now works in non-C locales.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <setlocal.h>
#include <string.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int _wcsicmp(dst, src) - compare wide-character strings, ignore case
*
*Purpose:
*       _wcsicmp perform a case-insensitive wchar_t string comparision.
*       _wcsicmp is independent of locale.
*
*Entry:
*       wchar_t *dst, *src - strings to compare
*
*Return:
*       <0 if dst < src
*        0 if dst = src
*       >0 if dst > src
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _wcsicmp (
        const wchar_t * dst,
        const wchar_t * src
        )
{
        wchar_t f,l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifndef _NTSUBSET_
#ifdef  _MT
        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* _NTSUBSET_ */
            do  {
                f = __ascii_towlower(*dst);
                l = __ascii_towlower(*src);
                dst++;
                src++;
            } while ( (f) && (f == l) );
#ifndef _NTSUBSET_
        }
        else {
            do  {
#ifdef  _MT
                f = __towlower_mt( ptloci, (unsigned short)(*(dst++)) );
                l = __towlower_mt( ptloci, (unsigned short)(*(src++)) );
#else
                f = towlower( (unsigned short)(*(dst++)) );
                l = towlower( (unsigned short)(*(src++)) );
#endif
            } while ( (f) && (f == l) );
        }
#endif  /* _NTSUBSET_ */

        return (int)(f - l);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcslen.c ===
/***
*wcslen.c - contains wcslen() routine
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	wcslen returns the length of a null-terminated wide-character string,
*	not including the null wchar_t itself.
*
*Revision History:
*	09-09-91  ETC	Created from strlen.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wcslen - return the length of a null-terminated wide-character string
*
*Purpose:
*	Finds the length in wchar_t's of the given string, not including
*	the final null wchar_t (wide-characters).
*
*Entry:
*	const wchar_t * wcs - string whose length is to be computed
*
*Exit:
*	length of the string "wcs", exclusive of the final null wchar_t
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen (
	const wchar_t * wcs
	)
{
	const wchar_t *eos = wcs;

	while( *eos++ ) ;

	return( (size_t)(eos - wcs - 1) );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcscoll.c ===
/***
*wcscoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*
*Revision History:
*       09-09-91  ETC   Created from strcoll.c.
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int wcscoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       In the C locale, wcscmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl wcscoll (
        const wchar_t *_string1,
        const wchar_t *_string2
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else 
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
                return (wcscmp(_string1, _string2));

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_collate_cp)) )
#else
                                              __lc_collate_cp)) )
#endif
        {
                errno = EINVAL;
                return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return wcscmp(_string1, _string2);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcslwr.c ===
/***
*wcslwr.c - routine to map upper-case characters in a wchar_t string 
*       to lower-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the upper case characters in a wchar_t string 
*       to lower case, in place.
*
*Revision History:
*       09-09-91  ETC   Created from strlwr.c.
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       08-12-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*wchar_t *_wcslwr(string) - map upper-case characters in a string to lower-case
*
*Purpose:
*       wcslwr converts upper-case characters in a null-terminated wchar_t 
*       string to their lower-case equivalents.  The result may be longer or
*       shorter than the original string.  Assumes enough space in string
*       to hold the result.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to lower case
*
*Exit:
*       input string address
*
*Exceptions:
*       on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * __cdecl _wcslwr (
        wchar_t * wsrc
        )
{
#ifndef _NTSUBSET_

        wchar_t *p;             /* traverses string for C locale conversion */
        wchar_t *wdst;          /* wide version of string in alternate case */
        int dstlen;             /* len of wdst string, wide chars, with null */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
            for ( p = wsrc ; *p ; p++ )
                if ( (*p >= (wchar_t)L'A') && (*p <= (wchar_t)L'Z') )
                    *p -= L'A' - L'a';

            return(wsrc);
        }   /* C locale */

        /* Inquire size of wdst string */
#ifdef  _MT
        if ( (dstlen = __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
        if ( (dstlen = __crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                          LCMAP_LOWERCASE,
                                          wsrc,
                                          -1,
                                          NULL,
                                          0,
#ifdef  _MT
                                          ptloci->lc_codepage )) == 0 )
#else
                                          __lc_codepage )) == 0 )
#endif
            return(wsrc);

        /* Allocate space for wdst */
        __try {
            wdst = (wchar_t *)_alloca(dstlen * sizeof(wchar_t));
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            wdst = NULL;
        }

        if ( wdst == NULL ) {
            wdst = (wchar_t *)_malloc_crt(dstlen * sizeof(wchar_t));
            malloc_flag++;
        }

        /* Map wrc string to wide-character wdst string in alternate case */
        if ( (wdst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                LCMAP_LOWERCASE,
                                wsrc,
                                -1,
                                wdst,
                                dstlen,
#ifdef  _MT
                                ptloci->lc_codepage ) != 0) )
#else
                                __lc_codepage ) != 0) )
#endif
            /* Copy wdst string to user string */
            wcscpy(wsrc, wdst);

        if ( malloc_flag )
            _free_crt(wdst);
#else

        wchar_t * p;

        for (p=wsrc; *p; ++p)
        {
            if (L'A' <= *p && *p <= L'Z')
                *p += (wchar_t)L'a' - (wchar_t)L'A';
        }

#endif
        return(wsrc);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcscmp.c ===
/***
*wcscmp.c - routine to compare two wchar_t strings (for equal, less, or greater)
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Compares two wide-character strings, determining their lexical order.
*
*Revision History:
*	09-09-91  ETC	Created from strcmp.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wcscmp - compare two wchar_t strings,
*	 returning less than, equal to, or greater than
*
*Purpose:
*	wcscmp compares two wide-character strings and returns an integer
*	to indicate whether the first is less than the second, the two are
*	equal, or whether the first is greater than the second.
*
*	Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*	say that Null wchar_t(0) is less than any other character.
*
*Entry:
*	const wchar_t * src - string for left-hand side of comparison
*	const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*	returns -1 if src <  dst
*	returns  0 if src == dst
*	returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcscmp (
	const wchar_t * src,
	const wchar_t * dst
	)
{
	int ret = 0 ;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsicoll.c ===
/***
*wcsicoll.c - Collate wide-character locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*
*Revision History:
*       10-16-91  ETC   Created from wcscoll.c.
*       12-08-91  ETC   Added multithread lock.
*       04-06-92  KRS   Make work without _INTL also.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Error sets errno, cleanup.
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-29-93  GJF   Merged NT SDK and Cuda versions.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _wcsicoll() - Collate wide-character locale strings without regard to case
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       In the C locale, _wcsicmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsicoll (
        const wchar_t *_string1,
        const wchar_t *_string2
        )
{
#if     !defined(_NTSUBSET_)
        int ret;
        wchar_t f, l;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE ) {
#endif
            do  {
                f = __ascii_towlower(*_string1);
                l = __ascii_towlower(*_string2);
                _string1++;
                _string2++;
            } while ( (f) && (f == l) );

            return (int)(f - l);
        }

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              -1,
                                              _string2,
                                              -1,
#ifdef  _MT
                                              ptloci->lc_codepage )) )
#else
                                              __lc_codepage )) )
#endif
        {
                errno = EINVAL;
                return _NLSCMPERROR;
        }
    
        return (ret - 2);

#else

        return _wcsicmp(_string1, _string2);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsncmp.c ===
/***
*wcsncmp.c - compare first n characters of two wide-character strings
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncmp() - compare first n characters of two wchar_t strings
*	for lexical order.
*
*Revision History:
*	09-09-91  ETC	Created from strncmp.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*int wcsncmp(first, last, count) - compare first count chars of wchar_t strings
*
*Purpose:
*	Compares two strings for lexical order.  The comparison stops
*	after: (1) a difference between the strings is found, (2) the end
*	of the strings is reached, or (3) count characters have been
*	compared (wide-character strings).
*
*Entry:
*	wchar_t *first, *last - strings to compare
*	size_t count - maximum number of characters to compare
*
*Exit:
*	returns <0 if first < last
*	returns  0 if first == last
*	returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsncmp (
	const wchar_t * first,
	const wchar_t * last,
	size_t count
	)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return((int)(*first - *last));
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsncat.c ===
/***
*wcsncat.c - append n chars of string to new string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncat() - appends n characters of string onto
*	end of other string
*
*Revision History:
*	09-09-91  ETC	Created from strncat.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsncat(front, back, count) - append count chars of back onto front
*
*Purpose:
*	Appends at most count characters of the string back onto the
*	end of front, and ALWAYS terminates with a null character.
*	If count is greater than the length of back, the length of back
*	is used instead.  (Unlike wcsncpy, this routine does not pad out
*	to count characters).
*
*Entry:
*	wchar_t *front - string to append onto
*	wchar_t *back - string to append
*	size_t count - count of max characters to append
*
*Exit:
*	returns a pointer to string appended onto (front).
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsncat (
	wchar_t * front,
	const wchar_t * back,
	size_t count
	)
{
	wchar_t *start = front;

	while (*front++)
		;
	front--;

	while (count--)
		if (!(*front++ = *back++))
			return(start);

	*front = L'\0';
	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsnicmp.c ===
/***
*wcsnicmp.c - compare n chars of wide-character strings, ignoring case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _wcsnicmp() - Compares at most n characters of two wchar_t
*       strings, without regard to case.
*
*Revision History:
*       09-09-91  ETC   Created from strnicmp.c and wcsicmp.c.
*       12-09-91  ETC   Use C for neutral locale.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Remove locale-sensitive portion.
*       09-07-93  GJF   Fixed bug introduced on 4-14 (return value not was
*                       not well-defined if count == 0).
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Now works in non-C locales.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>

#ifdef _XBOX
#undef _MT
#endif

/***
*int _wcsnicmp(first, last, count) - compares count wchar_t of strings,
*       ignore case
*
*Purpose:
*       Compare the two strings for lexical order.  Stops the comparison
*       when the following occurs: (1) strings differ, (2) the end of the
*       strings is reached, or (3) count characters have been compared.
*       For the purposes of the comparison, upper case characters are
*       converted to lower case (wide-characters).
*
*Entry:
*       wchar_t *first, *last - strings to compare
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 if first < last
*        0 if first == last
*        1 if first > last
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _wcsnicmp (
        const wchar_t * first,
        const wchar_t * last,
        size_t count
        )
{
        wchar_t f,l;
        int result = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        if ( count ) {
#ifndef _NTSUBSET_
#ifdef  _MT
            if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
            if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
#endif  /* _NTSUBSET_ */
                do {
                    f = __ascii_towlower(*first);
                    l = __ascii_towlower(*last);
                    first++;
                    last++;
                } while ( (--count) && f && (f == l) );
#ifndef _NTSUBSET_
            }
            else {
                do {
#ifdef  _MT
                    f = __towlower_mt( ptloci, (unsigned short)(*(first++)) );
                    l = __towlower_mt( ptloci, (unsigned short)(*(last++)) );
#else
                    f = towlower( (unsigned short)(*(first++)) );
                    l = towlower( (unsigned short)(*(last++)) );
#endif
                } while ( (--count) && f && (f == l) );
            }
#endif  /* _NTSUBSET_ */

            result = (int)(f - l);
        }
        return result;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsncoll.c ===
/***
*wcsncoll.c - Collate wide-character locale strings
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information.
*       Compares at most n characters of two strings.
*
*Revision History:
*       05-09-94  CFW   Created from wcsnicoll.c.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-13-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _wcsncoll() - Collate wide-character locale strings
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       Compares at most n characters of two strings.
*       In the C locale, _wcsncmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsncoll (
        const wchar_t *_string1,
        const wchar_t *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifdef  _MT
        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
            return wcsncmp(_string1, _string2, count);

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }
    
        return (ret - 2);

#else

        return wcsncmp(_string1, _string2, count);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsncpy.c ===
/***
*wcsncpy.c - copy at most n characters of wide-character string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsncpy() - copy at most n characters of wchar_t string
*
*Revision History:
*	09-09-91  ETC	Created from strncpy.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*	Copies count characters from the source string to the
*	destination.  If count is less than the length of source,
*	NO NULL CHARACTER is put onto the end of the copied string.
*	If count is greater than the length of sources, dest is padded
*	with null characters to length count (wide-characters).
*
*
*Entry:
*	wchar_t *dest - pointer to destination
*	wchar_t *source - source string for copy
*	size_t count - max number of characters to copy
*
*Exit:
*	returns dest
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsncpy (
	wchar_t * dest,
	const wchar_t * source,
	size_t count
	)
{
	wchar_t *start = dest;

	while (count && (*dest++ = *source++))	  /* copy string */
		count--;

	if (count)				/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsnicol.c ===
/***
*wcsnicoll.c - Collate wide-character locale strings without regard to case
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*
*Revision History:
*       01-13-94  CFW   Created from wcsicoll.c.
*       02-07-94  CFW   POSIXify.
*       04-11-93  CFW   Change NLSCMPERROR to _NLCMPERROR.
*       05-09-94  CFW   Fix !_INTL case.
*       05-26-94  CFW   If count is zero, return EQUAL.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-30-95  GJF   Specify SORT_STRINGSORT to CompareString.
*       07-16-96  SKS   Added missing call to _unlock_locale()
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <mtdll.h>
#include <errno.h>
#include <awint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*int _wcsnicoll() - Collate wide-character locale strings without regard to case
*
*Purpose:
*       Compare two wchar_t strings using the locale LC_COLLATE information
*       without regard to case.
*       Compares at most n characters of two strings.
*       In the C locale, _wcsicmp() is used to make the comparison.
*
*Entry:
*       const wchar_t *s1 = pointer to the first string
*       const wchar_t *s2 = pointer to the second string
*       size_t count - maximum number of characters to compare
*
*Exit:
*       -1 = first string less than second string
*        0 = strings are equal
*        1 = first string greater than second string
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*       _NLSCMPERROR    = error
*       errno = EINVAL
*
*******************************************************************************/

int __cdecl _wcsnicoll (
        const wchar_t *_string1,
        const wchar_t *_string2,
        size_t count
        )
{
#if     !defined(_NTSUBSET_)

        int ret;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if (!count)
            return 0;

        if ( count > INT_MAX ) {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

#ifdef  _MT
        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else
        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        {
            wchar_t f, l;

            do {
                f = __ascii_towlower(*_string1);
                l = __ascii_towlower(*_string2);
                _string1++;
                _string2++;
            } while ( (--count) && f && (f == l) );

            return (int)(f - l);
        }

#ifdef  _MT
        if ( 0 == (ret = __crtCompareStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (ret = __crtCompareStringW( __lc_handle[LC_COLLATE],
#endif
                                              SORT_STRINGSORT | NORM_IGNORECASE,
                                              _string1,
                                              (int)count,
                                              _string2,
                                              (int)count,
#ifdef  _MT
                                              ptloci->lc_collate_cp )) )
#else
                                              __lc_collate_cp )) )
#endif
        {
            errno = EINVAL;
            return _NLSCMPERROR;
        }

        return (ret - 2);

#else

        return _wcsnicmp(_string1, _string2, count);

#endif
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsnset.c ===
/***
*wcsnset.c - set first n wide-characters to single wide-character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsnset() - sets at most the first n characters of a 
*	wchar_t string to a given character.
*
*Revision History:
*	09-09-91  ETC	Created from strnset.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsnset(string, val, count) - set at most count characters to val
*
*Purpose:
*	Sets the first count characters of string the character value.
*	If the length of string is less than count, the length of
*	string is used in place of n (wide-characters).
*
*Entry:
*	wchar_t *string - string to set characters in
*	wchar_t val - character to fill with
*	size_t count - count of characters to fill
*
*Exit:
*	returns string, now filled with count copies of val.
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsnset (
	wchar_t * string,
	wchar_t val,
	size_t count
	)
{
	wchar_t *start = string;

	while (count-- && *string)
		*string++ = (wchar_t)val;

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsrchr.c ===
/***
*wcsrchr.c - find last occurrence of wchar_t character in wide string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcsrchr() - find the last occurrence of a given character
*	in a string (wide-characters).
*
*Revision History:
*	09-09-91  ETC	Created from strrchr.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsrchr(string, ch) - find last occurrence of ch in wide string
*
*Purpose:
*	Finds the last occurrence of ch in string.  The terminating
*	null character is used as part of the search (wide-characters).
*
*Entry:
*	wchar_t *string - string to search in
*	wchar_t ch - character to search for
*
*Exit:
*	returns a pointer to the last occurrence of ch in the given
*	string
*	returns NULL if ch does not occurr in the string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsrchr (
	const wchar_t * string,
	wchar_t ch
	)
{
	wchar_t *start = (wchar_t *)string;

	while (*string++)			/* find end of string */
		;
						/* search towards front */
	while (--string != start && *string != (wchar_t)ch)
		;

	if (*string == (wchar_t)ch)		/* wchar_t found ? */
		return( (wchar_t *)string );

	return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcspbrk.c ===
/***
*wcspbrk.c - scans wide character string for a character from control string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcspbrk()- returns pointer to the first wide-character in
*	a wide-character string in the control string.
*
*Revision History:
*	11-04-91  ETC	Created with source from crtdll.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcspbrk(string, control) - scans string for a character from control
*
*Purpose:
*	Returns pointer to the first wide-character in
*	a wide-character string in the control string.
*
*Entry:
*	wchar_t *string - string to search in
*	wchar_t *control - string containing characters to search for
*
*Exit:
*	returns a pointer to the first character from control found
*	in string.
*	returns NULL if string and control have no characters in common.
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcspbrk (
	const wchar_t * string,
	const wchar_t * control
	)
{
        wchar_t *wcset;

        /* 1st char in control string stops search */
        while (*string) {
            for (wcset = (wchar_t *) control; *wcset; wcset++) {
                if (*wcset == *string) {
                    return (wchar_t *) string;
                }
            }
            string++;
        }
        return NULL;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsrev.c ===
/***
*wcsrev.c - reverse a wide-character string in place
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsrev() - reverse a wchar_t string in place (not including
*	L'\0' character)
*
*Revision History:
*	09-09-91  ETC	Created from strrev.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsrev(string) - reverse a wide-character string in place
*
*Purpose:
*	Reverses the order of characters in the string.  The terminating
*	null character remains in place (wide-characters).
*
*Entry:
*	wchar_t *string - string to reverse
*
*Exit:
*	returns string - now with reversed characters
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsrev (
	wchar_t * string
	)
{
	wchar_t *start = string;
	wchar_t *left = string;
	wchar_t ch;

	while (*string++)		  /* find end of string */
		;
	string -= 2;

	while (left < string)
	{
		ch = *left;
		*left++ = *string;
		*string-- = ch;
	}

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsset.c ===
/***
*wcsset.c - sets all characters of wchar_t string to given character
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines _wcsset() - sets all of the characters in a string (except
*	the L'\0') equal to a given character (wide-characters).
*
*Revision History:
*	09-09-91  ETC	Created from strset.c.
*	04-07-92  KRS	Updated and ripped out _INTL switches.
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *_wcsset(string, val) - sets all of string to val (wide-characters)
*
*Purpose:
*	Sets all of wchar_t characters in string (except the terminating '/0'
*	character) equal to val (wide-characters).
*
*
*Entry:
*	wchar_t *string - string to modify
*	wchar_t val - value to fill string with
*
*Exit:
*	returns string -- now filled with val's
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _wcsset (
	wchar_t * string,
	wchar_t val
	)
{
	wchar_t *start = string;

	while (*string)
		*string++ = (wchar_t)val;

	return(start);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsspn.c ===
/***
*wcsspn.c - find length of initial substring of chars from a control string
*       (wide-character strings)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcsspn() - finds the length of the initial substring of
*       a string consisting entirely of characters from a control string
*       (wide-character strings).
*
*Revision History:
*       11-04-91  ETC   Created with source from crtdll.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       02-27-98  RKP   Added 64 bit support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*int wcsspn(string, control) - find init substring of control chars
*
*Purpose:
*       Finds the index of the first character in string that does belong
*       to the set of characters specified by control.  This is
*       equivalent to the length of the initial substring of string that
*       consists entirely of characters from control.  The L'\0' character
*       that terminates control is not considered in the matching process
*       (wide-character strings).
*
*Entry:
*       wchar_t *string - string to search
*       wchar_t *control - string containing characters not to search for
*
*Exit:
*       returns index of first wchar_t in string not in control
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcsspn (
        const wchar_t * string,
        const wchar_t * control
        )
{
        wchar_t *str = (wchar_t *) string;
        wchar_t *ctl;

        /* 1st char not in control string stops search */
        while (*str) {
            for (ctl = (wchar_t *)control; *ctl != *str; ctl++) {
                if (*ctl == (wchar_t)0) {
                    /*
                     * reached end of control string without finding a match
                     */
                    return (size_t)(str - string);
                }
            }
            str++;
        }
        /*
         * The whole string consisted of characters from control
         */
        return (size_t)(str - string);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsstr.c ===
/***
*wcsstr.c - search for one wide-character string inside another
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines wcsstr() - search for one wchar_t string inside another
*
*Revision History:
*       09-09-91  ETC   Created from strstr.c.
*       04-07-92  KRS   Updated and ripped out _INTL switches.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       08-02-00  GB    fixed str2 = ""
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>

/***
*wchar_t *wcsstr(string1, string2) - search for string2 in string1 
*       (wide strings)
*
*Purpose:
*       finds the first occurrence of string2 in string1 (wide strings)
*
*Entry:
*       wchar_t *string1 - string to search in
*       wchar_t *string2 - string to search for
*
*Exit:
*       returns a pointer to the first occurrence of string2 in
*       string1, or NULL if string2 does not occur in string1
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsstr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;

        if ( !*wcs2)
            return (wchar_t *)wcs1;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                while ( *s1 && *s2 && !(*s1-*s2) )
                        s1++, s2++;

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcstok.c ===
/***
*wcstok.c - tokenize a wide-character string with given delimiters
*
*	Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines wcstok() - breaks wide-character string into series of token
*	via repeated calls.
*
*Revision History:
*	09-09-91  ETC	Created from strtok.c.
*	08-17-92  KRS	Activate multithread support.
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	09-27-93  CFW	Remove Cruiser support.
*	09-29-93  GJF	Replaced MTHREAD with _MT.
*       02-07-94  CFW   POSIXify.
*	09-06-94  CFW	Replace MTHREAD with _MT (again).
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#ifdef	_MT
#include <mtdll.h>
#endif

/***
*wchar_t *wcstok(string, control) - tokenize string with delimiter in control
*	(wide-characters)
*
*Purpose:
*	wcstok considers the string to consist of a sequence of zero or more
*	text tokens separated by spans of one or more control chars. the first
*	call, with string specified, returns a pointer to the first wchar_t of
*	the first token, and will write a null wchar_t into string immediately
*	following the returned token. subsequent calls with zero for the first
*	argument (string) will work thru the string until no tokens remain. the
*	control string may be different from call to call. when no tokens remain
*	in string a NULL pointer is returned. remember the control chars with a
*	bit map, one bit per wchar_t. the null wchar_t is always a control char
*	(wide-characters).
*
*Entry:
*	wchar_t *string - wchar_t string to tokenize, or NULL to get next token
*	wchar_t *control - wchar_t string of characters to use as delimiters
*
*Exit:
*	returns pointer to first token in string, or if string
*	was NULL, to next token
*	returns NULL when no more tokens remain.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcstok (
	wchar_t * string,
	const wchar_t * control
	)
{
	wchar_t *token;
	const wchar_t *ctl;

#ifdef	_MT

	_ptiddata ptd = _getptd();

#else

	static wchar_t *nextoken;

#endif

	/* If string==NULL, continue with previous string */
	if (!string)

#ifdef	_MT

		string = ptd->_wtoken;

#else

		string = nextoken;

#endif

	/* Find beginning of token (skip over leading delimiters). Note that
	 * there is no token iff this loop sets string to point to the terminal
	 * null (*string == '\0') */

	while (*string) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (!*ctl) break;
		string++;
	}

	token = string;

	/* Find the end of the token. If it is not the end of the string,
	 * put a null there. */
	for ( ; *string ; string++ ) {
		for (ctl=control; *ctl && *ctl != *string; ctl++)
			;
		if (*ctl) {
			*string++ = '\0';
			break;
		}
	}

	/* Update nextoken (or the corresponding field in the per-thread data
	 * structure */
#ifdef	_MT

	ptd->_wtoken = string;

#else

	nextoken = string;

#endif

	/* Determine if a token has been found. */
	if ( token == string )
		return NULL;
	else
		return token;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsupr.c ===
/***
*wcsupr.c - routine to map lower-case characters in a wchar_t string
*       to upper-case
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts all the lower case characters in a wchar_t string
*       to upper case, in place.
*
*Revision History:
*       09-09-91  ETC   Created from strupr.c and wcslwr.c
*       04-06-92  KRS   Make work without _INTL also.
*       08-19-92  KRS   Activate NLS support.
*       08-22-92  SRW   Allow INTL definition to be conditional for building ntcrt.lib
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       02-16-93  CFW   Optimize test for lowercase in "C" locale.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       06-02-93  SRW   ignore _INTL if _NTSUBSET_ defined.
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-16-93  GJF   Merged NT SDK and Cuda versions.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       11-09-93  CFW   Add code page for __crtxxx().
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       08-17-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       10-19-98  GJF   Major typo, = should have been ==
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
#include <ctype.h>
#include <setlocal.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*wchar_t *_wcsupr(string) - map lower-case characters in a string to upper-case
*
*Purpose:
*       wcsupr converts lower-case characters in a null-terminated wchar_t 
*       string to their upper-case equivalents.  The result may be longer or
*       shorter than the original string.  Assumes enough space in string
*       to hold the result.
*
*Entry:
*       wchar_t *wsrc - wchar_t string to change to upper case
*
*Exit:
*       input string address
*
*Exceptions:
*       on an error, the original string is unaltered
*
*******************************************************************************/

wchar_t * __cdecl _wcsupr (
        wchar_t * wsrc
        )
{
#ifndef _NTSUBSET_

        wchar_t *p;             /* traverses string for C locale conversion */
        wchar_t *wdst;          /* wide version of string in alternate case */
        int dstlen;             /* len of wdst string, wide chars, with null */
        int malloc_flag = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#else
        if ( __lc_handle[LC_CTYPE] == _CLOCALEHANDLE ) {
#endif
            for ( p = wsrc ; *p ; p++ )
            {
                if ( (*p >= (wchar_t)L'a') && (*p <= (wchar_t)L'z') )
                    *p = *p - (L'a' - L'A');
            }
            return(wsrc);
        }   /* C locale */


        /* Inquire size of wdst string */
#ifdef  _MT
        if ( (dstlen = __crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
        if ( (dstlen = __crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                          LCMAP_UPPERCASE,
                                          wsrc,
                                          -1,
                                          NULL,
                                          0,
#ifdef  _MT
                                          ptloci->lc_codepage )) == 0 )
#else
                                          __lc_codepage )) == 0 )
#endif
            return(wsrc);

        /* Allocate space for wdst */
        __try {
            wdst = (wchar_t *)_alloca(dstlen * sizeof(wchar_t));
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            wdst = NULL;
        }

        if ( wdst == NULL ) {
            wdst = (wchar_t *)_malloc_crt(dstlen * sizeof(wchar_t));
            malloc_flag++;
        }

        /* Map wrc string to wide-character wdst string in alternate case */
        if ( (wdst != NULL) &&
#ifdef  _MT
             (__crtLCMapStringW( ptloci->lc_handle[LC_CTYPE],
#else
             (__crtLCMapStringW( __lc_handle[LC_CTYPE],
#endif
                                 LCMAP_UPPERCASE,
                                 wsrc,
                                 -1,
                                 wdst,
                                 dstlen,
#ifdef  _MT
                                 ptloci->lc_codepage ) != 0) )
#else
                                 __lc_codepage ) != 0) )
#endif
            /* Copy wdst string to user string */
            wcscpy (wsrc, wdst);

        if ( malloc_flag )
            _free_crt(wdst);

#else

        wchar_t * p;

        for (p=wsrc; *p; ++p)
        {
                if (L'a' <= *p && *p <= L'z')
                        *p += (wchar_t)(L'A' - L'a');
        }


#endif
        return(wsrc);
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memcpy.asm ===
page    ,132
        title   memcpy - Copy source memory bytes to destination
;***
;memcpy.asm - contains memcpy and memmove routines
;
;       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are not treated specially, so propogation may occur.
;       memmove() copies a source memory buffer to a destination buffer.
;       Overlapping buffers are treated specially, to avoid propogation.
;
;Revision History:
;       02-06-87  JCR   Added memmove entry
;       04-08-87  JCR   Conditionalized memmove/memcpy entries
;       06-30-87  SKS   Rewritten for speed and size
;       08-21-87  SKS   Fix return value for overlapping copies
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-19-88  JCR   Minor 386 corrections/enhancements
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       11-13-92  SRW   Make it fast with unaligned arguments
;       09-26-96  RDK   Total rewrite to optimize for Pentium execution.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

M_EXIT  macro
ifdef   _STDCALL_
        ret     2*DPSIZE + ISIZE ; _stdcall return
else
        ret                     ; _cdecl return
endif
        endm    ; M_EXIT

        CODESEG

page
;***
;memcpy - Copy source buffer to destination buffer
;
;Purpose:
;       memcpy() copies a source memory buffer to a destination memory buffer.
;       This routine does NOT recognize overlapping buffers, and thus can lead
;       to propogation.
;       For cases where propogation must be avoided, memmove() must be used.
;
;       Algorithm:
;
;       void * memcpy(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               /*
;                * copy from lower addresses to higher addresses
;                */
;               while (count--)
;                       *dst++ = *src++;
;
;               return(ret);
;       }
;
;memmove - Copy source buffer to destination buffer
;
;Purpose:
;       memmove() copies a source memory buffer to a destination memory buffer.
;       This routine recognize overlapping buffers to avoid propogation.
;       For cases where propogation is not a problem, memcpy() can be used.
;
;   Algorithm:
;
;       void * memmove(void * dst, void * src, size_t count)
;       {
;               void * ret = dst;
;
;               if (dst <= src || dst >= (src + count)) {
;                       /*
;                        * Non-Overlapping Buffers
;                        * copy from lower addresses to higher addresses
;                        */
;                       while (count--)
;                               *dst++ = *src++;
;                       }
;               else {
;                       /*
;                        * Overlapping Buffers
;                        * copy from higher addresses to lower addresses
;                        */
;                       dst += count - 1;
;                       src += count - 1;
;
;                       while (count--)
;                               *dst-- = *src--;
;                       }
;
;               return(ret);
;       }
;
;
;Entry:
;       void *dst = pointer to destination buffer
;       const void *src = pointer to source buffer
;       size_t count = number of bytes to copy
;
;Exit:
;       Returns a pointer to the destination buffer in AX/DX:AX
;
;Uses:
;       CX, DX
;
;Exceptions:
;*******************************************************************************

ifdef   MEM_MOVE
        _MEM_     equ <memmove>
else
        _MEM_     equ <memcpy>
endif

%       public  _MEM_
_MEM_   proc \
        dst:ptr byte, \
        src:ptr byte, \
        count:IWORD

              ; destination pointer
              ; source pointer
              ; number of bytes to copy

;       push    ebp             ;U - save old frame pointer
;       mov     ebp, esp        ;V - set new frame pointer

        push    edi             ;U - save edi
        push    esi             ;V - save esi

        mov     esi,[src]       ;U - esi = source
        mov     ecx,[count]     ;V - ecx = number of bytes to move

        mov     edi,[dst]       ;U - edi = dest

;
; Check for overlapping buffers:
;       If (dst <= src) Or (dst >= src + Count) Then
;               Do normal (Upwards) Copy
;       Else
;               Do Downwards Copy to avoid propagation
;

        mov     eax,ecx         ;V - eax = byte count...

        mov     edx,ecx         ;U - edx = byte count...
        add     eax,esi         ;V - eax = point past source end

        cmp     edi,esi         ;U - dst <= src ?
        jbe     short CopyUp    ;V - yes, copy toward higher addresses

        cmp     edi,eax         ;U - dst < (src + count) ?
        jb      CopyDown        ;V - yes, copy toward lower addresses

;
; Copy toward higher addresses.
;
;
; The algorithm for forward moves is to align the destination to a dword
; boundary and so we can move dwords with an aligned destination.  This
; occurs in 3 steps.
;
;   - move x = ((4 - Dest & 3) & 3) bytes
;   - move y = ((L-x) >> 2) dwords
;   - move (L - x - y*4) bytes
;

CopyUp:
        test    edi,11b         ;U - destination dword aligned?
        jnz     short CopyLeadUp ;V - if we are not dword aligned already, align

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;
; Code to do optimal memory copies for non-dword-aligned destinations.
;

; The following length check is done for two reasons:
;
;    1. to ensure that the actual move length is greater than any possiale
;       alignment move, and
;
;    2. to skip the multiple move logic for small moves where it would
;       be faster to move the bytes with one instruction.
;

        align   @WordSize
CopyLeadUp:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        sub     ecx,4           ;U - check for really short string - sub for adjust
        jb      short ByteCopyUp ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        add     ecx,eax         ;V - update size after leading bytes copied

        jmp     dword ptr LeadUpVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyUp:
        jmp     dword ptr TrailUpVec[ecx*4+16] ;N - process just bytes

        align   @WordSize
CopyUnwindUp:
        jmp     dword ptr UnwindUpVec[ecx*4] ;N - unwind dword copy

        align   @WordSize
LeadUpVec       dd      LeadUp1, LeadUp2, LeadUp3

        align   @WordSize
LeadUp1:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        mov     [edi+1],al      ;U - write second byte to destination
        mov     al,[esi+2]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write third byte to destination

        add     esi,3           ;U - advance source pointer
        add     edi,3           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp2:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write second byte to destination

        add     esi,2           ;U - advance source pointer
        add     edi,2           ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadUp3:
        and     edx,ecx         ;U - trailing byte count
        mov     al,[esi]        ;V - get first byte from source

        mov     [edi],al        ;U - write second byte to destination
        inc     esi             ;V - advance source pointer

        shr     ecx,2           ;U - shift down to dword count
        inc     edi             ;V - advance destination pointer

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindUp ;V - if so, then jump

        rep     movsd           ;N - move all of our dwords

        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes
        
        align   @WordSize
UnwindUpVec     dd      UnwindUp0, UnwindUp1, UnwindUp2, UnwindUp3
                dd      UnwindUp4, UnwindUp5, UnwindUp6, UnwindUp7

UnwindUp7:
        mov     eax,[esi+ecx*4-28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4-28],eax ;U - put dword into destination
UnwindUp6:
        mov     eax,[esi+ecx*4-24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-24],eax ;U - put dword into destination
UnwindUp5:
        mov     eax,[esi+ecx*4-20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-20],eax ;U - put dword into destination
UnwindUp4:
        mov     eax,[esi+ecx*4-16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-16],eax ;U - put dword into destination
UnwindUp3:
        mov     eax,[esi+ecx*4-12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4-12],eax ;U - put dword into destination
UnwindUp2:
        mov     eax,[esi+ecx*4-8] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-8],eax ;U - put dword into destination
UnwindUp1:
        mov     eax,[esi+ecx*4-4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4-4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindUp0:
        jmp     dword ptr TrailUpVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailUpVec      dd      TrailUp0, TrailUp1, TrailUp2, TrailUp3

        align   @WordSize
TrailUp0:
        mov     eax,[dst]       ;U - return pointer to destination
        pop     esi             ;V - restore esi
        pop     edi             ;U - restore edi
                                ;V - spare
        M_EXIT

        align   @WordSize
TrailUp1:
        mov     al,[esi]        ;U - get byte from source
                                ;V - spare
        mov     [edi],al        ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp2:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailUp3:
        mov     al,[esi]        ;U - get first byte from source
                                ;V - spare
        mov     [edi],al        ;U - put first byte into destination
        mov     al,[esi+1]      ;V - get second byte from source
        mov     [edi+1],al      ;U - put second byte into destination
        mov     al,[esi+2]      ;V - get third byte from source
        mov     [edi+2],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------

;
; Copy down to avoid propogation in overlapping buffers.
;
        align   @WordSize
CopyDown:
        lea     esi,[esi+ecx-4] ;U - point to 4 bytes before src buffer end
        lea     edi,[edi+ecx-4] ;V - point to 4 bytes before dest buffer end
;
; See if the destination start is dword aligned
;

        test    edi,11b         ;U - test if dword aligned
        jnz     short CopyLeadDown ;V - if not, jump

        shr     ecx,2           ;U - shift down to dword count
        and     edx,11b         ;V - trailing byte count

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag back

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
CopyUnwindDown:
        neg     ecx             ;U - negate dword count for table merging
                                ;V - spare

        jmp     dword ptr UnwindDownVec[ecx*4+28] ;N - unwind copy

        align   @WordSize
CopyLeadDown:

        mov     eax,edi         ;U - get destination offset
        mov     edx,11b         ;V - prepare for mask

        cmp     ecx,4           ;U - check for really short string
        jb      short ByteCopyDown ;V - branch to just copy bytes

        and     eax,11b         ;U - get offset within first dword
        sub     ecx,eax         ;U - to update size after lead copied

        jmp     dword ptr LeadDownVec[eax*4-4] ;N - process leading bytes

        align   @WordSize
ByteCopyDown:
        jmp     dword ptr TrailDownVec[ecx*4] ;N - process just bytes

        align   @WordSize
LeadDownVec     dd      LeadDown1, LeadDown2, LeadDown3

        align   @WordSize
LeadDown1:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        dec     esi             ;V - point to last src dword

        shr     ecx,2           ;U - shift down to dword count
        dec     edi             ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes
        
        align   @WordSize
LeadDown2:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+2],al      ;V - write second byte to destination

        sub     esi,2           ;U - point to last src dword
        sub     edi,2           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      short CopyUnwindDown ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

        align   @WordSize
LeadDown3:
        mov     al,[esi+3]      ;U - load first byte
        and     edx,ecx         ;V - trailing byte count

        mov     [edi+3],al      ;U - write out first byte
        mov     al,[esi+2]      ;V - get second byte from source

        mov     [edi+2],al      ;U - write second byte to destination
        mov     al,[esi+1]      ;V - get third byte from source

        shr     ecx,2           ;U - shift down to dword count
        mov     [edi+1],al      ;V - write third byte to destination

        sub     esi,3           ;U - point to last src dword
        sub     edi,3           ;V - point to last dest dword

        cmp     ecx,8           ;U - test if small enough for unwind copy
        jb      CopyUnwindDown  ;V - if so, then jump

        std                     ;N - set direction flag
        rep     movsd           ;N - move all of our dwords
        cld                     ;N - clear direction flag

        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;------------------------------------------------------------------

        align   @WordSize
UnwindDownVec   dd      UnwindDown7, UnwindDown6, UnwindDown5, UnwindDown4
                dd      UnwindDown3, UnwindDown2, UnwindDown1, UnwindDown0

UnwindDown7:
        mov     eax,[esi+ecx*4+28] ;U - get dword from source
                                   ;V - spare
        mov     [edi+ecx*4+28],eax ;U - put dword into destination
UnwindDown6:
        mov     eax,[esi+ecx*4+24] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+24],eax ;U - put dword into destination
UnwindDown5:
        mov     eax,[esi+ecx*4+20] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+20],eax ;U - put dword into destination
UnwindDown4:
        mov     eax,[esi+ecx*4+16] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+16],eax ;U - put dword into destination
UnwindDown3:
        mov     eax,[esi+ecx*4+12] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+12],eax ;U - put dword into destination
UnwindDown2:
        mov     eax,[esi+ecx*4+8] ;U(entry)/V(not) - get dword from source
                                   ;V(entry) - spare
        mov     [edi+ecx*4+8],eax ;U - put dword into destination
UnwindDown1:
        mov     eax,[esi+ecx*4+4] ;U(entry)/V(not) - get dword from source
                                  ;V(entry) - spare
        mov     [edi+ecx*4+4],eax ;U - put dword into destination

        lea     eax,[ecx*4]     ;V - compute update for pointer

        add     esi,eax         ;U - update source pointer
        add     edi,eax         ;V - update destination pointer
UnwindDown0:
        jmp     dword ptr TrailDownVec[edx*4] ;N - process trailing bytes

;-----------------------------------------------------------------------------

        align   @WordSize
TrailDownVec    dd      TrailDown0, TrailDown1, TrailDown2, TrailDown3

        align   @WordSize
TrailDown0:
        mov     eax,[dst]       ;U - return pointer to destination
                                ;V - spare
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown1:
        mov     al,[esi+3]      ;U - get byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put byte in destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown2:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

        align   @WordSize
TrailDown3:
        mov     al,[esi+3]      ;U - get first byte from source
                                ;V - spare
        mov     [edi+3],al      ;U - put first byte into destination
        mov     al,[esi+2]      ;V - get second byte from source
        mov     [edi+2],al      ;U - put second byte into destination
        mov     al,[esi+1]      ;V - get third byte from source
        mov     [edi+1],al      ;U - put third byte into destination
        mov     eax,[dst]       ;V - return pointer to destination
        pop     esi             ;U - restore esi
        pop     edi             ;V - restore edi
        M_EXIT

_MEM_   endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memccpy.asm ===
page	,132
	title	memccpy - copy bytes until character found
;***
;memccpy.asm - copy bytes until a character is found
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _memccpy() - copies bytes until a specifed character
;	is found, or a maximum number of characters have been copied.
;
;Revision History:
;	05-16-84  RN	initial version
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 adjustments
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-17-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	10-27-92  SKS	Avoid using a MASM keyword ("C") as a parameter name
;	01-19-95  GJF	Faster version courtesy of Intel Israel.
;	01-24-95  GJF	Added FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_memccpy(dest, src, _c, count) - copy bytes until character found
;
;Purpose:
;	Copies bytes from src to dest until count bytes have been
;	copied, or up to and including the character _c, whichever
;	comes first.
;
;	Algorithm:
;	char *
;	_memccpy (dest, src, _c, count)
;	      char *dest, *src, _c;
;	      unsigned int count;
;	      {
;	      while (count && (*dest++ = *src++) != _c)
;		      count--;
;
;	      return(count ? dest : NULL);
;	      }
;
;Entry:
;	char *dest - pointer to memory to receive copy
;	char *src - source of bytes
;	char _c - character to stop copy at
;	int count - max number of bytes to copy
;
;Exit:
;	returns pointer to byte immediately after _c in dest;
;	returns NULL if _c was never found
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_memccpy
_memccpy proc

	.FPO	( 0, 4, 0, 0, 0, 0 )

	mov	ecx,[esp + 10h]	; ecx = max byte count
	push	ebx		; save ebx
 
	test	ecx,ecx 	; if it's nothing to move
	jz	ret_zero_len	; restore ebx, and return NULL
 
	mov	bh,[esp + 10h]	; bh = byte to look for
	push	esi		; save esi
 
	test	ecx,1		; test if counter is odd or even
 
	mov	eax,[esp + 0ch]	; eax = dest   , don't affect flags
	mov	esi,[esp + 10h]	; esi = source , don't affect flags
 
;	nop
	jz	lupe2		; if counter is even, do double loop
				; else do one iteration, and drop into double loop
	mov	bl,[esi]	; get first byte into bl
	inc	esi		; kick src (esi points to src)
 
	mov	[eax],bl	; store it in dest
	inc	eax		; kick dest
 
	cmp	bl,bh		; see if we just moved the byte
	je	short toend
 
	dec	ecx		; decriment counter
	jz	retnull		; drop into double loop if nonzero
 
lupe2:
	mov	bl,[esi]	; get first byte into bl
	add	esi,2		; kick esi (src)
 
	cmp	bl,bh		; check if we just moved the byte (from bl)
	je	toend_mov_inc	; store bl & exit
 
	mov	[eax],bl	; store first byte from bl
	mov	bl,[esi - 1]	; get second byte  into bl
 
	mov	[eax + 1],bl	; store second byte from bl
	add	eax,2		; kick eax (dest)
 
	cmp	bl,bh		; see if we just moved the byte
	je	short toend	; end of string
 
	sub	ecx,2		; modify counter, and if nonzero continue
	jnz	lupe2		; else drop out & return NULL
 
retnull:
	pop	esi
ret_zero_len:
	xor	eax,eax 	; null pointer
	pop	ebx
 
	ret			; _cdecl return
 
toend_mov_inc:
	mov	[eax],bl	; store first byte from bl
	inc	eax		; eax points rihgt after the value
 
toend:	pop	esi
	pop	ebx
 
	ret			; _cdecl return
 
_memccpy endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memchr.asm ===
page	,132
	title	memchr - search memory for a given character
;***
;memchr.asm - search block of memory for a given character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines memchr() - search memory until a character is
;	found or a limit is reached.
;
;Revision History:
;	05-16-84  RN	initial version
;	07-20-87  SKS	rewritten for speed
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-01-95  GJF	New, faster version from Intel!
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *memchr(buf, chr, cnt) - search memory for given character.
;
;Purpose:
;	Searched at buf for the given character, stopping when chr is
;	first found or cnt bytes have been searched through.
;
;	Algorithm:
;	char *
;	memchr (buf, chr, cnt)
;		char *buf;
;		int chr;
;		unsigned cnt;
;	{
;		while (cnt && *buf++ != c)
;			cnt--;
;		return(cnt ? --buf : NULL);
;	}
;
;Entry:
;	char *buf - memory buffer to be searched
;	char chr - character to search for
;	unsigned cnt - max number of bytes to search
;
;Exit:
;	returns pointer to first occurence of chr in buf
;	returns NULL if chr not found in the first cnt bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memchr
memchr	proc

	.FPO	( 0, 1, 0, 0, 0, 0 )

	mov	eax,[esp+0ch]	; eax = count
	push	ebx		; Preserve ebx

	test	eax,eax 	; check if count=0
	jz	short retnull	; if count=0, leave

	mov	edx,[esp+8]	; edx = buffer
	xor	ebx,ebx

	mov	bl,[esp+0ch]	; bl = search char

	test	edx,3		; test if string is aligned on 32 bits
	jz	short main_loop_start

str_misaligned: 		; simple byte loop until string is aligned
	mov	cl,byte ptr [edx]
	inc	edx
	xor	cl,bl
	je	short found
	dec	eax		; counter--
	jz	short retnull
	test	edx,3		; already aligned ?
	jne	short str_misaligned

main_loop_start:
	sub	eax,4
	jb	short tail_less_then_4

; set all 4 bytes of ebx to [value]
	push	edi		; Preserve edi
	mov	edi,ebx		; edi=0/0/0/char
	shl	ebx,8		; ebx=0/0/char/0
	add	ebx,edi		; ebx=0/0/char/char
	mov	edi,ebx		; edi=0/0/char/char
	shl	ebx,10h		; ebx=char/char/0/0
	add	ebx,edi		; ebx = all 4 bytes = [search char]
	jmp	short main_loop_entry	; ecx >=0

return_from_main:
	pop	edi

tail_less_then_4:
	add	eax,4
	jz	retnull

tail_loop:			; 0 < eax < 4
	mov	cl,byte ptr [edx]
	inc	edx
	xor	cl,bl
	je	short found
	dec	eax
	jnz	short tail_loop
retnull:
	pop	ebx
	ret			; _cdecl return

main_loop:
	sub	eax,4
	jb	short return_from_main
main_loop_entry:
	mov	ecx,dword ptr [edx]	; read 4 bytes

	xor	ecx,ebx		; ebx is byte\byte\byte\byte
	mov	edi,7efefeffh

	add	edi,ecx
	xor	ecx,-1

	xor	ecx,edi
	add	edx,4

	and	ecx,81010100h
	je	short main_loop

; found zero byte in the loop?
char_is_found:
	mov	ecx,[edx - 4]
	xor	cl,bl		; is it byte 0
	je	short byte_0
	xor	ch,bl		; is it byte 1
	je	short byte_1
	shr	ecx,10h		; is it byte 2
	xor	cl,bl
	je	short byte_2
        xor     ch,bl           ; is it byte 3
        je      short byte_3
	jmp	short main_loop ; taken if bits 24-30 are clear and bit
				; 31 is set

byte_3:
	pop	edi		; restore edi
found:
	lea	eax,[edx - 1]
	pop	ebx		; restore ebx
	ret			; _cdecl return

byte_2:
	lea	eax,[edx - 2]
	pop	edi
	pop	ebx
	ret			; _cdecl return

byte_1:
	lea	eax,[edx - 3]
	pop	edi
	pop	ebx
	ret			; _cdecl return

byte_0:
	lea	eax,[edx - 4]
	pop	edi		; restore edi
	pop	ebx		; restore ebx
	ret			; _cdecl return

memchr	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memcmp.asm ===
page	,132
	title	memcmp - compare to blocks of memory
;***
;memcmp.asm - compare two blocks of memory
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines memcmp() - compare two memory blocks lexically and
;	find their order.
;
;Revision History:
;	05-16-83  RN	initial version
;	07-20-87  SKS	rewritten for speed
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-01-95  GJF	New, faster version from Intel!
;	05-09-95  GJF	Replaced a bad ret with a good jz retnull (my editing
;			error, not Intel's).
;       11-06-95  GJF   Corrected order in which esi and edi are saved.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int memcmp(buf1, buf2, count) - compare memory for lexical order
;
;Purpose:
;	Compares count bytes of memory starting at buf1 and buf2
;	and find if equal or which one is first in lexical order.
;
;	Algorithm:
;	int
;	memcmp (buf1, buf2, count)
;		char *buf1, *buf2;
;		unsigned count;
;	{
;		if (!count)
;			return(0);
;		while (--count && *buf1 == *buf2)
;			{
;			buf1++;
;			buf2++;
;			}
;		return(*buf1 - *buf2);
;	}
;
;Entry:
;	char *buf1, *buf2 - pointers to memory sections to compare
;	unsigned count - length of sections to compare
;
;Exit:
;	returns -1 if buf1 < buf2
;	returns  0 if buf1 == buf2
;	returns +1 if buf1 > buf2
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memcmp
memcmp	proc

	.FPO	( 0, 3, 0, 0, 0, 0 )

	mov	eax,[esp+0ch]	; eax = counter
	test	eax,eax 	; test if counter is zero
	jz	short retnull	; return 0

	mov	edx,[esp+4]	; edx = buf1
	push	esi
	push	edi
	mov	esi,edx		; esi = buf1
	mov	edi,[esp+10h]	; edi = buf2

; Check for dword (32 bit) alignment
	or	edx,edi
	and	edx,3		; edx=0 iff buf1 are buf2 are aligned
	jz	short dwords
 
; Strings are not aligned. If the caller knows the strings (buf1 and buf2) are
; different, the function may be called with length like -1. The difference 
; may be found in the last dword of aligned string, and because the other 
; string is misaligned it may cause page fault. So, to be safe. the comparison
; must be done byte by byte.
	test	eax,1
	jz	short main_loop
 
	mov	cl,[esi]
	cmp	cl,[edi]
	jne	short not_equal
	inc	esi
	inc	edi
	dec	eax
	jz	short done	; eax is already 0

main_loop:
	mov	cl,[esi]
	mov	dl,[edi]
	cmp	cl,dl
	jne	short not_equal
 
	mov	cl,[esi+1]
	mov	dl,[edi+1]
	cmp	cl,dl
	jne	short not_equal
 
	add	edi,2
	add	esi,2
 
	sub	eax,2
	jnz	short main_loop
done:
	pop	edi
	pop	esi
retnull:
	ret			; _cdecl return
 
 
dwords:
	mov	ecx,eax
	and	eax,3		; eax= counter for tail loop
 
	shr	ecx,2
	jz	short tail_loop_start
				; counter was >=4 so may check one dword
	rep	cmpsd
 
	jz	short tail_loop_start
 
; in last dword was difference
	mov	ecx,[esi-4]	; load last dword from buf1 to ecx
	mov	edx,[edi-4]	; load last dword from buf2 to edx
	cmp	cl,dl		; test first bytes
	jne	short difference_in_tail
	cmp	ch,dh		; test seconds bytes
	jne	short difference_in_tail
	shr	ecx,10h
	shr	edx,10h
	cmp	cl,dl		; test third bytes
	jne	short difference_in_tail
	cmp	ch,dh		; they are different, but each one is bigger?
;	jmp	short difference_in_tail
 
difference_in_tail:
	mov	eax,0
				; buf1 < buf2 buf1 > buf2
not_equal:
	sbb	eax,eax		; AX=-1, CY=1 AX=0, CY=0
	pop	edi		; counter
	sbb	eax,-1		; AX=-1	AX=1
	pop	esi
	ret			; _cdecl return
 
; in tail loop we test last three bytes (esi and edi are aligned on dword
; boundary)
tail_loop_start:
 
	test	eax,eax 	; eax is counter%4 (number of bytes for tail
				; loop)
	jz	short done	; taken if there is no tail bytes
	mov	edx,[esi]	; load dword from buf1
	mov	ecx,[edi]	; load dword from buf2
	cmp	dl,cl		; test first bytes
	jne	short difference_in_tail
	dec	eax		; counter--
	jz	short tail_done
	cmp	dh,ch		; test second bytes
	jne	short difference_in_tail
	dec	eax		; counter--
	jz	short tail_done
	and	ecx,00ff0000h	; test third bytes
	and	edx,00ff0000h
	cmp	edx,ecx
	jne	short difference_in_tail
	dec	eax
tail_done:
	pop	edi
	pop	esi
	ret			; _cdecl return
 
memcmp	endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\wcsxfrm.c ===
/***
*wcsxfrm.c - Transform a wide-character string using locale information
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Transform a wide-character string using the locale information as set by
*       LC_COLLATE.
*
*Revision History:
*       09-09-91  ETC   Created from strxfrm.c.
*       12-09-91  ETC   Updated api; Added multithread lock.
*       12-18-91  ETC   Changed back LCMAP_SORTKEYA --> LCMAP_SORTKEY.
*       04-06-92  KRS   Fix so it works without _INTL too.
*       08-19-92  KRS   Activate use of NLS API.
*       09-02-92  SRW   Get _INTL definition via ..\crt32.def
*       12-15-92  KRS   Fix return value to match ANSI/ISO Std.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       09-22-93  CFW   Use __crtxxx internal NLS API wrapper.
*       09-23-93  CFW   Complete re-write. Non-C locale totally broken.
*       11-09-93  CFW   Use LC_COLLATE code page for __crtxxx() conversion.
*       02-07-94  CFW   POSIXify.
*       09-06-94  CFW   Remove _INTL switch.
*       10-25-94  GJF   Sped up C locale, multi-thread case.
*       01-10-95  CFW   Debug CRT allocs.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       10-11-95  BWT   Fix NTSUBSET
*       11-24-97  GJF   Removed bogus codepage determination.
*       01-12-98  GJF   Use _lc_collate_cp codepage.
*       07-16-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca instead of _malloc_crt if
*                       possible.
*       01-04-99  GJF   Changes for 64-bit size_t.
*       04-30-99  PML   Minor cleanup as part of 64-bit merge.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*       10-12-00  GB    Changed the function to be similar to strxfrm()
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <windows.h>
#include <string.h>
#include <limits.h>
#include <locale.h>
#include <setlocal.h>
#include <stdlib.h>
#include <mtdll.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>

#if defined(_XBOX) && !defined(_NTSUBSET_)
#define _NTSUBSET_
#endif

/***
*size_t wcsxfrm() - Transform a string using locale information
*
*Purpose:
*       Transform the wide string pointed to by _string2 and place the
*       resulting wide string into the array pointed to by _string1.
*       No more than _count wide characters are placed into the
*       resulting string (including the null).
*
*       The transformation is such that if wcscmp() is applied to
*       the two transformed strings, the return value is equal to
*       the result of wcscoll() applied to the two original strings.
*       Thus, the conversion must take the locale LC_COLLATE info
*       into account.
*
*       In the C locale, wcsxfrm() simply resolves to wcsncpy()/wcslen().
*
*Entry:
*       wchar_t *_string1       = result string
*       const wchar_t *_string2 = source string
*       size_t _count           = max wide chars to move
*
*       [If _count is 0, _string1 is permitted to be NULL.]
*
*Exit:
*       Length of the transformed string (not including the terminating
*       null).  If the value returned is >= _count, the contents of the
*       _string1 array are indeterminate.
*
*Exceptions:
*       Non-standard: if OM/API error, return INT_MAX.
*
*******************************************************************************/

size_t __cdecl wcsxfrm (
        wchar_t *_string1,
        const wchar_t *_string2,
        size_t _count
        )
{
#ifdef  _NTSUBSET_
        if (_string1)
            wcsncpy(_string1, _string2, _count);
        return wcslen(_string2);
#else
        int size = INT_MAX;
#ifdef  _MT
        pthreadlocinfo ptloci;
#endif

        if ( _count > INT_MAX )
            return (size_t)size;

#ifdef  _MT
        ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        if ( ptloci->lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#else

        if ( __lc_handle[LC_COLLATE] == _CLOCALEHANDLE )
#endif
        {
            wcsncpy(_string1, _string2, _count);
            return wcslen(_string2);
        }

#ifdef  _MT
        if ( 0 == (size = __crtLCMapStringW( ptloci->lc_handle[LC_COLLATE],
#else
        if ( 0 == (size = __crtLCMapStringW( __lc_handle[LC_COLLATE],
#endif
                                             LCMAP_SORTKEY,
                                             _string2,
                                             -1,
                                             NULL,
                                             0,
#ifdef  _MT
                                             ptloci->lc_collate_cp )) )
#else
                                             __lc_collate_cp )) )
#endif
        {
            size = INT_MAX;
        } else
        {
            if ( (size_t)size <= _count)
            {
#ifdef  _MT
                if ( 0 == (size = __crtLCMapStringW( ptloci->lc_handle[LC_COLLATE],
#else
                if ( 0 == (size = __crtLCMapStringW( __lc_handle[LC_COLLATE],
#endif
                                                     LCMAP_SORTKEY,
                                                     _string2,
                                                     -1,
                                                     (wchar_t *)_string1,
                                                     (int)_count,
#ifdef  _MT
                                                     ptloci->lc_collate_cp )) )
#else
                                                     __lc_collate_cp )) )
#endif
                {
                    size = INT_MAX; /* default error */
                }
            }
        }

        return (size_t)size;

#endif  /* _NTSUBSET_ */

}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memmove.asm ===
;***
;memmove.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	memmove() copies a source memory buffer to a destination buffer.
;	Overlapping buffers are treated specially, to avoid propogation.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

MEM_MOVE EQU 1
INCLUDE I386\MEMCPY.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strchr.asm ===
page    ,132
        title   strchr - search string for given character
;***
;strchr.asm - search a string for a given character
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strchr() - search a string for a character
;
;Revision History:
;       10-27-83  RN    initial version
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;	09-08-94  GJF	Smaller and faster.
;       11-28-95  GJF   Much faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strchr(string, chr) - search a string for a character
;
;Purpose:
;       Searches a string for a given character, which may be the
;       null character '\0'.
;
;       Algorithm:
;       char *
;       strchr (string, chr)
;       char *string, chr;
;       {
;         while (*string && *string != chr)
;             string++;
;         if (*string == chr)
;             return(string);
;         return((char *)0);
;       }
;
;Entry:
;       char *string - string to search in
;       char chr     - character to search for
;
;Exit:
;       returns pointer to the first occurence of c in string
;       returns NULL if chr does not occur in string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

found_bx:
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

        align   16
        public  strchr, __from_strstr_to_strchr
strchr  proc

	.FPO	( 0, 2, 0, 0, 0, 0 )

        xor     eax,eax
        mov     al,[esp + 8]        ; al = chr (search char)

__from_strstr_to_strchr label proc

        push    ebx                 ; PRESERVE EBX
        mov     ebx,eax             ; ebx = 0/0/0/chr
        shl     eax,8               ; eax = 0/0/chr/0
        mov     edx,[esp + 8]       ; edx = buffer
        test    edx,3               ; test if string is aligned on 32 bits
        jz      short main_loop_start

str_misaligned:                     ; simple byte loop until string is aligned
        mov     cl,[edx]
        inc     edx
        cmp     cl,bl
        je      short found_bx
        test    cl,cl
        jz      short retnull_bx
        test    edx,3               ; now aligned ?
        jne     short str_misaligned

main_loop_start:                    ; set all 4 bytes of ebx to [chr]
        or      ebx,eax             ; ebx = 0/0/chr/chr
        push    edi                 ; PRESERVE EDI
        mov     eax,ebx             ; eax = 0/0/chr/chr
        shl     ebx,10h             ; ebx = chr/chr/0/0
        push    esi                 ; PRESERVE ESI
        or      ebx,eax             ; ebx = all 4 bytes = [chr]

; in the main loop (below), we are looking for chr or for EOS (end of string)

main_loop:
        mov     ecx,[edx]           ; read  dword (4 bytes)
        mov     edi,7efefeffh       ; work with edi & ecx for looking for chr

        mov     eax,ecx             ; eax = dword
        mov     esi,edi             ; work with esi & eax for looking for EOS

        xor     ecx,ebx             ; eax = dword xor chr/chr/chr/chr
        add     esi,eax

        add     edi,ecx
        xor     ecx,-1

        xor     eax,-1
        xor     ecx,edi

        xor     eax,esi
        add     edx,4

        and     ecx,81010100h       ; test for chr
        jnz     short chr_is_found  ; chr probably has been found

        ; chr was not found, check for EOS

        and     eax,81010100h       ; is any flag set ??
        jz      short main_loop     ; EOS was not found, go get another dword

        and     eax,01010100h       ; is it in high byte?
        jnz     short retnull       ; no, definitely found EOS, return failure

        and     esi,80000000h       ; check was high byte 0 or 80h
        jnz     short main_loop     ; it just was 80h in high byte, go get 
                                    ; another dword
retnull:
        pop     esi
        pop     edi
retnull_bx:
        pop     ebx
        xor     eax,eax
        ret                         ; _cdecl return

chr_is_found:
        mov     eax,[edx - 4]       ; let's look one more time on this dword
        cmp     al,bl               ; is chr in byte 0?
        je      short byte_0
        test    al,al               ; test if low byte is 0
        je      retnull
        cmp     ah,bl               ; is it byte 1
        je      short byte_1
        test    ah,ah               ; found EOS ?
        je      retnull
        shr     eax,10h             ; is it byte 2
        cmp     al,bl
        je      short byte_2
        test    al,al               ; if in al some bits were set, bl!=bh
        je      retnull
        cmp     ah,bl
        je      short byte_3
        test    ah,ah
        jz      retnull
        jmp     short main_loop     ; neither chr nor EOS found, go get
                                    ; another dword
byte_3:
        pop     esi
        pop     edi
        lea     eax,[edx - 1]
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

byte_2:
        lea     eax,[edx - 2]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_1:
        lea     eax,[edx - 3]
        pop     esi
        pop     edi
        pop     ebx
        ret                         ; _cdecl return

byte_0:
        lea     eax,[edx - 4]
        pop     esi                 ; restore esi
        pop     edi                 ; restore edi
        pop     ebx                 ; restore ebx
        ret                         ; _cdecl return

strchr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strcspn.asm ===
;***
;strcspn.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

SSTRCSPN EQU 1
INCLUDE I386\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strcmp.asm ===
page	,132
	title	strcmp.asm - compare two strings
;***
;strcmp.asm - routine to compare two strings (for equal, less, or greater)
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCMP compares two strings and returns an integer
;	to indicate whether the first is less than the second, the two are
;	equal, or whether the first is greater than the second, respectively.
;	Comparison is done byte by byte on an UNSIGNED basis, which is to
;	say that Null (0) is less than any other character (1-255).
;
;Revision History:
;	04-21-87  SKS	Module rewritten to be fast and small
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	Minor 386 cleanup
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	05-26-93  GJF	Tuned for the 486.
;	06-14-93  GJF	Testing wrong byte of ax against 0 in one case.
;	06-16-93  GJF	Added .FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strcmp - compare two strings, returning less than, equal to, or greater than
;
;Purpose:
;	Compares two string, determining their lexical order.  Unsigned
;	comparison is used.
;
;	Algorithm:
;	   int strcmp ( src , dst )
;		   unsigned char *src;
;		   unsigned char *dst;
;	   {
;		   int ret = 0 ;
;
;		   while( ! (ret = *src - *dst) && *dst)
;			   ++src, ++dst;
;
;		   if ( ret < 0 )
;			   ret = -1 ;
;		   else if ( ret > 0 )
;			   ret = 1 ;
;
;		   return( ret );
;	   }
;
;Entry:
;	const char * src - string for left-hand side of comparison
;	const char * dst - string for right-hand side of comparison
;
;Exit:
;	AX < 0, 0, or >0, indicating whether the first string is
;	Less than, Equal to, or Greater than the second string.
;
;Uses:
;	CX, DX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strcmp
strcmp	proc

	.FPO	( 0, 2, 0, 0, 0, 0 )

	mov	edx,[esp + 4]	; edx = src
	mov	ecx,[esp + 8]	; ecx = dst

	test	edx,3
	jnz	short dopartial

	align	4
dodwords:
	mov	eax,[edx]

	cmp	al,[ecx]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 1]
	jne	short donene
	or	ah,ah
	jz	short doneeq

	shr	eax,16

	cmp	al,[ecx + 2]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 3]
	jne	short donene
	add	ecx,4
	add	edx,4
	or	ah,ah
	jnz	short dodwords

	align	4
doneeq:
	xor	eax,eax
	ret

	align	4
donene:
	; The instructions below should place -1 in eax if src < dst,
	; and 1 in eax if src > dst.

	sbb	eax,eax
	sal	eax,1
	inc	eax
	ret

	align	4
dopartial:
	test	edx,1
	jz	short doword

	mov	al,[edx]
	inc	edx
	cmp	al,[ecx]
	jne	short donene
	inc	ecx
	or	al,al
	jz	short doneeq

	test	edx,2
	jz	short dodwords


	align	4
doword:
	mov	ax,[edx]
	add	edx,2
	cmp	al,[ecx]
	jne	short donene
	or	al,al
	jz	short doneeq
	cmp	ah,[ecx + 1]
	jne	short donene
	or	ah,ah
	jz	short doneeq
	add	ecx,2
	jmp	short dodwords

strcmp	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strlen.asm ===
page	,132
	title	strlen - return the length of a null-terminated string
;***
;strlen.asm - contains strlen() routine
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	strlen returns the length of a null-terminated string,
;	not including the null byte itself.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Add 32 bit code, use cruntime vs cmacros
;	08-23-88  JCR	386 cleanup
;	10-05-88  GJF	Fixed off-by-2 error.
;	10-10-88  JCR	Minor improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	04-23-93  GJF	Tuned for the 486.
;	06-16-93  GJF	Added .FPO directive.
;	11-28-94  GJF	New, faster version from Intel.
;       11-28-95  GJF   Align main_loop on para boundary for 486 and P6
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;strlen - return the length of a null-terminated string
;
;Purpose:
;	Finds the length in bytes of the given string, not including
;	the final null character.
;
;	Algorithm:
;	int strlen (const char * str)
;	{
;	    int length = 0;
;
;	    while( *str++ )
;		    ++length;
;
;	    return( length );
;	}
;
;Entry:
;	const char * str - string whose length is to be computed
;
;Exit:
;	EAX = length of the string "str", exclusive of the final null byte
;
;Uses:
;	EAX, ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strlen

strlen	proc

	.FPO	( 0, 1, 0, 0, 0, 0 )
 
string  equ     [esp + 4]
 
        mov     ecx,string              ; ecx -> string
        test    ecx,3                   ; test if string is aligned on 32 bits
        je      short main_loop
 
str_misaligned:
        ; simple byte loop until string is aligned
        mov     al,byte ptr [ecx]
        inc     ecx
        test    al,al
        je      short byte_3
        test    ecx,3
        jne     short str_misaligned

	add	eax,dword ptr 0         ; 5 byte nop to align label below

	align	16                      ; should be redundant
 
main_loop:
        mov     eax,dword ptr [ecx]     ; read 4 bytes
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     ecx,4
        test    eax,81010100h
        je      short main_loop
        ; found zero byte in the loop
        mov     eax,[ecx - 4]
        test    al,al                   ; is it byte 0
        je      short byte_0
        test    ah,ah                   ; is it byte 1
        je      short byte_1
        test    eax,00ff0000h           ; is it byte 2
        je      short byte_2
	test	eax,0ff000000h		; is it byte 3
        je      short byte_3
	jmp	short main_loop 	; taken if bits 24-30 are clear and bit
                                        ; 31 is set
 
byte_3:
        lea     eax,[ecx - 1]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_2:
        lea     eax,[ecx - 2]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_1:
        lea     eax,[ecx - 3]
        mov     ecx,string
        sub     eax,ecx
        ret
byte_0:
        lea     eax,[ecx - 4]
        mov     ecx,string
        sub     eax,ecx
        ret
 
strlen  endp
 
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\memset.asm ===
page	,132
	title	memset - set sections of memory all to one byte
;***
;memset.asm - set a section of memory to all one byte
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	contains the memset() routine
;
;Revision History:
;	05-07-84  RN	initial version
;	06-30-87  SKS	faster algorithm
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-19-88  JCR	Enable word alignment code for all models/CPUs,
;			Some code improvement
;	10-25-88  JCR	General cleanup for 386-only code
;	10-27-88  JCR	More optimization (dword alignment, no ebx usage, etc)
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	01-23-95  GJF	Improved routine from Intel Israel. I fixed up the
;			formatting and comments.
;	01-24-95  GJF	Added FPO directive.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *memset(dst, value, count) - sets "count" bytes at "dst" to "value"
;
;Purpose:
;	Sets the first "count" bytes of the memory starting
;	at "dst" to the character value "value".
;
;	Algorithm:
;	char *
;	memset (dst, value, count)
;		char *dst;
;		char value;
;		unsigned int count;
;		{
;		char *start = dst;
;
;		while (count--)
;			*dst++ = value;
;		return(start);
;		}
;
;Entry:
;	char *dst - pointer to memory to fill with value
;	char value - value to put in dst bytes
;	int count - number of bytes of dst to fill
;
;Exit:
;	returns dst, with filled bytes
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	memset
memset proc

	.FPO	( 0, 3, 0, 0, 0, 0 )

	mov	edx,[esp + 0ch]	; edx = "count"
	mov	ecx,[esp + 4]	; ecx points to "dst"
 
	test	edx,edx 	; 0?
	jz	short toend	; if so, nothing to do
 
	xor	eax,eax
	mov	al,[esp + 8]	; the byte "value" to be stored
 
 
; Align address on dword boundary
 
	push	edi		; preserve edi
	mov	edi,ecx		; edi = dest pointer
 
	cmp	edx,4		; if it's less then 4 bytes
	jb	tail		; tail needs edi and edx to be initialized
 
	neg	ecx
	and	ecx,3		; ecx = # bytes before dword boundary
	jz	short dwords	; jump if address already aligned
 
	sub	edx,ecx		; edx = adjusted count (for later)
adjust_loop:
	mov	[edi],al
	inc	edi
	dec	ecx
	jnz	adjust_loop
 
dwords:
; set all 4 bytes of eax to [value]
	mov	ecx,eax		; ecx=0/0/0/value
	shl	eax,8		; eax=0/0/value/0
 
	add	eax,ecx		; eax=0/0val/val
 
	mov	ecx,eax		; ecx=0/0/val/val
 
	shl	eax,10h		; eax=val/val/0/0
 
	add	eax,ecx		; eax = all 4 bytes = [value]
 
; Set dword-sized blocks
	mov	ecx,edx		; move original count to ecx
	and	edx,3		; prepare in edx byte count (for tail loop)
	shr	ecx,2		; adjust ecx to be dword count
	jz	tail		; jump if it was less then 4 bytes
 
	rep	stosd
main_loop_tail:
	test	edx,edx 	; if there is no tail bytes,
	jz	finish		; we finish, and it's time to leave
; Set remaining bytes
 
tail:
	mov	[edi],al	; set remaining bytes
	inc	edi
 
	dec	edx		; if there is some more bytes
	jnz	tail		; continue to fill them
 
; Done
finish:
	mov	eax,[esp + 8]	; return dest pointer
	pop	edi		; restore edi

	ret

toend:
	mov	eax,[esp + 4]	; return dest pointer
 
	ret
 
memset	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strcat.asm ===
page	,132
	title	strcat - concatenate (append) one string to another
;***
;strcat.asm - contains strcat() and strcpy() routines
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	STRCAT concatenates (appends) a copy of the source string to the
;	end of the destination string, returning the destination string.
;
;Revision History:
;	04-21-87  SKS	Rewritten to be fast and small, added file header
;	05-17-88  SJM	Add model-independent (large model) ifdef
;	07-27-88  SJM	Rewritten to be 386-specific and to include strcpy
;	08-29-88  JCR	386 cleanup...
;	10-07-88  JCR	Correct off-by-1 strcat bug; optimize ecx=-1
;	10-25-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	04-23-93  GJF	Tuned for the 486.
;	04-30-93  GJF	If (4*K + 1)-st char was null, didn't copy/cat it
;			it properly.
;	06-16-93  GJF	Added .FPO directive.
;	05-01-95  GJF	New, faster version from Intel!
;       11-13-95  GJF   Aligned strcat on paragraph boundary.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list


page
;***
;char *strcat(dst, src) - concatenate (append) one string to another
;
;Purpose:
;	Concatenates src onto the end of dest.	Assumes enough
;	space in dest.
;
;	Algorithm:
;	char * strcat (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp )
;		    ++cp;	    /* Find end of dst */
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src to end of dst */
;	    return( dst );
;	}
;
;Entry:
;	char *dst - string to which "src" is to be appended
;	const char *src - string to be appended to the end of "dst"
;
;Exit:
;	The address of "dst" in EAX
;
;Uses:
;	EAX, ECX
;
;Exceptions:
;
;*******************************************************************************

page
;***
;char *strcpy(dst, src) - copy one string over another
;
;Purpose:
;	Copies the string src into the spot specified by
;	dest; assumes enough room.
;
;	Algorithm:
;	char * strcpy (char * dst, char * src)
;	{
;	    char * cp = dst;
;
;	    while( *cp++ = *src++ )
;		    ;		    /* Copy src over dst */
;	    return( dst );
;	}
;
;Entry:
;	char * dst - string over which "src" is to be copied
;	const char * src - string to be copied over "dst"
;
;Exit:
;	The address of "dst" in EAX
;
;Uses:
;	EAX, ECX
;
;Exceptions:
;*******************************************************************************

 
	CODESEG

%	public	strcat, strcpy	    ; make both functions available
strcpy	proc
	push	edi		    ; preserve edi
	mov	edi,[esp+8]	    ; edi points to dest string
	jmp	short copy_start

strcpy	endp

	align	16

strcat	proc
 
	.FPO	( 0, 2, 0, 0, 0, 0 )
 
	mov	ecx,[esp+4]	    ; ecx -> dest string
	push	edi		    ; preserve edi
	test	ecx,3		    ; test if string is aligned on 32 bits
	je	short find_end_of_dest_string_loop
 
dest_misaligned:		    ; simple byte loop until string is aligned
	mov	al,byte ptr [ecx]
	inc	ecx
	test	al,al
	je	short start_byte_3
	test	ecx,3
	jne	short dest_misaligned
 
	align	4
 
find_end_of_dest_string_loop:
	mov	eax,dword ptr [ecx] ; read 4 bytes
	mov	edx,7efefeffh
	add	edx,eax
	xor	eax,-1
	xor	eax,edx
	add	ecx,4
	test	eax,81010100h
	je	short find_end_of_dest_string_loop
	; found zero byte in the loop
	mov	eax,[ecx - 4]
	test	al,al		    ; is it byte 0
	je	short start_byte_0
	test	ah,ah		    ; is it byte 1
	je	short start_byte_1
	test	eax,00ff0000h	    ; is it byte 2
	je	short start_byte_2
	test	eax,0ff000000h	    ; is it byte 3
	je	short start_byte_3
	jmp	short find_end_of_dest_string_loop
				    ; taken if bits 24-30 are clear and bit
				    ; 31 is set
start_byte_3:
	lea	edi,[ecx - 1]
	jmp	short copy_start
start_byte_2:
	lea	edi,[ecx - 2]
	jmp	short copy_start
start_byte_1:
	lea	edi,[ecx - 3]
	jmp	short copy_start
start_byte_0:
	lea	edi,[ecx - 4]
;	jmp	short copy_start
 
;	edi points to the end of dest string.
copy_start::
	mov	ecx,[esp+0ch]	    ; ecx -> sorc string
	test	ecx,3		    ; test if string is aligned on 32 bits
	je	short main_loop_entrance
 
src_misaligned: 		    ; simple byte loop until string is aligned
	mov	dl,byte ptr [ecx]
	inc	ecx
	test	dl,dl
	je	short byte_0
	mov	[edi],dl
	inc	edi
	test	ecx,3
	jne	short src_misaligned
	jmp	short main_loop_entrance
 
main_loop:			    ; edx contains first dword of sorc string
	mov	[edi],edx	    ; store one more dword
	add	edi,4		    ; kick dest pointer
main_loop_entrance:
	mov	edx,7efefeffh
	mov	eax,dword ptr [ecx] ; read 4 bytes
 
	add	edx,eax
	xor	eax,-1
 
	xor	eax,edx
	mov	edx,[ecx]	    ; it's in cache now
 
	add	ecx,4		    ; kick dest pointer
	test	eax,81010100h
 
	je	short main_loop
	; found zero byte in the loop
; main_loop_end:
	test	dl,dl		    ; is it byte 0
	je	short byte_0
	test	dh,dh		    ; is it byte 1
	je	short byte_1
	test	edx,00ff0000h	    ; is it byte 2
	je	short byte_2
	test	edx,0ff000000h	    ; is it byte 3
	je	short byte_3
	jmp	short main_loop	    ; taken if bits 24-30 are clear and bit
				    ; 31 is set
byte_3:
	mov	[edi],edx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
byte_2:
	mov	[edi],dx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	mov	byte ptr [edi+2],0
	pop	edi
	ret
byte_1:
	mov	[edi],dx
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
byte_0:
	mov	[edi],dl
	mov	eax,[esp+8]	    ; return in eax pointer to dest string
	pop	edi
	ret
 
strcat	endp
 
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strncat.asm ===
page    ,132
        title   strncat - append n chars of string1 to string2
;***
;strncat.asm - append n chars of string to new string
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncat() - appends n characters of string onto
;       end of other string
;
;Revision History:
;       10-25-83  RN    initial version
;       08-05-87  SKS   Fixed bug: extra null was stored if n > strlen(back)
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Minor 386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-15-96  GJF   Faster version from Intel.
;       12-19-96  GJF   Fixed bugs in Intel code
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncat(front, back, count) - append count chars of back onto front
;
;Purpose:
;       Appends at most count characters of the string back onto the
;       end of front, and ALWAYS terminates with a null character.
;       If count is greater than the length of back, the length of back
;       is used instead.  (Unlike strncpy, this routine does not pad out
;       to count characters).
;
;       Algorithm:
;       char *
;       strncat (front, back, count)
;           char *front, *back;
;           unsigned count;
;       {
;           char *start = front;
;
;           while (*front++)
;               ;
;           front--;
;           while (count--)
;               if (!(*front++ = *back++))
;                   return(start);
;           *front = '\0';
;           return(start);
;       }
;
;Entry:
;       char *   front - string to append onto
;       char *   back  - string to append
;       unsigned count - count of max characters to append
;
;Exit:
;       returns a pointer to string appended onto (front).
;
;Uses:  ECX, EDX
;
;Exceptions:
;
;*******************************************************************************

    CODESEG

    public  strncat
strncat proc
;   front:ptr byte,
;   back:ptr byte,
;   count:IWORD

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx
        jz      finish              ; leave if count is zero

        mov     edi,[esp + 8]       ; edi -> front string
        push    esi                 ; preserve esi
        test    edi,3               ; is string aligned on dword (4 bytes)
        push    ebx                 ; preserve ebx
        je      short find_end_of_front_string_loop

        ; simple byte loop until string is aligned

front_misaligned:
        mov     al,byte ptr [edi]
        inc     edi
        test    al,al
        je      short start_byte_3
        test    edi,3
        jne     short front_misaligned

find_end_of_front_string_loop:
        mov     eax,dword ptr [edi] ; read dword (4 bytes)
        mov     edx,7efefeffh
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        add     edi,4
        test    eax,81010100h
        je      short find_end_of_front_string_loop

; found zero byte in the loop
        mov     eax,[edi - 4]
        test    al,al               ; is it byte 0
        je      short start_byte_0
        test    ah,ah               ; is it byte 1
        je      short start_byte_1
        test    eax,00ff0000h       ; is it byte 2
        je      short start_byte_2
        test    eax,0ff000000h      ; is it byte 3
        jne     short find_end_of_front_string_loop
                                    ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
start_byte_3:
        dec     edi
        jmp     short copy_start
start_byte_2:
        sub     edi,2
        jmp     short copy_start
start_byte_1:
        sub     edi,3
        jmp     short copy_start
start_byte_0:
        sub     edi,4

; edi now points to the end of front string.

copy_start:
        mov     esi,[esp + 14h]     ; esi -> back string
        test    esi,3               ; is back string is dword aligned?
        jnz     back_misaligned

        mov     ebx,ecx             ; store count for tail loop

        shr     ecx,2
        jnz     short main_loop_entrance
        jmp     short tail_loop_start   ; 0 < counter < 4

; simple byte loop until back string is aligned

back_misaligned:
        mov     dl,byte ptr [esi]
        inc     esi
        test    dl,dl
        je      short byte_0
        mov     [edi],dl
        inc     edi
        dec     ecx
        jz      empty_counter
        test    esi,3
        jne     short back_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2               ; convert ecx to dword count
        jnz     short main_loop_entrance

tail_loop_start:
        mov     ecx,ebx 
        and     ecx,3               ; ecx = count of leftover bytes after the
                                    ; dwords have been concatenated
        jz      empty_counter

tail_loop:
        mov     dl,byte ptr [esi]
        inc     esi
        mov     [edi],dl
        inc     edi
        test    dl,dl
        je      short finish1       ; '\0' was already copied
        dec     ecx
        jnz     tail_loop

empty_counter:
        mov     [edi],cl            ; cl=0;
finish1:
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to front string
        pop     edi
        ret                         ; _cdecl return


byte_0:
        mov     [edi],dl
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return


main_loop:                          ; edx contains first dword of back string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick pointer to front string

        dec     ecx
        jz      tail_loop_start
main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes

        add     edx,eax
        xor     eax,-1

        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now

        add     esi,4               ; kick pointer to back string
        test    eax,81010100h

        je      short main_loop

; may be found zero byte in the loop
        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne short main_loop         ; taken if bits 24-30 are clear and bit
                                    ; 31 is set
byte_3:
        mov     [edi],edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_2:
        mov     [edi],dx
        xor     edx,edx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        mov     [edi + 2],dl
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

byte_1:
        mov     [edi],dx
        mov     eax,[esp + 10h]     ; return in eax pointer to front string
        pop     ebx
        pop     esi
        pop     edi
        ret                         ; _cdecl return

strncat endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strncmp.asm ===
page	,132
	title	strncmp - compare first n chars of two strings
;***
;strncmp.asm - compare first n characters of two strings
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strncmp() - compare first n characters of two strings
;	for lexical order.
;
;Revision History:
;	10-26-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int strncmp(first, last, count) - compare first count chars of strings
;
;Purpose:
;	Compares two strings for lexical order.  The comparison stops
;	after: (1) a difference between the strings is found, (2) the end
;	of the strings is reached, or (3) count characters have been
;	compared.
;
;	Algorithm:
;	int
;	strncmp (first, last, count)
;	      char *first, *last;
;	      unsigned count;
;	      {
;	      if (!count)
;		      return(0);
;	      while (--count && *first && *first == *last)
;		      {
;		      first++;
;		      last++;
;		      }
;	      return(*first - *last);
;	      }
;
;Entry:
;	char *first, *last - strings to compare
;	unsigned count - maximum number of characters to compare
;
;Exit:
;	returns <0 if first < last
;	returns 0 if first == last
;	returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strncmp
strncmp proc \
	uses edi esi ebx, \
	first:ptr byte, \
	last:ptr byte, \
	count:IWORD


	mov	ecx,[count]	; cx=max number of bytes to compare
	jecxz	short toend	; it's as if strings are equal

	mov	ebx,ecx 	; bx saves count

	mov	edi,[first]	; di=first pointer (es=segment part)

	mov	esi,edi 	; si saves first pointer
	xor	eax,eax 	; ax=0
repne	scasb			; count bytes
	neg	ecx		; cx=count - strlen
	add	ecx,ebx 	; strlen + count - strlen

okay:
	mov	edi,esi 	; restore first pointer
	mov	esi,[last]	; si = last pointer
repe	cmpsb			; compare strings
	mov	al,[esi-1]
	xor	ecx,ecx 	; set return value = 0

	cmp	al,[edi-1]	; last-first
	ja	short lastbig	; <last is bigger>
	je	short toend	; <equal>
	;jb	short firstbig	; <first is bigger>

firstbig:
	dec	ecx		; first string is bigger
	dec	ecx		; make FFFE so 'not' will give 0001

lastbig:			; last string is bigger
	not	ecx		; return -1

toend:
	mov	eax,ecx 	; return value

ifdef	_STDCALL_
	ret	2*DPSIZE + ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

strncmp endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strncpy.asm ===
page    ,132
        title   strncpy - copy at most n characters of string
;***
;strncpy.asm - copy at most n characters of string
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strncpy() - copy at most n characters of string
;
;Revision History:
;       10-25-83  RN    initial version
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       10-26-88  JCR   Re-arrange regs to avoid push/pop ebx
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-20-96  GJF   Faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strncpy(dest, source, count) - copy at most n characters
;
;Purpose:
;       Copies count characters from the source string to the
;       destination.  If count is less than the length of source,
;       NO NULL CHARACTER is put onto the end of the copied string.
;       If count is greater than the length of sources, dest is padded
;       with null characters to length count.
;
;       Algorithm:
;       char *
;       strncpy (dest, source, count)
;       char *dest, *source;
;       unsigned count;
;       {
;         char *start = dest;
;
;         while (count && (*dest++ = *source++))
;             count--;
;         if (count)
;             while (--count)
;                 *dest++ = '\0';
;         return(start);
;       }
;
;Entry:
;       char *dest     - pointer to spot to copy source, enough space
;                        is assumed.
;       char *source   - source string for copy
;       unsigned count - characters to copy
;
;Exit:
;       returns dest, with the character copied there.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  strncpy
strncpy proc

        .FPO    ( 0, 3, 0, 0, 0, 0 )

        mov     ecx,[esp + 0ch]     ; ecx = count
        push    edi                 ; preserve edi
        test    ecx,ecx         
        jz      short finish        ; leave if count is zero

        push    esi                 ; preserve edi
        push    ebx                 ; preserve ebx
        mov     ebx,ecx             ; store count for tail loop
        mov     esi,[esp + 14h]     ; esi -> source string
        test    esi,3               ; test if source string is aligned on 32 bits
        mov     edi,[esp + 10h]     ; edi -> dest string
        jnz     short src_misaligned    ; (almost always source is aligned)

        shr     ecx,2               ; convert ecx to dword count
        jnz     short main_loop_entrance
        jmp     short copy_tail_loop    ; 0 < count < 4

; simple byte loop until string is aligned

src_misaligned:
        mov     al,byte ptr [esi]   ; copy a byte from source to dest
        inc     esi
        mov     [edi],al
        inc     edi
        dec     ecx
        jz      fill_tail_end1      ; if count == 0, leave
        test    al,al               ; was last copied byte zero?
        jz      short align_dest    ; if so, go align dest and pad it out
                                    ; with zeros
        test    esi,3               ; esi already aligned ?
        jne     short src_misaligned
        mov     ebx,ecx             ; store count for tail loop
        shr     ecx,2
        jnz     short main_loop_entrance

tail_loop_start:
        and     ebx,3               ; ebx = count_before_main_loop%4
        jz      short fill_tail_end1    ; if ebx == 0 then leave without
                                        ; appending a null byte

; while ( EOS (end-of-string) not found and count > 0 ) copy bytes

copy_tail_loop:
        mov     al,byte ptr [esi]   ; load byte from source
        inc     esi
        mov     [edi],al            ; store byte to dest
        inc     edi
        test    al,al               ; EOS found?
        je      short fill_tail_zero_bytes  ; '\0' was already copied
        dec     ebx
        jnz     copy_tail_loop
fill_tail_end1:
        mov     eax,[esp + 10h]     ; prepare return value
        pop     ebx
        pop     esi
        pop     edi
        ret

; EOS found. Pad with null characters to length count

align_dest:
        test    edi,3               ; dest string aligned?
        jz      dest_align_loop_end
dest_align_loop:
        mov     [edi],al
        inc     edi
        dec     ecx                 ; count == 0?
        jz      fill_tail_end       ; if so, finished
        test    edi,3               ; is edi aligned ?
        jnz     dest_align_loop
dest_align_loop_end:
        mov     ebx,ecx             ; ebx > 0
        shr     ecx,2               ; convert ecx to count of dwords
        jnz     fill_dwords_with_EOS
        ; pad tail bytes
finish_loop:                        ; 0 < ebx < 4
        mov     [edi],al
        inc     edi
fill_tail_zero_bytes:
        dec     ebx
        jnz     finish_loop
        pop     ebx
        pop     esi
finish:
        mov     eax,[esp + 8]       ; return in eax pointer to dest string
        pop     edi
        ret

; copy (source) string to (dest). Also look for end of (source) string

main_loop:                          ; edx contains first dword of source string
        mov     [edi],edx           ; store one more dword
        add     edi,4               ; kick dest pointer
        dec     ecx
        jz      tail_loop_start

main_loop_entrance:
        mov     edx,7efefeffh
        mov     eax,dword ptr [esi] ; read 4 bytes (dword)
        add     edx,eax
        xor     eax,-1
        xor     eax,edx
        mov     edx,[esi]           ; it's in cache now
        add     esi,4               ; kick dest pointer
        test    eax,81010100h
        je      short main_loop

        ; may have found zero byte in the dword

        test    dl,dl               ; is it byte 0
        je      short byte_0
        test    dh,dh               ; is it byte 1
        je      short byte_1
        test    edx,00ff0000h       ; is it byte 2
        je      short byte_2
        test    edx,0ff000000h      ; is it byte 3
        jne     short main_loop     ; taken if bits 24-30 are clear and bit
                                    ; 31 is set

; a null character was found, so dest needs to be padded out with null chars
; to count length.

        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_2:
        and     edx,0ffffh          ; fill high 2 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_1:
        and     edx,0ffh            ; fill high 3 bytes with 0
        mov     [edi],edx
        jmp     short fill_with_EOS_dwords

byte_0:
        xor     edx,edx             ; fill whole dword with 0
        mov     [edi],edx

; End of string was found. Pad out dest string with dwords of 0

fill_with_EOS_dwords:               ; ecx > 0   (ecx is dword counter)
        add     edi,4
        xor     eax,eax             ; it is instead of ???????????????????
        dec     ecx
        jz      fill_tail           ; we filled all dwords

fill_dwords_with_EOS:
        xor     eax,eax
fill_with_EOS_loop:
        mov     [edi],eax
        add     edi,4
        dec     ecx
        jnz     short fill_with_EOS_loop
fill_tail:                          ; let's pad tail bytes with zero
        and     ebx,3               ; ebx = ebx % 4
        jnz     short finish_loop   ; taken, when there are some tail bytes
fill_tail_end:
        mov     eax,[esp + 10h]
        pop     ebx
        pop     esi
        pop     edi
        ret

strncpy endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strnset.asm ===
page	,132
	title	strnset - set first n characters to one char.
;***
;strnset.asm - set first n characters to single character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strnset() - sets at most the first n characters of a string
;	to a given character.
;
;Revision History:
;	11-18-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	05-23-88  WAJ	If count = strlen(string)+1 then strlen+1 bytes were set.
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-23-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strnset(string, val, count) - set at most count characters to val
;
;Purpose:
;	Sets the first count characters of string the character value.
;	If the length of string is less than count, the length of
;	string is used in place of n.
;
;	Algorithm:
;	char *
;	_strnset (string, val, count)
;	      char *string,val;
;	      unsigned int count;
;	      {
;	      char *start = string;
;
;	      while (count-- && *string)
;		      *string++ = val;
;	      return(start);
;	      }
;
;Entry:
;	char *string - string to set characters in
;	char val - character to fill with
;	unsigned count - count of characters to fill
;
;Exit:
;	returns string, now filled with count copies of val.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strnset
_strnset proc \
	uses edi ebx, \
	string:ptr byte, \
	val:byte, \
	count:IWORD


	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=string addr; save return value
	mov	ebx,[count]	; cx = max chars to set
	xor	eax,eax 	; null byte
	mov	ecx,ebx
	jecxz	short done	; zero length specified

repne	scasb			; find null byte & count bytes in cx
	jne	short nonull	; null not found
	inc	ecx		; don't want the null

nonull:
	sub	ebx,ecx 	; bx=strlen (not null)
	mov	ecx,ebx 	; cx=strlen (not null)

	mov	edi,edx 	; restore string pointer
	mov	al,val		; byte value
rep	stosb			; fill 'er up

done:
	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE + 2*ISIZE ; _stdcall return
else
	ret			; _cdecl return
endif

_strnset endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strpbrk.asm ===
;***
;strpbrk.asm -
;
;	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines strpbrk()- finds the index of the first character in a string
;	that is not in a control string
;
;	NOTE:  This stub module scheme is compatible with NT build
;	procedure.
;
;Revision History:
;	09-25-91  JCR	Stub module created.
;
;*******************************************************************************

SSTRPBRK EQU 1
INCLUDE I386\STRSPN.ASM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strrchr.asm ===
page	,132
	title	strrchr - find last occurence of character in string
;***
;strrchr.asm - find last occurrence of character in string
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strrchr() - find the last occurrence of a given character
;	in a string.
;
;Revision History:
;	10-27-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *strrchr(string, ch) - find last occurrence of ch in string
;
;Purpose:
;	Finds the last occurrence of ch in string.  The terminating
;	null character is used as part of the search.
;
;	Algorithm:
;	char *
;	strrchr (string, ch)
;	      char *string, ch;
;	      {
;	      char *start = string;
;
;	      while (*string++)
;		      ;
;	      while (--string != start && *string != ch)
;		      ;
;	      if (*string == ch)
;		      return(string);
;	      return(NULL);
;	      }
;
;Entry:
;	char *string - string to search in
;	char ch - character to search for
;
;Exit:
;	returns a pointer to the last occurrence of ch in the given
;	string
;	returns NULL if ch does not occurr in the string
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	strrchr
strrchr proc \
	uses edi, \
	string:ptr byte, \
	chr:byte

	mov	edi,[string]	; di = string
	xor	eax,eax 	; al=null byte
	or	ecx,-1		; cx = -1
repne	scasb			; find the null & count bytes
	inc	ecx		; cx=-byte count (with null)
	neg	ecx		; cx=+byte count (with null)
	dec	edi		; di points to terminal null
	mov	al,chr		; al=search byte
	std			; count 'down' on string this time
repne	scasb			; find that byte
	inc	edi		; di points to byte which stopped scan

	cmp	[edi],al	; see if we have a hit
	je	short returndi	; yes, point to byte

	xor	eax,eax 	; no, return NULL
	jmp	short toend	; do return sequence

returndi:
	mov	eax,edi 	; ax=pointer to byte

toend:
	cld

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

strrchr endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strrev.asm ===
page	,132
	title	strrev - reverse a string in place
;***
;strrev.asm - reverse a string in place
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strrev() - reverse a string in place (not including
;	'\0' character)
;
;Revision History:
;	10-26-83  RN	initial version
;	07-16-87  JCR	Added check for empty string (fixes large model bug)
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup, minor alterations
;	10-26-88  JCR	General cleanup for 386-only code
;	10-26-88  JCR	Re-arrange regs to avoid push/pop ebx
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strrev(string) - reverse a string in place
;
;Purpose:
;	Reverses the order of characters in the string.  The terminating
;	null character remains in place.
;
;	Algorithm:
;	char *
;	_strrev (string)
;	      char *string;
;	      {
;	      char *start = string;
;	      char *left = string;
;	      char ch;
;
;	      while (*string++)
;		      ;
;	      string -= 2;
;	      while (left < string)
;		      {
;		      ch = *left;
;		      *left++ = *string;
;		      *string-- = ch;
;		      }
;	      return(start);
;	      }
;
;	NOTE: There is a check for an empty string in the following code.
;	Normally, this would fall out of the "cmp si,di" instruction in the
;	loop portion of the routine.  However, if the offset of the empty
;	string is 0 (as it could be in large model), then the cmp does not
;	catch the empty string and the routine essentially hangs (i.e., loops
;	moving bytes one at a time FFFFh times).  An explicit empty string
;	check corrects this.
;
;Entry:
;	char *string - string to reverse
;
;Exit:
;	returns string - now with reversed characters
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strrev
_strrev proc \
	uses edi esi, \
	string:ptr byte

	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=pointer to string; save return value

	mov	esi,edi 	; si=pointer to string
	xor	eax,eax 	; search value (null)
	or	ecx,-1		; cx = -1
repne	scasb			; find null
	cmp	ecx,-2		; is string empty? (if offset value is 0, the
	je	short done	; cmp below will not catch it and we'll hang).

	dec	edi		; string is not empty, move di pointer back
	dec	edi		; di points to last non-null byte

lupe:
	cmp	esi,edi 	; see if pointers have crossed yet
	jae	short done	; exit when pointers meet (or cross)

	mov	ah,[esi]	; get front byte...
	mov	al,[edi]	;   and end byte
	mov	[esi],al	; put end byte in front...
	mov	[edi],ah	;   and front byte at end
	inc	esi		; front moves up...
	dec	edi		;   and end moves down
	jmp	short lupe	; keep switching bytes

done:
	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE		; _stdcall return
else
	ret			; _cdecl return
endif

_strrev endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strset.asm ===
page	,132
	title	strset - set all characters of string to character
;***
;strset.asm - sets all charcaters of string to given character
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines _strset() - sets all of the characters in a string (except
;	the '\0') equal to a given character.
;
;Revision History:
;	11-18-83  RN	initial version
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-04-88  SJM	convert to cruntime/ add 32-bit support
;	08-23-88  JCR	386 cleanup
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	01-18-91  GJF	ANSI naming.
;	05-10-91  GJF	Back to _cdecl, sigh...
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;char *_strset(string, val) - sets all of string to val
;
;Purpose:
;	Sets all of characters in string (except the terminating '/0'
;	character) equal to val.
;
;	Algorithm:
;	char *
;	_strset (string, val)
;	      char *string;
;	      char val;
;	      {
;	      char *start = string;
;
;	      while (*string)
;		      *string++ = val;
;	      return(start);
;	      }
;
;Entry:
;	char *string - string to modify
;	char val - value to fill string with
;
;Exit:
;	returns string -- now filled with val's
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

	CODESEG

	public	_strset
_strset proc \
	uses edi, \
	string:ptr byte, \
	val:byte


	mov	edi,[string]	; di = string
	mov	edx,edi 	; dx=string addr; save return value

	xor	eax,eax 	; ax = 0
	or	ecx,-1		; cx = -1
repne	scasb			; scan string & count bytes
	inc	ecx
	inc	ecx		; cx=-strlen
	neg	ecx		; cx=strlen
	mov	al,[val]	; al = byte value to store
	mov	edi,edx 	; di=string addr
rep	stosb

	mov	eax,edx 	; return value: string addr

ifdef	_STDCALL_
	ret	DPSIZE + ISIZE	; _stdcall return
else
	ret			; _cdecl return
endif

_strset endp
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\mt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strstr.asm ===
page    ,132
        title   strstr - search for one string inside another
;***
;strstr.asm - search for one string inside another
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines strstr() - search for one string inside another
;
;Revision History:
;       02-02-88  SKS   Rewritten from scratch.  Now works correctly with
;                       strings > 32 KB in length.  Also smaller and faster.
;       03-01-88  SKS   Ensure that ES = DS right away (Small/Medium models)
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-18-88  PHG   Corrected return value when src is empty string
;                       to conform with ANSI.
;       08-23-88  JCR   Minor 386 cleanup
;       10-26-88  JCR   General cleanup for 386-only code
;       03-26-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       12-19-94  GJF   Revised to improve performance a bit.
;       12-04-95  GJF   Much faster version from Intel.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;char *strstr(str1, str2) - search for str2 in str1
;
;Purpose:
;       finds the first occurrence of str2 in str1
;
;Entry:
;       char *str1 - string to search in
;       char *str2 - string to search for
;
;Exit:
;       returns a pointer to the first occurrence of string2 in
;       string1, or NULL if string2 does not occur in string1
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


__from_strstr_to_strchr proto

        CODESEG

        public  strstr

strstr  proc

        mov     ecx,[esp + 8]       ; str2 (the string to be searched for)

        push    edi                 ; Preserve edi, ebx and esi
        push    ebx
        push    esi

        mov     dl,[ecx]            ; dl contains first char from str2

        mov     edi,[esp + 10h]     ; str1 (the string to be searched)

        test    dl,dl               ; is str2 empty?
        jz      empty_str2

        mov     dh,[ecx + 1]        ; second char from str2
        test    dh,dh               ; is str2 a one-character string?
        jz      strchr_call         ; if so, go use strchr code

; length of str2 is now known to be > 1 (used later)
; dl contains first char from str2
; dh contains second char from str2
; edi holds str1

findnext:
        mov     esi,edi             ; esi = edi = pointers to somewhere in str1
        mov     ecx,[esp + 14h]     ; str2

;use edi instead of esi to eliminate AGI
        mov     al,[edi]            ; al is next char from str1

        inc     esi                 ; increment pointer into str1

        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?    
        jz      not_found           ; yes, and no match has been found

loop_start:
        mov     al,[esi]            ; put next char from str1 into al
        inc     esi                 ; increment pointer in str1
in_loop:
        cmp     al,dl
        je      first_char_found

        test    al,al               ; end of str1?
        jnz     loop_start          ; no, go get another char from str1

not_found:
        pop     esi
        pop     ebx
        pop     edi
        xor     eax,eax
        ret

; recall that dh contains the second char from str2

first_char_found:
        mov     al,[esi]            ; put next char from str1 into al
        inc     esi

        cmp     al,dh               ; compare second chars
        jnz     in_loop             ; no match, continue search

two_first_chars_equal:
        lea     edi,[esi - 1]       ; store position of last read char in str1

compare_loop:
        mov     ah,[ecx + 2]        ; put next char from str2 into ah
        test    ah,ah               ; end of str2?
        jz      match               ; if so, then a match has been found

        mov     al,[esi]            ; get next char from str1
        add     esi,2               ; bump pointer into str1 by 2

        cmp     al,ah               ; are chars from str1 and str2 equal?
        jne     findnext            ; no

; do one more iteration

        mov     al,[ecx + 3]        ; put the next char from str2 into al
        test    al,al               ; end of str2
        jz      match               ; if so, then a match has been found

        mov     ah,[esi - 1]        ; get next char from str1 
        add     ecx,2               ; bump pointer in str1 by 2
        cmp     al,ah               ; are chars from str1 and str2 equal?
        je      compare_loop

; no match. test some more chars (to improve execution time for bad strings).

        jmp     findnext

; str2 string contains only one character so it's like the strchr functioin

strchr_call:
        xor     eax,eax
        pop     esi
        pop     ebx
        pop     edi
        mov     al,dl
        jmp     __from_strstr_to_strchr

;
;
; Match!  Return (ebx - 1)
;
match:
        lea     eax,[edi - 1]
        pop     esi
        pop     ebx
        pop     edi
        ret

empty_str2:           ; empty target string, return src (ANSI mandated)
        mov     eax,edi
        pop     esi
        pop     ebx
        pop     edi
        ret

strstr  endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\strspn.asm ===
page	,132
	title	strspn - search for init substring of chars from control str
;***
;strspn.asm - find length of initial substring of chars from a control string
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	defines strspn() - finds the length of the initial substring of
;	a string consisting entirely of characters from a control string.
;
;	defines strcspn()- finds the length of the initial substring of
;	a string consisting entirely of characters not in a control string.
;
;	defines strpbrk()- finds the index of the first character in a string
;	that is not in a control string
;
;Revision History:
;	10-28-83  RN	initial version
;	06-30-87  SKS	Faster version -- also reentrant
;	05-18-88  SJM	Add model-independent (large model) ifdef
;	08-02-88  SJM	Created 386-specific version.
;	08-23-88  JCR	386 cleanup
;	10-10-88  JCR	Misc bug fixes
;	10-26-88  JCR	General cleanup for 386-only code
;	03-26-90  GJF	Changed to _stdcall. Also, fixed the copyright.
;	05-10-91  GJF	Back to _cdecl, sigh...
;	09-25-91  JCR	Build "strspn" if no other directives are given
;	01-17-92  GJF	Fixed build of "strspn".
;	01-17-95  GJF	Tuned.
;
;*******************************************************************************

	.xlist
	include cruntime.inc
	.list

page
;***
;int strspn(string, control) - find init substring of control chars
;
;Purpose:
;	Finds the index of the first character in string that does belong
;	to the set of characters specified by control.	This is
;	equivalent to the length of the initial substring of string that
;	consists entirely of characters from control.  The '\0' character
;	that terminates control is not considered in the matching process.
;
;	Algorithm:
;	int
;	strspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		if (*string)
;		{
;			while (map[*string >> 3] & (1 << (*string & 7)))
;			{
;				count++;
;				string++;
;			}
;			return(count);
;		}
;		return(0);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - string containing characters not to search for
;
;Exit:
;	returns index of first char in string not in control
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;int strcspn(string, control) - search for init substring w/o control chars
;
;Purpose:
;	returns the index of the first character in string that belongs
;	to the set of characters specified by control.	This is equivalent
;	to the length of the length of the initial substring of string
;	composed entirely of characters not in control.  Null chars not
;	considered.
;
;	Algorithm:
;	int
;	strcspn (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		map[0] |= 1;
;		while (!(map[*string >> 3] & (1 << (*string & 7))))
;		{
;			count++;
;			string++;
;		}
;		return(count);
;	}
;
;Entry:
;	char *string - string to search
;	char *control - set of characters not allowed in init substring
;
;Exit:
;	returns the index of the first char in string
;	that is in the set of characters specified by control.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

;***
;char *strpbrk(string, control) - scans string for a character from control
;
;Purpose:
;	Finds the first occurence in string of any character from
;	the control string.
;
;	Algorithm:
;	char *
;	strpbrk (string, control)
;		unsigned char *string, *control;
;	{
;		unsigned char map[32];
;		int count;
;
;		for (count = 0; count < 32; count++)
;			map[count] = 0;
;		while (*control)
;		{
;			map[*control >> 3] |= (1 << (*control & 7));
;			control++;
;		}
;		while (*string)
;		{
;			if (map[*string >> 3] & (1 << (*string & 7)))
;				return(string);
;			string++;
;		}
;		return(NULL);
;	}
;
;Entry:
;	char *string - string to search in
;	char *control - string containing characters to search for
;
;Exit:
;	returns a pointer to the first character from control found
;	in string.
;	returns NULL if string and control have no characters in common.
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************


ifdef SSTRCSPN

    _STRSPN_ equ <strcspn>

elseifdef SSTRPBRK

    _STRSPN_ equ <strpbrk>

else

; Default is to build strspn()

    SSTRSPN equ 1
    _STRSPN_ equ <strspn>

endif

% public  _STRSPN_

    CODESEG

_STRSPN_ proc \
	uses esi, \
	string:ptr byte, \
	control:ptr byte

; create and zero out char bit map

	xor	eax,eax
	push	eax		; 32
	push	eax
	push	eax
	push	eax		; 128
	push	eax
	push	eax
	push	eax
	push	eax		; 256

map	equ	[esp]

; Set control char bits in map

	mov	edx,control	; si = control string

	align	@WordSize
lab listnext			; init char bit map
	mov	al,[edx]
	or	al,al
	jz	short listdone
	inc	edx
	bts	map,eax
	jmp	short listnext

lab listdone

; Loop through comparing source string with control bits

	mov	esi,string	; si = string

_ifnd	SSTRPBRK <or	 ecx,-1> ; set ecx to -1

	align	@WordSize
lab dstnext

_ifnd	SSTRPBRK <inc	 ecx>

	mov	al,[esi]
	or	al,al
	jz	short dstdone
	inc	esi
	bt	map, eax

ifdef SSTRSPN
	jc	short dstnext	; strspn: found char, continue
elseifdef SSTRCSPN
	jnc	short dstnext	; strcspn: did not find char, continue
elseifdef SSTRPBRK
	jnc	short dstnext	; strpbrk: did not find char, continue
	lea	eax,[esi - 1]	; found char, return address of it
endif

; Return code

lab dstdone

_ifnd	SSTRPBRK <mov	eax,ecx> ; strspn/strcspn: return index

	add	esp,32

	ret			; _cdecl return

_STRSPN_ endp
	 end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\st\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\nt\makefile.inc ===
SRCDIR = ..^\
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\_stricmp.asm ===
page    ,132
        title   stricmp
;***
;stricmp.asm - contains ASCII only, case-insensitive, string comparision routine
;       __ascii_stricmp
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       contains __ascii_stricmp()
;
;Revision History:
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Minor 386 cleanup
;       10-10-88  JCR   Added strcmpi() entry for compatiblity with early revs
;       10-25-88  JCR   General cleanup for 386-only code
;       10-27-88  JCR   Shuffled regs so no need to save/restore ebx
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-18-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls. Also, fixed bug in reg operand size.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       10-03-95  GJF   New locale locking scheme.
;       11-13-95  GJF   Made _strcmpi a proc instead of a label.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active
;       07-18-96  GJF   Fixed race condition.
;       08-26-98  GJF   All locale and multithread support moved up to
;                       stricmp.c. Renamed this file to _stricmp.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_stricmp(dst, src) - compare strings, ignore case
;
;Purpose:
;       _stricmp/_strcmpi perform a case-insensitive string comparision.
;       For differences, upper case letters are mapped to lower case.
;       Thus, "abc_" < "ABCD" since "_" < "d".
;
;       Algorithm:
;
;       int _strcmpi (char * dst, char * src)
;       {
;               int f,l;
;
;               do {
;                       f = tolower(*dst);
;                       l = tolower(*src);
;                       dst++;
;                       src++;
;               } while (f && f == l);
;
;               return(f - l);
;       }
;
;Entry:
;       char *dst, *src - strings to compare
;
;Exit:
;       AX = -1 if dst < src
;       AX =  0 if dst = src
;       AX = +1 if dst > src
;
;Uses:
;       CX, DX
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_stricmp
__ascii_stricmp proc \
        uses edi esi ebx, \
        dst:ptr, \
        src:ptr

        ; load up args

        mov     esi,[src]       ; esi = src
        mov     edi,[dst]       ; edi = dst

        mov     al,-1           ; fall into loop

        align   4

chk_null:
        or      al,al
        jz      short done

        mov     al,[esi]        ; al = next source byte
        inc     esi
        mov     ah,[edi]        ; ah = next dest byte
        inc     edi

        cmp     ah,al           ; first try case-sensitive comparision
        je      short chk_null  ; match

        sub     al,'A'
        cmp     al,'Z'-'A'+1
        sbb     cl,cl
        and     cl,'a'-'A'
        add     al,cl
        add     al,'A'          ; tolower(*dst)

        xchg    ah,al           ; operations on AL are shorter than AH

        sub     al,'A'
        cmp     al,'Z'-'A'+1
        sbb     cl,cl
        and     cl,'a'-'A'
        add     al,cl
        add     al,'A'          ; tolower(*src)

        cmp     al,ah           ; inverse of above comparison -- AL & AH are swapped
        je      short chk_null

                                ; dst < src     dst > src
        sbb     al,al           ; AL=-1, CY=1   AL=0, CY=0
        sbb     al,-1           ; AL=-1         AL=1
done:
        movsx   eax,al          ; extend al to eax

        ret

__ascii_stricmp endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\_strnicm.asm ===
page    ,132
        title   strnicmp - compare n chars of strings, ignore case
;***
;strnicmp.asm - compare n chars of strings, ignoring case
;
;       Copyright (c) 1986-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_strnicmp() - Compares at most n characters of two 
;       strings, without regard to case.
;
;Revision History:
;       04-04-85  RN    initial version
;       07-11-85  TC    zeroed cx, to allow correct return value if not equal
;       05-18-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   386 cleanup and improved return value sequence
;       10-26-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-18-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls.
;       11-22-94  GJF   Forgot to increment pointers in non-C locales.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       09-22-95  GJF   Fixed first line at label differ2 to loaded -1 into
;                       ecx (same as code a label differ).
;       10-03-95  GJF   New locale locking scheme.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active
;       07-18-96  GJF   Fixed race condition.
;       09-10-98  GJF   All locale and multithread support moved up to
;                       strnicmp.c. Renamed this file to _strnicm.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_strnicmp(first, last, count) - compares count char of strings,
;       ignore case
;
;Purpose:
;       Compare the two strings for lexical order.  Stops the comparison
;       when the following occurs: (1) strings differ, (2) the end of the
;       strings is reached, or (3) count characters have been compared.
;       For the purposes of the comparison, upper case characters are
;       converted to lower case.
;
;       Algorithm:
;       int
;       _strncmpi (first, last, count)
;             char *first, *last;
;             unsigned int count;
;             {
;             int f,l;
;             int result = 0;
;
;             if (count) {
;                     do      {
;                             f = tolower(*first);
;                             l = tolower(*last);
;                             first++;
;                             last++;
;                             } while (--count && f && l && f == l);
;                     result = f - l;
;                     }
;             return(result);
;             }
;
;Entry:
;       char *first, *last - strings to compare
;       unsigned count - maximum number of characters to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_strnicmp
__ascii_strnicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = byte count
        or      ecx,ecx
        jz      toend           ; if count = 0, we are done

        mov     esi,[first]     ; si = first string
        mov     edi,[last]      ; di = last string

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; *first

        or      ah,ah           ; see if *first is null

        mov     al,[edi]        ; *last

        jz      short eject     ;   jump if *first is null

        or      al,al           ; see if *last is null
        jz      short eject     ;   jump if so

        inc     esi             ; first++
        inc     edi             ; last++

        cmp     ah,bh           ; 'A'
        jb      short skip1

        cmp     ah,bl           ; 'Z'
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; 'A'
        jb      short skip2

        cmp     al,bl           ; 'Z'
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ

        dec     ecx
        jnz     short lupe

eject:
        xor     ecx,ecx
        cmp     ah,al           ; compare the (possibly) differing bytes
        je      short toend     ; both zero; return 0

differ:
        mov     ecx,-1          ; assume last is bigger (* can't use 'or' *)
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx

        ret                     ; _cdecl return

__ascii_strnicmp endp
         end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\string\i386\_memicmp.asm ===
page        ,132
        title        memicmp - compare blocks of memory, ignore case
;***
;memicmp.asm - compare memory, ignore case
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       defines __ascii_memicmp() - compare two blocks of memory for lexical
;       order. Case is ignored in the comparison.
;
;Revision History:
;       05-16-83  RN    initial version
;       05-17-88  SJM   Add model-independent (large model) ifdef
;       08-04-88  SJM   convert to cruntime/ add 32-bit support
;       08-23-88  JCR   Cleanup...
;       10-25-88  JCR   General cleanup for 386-only code
;       03-23-90  GJF   Changed to _stdcall. Also, fixed the copyright.
;       01-17-91  GJF   ANSI naming.
;       05-10-91  GJF   Back to _cdecl, sigh...
;       10-20-94  GJF   Made locale sensitive (i.e., now works for all
;                       single-byte character locales). Made multi-thread
;                       safe. Also, deleted obsolete _STDCALL_ code.
;       10-27-94  GJF   Adapted above change for Win32S.
;       11-12-94  GJF   Must avoid volatile regs or save them across function
;                       calls. Also, fixed bug in reg operand size.
;       07-03-95  CFW   Changed offset of _lc_handle[LC_CTYPE], added sanity check 
;                       to crtlib.c to catch changes to win32s.h that modify offset.
;       10-03-95  GJF   New locale locking scheme.
;       07-17-96  GJF   Added lock prefix to increment and decrement of 
;                       __unguarded_readlc_active.
;       07-18-96  GJF   Fixed race condition.
;       09-08-98  GJF   All locale and multithread support moved up to
;                       memicmp.c. Renamed this file to _memicmp.asm.
;
;*******************************************************************************

        .xlist
        include cruntime.inc
        .list

page
;***
;int __ascii_memicmp(first, last, count) - compare two blocks of memory, ignore case
;
;Purpose:
;       Compares count bytes of the two blocks of memory stored at first
;       and last.  The characters are converted to lowercase before
;       comparing (not permanently), so case is ignored in the search.
;
;       Algorithm:
;       int
;       _memicmp (first, last, count)
;               char *first, *last;
;               unsigned count;
;               {
;               if (!count)
;                       return(0);
;               while (--count && tolower(*first) == tolower(*last))
;                       {
;                       first++;
;                       last++;
;                       }
;               return(tolower(*first) - tolower(*last));
;               }
;
;Entry:
;       char *first, *last - memory buffers to compare
;       unsigned count - maximum length to compare
;
;Exit:
;       returns <0 if first < last
;       returns 0 if first == last
;       returns >0 if first > last
;
;Uses:
;
;Exceptions:
;
;*******************************************************************************

        CODESEG

        public  __ascii_memicmp
__ascii_memicmp proc \
        uses edi esi ebx, \
        first:ptr byte, \
        last:ptr byte, \
        count:IWORD

        mov     ecx,[count]     ; cx = count
        or      ecx,ecx
        jz      short toend     ; if count=0, nothing to do

        mov     esi,[first]     ; si = first
        mov     edi,[last]      ; di = last

        ; C locale

        mov     bh,'A'
        mov     bl,'Z'
        mov     dh,'a'-'A'      ; add to cap to make lower

        align   4

lupe:
        mov     ah,[esi]        ; ah = *first
        inc     esi             ; first++
        mov     al,[edi]        ; al = *last
        inc     edi             ; last++

        cmp     ah,al           ; test for equality BEFORE converting case
        je      short dolupe

        cmp     ah,bh           ; ah < 'A' ??
        jb      short skip1

        cmp     ah,bl           ; ah > 'Z' ??
        ja      short skip1

        add     ah,dh           ; make lower case

skip1:
        cmp     al,bh           ; al < 'A' ??
        jb      short skip2

        cmp     al,bl           ; al > 'Z' ??
        ja      short skip2

        add     al,dh           ; make lower case

skip2:
        cmp     ah,al           ; *first == *last ??
        jne     short differ    ; nope, found mismatched chars

dolupe:
        dec     ecx
        jnz     short lupe

        jmp     short toend     ; cx = 0, return 0

differ:
        mov     ecx,-1          ; assume last is bigger
                                ; *** can't use "or ecx,-1" due to flags ***
        jb      short toend     ; last is, in fact, bigger (return -1)
        neg     ecx             ; first is bigger (return 1)

toend:
        mov     eax,ecx         ; move return value to ax

        ret                     ; _cdecl return

__ascii_memicmp endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\days.c ===
/***
*days.c - static arrays with days from beg of year for each month
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains static arrays used by gmtime and statconv to determine
*	date and time values.  Shows days from beg of year.
*
*Revision History:
*	03-??-84  RLB	initial version
*	05-??-84  DFW	split out definitions from ctime routines
*	07-03-89  PHG	removed _NEAR_ for 386
*	03-20-90  GJF	Fixed copyright.
*
*******************************************************************************/

#include <internal.h>

int _lpdays[] = {
	-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

int _days[] = {
	-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\asctime.c ===
/***
*asctime.c - convert date/time structure to ASCII string
*
*	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains asctime() - convert a date/time structure to ASCII string.
*
*Revision History:
*	03-??-84  RLB	Module created
*	05-??-84  DCW	Removed use of sprintf, to avoid loading stdio
*			functions
*	04-13-87  JCR	Added "const" to declarations
*	05-21-87  SKS	Declare the static buffer and helper routines as NEAR
*			Replace store_year() with in-line code
*
*	11-24-87  WAJ	allocated a static buffer for each thread.
*	12-11-87  JCR	Added "_LOAD_DS" to declaration
*	05-24-88  PHG	Merged DLL and normal versions; Removed initializers to
*			save memory
*	06-06-89  JCR	386 mthread support
*	03-20-90  GJF	Replaced _LOAD_DS with _CALLTYPE1, added #include
*			<cruntime.h>, removed #include <register.h>, fixed
*			the copyright and removed some leftover 16-bit support.
*			Also, cleaned up the formatting a bit.
*	08-16-90  SBM	Compiles cleanly with -W3
*	10-04-90  GJF	New-style function declarators.
*	07-17-91  GJF	Multi-thread support for Win32 [_WIN32_].
*	02-17-93  GJF	Changed for new _getptd().
*	04-06-93  SKS	Replace _CRTAPI* with __cdecl
*	11-01-93  CFW	Enable Unicode variant, rip out Cruiser.
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	01-10-95  CFW	Debug CRT allocs.
*	02-09-95  GJF	Replaced WPRFLAG with _UNICODE.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <mtdll.h>
#ifdef	_MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <tchar.h>
#include <dbgint.h>

#define _ASCBUFSIZE   26
static _TSCHAR buf[_ASCBUFSIZE];

/*
** This prototype must be local to this file since the procedure is static
*/

static _TSCHAR * __cdecl store_dt(_TSCHAR *, int);

static _TSCHAR * __cdecl store_dt (
	REG1 _TSCHAR *p,
	REG2 int val
	)
{
	*p++ = (_TSCHAR)(_T('0') + val / 10);
	*p++ = (_TSCHAR)(_T('0') + val % 10);
	return(p);
}


/***
*char *asctime(time) - convert a structure time to ascii string
*
*Purpose:
*	Converts a time stored in a struct tm to a charcater string.
*	The string is always exactly 26 characters of the form
*		Tue May 01 02:34:55 1984\n\0
*
*Entry:
*	struct tm *time - ptr to time structure
*
*Exit:
*	returns pointer to static string with time string.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tasctime (
	REG1 const struct tm *tb
	)
{
#ifdef	_MT

	_ptiddata ptd = _getptd();

	REG2 _TSCHAR *p;			/* will point to asctime buffer */
	_TSCHAR *retval;			/* holds retval pointer */

#else

	REG2 _TSCHAR *p = buf;

#endif

	int day, mon;
	int i;

#ifdef	_MT

	/* Use per thread buffer area (malloc space, if necessary) */

#ifdef	_UNICODE
	if ( (ptd->_wasctimebuf != NULL) || ((ptd->_wasctimebuf =
	    (wchar_t *)_malloc_crt(_ASCBUFSIZE * sizeof(wchar_t))) != NULL) )
		p = ptd->_wasctimebuf;
#else
	if ( (ptd->_asctimebuf != NULL) || ((ptd->_asctimebuf =
	    (char *)_malloc_crt(_ASCBUFSIZE * sizeof(char))) != NULL) )
		p = ptd->_asctimebuf;
#endif
	else
		p = buf;	/* error: use static buffer */

	retval = p;			/* save return value for later */

#endif

	/* copy day and month names into the buffer */

	day = tb->tm_wday * 3;		/* index to correct day string */
	mon = tb->tm_mon * 3;		/* index to correct month string */
	for (i=0; i < 3; i++,p++) {
		*p = *(__dnames + day + i);
		*(p+4) = *(__mnames + mon + i);
	}

	*p = _T(' ');			/* blank between day and month */

	p += 4;

	*p++ = _T(' ');
	p = store_dt(p, tb->tm_mday);	/* day of the month (1-31) */
	*p++ = _T(' ');
	p = store_dt(p, tb->tm_hour);	/* hours (0-23) */
	*p++ = _T(':');
	p = store_dt(p, tb->tm_min);	/* minutes (0-59) */
	*p++ = _T(':');
	p = store_dt(p, tb->tm_sec);	/* seconds (0-59) */
	*p++ = _T(' ');
	p = store_dt(p, 19 + (tb->tm_year/100)); /* year (after 1900) */
	p = store_dt(p, tb->tm_year%100);
	*p++ = _T('\n');
	*p = _T('\0');

#ifdef	_POSIX_
	/* Date should be padded with spaces instead of zeroes. */

	if (_T('0') == buf[8])
		buf[8] = _T(' ');
#endif

#ifdef	_MT
	return (retval);
#else
	return ((_TSCHAR *) buf);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\ctime64.c ===
/***
*ctime64.c - convert time argument to a string
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _ctime64() - convert time value to string
*
*Revision History:
*       05-21-98  GJF   Created.
*       08-30-99  PML   Fix function header comment.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <stddef.h>
#include <tchar.h>

/***
*_TSCHAR *_ctime64(time) - converts a time stored as a __time64_t to a string
*
*Purpose:
*       Converts a time stored as a __time64_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time64_t *time - time value in internal, 64-bit format
*
*Exit:
*       returns pointer to static string or NULL if an error occurs
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime64 (
        const __time64_t *timp
        )
{
        struct tm *tmtemp;

        if ( (tmtemp = _localtime64(timp)) != NULL )
            return(_tasctime((const struct tm *)tmtemp));
        else
            return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\clock.c ===
/***
*clock.c - Contains the clock runtime
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The clock runtime returns the processor time used by
*       the current process.
*
*Revision History:
*       01-17-87  JCR   Module created
*       06-01-87  SKS   "itime" must be declared static
*       07-20-87  JCR   Changes "inittime" to "_inittime"
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       07-25-91  GJF   Added _pinittime definition for new initialization
*                       scheme [_WIN32_].
*       03-13-92  SKS   Changed itime from static local to external as
*                       a part of return to initializer table scheme.
*                       Changed _inittime to __inittime.
*       05-19-92  DJM   POSIX support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       10-29-93  GJF   Define entry for initialization section (used to be
*                       in i386\cinitclk.asm). Also, deleted old Cruiser
*                       support.
*       04-12-94  GJF   Made definition of __itimeb conditional on ndef
*                       DLL_FOR_WIN32S.
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       07-25-96  RDK   Moved PMAC init ptr here from tzset.c.
*       08-26-97  GJF   Use GetSystemTimeAsFileTime API.
*       04-28-99  PML   Wrap __declspec(allocate()) in _CRTALLOC macro.
*       05-17-99  PML   Remove all Macintosh support.
*       03-27-01  PML   .CRT$XI routines must now return 0 or _RT_* fatal
*                       error code (vs7#231220)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <time.h>

#ifdef  _POSIX_
#include <posix/sys/times.h>
#else   /* ndef _POSIX_ */
#include <internal.h>
#include <sys\timeb.h>
#include <sys\types.h>
#endif  /* _POSIX_ */


#ifndef _POSIX_

int __cdecl __inittime(void);

#ifdef  _MSC_VER

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __inittime;

#pragma data_seg()

#endif  /* _MSC_VER */

static unsigned __int64 start_tics;

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates how much time the calling process
*       has used.  At startup time, startup calls __inittime which stores
*       the initial time.  The clock routine calculates the difference
*       between the current time and the initial time.
*
*       Clock must reference _cinitime so that _cinitim.asm gets linked in.
*       That routine, in turn, puts __inittime in the startup initialization
*       routine table.
*
*Entry:
*       No parameters.
*       itime is a static structure of type timeb.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        unsigned __int64 current_tics;
        FILETIME ct;

        GetSystemTimeAsFileTime( &ct );

        current_tics = (unsigned __int64)ct.dwLowDateTime + 
                       (((unsigned __int64)ct.dwHighDateTime) << 32);

        /* calculate the elapsed number of 100 nanosecond units */
        current_tics -= start_tics;

        /* return number of elapsed milliseconds */
        return (clock_t)(current_tics / 10000);
}

/***
*int __inittime() - Initialize the time location
*
*Purpose:
*       This routine stores the time of the process startup.
*       It is only linked in if the user issues a clock runtime call.
*
*Entry:
*       No arguments.
*
*Exit:
*       Returns 0 to indicate no error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl __inittime (
        void
        )
{
        FILETIME st;

        GetSystemTimeAsFileTime( &st );

        start_tics = (unsigned __int64)st.dwLowDateTime + 
                     (((unsigned __int64)st.dwHighDateTime) << 32);

        return 0;
}

#else   /* _POSIX_ */

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates how much time the calling process
*       has used. It uses the POSIX system call times().
*
*
*Entry:
*       No parameters.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        struct tms now;
        clock_t elapsed;

        elapsed= times(&now);
        if (elapsed == (clock_t) -1)
            return((clock_t) -1);
        else
            return(now.tms_utime+now.tms_stime);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\ctime.c ===
/***
*ctime.c - convert time argument into ASCII string
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains ctime() - convert time value to string
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-??-84  DFW   split off into seperate module
*       02-18-87  JCR   put in NULL ptr support
*       04-10-87  JCR   changed long declaration ot time_t and added const.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       05-21-90  GJF   Fixed compiler warning.
*       10-04-90  GJF   New-style function declarators.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       08-30-99  PML   Fix function header comment, detab.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <stddef.h>
#include <tchar.h>

/***
*_TSCHAR *ctime(time) - converts a time stored as a long to a ASCII string
*
*Purpose:
*       Converts a time stored as a time_t to an ASCII string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       time_t *time - time value in XENIX format
*
*Exit:
*       returns pointer to static string or NULL if time is before
*       Jan 1 1980.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime (
        const time_t *timp
        )
{
        struct tm *tmtemp;

        if ((tmtemp=localtime(timp)) != NULL)
                return(_tasctime((const struct tm *)tmtemp));
        else
                return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\difftime.c ===
/***
*difftime.c - return difference between two times as a double
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Find difference between two time in seconds.
*
*Revision History:
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       08-15-89  PHG   Made MTHREAD version _pascal
*       11-20-89  JCR   difftime() always _cdecl (not pascal even under
*                       mthread)
*       03-20-90  GJF   Replaced _LOAD_DS with CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarator.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       08-30-99  PML   Fix function header comment, detab.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>

/***
*double difftime(b, a) - find difference between two times
*
*Purpose:
*       returns difference between two times (b-a)
*
*Entry:
*       time_t a, b - times to difference
*
*Exit:
*       returns a double with the time in seconds between two times
*
*Exceptions:
*
*******************************************************************************/

double __cdecl difftime (
        time_t b,
        time_t a
        )
{
        return( (double)( b - a ) );
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\dtoxtm64.c ===
/***
*dtoxtm64.c - convert OS local time to __time64_t
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime64_t() - convert OS local time to internal format
*       (__time64_t).
*
*Revision History:
*       05-21-98  GJF   Created.
*       10-19-98  GJF   Fill in tm_min and tm_sec before calling _isindst
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*__time64_t __loctotime64_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS 
*       local time to internal time format (i.e., a __time64_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to __time64_t format (i.e., the number elapsed seconds
*       since 01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __loctotime64_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        __time64_t tmptim;
        struct tm tb;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR64) )
            return (__time64_t)(-1);

        /*
         * Compute the number of elapsed days in the current year.
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
            tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((__time64_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (__time64_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;
        /*
         * Account for time zone.
         */
        __tzset();
        tmptim += _timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && _daylight && 
                                _isindst(&tb)) )
            tmptim += _dstbias;
        return(tmptim);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\ftime64.c ===
/***
*ftime64.c - return system time
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*Revision History:
*       05-22-98  GJF   Created.
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#include <dos.h>
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static __time64_t elapsed_minutes_cache;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct timeb *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _ftime64 (
        struct __timeb64 *tp
        )
{
        FT nt_time;
        __time64_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;

        __tzset();

        tp->timezone = (short)(_timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (__time64_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF ) 
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) % 
                      1000i64);

        tp->time = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\gmtime.c ===
/***
*gmtime.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines gmtime() - breaks the clock value down into GMT time/date
*       information; return pointer to structure with the data.
*
*Revision History:
*       01-??-84  RLB   Module created
*       05-??-84  DCW   Split off from rest off ctime routines.
*       02-18-87  JCR   For MS C, gmtime now returns NULL for out of range
*                       time/date.      (This is for ANSI compatibility.)
*       04-10-87  JCR   Changed long declaration to time_t and added const
*       05-21-87  SKS   Declare "struct tm tb" as NEAR data
*       11-10-87  SKS   Removed IBMC20 switch
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-24-88  PHG   Merge DLL and regular versions
*       06-06-89  JCR   386 mthread support
*       11-06-89  KRS   Add (unsigned) to handle years 2040-2099 correctly
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator.
*       07-17-91  GJF   Multi-thread support for Win32 [_WIN32_].
*       02-17-93  GJF   Changed for new _getptd().
*       03-24-93  GJF   Propagated changes from 16-bit tree.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       01-10-95  CFW   Debug CRT allocs.
*       02-07-98  GJF   Changes for Win64: replaced long with time_t.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>
#ifdef _MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <dbgint.h>

static struct tm tb = { 0 };    /* time block */

/***
*struct tm *gmtime(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in internal format (time_t), to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const time_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0L
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl gmtime (
        const time_t *timp
        )
{

        time_t caltim = *timp;          /* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        REG1 int tmptim;
        REG3 int *mdays;                /* pointer to days or lpdays */

#ifdef  _MT

        REG2 struct tm *ptb;            /* will point to gmtime buffer */
        _ptiddata ptd = _getptd();

#else
        REG2 struct tm *ptb = &tb;
#endif

        if ( caltim < 0 )
                return(NULL);

#ifdef  _MT

        /* Use per thread buffer area (malloc space, if necessary) */

        if ( (ptd->_gmtimebuf != NULL) || ((ptd->_gmtimebuf =
            _malloc_crt(sizeof(struct tm))) != NULL) )
                ptb = ptd->_gmtimebuf;
        else
                ptb = &tb;      /* malloc error: use static buffer */

#endif

        /*
         * Determine years since 1970. First, identify the four-year interval
         * since this makes handling leap-years easy (note that 2000 IS a
         * leap year and 2100 is out-of-range).
         */
        tmptim = (int)(caltim / _FOUR_YEAR_SEC);
        caltim -= ((time_t)tmptim * _FOUR_YEAR_SEC);

        /*
         * Determine which year of the interval
         */
        tmptim = (tmptim * 4) + 70;         /* 1970, 1974, 1978,...,etc. */

        if ( caltim >= _YEAR_SEC ) {

            tmptim++;                       /* 1971, 1975, 1979,...,etc. */
            caltim -= _YEAR_SEC;

            if ( caltim >= _YEAR_SEC ) {

                tmptim++;                   /* 1972, 1976, 1980,...,etc. */
                caltim -= _YEAR_SEC;

                /*
                 * Note, it takes 366 days-worth of seconds to get past a leap
                 * year.
                 */
                if ( caltim >= (_YEAR_SEC + _DAY_SEC) ) {

                        tmptim++;           /* 1973, 1977, 1981,...,etc. */
                        caltim -= (_YEAR_SEC + _DAY_SEC);
                }
                else {
                        /*
                         * In a leap year after all, set the flag.
                         */
                        islpyr++;
                }
            }
        }

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (time_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (time_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return( (struct tm *)ptb );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\dtoxtime.c ===
/***
*dtoxtime.c - convert OS local time to time_t
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime_t() - convert OS local time to internal format
*       (time_t).
*
*Revision History:
*       03-??-84  RLB   written
*       11-18-87  SKS   change tzset() to __tzset(), change source file name
*                       make _dtoxtime a near procedure
*       01-26-88  SKS   _dtoxtime is no longer a near procedure (for QC)
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator.
*       01-21-91  GJF   ANSI naming.
*       05-19-92  DJM   ifndef for POSIX build.
*       03-30-93  GJF   Revised. Old _dtoxtime is replaced by __gmtotime_t,
*                       which is more useful on Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-06-93  GJF   Rewrote computation to avoid compiler warnings.
*       07-20-93  GJF   Replaced __gmtotime_t with function very similar to
*                       _dostotime_t() in 16-bit C 8.00. The reason for the
*                       change is that only local time values can be trusted
*                       on a Win32 platform. System time may be UTC (as
*                       documented), and is on NT, or may be the same as
*                       local time, as on Win32S and Win32C
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       09-25-95  GJF   Added DST flag to __loctotime_t's arguments. Also, 
*                       use _dstbias instead of assuming a DST bias of -3600.
*       02-07-98  GJF   Changes for Win64: replaced long type with time_t
*       10-19-98  GJF   Fill in tm_min and tm_sec before calling _isindst
*       05-17-99  PML   Remove all Macintosh support.
*       12-10-99  GB    Added support for years beyond 2099.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*time_t __loctotime_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS local
*       time to internal time format (i.e., a time_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to time_t format (i.e., the number elapsed seconds since
*       01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __loctotime_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        time_t tmptim;
        struct tm tb;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((yr -= 1900) < _BASE_YEAR) || (yr > _MAX_YEAR) )
                return (time_t)(-1);

        /*
         * Compute the number of elapsed days in the current year. Note the
         * test for a leap year would fail in the year 2100, if this was in
         * range (which it isn't).
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
                tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((time_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (time_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;
        /*
         * Account for time zone.
         */
        __tzset();
        tmptim += _timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && _daylight && 
                                _isindst(&tb)) )
                tmptim += _dstbias;
        return(tmptim);
}


#if 0

/*
 * THE FOLLOWING FUNCTION WAS DEFINED AND USED (IN PLACE OF THE ONE ABOVE)
 * FOR THE CUDA PRODUCT AND THE NT 1.0 SDK. IT WAS REPLACED (BY THE ONE
 * ABOVE) BECAUSE NON-NT WIN32 PLATFORMS MAY USE LOCAL TIME FOR SYSTEM TIME,
 * RATHER THAN UTC.
 */

/***
*time_t __gmtotime_t(yr, mo, dy, hr, mn, sc) - convert broken down time (UTC)
*   to time_t
*
*Purpose:
*       Converts a broken down UTC (GMT) time to time_t. This is similar to
*       _mkgmtime() except there is minimal overflow checking and no updating
*       of the input values (i.e., the fields of tm structure).
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns time_t value
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl __gmtotime_t (
        int yr,     /* 0 based */
        int mo,     /* 1 based */
        int dy,     /* 1 based */
        int hr,
        int mn,
        int sc
        )
{
        int tmpdays;
        long tmptim;

        /*
         * Do a quick range check on the year and convert it to a delta
         * off of 1900.
         */
        if ( ((long)(yr -= 1900) < _BASE_YEAR) || ((long)yr > _MAX_YEAR) )
                return (time_t)(-1);

        /*
         * Compute the number of elapsed days in the current year minus
         * one. Note the test for leap year and the would fail in the year 2100
         * if this was in range (which it isn't).
         */
        tmpdays = dy + _days[mo - 1];
        if ( !(yr & 3) && (mo > 2) )
                /*
                 * in a leap year, after Feb. add one day for elapsed
                 * Feb 29.
                 */
                tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((long)yr - _BASE_YEAR) * 365L

                 /* one day for each elapsed leap year */
                 + (long)((yr - 1) >> 2) - _LEAP_YEAR_ADJUST

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24L + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60L + mn)

                 /* convert to seconds and add in sec */
                 * 60L + sc;

        return (tmptim >= 0) ? (time_t)tmptim : (time_t)(-1);
}

#endif

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\ftime.c ===
/***
*ftime.c - return system time
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-17-86  SKS   ported to OS/2
*       03-09-87  SKS   correct Daylight Savings Time flag
*       11-18-87  SKS   Change tzset() to __tzset()
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       04-12-89  JCR   New syscall interface
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed some leftover 16-bit support
*                       and fixed the copyright. Also, cleaned up the
*                       formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       08-13-90  SBM   Compiles cleanly with -W3
*       08-20-90  SBM   Removed old incorrect, redundant tp->dstflag assignment
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-21-91  GJF   ANSI naming.
*       01-23-92  GJF   Change in time zone field name for Win32, to support
*                       crtdll.dll [_WIN32_].
*       03-30-93  GJF   Revised to use mktime(). Also purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Add _CRTIMP keyword for CRT DLL model
*                       Restore correct spelling of "timezone" struct member.
*       07-15-93  GJF   Call __tzset() instead of _tzset().
*       02-10-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       01-15-98  GJF   Complete rewrite of _ftime to eliminate incorrect dst
*                       status during the fall-back hour.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#ifndef _XBOX
#include <dos.h>
#endif
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static time_t elapsed_minutes_cache = 0;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct timeb *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _ftime (
        struct _timeb *tp
        )
{
        FT nt_time;
        time_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;

        __tzset();

        tp->timezone = (short)(_timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (time_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF ) 
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) % 
                      1000i64);

        tp->time = (time_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\gmtime64.c ===
/***
*gmtime64.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _gmtime64() - breaks the clock value down into GMT time/date
*       information; returns pointer to structure with the data.
*
*Revision History:
*       05-13-98  GJF   Created. Adapted from Win64 version of _gmtime64.c.
*       06-12-98  GJF   Fixed elapsed years calculation.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>
#ifdef  _MT
#include <malloc.h>
#include <stddef.h>
#endif
#include <dbgint.h>

static struct tm tb = { 0 };    /* time block */

/***
*struct tm *_gmtime64(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in internal 64-bit format to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const __time64_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl _gmtime64 (
        const __time64_t *timp
        )
{

        __time64_t caltim = *timp;      /* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        int tmptim;
        int *mdays;                     /* pointer to days or lpdays */

#ifdef  _MT

        struct tm *ptb;                 /* will point to gmtime buffer */
        _ptiddata ptd = _getptd();

#else
        struct tm *ptb = &tb;
#endif

        if ( (caltim < 0) || (caltim > _MAX__TIME64_T) )
                return(NULL);

#ifdef  _MT

        /* Use per thread buffer area (malloc space, if necessary) */

        if ( (ptd->_gmtimebuf != NULL) || ((ptd->_gmtimebuf =
            _malloc_crt(sizeof(struct tm))) != NULL) )
                ptb = ptd->_gmtimebuf;
        else
                ptb = &tb;      /* malloc error: use static buffer */

#endif

        /*
         * Determine the years since 1900. Start by ignoring leap years.
         */
        tmptim = (int)(caltim / _YEAR_SEC) + 70;
        caltim -= ((__time64_t)(tmptim - 70) * _YEAR_SEC);

        /*
         * Correct for elapsed leap years
         */
        caltim -= ((__time64_t)_ELAPSED_LEAP_YEARS(tmptim) * _DAY_SEC);

        /*
         * If we have underflowed the __time64_t range (i.e., if caltim < 0), 
         * back up one year, adjusting the correction if necessary.
         */
        if ( caltim < 0 ) {
            caltim += (__time64_t)_YEAR_SEC;
            tmptim--;
            if ( _IS_LEAP_YEAR(tmptim) ) {
                caltim += _DAY_SEC;
                islpyr++;
            }
        }
        else
            if ( _IS_LEAP_YEAR(tmptim) )
                islpyr++;

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (__time64_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (__time64_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return( (struct tm *)ptb );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\localtim.c ===
/***
*localtim.c - Convert time_t value to time structure
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a time_t value to a structure of type
*       struct tm expressed as local time.
*
*Revision History:
*       01-??-84  RLB   Module created
*       05-??-84  DCW   split off from the rest of the ctime routines
*       02-18-87  JCR   made localtime work when gmtime returns null
*       03-31-87  JCR   fixed bug pertaining to uninitialized _isindst(tb)
*       04-10-87  JCR   changed long declaration to time_t and added const
*       11-10-87  SKS   Removed IBMC20 switch
*       11-18-87  SKS   Change tzset() to __tzset()
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       11-06-89  KRS   Added (unsigned) to handle years 2040-2099 correctly.
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       fixed the copyright. Also, cleaned up the formatting
*                       a bit.
*       10-04-90  GJF   New-style function declarator. Also, rewrote expr.
*                       to avoid using cast as lvalue.
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix support (TZ stuff).
*       03-24-93  GJF   Ported C8-16 version and adapted for exotic Daylight
*                       Savings Time conversions which are legal under POSIX.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  GJF   Replaced _tzset() call with __tzset() call.
*       09-20-93  GJF   Merged NT SDK and Cuda version (amount to picking up
*                       fixes to Posix build).
*       11-04-93  GJF   Picked up a fix for the Posix build.
*       02-13-95  GJF   Call _tzset for Mac builds (temp change?). Also,
*                       picked up bug fix from Mac version (setting of
*                       tm_yday field in underflow case).
*       08-31-95  GJF   Use _dstbias as the Daylight Saving Time bias and
*                       all for the beginning or end of the Epoch to be in a
*                       DST.
*       02-07-98  GJF   Changes for Win64: replaced long type with time_t, 
*                       added some int casts where required, also use __int64
*                       max value for bounds checking.
*       09-25-98  GJF   Set tm_isdst, when appropriate, at beginning/end of the
*                       Epoch
*       05-17-99  PML   Remove all Macintosh support.
*       11-03-99  RDL   Win64 POSIX warning fix.
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <ctime.h>
#include <internal.h>

/***
*struct tm *localtime(ptime) - convert time_t value to tm structure
*
*Purpose:
*       Convert a value in internal (time_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime and localtime use a single statically allocated buffer.
*           Each call to one of these routines destroys the contents of the
*           previous call.
*       (3) It is assumed that time_t is a 32-bit long integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       time_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl localtime (
        const time_t *ptime
        )
{
        REG1 struct tm *ptm;
        time_t ltime;

        /*
         * Check for illegal time_t value
         */
        if ( *ptime < 0 )
                return( NULL );

#ifdef  _POSIX_
        tzset();
#else
        __tzset();
#endif

#ifdef  _WIN64
        if ( (*ptime > 3 * _DAY_SEC) && (*ptime < _I64_MAX - 3 * _DAY_SEC) ) {
#else
        if ( (*ptime > 3 * _DAY_SEC) && (*ptime < LONG_MAX - 3 * _DAY_SEC) ) {
#endif
                /*
                 * The date does not fall within the first three, or last
                 * three, representable days of the Epoch. Therefore, there
                 * is no possibility of overflowing or underflowing the
                 * time_t representation as we compensate for timezone and
                 * Daylight Savings Time.
                 */

                ltime = *ptime - _timezone;
                ptm = gmtime( &ltime );

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( _daylight && _isindst( ptm ) ) {
#ifdef  _POSIX_
                        ltime -= _dstoffset - _timezone;
#else
                        ltime -= _dstbias;
#endif
                        ptm = gmtime( &ltime );
                        ptm->tm_isdst = 1;
                }
        }
        else {
                ptm = gmtime( ptime );

                /*
                 * The date falls with the first three, or last three days
                 * of the Epoch. It is possible the time_t representation
                 * would overflow or underflow while compensating for
                 * timezone and Daylight Savings Time. Therefore, make the
                 * timezone and Daylight Savings Time adjustments directly
                 * in the tm structure. The beginning of the Epoch is
                 * 00:00:00, 01-01-70 (UTC) and the last representable second
                 * in the Epoch is 03:14:07, 01-19-2038 (UTC). This will be
                 * used in the calculations below.
                 *
                 * First, adjust for the timezone.
                 */
#ifdef  _POSIX_
                ltime = (time_t)ptm->tm_sec - _timezone;
#else
                if ( _daylight && _isindst(ptm) ) {
                        ltime = (time_t)ptm->tm_sec - (_timezone + _dstbias);
                        ptm->tm_isdst = 1;
                }
                else
                        ltime = (time_t)ptm->tm_sec - _timezone;
#endif
                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (time_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (time_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime > 0 ) {
                        /*
                         * There is no possibility of overflowing the tm_mday
                         * and tm_yday fields since the date can be no later
                         * than January 19.
                         */
                        ptm->tm_wday = (ptm->tm_wday + (int)ltime) % 7;
                        ptm->tm_mday += (int)ltime;
                        ptm->tm_yday += (int)ltime;
                }
                else if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                ptm->tm_yday = 364;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }

#ifdef  _POSIX_
                /*
                 * In Posix, it is possible either the first or last three
                 * days of the Epoch might lie with Daylight Savings Time in
                 * certain time zones.
                 */
                if ( _isindst(ptm) ) {

                        ltime = (long)ptm->tm_sec + _dstoffset;
                        ptm->tm_sec = (int)(ltime % 60);
                        if ( ptm->tm_sec < 0 ) {
                                ptm->tm_sec += 60;
                                ltime -= 60;
                        }

                        ltime = (long)ptm->tm_min + ltime/60;
                        ptm->tm_min = (int)(ltime % 60);
                        if ( ptm->tm_min < 0 ) {
                                ptm->tm_min += 60;
                                ltime -= 60;
                        }

                        ltime = (long)ptm->tm_hour + ltime/60;
                        ptm->tm_hour = (int)(ltime % 24);
                        if ( ptm->tm_hour < 0 ) {
                                ptm->tm_hour += 24;
                                ltime -=24;
                        }

                        ltime /= 24;

                        if ( ltime > 0L ) {
                                /*
                                 * There is no possibility of overflowing the
                                 * tm_mday and tm_yday fields since the date
                                 * can be no later than January 19.
                                 */
                                ptm->tm_wday = (int)((ptm->tm_wday + ltime) % 7);
                                ptm->tm_mday += (int)ltime;
                                ptm->tm_yday += (int)ltime;
                        }
                        else if ( ltime < 0L ) {
                                /*
                                 * It is possible to underflow the tm_mday
                                 * and tm_yday fields. If this happens, then
                                 * adjusted date must lie in December 1969.
                                 */
                                ptm->tm_wday = (int)((ptm->tm_wday + 7 + ltime) % 7);
                                if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                        ptm->tm_mday += 31;
                                        ptm->tm_yday = 364;
                                        ptm->tm_mon = 11;
                                        ptm->tm_year--;
                                }
                                else {
                                        ptm->tm_yday += (int)ltime;
                                }
                        }
                }

#endif

        }


        return(ptm);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\sources.inc ===
MAJORCOMP=crt
MINORCOMP=time

TARGETNAME=time

!INCLUDE ..\..\crt32.inc

INCLUDES=$(INCLUDES);..\..\extinc

SOURCES= \
    ..\asctime.c   \
    ..\clock.c     \
    ..\ctime.c     \
    ..\days.c      \
    ..\difftime.c  \
    ..\dtoxtime.c  \
    ..\ftime.c     \
    ..\gmtime.c    \
    ..\localtim.c  \
    ..\mktime.c    \
    ..\strftime.c  \
    ..\strdate.c   \
    ..\strtime.c   \
    ..\time.c      \
    ..\timeset.c   \
    ..\tzset.c     \
    ..\utime.c     \
    ..\ctime64.c   \
    ..\dtoxtm64.c  \
    ..\ftime64.c   \
    ..\gmtime64.c  \
    ..\loctim64.c  \
    ..\mktime64.c  \
    ..\time64.c    \
    ..\systime.c   \
    ..\utime64.c   \
    ..\wcsftime.c  \
    ..\wasctime.c  \
    ..\wctime.c    \
    ..\wctime64.c  \
    ..\wstrdate.c  \
    ..\wstrtime.c  \
    ..\wutime.c    \
    ..\wutime64.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\mktime64.c ===
/***
*mktime64.c - Convert struct tm value to __time64_t value.
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _mktime64() and _mkgmtime64(), routines to converts a time 
*       value in a tm structure (possibly incomplete) into a __time64_t value,
*       then update (all) the structure fields with "normalized" values.
*
*Revision History:
*       05-07-98  GJF   Created, adapted from Win64 version of mktime.c
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>


/*
 * Core function for both _mktime64() and _mkgmtime64()
 */
static __time64_t __cdecl _make__time64_t( struct tm *, int);


/***
*__time64_t _mktime64(tb) - Normalize user time block structure
*
*Purpose:
*       _mktime64 converts a time structure, passed in as an argument, into a
*       64-bit calendar time value in internal format (__time64_t). It also 
*       completes and updates the fields the of the passed in structure with 
*       'normalized' values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (__time64_t).
*       (2) To have _mktime64 fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have _mktime64 "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded as
*       a __time64_t value. Otherwise, (__time64_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

__time64_t __cdecl _mktime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 1) );
}


/***
*__time64_t _mkgmtime64(tb) - Convert broken down UTC time to __time64_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to 64-bit internal format (__time64_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values.
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime64 returns the calender time encoded as a
*       __time64_t value.
*       Otherwise, (__time64_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

__time64_t __cdecl _mkgmtime64 (
        struct tm *tb
        )
{
        return( _make__time64_t(tb, 0) );
}


/***
*static __time64_t make_time_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a __time64_t value, then updates the 
*       struct tm value. Either local time or UTC is supported, based on 
*       ultflag. This is the routine that actually does the work for both
*       _mktime64() and _mkgmtime64().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, _mktime64 returns the specified calender time encoded
*       as a __time64_t value. Otherwise, (__time64_t)(-1) is returned to
*       indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static __time64_t __cdecl _make__time64_t (
        struct tm *tb,
        int ultflag
        )
{
        __time64_t tmptm1, tmptm2, tmptm3;
        struct tm *tbtemp;

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR64 + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( _IS_LEAP_YEAR(tmptm1) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365 + _ELAPSED_LEAP_YEARS(tmptm1);

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date.
         */
        tmptm1 = tmptm3 + (tmptm2 = (__time64_t)(tb->tm_mday));

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_hour);

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_min);

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60;

        tmptm1 = tmptm2 + (tmptm3 = (__time64_t)tb->tm_sec);

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

#ifdef _POSIX_
            tzset();
#else
            __tzset();
#endif

            tmptm1 += _timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( (tbtemp = _localtime64(&tmptm1)) == NULL )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp->tm_isdst > 0)) ) {
#ifdef _POSIX_
                tmptm1 -= _timezone;
                tmptm1 += _dstoffset;
#else
                tmptm1 += _dstbias;
#endif
                tbtemp = _localtime64(&tmptm1); /* reconvert, can't get NULL */
            }

        } 
        else {
            if ( (tbtemp = _gmtime64(&tmptm1)) == NULL )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = *tbtemp;
        return tmptm1;

err_mktime:
        /*
         * All errors come to here
         */
        return (__time64_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\loctim64.c ===
/***
*loctim64.c - Convert __time64_t value to time structure
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts time stored as a __time64_t value to a structure of type
*       struct tm expressed as local time.
*
*Revision History:
*       05-11-98  GJF   Created, adapted from the Win64 version.
*       09-25-98  GJF   Set tm_isdst, when appropriate, at beginning/end of the
*                       Epoch
*
*******************************************************************************/

#include <cruntime.h>
#include <limits.h>
#include <time.h>
#include <stddef.h>
#include <ctime.h>
#include <internal.h>

/***
*struct tm *_localtime64(ptime) - convert __time64_t value to tm structure
*
*Purpose:
*       Convert a value in 64-bit internal (__time64_t) format to a tm struct
*       containing the corresponding local time.
*
* NOTES:
*       (1) gmtime must be called before _isindst to ensure that the tb time
*           structure is initialized.
*       (2) gmtime, _gtime64, localtime and _localtime64() all use a single 
*           statically allocated buffer. Each call to one of these routines 
*           destroys the contents of the previous call.
*       (3) It is assumed that __time64_t is a 64-bit integer representing
*           the number of seconds since 00:00:00, 01-01-70 (UTC) (i.e., the
*           Posix/Unix Epoch. Only non-negative values are supported.
*       (4) It is assumed that the maximum adjustment for local time is
*           less than three days (include Daylight Savings Time adjustment).
*           This only a concern in Posix where the specification of the TZ
*           environment restricts the combined offset for time zone and
*           Daylight Savings Time to 2 * (24:59:59), just under 50 hours.
*
*Entry:
*       __time64_t *ptime - pointer to a long time value
*
*Exit:
*       If *ptime is non-negative, returns a pointer to the tm structure.
*       Otherwise, returns NULL.
*
*Exceptions:
*       See items (3) and (4) in the NOTES above. If these assumptions are
*       violated, behavior is undefined.
*
*******************************************************************************/

struct tm * __cdecl _localtime64 (
        const __time64_t *ptime
        )
{
        REG1 struct tm *ptm;
        __time64_t ltime;

        /*
         * Check for illegal __time64_t value
         */
        if ( (*ptime < 0) || (*ptime > _MAX__TIME64_T) )
                return( NULL );

        __tzset();

        if ( *ptime > 3 * _DAY_SEC ) {
                /*
                 * The date does not fall within the first three representable
                 * days of the Epoch. Therefore, there is no possibility of 
                 * underflowing the __time64_t representation as we compensate 
                 * for timezone and Daylight Savings Time.
                 */

                ltime = *ptime - _timezone;
                ptm = _gmtime64( &ltime );

                /*
                 * Check and adjust for Daylight Saving Time.
                 */
                if ( _daylight && _isindst( ptm ) ) {
                        ltime -= _dstbias;
                        ptm = _gmtime64( &ltime );
                        ptm->tm_isdst = 1;
                }
        }
        else {
                ptm = _gmtime64( ptime );

                /*
                 * The date falls with the first three days of the Epoch.
                 * It is possible the time_t representation would underflow
                 * while compensating for timezone and Daylight Savings Time
                 * Therefore, make the timezone and Daylight Savings Time
                 * adjustments directly in the tm structure. The beginning of
                 * the Epoch is 00:00:00, 01-01-70 (UTC).
                 *
                 * First, adjust for the timezone.
                 */
                if ( _isindst(ptm) ) {
                        ltime = (__time64_t)ptm->tm_sec - (_timezone + _dstbias);
                        ptm->tm_isdst;
                }
                else
                        ltime = (__time64_t)ptm->tm_sec - _timezone;

                ptm->tm_sec = (int)(ltime % 60);
                if ( ptm->tm_sec < 0 ) {
                        ptm->tm_sec += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_min + ltime/60;
                ptm->tm_min = (int)(ltime % 60);
                if ( ptm->tm_min < 0 ) {
                        ptm->tm_min += 60;
                        ltime -= 60;
                }

                ltime = (__time64_t)ptm->tm_hour + ltime/60;
                ptm->tm_hour = (int)(ltime % 24);
                if ( ptm->tm_hour < 0 ) {
                        ptm->tm_hour += 24;
                        ltime -=24;
                }

                ltime /= 24;

                if ( ltime < 0 ) {
                        /*
                         * It is possible to underflow the tm_mday and tm_yday
                         * fields. If this happens, then adjusted date must
                         * lie in December 1969.
                         */
                        ptm->tm_wday = (ptm->tm_wday + 7 + (int)ltime) % 7;
                        if ( (ptm->tm_mday += (int)ltime) <= 0 ) {
                                ptm->tm_mday += 31;
                                ptm->tm_yday = 364;
                                ptm->tm_mon = 11;
                                ptm->tm_year--;
                        }
                        else {
                                ptm->tm_yday += (int)ltime;
                        }
                }
        }


        return(ptm);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\systime.c ===
/***
*systime.c - _getsystime and _setsystime
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getsystime() and _setsystime()
*
*Revision History:
*       08-22-91  BWM   Wrote module.
*       05-19-92  DJM   ifndef for POSIX build.
*       09-25-92  SKS   Use SetLocalTime(), not SetSystemTime().
*                       Fix bug: daylight flag must be initialized to -1.
*                       Replace C++ comments with C-style comments
*       11-10-93  GJF   Resurrected from from crt32 (for compatibility with
*                       the NT SDK release) and cleaned up.
*       08-30-99  PML   Fix function header comment in _getsystime(), detab.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <oscalls.h>
#include <time.h>

/***
*unsigned _getsystime(timestruc) - Get current system time
*
*Purpose:
*
*Entry:
*       struct tm * ptm - time structure
*
*Exit:
*       milliseconds of current time
*
*Exceptions:
*
*******************************************************************************/

unsigned __cdecl _getsystime(struct tm * ptm)
{
    SYSTEMTIME  st;

    GetLocalTime(&st);

    ptm->tm_isdst       = -1;   /* mktime() computes whether this is */
                                /* during Standard or Daylight time. */
    ptm->tm_sec         = (int)st.wSecond;
    ptm->tm_min         = (int)st.wMinute;
    ptm->tm_hour        = (int)st.wHour;
    ptm->tm_mday        = (int)st.wDay;
    ptm->tm_mon         = (int)st.wMonth - 1;
    ptm->tm_year        = (int)st.wYear - 1900;
    ptm->tm_wday        = (int)st.wDayOfWeek;

    /* Normalize uninitialized fields */
    mktime(ptm);

    return (st.wMilliseconds);
}

#ifndef _XBSTRICT

/***
*unsigned _setsystime(timestruc, milliseconds) - Set new system time
*
*Purpose:
*
*Entry:
*       struct tm * ptm - time structure
*       unsigned milliseconds - milliseconds of current time
*
*Exit:
*       0 if succeeds
*       system error if fails
*
*Exceptions:
*
*******************************************************************************/

unsigned __cdecl _setsystime(struct tm * ptm, unsigned uMilliseconds)
{
#ifndef _XBOX
    SYSTEMTIME  st;

    /* Normalize uninitialized fields */
    mktime(ptm);

    st.wYear            = (WORD)(ptm->tm_year + 1900);
    st.wMonth           = (WORD)(ptm->tm_mon + 1);
    st.wDay             = (WORD)ptm->tm_mday;
    st.wHour            = (WORD)(ptm->tm_hour);
    st.wMinute          = (WORD)ptm->tm_min;
    st.wSecond          = (WORD)ptm->tm_sec;
    st.wMilliseconds    = (WORD)uMilliseconds;

    if (!SetLocalTime(&st)) {
        return ((int)GetLastError());
    }

    return (0);
#else // XBOX
    RIP("_setsystime() not supported on Xbox");
    return -1;
#endif // XBOX
}

#endif // XBSTRICT

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\strtime.c ===
/***
*strtime.c - contains the function "_strtime()"
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _strtime()
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-10-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <tchar.h>
#include <oscalls.h>


/***
*_TSCHAR *_strtime(buffer) - return time in string form
*
*Purpose:
*       _strtime() returns a string containing the time in "HH:MM:SS" form
*
*Entry:
*       _TSCHAR *buffer = the address of a 9-byte user buffer
*
*Exit:
*       returns buffer, which contains the time in "HH:MM:SS" form
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tstrtime (
        _TSCHAR *buffer
        )
{
        int hours, minutes, seconds;
        SYSTEMTIME dt;                       /* Win32 time structure */
        GetLocalTime(&dt);

        hours = dt.wHour;
        minutes = dt.wMinute;
        seconds = dt.wSecond;

        /* store the components of the time into the string */
        /* store separators */
        buffer[2] = buffer[5] = _T(':');
        /* store end of string */
        buffer[8] = _T('\0');
        /* store tens of hour */
        buffer[0] = (_TSCHAR) (hours   / 10 + _T('0'));
        /* store units of hour */
        buffer[1] = (_TSCHAR) (hours   % 10 + _T('0'));
        /* store tens of minute */
        buffer[3] = (_TSCHAR) (minutes / 10 + _T('0'));
        /* store units of minute */
        buffer[4] = (_TSCHAR) (minutes % 10 + _T('0'));
        /* store tens of second */
        buffer[6] = (_TSCHAR) (seconds / 10 + _T('0'));
        /* store units of second */
        buffer[7] = (_TSCHAR) (seconds % 10 + _T('0'));

        return buffer;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\strdate.c ===
/***
*strdate.c - contains the function "_strdate()"
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the function _strdate()
*
*Revision History:
*       06-07-89  PHG   Module created, base on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-10-95  GJF   Merged in Mac version.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <tchar.h>
#include <time.h>
#include <oscalls.h>


/***
*_TSCHAR *_strdate(buffer) - return date in string form
*
*Purpose:
*       _strdate() returns a string containing the date in "MM/DD/YY" form
*
*Entry:
*       _TSCHAR *buffer = the address of a 9-byte user buffer
*
*Exit:
*       returns buffer, which contains the date in "MM/DD/YY" form
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tstrdate (
        _TSCHAR *buffer
        )
{
        int month, day, year;
        SYSTEMTIME dt;                  /* Win32 time structure */

        GetLocalTime(&dt);
        month = dt.wMonth;
        day = dt.wDay;
        year = dt.wYear % 100;          /* change year into 0-99 value */

        /* store the components of the date into the string */
        /* store seperators */
        buffer[2] = buffer[5] = _T('/');
        /* store end of string */
        buffer[8] = _T('\0');
        /* store tens of month */
        buffer[0] = (_TSCHAR) (month / 10 + _T('0'));
        /* store units of month */
        buffer[1] = (_TSCHAR) (month % 10 + _T('0'));
        /* store tens of day */
        buffer[3] = (_TSCHAR) (day   / 10 + _T('0'));
        /* store units of day */
        buffer[4] = (_TSCHAR) (day   % 10 + _T('0'));
        /* store tens of year */
        buffer[6] = (_TSCHAR) (year  / 10 + _T('0'));
        /* store units of year */
        buffer[7] = (_TSCHAR) (year  % 10 + _T('0'));

        return buffer;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\strftime.c ===
/***
*strftime.c - String Format Time
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-09-89  JCR   Initial version.
*       03-15-89  JCR   Changed day/month strings from all caps to leading cap
*       06-20-89  JCR   Removed _LOAD_DGROUP code
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h> and
*                       removed some leftover 16-bit support. Also, fixed
*                       the copyright.
*       03-23-90  GJF   Made static functions _CALLTYPE4.
*       07-23-90  SBM   Compiles cleanly with -W3 (removed unreferenced
*                       variable)
*       08-13-90  SBM   Compiles cleanly with -W3 with new build of compiler
*       10-04-90  GJF   New-style function declarators.
*       01-22-91  GJF   ANSI naming.
*       08-15-91  MRM   Calls tzset() to set timezone info in case of %z.
*       08-16-91  MRM   Put appropriate header file for tzset().
*       10-10-91  ETC   Locale support under _INTL switch.
*       12-18-91  ETC   Use localized time strings structure.
*       02-10-93  CFW   Ported to Cuda tree, change _CALLTYPE4 to _CRTAPI3.
*       02-16-93  CFW   Massive changes: bug fixes & enhancements.
*       03-08-93  CFW   Changed _expand to _expandtime.
*       03-09-93  CFW   Handle string literals inside format strings.
*       03-09-93  CFW   Alternate form cleanup.
*       03-17-93  CFW   Change *count > 0, to *count != 0, *count is unsigned.
*       03-22-93  CFW   Change "C" locale time format specifier to 24-hour.
*       03-30-93  GJF   Call _tzset instead of __tzset (which no longer
*                       exists).
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-14-93  CFW   Disable _alternate_form for 'X' specifier, fix count bug.
*       04-28-93  CFW   Fix bug in '%c' handling.
*       07-15-93  GJF   Call __tzset() in place of _tzset().
*       09-15-93  CFW   Use ANSI conformant "__" names.
*       04-11-94  GJF   Made definitions of __lc_time_c, _alternate_form and
*                       _no_lead_zeros conditional on ndef DLL_FOR_WIN32S.
*       09-06-94  CFW   Remove _INTL switch.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       09-26-95  GJF   New locking macro, and scheme, for functions which
*                       reference the locale.
*       02-22-96  JWM   Merge in PlumHall mods.
*       06-17-96  SKS   Enable new Plum-Hall code for _MAC as well as _WIN32
*       07-10-97  GJF   Made __lc_time_c selectany. Also, removed unnecessary
*                       init to 0 for globals, cleaned up the formatting a bit,
*                       added a few __cdecls and detailed old (and no longer
*                       used as of 6/17/96 change) Mac version.
*       08-21-97  GJF   Added support for AM/PM type suffix to time string.
*       09-10-98  GJF   Added support for per-thread locale info.
*       03-04-99  GJF   Added refcount field to __lc_time_c.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   Don't overflow buffer on leadbyte in _store_winword.
*       03-17-00  PML   Corrected _Gettnames to also copy ww_timefmt (VS7#9374)
*       09-07-00  PML   Remove dependency on libcp.lib/xlocinfo.h (vs7#159463)
*       03-25-01  PML   Use GetDateFormat/GetTimeFormat in _store_winword for
*                       calendar types other than the basic type 1, localized
*                       Gregorian (vs7#196892)  Also fix formatting for leading
*                       zero suppression in fields, which was busted for %c,
*                       %x, %X.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <time.h>
#include <locale.h>
#include <setlocal.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <dbgint.h>
#include <malloc.h>

#ifdef _XBOX
#ifdef _MT
#define _XBMT
#endif
#undef _MT
#endif // XBOX

/* Prototypes for local routines */
static void __cdecl _expandtime(
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        char specifier,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time,
        unsigned alternate_form);

static void __cdecl _store_str (char *in, char **out, size_t *count);

static void __cdecl _store_num (int num, int digits, char **out, size_t *count,
        unsigned no_lead_zeros);

static void __cdecl _store_number (int num, char **out, size_t *count);

static void __cdecl _store_winword (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        int field_code,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time);

size_t __cdecl _Strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        );

#ifdef  _MT
size_t __cdecl _Strftime_mt (pthreadlocinfo ptloci, char *string, size_t maxsize,
        const char *format, const struct tm *timeptr, void *lc_time_arg);
#endif

/* LC_TIME data for local "C" */

__declspec(selectany) struct __lc_time_data __lc_time_c = {

        {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"},

        {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
                "Friday", "Saturday", },

        {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug",
                "Sep", "Oct", "Nov", "Dec"},

        {"January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October",
                "November", "December"},

        {"AM", "PM"},

        { "MM/dd/yy" },
        { "dddd, MMMM dd, yyyy" },
        { "HH:mm:ss" },

        0x0409,
        1,

#if defined(_MT) || defined(_XBMT)
        0
#endif
        };

/* Pointer to the current LC_TIME data structure. */

struct __lc_time_data *__lc_time_curr = &__lc_time_c;

/* Codes for __lc_time_data ww_* fields for _store_winword */

#define WW_SDATEFMT     0
#define WW_LDATEFMT     1
#define WW_TIMEFMT      2

#define TIME_SEP        ':'

/*      get a copy of the current day names */
char * __cdecl _Getdays (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        char *p;

        for (n = 0; n < 7; ++n)
            len += strlen(pt->wday_abbr[n]) + strlen(pt->wday[n]) + 2;
        p = (char *)_malloc_crt(len + 1);

        if (p != 0) {
            char *s = p;

            for (n = 0; n < 7; ++n) {
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->wday_abbr[n]));
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->wday[n]));
            }
            *s++ = '\0';
        }

        return (p);
}

/*      get a copy of the current month names */
char * __cdecl _Getmonths (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        char *p;

        for (n = 0; n < 12; ++n)
            len += strlen(pt->month_abbr[n]) + strlen(pt->month[n]) + 2;
        p = (char *)_malloc_crt(len + 1);

        if (p != 0) {
            char *s = p;

            for (n = 0; n < 12; ++n) {
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->month_abbr[n]));
                *s++ = TIME_SEP;
                s += strlen(strcpy(s, pt->month[n]));
            }
            *s++ = '\0';
        }

        return (p);
}

/*      get a copy of the current time locale information */
void * __cdecl _Gettnames (
        void
        )
{
        const struct __lc_time_data *pt = __lc_time_curr;
        size_t n, len = 0;
        void *p;

        for (n = 0; n < 7; ++n)
            len += strlen(pt->wday_abbr[n]) + strlen(pt->wday[n]) + 2;
        for (n = 0; n < 12; ++n)
            len += strlen(pt->month_abbr[n]) + strlen(pt->month[n]) + 2;
        len += strlen(pt->ampm[0]) + strlen(pt->ampm[1]) + 2;
        len += strlen(pt->ww_sdatefmt) + 1;
        len += strlen(pt->ww_ldatefmt) + 1;
        len += strlen(pt->ww_timefmt) + 1;
        p = _malloc_crt(sizeof (*pt) + len);

        if (p != 0) {
            struct __lc_time_data *pn = (struct __lc_time_data *)p;
            char *s = (char *)p + sizeof (*pt);

            memcpy(p, __lc_time_curr, sizeof (*pt));
            for (n = 0; n < 7; ++n) {
                pn->wday_abbr[n] = s;
                s += strlen(strcpy(s, pt->wday_abbr[n])) + 1;
                pn->wday[n] = s;
                s += strlen(strcpy(s, pt->wday[n])) + 1;
            }
            for (n = 0; n < 12; ++n) {
                pn->month_abbr[n] = s;
                s += strlen(strcpy(s, pt->month_abbr[n])) + 1;
                pn->month[n] = s;
                s += strlen(strcpy(s, pt->month[n])) + 1;
            }
            pn->ampm[0] = s;
            s += strlen(strcpy(s, pt->ampm[0])) + 1;
            pn->ampm[1] = s;
            s += strlen(strcpy(s, pt->ampm[1])) + 1;
            pn->ww_sdatefmt = s;
            s += strlen(strcpy(s, pt->ww_sdatefmt)) + 1;
            pn->ww_ldatefmt = s;
            s += strlen(strcpy(s, pt->ww_ldatefmt)) + 1;
            pn->ww_timefmt = s;
            strcpy(s, pt->ww_timefmt);
        }

        return (p);
}


/***
*size_t strftime(string, maxsize, format, timeptr) - Format a time string
*
*Purpose:
*       Place characters into the user's output buffer expanding time
*       format directives as described in the user's control string.
*       Use the supplied 'tm' structure for time data when expanding
*       the format directives.
*       [ANSI]
*
*Entry:
*       char *string = pointer to output string
*       size_t maxsize = max length of string
*       const char *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of chars placed in the 'string' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr
        )
{
        return (_Strftime(string, maxsize, format, timeptr, 0));
}

/***
*size_t _Strftime(string, maxsize, format,
*       timeptr, lc_time) - Format a time string for a given locale
*
*Purpose:
*       Place characters into the user's output buffer expanding time
*       format directives as described in the user's control string.
*       Use the supplied 'tm' structure for time data when expanding
*       the format directives. use the locale information at lc_time.
*       [ANSI]
*
*Entry:
*       char *string = pointer to output string
*       size_t maxsize = max length of string
*       const char *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*               struct __lc_time_data *lc_time = pointer to locale-specific info
*                       (passed as void * to avoid type mismatch with C++)
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of chars placed in the 'string' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl _Strftime (
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        )
{
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();

        return _Strftime_mt(ptloci, string, maxsize, format, timeptr,
                            lc_time_arg);
}

size_t __cdecl _Strftime_mt (
        pthreadlocinfo ptloci,
        char *string,
        size_t maxsize,
        const char *format,
        const struct tm *timeptr,
        void *lc_time_arg
        )
{
#endif
        unsigned alternate_form;
        struct __lc_time_data *lc_time;
        size_t left;                    /* space left in output string */
#ifdef  _MT
        lc_time = lc_time_arg == 0 ? ptloci->lc_time_curr :
#else
        lc_time = lc_time_arg == 0 ? __lc_time_curr :
#endif
                  (struct __lc_time_data *)lc_time_arg;

        /* Copy maxsize into temp. */
        left = maxsize;

        /* Copy the input string to the output string expanding the format
        designations appropriately.  Stop copying when one of the following
        is true: (1) we hit a null char in the input stream, or (2) there's
        no room left in the output stream. */

        while (left > 0)
        {
            switch(*format)
            {

            case('\0'):

                /* end of format input string */
                goto done;

            case('%'):

                /* Format directive.  Take appropriate action based
                on format control character. */

                format++;                       /* skip over % char */

                /* process flags */
                alternate_form = 0;
                if (*format == '#')
                {
                    alternate_form = 1;
                    format++;
                }
#ifdef  _MT
                _expandtime (ptloci, *format, timeptr, &string,
#else
                _expandtime (*format, timeptr, &string,
#endif
                             &left,lc_time, alternate_form);
                format++;                       /* skip format char */
                break;


            default:

                /* store character, bump pointers, dec the char count */
                if (isleadbyte((int)(*format)) && left > 1)
                {
                    *string++ = *format++;
                    left--;
                }
                *string++ = *format++;
                left--;
                break;
            }
        }


        /* All done.  See if we terminated because we hit a null char or because
        we ran out of space */

        done:

        if (left > 0) {

            /* Store a terminating null char and return the number of chars
            we stored in the output string. */

            *string = '\0';
            return(maxsize-left);
        }

        else
            return(0);

}


/***
*_expandtime() - Expand the conversion specifier
*
*Purpose:
*       Expand the given strftime conversion specifier using the time struct
*       and store it in the supplied buffer.
*
*       The expansion is locale-dependent.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       char specifier = strftime conversion specifier to expand
*       const struct tm *tmptr = pointer to time/date structure
*       char **string = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*       struct __lc_time_data *lc_time = pointer to locale-specific info
*
*Exit:
*       none
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _expandtime (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        char specifier,
        const struct tm *timeptr,
        char **string,
        size_t *left,
        struct __lc_time_data *lc_time,
        unsigned alternate_form
        )
{
        unsigned temp;                  /* temps */
        int wdaytemp;

        /* Use a copy of the appropriate __lc_time_data pointer.  This
        should prevent the necessity of locking/unlocking in mthread
        code (if we can guarantee that the various __lc_time data
        structures are always in the same segment). contents of time
        strings structure can now change, so thus we do use locking */

        switch(specifier) {             /* switch on specifier */

        case('a'):              /* abbreviated weekday name */
            _store_str((char *)(lc_time->wday_abbr[timeptr->tm_wday]),
                     string, left);
            break;

        case('A'):              /* full weekday name */
            _store_str((char *)(lc_time->wday[timeptr->tm_wday]),
                     string, left);
            break;

        case('b'):              /* abbreviated month name */
            _store_str((char *)(lc_time->month_abbr[timeptr->tm_mon]),
                     string, left);
            break;

        case('B'):              /* full month name */
            _store_str((char *)(lc_time->month[timeptr->tm_mon]),
                     string, left);
            break;

        case('c'):              /* date and time display */
            if (alternate_form)
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_LDATEFMT, timeptr, string, left, lc_time);
                if (*left == 0)
                    return;
                *(*string)++=' ';
                (*left)--;
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_TIMEFMT, timeptr, string, left, lc_time);
            }
            else {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_SDATEFMT, timeptr, string, left, lc_time);
                if (*left == 0)
                    return;
                *(*string)++=' ';
                (*left)--;
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_TIMEFMT, timeptr, string, left, lc_time);
            }
            break;

        case('d'):              /* mday in decimal (01-31) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_mday, 2, string, left, 
                       alternate_form);
            break;

        case('H'):              /* 24-hour decimal (00-23) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_hour, 2, string, left,
                       alternate_form);
            break;

        case('I'):              /* 12-hour decimal (01-12) */
            if (!(temp = timeptr->tm_hour%12))
                temp=12;
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('j'):              /* yday in decimal (001-366) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_yday+1, 3, string, left,
                       alternate_form);
            break;

        case('m'):              /* month in decimal (01-12) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_mon+1, 2, string, left,
                       alternate_form);
            break;

        case('M'):              /* minute in decimal (00-59) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_min, 2, string, left,
                       alternate_form);
            break;

        case('p'):              /* AM/PM designation */
            if (timeptr->tm_hour <= 11)
                _store_str((char *)(lc_time->ampm[0]), string, left);
            else
                _store_str((char *)(lc_time->ampm[1]), string, left);
            break;

        case('S'):              /* secs in decimal (00-59) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_sec, 2, string, left,
                       alternate_form);
            break;

        case('U'):              /* sunday week number (00-53) */
            wdaytemp = timeptr->tm_wday;
            goto weeknum;   /* join common code */

        case('w'):              /* week day in decimal (0-6) */
            /* pass alternate_form as the no leading zeros flag */
            _store_num(timeptr->tm_wday, 1, string, left,
                       alternate_form);
            break;

        case('W'):              /* monday week number (00-53) */
            if (timeptr->tm_wday == 0)  /* monday based */
                wdaytemp = 6;
            else
                wdaytemp = timeptr->tm_wday-1;
        weeknum:
            if (timeptr->tm_yday < wdaytemp)
                temp = 0;
            else {
                temp = timeptr->tm_yday/7;
                if ((timeptr->tm_yday%7) >= wdaytemp)
                    temp++;
            }
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('x'):              /* date display */
            if (alternate_form)
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_LDATEFMT, timeptr, string, left, lc_time);
            }
            else
            {
                _store_winword(
#ifdef  _MT
                               ptloci,
#endif
                               WW_SDATEFMT, timeptr, string, left, lc_time);
            }
            break;

        case('X'):              /* time display */
            _store_winword(
#ifdef  _MT
                           ptloci,
#endif
                           WW_TIMEFMT, timeptr, string, left, lc_time);
            break;

        case('y'):              /* year w/o century (00-99) */
            temp = timeptr->tm_year%100;
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 2, string, left, alternate_form);
            break;

        case('Y'):              /* year w/ century */
            temp = (((timeptr->tm_year/100)+19)*100) +
                   (timeptr->tm_year%100);
            /* pass alternate_form as the no leading zeros flag */
            _store_num(temp, 4, string, left, alternate_form);
            break;

        case('Z'):              /* time zone name, if any */
        case('z'):              /* time zone name, if any */
#ifdef _POSIX_
            tzset();        /* Set time zone info */
            _store_str(tzname[((timeptr->tm_isdst)?1:0)],
                     string, left);
#else
            __tzset();      /* Set time zone info */
            _store_str(_tzname[((timeptr->tm_isdst)?1:0)],
                     string, left);
#endif
            break;

        case('%'):              /* percent sign */
            *(*string)++ = '%';
            (*left)--;
            break;

        default:                /* unknown format directive */
            /* ignore the directive and continue */
            /* [ANSI: Behavior is undefined.]    */
            break;

        }       /* end % switch */
}


/***
*_store_str() - Copy a time string
*
*Purpose:
*       Copy the supplied time string into the output string until
*       (1) we hit a null in the time string, or (2) the given count
*       goes to 0.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       char *in = pointer to null terminated time string
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*
*Exit:
*       none
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_str (
        char *in,
        char **out,
        size_t *count
        )
{

        while ((*count != 0) && (*in != '\0')) {
            *(*out)++ = *in++;
            (*count)--;
        }
}


/***
*_store_num() - Convert a number to ascii and copy it
*
*Purpose:
*       Convert the supplied number to decimal and store
*       in the output buffer.  Update both the count and
*       buffer pointers.
*
*       *** For internal use with strftime() only ***
*
*Entry:
*       int num                 = pointer to integer value
*       int digits              = # of ascii digits to put into string
*       char **out              = address of pointer to output string
*       size_t *count           = address of char count (space in output area)
*       unsigned no_lead_zeros  = flag indicating that padding by leading
*                                 zeros is not necessary
*
*Exit:
*       none
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_num (
        int num,
        int digits,
        char **out,
        size_t *count,
        unsigned no_lead_zeros
        )
{
        int temp = 0;

        if (no_lead_zeros) {
            _store_number (num, out, count);
            return;
        }

        if ((size_t)digits < *count)  {
            for (digits--; (digits+1); digits--) {
                (*out)[digits] = (char)('0' + num % 10);
                num /= 10;
                temp++;
            }
            *out += temp;
            *count -= temp;
        }
        else
            *count = 0;
}

/***
*_store_number() - Convert positive integer to string
*
*Purpose:
*       Convert positive integer to a string and store it in the output
*       buffer with no null terminator.  Update both the count and
*       buffer pointers.
*
*       Differs from _store_num in that the precision is not specified,
*       and no leading zeros are added.
*
*       *** For internal use with strftime() only ***
*
*       Created from xtoi.c
*
*Entry:
*       int num = pointer to integer value
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*
*Exit:
*       none
*
*Exceptions:
*       The buffer is filled until it is out of space.  There is no
*       way to tell beforehand (as in _store_num) if the buffer will
*       run out of space.
*
*******************************************************************************/

static void __cdecl _store_number (
        int num,
        char **out,
        size_t *count
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */

        p = *out;

        /* put the digits in the buffer in reverse order */
        if (*count > 1)
        {
            do {
                *p++ = (char) (num % 10 + '0');
                (*count)--;
            } while ((num/=10) > 0 && *count > 1);
        }

        firstdig = *out;                /* firstdig points to first digit */
        *out = p;                       /* return pointer to next space */
        p--;                            /* p points to last digit */

        /* reverse the buffer */
        do {
            temp = *p;
            *p-- = *firstdig;
            *firstdig++ = temp;     /* swap *p and *firstdig */
        } while (firstdig < p);         /* repeat until halfway */
}


/***
*_store_winword() - Store date/time in WinWord format
*
*Purpose:
*       Format the date/time in the supplied WinWord format
*       and store it in the supplied buffer.
*
*       *** For internal use with strftime() only ***
*
*       For simple localized Gregorian calendars (calendar type 1), the WinWord
*       format is converted token by token to strftime conversion specifiers.
*       _expandtime is then called to do the work.  The WinWord format is
*       expected to be a character string (not wide-chars).
*
*       For other calendar types, the Win32 APIs GetDateFormat/GetTimeFormat
*       are instead used to do all formatting, so that this routine doesn't
*       have to know about era/period strings, year offsets, etc.
*
*
*Entry:
*       int field_code = code for ww_* field with format 
*       const struct tm *tmptr = pointer to time/date structure
*       char **out = address of pointer to output string
*       size_t *count = address of char count (space in output area)
*       struct __lc_time_data *lc_time = pointer to locale-specific info
*
*Exit:
*       none
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _store_winword (
#ifdef  _MT
        pthreadlocinfo ptloci,
#endif
        int field_code,
        const struct tm *tmptr,
        char **out,
        size_t *count,
        struct __lc_time_data *lc_time
        )
{
        const char *format;
        char specifier;
        const char *p;
        int repeat;
        char *ampmstr;
        unsigned no_lead_zeros;

        switch (field_code)
        {
        case WW_SDATEFMT:
            format = lc_time->ww_sdatefmt;
            break;
        case WW_LDATEFMT:
            format = lc_time->ww_ldatefmt;
            break;
        case WW_TIMEFMT:
        default:
            format = lc_time->ww_timefmt;
            break;
        }


        if (lc_time->ww_caltype != 1)
        {
#ifdef _XBOX
            RIP("strftime: unsupported date/time format");
#else
            /* We have something other than the basic Gregorian calendar */

            SYSTEMTIME SystemTime;
            int cch;
            int (WINAPI * FormatFunc)(LCID, DWORD, const SYSTEMTIME *,
                                      LPCSTR, LPSTR, int);

            if (field_code != WW_TIMEFMT)
                FormatFunc = GetDateFormat;
            else
                FormatFunc = GetTimeFormat;

            SystemTime.wYear   = (WORD)(tmptr->tm_year + 1900);
            SystemTime.wMonth  = (WORD)(tmptr->tm_mon + 1);
            SystemTime.wDay    = (WORD)(tmptr->tm_mday);
            SystemTime.wHour   = (WORD)(tmptr->tm_hour);
            SystemTime.wMinute = (WORD)(tmptr->tm_min);
            SystemTime.wSecond = (WORD)(tmptr->tm_sec);
            SystemTime.wMilliseconds = 0;

            /* Find buffer size required */
            cch = FormatFunc(lc_time->ww_lcid, 0, &SystemTime,
                             format, NULL, 0);

            if (cch != 0)
            {
                int malloc_flag = 0;
                char *buffer;

                /* Allocate buffer, first try stack, then heap */
                __try
                {
                    buffer = (char *)_alloca(cch);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    _resetstkoflw();
                    buffer = NULL;
                }

                if (buffer == NULL)
                {
                    buffer = (char *)_malloc_crt(cch);
                    if (buffer != NULL)
                        malloc_flag = 1;
                }

                if (buffer != NULL)
                {
                    /* Do actual date/time formatting */
                    cch = FormatFunc(lc_time->ww_lcid, 0, &SystemTime,
                                     format, buffer, cch);

                    /* Copy to output buffer */
                    p = buffer;
                    while (--cch > 0 && *count > 0) {
                        *(*out)++ = *p++;
                        (*count)--;
                    }

                    if (malloc_flag)
                        _free_crt(buffer);
                    return;
                }
            }

            /* In case of error, just fall through to localized Gregorian */
#endif // XBOX
        }

        while (*format && *count != 0)
        {
            specifier = 0;          /* indicate no match */
            no_lead_zeros = 0;      /* default is print leading zeros */

            /* count the number of repetitions of this character */
            for (repeat=0, p=format; *p++ == *format; repeat++);
            /* leave p pointing to the beginning of the next token */
            p--;

            /* switch on ascii format character and determine specifier */
            switch (*format)
            {
            case 'M':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'm'; break;
                case 3: specifier = 'b'; break;
                case 4: specifier = 'B'; break;
                } break;
            case 'd':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'd'; break;
                case 3: specifier = 'a'; break;
                case 4: specifier = 'A'; break;
                } break;
            case 'y':
                switch (repeat)
                {
                case 2: specifier = 'y'; break;
                case 4: specifier = 'Y'; break;
                } break;
            case 'h':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'I'; break;
                } break;
            case 'H':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'H'; break;
                } break;
            case 'm':
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'M'; break;
                } break;
            case 's': /* for compatibility; not strictly WinWord */
                switch (repeat)
                {
                case 1: no_lead_zeros = 1;  /* fall thru */
                case 2: specifier = 'S'; break;
                } break;
            case 'A':
            case 'a':
                if (!__ascii_stricmp(format, "am/pm"))
                    p = format + 5;
                else if (!__ascii_stricmp(format, "a/p"))
                    p = format + 3;
                specifier = 'p';
                break;
            case 't': /* t or tt time marker suffix */
                if ( tmptr->tm_hour <= 11 )
                    ampmstr = lc_time->ampm[0];
                else
                    ampmstr = lc_time->ampm[1];

                while ( (repeat > 0) && (*count > 0) )
                {
#ifdef  _MT
                    if ( __isleadbyte_mt(ptloci, (int)*ampmstr) &&
#else
                    if ( isleadbyte((int)*ampmstr) &&
#endif
                         (*count > 1) )
                    {
                        *(*out)++ = *ampmstr++;
                        (*count)--;
                    }
                    *(*out)++ = *ampmstr++;
                    (*count)--;
                    repeat--;
                }
                format = p;
                continue;

            case '\'': /* literal string */
                if (repeat & 1) /* odd number */
                {
                    format += repeat;
                    while (*format && *count != 0)
                    {
                        if (*format == '\'')
                        {
                            format++;
                            break;
                        }
#ifdef  _MT
                        if ( __isleadbyte_mt(ptloci, (int)*format) &&
#else
                        if ( isleadbyte((int)*format) &&
#endif
                             (*count > 1) )
                        {
                            *(*out)++ = *format++;
                            (*count)--;
                        }
                        *(*out)++ = *format++;
                        (*count)--;
                    }
                }
                else { /* even number */
                    format += repeat;
                }
                continue;

            default: /* non-control char, print it */
                break;
            } /* switch */

            /* expand specifier, or copy literal if specifier not found */
            if (specifier)
            {
                _expandtime(
#ifdef  _MT
                            ptloci,
#endif
                            specifier, tmptr, out, count,
                            lc_time, no_lead_zeros);
                format = p; /* bump format up to the next token */
            } else {
#ifdef  _MT
                if (__isleadbyte_mt(ptloci, (int)*format) &&
#else
                if (isleadbyte((int)*format) &&
#endif
                    (*count > 1))
                {
                    *(*out)++ = *format++;
                    (*count)--;
                }
                *(*out)++ = *format++;
                (*count)--;
            }
        } /* while */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\mktime.c ===
/***
*mktime.c - Convert struct tm value to time_t value.
*
*       Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines mktime() and _mkgmtime(), routines to converts a time value
*       in a tm structure (possibly incomplete) into a time_t value, then
*       update (all) the structure fields with "normalized" values.
*
*Revision History:
*       01-14-87  JCR   Module created
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       06-15-89  PHG   Now allows negative values and does DST by ANSI rules
*       11-06-89  KRS   Added (unsigned) to handle years 2040-2099 correctly.
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       10-04-90  GJF   New-style function declarator. Also, rewrote expr.
*                       to avoid using casts as lvalues.
*       10-26-90  GJF   Added ulscount to avoid overflows. Ugly, temporary
*                       hack (whole function needs to be revised for ANSI
*                       conformance).
*       01-22-91  GJF   ANSI naming.
*       03-24-93  GJF   Propagated changes from 16-bit tree. Modified to
*                       expose _mkgmtime() routine.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-15-93  GJF   Replaced _tzset() call with __tzset() call.
*       09-13-93  GJF   Merged NT SDK and Cuda versions (amounted to picking
*                       up MattBr's changes to the Posix build made last
*                       April).
*       02-10-95  GJF   Conditionally call _tzset instead of __tzset for Mac
*                       builds (probably temporary change).
*       05-09-95  GJF   Properly handle initial tm_mon values from -11 to -1.
*       08-31-95  GJF   Use _dstbias for Daylight Saving Time bias instead of
*                       -3600L.
*       05-17-99  PML   Remove all Macintosh support.
*       08-30-99  PML   long -> time_t in a few casts.
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <ctime.h>
#include <time.h>
#include <internal.h>

/*
 * ChkAdd evaluates to TRUE if dest = src1 + src2 has overflowed
 */
#define ChkAdd(dest, src1, src2)   ( ((src1 >= 0L) && (src2 >= 0L) \
    && (dest < 0L)) || ((src1 < 0L) && (src2 < 0L) && (dest >= 0L)) )

/*
 * ChkMul evaluates to TRUE if dest = src1 * src2 has overflowed
 */
#define ChkMul(dest, src1, src2)   ( src1 ? (dest/src1 != src2) : 0 )


/*
 * Core function for both mktime() and _mkgmtime()
 */
static time_t __cdecl _make_time_t( struct tm *, int);


/***
*time_t mktime(tb) - Normalize user time block structure
*
*Purpose:
*       Mktime converts a time structure, passed in as an argument, into a
*       calendar time value in internal format (time_t). It also completes
*       and updates the fields the of the passed in structure with 'normalized'
*       values. There are three practical uses for this routine:
*
*       (1) Convert broken-down time to internal time format (time_t).
*       (2) To have mktime fill in the tm_wday, tm_yday, or tm_isdst fields.
*       (3) To pass in a time structure with 'out of range' values for some
*           fields and have mktime "normalize" them (e.g., pass in 1/35/87 and
*           get back 2/4/87).
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, mktime returns the specified calender time encoded as
*       a time_t value. Otherwise, (time_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/


time_t __cdecl mktime (
        struct tm *tb
        )
{
        return( _make_time_t(tb, 1) );
}


/***
*time_t _mkgmtime(tb) - Convert broken down UTC time to time_t
*
*Purpose:
*       Convert a tm structure, passed in as an argument, containing a UTC
*       time value to internal format (time_t). It also completes and updates
*       the fields the of the passed in structure with 'normalized' values.

*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*
*Exit:
*       If successful, _mkgmtime returns the calender time encoded as time_t
*       Otherwise, (time_t)(-1) is returned to indicate an error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

time_t __cdecl _mkgmtime (
        struct tm *tb
        )
{
        return( _make_time_t(tb, 0) );
}


/***
*static time_t make_time_t(tb, ultflag) -
*
*Purpose:
*       Converts a struct tm value to a time_t value, then updates the struct
*       tm value. Either local time or UTC is supported, based on ultflag.
*       This is the routine that actually does the work for both mktime() and
*       _mkgmtime().
*
*Entry:
*       struct tm *tb - pointer to a tm time structure to convert and
*                       normalize
*       int ultflag   - use local time flag. the tb structure is assumed
*                       to represent a local date/time if ultflag > 0.
*                       otherwise, UTC is assumed.
*
*Exit:
*       If successful, mktime returns the specified calender time encoded as
*       a time_t value. Otherwise, (time_t)(-1) is returned to indicate an
*       error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

static time_t __cdecl _make_time_t (
        struct tm *tb,
        int ultflag
        )
{
        time_t tmptm1, tmptm2, tmptm3;
        struct tm *tbtemp;

        /*
         * First, make sure tm_year is reasonably close to being in range.
         */
        if ( ((tmptm1 = tb->tm_year) < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR
          + 1) )
            goto err_mktime;


        /*
         * Adjust month value so it is in the range 0 - 11.  This is because
         * we don't know how many days are in months 12, 13, 14, etc.
         */

        if ( (tb->tm_mon < 0) || (tb->tm_mon > 11) ) {

            /*
             * no danger of overflow because the range check above.
             */
            tmptm1 += (tb->tm_mon / 12);

            if ( (tb->tm_mon %= 12) < 0 ) {
                tb->tm_mon += 12;
                tmptm1--;
            }

            /*
             * Make sure year count is still in range.
             */
            if ( (tmptm1 < _BASE_YEAR - 1) || (tmptm1 > _MAX_YEAR + 1) )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed years *****/

        /*
         * Calculate days elapsed minus one, in the given year, to the given
         * month. Check for leap year and adjust if necessary.
         */
        tmptm2 = _days[tb->tm_mon];
        if ( !(tmptm1 & 3) && (tb->tm_mon > 1) )
                tmptm2++;

        /*
         * Calculate elapsed days since base date (midnight, 1/1/70, UTC)
         *
         *
         * 365 days for each elapsed year since 1970, plus one more day for
         * each elapsed leap year. no danger of overflow because of the range
         * check (above) on tmptm1.
         */
        tmptm3 = (tmptm1 - _BASE_YEAR) * 365L + ((tmptm1 - 1L) >> 2)
          - _LEAP_YEAR_ADJUST;

        /*
         * elapsed days to current month (still no possible overflow)
         */
        tmptm3 += tmptm2;

        /*
         * elapsed days to current date. overflow is now possible.
         */
        tmptm1 = tmptm3 + (tmptm2 = (time_t)(tb->tm_mday));
        if ( ChkAdd(tmptm1, tmptm3, tmptm2) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed days *****/

        /*
         * Calculate elapsed hours since base date
         */
        tmptm2 = tmptm1 * 24L;
        if ( ChkMul(tmptm2, tmptm1, 24L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_hour);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed hours *****/

        /*
         * Calculate elapsed minutes since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_min);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed minutes *****/

        /*
         * Calculate elapsed seconds since base date
         */

        tmptm2 = tmptm1 * 60L;
        if ( ChkMul(tmptm2, tmptm1, 60L) )
            goto err_mktime;

        tmptm1 = tmptm2 + (tmptm3 = (time_t)tb->tm_sec);
        if ( ChkAdd(tmptm1, tmptm2, tmptm3) )
            goto err_mktime;

        /***** HERE: tmptm1 holds number of elapsed seconds *****/

        if  ( ultflag ) {

            /*
             * Adjust for timezone. No need to check for overflow since
             * localtime() will check its arg value
             */

#ifdef _POSIX_
            tzset();
#else
            __tzset();
#endif

            tmptm1 += _timezone;

            /*
             * Convert this second count back into a time block structure.
             * If localtime returns NULL, return an error.
             */
            if ( (tbtemp = localtime(&tmptm1)) == NULL )
                goto err_mktime;

            /*
             * Now must compensate for DST. The ANSI rules are to use the
             * passed-in tm_isdst flag if it is non-negative. Otherwise,
             * compute if DST applies. Recall that tbtemp has the time without
             * DST compensation, but has set tm_isdst correctly.
             */
            if ( (tb->tm_isdst > 0) || ((tb->tm_isdst < 0) &&
              (tbtemp->tm_isdst > 0)) ) {
#ifdef _POSIX_
                tmptm1 -= _timezone;
                tmptm1 += _dstoffset;
#else
                tmptm1 += _dstbias;
#endif
                tbtemp = localtime(&tmptm1);    /* reconvert, can't get NULL */
            }

        } 
        else {
            if ( (tbtemp = gmtime(&tmptm1)) == NULL )
                goto err_mktime;
        }

        /***** HERE: tmptm1 holds number of elapsed seconds, adjusted *****/
        /*****       for local time if requested                      *****/

        *tb = *tbtemp;
        return (time_t)tmptm1;

err_mktime:
        /*
         * All errors come to here
         */
        return (time_t)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\utime64.c ===
/***
*utime64.c - set modification time for a file
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       05-28-98  GJF   Created.
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/utime.h>
#include <msdos.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <oscalls.h>
#include <errno.h>
#include <stddef.h>
#include <internal.h>

#include <stdio.h>
#include <tchar.h>

/***
*int _utime64(pathname, time) - set modification time for file
*
*Purpose:
*       Sets the modification time for the file specified by pathname.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct __utimbuf64 *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tutime64 (
        const _TSCHAR *fname,
        struct __utimbuf64 *times
        )
{
        int fh;
        int retval;

        /* open file, fname, since filedate system call needs a handle.  Note
         * _utime definition says you must have write permission for the file
         * to change its time, so open file for write only.  Also, must force
         * it to open in binary mode so we dont remove ^Z's from binary files.
         */


        if ((fh = _topen(fname, _O_RDWR | _O_BINARY)) < 0)
                return(-1);

        retval = _futime64(fh, times);

        _close(fh);
        return(retval);
}

#ifndef _UNICODE

/***
*int __futime64(fh, time) - set modification time for open file
*
*Purpose:
*       Sets the modification time for the open file specified by fh.
*       Only the modification time from the _utimbuf64 structure is used
*       under MS-DOS.
*
*Entry:
*       struct __utimbuf64 *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _futime64 (
        int fh,
        struct __utimbuf64 *times
        )
{
        struct tm *tmb;

        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;
        FILETIME LastWriteTime;
        FILETIME LastAccessTime;
        struct __utimbuf64 deftimes;

        if (times == NULL) {
                _time64(&deftimes.modtime);
                deftimes.actime = deftimes.modtime;
                times = &deftimes;
        }

        if ((tmb = _localtime64(&times->modtime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastWriteTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        if ((tmb = _localtime64(&times->actime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastAccessTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        /* set the date via the filedate system call and return. failing
         * this call implies the new file times are not supported by the
         * underlying file system.
         */

        if (!SetFileTime((HANDLE)_get_osfhandle(fh),
                                NULL,
                                &LastAccessTime,
                                &LastWriteTime
                               ))
        {
                errno = EINVAL;
                return(-1);
        }

        return(0);
}

#endif  /* _UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\time64.c ===
/***
*time64.c - get current system time
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _time64() - gets the current system time and converts it to
*       internal (__time64_t) format time.
*
*Revision History:
*       05-20-98  GJF   Created.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <windows.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;


/***
*__time64_t _time64(timeptr) - Get current system time and convert to a
*       __time64_t value.
*
*Purpose:
*       Gets the current date and time and stores it in internal 64-bit format
*       (__time64_t). The time is returned and stored via the pointer passed in
*       timeptr. If timeptr == NULL, the time is only returned, not stored in
*       *timeptr. The internal (__time64_t) format is the number of seconds 
*       since 00:00:00, Jan 1 1970 (UTC).
*
*Entry:
*       __time64_t *timeptr - pointer to long to store time in.
*
*Exit:
*       returns the current time.
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl _time64 (
        __time64_t *timeptr
        )
{
        __time64_t tim;
        FT nt_time;

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        tim = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);


        if (timeptr)
                *timeptr = tim;         /* store time if requested */

        return tim;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wasctime.c ===
/***
*wasctime.c - convert date/time structure to ASCII string (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Contains _wasctime() - convert a date/time structure to wide ASCII string.
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "asctime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\time.c ===
/***
*time.c - get current system time
*
*       Copyright (c) 1989-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines time() - gets the current system time and converts it to
*                        internal (time_t) format time.
*
*Revision History:
*       06-07-89  PHG   Module created, based on asm version
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h> and fixed the copyright. Also, cleaned
*                       up the formatting a bit.
*       07-25-90  SBM   Removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       05-19-92  DJM   ifndef for POSIX build.
*       03-30-93  GJF   Replaced dtoxtime() reference by __gmtotime_t. Also
*                       purged Cruiser support.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       07-21-93  GJF   Converted from using __gmtotime_t and GetSystemTime,
*                       to using __loctotime_t and GetLocalTime.
*       02-13-95  GJF   Merged in Mac version.
*       09-22-95  GJF   Obtain and use Win32's DST flag.
*       10-24-95  GJF   GetTimeZoneInformation is *EXPENSIVE* on NT. Use a
*                       cache to minimize calls to this API.
*       12-13-95  GJF   Optimization above wasn't working because I had 
*                       switched gmt and gmt_cache (thanks PhilipLu!)
*       10-11-96  GJF   More elaborate test needed to determine if current
*                       time is a DST time.
*       05-20-98  GJF   Get UTC time directly from the system.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <windows.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/***
*time_t time(timeptr) - Get current system time and convert to time_t value.
*
*Purpose:
*       Gets the current date and time and stores it in internal (time_t)
*       format. The time is returned and stored via the pointer passed in
*       timeptr. If timeptr == NULL, the time is only returned, not stored in
*       *timeptr. The internal (time_t) format is the number of seconds since
*       00:00:00, Jan 1 1970 (UTC).
*
*       Note: We cannot use GetSystemTime since its return is ambiguous. In
*       Windows NT, in return UTC. In Win32S, probably also Win32C, it
*       returns local time.
*
*Entry:
*       time_t *timeptr - pointer to long to store time in.
*
*Exit:
*       returns the current time.
*
*Exceptions:
*
*******************************************************************************/

time_t __cdecl time (
        time_t *timeptr
        )
{
        time_t tim;
        FT nt_time;

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        tim = (time_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);

        if (timeptr)
                *timeptr = tim;         /* store time if requested */

        return tim;
}

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\timeset.c ===
/***
*timeset.c - contains defaults for timezone setting
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the timezone values for default timezone.
*       Also contains month and day name three letter abbreviations.
*
*Revision History:
*       12-03-86  JMB   added Japanese defaults and module header
*       09-22-87  SKS   fixed declarations, include <time.h>
*       02-21-88  SKS   Clean up ifdef-ing, change IBMC20 to IBMC2
*       07-05-89  PHG   Remove _NEAR_ for 386
*       08-15-89  GJF   Fixed copyright, indents. Got rid of _NEAR.
*       03-20-90  GJF   Added #include <cruntime.h> and fixed the copyright.
*       05-18-90  GJF   Added _VARTYPE1 to publics to match declaration in
*                       time.h (picky 6.0 front-end!).
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix support(TZ stuff).
*       04-06-93  SKS   Remove _VARTYPE1
*       06-08-93  KRS   Tie JAPAN switch to _KANJI switch.
*       09-13-93  GJF   Merged NT SDK and Cuda versions.
*       04-08-94  GJF   Made non-POSIX definitions of _timezone, _daylight
*                       and _tzname conditional on ndef DLL_FOR_WIN32S.
*       10-04-94  CFW   Removed #ifdef _KANJI
*       02-13-95  GJF   Fixed def of tzname[] so that string constants would
*                       not get overwritten (dangerous if string-pooling is
*                       turned on in build). Made it big enough to hold
*                       timezone names which work with Posix. Also, made
*                       __mnames[] and __dnames[] const.
*       03-01-95  BWT   Fix POSIX by including limits.h
*       08-30-95  GJF   Added _dstbias for Win32. Also increased limit on
*                       timezone strings to 63.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <time.h>
#include <internal.h>

#ifndef _POSIX_

long _timezone = 8 * 3600L; /* Pacific Time Zone */
int _daylight = 1;          /* Daylight Saving Time (DST) in timezone */
long _dstbias = -3600L;     /* DST offset in seconds */

/* note that NT Posix's TZNAME_MAX is only 10 */

static char tzstd[64] = { "PST" };
static char tzdst[64] = { "PDT" };

char *_tzname[2] = { tzstd, tzdst };

#else   /* _POSIX_ */

#include <limits.h>

long _timezone = 8*3600L;   /* Pacific Time */
int _daylight = 1;          /* Daylight Savings Time */
                            /* when appropriate */

static char tzstd[TZNAME_MAX + 1] = { "PST" };
static char tzdst[TZNAME_MAX + 1] = { "PDT" };

char *tzname[2] = { tzstd, tzdst };

char *_rule;
long _dstoffset = 3600L;

#endif  /* _POSIX_ */

/*  Day names must be Three character abbreviations strung together */

const char __dnames[] = {
        "SunMonTueWedThuFriSat"
};

/*  Month names must be Three character abbreviations strung together */

const char __mnames[] = {
        "JanFebMarAprMayJunJulAugSepOctNovDec"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\tzset.c ===
/***
*tzset.c - set timezone information and see if we're in daylight time
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _tzset() - set timezone and daylight saving time vars
*
*Revision History:
*       03-??-84  RLB   initial version
*       03-26-86  TC    added minus capability to time difference w.r.t GMT
*       03-27-86  TC    fixed daylight davings time calculation, off by a day
*                       error
*       12-03-86  SKS   daylight savings time is different starting april 1987
*                       Fixed off-by-1 errors when either Apr 30 or Oct 31 is
*                       Sat. Simplified leap year check: this works for
*                       1970-2099 only!
*       11-19-87  SKS   Add __tzset() which calls tzset only the first time
*                       Made _isindst() a near procedure
*       11-25-87  WAJ   Added calls to _lock and _unlock
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       01-27-88  SKS   Made _isindst() and _dtoxtime() are no longer near (for
*                       QC)
*       05-24-88  PHG   Merged DLL and normal versions
*       03-20-90  GJF   Made calling type _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       03-23-90  GJF   Made static functions _CALLTYPE4.
*       07-30-90  SBM   Added void to empty function arg lists to create
*                       prototypes
*       10-04-90  GJF   New-style function declarators.
*       01-21-91  GJF   ANSI naming.
*       08-10-92  PBS   Posix Support (TZ stuff).
*       03-30-93  GJF   Ported C8-16 version to Win32.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       04-07-93  SKS   Replace strdup() with ANSI conformant _strdup()
*       06-28-93  GJF   Limited support for system's notion of time zone
*                       in Windows NT.
*       07-15-93  GJF   Resurrected __tzset().
*       04-22-94  GJF   Made definitions of lastTZ and first_time conditonal
*                       on DLL_FOR_WIN32S.
*       01-10-95  CFW   Debug CRT allocs.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       04-07-95  JCF   Change gmtFlags with u. Due to Changes in macos\osutils.h
*       06-28-95  CFW   Mac: when TZ not set, _tzname[0,1]="" not "???";
*       08-30-95  GJF   Complete support for Win32's notion of time zones.
*       11-08-95  GJF   Fixed isindst() to release lock.
*       11-15-95  GJF   Ensure dststart, dstend get recomputed after _tzset.
*       01-18-96  GJF   Ensure _tzname[] strings are null-terminated.
*       03-22-96  GJF   Zero out _dstbias if there is no DST. This works
*                       around a bug in NT's GetTimeZoneInformation API.
*       07-25-96  RDK   Removed PMAC init ptr here to clock.c.
*       10-11-96  GJF   Return value of TIME_ZONE_ID_UNKNOWN from 
*                       GetTimeZoneInformation does NOT mean there is no time
*                       zone info (it may simply mean there is no DST).
*       08-28-97  GJF   Fixed underflow adjustment in cvtdate. Also, deleted
*                       some old Win32S support and detab-ed.
*       01-28-98  GJF   Use WideCharToMultiByte API instead of mbstowcs so
*                       that the host's default ANSI codepage is used when we
*                       are in the C locale.
*       02-09-98  GJF   Changes for Win64: removing unnecessary typing of vars
*                       and constants as long.
*       05-11-98  GJF   Use more general leap determination to support time
*                       values past 2099. 
*       05-11-98  GJF   Merged in crt.ia64 and crt.ia64 versions.
*       08-27-98  GJF   Copy __lc_codepage, a global, to a local var for 
*                       multithread safety.
*       09-25-98  GJF   Minor bug in transition day calculation.
*       04-28-99  GJF   Changed dwFlags arg value to 0 in WideCharToMultiByte
*                       calls to avoid problems with codepage 1258 on NT 5.0.
*       05-17-99  PML   Remove all Macintosh support.
*       06-08-99  GJF   Fixed handling of empty TZ environment variable.
*       09-28-99  PML   Fixed double free of lastTZ (ntbug#390281)
*
*******************************************************************************/

#include <cruntime.h>
#include <ctype.h>
#include <ctime.h>
#include <time.h>
#include <stdlib.h>
#include <internal.h>
#ifdef  _POSIX_
#include <limits.h>
#else
#include <mtdll.h>
#include <windows.h>
#endif
#include <setlocal.h>
#include <string.h>
#include <dbgint.h>

#ifndef _POSIX_

/*
 * Number of milliseconds in one day
 */
#define DAY_MILLISEC    (24 * 60 * 60 * 1000)

/*
 * Pointer to a saved copy of the TZ value obtained in the previous call
 * to tzset() set (if any).
 */
static char * lastTZ = NULL;

/*
 * Flag indicating that time zone information came from GetTimeZoneInformation
 * API call.
 */
static int tzapiused;

static TIME_ZONE_INFORMATION tzinfo;

/*
 * Structure used to represent DST transition date/times.
 */
typedef struct {
        int  yr;        /* year of interest */
        int  yd;        /* day of year */
        int  ms;        /* milli-seconds in the day */
        } transitiondate;

/*
 * DST start and end structs.
 */
static transitiondate dststart = { -1, 0, 0 };
static transitiondate dstend   = { -1, 0, 0 };

static int __cdecl _isindst_lk(struct tm *);

#endif


/***
*void tzset() - sets timezone information and calc if in daylight time
*
*Purpose:
*       Sets the timezone information from the TZ environment variable
*       and then sets _timezone, _daylight, and _tzname. If we're in daylight
*       time is automatically calculated.
*
*Entry:
*       None, reads TZ environment variable.
*
*Exit:
*       sets _daylight, _timezone, and _tzname global vars, no return value
*
*Exceptions:
*
*******************************************************************************/

#ifndef _POSIX_

#ifdef  _MT
static void __cdecl _tzset_lk(void);
#else
#define _tzset_lk _tzset
#endif

void __cdecl __tzset(void)
{
        static int first_time = 0;

        if ( !first_time ) {

            _mlock( _TIME_LOCK );

            if ( !first_time ) {
                _tzset_lk();
                first_time++;
            }

            _munlock(_TIME_LOCK );

        }
}


#ifdef  _MT     /* multi-thread; define both tzset and _tzset_lk */
void __cdecl _tzset (
        void
        )
{
        _mlock( _TIME_LOCK );

        _tzset_lk();

        _munlock( _TIME_LOCK );
}


static void __cdecl _tzset_lk (

#else   /* non multi-thread; only define tzset */

void __cdecl _tzset (

#endif  /* rejoin common code */

        void
        )
{
        char *TZ;
        int defused;
        int negdiff = 0;
        unsigned int lc_cp;

        _mlock(_ENV_LOCK);

        /*
         * Copy codepage to local (only really necessary for multithread case)
         */
        lc_cp = __lc_codepage;

        /*
         * Clear the flag indicated whether GetTimeZoneInformation was used.
         */
        tzapiused = 0;

        /*
         * Set year fields of dststart and dstend structures to -1 to ensure
         * they are recomputed as after this 
         */
        dststart.yr = dstend.yr = -1;

        /*
         * Fetch the value of the TZ environment variable.
         */
#ifndef _XBOX
        if ( ((TZ = _getenv_lk("TZ")) == NULL) || (*TZ =='\0') )
#endif
        {

            /*
             * There is no TZ environment variable, try to use the time zone
             * information from the system.
             */

            /*
             * If there is a lastTZ, discard it
             */
            if ( lastTZ != NULL ) {
                _free_crt(lastTZ);
		lastTZ = NULL;
	    }

            _munlock(_ENV_LOCK);

            if ( GetTimeZoneInformation( &tzinfo ) != 0xFFFFFFFF ) {
                /*
                 * Note that the API was used.
                 */
                tzapiused = 1;

                /*
                 * Derive _timezone value from Bias and StandardBias fields.
                 */
                _timezone = tzinfo.Bias * 60;

                if ( tzinfo.StandardDate.wMonth != 0 )
                    _timezone += (tzinfo.StandardBias * 60);

                /*
                 * Check to see if there is a daylight time bias. Since the
                 * StandardBias has been added into _timezone, it must be 
                 * compensated for in the value computed for _dstbias.
                 */
                if ( (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                {
                    _daylight = 1;
                    _dstbias = (tzinfo.DaylightBias - tzinfo.StandardBias) *
                               60;
                }
                else {
                        _daylight = 0;

                    /*
                     * Set daylight bias to 0 because GetTimeZoneInformation 
                     * may return TIME_ZONE_ID_DAYLIGHT even though there is
                     * no DST (in NT 3.51, just turn off the automatic DST
                     * adjust in the control panel)!
                     */
                    _dstbias = 0;
                }

#ifndef _XBOX
                /*
                 * Try to grab the name strings for both the time zone and the
                 * daylight zone. Note the wide character strings in tzinfo
                 * must be converted to multibyte characters strings. The 
                 * locale codepage, __lc_codepage, is used for this. Note that
                 * if setlocale() with LC_ALL or LC_CTYPE has not been called,
                 * then __lc_codepage will be 0 (_CLOCALECP), which is CP_ACP
                 * (which means use the host's default ANSI codepage).
                 */
                if ( (WideCharToMultiByte( lc_cp,
                                           0,
                                           tzinfo.StandardName,
                                           -1,
                                           _tzname[0],
                                           63,
                                           NULL, 
                                           &defused ) != 0) &&
                     (!defused) )
                    _tzname[0][63] = '\0';
                else
                    _tzname[0][0] = '\0';

                if ( (WideCharToMultiByte( lc_cp,
                                           0,
                                           tzinfo.DaylightName,
                                           -1,
                                           _tzname[1],
                                           63,
                                           NULL, 
                                           &defused ) != 0) &&
                     (!defused) )
                    _tzname[1][63] = '\0';
                else
                    _tzname[1][0] = '\0';
#endif
            }

            /*
             * Time zone information is unavailable, just return.
             */
            return;
        }


        if ( (lastTZ != NULL) && (strcmp(TZ, lastTZ) == 0) )
        {
            /*
             * TZ is unchanged from a earlier call (to this function). Just
             * return.
             */
            _munlock(_ENV_LOCK);
            return;
        }

        /*
         * Update lastTZ
         */
        if ( lastTZ != NULL )
            _free_crt(lastTZ);

        if ((lastTZ = _malloc_crt(strlen(TZ)+1)) == NULL)
        {
            _munlock(_ENV_LOCK);
            return;
        }
        strcpy(lastTZ, TZ);

        _munlock(_ENV_LOCK);

        /*
         * Process TZ value and update _tzname, _timezone and _daylight.
         */

        strncpy(_tzname[0], TZ, 3);
        _tzname[0][3] = '\0';

        /*
         * time difference is of the form:
         *
         *      [+|-]hh[:mm[:ss]]
         *
         * check minus sign first.
         */
        if ( *(TZ += 3) == '-' ) {
            negdiff++;
            TZ++;
        }

        /*
         * process, then skip over, the hours
         */
        _timezone = atol(TZ) * 3600;

        while ( (*TZ == '+') || ((*TZ >= '0') && (*TZ <= '9')) ) TZ++;

        /*
         * check if minutes were specified
         */
        if ( *TZ == ':' ) {
            /*
             * process, then skip over, the minutes
             */
            _timezone += atol(++TZ) * 60;
            while ( (*TZ >= '0') && (*TZ <= '9') ) TZ++;

            /*
             * check if seconds were specified
             */
            if ( *TZ == ':' ) {
                /*
                 * process, then skip over, the seconds
                 */
                _timezone += atol(++TZ);
                while ( (*TZ >= '0') && (*TZ <= '9') ) TZ++;
            }
        }

        if ( negdiff )
            _timezone = -_timezone;

        /*
         * finally, check for a DST zone suffix
         */
        if ( _daylight = *TZ ) {
            strncpy(_tzname[1], TZ, 3);
            _tzname[1][3] = '\0';
        }
        else
            *_tzname[1] = '\0';

}

/***
*static void cvtdate( trantype, datetype, year, month, week, dayofweek,
*                     date, hour, min, second, millisec ) - convert 
*       transition date format
*
*Purpose:
*       Convert the format of a transition date specification to a value of
*       a transitiondate structure.
*
*Entry:
*       int trantype    - 1, if it is the start of DST
*                         0, if is the end of DST (in which case the date is
*                            is a DST date)
*       int datetype    - 1, if a day-in-month format is specified.
*                         0, if an absolute date is specified.
*       int year        - year for which the date is being converted (70 ==
*                         1970)
*       int month       - month (0 == January)
*       int week        - week of month, if datetype == 1 (note that 5== last
*                         week of month), 
*                         0, otherwise.
*       int dayofweek   - day of week (0 == Sunday), if datetype == 1.
*                         0, otherwise.
*       int date        - date of month (1 - 31)
*       int hour        - hours (0 - 23)
*       int min         - minutes (0 - 59)
*       int sec         - seconds (0 - 59)
*       int msec        - milliseconds (0 - 999)
*
*Exit:
*       dststart or dstend is filled in with the converted date.
*
*******************************************************************************/

static void __cdecl cvtdate (
        int trantype,
        int datetype,
        int year,
        int month,
        int week,
        int dayofweek,
        int date,
        int hour,
        int min,
        int sec,
        int msec
        )
{
        int yearday;
        int monthdow;

        if ( datetype == 1 ) {

            /*
             * Transition day specified in day-in-month format.
             */

            /*
             * Figure the year-day of the start of the month.
             */
            yearday = 1 + (_IS_LEAP_YEAR(year) ? _lpdays[month - 1] :
                      _days[month - 1]);

            /* 
             * Figure the day of the week of the start of the month.
             */
            monthdow = (yearday + ((year - 70) * 365) +
                        _ELAPSED_LEAP_YEARS(year) + _BASE_DOW) % 7;

            /*
             * Figure the year-day of the transition date
             */
            if ( monthdow <= dayofweek )
                yearday += (dayofweek - monthdow) + (week - 1) * 7;
            else
                yearday += (dayofweek - monthdow) + week * 7;

            /*
             * May have to adjust the calculation above if week == 5 (meaning
             * the last instance of the day in the month). Check if year falls
             * beyond after month and adjust accordingly.
             */
            if ( (week == 5) && 
                 (yearday > (_IS_LEAP_YEAR(year) ? _lpdays[month] :
                             _days[month])) )
            {
                yearday -= 7;
            }
        }
        else {
            /* 
             * Transition day specified as an absolute day
             */
            yearday = _IS_LEAP_YEAR(year) ? _lpdays[month - 1] :
                      _days[month - 1];

            yearday += date;
        }

        if ( trantype == 1 ) {
            /*
             * Converted date was for the start of DST
             */
            dststart.yd = yearday;
            dststart.ms = msec + (1000 * (sec + 60 * (min + 60 * hour)));
            /*
             * Set year field of dststart so that unnecessary calls to
             * cvtdate() may be avoided.
             */
            dststart.yr = year;
        }
        else {
            /*
             * Converted date was for the end of DST
             */
            dstend.yd = yearday;
            dstend.ms = msec + (1000 * (sec + 60 * (min + 60 * hour)));
            /*
             * The converted date is still a DST date. Must convert to a 
             * standard (local) date while being careful the millisecond field
             * does not overflow or underflow.
             */
            if ( (dstend.ms += (_dstbias * 1000)) < 0 ) {
                dstend.ms += DAY_MILLISEC;
                dstend.yd--;
            }
            else if ( dstend.ms >= DAY_MILLISEC ) {
                dstend.ms -= DAY_MILLISEC;
                dstend.yd++;
            }

            /*
             * Set year field of dstend so that unnecessary calls to cvtdate()
             * may be avoided.
             */
            dstend.yr = year;
        }

        return;
}

/***
*int _isindst(tb) - determine if broken-down time falls in DST
*
*Purpose:
*       Determine if the given broken-down time falls within daylight saving
*       time (DST). The DST rules are either obtained from Win32 (tzapiused !=
*       TRUE) or assumed to be USA rules, post 1986.
*
*       If the DST rules are obtained from Win32's GetTimeZoneInformation API,
*       the transition dates to/from DST can be specified in either of two
*       formats. First, a day-in-month format, similar to the way USA rules 
*       are specified, can be used. The transition date is given as the n-th 
*       occurence of a specified day of the week in a specified month. Second,
*       an absolute date can be specified. The two cases are distinguished by
*       the value of wYear field in the SYSTEMTIME structure (0 denotes a
*       day-in-month format).
*
*       USA rules for DST are that a time is in DST iff it is on or after 
*       02:00 on the first Sunday in April, and before 01:00 on the last 
*       Sunday in October.
*
*Entry:
*       struct tm *tb - structure holding broken-down time value
*
*Exit:
*       1, if time represented is in DST
*       0, otherwise
*
*******************************************************************************/

int __cdecl _isindst (
        struct tm *tb
        )
#ifdef  _MT
{
        int retval;

        _mlock( _TIME_LOCK );
        retval = _isindst_lk( tb );
        _munlock( _TIME_LOCK );

        return retval;
}

static int __cdecl _isindst_lk (
        struct tm *tb
        )
#endif  /* _MT */
{
        long ms;

        if ( _daylight == 0 )
            return 0;

        /*
         * Compute (recompute) the transition dates for daylight saving time
         * if necessary.The yr (year) fields of dststart and dstend is 
         * compared to the year of interest to determine necessity.
         */
        if ( (tb->tm_year != dststart.yr) || (tb->tm_year != dstend.yr) ) {
            if ( tzapiused ) {
                /*
                 * Convert the start of daylight saving time to dststart.
                 */
                if ( tzinfo.DaylightDate.wYear == 0 ) 
                    cvtdate( 1, 
                             1,             /* day-in-month format */
                             tb->tm_year, 
                             tzinfo.DaylightDate.wMonth,
                             tzinfo.DaylightDate.wDay,
                             tzinfo.DaylightDate.wDayOfWeek,
                             0,
                             tzinfo.DaylightDate.wHour,
                             tzinfo.DaylightDate.wMinute,
                             tzinfo.DaylightDate.wSecond,
                             tzinfo.DaylightDate.wMilliseconds );
                else
                    cvtdate( 1,
                             0,             /* absolute date */
                             tb->tm_year,
                             tzinfo.DaylightDate.wMonth,
                             0,
                             0,
                             tzinfo.DaylightDate.wDay,
                             tzinfo.DaylightDate.wHour,
                             tzinfo.DaylightDate.wMinute,
                             tzinfo.DaylightDate.wSecond,
                             tzinfo.DaylightDate.wMilliseconds );
                /*
                 * Convert start of standard time to dstend.
                 */
                if ( tzinfo.StandardDate.wYear == 0 ) 
                    cvtdate( 0, 
                             1,             /* day-in-month format */
                             tb->tm_year, 
                             tzinfo.StandardDate.wMonth,
                             tzinfo.StandardDate.wDay,
                             tzinfo.StandardDate.wDayOfWeek,
                             0,
                             tzinfo.StandardDate.wHour,
                             tzinfo.StandardDate.wMinute,
                             tzinfo.StandardDate.wSecond,
                             tzinfo.StandardDate.wMilliseconds );
                else
                    cvtdate( 0, 
                             0,             /* absolute date */
                             tb->tm_year, 
                             tzinfo.StandardDate.wMonth,
                             0,
                             0,
                             tzinfo.StandardDate.wDay,
                             tzinfo.StandardDate.wHour,
                             tzinfo.StandardDate.wMinute,
                             tzinfo.StandardDate.wSecond,
                             tzinfo.StandardDate.wMilliseconds );

            }
            else {
                /*
                 * GetTimeZoneInformation API was NOT used, or failed. USA 
                 * daylight saving time rules are assumed.
                 */
                cvtdate( 1, 
                         1,
                         tb->tm_year, 
                         4,                 /* April */
                         1,                 /* first... */
                         0,                 /* ...Sunday */
                         0,
                         2,                 /* 02:00 (2 AM) */
                         0,
                         0,
                         0 );

                cvtdate( 0, 
                         1,
                         tb->tm_year, 
                         10,                /* October */
                         5,                 /* last... */
                         0,                 /* ...Sunday */
                         0,
                         2,                 /* 02:00 (2 AM) */
                         0,
                         0,
                         0 );
            }
        }

        /* 
         * Handle simple cases first.
         */
        if ( dststart.yd < dstend.yd ) {
            /*
             * Northern hemisphere ordering
             */
            if ( (tb->tm_yday < dststart.yd) || (tb->tm_yday > dstend.yd) )
                return 0;           
            if ( (tb->tm_yday > dststart.yd) && (tb->tm_yday < dstend.yd) )
                return 1;
        }
        else { 
            /*
             * Southern hemisphere ordering
             */
            if ( (tb->tm_yday < dstend.yd) || (tb->tm_yday > dststart.yd) )
                return 1;
            if ( (tb->tm_yday > dstend.yd) && (tb->tm_yday < dststart.yd) )
                return 0;
        }

        ms = 1000 * (tb->tm_sec + 60 * tb->tm_min + 3600 * tb->tm_hour);

        if ( tb->tm_yday == dststart.yd ) {
            if ( ms >= dststart.ms )
                return 1;
            else
                return 0;
        }
        else {
            /* 
             * tb->tm_yday == dstend.yd
             */
            if ( ms < dstend.ms )
                return 1;
            else
                return 0;
        }

}

#else   /* _POSIX_ */

/*
 *  The following is an implementation of the TZ grammar specified in the
 *  document:
 *
 *       8.1.1 Extension to Time Functions
 *       IEEE Std 1003.1 - 1990
 *       Page 152 - 153
 *
 *  The TZ grammar looks like:
 *
 *          stdoffset[dst[offset][,start[/time],end[/time]]]
 *
 *  Variables used in code:
 *
 *      tzname[0] ==> std
 *      _timezone  ==> offset(the one after 'std')
 *      tzname[1] ==> dst
 *      _dstoffset ==> offset(the one after 'dst')
 *      _startdate ==> start
 *      _starttime ==> time(the one after 'start')
 *      _enddate   ==> end
 *      _endtime   ==> time(the one after 'end')
 *
 */

/*
 *  Refer to the document for the detailed description of fields of _DSTDATE.
 *  Two of Jn, n, and Mm are -1, indicating the one(not -1) is a vaild value.
 */

typedef struct _DSTDATE {
        int Jn; /* -1 or [1, 365](year day and leap day shall not be counted) */
        int n;  /* -1 or [0, 365](year day and leap day shall be counted) */
        int Mm; /* -1 or [1, 12](month) */
        int Mn; /* [1, 5] if Mm != -1 (week) */
        int Md; /* [0, 6] if Mm != -1 (weekday, Sunday == 0) */
} DSTDATE, *PDSTDATE;

#define SEC_PER_HOUR    (60 * 60)
#define SEC_PER_DAY     (SEC_PER_HOUR * 24)


/*
 *  The default TZ in tzset() should look like:
 *
 *       TZ = "PST8PDT,M4.1.0/2:00,M10.5.0/2:00";
 */

/* Day light saving start/end date and default vaules */
static DSTDATE _startdate = { -1, -1, 4, 1, 0};
static DSTDATE _enddate = {-1, -1, 10, 5, 0};


/* Seconds since midnight on _startdate/_enddate with default values.
 * _endtime is 1am instead of 2am because the DST end time is 2am
 * local time, which by default is 1am standard time.
 */
long  _starttime = 7200L, _endtime = 7200L;

/*
 * If we are only interested in years between 1901 and 2099, we could use this:
 *
 *      #define IS_LEAP_YEAR(y)  (y % 4 == 0)
 */

#define IS_LEAP_YEAR(y)  ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0)


/*
 *  ParsePosixStdOrDst - parse the std or dst element in TZ.
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *  RETURN  pointer to one position after the std or dst element parsed,
 *          or NULL if failed.
 */


static  char * __cdecl
ParsePosixStdOrDst(
        REG1 char *pch
        )
{
#define UNWANTED(x) (isdigit(x) || x=='\0' || x==',' || x=='-' || x=='+')
        int i;

        /*
         *  Check against the rule.
         */

        if(*pch == ':' || UNWANTED(*pch)) {
                return NULL;
        }

        /*
         *  Get a valid std or dst(i.e. 3 <= lenth_of(std | dst) <= TZNAME_MAX).
         */

        for(i=1, ++pch; (i < TZNAME_MAX) && !UNWANTED(*pch); i++, pch++) {
                ;
        }

        /*
         *  pch now point to 1 position after the valid std or dst.
         */

        return (i >= 3) ? pch : NULL;
}


/*
 *  ParsePosixOffset - parse the offset element in TZ. The format of time is:
 *
 *                   [- | +]hh[:mm[:ss]]
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          ptime - pointer to a variable(_timezone or _dstoffset) storing the
 *                  time(in seconds) parsed.
 *
 *  RETURN  pointer to one position after the end of the offset element parsed.
 */


static  char * __cdecl
ParsePosixOffset(
        REG1 char *pch,
        REG2 long *poffset
        )
{
        int  fNegative;
        long offset;

        if((fNegative = (*pch == '-')) || *pch == '+') {
                pch++;
        }

        offset = atol(pch)*3600L; /* hh */

        while(*pch && isdigit(*pch)) {
                pch++;
        }

        if(*pch == ':') {
                offset += atol(++pch)*60L; /* mm */
                while(*pch && isdigit(*pch)) {
                        pch++;
                }

                if(*pch == ':') {
                        offset += atol(++pch); /* ss */
                        while(*pch && isdigit(*pch)) {
                                pch++;
                        }
                }
        }

        *poffset = fNegative ? -offset : offset;

        return pch;
}



/*
 *  ParsePosixDate - parse the date element in TZ. The format of date is one
 *                   of following:
 *
 *                   Jn, n, and Mm.n.d
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          pDstDate - pointer to _startdate or _enddate storing the result.
 *
 *  RETURN  pointer to one position after the end of the date element parsed,
 *          or NULL if failed.
 */

static  char * __cdecl
ParsePosixDate(
        REG1 char *pch,
        REG2 PDSTDATE pDstDate
        )
{
        pDstDate->Jn = -1;
        pDstDate->n = -1;
        pDstDate->Mn = -1;

        /*
         *  Two out of the three -1's will remain.
         */

        if(*pch == 'J') {                        /* Jn */
                pDstDate->Jn = atoi(++pch);
        } else if(*pch != 'M') {                 /* n */
                pDstDate->n = atoi(pch);
        } else {                                 /* Mm.n.d */

                pDstDate->Mm = atoi(++pch);

                if(*++pch != '.') {
                        pch++;
                }
                pDstDate->Mn = atoi(++pch);

                if(*++pch != '.') {
                        pch++;
                }
                pDstDate->Md = atoi(++pch);
        }

        while(*pch && isdigit(*pch)) {
                pch++;
        }

#define IN_RANGE(x, a, b)    (x >= a && x <= b)

        return ((pDstDate->Jn != -1 && IN_RANGE(pDstDate->Jn, 1, 365)) ||
                (pDstDate->n != -1 && IN_RANGE(pDstDate->n, 0, 365)) ||
                (pDstDate->Mm != -1 && IN_RANGE(pDstDate->Mm, 1, 12) &&
                IN_RANGE(pDstDate->Mn, 1, 5) && IN_RANGE(pDstDate->Md, 0, 6)))
                ? pch : NULL;
}

/*
 *  ParsePosixTime - parse the time element in TZ. The format of time is:
 *
 *                   hh[:mm[:ss]]
 *
 *  ENTRY   pch - beginning of the substring in TZ.
 *
 *          ptime - pointer to a variable(_starttime or _endtime) storing the
 *                  time(in seconds) parsed.
 *
 *  RETURN  pointer to one position after the end of the time element parsed.
 */

static  char * __cdecl
ParsePosixTime(
        REG1 char *pch,
        REG2 long *ptime
        )
{
        long time;

        time = atol(pch)*SEC_PER_HOUR; /* hh */

        while(*pch && isdigit(*pch)) {
                pch++;
        }

        if(*pch == ':') {

                time += atol(++pch)*60L; /* mm */
                while(*pch && isdigit(*pch)) {
                        pch++;
                }

                if(*pch == ':') {

                        time += atol(++pch); /* ss */
                        while(*pch && isdigit(*pch)) {
                                pch++;
                        }
                }
        }

        *ptime = time;

        return pch;
}

/*
 *  tzset -  sets the timezone information from the TZ environment variable.
 *           Global tzname[], _timezone, _daylight, and _dstoffset will be
 *           set. Static _startdate, _enddate, _starttime, and _endtime will
 *           also be set. TZ string looks like:
 *
 *                stdoffset[dst[offset][,start[/time],end[/time]]]
 *
 *  In form of variables: tzname[0]_timezone[tzname[1][_dstoffset]
 *                        [,_startdate[/_starttime],_enddate[/_endtime]]]
 *
 *  ENTRY   none.
 *
 *  RETURN  none.
 */

void __cdecl tzset(
        void
        )
{
        /* pch points to the beginning of an element to be parsed. */
        REG1 char *pch;

        /* pchCurr points to one position after the end of last element parsed. */
        REG2 char *pchCurr;

        char *TZ;

        _endtime = 7200L;
        _starttime = 7200L;

        if (!(TZ = getenv("TZ")) || !*TZ) {
                TZ = "PST8PDT7,M4.1.0/2:00,M10.5.0/2:00"; /* use default */
        }

        if((pchCurr = ParsePosixStdOrDst(pch=TZ)) == NULL) {
                return;
        }

        memcpy(tzname[0], pch, (int)(pchCurr-pch));
        tzname[0][(int)(pchCurr-pch)] = '\0';

        if((pchCurr = ParsePosixOffset(pch=pchCurr, &_timezone)) == NULL) {
                return;
        }

        _daylight = (*pchCurr != '\0');

        if(!_daylight) {
                return;
        }

        if((pchCurr = ParsePosixStdOrDst(pch=pchCurr)) == NULL) {
                return;
        }

        memcpy(tzname[1], pch, (int)(pchCurr-pch));
        tzname[1][(int)(pchCurr-pch)] = '\0';

        if(isdigit(*pchCurr) || *pchCurr == '-' || *pchCurr == '+') {
                if((pchCurr = ParsePosixOffset(pch=pchCurr, &_dstoffset)) == NULL) {
                        return;
                }
        } else {
                /* default: 1 hour ahead of standard time */
                _dstoffset = _timezone - SEC_PER_HOUR;
        }

        if(*pchCurr == ',') { /* ,start[/time],end[/time] */

                if((pchCurr = ParsePosixDate(pchCurr+1, &_startdate)) == NULL) {
                        goto out;
                }

                if(*pchCurr == '/') {
                        if(!(pchCurr = ParsePosixTime(pchCurr+1, &_starttime))) {
                                goto out;
                        }
                }

                if(*pchCurr != ',') {
                        goto out;
                }

                if ((pchCurr = ParsePosixDate(pchCurr+1, &_enddate)) == NULL) {
                        goto out;
                }

                if (*pchCurr == '/') {
                        if(!(pchCurr = ParsePosixTime(pchCurr+1, &_endtime))) {
                                goto out;
                        }
                }
        }
out:
        /*
         * Adjust the _endtime to account for the fact that
         * dst ends at _endtime local time, rather than
         * standard time.
         */

        _endtime -= (_timezone - _dstoffset);
}


#define DAY1    (4)             /* Jan 1 1970 was a Thursday */

/*
 *  GetDstStartOrEndYearDay - Converts day info from DSTDATE into 0-based
 *                            year-day.
 *
 *  ENTRY   tm_year - the year concerned(tb->tm_year).
 *
 *          pDstDate - pointer to either _startdate or _enddate.
 *
 *  RETURN  the year-day calculated.
 */

static int __cdecl
GetDstStartOrEndYearDay(
        REG1 int tm_year,
        REG2 PDSTDATE pDstDate
        )
{
        REG1 int yday; /* year-day */
        REG2 int theyear;

        theyear = tm_year + 1900;

        if(pDstDate->Jn != -1) {

                /*
                 *  Jn is in [1, 365] and leap day is not counted.
                 *  Convert Jn to 0-based yday; Note: 60 is March 1.
                 */


                yday = (IS_LEAP_YEAR(theyear) && (pDstDate->Jn >= 60))
                        ? pDstDate->Jn : pDstDate->Jn - 1;

        } else if(pDstDate->n != -1) {

                /*
                 *  n is in [0, 365] and leap day is counted.
                 */

                yday = pDstDate->n;

        } else { /* Mm.n.d */

                int *ptrday;
                int years;
                int wday;

                /*
                 *  We first need to calculate year-day(yday) and week-day
                 *  (wday) of 1st day of month pDstDate->Mm. We then figure
                 *  out year-day(yday) of Md day of week Mn of month Mm.
                 */

                ptrday = IS_LEAP_YEAR(theyear) ? _lpdays : _days;

                yday = ptrday[pDstDate->Mm-1] + 1; /* ptrday[i] are all by -1 off */

                years = tm_year - 70;

                /*
                 *  Here constant Day1 is the week-day of Jan 1, 1970.
                 *  (years+1)/4 is for correcting the leap years.
                 */

                wday = (yday + 365*years + (years+1)/4 + DAY1) % 7;

                /*
                 *  Calculate yday of Md day of week 1 of month Mm.
                 */

                yday += pDstDate->Md - wday;
                if(pDstDate->Md < wday) {
                        yday += 7;
                }

                /*
                 *  Calculate yday of Md day of week Mn of month Mm.
                 */

                yday += (pDstDate->Mn-1)*7;

                /*
                 *  Adjust if yday goes beyond the end of the month.
                 */

                if(pDstDate->Md == 5 && yday >= ptrday[pDstDate->Mm] + 1) {
                        yday -= 7;
                }

        }

        return yday;
}

/*
 *  _isindst - Tells whether Xenix-type time value falls under DST.
 *
 *  ENTRY   tb - 'time' structure holding broken-down time value.
 *
 *  RETURN  1 if time represented is in DST, else 0.
 */

int __cdecl _isindst (
        REG1 struct tm *tb
        )
{
        int st_yday, end_yday;
        int st_sec, end_sec;

        int check_time;

        /*
         * We need start/end year-days of DST in syday/eyday which are converted
         * from one of the format Jn, n, and Mm.n.d. We already have start/end
         * time (in seconds) of DST in _starttime/_endtime.
         */

        st_yday = GetDstStartOrEndYearDay(tb->tm_year, &_startdate);
        end_yday = GetDstStartOrEndYearDay(tb->tm_year, &_enddate);

        st_sec = st_yday * SEC_PER_DAY + _starttime;
        end_sec = end_yday * SEC_PER_DAY + _endtime;

        check_time = tb->tm_yday * SEC_PER_DAY + tb->tm_hour * SEC_PER_HOUR
                + tb->tm_min * 60 + tb->tm_sec;

        if (check_time >= st_sec && check_time < end_sec)
                return 1;

        return 0;
}

/*
 *  _isskiptime - Tells whether the given time is skipped at the
 *      dst change.  For instance, we set our clocks forward one
 *      hour at 2am to 3am...  This function returns true for
 *      the times between 1:59:59 and 3:00:00.
 *
 *  ENTRY   tb - 'time' structure holding broken-down time value.
 *
 *  RETURN  1 if time represented is in the skipped period, 0
 *      otherwise.
 */

int __cdecl _isskiptime (
        REG1 struct tm *tb
        )
{
        int st_yday;
        int st_sec;
        int check_time;

        st_yday = GetDstStartOrEndYearDay(tb->tm_year, &_startdate);
        st_sec = st_yday * SEC_PER_DAY + _starttime;

        check_time = tb->tm_yday * SEC_PER_DAY + tb->tm_hour * SEC_PER_HOUR
                + tb->tm_min * 60 + tb->tm_sec;

        if (check_time >= st_sec && check_time < st_sec - _dstoffset) {
                return 1;
        }
        return 0;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\utime.c ===
/***
*utime.c - set modification time for a file
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       03-??-84  RLB   initial version
*       05-17-86  SKS   ported to OS/2
*       08-21-87  JCR   error return if localtime() returns NULL.
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       10-03-88  JCR   386: Change DOS calls to SYS calls
*       10-04-88  JCR   386: Removed 'far' keyword
*       10-10-88  GJF   Made API names match DOSCALLS.H
*       10-11-88  GJF   Made API arg types match DOSCALLS.H
*       04-12-89  JCR   New syscall interface
*       05-01-89  JCR   Corrected OS/2 time/date interpretation
*       05-25-89  JCR   386 OS/2 calls use '_syscall' calling convention
*       08-16-89  PHG   moved date validation above open() so file isn't left
*                       open if the date is invalid
*       03-20-90  GJF   Replaced _LOAD_DS with _CALLTYPE1, added #include
*                       <cruntime.h>, removed #include <register.h>, removed
*                       some leftover 16-bit support and fixed the copyright.
*                       Also, cleaned up the formatting a bit.
*       07-25-90  SBM   Compiles cleanly with -W3 (added include, removed
*                       unreferenced variable), removed '32' from API names
*       10-04-90  GJF   New-style function declarator.
*       12-04-90  SRW   Changed to include <oscalls.h> instead of <doscalls.h>
*       12-06-90  SRW   Added _CRUISER_ and _WIN32 conditionals.
*       01-18-91  GJF   ANSI naming.
*       02-14-91  SRW   Fix Mips compile error (_WIN32_)
*       02-26-91  SRW   Fix SetFileTime parameter ordering (_WIN32_)
*       08-21-91  BWM   Add _futime to set time on open file
*       08-26-91  BWM   Change _utime to call _futime
*       05-19-92  DJM   ifndef for POSIX build.
*       08-18-92  SKS   SystemTimeToFileTime now takes UTC/GMT, not local time.
*                       Remove _CRUISER_ conditional
*       04-02-93  GJF   Changed interpretation of error on SetFileTime call.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       09-09-93  GJF   Have Win32 convert from a local file time value to a
*                       (system) file time value. This is symmetric with
*                       _stat() and a better work-around for the Windows NT
*                       bug in converting file times on FAT (applies DST
*                       offset based on current time rather than the file's
*                       time stamp).
*       11-01-93  CFW   Enable Unicode variant, rip out Cruiser.
*       02-09-95  GJF   Replaced WPRFLAG with _UNICODE.
*       02-13-95  GJF   Appended Mac version of source file (somewhat cleaned
*                       up), with appropriate #ifdef-s.
*       05-17-99  PML   Remove all Macintosh support.
*       10-27-99  GB    Remove #inlcude <dostypes.h>
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <sys/types.h>
#include <sys/utime.h>
#include <msdos.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#ifndef _XBOX
#include <dos.h>
#endif
#include <oscalls.h>
#include <errno.h>
#include <stddef.h>
#include <internal.h>

#include <stdio.h>
#include <tchar.h>

/***
*int _utime(pathname, time) - set modification time for file
*
*Purpose:
*       Sets the modification time for the file specified by pathname.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct _utimbuf *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tutime (
        const _TSCHAR *fname,
        struct _utimbuf *times
        )
{
        int fh;
        int retval;

        /* open file, fname, since filedate system call needs a handle.  Note
         * _utime definition says you must have write permission for the file
         * to change its time, so open file for write only.  Also, must force
         * it to open in binary mode so we dont remove ^Z's from binary files.
         */


        if ((fh = _topen(fname, _O_RDWR | _O_BINARY)) < 0)
                return(-1);

        retval = _futime(fh, times);

        _close(fh);
        return(retval);
}

#ifndef _UNICODE

/***
*int _futime(fh, time) - set modification time for open file
*
*Purpose:
*       Sets the modification time for the open file specified by fh.
*       Only the modification time from the _utimbuf structure is used
*       under MS-DOS.
*
*Entry:
*       struct _utimbuf *time - new modification date
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _futime (
        int fh,
        struct _utimbuf *times
        )
{
        REG1 struct tm *tmb;

        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;
        FILETIME LastWriteTime;
        FILETIME LastAccessTime;
        struct _utimbuf deftimes;

        if (times == NULL) {
                time(&deftimes.modtime);
                deftimes.actime = deftimes.modtime;
                times = &deftimes;
        }

        if ((tmb = localtime(&times->modtime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastWriteTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        if ((tmb = localtime(&times->actime)) == NULL) {
                errno = EINVAL;
                return(-1);
        }

        SystemTime.wYear   = (WORD)(tmb->tm_year + 1900);
        SystemTime.wMonth  = (WORD)(tmb->tm_mon + 1);
        SystemTime.wDay    = (WORD)(tmb->tm_mday);
        SystemTime.wHour   = (WORD)(tmb->tm_hour);
        SystemTime.wMinute = (WORD)(tmb->tm_min);
        SystemTime.wSecond = (WORD)(tmb->tm_sec);
        SystemTime.wMilliseconds = 0;

        if ( !SystemTimeToFileTime( &SystemTime, &LocalFileTime ) ||
             !LocalFileTimeToFileTime( &LocalFileTime, &LastAccessTime ) )
        {
                errno = EINVAL;
                return(-1);
        }

        /* set the date via the filedate system call and return. failing
         * this call implies the new file times are not supported by the
         * underlying file system.
         */

        if (!SetFileTime((HANDLE)_get_osfhandle(fh),
                                NULL,
                                &LastAccessTime,
                                &LastWriteTime
                               ))
        {
                errno = EINVAL;
                return(-1);
        }

        return(0);
}

#endif  /* _UNICODE */

#endif  /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wcsftime.c ===
/***
*wcsftime.c - String Format Time
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       03-08-93  CFW   Module Created.
*       03-10-93  CFW   Fixed up properly.
*       04-06-93  SKS   Replace _CRTAPI* with __cdecl
*       02-07-94  CFW   POSIXify.
*       12-16-94  CFW   Format must be wchar_t!
*       01-10-95  CFW   Debug CRT allocs.
*       08-27-98  GJF   Revised multithread support based on threadlocinfo
*                       struct. Also, use _alloca rather than malloc/free, 
*                       when possible.
*       01-06-99  GJF   Changes for 64-bit size_t.
*       12-10-99  GB    Added support for recovery from stack overflow around 
*                       _alloca().
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <time.h>
#include <dbgint.h>
#include <malloc.h>
#include <excpt.h>

#ifdef _XBOX
#undef _MT
#endif

#ifdef  _MT
size_t __cdecl _Strftime_mt (pthreadlocinfo ptloci, char *string, size_t maxsize,
        const char *format, const struct tm *timeptr, void *lc_time_arg);
#else
size_t __cdecl _Strftime (char *string, size_t maxsize, const char *format, 
        const struct tm *timeptr, void *lc_time_arg);
#endif


/***
*size_t wcsftime(wstring, maxsize, format, timeptr) - Format a time string
*
*Purpose:
*       The wcsftime functions is equivalent to to the strftime function, except
*       that the argument 'wstring' specifies an array of a wide string into
*       which the generated output is to be placed. The wcsftime acts as if
*       strftime were called and the result string converted by mbstowcs().
*       [ISO]
*
*Entry:
*       wchar_t *wstring = pointer to output string
*       size_t maxsize = max length of string
*       const wchar_t *format = format control string
*       const struct tm *timeptr = pointer to tb data structure
*
*Exit:
*       !0 = If the total number of resulting characters including the
*       terminating null is not more than 'maxsize', then return the
*       number of wide chars placed in the 'wstring' array (not including the
*       null terminator).
*
*       0 = Otherwise, return 0 and the contents of the string are
*       indeterminate.
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcsftime (
        wchar_t *wstring,
        size_t maxsize,
        const wchar_t *wformat,
        const struct tm *timeptr
        )
{
        size_t retval = 0;
        char *format = NULL;
        char *string = NULL;
        size_t flen = wcslen(wformat) + 1;
        int malloc_flag1 = 0;
        int malloc_flag2 = 0;
#ifdef  _MT
        pthreadlocinfo ptloci = _getptd()->ptlocinfo;

        if ( ptloci != __ptlocinfo )
            ptloci = __updatetlocinfo();
#endif

        __try {
            string = (char *)_alloca(sizeof(char) * maxsize * 2);
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            string = NULL;
        }

        if ( string == NULL ) {
            if ((string = (char *)_malloc_crt(sizeof(char) * maxsize * 2)) == NULL)
                return 0;
            else
                malloc_flag1++;
        }

        __try {
            format = (char *)_alloca(sizeof(char) * flen * 2);
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            _resetstkoflw();
            format = NULL;
        }

        if ( format == NULL ) {
            if ((format = (char *)_malloc_crt(sizeof(char) * flen * 2)) == NULL)
                goto done;
            else
                malloc_flag2++;
        }

#ifdef  _MT
        if (__wcstombs_mt(ptloci, format, wformat, flen * 2) == -1)
#else
        if (wcstombs(format, wformat, flen * 2) == -1)
#endif
            goto done;

#ifdef  _MT
        if (_Strftime_mt(ptloci, string, maxsize * 2, format, timeptr, 0))
#else
        if (_Strftime(string, maxsize * 2, format, timeptr, 0))
#endif
        {
#ifdef  _MT
            if ((retval = __mbstowcs_mt(ptloci, wstring, string, maxsize)) 
                == -1)
#else
            if ((retval = mbstowcs(wstring, string, maxsize)) == -1)
#endif
                retval = 0;
        }

done:
        if ( malloc_flag1 )
            _free_crt(string);

        if ( malloc_flag2 )
            _free_crt(format);

        return retval;
}

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wctime64.c ===
/***
*wctime64.c - convert time argument into a string (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _wctime64() - convert time value to wide char string
*
*Revision History:
*       05-21-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime64.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wutime64.c ===
/***
*wutime64.c - set modification time for a file (wchar_t version)
*
*       Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the access/modification times for a file.
*
*Revision History:
*       05-28-98  GJF   Created.
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE    /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "utime64.c"


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wutime.c ===
/***
*wutime.c - set modification time for a file (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sets the access/modification times for a file.
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "utime.c"


#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wctime.c ===
/***
*wctime.c - convert time argument into ASCII string (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains _wctime() - convert time value to wide ASCII string
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "ctime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wstrtime.c ===
/***
*wstrtime.c - contains the function "_wstrtime()"
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains the function _wstrtime()
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "strtime.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\time\wstrdate.c ===
/***
*wstrdate.c - contains the function "_wstrdate()" (wchar_t version)
*
*	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains the function _wstrdate()
*
*Revision History:
*	11-01-93  CFW	Module created.
*	02-07-94  CFW	POSIXify.
*	02-09-95  GJF	Removed obsolete WPRFLAG
*
*******************************************************************************/

#ifndef _POSIX_

#ifndef _UNICODE   /* CRT flag */
#define _UNICODE 1
#endif

#ifndef UNICODE	   /* NT flag */
#define UNICODE 1
#endif

#undef _MBCS /* UNICODE not _MBCS */

#include "strdate.c"

#endif /* _POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\delete.cpp ===
/***
*delete.cxx - defines C++ delete routine
*
*	Copyright (c) 1990-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	Defines C++ delete routine.
*
*Revision History:
*	05-07-90  WAJ	Initial version.
*	08-30-90  WAJ	new now takes unsigned ints.
*	08-08-91  JCR	call _halloc/_hfree, not halloc/hfree
*	08-13-91  KRS	Change new.hxx to new.h.  Fix copyright.
*	08-13-91  JCR	ANSI-compatible _set_new_handler names
*	10-30-91  JCR	Split new, delete, and handler into seperate sources
*	11-13-91  JCR	32-bit version
*	04-06-95  GJF	Not in debug libs.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <new.h>


void operator delete( void * p )
{
    free( p );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\calloc.c ===
/***
*calloc.c - Win32 calloc heap routines
*
*	Copyright (c) 1991-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*	01-10-92  JCR	Module created.
*	02-04-92  GJF	Replaced windows.h with oscalls.h.
*	05-06-92  DJM	POSIX support.
*	06-15-92  KRS	Enable C++ support.
*	09-09-92  SRW	_POSIX_ not even close.
*	09-23-92  SRW	Change winheap code to call NT directly always
*	10-28-92  SRW	Change winheap code to call Heap????Ex calls
*	11-05-92  SKS	Change name of variable "CrtHeap" to "_crtheap"
*	11-07-92  SRW   _NTIDW340 replaced by linkopts\betacmp.c
*	11-16-92  SRW	Heap???Ex functions renamed to Heap???
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl. Cleaned up format.
*	12-23-93  GJF	os2dll.h has been renamed mtdll.h.
*	09-21-94  GJF	Incorporated new handler changes.
*	04-06-95  GJF	Added support for debug heap.
*
*******************************************************************************/

#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <dbgint.h>

#ifndef _POSIX_

#include <new.h>

#ifndef DLL_FOR_WIN32S

extern _PNH _pnhHeap;	/* pointer to new() handler */

#endif	/* DLL_FOR_WIN32S */

#endif


/***
*void *calloc(size_t num, size_t size) - allocate storage for an array from
*	the heap
*
*Purpose:
*	Allocate a block of memory from heap big enough for an array of num
*	elements of size bytes each, initialize all bytes in the block to 0
*	and return a pointer to it.
*
*Entry:
*	size_t num	- number of elements in the array
*	size_t size	- size of each element
*
*Exit:
*	Success:  void pointer to allocated block
*	Failure:  NULL
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _calloc_base (
    size_t num,
    size_t size
    )
{
	void * retp;
	size_t n;

	if (!(n = num * size)) n = 1;

#ifndef _POSIX_
	for (;;) {
#endif  /* ndef _POSIX_ */

		retp = HeapAlloc(_crtheap,
			      HEAP_ZERO_MEMORY,
			      n
			     );
#ifndef _POSIX_
		if ( (retp != NULL) || (_newmode == 0) ||
		     (_pnhHeap == NULL) || ((*_pnhHeap)(n) == 0) )
#endif  /* ndef _POSIX_ */
			return( retp );

#ifndef _POSIX_
        }
#endif  /* ndef _POSIX_ */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapadd.c ===
/***
*heapadd.c -
*
*	Copyright (c) 1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>

int __cdecl
_heapadd (
    void * block,
    size_t size
    )
{
    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\handler.cpp ===
/***
*handler.cxx - defines C++ setHandler routine
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines C++ setHandler routine.
*
*Revision History:
*	05-07-90  WAJ	Initial version.
*	08-30-90  WAJ	new now takes unsigned ints.
*	08-08-91  JCR	call _halloc/_hfree, not halloc/hfree
*	08-13-91  KRS	Change new.hxx to new.h.  Fix copyright.
*	08-13-91  JCR	ANSI-compatible _set_new_handler names
*	10-30-91  JCR	Split new, delete, and handler into seperate sources
*	11-13-91  JCR	32-bit version
*	06-15-92  KRS	Remove per-thread handler for multi-thread libs
*	03-02-94  SKS	Add _query_new_handler(), remove commented out
*			per-thread thread handler version of _set_new_h code.
*	04-01-94  GJF	Made declaration of _pnhHeap conditional on ndef
*			DLL_FOR_WIN32S.
*	05-03-94  CFW	Add set_new_handler.
*	06-03-94  SKS	Remove set_new_hander -- it does NOT conform to ANSI
*			C++ working standard.  We may implement it later.
*	09-21-94  SKS	Fix typo: no leading _ on "DLL_FOR_WIN32S"
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <new.h>
#include <stdlib.h>

#ifndef	DLL_FOR_WIN32S

/* pointer to C++ new handler */
extern "C" _PNH _pnhHeap;

#endif	/* DLL_FOR_WIN32S */

/*
 * _set_new_handler is different from the ANSI C++ working standard definition
 * of set_new_handler.  Therefore it has a leading underscore in its name.
 */

_PNH _set_new_handler( _PNH pnh )
{
_PNH	 pnhOld;

    pnhOld = _pnhHeap;
    _pnhHeap = pnh;

    return(pnhOld);
}

_PNH _query_new_handler ( void )
{
    return _pnhHeap;
}

/***
*int _callnewh - call the appropriate new handler
*
*Purpose:
*       Call the appropriate new handler.
*
*Entry:
*       None
*
*Return:
*       1 for success
*       0 for failure
*       may throw bad_alloc
*
*******************************************************************************/

extern "C" int _callnewh(size_t size)
{
    _PNH pnh = _pnhHeap;
    
    if ( (pnh == NULL) || ((*pnh)(size) == 0) )
        return 0;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\expand.c ===
/***
*expand.c - Win32 expand heap routine
*
*	Copyright (c) 1991-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*	01-15-92  JCR	Module created.
*	02-04-92  GJF	Replaced windows.h with oscalls.h.
*	05-06-92  DJM	ifndef out of POSIX build.
*	09-23-92  SRW	Change winheap code to call NT directly always
*	10-15-92  SKS	Removed the ill-named HEAP_GROWTH_ALLOWED flag
*			which was causing a bug: _expand was behaving like
*			realloc(), by moving the block when it could not be
*			grown in place.  _expand() must NEVER move the block.
*			Also added a safety check to work around a bug in
*			HeapReAlloc, where it returns success even
*			when it fails to grow the block in place.
*	10-28-92  SRW	Change winheap code to call Heap????Ex calls
*	11-05-92  SKS	Change name of variable "CrtHeap" to "_crtheap"
*	11-07-92  SRW   _NTIDW340 replaced by linkopts\betacmp.c
*	11-16-92  SRW	Heap???Ex functions renamed to Heap???
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl. Cleaned up format.
*	04-06-95  GJF	Added support for debug heap.
*
*******************************************************************************/

#ifndef _POSIX_

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <oscalls.h>
#include <dbgint.h>

/***
*void *_expand(void *pblck, size_t newsize) - expand/contract a block of memory
*	in the heap
*
*Purpose:
*	Resizes a block in the heap to newsize bytes. newsize may be either
*	greater (expansion) or less (contraction) than the original size of
*	the block. The block is NOT moved.
*
*	NOTES:
*
*	(1) In this implementation, if the block cannot be grown to the
*	desired size, the resulting block will NOT be grown to the max
*	possible size.	(That is, either it works or it doesn't.)
*
*	(2) Unlike other implementations, you can NOT pass a previously
*	freed block to this routine and expect it to work.
*
*Entry:
*	void *pblck	- pointer to block in the heap previously allocated
*			  by a call to malloc(), realloc() or _expand().
*
*	size_t newsize	- requested size for the resized block
*
*Exit:
*	Success:  Pointer to the resized memory block (i.e., pblck)
*	Failure:  NULL
*
*Uses:
*
*Exceptions:
*	If pblck does not point to a valid allocation block in the heap,
*	_expand() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _expand_base(
    void * pblock,
    size_t n
    )
{
	void * p;

	p = HeapReAlloc(_crtheap,
			HEAP_REALLOC_IN_PLACE_ONLY,
			pblock,
			n ? n : 1
		       );

	/**
	 * Temporary BUG work-around:
	 * HeapReAlloc sometimes (often?) returns success
	 * even when there has been a failure to grow in place.
	 * This conditional will recognize this case and handle it.
	 **/
	return ( p == pblock ) && ( _msize(pblock) >= n ) ? pblock : NULL;
}

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapmin.c ===
/***
*heapmin.c - Minimize the heap
*
*	Copyright (c) 1989-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Minimize the heap freeing as much memory as possible back
*	to the OS.
*
*Revision History:
*	08-28-89   JCR	Module created.
*	11-06-89   JCR	Improved, partitioned
*	11-13-89   GJF	Added MTHREAD support, also fixed copyright
*	12-14-89   GJF	Couple of bug fixes, some tuning, cleaned up the
*			formatting a bit and changed header file name to
*			heap.h
*	12-20-89   GJF	Removed references to plastdesc
*	03-11-90   GJF	Replaced _cdecl with _CALLTYPE1, added #include
*			<cruntime.h> and removed #include <register.h>.
*	03-29-90   GJF	Made _heapmin_region() and _free_partial_region()
*			_CALLTYPE4.
*	07-24-90   SBM	Compiles cleanly with -W3 (tentatively removed
*			unreferenced labels and unreachable code), removed
*			'32' from API names
*	09-28-90   GJF	New-style function declarators. Also, rewrote expr.
*			to avoid using cast as lvalue.
*	12-04-90  SRW	Changed to include <oscalls.h> instead of <doscalls.h>
*	12-06-90  SRW	Added _CRUISER_ and _WIN32 conditionals.
*	12-28-90  SRW	Added cast of void * to char * for Mips C Compiler
*       03-05-91  GJF   Changed strategy for rover - old version available
*                       by #define-ing _OLDROVER_.
*	06-27-94  SRW	Ported to Win32 Heap API
*	09-20-94  GJF	NT version, merged into VC tree.
*	10-92-94  BWT	os2dll.h has been renamed to mtdll.h
*	10-31-94  GJF	Use _crtheap instead of calling GetProcessHeap().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <winheap.h>

#ifndef _POSIX_

/***
*_heapmin() - Minimize the heap
*
*Purpose:
*	Minimize the heap freeing as much memory as possible back
*	to the OS.
*
*Entry:
*	(void)
*
*Exit:
*
*	 0 = no error has occurred
*	-1 = an error has occurred (errno is set)
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapmin(void)
{
	if ( HeapCompact( _crtheap, 0 ) == 0 ) {
	    return -1;
        }
	else {
	    return 0;
        }
}

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapchk.c ===
/***
*heapchk.c - perform a consistency check on the heap
*
*	Copyright (c) 1989-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the _heapchk() and _heapset() functions
*
*Revision History:
*	06-30-89  JCR	Module created.
*	07-28-89  GJF	Added check for free block preceding the rover
*	11-13-89  GJF	Added MTHREAD support, also fixed copyright
*	12-13-89  GJF	Added check for descriptor order, did some tuning,
*			changed header file name to heap.h
*	12-15-89  GJF	Purged DEBUG286 stuff. Also added explicit _cdecl to
*			function definitions.
*	12-19-89  GJF	Got rid of checks involving plastdesc (revised check
*			of proverdesc and DEBUG errors accordingly)
*	03-09-90  GJF	Replaced _cdecl with _CALLTYPE1, added #include
*			<cruntime.h> and removed #include <register.h>.
*	03-29-90  GJF	Made _heap_checkset() _CALLTYPE4.
*	09-27-90  GJF	New-style function declarators.
*	03-05-91  GJF	Changed strategy for rover - old version available
*			by #define-ing _OLDROVER_.
*       06-27-94  SRW   Ported to Win32 Heap API
*	07-06-94  SRW	Chicago compatibility changes.
*	09-20-94  GJF	NT version, merged into VC tree.
*	10-92-94  BWT	os2dll.h has been renamed to mtdll.h
*	10-31-94  GJF	Use _crtheap instead of calling GetProcessHeap().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <string.h>
#include <winheap.h>

#ifndef _POSIX_

/***
*int _heapchk()      - Validate the heap
*int _heapset(_fill) - Validate the heap and fill in free entries
*
*Purpose:
*	Performs a consistency check on the heap.
*
*Entry:
*	For heapchk()
*		No arguments
*	For heapset()
*		int _fill - value to be used as filler in free entries
*
*Exit:
*	Returns one of the following values:
*
*		_HEAPOK 	 - completed okay
*		_HEAPEMPTY	 - heap not initialized
*		_HEAPBADBEGIN	 - can't find initial header info
*		_HEAPBADNODE	 - malformed node somewhere
*
*	Debug version prints out a diagnostic message if an error is found
*	(see errmsg[] above).
*
*	NOTE:  Add code to support memory regions.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapchk(void)
{
	if ( !HeapValidate( _crtheap, 0, NULL ) ) {
            return _HEAPBADNODE;
	}
        else {
            return _HEAPOK;
	}
}

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

int __cdecl _heapset (
	unsigned int _fill
	)
{
        int _retval = _HEAPOK;
        PROCESS_HEAP_ENTRY Entry;

	if ( !HeapValidate( _crtheap, 0, NULL ) ) {
            return _HEAPBADNODE;
	}

	if ( !HeapLock( _crtheap ) ) {
            return _HEAPBADBEGIN;
	}

        Entry.lpData = NULL;
	__try {
            while (TRUE) {
		if (!HeapWalk( _crtheap, &Entry )) {
                    if (GetLastError() != ERROR_NO_MORE_ITEMS) {
                        _retval = _HEAPBADNODE;
		    }

                    break;
		}

                if (Entry.wFlags & (PROCESS_HEAP_REGION | PROCESS_HEAP_UNCOMMITTED_RANGE)) {
                    continue;
		}


                if (!(Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY)) {
		    __try {
                        memset( Entry.lpData, _fill, Entry.cbData );
		    }
		    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        // Chicago free blocks may contain uncommitted pages.  Punt
		    }
		}
	    }
	}
	__finally {
	    HeapUnlock( _crtheap );
	}

        return _retval;
}

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapinit.c ===
/***
*heapinit.c -  Initialze the heap
*
*	Copyright (c) 1989-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	01-10-92  JCR	Module created.
*	05-12-92  DJM	POSIX calls RtlProcessHeap.
*	09-23-92  SRW	Change winheap code to call NT directly always
*	10-28-92  SRW	Change winheap code to call Heap????Ex calls
*	11-05-92  SKS	Change name of variable "CrtHeap" to "_crtheap"
*	11-07-92  SRW	_NTIDW340 replaced by linkopts\betacmp.c
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl.
*	10-31-94  GJF	Use HeapCreate instead of GetProcessHeap.
*	11-07-94  GJF	Added conditional, dummy definition for _amblksiz so
*			that the dll will build.
*	04-07-95  GJF	Made definition of _crtheap conditional on
*			DLL_FOR_WIN32S.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>

#ifndef _XBOX

#ifndef DLL_FOR_WIN32S
HANDLE _crtheap;
#endif

#if	!defined(_NTSDK) && !defined(DLL_FOR_WIN32S)
/*
 * Dummy definition of _amblksiz. Included primarily so the dll will build
 * without having to change crtlib.c (there is an access function for _amblksiz
 * defined in crtlib.c).
 */
unsigned int _amblksiz = _PAGESIZE_;
#endif


/***
*_heap_init() - Initialize the heap
*
*Purpose:
*	Setup the initial C library heap.
*
*	NOTES:
*	(1) This routine should only be called once!
*	(2) This routine must be called before any other heap requests.
*
*Entry:
*	<void>
*Exit:
*	<void>
*
*Exceptions:
*	If heap cannot be initialized, the program will be terminated
*	with a fatal runtime error.
*
*******************************************************************************/

void __cdecl _heap_init (
	void
	)
{
	_crtheap = HeapCreate (
#ifdef	_MT
				0,
#else
				HEAP_NO_SERIALIZE,
#endif
				_PAGESIZE_,
				0
			      );
	return;
}


/***
*_heap_term() - return the heap to the OS
*
*Purpose:
*
*	NOTES:
*	(1) This routine should only be called once!
*	(2) This routine must be called AFTER any other heap requests.
*
*Entry:
*	<void>
*Exit:
*	<void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_term (
	void
	)
{
	HeapDestroy( _crtheap );
}

#endif !_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapused.c ===
/***
*heapused.c
*
*	Copyright (c) 1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>

size_t __cdecl
_heapused(
    size_t *pUsed,
    size_t *pCommit
    )
{
    *pUsed = 64 * 1024;
    *pCommit = 128 * 1024;
    return(64 * 1024);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\heapwalk.c ===
/***
*heapwalk.c - walk the heap
*
*	Copyright (c) 1989-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Defines the _heapwalk() function
*
*Revision History:
*	07-05-89  JCR	Module created.
*	11-13-89  GJF	Added MTHREAD support, also fixed copyright.
*	11-14-89  JCR	Fixed bug -- returned address was off by HDRSIZE
*	12-18-89  GJF	Removed DEBUG286 stuff, also some tuning, cleaned up
*			format a bit, changed header file name to heap.h, added
*			explicit _cdecl to function definition
*	12-20-89  GJF	Removed references to plastdesc
*	03-11-90  GJF	Replaced _cdecl with _CALLTYPE1, added #include
*			<cruntime.h> and removed #include <register.h>.
*	09-28-90  GJF	New-style function declarator.
*	06-27-94  SRW	Ported to Win32 Heap API
*	09-20-94  GJF	NT version, merged into VC tree.
*	10-92-94  BWT	os2dll.h has been renamed to mtdll.h
*	10-31-94  GJF	Use _crtheap instead of calling GetProcessHeap().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <winheap.h>

#ifndef _POSIX_

/***
*int _heapwalk() - Walk the heap
*
*Purpose:
*	Walk the heap returning information on one entry at a time.
*
*Entry:
*	struct _heapinfo {
*		int * _pentry;	heap entry pointer
*		size_t size;	size of heap entry
*		int _useflag;	free/inuse flag
*		} *entry;
*
*Exit:
*	Returns one of the following values:
*
*		_HEAPOK 	- completed okay
*		_HEAPEMPTY	- heap not initialized
*		_HEAPBADPTR	- _pentry pointer is bogus
*		_HEAPBADBEGIN	- can't find initial header info
*		_HEAPBADNODE	- malformed node somewhere
*		_HEAPEND	- end of heap successfully reached
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapwalk (
	struct _heapinfo *_entry
	)
{
        PROCESS_HEAP_ENTRY Entry;
	int retval = _HEAPOK;

        Entry.wFlags = 0;
        Entry.iRegionIndex = 0;
        if ((Entry.lpData = _entry->_pentry) == NULL) {
	    if (!HeapWalk( _crtheap, &Entry )) {
                return _HEAPBADBEGIN;
                }
            }
        else {
            if (_entry->_useflag == _USEDENTRY) {
                Entry.wFlags = PROCESS_HEAP_ENTRY_BUSY;
                }
nextBlock:
	    if (!HeapWalk( _crtheap, &Entry )) {
                return _HEAPBADNODE;
                }
            }

        if (Entry.wFlags & (PROCESS_HEAP_REGION | PROCESS_HEAP_UNCOMMITTED_RANGE)) {
            goto nextBlock;
            }

        _entry->_pentry = Entry.lpData;
        _entry->_size = Entry.cbData;
        if (Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            _entry->_useflag = _USEDENTRY;
            }
        else {
            _entry->_useflag = _FREEENTRY;
            }

	return(retval);
}

#endif  /* !_POSIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\new_mode.cpp ===
/***
*newmode.cxx - defines C++ setHandler mode
*
*	Copyright (c) 1994-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	Defines routines to set and to query the C++ new handler mode.
*
*	The new handler mode flag determines whether malloc() failures will
*	call the new() failure handler, or whether malloc will return NULL.
*
*Revision History:
*	03-03-94  SKS	Initial version.
*	03-04-94  SKS	Rename _nhMode to _newmode
*	04-14-94  GJF	Made declaration of _newmode conditional on
*			DLL_FOR_WIN32S.
*	04-06-95  GJF	Replaced above change by including internal.h.
*
*******************************************************************************/

#include <cruntime.h>
#include <new.h>
#include <internal.h>
#include <winheap.h>

int _set_new_mode( int nhm )
{
    int nhmOld;

    /*
     * The only valid inputs are 0 and 1
     */

    if ( ( nhm & 01 ) != nhm )
	return -1;

    /*
     * Set the new mode and return the old
     */
    nhmOld = _newmode;
    _newmode = nhm;

    return nhmOld;
}

int _query_new_mode ( void )
{
    return _newmode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\sources.inc ===
MAJORCOMP=crt
MINORCOMP=winheap

TARGETNAME=winheap

!INCLUDE ..\..\crt32.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\malloc.c ===
/***
*malloc.c - Win32 malloc/free heap routines
*
*	Copyright (c) 1991-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*	01-10-92  JCR	Module created.
*	02-04-92  GJF	Replaced windows.h with oscalls.h.
*	05-06-92  DJM	POSIX support.
*	06-15-92  KRS	Enable C++ support.
*	09-09-92  SRW	_POSIX_ not even close.
*	09-23-92  SRW	Change winheap code to call NT directly always
*	10-28-92  SRW	Change winheap code to call Heap????Ex calls
*	11-05-92  SKS	Change name of variable "CrtHeap" to "_crtheap"
*	11-07-92  SRW   _NTIDW340 replaced by linkopts\betacmp.c
*	11-16-92  SRW	Heap???Ex functions renamed to Heap???
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl. Cleaned up format.
*	12-23-93  GJF	os2dll.h has been renamed mtdll.h.
*	09-21-94  GJF	Incorporated new handler changes.
*	10-02-94  BWT	Use correct name when calling _nh_malloc.
*	04-04-95  GJF	Don't bother to call HeapFree for free(NULL).
*	04-06-95  GJF	Added support from debug heap.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <dbgint.h>

#ifndef _POSIX_

#include <new.h>

#ifndef DLL_FOR_WIN32S

_PNH _pnhHeap = NULL;	/* pointer to new() handler */

#endif	/* DLL_FOR_WIN32S */

#endif

/***
*void *malloc(size_t size) - Get a block of memory from the heap
*
*Purpose:
*	Allocate of block of memory of at least size bytes from the heap and
*	return a pointer to it.
*
*Entry:
*	size_t size	- size of block requested
*
*Exit:
*	Success:  Pointer to memory block
*	Failure:  NULL (or some error value)
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _malloc_base(
	size_t n
	)

#ifndef _POSIX_

{
	return _nh_malloc_base( n , _newmode ) ;
}

void * __cdecl _nh_malloc_base(
	size_t n,
	int nhFlag
	)
{
	void * h;
	n = (n ? n : 1);	/* if n == 0, n = 1 */

	for (;;) {
		h = _heap_alloc_base( n );
		if ( (h != NULL) || (nhFlag == 0) || (_pnhHeap == NULL) ||
		     ((*_pnhHeap)(n) == 0) )
			return((void *)h);
	}
}

/***
*void *_heap_alloc_base(size_t size) - does actual allocation
*
*Purpose:
*	Same as malloc() except the new handler is not called.
*
*Entry:
*	See malloc
*
*Exit:
*	See malloc
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _heap_alloc_base (
	size_t n
	)

#endif	/* _POSIX_ */

{
	void * h;
	n = (n ? n : 1);	/* if n == 0, n = 1 */

	h = HeapAlloc( _crtheap, 0, n );

	return((void *)h);
}


/***
*void free(pblock) - free a block in the heap
*
*Purpose:
*	Free a memory block in the heap.
*
*	Special ANSI Requirements:
*
*	(1) free(NULL) is benign.
*
*Entry:
*	void *pblock - pointer to a memory block in the heap
*
*Return:
*	<void>
*
*******************************************************************************/

void __cdecl _free_base(
    void * pblock
    )
{
	if ( pblock == NULL )
	    return;

	HeapFree(_crtheap,
		 0,
		 pblock
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\hpabort.c ===
/***
*hpabort.c - Abort process due to fatal heap error
*
*	Copyright (c) 1988-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*	11-13-89   JCR	Module created
*	12-18-89   GJF	#include-ed heap.h, also added explicit _cdecl to
*			function definition.
*	03-11-90   GJF	Replaced _cdecl with _CALLTYPE1 and added #include
*			<cruntime.h>.
*	10-03-90   GJF	New-style function declarator.
*	10-11-90   GJF	Changed interface to _amsg_exit().
*	08-30-93   GJF	Deleted #include <heap.h>
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>


/***
* _heap_abort() - Abort process due to fatal heap error
*
*Purpose:
*	Terminate the process and output a heap error message
*
*Entry:
*	Void
*
*Exit:
*	Never returns
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_abort (
	void
	)
{
	_amsg_exit(_RT_HEAP);		/* heap error */
	/*** PROCESS TERMINATED ***/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\new.cpp ===
/***
*new.cxx - defines C++ new routine
*
*	Copyright (c) 1990-1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Defines C++ new routine.
*
*Revision History:
*	05-07-90  WAJ	Initial version.
*	08-30-90  WAJ	new now takes unsigned ints.
*	08-08-91  JCR	call _halloc/_hfree, not halloc/hfree
*	08-13-91  KRS	Change new.hxx to new.h.  Fix copyright.
*	08-13-91  JCR	ANSI-compatible _set_new_handler names
*	10-30-91  JCR	Split new, delete, and handler into seperate sources
*	11-13-91  JCR	32-bit version
*	02-16-94  SKS	Move set_new_handler functionality here from malloc()
*	03-01-94  SKS	_pnhHeap must be declared in malloc.c, not here
*	03-03-94  SKS	New handler functionality moved to malloc.c but under
*			a new name, _nh_malloc().
*	09-20-94  GJF	Copied over from  heap\new.cxx. Changed heap.h to
*			winheap.h
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <new.h>
#include <stdlib.h>

void * operator new( unsigned int cb )
{
    return _nh_malloc(cb, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\msize.c ===
/***
*msize.c - Win32 malloc/free heap routines
*
*	Copyright (c) 1991-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       01-10-92  JCR   Module created.
*       02-04-92  GJF   Replaced windows.h with oscalls.h.
*       05-06-92  DJM   ifndef out for POSIX.
*       09-23-92  SRW   Change winheap code to call NT directly always
*       10-28-92  SRW   Change winheap code to call Heap????Ex calls
*       11-05-92  SKS   Change name of variable "CrtHeap" to "_crtheap"
*       11-07-92  SRW   _NTIDW340 replaced by linkopts\betacmp.c
*       11-16-92  SRW   Heap???Ex functions renamed to Heap???
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl. Cleaned up format.
*	04-06-95  GJF	Added support for debug heap.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <dbgint.h>

/***
*size_t _msize(pblock) - calculate the size of specified block in the heap
*
*Purpose:
*       Calculates the size of memory block (in the heap) pointed to by
*       pblock.
*
*Entry:
*       void *p - pointer to a memory block in the heap
*
*Return:
*       size of the block
*
*******************************************************************************/

size_t __cdecl
_msize_base(
    void * pblock
    )
{
	return( (size_t) HeapSize( _crtheap, 0, pblock ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\realloc.c ===
/***
*realloc.c - Win32 realloc heap routine
*
*	Copyright (c) 1991-1995, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*	01-10-92  JCR	Module created.
*	02-04-92  GJF	Replaced windows.h with oscalls.h.
*	05-06-92  DJM	POSIX support.
*	09-09-92  SRW	Fixed _POSIX_ to allow movement when growing.
*	09-23-92  SRW	Change winheap code to call NT directly always
*	10-28-92  SRW	Change winheap code to call Heap????Ex calls
*	11-05-92  SKS	Change name of variable "CrtHeap" to "_crtheap"
*	11-07-92  SRW   _NTIDW340 replaced by linkopts\betacmp.c
*	11-16-92  SRW	Heap???Ex functions renamed to Heap???
*	10-21-93  GJF	Replace _CALLTYPE1 with _cdecl. Cleaned format up.
*	09-21-94  GJF	Put in support for user-specified new handler.
*	04-06-95  GJF	Added support for debug heap.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <dbgint.h>

#ifndef _POSIX_

#include <new.h>

#ifndef DLL_FOR_WIN32S

extern _PNH _pnhHeap;	/* pointer to new() handler */

#endif	/* DLL_FOR_WIN32S */

#endif

/***
*void *realloc(void *pblock, size_t newsize) - reallocate a block of memory in
*	the heap
*
*Purpose:
*	Re-allocates a block in the heap to newsize bytes. newsize may be
*	either greater or less than the original size of the block. The
*	re-allocation may result in moving the block as well as changing
*	the size. If the block is moved, the contents of the original block
*	are copied over.
*
*	Special ANSI Requirements:
*
*	(1) realloc(NULL, newsize) is equivalent to malloc(newsize)
*
*	(2) realloc(pblock, 0) is equivalent to free(pblock) (except that
*	    NULL is returned)
*
*	(3) if the realloc() fails, the object pointed to by pblock is left
*	    unchanged
*
*Entry:
*	void *pblock	- pointer to block in the heap previously allocated
*			  by a call to malloc(), realloc() or _expand().
*
*	size_t newsize	- requested size for the re-allocated block
*
*Exit:
*	Success:  Pointer to the re-allocated memory block
*	Failure:  NULL
*
*Uses:
*
*Exceptions:
*	If pblock does not point to a valid allocation block in the heap,
*	realloc() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _realloc_base(
	void * pblock,
	size_t n
	)

{
	void *retp;

	/* if ptr is NULL, call malloc */
	if ( pblock == (void *) NULL )
		return( _malloc_base( n ) );

	/* if ptr is !NULL and size is 0, call free and return NULL */
	if ( n == 0 ) {
		_free_base( pblock );
		return( (void *)NULL );
	}

#ifndef _POSIX_
	for (;;) {
#endif	/* _POSIX_ */

		retp = HeapReAlloc( _crtheap,
				    0,
				    pblock,
				    n
				  );
#ifndef _POSIX_
		if ( (retp != NULL) || (_newmode == 0) || (_pnhHeap == NULL)
		     || ((*_pnhHeap)(n) == 0) )
#endif  /* ndef _POSIX_ */
			return( (void *)retp );
#ifndef _POSIX_
        }
#endif	/* ndef _POSIX_ */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\assrt.c ===
/***
*assrt.c - assertions needed for string conversion routines
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Make sure that the data types used by the string conversion
*   routines have the right size. If this file does not compile,
*   the type definitions in cv.h should change appropriately.
*
*Revision History:
*   07-25-91	    GDP     written
*
*******************************************************************************/


#include <cv.h>

static void assertion_test(void)
{
    sizeof(u_char) == 1 ? 0 : 1/0,
    sizeof(u_short)  == 2 ? 0 : 1/0,
    sizeof(u_long) == 4 ? 0 : 1/0,
    sizeof(s_char) == 1 ? 0 : 1/0,
    sizeof(s_short)  == 2 ? 0 : 1/0,
    sizeof(s_long) == 4 ? 0 : 1/0;
#ifdef _LDSUPPORT
    sizeof(long double) == 10 ? 0 : 1/0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\cfin.c ===
/***
*cfin.c - Encode interface for C
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*       07-20-91  GDP   Ported to C from assembly
*       04-30-92  GDP   use __strgtold12 and _ld12tod
*       06-22-92  GDP   use new __strgtold12 interface
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       09-06-94  CFW   Replace MTHREAD with _MT.
*       10-06-99  PML   Copy a DOUBLE, not double, to avoid exceptions
*
*******************************************************************************/

#include <string.h>
#include <cv.h>


#ifndef _MT
static struct _flt ret;
static FLT flt = &ret;
#endif

/* The only three conditions that this routine detects */
#define CFIN_NODIGITS 512
#define CFIN_OVERFLOW 128
#define CFIN_UNDERFLOW 256

/* This version ignores the last two arguments (radix and scale)
 * Input string should be null terminated
 * len is also ignored
 */
#ifdef _MT
FLT __cdecl _fltin2(FLT flt, const char *str, int len_ignore, int scale_ignore, int radix_ignore)
#else
FLT __cdecl _fltin(const char *str, int len_ignore, int scale_ignore, int radix_ignore)
#endif
{
    _LDBL12 ld12;
    DOUBLE x;
    const char *EndPtr;
    unsigned flags;
    int retflags = 0;

    flags = __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0);
    if (flags & SLD_NODIGITS) {
        retflags |= CFIN_NODIGITS;
        *(u_long *)&x = 0;
        *((u_long *)&x+1) = 0;
    }
    else {
        INTRNCVT_STATUS intrncvt;

        intrncvt = _ld12tod(&ld12, &x);

        if (flags & SLD_OVERFLOW  ||
            intrncvt == INTRNCVT_OVERFLOW) {
            retflags |= CFIN_OVERFLOW;
        }
        if (flags & SLD_UNDERFLOW ||
            intrncvt == INTRNCVT_UNDERFLOW) {
            retflags |= CFIN_UNDERFLOW;
        }
    }

    flt->flags = retflags;
    flt->nbytes = (int)(EndPtr - str);
    *(DOUBLE *)&flt->dval = *(DOUBLE *)&x;

    return flt;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\crtw32\winheap\_newmode.c ===
/***
*_newmode.c - set new() handler mode to not handle malloc failures
*
*	Copyright (c) 1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Sets the global flag which controls whether the new() handler
*	is called on malloc failures.  The default behavior in Visual
*	C++ v2.0 and later is not to, that malloc failures return NULL
*	without calling the new handler.  This object is linked in unless
*	the special object NEWMODE.OBJ is manually linked.
*
*	This source file is the complement of LINKOPTS/NEWMODE.C.
*
*Revision History:
*	03-04-94  SKS	Original version.
*	04-14-94  GJF	Added conditionals so this definition doesn't make
*			it into the Win32s version of msvcrt*.dll.
*	10-02-94  BWT	For _NTSDK, make it default to call the new handler for
*			backward compatability with crtdll.dll
*
*******************************************************************************/

#ifndef _POSIX_

#if	!defined(CRTDLL) || !defined(DLL_FOR_WIN32S)

#include <internal.h>

/* enable new handler calls upon malloc failures */

#ifdef _NTSDK
int _newmode = 1;	/* Malloc New Handler MODE */
#else
int _newmode = 0;	/* Malloc New Handler MODE */
#endif

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\fltinf.c ===
/***
*fltinf.c - Encode interface for FORTRAN
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       FORTRAN interface for decimal to binary (input) conversion
*
*Revision History:
*       06-22-92  GDP   Modified version of cfin.c for FORTRAN support
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       10-06-99  PML   Copy a DOUBLE, not double, to avoid exceptions
*
*******************************************************************************/

#include <string.h>
#include <cv.h>

static struct _flt ret;
static FLT flt = &ret;

/* Error codes set by this routine */
#define CFIN_NODIGITS 512
#define CFIN_OVERFLOW 128
#define CFIN_UNDERFLOW 256
#define CFIN_INVALID  64

FLT __cdecl _fltinf(const char *str, int len, int scale, int decpt)
{
    _LDBL12 ld12;
    DOUBLE x;
    const char *EndPtr;
    unsigned flags;
    int retflags = 0;

    flags = __strgtold12(&ld12, &EndPtr, str, 0, scale, decpt, 1);
    if (flags & SLD_NODIGITS) {
        retflags |= CFIN_NODIGITS;
        *(u_long *)&x = 0;
        *((u_long *)&x+1) = 0;
    }
    else {
        INTRNCVT_STATUS intrncvt;

        intrncvt = _ld12tod(&ld12, &x);

        if (flags & SLD_OVERFLOW  ||
            intrncvt == INTRNCVT_OVERFLOW) {
            retflags |= CFIN_OVERFLOW;
        }
        if (flags & SLD_UNDERFLOW ||
            intrncvt == INTRNCVT_UNDERFLOW) {
            retflags |= CFIN_UNDERFLOW;
        }
    }

    flt->nbytes = (int)(EndPtr - str);
    if (len != flt->nbytes)
        retflags |= CFIN_INVALID;
    *(DOUBLE *)&flt->dval = *(DOUBLE *)&x;
    flt->flags = retflags;

    return flt;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\constpow.c ===
/***
*constpow.c - constant powers of ten
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Provide powers of ten in long double form:
*   10^(2^i), i=0,1,2,...
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/


#include <cv.h>

/* Format: A 10 byte long double + 2 bytes of extra precision
 * If the extra precision is desired, the 10-byte long double
 * should be "unrounded" first.
 * This may change in later versions
 */

#ifdef L_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},
 /*P0002*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},
 /*P0003*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},
 /*P0004*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},
 /*P0005*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},
 /*P0006*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},
 /*P0007*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},
 /*P0008*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},
 /*P0016*/ {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},
 /*P0024*/ {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},
 /*P0032*/ {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},
 /*P0040*/ {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},
 /*P0048*/ {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},
 /*P0056*/ {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},
 /*P0064*/ {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},
 /*P0128*/ {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},
 /*P0192*/ {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},
 /*P0256*/ {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},
 /*P0320*/ {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},
 /*P0384*/ {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},
 /*P0448*/ {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},
 /*P0512*/ {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},
 /*P1024*/ {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},
 /*P1536*/ {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},
 /*P2048*/ {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},
 /*P2560*/ {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},
 /*P3072*/ {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},
 /*P3584*/ {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},
 /*P4096*/ {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},
 /*N0002*/ {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},
 /*N0003*/ {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},
 /*N0004*/ {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},
 /*N0005*/ {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},
 /*N0006*/ {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},
 /*N0007*/ {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},
 /*N0008*/ {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},
 /*N0016*/ {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},
 /*N0024*/ {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},
 /*N0032*/ {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},
 /*N0040*/ {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},
 /*N0048*/ {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},
 /*N0056*/ {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},
 /*N0064*/ {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},
 /*N0128*/ {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},
 /*N0192*/ {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},
 /*N0256*/ {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},
 /*N0320*/ {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},
 /*N0384*/ {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},
 /*N0448*/ {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},
 /*N0512*/ {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},
 /*N1024*/ {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},
 /*N1536*/ {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},
 /*N2048*/ {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},
 /*N2560*/ {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},
 /*N3072*/ {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},
 /*N3584*/ {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},
 /*N4096*/ {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}
};

#endif

#ifdef B_END

_LDBL12 _pow10pos[] = {
 /*P0001*/ {{0x40,0x02,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0002*/ {{0x40,0x05,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0003*/ {{0x40,0x08,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0004*/ {{0x40,0x0C,0x9C,0x40,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0005*/ {{0x40,0x0F,0xC3,0x50,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0006*/ {{0x40,0x12,0xF4,0x24,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0007*/ {{0x40,0x16,0x98,0x96,0x80,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0008*/ {{0x40,0x19,0xBE,0xBC,0x20,0x00,0x00,0x00,0x00,0x00, 0x00,0x00}},
 /*P0016*/ {{0x40,0x34,0x8E,0x1B,0xC9,0xBF,0x04,0x00,0x00,0x00, 0x00,0x00}},
 /*P0024*/ {{0x40,0x4E,0xD3,0xC2,0x1B,0xCE,0xCC,0xED,0xA1,0x00, 0x00,0x00}},
 /*P0032*/ {{0x40,0x69,0x9D,0xC5,0xAD,0xA8,0x2B,0x70,0xB5,0x9E, 0xF0,0x20}},
 /*P0040*/ {{0x40,0x83,0xEB,0x19,0x4F,0x8E,0x1A,0xE5,0x25,0xFD, 0x5D,0xD0}},
 /*P0048*/ {{0x40,0x9E,0xAF,0x29,0x8D,0x05,0x0E,0x43,0x95,0xD7, 0x96,0x71}},
 /*P0056*/ {{0x40,0xB9,0x82,0x81,0x8F,0x12,0x81,0xED,0x44,0xA0, 0xBF,0xF9}},
 /*P0064*/ {{0x40,0xD3,0xC2,0x78,0x1F,0x49,0xFF,0xCF,0xA6,0xD5, 0x3C,0xBF}},
 /*P0128*/ {{0x41,0xA8,0x93,0xBA,0x47,0xC9,0x80,0xE9,0x8C,0xE0, 0xC6,0x6F}},
 /*P0192*/ {{0x42,0x7C,0xE0,0x70,0xF7,0x8D,0x39,0x27,0x55,0x6B, 0x85,0xBC}},
 /*P0256*/ {{0x43,0x51,0xAA,0x7E,0xEB,0xFB,0x9D,0xF9,0xDE,0x8E, 0xDD,0xBC}},
 /*P0320*/ {{0x44,0x26,0x81,0x84,0x2F,0x29,0xF2,0xCC,0xE3,0x76, 0xE6,0xA1}},
 /*P0384*/ {{0x44,0xFA,0xC4,0xC5,0xE3,0x10,0xAE,0xF8,0xAA,0x17, 0x10,0x28}},
 /*P0448*/ {{0x45,0xCF,0x95,0x7A,0x4A,0xE1,0xEB,0xF7,0xF3,0xD4, 0xA7,0xEB}},
 /*P0512*/ {{0x46,0xA3,0xE3,0x19,0xA0,0xAE,0xA6,0x0E,0x91,0xC7, 0xCC,0x65}},
 /*P1024*/ {{0x4D,0x48,0xC9,0x76,0x75,0x86,0x81,0x75,0x0C,0x17, 0x65,0x0D}},
 /*P1536*/ {{0x53,0xED,0xB2,0xB8,0x35,0x3B,0x39,0x93,0xA7,0xE4, 0x42,0x58}},
 /*P2048*/ {{0x5A,0x92,0x9E,0x8B,0x3B,0x5D,0xC5,0x3D,0x5D,0xE5, 0xA7,0x4D}},
 /*P2560*/ {{0x61,0x37,0x8C,0xA5,0x54,0xC0,0x20,0xA1,0xF0,0xA6, 0x5D,0xFF}},
 /*P3072*/ {{0x67,0xDB,0xF9,0x89,0x5D,0x25,0xD8,0x8B,0x5A,0x8B, 0xFD,0xD1}},
 /*P3584*/ {{0x6E,0x80,0xDD,0x5D,0xC8,0xA2,0xBF,0x27,0xF3,0xF8, 0x95,0xAA}},
 /*P4096*/ {{0x75,0x25,0xC4,0x60,0x52,0x02,0x8A,0x20,0x97,0x9B, 0xC9,0x4C}}
};

_LDBL12 _pow10neg[] = {
 /*N0001*/ {{0x3F,0xFB,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCD, 0xCC,0xCD}},
 /*N0002*/ {{0x3F,0xF8,0xA3,0xD7,0x0A,0x3D,0x70,0xA3,0xD7,0x0A, 0x3D,0x71}},
 /*N0003*/ {{0x3F,0xF5,0x83,0x12,0x6E,0x97,0x8D,0x4F,0xDF,0x3B, 0x64,0x5A}},
 /*N0004*/ {{0x3F,0xF1,0xD1,0xB7,0x17,0x58,0xE2,0x19,0x65,0x2C, 0xD3,0xC3}},
 /*N0005*/ {{0x3F,0xEE,0xA7,0xC5,0xAC,0x47,0x1B,0x47,0x84,0x23, 0x0F,0xD0}},
 /*N0006*/ {{0x3F,0xEB,0x86,0x37,0xBD,0x05,0xAF,0x6C,0x69,0xB6, 0xA6,0x40}},
 /*N0007*/ {{0x3F,0xE7,0xD6,0xBF,0x94,0xD5,0xE5,0x7A,0x42,0xBC, 0x3D,0x33}},
 /*N0008*/ {{0x3F,0xE4,0xAB,0xCC,0x77,0x11,0x84,0x61,0xCE,0xFD, 0xFD,0xC2}},
 /*N0016*/ {{0x3F,0xC9,0xE6,0x95,0x94,0xBE,0xC4,0x4D,0xE1,0x5B, 0x4C,0x2F}},
 /*N0024*/ {{0x3F,0xAF,0x9A,0xBE,0x14,0xCD,0x44,0x75,0x3B,0x53, 0xC4,0x92}},
 /*N0032*/ {{0x3F,0x94,0xCF,0xB1,0x1E,0xAD,0x45,0x39,0x94,0xBA, 0x67,0xDE}},
 /*N0040*/ {{0x3F,0x7A,0x8B,0x61,0x31,0x3B,0xBA,0xBC,0xE2,0xC6, 0x23,0x24}},
 /*N0048*/ {{0x3F,0x5F,0xBB,0x12,0x7C,0x53,0xB1,0x7E,0xC1,0x59, 0x55,0x61}},
 /*N0056*/ {{0x3F,0x44,0xFB,0x15,0x85,0x92,0xBE,0x06,0x8D,0x2F, 0xEE,0xD7}},
 /*N0064*/ {{0x3F,0x2A,0xA8,0x7F,0xEA,0x27,0xA5,0x39,0xE9,0xA5, 0x3F,0x24}},
 /*N0128*/ {{0x3E,0x55,0xDD,0xD0,0x46,0x7C,0x64,0xBC,0xE4,0xA1, 0xAC,0x7D}},
 /*N0192*/ {{0x3D,0x81,0x91,0xFF,0x83,0x77,0x54,0x23,0xCC,0x06, 0x7B,0x63}},
 /*N0256*/ {{0x3C,0xAC,0xC0,0x31,0x43,0x25,0x63,0x7A,0x19,0x3A, 0xFA,0x91}},
 /*N0320*/ {{0x3B,0xD7,0xFD,0x00,0xB8,0x97,0x47,0x82,0x38,0xD1, 0x89,0x21}},
 /*N0384*/ {{0x3B,0x03,0xA6,0x86,0xE3,0xE8,0xB1,0x1B,0x08,0x58, 0x88,0xDC}},
 /*N0448*/ {{0x3A,0x2E,0xDB,0x37,0x75,0x99,0xB6,0x07,0x42,0x45, 0x84,0xC6}},
 /*N0512*/ {{0x39,0x5A,0x90,0x49,0xEE,0x32,0xDB,0x23,0xD2,0x1C, 0x71,0x33}},
 /*N1024*/ {{0x32,0xB5,0xA2,0xA6,0x82,0xA5,0xDA,0x57,0xC0,0xBE, 0x87,0xA6}},
 /*N1536*/ {{0x2C,0x10,0xB7,0x59,0x44,0x9F,0x52,0xA7,0x11,0xB2, 0x68,0xE2}},
 /*N2048*/ {{0x25,0x6B,0xCE,0xAE,0x53,0x4F,0x34,0x36,0x2D,0xE4, 0x49,0x25}},
 /*N2560*/ {{0x1E,0xC6,0xE8,0xFB,0x7D,0xC2,0xDE,0xC0,0xA4,0x04, 0x59,0x8F}},
 /*N3072*/ {{0x18,0x22,0x83,0x50,0xBF,0x3C,0x91,0x57,0x5A,0x88, 0xE7,0x9E}},
 /*N3584*/ {{0x11,0x7D,0x94,0x06,0xAF,0x8F,0x83,0xFD,0x62,0x65, 0x4B,0x4E}},
 /*N4096*/ {{0x0A,0xD8,0xA6,0xDD,0x04,0xC8,0xD2,0xCE,0x9F,0xDE, 0x2D,0xE4}}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\fp32.inc ===
####
#fp32.def - definitions for the fp32 libs build
#
#       Copyright (c) 1991-1994, Microsoft Corporation. All rights reserved.
#
#Purpose:
#       This file is included in the 'sources' files in this tree
#
#       Key to FP32 environment variables:
#
#       CRTLIBDEBUG = debug flag (define for debug libs)
#       CRTLIBTYPE = [dll/mt/st], dll = dynlink
#                                 mt = multithread,
#                                 st = singlethread
#
#Revision History:
#        9-26-91  GDP
#        2-07-92  GDP   DLL support (according to crt32.def)
#        3-04-92  GDP   Enabled 386 optimizations
#       05-22-93  SRW   Compile runtines with no debug info except globals.
#       06-03-93  SRW   Okay to allow FPO now, as crt32\startup\mlock.c has
#                       been fixed to explicitly disable FPO for itself.
#       10-18-93  SRW   Disable intrinsics on Alpha
#       11-19-93  GJF   Merged in NT SDK version.
#       01-04-94  GJF   Picked up MIPS_OPTIMIZATION from NT SDK version
#       01-11-94  GJF   Variant of fp32.def for NT SDK build.
#       09-06-94  CFW   Remove MTHREAD and _INTL definitions.
#
################################################################################

NTLEGO=1
LINKER_FLAGS=-ignore:4006
LIBRARIAN_FLAGS=-ignore:4006
MSC_WARNING_LEVEL=/W3 /WX

!if $(FREEBUILD)
DEBUG_CDEFINE = -DNDEBUG
!else
DEBUG_CDEFINE = -D_DEBUG
!endif

386_STDCALL=0
TARGETTYPE=LIBRARY
TARGETPATH=obj
INCLUDES=$(INCLUDES)

!if "$(CRTLIBTYPE)" == "MT"
TARGETNAMESUFFIX=mt
MTOPTION=-D_MT -D_BUILD_FOR_MT
C_DEFINES1=$(DEBUG_CDEFINE)
ASM_DEFINES1=
!elseif "$(CRTLIBTYPE)" == "ST"
TARGETNAMESUFFIX=
MTOPTION=
C_DEFINES1=$(DEBUG_CDEFINE)
ASM_DEFINES1=
!elseif "$(CRTLIBTYPE)" == "NT"
TARGETNAMESUFFIX=nt
MTOPTION=
C_DEFINES1=-D_NTSUBSET_=1 -D_NTSYSTEM_=1
ASM_DEFINES1=-D_NTSUBSET_=1 -D_NTSYSTEM_=1
!else
!ERROR Unsupported Library CRTLIBTYPE: $(CRTLIBTYPE)
!ENDIF

C_DEFINES1=$(C_DEFINES1) -DNT_BUILD -D_CRTBLD -D_XBOX
ASM_DEFINES1=$(C_DEFINES1) -DNT_BUILD -D_WIN32=1 -D_XBOX

C_DEFINES  =$(MTOPTION) $(C_DEFINES1)
ASM_DEFINES=$(MTOPTION) -DI386 -DFLAT386 $(ASM_DEFINES1)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\cfout.c ===
/***
*cfout.c - Encode interface for C
*
*	Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*	07-20-91  GDP	Ported to C from assembly
*	04-30-92  GDP	Added _dtold routine (moved here from ldtod.c)
*	05-14-92  GDP	NDIGITS is now 17 (instead of 16)
*	06-18-92  GDP	Use double instead of DOUBLE to remove C8 warning
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	09-06-94  CFW	Replace MTHREAD with _MT.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/


#include <string.h>
#include <cv.h>

#define NDIGITS 17

void __dtold(_LDOUBLE *pld, double *px);


#ifndef _MT
static struct _strflt ret;
static FOS fos;
#endif

#ifdef _MT
STRFLT __cdecl _fltout2(DOUBLE x, STRFLT flt, char *resultstr)
{
    _LDOUBLE ld;
    FOS autofos;

    __dtold(&ld, (double *)&x);
    flt->flag =  $I10_OUTPUT(ld,NDIGITS,0,&autofos);
    flt->sign = autofos.sign;
    flt->decpt = autofos.exp;
    strcpy(resultstr,autofos.man);
    flt->mantissa = resultstr;

    return flt;
}

#else

STRFLT __cdecl _fltout(DOUBLE x)
{
    _LDOUBLE ld;

    __dtold(&ld, (double *)&x);
    ret.flag = $I10_OUTPUT(ld,NDIGITS,0,&fos);
    ret.sign = fos.sign;
    ret.decpt = fos.exp;
    ret.mantissa = fos.man;

    return &ret;
}

#endif




/***
* __dtold -	convert a double into a _LDOUBLE
*
*Purpose:  Use together with i10_output() to get string conversion
*   for double
*
*Entry: double *px
*
*Exit: the corresponding _LDOUBLE value is returned in *pld
*
*Exceptions:
*
*******************************************************************************/

void __dtold(_LDOUBLE *pld, double *px)
{
    u_short exp;
    u_short sign;
    u_long manhi, manlo;
    u_long msb = MSB_ULONG;
    u_short ldexp = 0;

    exp = (*U_SHORT4_D(px) & (u_short)0x7ff0) >> 4;
    sign = *U_SHORT4_D(px) & (u_short)0x8000;
    manhi = *UL_HI_D(px) & 0xfffff;
    manlo = *UL_LO_D(px);

    switch (exp) {
    case D_MAXEXP:
	ldexp = LD_MAXEXP;
	break;
    case 0:
	/* check for zero */
	if (manhi == 0 && manlo == 0) {
	    *UL_MANHI_LD(pld) = 0;
	    *UL_MANLO_LD(pld) = 0;
	    *U_EXP_LD(pld) = 0;
	    return;
	}
	/* we have a denormal -- we'll normalize later */
	ldexp = (u_short) ((s_short)exp - D_BIAS + LD_BIAS + 1);
	msb = 0;
	break;
    default:
	exp -= D_BIAS;
	ldexp = (u_short) ((s_short)exp + LD_BIAS);
	break;
    }

    *UL_MANHI_LD(pld) = msb | manhi << 11 | manlo >> 21;
    *UL_MANLO_LD(pld) = manlo << 11;

    /* normalize if necessary */
    while ((*UL_MANHI_LD(pld) & MSB_ULONG) == 0) {
	/* shift left */
	*UL_MANHI_LD(pld) = *UL_MANHI_LD(pld) << 1 |
			    (MSB_ULONG & *UL_MANLO_LD(pld) ? 1: 0);
	(*UL_MANLO_LD(pld)) <<= 1;
	ldexp --;
    }

    *U_EXP_LD(pld) = sign | ldexp;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\cvt.c ===
/*** 
*cvt.c - C floating-point output conversions
*
*	Copyright (c) 1983-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	contains routines for performing %e, %f, and %g output conversions
*	for printf, etc.
*
*	routines include _cfltcvt(), _cftoe(), _cftof(), _cftog(),
*			 _fassign(), _positive(), _cropzeros(), _forcdecpt()
*
*Revision History:
*	04-18-84  RN	author
*	01-15-87  BCM	corrected processing of %g formats (to handle precision
*			as the maximum number of signifcant digits displayed)
*	03-24-87  BCM	Evaluation Issues: (fccvt.obj version for ?LIBFA)
*			------------------
*			SDS - no problem
*			GD/TS :
*				char g_fmt = 0; 		(local,   initialized)
*				int g_magnitude =0;		(local,   initialized)
*				char g_round_expansion = 0;	(local,   initialized)
*				STRFLT g_pflt;				(local, uninitialized)
*			other INIT :
*			ALTMATH __fpmath() initialization (perhaps)
*			TERM - nothing
*	10-22-87  BCM	changes for OS/2 Support Library -
*				    including elimination of g_... static variables
*				    in favor of stack-based variables & function arguments
*				    under MTHREAD switch;  changed interfaces to _cfto? routines
*	01-15-88  BCM	remove IBMC20 switches; use only memmove, not memcpy;
*				    use just MTHREAD switch, not SS_NEQ_DGROUP
*	06-13-88  WAJ	Fixed %.1g processing for small x
*	08-02-88  WAJ	Made changes to _fassign() for new input().
*	03-09-89  WAJ	Added some long double support.
*	06-05-89  WAJ	Made changes for C6. LDOUBLE => long double
*	06-12-89  WAJ	Renamed this file from cvtn.c to cvt.c
*	11-02-89  WAJ	Removed register.h
*	06-28-90  WAJ	Removed fars.
*	11-15-90  WAJ	Added _cdecl where needed. Also "pascal" => "_pascal".
*	09-12-91  GDP	_cdecl=>_CALLTYPE2 _pascal=>_CALLTYPE5 near=>_NEAR
*	04-30-92  GDP	Removed floating point code. Instead used S/W routines
*			(_atodbl, _atoflt _atoldbl), so that to avoid
*			generation of IEEE exceptions from the lib code.
*	03-11-93  JWM	Added minimal support for _INTL decimal point - one byte only!
*	04-06-93  SKS	Replace _CALLTYPE* with __cdecl
*	07-16-93  SRW	ALPHA Merge
*	11-15-93  GJF	Merged in NT SDK version ("ALPHA merge" stuff). Also,
*			dropped support of Alpha acc compier, replaced i386
*			with _M_IX86, replaced MTHREAD with _MT.
*	09-06-94  CFW	Remove _INTL switch.
*	09-05-00  GB    Changed the defination of fltout functions. Use DOUBLE 
*	                instead of double
*
*******************************************************************************/

#include <ctype.h>
#include <string.h>
#include <math.h>
#include <cv.h>
#include <nlsint.h>

#ifdef	_M_IX86
/* Uncomment this for enabling 10-byte long double string conversions */
/* #define LONG_DOUBLE */
#endif


/* this routine resides in the crt32 tree */
extern void _fptostr(char *buf, int digits, STRFLT pflt);


static void _CALLTYPE5 _shift( char *s, int dist );

#ifdef	_MT
    static char * _cftoe2( char * buf, int ndec, int caps, STRFLT pflt, char g_fmt );
    static char * _cftof2( char * buf, int ndec, STRFLT pflt, char g_fmt );

#else	/* not _MT */
    static char * _cftoe_g( double * pvalue, char * buf, int ndec, int caps );
    static char * _cftof_g( double * pvalue, char * buf, int ndec );
#endif	/* not _MT */

/*** 
*_forcdecpt(buffer) - force a decimal point in floating-point output
*Purpose:
*  	force a decimal point in floating point output. we are only called if '#'
*  	flag is given and precision is 0; so we know the number has no '.'. insert
*  	the '.' and move everybody else back one position, until '\0' seen
*
* 	side effects: futzes around with the buffer, trying to insert a '.' 
*	after the initial string of digits. the first char can usually be 
*   skipped since it will be a digit or a '-'.  but in the 0-precision case, 
* 	the number could start with 'e' or 'E', so we'd want the '.' before the 
*	exponent in that case.
*
*Entry:
*	buffer = (char *) pointer to buffer to modify
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _forcdecpt( char * buffer )
{
char	holdchar;
char	nextchar;

    if (tolower(*buffer) != 'e'){
	do {
	    buffer++;
	    }
	while (isdigit(*buffer));
	}

    holdchar = *buffer;
    
	*buffer++ = *__decimal_point;

    do	{
	nextchar = *buffer;
	*buffer = holdchar;
	holdchar = nextchar;
	}

    while(*buffer++);
}


/*** 
*_cropzeros(buffer) - removes trailing zeros from floating-point output
*Purpose:
*	removes trailing zeros (after the '.') from floating-point output;
*	called only when we're doing %g format, there's no '#' flag, and 
*	precision is non-zero.  plays around with the buffer, looking for
*	trailing zeros.  when we find them, then we move everbody else forward
*	so they overlay the zeros.  if we eliminate the entire fraction part,
*	then we overlay the decimal point ('.'), too.	
*
* 	side effects: changes the buffer from
*   	[-] digit [digit...] [ . [digits...] [0...] ] [(exponent part)]
*	to
*		[-] digit [digit...] [ . digit [digits...] ] [(exponent part)]
*	or
*   	[-] digit [digit...] [(exponent part)]
*
*Entry:
*	buffer = (char *) pointer to buffer to modify
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

void __cdecl _cropzeros( char * buf )
{
char	*stop;

    while (*buf && *buf != *__decimal_point)
	buf++;

    if (*buf++) {
	while (*buf && *buf != 'e' && *buf != 'E')
	    buf++;

	stop = buf--;

	while (*buf == '0')
	    buf--;

	if (*buf == *__decimal_point)
	    buf--;

	while( (*++buf = *stop++) != '\0' );
	}
}


int __cdecl _positive( double * arg )
{
    return( (*arg >= 0.0) );
}


void  __cdecl _fassign( int flag, char * argument, char * number )
{

    FLOAT floattemp;
    DOUBLE doubletemp;

#ifdef	LONG_DOUBLE

    _LDOUBLE longtemp;

    switch( flag ){
	case 2:
	    _atoldbl( &longtemp, number );
	    *(_LDOUBLE UNALIGNED *)argument = longtemp;
	    break;

	case 1:
	    _atodbl( &doubletemp, number );
	    *(DOUBLE UNALIGNED *)argument = doubletemp;
	    break;

	default:
	    _atoflt( &floattemp, number );
	    *(FLOAT UNALIGNED *)argument = floattemp;
	}

#else	/* not LONG_DOUBLE */

    if (flag) {
	_atodbl( &doubletemp, number );
	*(DOUBLE UNALIGNED *)argument = doubletemp;
    } else {
	_atoflt( &floattemp, number );
	*(FLOAT UNALIGNED *)argument = floattemp;
    }

#endif	/* not LONG_DOUBLE */
}


#ifndef _MT
    static char   g_fmt = 0;
    static int	  g_magnitude = 0;
    static char   g_round_expansion = 0;
    static STRFLT g_pflt;
#endif


/*
 *  Function name:  _cftoe
 *
 *  Arguments:	    pvalue -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *		    caps   -  int
 *
 *  Description:    _cftoe converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %e format, nad returns a pointer to the result.
 *		    This format has the form [-]d.ddde(+/-)ddd, where there
 *		    will be ndec digits following the decimal point.  If
 *		    ndec <= 0, no decimal point will appear.  The low order
 *		    digit is rounded.  If caps is nonzero then the exponent
 *		    will appear as E(+/-)ddd.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT
    static char * _cftoe2( char * buf, int ndec, int caps, STRFLT pflt, char g_fmt )
#else
    char * __cdecl _cftoe( double * pvalue, char * buf, int ndec, int caps )
#endif
{
#ifndef _MT
    STRFLT pflt;
    DOUBLE *pdvalue = (DOUBLE *)pvalue;
#endif

char	*p;
int	exp;

    /* first convert the value */

    /* place the output in the buffer and round.  Leave space in the buffer
     * for the '-' sign (if any) and the decimal point (if any)
     */

    if (g_fmt) {
#ifndef _MT
	pflt = g_pflt;
#endif
	/* shift it right one place if nec. for decimal point */

	p = buf + (pflt->sign == '-');
	_shift(p, (ndec > 0));
		}
#ifndef _MT
    else {
	pflt = _fltout(*pdvalue);
	_fptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
	}
#endif


    /* now fix the number up to be in e format */

    p = buf;

    /* put in negative sign if needed */

    if (pflt->sign == '-')
	*p++ = '-';

    /* put in decimal point if needed.	Copy the first digit to the place
     * left for it and put the decimal point in its place
     */

    if (ndec > 0) {
	*p = *(p+1);
	*(++p) = *__decimal_point;
	}

    /* find the end of the string and attach the exponent field */

    p = strcpy(p+ndec+(!g_fmt), "e+000");

    /* adjust exponent indicator according to caps flag and increment
     * pointer to point to exponent sign
     */

    if (caps)
	*p = 'E';

    p++;

    /* if mantissa is zero, then the number is 0 and we are done; otherwise
     * adjust the exponent sign (if necessary) and value.
     */

    if (*pflt->mantissa != '0') {

	/* check to see if exponent is negative; if so adjust exponent sign and
	 * exponent value.
	 */

	if( (exp = pflt->decpt - 1) < 0 ) {
	    exp = -exp;
	    *p = '-';
	    }

	p++;

	if (exp >= 100) {
	    *p += (char)(exp / 100);
	    exp %= 100;
	    }
	p++;

	if (exp >= 10) {
	    *p += (char)(exp / 10);
	    exp %= 10;
	    }

	*++p += (char)exp;
	}

    return(buf);
}


#ifdef _MT

char * __cdecl _cftoe( double * pvalue, char * buf, int ndec, int caps )
{
struct _strflt retstrflt;
char  resstr[21];
DOUBLE *pdvalue = (DOUBLE *)pvalue;
STRFLT pflt = &retstrflt;

    _fltout2(*pdvalue, (struct _strflt *)&retstrflt,
	      (char *)resstr);
    _fptostr(buf + (pflt->sign == '-') + (ndec > 0), ndec + 1, pflt);
    _cftoe2(buf, ndec, caps, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else	/* not _MT */

static char * _cftoe_g( double * pvalue, char * buf, int ndec, int caps )
{
    char *res;
    g_fmt = 1;
    res = _cftoe(pvalue, buf, ndec, caps);
    g_fmt = 0;
    return (res);
}

#endif	/* not _MT */


#ifdef _MT
static char * _cftof2( char * buf, int ndec, STRFLT pflt, char g_fmt )

#else
char * __cdecl _cftof( double * pvalue, char * buf, int ndec )
#endif

{
#ifndef _MT
STRFLT pflt;
DOUBLE *pdvalue = (DOUBLE *)pvalue;
#endif

char	*p;

#ifdef _MT
int	g_magnitude = pflt->decpt - 1;
#endif


    /* first convert the value */

    /* place the output in the users buffer and round.	Save space for
     * the minus sign now if it will be needed
     */

    if (g_fmt) {
#ifndef _MT
	pflt = g_pflt;
#endif

	p = buf + (pflt->sign == '-');
	if (g_magnitude == ndec) {
	    char *q = p + g_magnitude;
	    *q++ = '0';
	    *q = '\0';
	    /* allows for extra place-holding '0' in the exponent == precision
	     * case of the g format
	     */
	    }
	}
#ifndef _MT
    else {
	pflt = _fltout(*pdvalue);
	_fptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
	}
#endif


    /* now fix up the number to be in the correct f format */

    p = buf;

    /* put in negative sign, if necessary */

    if (pflt->sign == '-')
	*p++ = '-';

    /* insert leading 0 for purely fractional values and position ourselves
     * at the correct spot for inserting the decimal point
     */

    if (pflt->decpt <= 0) {
	_shift(p, 1);
	*p++ = '0';
	}
    else
	p += pflt->decpt;

	/* put in decimal point if required and any zero padding needed */

    if (ndec > 0) {
	_shift(p, 1);
	*p++ = *__decimal_point;

	/* if the value is less than 1 then we may need to put 0's out in
	 * front of the first non-zero digit of the mantissa
	 */

	if (pflt->decpt < 0) {
	    if( g_fmt )
		ndec = -pflt->decpt;
	    else
		ndec = (ndec < -pflt->decpt ) ? ndec : -pflt->decpt;
	    _shift(p, ndec);
	    memset( p, '0', ndec);
	    }
	}

    return( buf);
}


/*
 *  Function name:  _cftof
 *
 *  Arguments:	    value  -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *
 *  Description:    _cftof converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %f format, and returns a pointer to the result.
 *		    This format has the form [-]ddddd.ddddd, where there will
 *		    be ndec digits following the decimal point.  If ndec <= 0,
 *		    no decimal point will appear.  The low order digit is
 *		    rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

#ifdef _MT

char * __cdecl _cftof( double * pvalue, char * buf, int ndec )
{
    struct _strflt retstrflt;
    char  resstr[21];
    DOUBLE *pdvalue = (DOUBLE *)pvalue;
    STRFLT pflt = &retstrflt;
    _fltout2(*pdvalue, (struct _strflt *) &retstrflt,
				      (char *) resstr);
    _fptostr(buf+(pflt->sign == '-'), ndec + pflt->decpt, pflt);
    _cftof2(buf, ndec, pflt, /* g_fmt = */ 0);

    return( buf );
}

#else	/* not _MT */


static char * _cftof_g( double * pvalue, char * buf, int ndec )
{
    char *res;
    g_fmt = 1;
    res = _cftof(pvalue, buf, ndec);
    g_fmt = 0;
    return (res);
}

#endif	/* not _MT */

/*
 *  Function name:  _cftog
 *
 *  Arguments:	    value  -  double * pointer
 *		    buf    -  char * pointer
 *		    ndec   -  int
 *
 *  Description:    _cftog converts the double pointed to by pvalue to a null
 *		    terminated string of ASCII digits in the c language
 *		    printf %g format, and returns a pointer to the result.
 *		    The form used depends on the value converted.  The printf
 *		    %e form will be used if the magnitude of valude is less
 *		    than -4 or is greater than ndec, otherwise printf %f will
 *		    be used.  ndec always specifies the number of digits
 *		    following the decimal point.  The low order digit is
 *		    appropriately rounded.
 *
 *  Side Effects:   the buffer 'buf' is assumed to have a minimum length
 *		    of CVTBUFSIZE (defined in cvt.h) and the routines will
 *		    not write over this size.
 *
 *  Author:	    written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *
 */

char * __cdecl _cftog( double * pvalue, char * buf, int ndec, int caps )
{
char *p;
DOUBLE *pdvalue = (DOUBLE *)pvalue;

#ifdef _MT
char g_round_expansion = 0;
STRFLT g_pflt;
int g_magnitude;
struct _strflt retstrflt;
char  resstr[21];

    /* first convert the number */

    g_pflt = &retstrflt;
    _fltout2(*pdvalue, (struct _strflt *)&retstrflt,
		  (char *)resstr);

#else	/* not _MT */

    /* first convert the number */

    g_pflt = _fltout(*pdvalue);
#endif	/* not _MT */

    g_magnitude = g_pflt->decpt - 1;
    p = buf + (g_pflt->sign == '-');

    _fptostr(p, ndec, g_pflt);
    g_round_expansion = (char)(g_magnitude < (g_pflt->decpt-1));


    /* compute the magnitude of value */

    g_magnitude = g_pflt->decpt - 1;

    /* convert value to the c language g format */

    if (g_magnitude < -4 || g_magnitude >= ndec){     /* use e format */
	/*  (g_round_expansion ==>
	 *  extra digit will be overwritten by 'e+xxx')
	 */

#ifdef _MT
	return(_cftoe2(buf, ndec, caps, g_pflt, /* g_fmt = */ 1));
#else
	return(_cftoe_g(pvalue, buf, ndec, caps));
#endif

	}
    else {										     /* use f format */
	if (g_round_expansion) {
	    /* throw away extra final digit from expansion */
	    while (*p++);
	    *(p-2) = '\0';
	    }

#ifdef _MT
	return(_cftof2(buf, ndec, g_pflt, /* g_fmt = */ 1));
#else
	return(_cftof_g(pvalue, buf, ndec));
#endif

	}
}

/*** 
*_cfltcvt(arg, buf, format, precision, caps) - convert floating-point output
*Purpose:
*
*Entry:
*	arg = (double *) pointer to double-precision floating-point number 
*	buf = (char *) pointer to buffer into which to put the converted
*				   ASCII form of the number
*	format = (int) 'e', 'f', or 'g'
*	precision = (int) giving number of decimal places for %e and %f formats,
*					  and giving maximum number of significant digits for
*					  %g format
*	caps = (int) flag indicating whether 'E' in exponent should be capatilized
*				 (for %E and %G formats only)
*	
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/
/*
 *  Function name:  _cfltcvt
 *
 *  Arguments:	    arg    -  double * pointer
 *		    buf    -  char * pointer
 *					format -  int
 *		    ndec   -  int
 *		    caps   -  int
 *
 *  Description:    _cfltcvt determines from the format, what routines to
 *		    call to generate the correct floating point format
 *
 *  Side Effects:   none
 *
 *	Author: 	   Dave Weil, Jan 12, 1985
 */

void __cdecl _cfltcvt( double * arg, char * buffer, int format, int precision, int caps )
{
    if (format == 'e' || format == 'E')
	_cftoe(arg, buffer, precision, caps);
    else if (format == 'f')
	_cftof(arg, buffer, precision);
    else
	_cftog(arg, buffer, precision, caps);
}

/*** 
*_shift(s, dist) - shift a null-terminated string in memory (internal routine)
*Purpose:
*	_shift is a helper routine that shifts a null-terminated string 
*	in memory, e.g., moves part of a buffer used for floating-point output
*
*	modifies memory locations (s+dist) through (s+dist+strlen(s))
*
*Entry:
*	s = (char *) pointer to string to move
*	dist = (int) distance to move the string to the right (if negative, to left)
*
*Exit:
*	returns : (void)
*
*Exceptions:
*******************************************************************************/

static void _CALLTYPE5 _shift( char *s, int dist )
{
    if( dist )
	memmove(s+dist, s, strlen(s)+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\mantold.c ===
/***
*mantold.c - conversion of a decimal mantissa to _LDBL12
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Conversion of a decimal mantissa into _LDBL12 format (i.e. long
*   double with two additional bytes of significand)
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*
*******************************************************************************/

#include <cv.h>





/***
*int _CALLTYPE5 __addl(u_long x, u_long y, u_long *sum) - u_long addition
*
*Purpose: add two u_long numbers and return carry
*
*Entry: u_long x, u_long y : the numbers to be added
*	u_long *sum : where to store the result
*
*Exit: *sum receives the value of x+y
*      the value of the carry is returned
*
*Exceptions:
*
*******************************************************************************/

int _CALLTYPE5 __addl(u_long x, u_long y, u_long *sum)
{
    u_long r;
    int carry=0;
    r = x+y;
    if (r < x || r < y)
	carry++;
    *sum = r;
    return carry;
}






/***
*void _CALLTYPE5 __add_12(_LDBL12 *x, _LDBL12 *y) -	_LDBL12 addition
*
*Purpose: add two _LDBL12 numbers. The numbers are added
*   as 12-byte integers. Overflow is ignored.
*
*Entry: x,y: pointers to the operands
*
*Exit: *x receives the sum
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __add_12(_LDBL12 *x, _LDBL12 *y)
{
    int c0,c1,c2;
    c0 = __addl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x));
    if (c0) {
	c1 = __addl(*UL_MED_12(x),(u_long)1,UL_MED_12(x));
	if (c1) {
	    (*UL_HI_12(x))++;
	}
    }
    c2 = __addl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x));
    if (c2) {
	(*UL_HI_12(x))++;
    }
    /* ignore next carry -- assume no overflow will occur */
    (void) __addl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));
}





/***
*void _CALLTYPE5 __shl_12(_LDBL12 *x) - _LDBL12 shift left
*void _CALLTYPE5 __shr_12(_LDBL12 *x) - _LDBL12 shift right
*
*Purpose: Shift a _LDBL12 number one bit to the left (right). The number
*   is shifted as a 12-byte integer. The MSB is lost.
*
*Entry: x: a pointer to the operand
*
*Exit: *x is shifted one bit to the left (or right)
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __shl_12(_LDBL12 *p)
{
    u_long c0,c1;

    c0 = *UL_LO_12(p) & MSB_ULONG ? 1: 0;
    c1 = *UL_MED_12(p) & MSB_ULONG ? 1: 0;
    *UL_LO_12(p) <<= 1;
    *UL_MED_12(p) = *UL_MED_12(p)<<1 | c0;
    *UL_HI_12(p) = *UL_HI_12(p)<<1 | c1;
}

void _CALLTYPE5 __shr_12(_LDBL12 *p)
{
    u_long c2,c1;
    c2 = *UL_HI_12(p) & 0x1 ? MSB_ULONG: 0;
    c1 = *UL_MED_12(p) & 0x1 ? MSB_ULONG: 0;
    *UL_HI_12(p) >>= 1;
    *UL_MED_12(p) = *UL_MED_12(p)>>1 | c2;
    *UL_LO_12(p) = *UL_LO_12(p)>>1 | c1;
}






/***
*void _CALLTYPE5 __mtold12(char *manptr,unsigned manlen,_LDBL12 *ld12) -
*   convert a mantissa into a _LDBL12
*
*Purpose: convert a mantissa into a _LDBL12. The mantissa is
*   in the form of an array of manlen BCD digits and is
*   considered to be an integer.
*
*Entry: manptr: the array containing the packed BCD digits of the mantissa
*	manlen: the size of the array
*	ld12: a pointer to the long double where the result will be stored
*
*Exit:
*	ld12 gets the result of the conversion
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __mtold12(char *manptr,
			 unsigned manlen,
			 _LDBL12 *ld12)
{
    _LDBL12 tmp;
    u_short expn = LD_BIASM1+80;

    *UL_LO_12(ld12) = 0;
    *UL_MED_12(ld12) = 0;
    *UL_HI_12(ld12) = 0;
    for (;manlen>0;manlen--,manptr++){
	tmp = *ld12;
	__shl_12(ld12);
	__shl_12(ld12);
	__add_12(ld12,&tmp);
	__shl_12(ld12);	       /* multiply by 10 */
	*UL_LO_12(&tmp) = (u_long)*manptr;
	*UL_MED_12(&tmp) = 0;
	*UL_HI_12(&tmp) = 0;
	__add_12(ld12,&tmp);
    }

    /* normalize mantissa -- first shift word by word */
    while (*UL_HI_12(ld12) == 0) {
	*UL_HI_12(ld12) = *UL_MED_12(ld12) >> 16;
	*UL_MED_12(ld12) = *UL_MED_12(ld12) << 16 | *UL_LO_12(ld12) >> 16;
	(*UL_LO_12(ld12)) <<= 16;
	expn -= 16;
    }
    while ((*UL_HI_12(ld12) & 0x8000) == 0) {
	__shl_12(ld12);
	expn--;
    }
    *U_EXP_12(ld12) = expn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\fpinit.c ===
/***
*fpinit.c - Initialize floating point
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*Revision History:
*       09-29-91  GDP   merged fpmath.c and fltused.asm to produce this file
*       09-30-91  GDP   per thread initialization and termination hooks
*       03-04-92  GDP   removed finit instruction
*       11-06-92  GDP   added __fastflag for FORTRAN libs
*       03-23-93  JWM   added _setdefaultprecision() to _fpmath()
*       12-09-94  JWM   added __adjust_fdiv for Pentium FDIV detection
*       12-12-94  SKS   _adjust_fdiv must be exported in MSVCRT.LIB model
*       02-06-95  JWM   Mac merge
*       04-04-95  JWM   Clear exceptions after FDIV detection (x86 only).
*       11-15-95  BWT   Assume P5 FDIV problem will be handled in the OS.
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/
#include <cv.h>

#ifdef  _M_IX86
#include <testfdiv.h>
#endif

#if     defined(_M_IA64)
#include <trans.h>
#endif

int _fltused = 0x9875;
int _ldused = 0x9873;

int __fastflag = 0;


void  _cfltcvt_init(void);
void  _fpmath(void);
void  _fpclear(void);

#if     defined(_M_IX86) || defined(_M_IA64)

#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else
#define _CRTIMP
#endif

_CRTIMP int _adjust_fdiv = 0;

extern void _setdefaultprecision();
#endif

void  (* _FPinit)(void) = _fpmath;
void  (* _FPmtinit)(void) = _fpclear;
void  (* _FPmtterm)(void) = _fpclear;


void _fpmath()
{

    //
    // There is no need for 'finit'
    // since this is done by the OS
    //

    _cfltcvt_init();

#ifdef  _M_IX86
#ifndef NT_BUILD
    _adjust_fdiv = _ms_p5_mp_test_fdiv();
#endif
    _setdefaultprecision();
    _asm {
        fnclex
    }
#elif   defined(_M_IA64)
/*  _setdefaultprecision(); */
    _clrfp();
#endif

    return;
}

void _fpclear()
{
    //
    // There is no need for 'finit'
    // since this is done by the OS
    //

    return;
}

void _cfltcvt_init()
{
    _cfltcvt_tab[0] = (PFV) _cfltcvt;
    _cfltcvt_tab[1] = (PFV) _cropzeros;
    _cfltcvt_tab[2] = (PFV) _fassign;
    _cfltcvt_tab[3] = (PFV) _forcdecpt;
    _cfltcvt_tab[4] = (PFV) _positive;
    /* map long double to double */
    _cfltcvt_tab[5] = (PFV) _cfltcvt;

}


/*
 * Routine to set the fast flag in order to speed up computation
 * of transcendentals at the expense of limiting error checking
 */

int __setfflag(int new)
{
    int old = __fastflag;
    __fastflag = new;
    return old;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\sources.inc ===
!INCLUDE ..\..\fp32.inc

MAJORCOMP=fp
MINORCOMP=conv

TARGETNAME=conv

INCLUDES=..\..\include;..\..\..\crtw32\h

SOURCES=\
        ..\cfin.c      \
        ..\cfout.c     \
        ..\constpow.c  \
        ..\cvt.c       \
        ..\fpinit.c    \
        ..\intrncvt.c  \
        ..\mantold.c   \
        ..\strgtold.c  \
        ..\tenpow.c    \
        ..\x10fout.c   \
        ..\fltinf.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\tenpow.c ===
/***
*tenpow.c - multiply a _LDBL12 by a power of 10
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       07-17-91  GDP   Initial version (ported from assembly)
*       11-15-93  GJF   Merged in NT SDK verions. Replaced MIPS and _ALPHA_
*                       by _M_MRX000 and _M_ALPHA (resp.).
*       10-02-94  BWT   PPC changes
*       07-15-96  GJF   Added parantheses to fix precedence problem in expr.
*                       Also, detab-ed.
*       05-05-99  RDL   Added _M_IA64 to #if def's for alignment.
*
*******************************************************************************/


#include <cv.h>

extern _LDBL12 _pow10pos[];
extern _LDBL12 _pow10neg[];




/***
*void _CALLTYPE5 __ld12mul(_LDBL12 *px, _LDBL12 *py) -
*   _LDBL12 multiplication
*
*Purpose: multiply two _LDBL12 numbers
*
*Entry: px,py: pointers to the _LDBL12 operands
*
*Exit: *px contains the product
*
*Exceptions:
*
*******************************************************************************/

void _CALLTYPE5 __ld12mul(_LDBL12 *px, _LDBL12 *py)
{
    u_short sign = 0;
    _LDBL12 tempman; /*this is actually a 12-byte mantissa,
                         not a 12-byte long double */
    int i;
    u_short expx, expy, expsum;
    int roffs,poffs,qoffs;
    int sticky = 0;

    *UL_LO_12(&tempman) = 0;
    *UL_MED_12(&tempman) = 0;
    *UL_HI_12(&tempman) = 0;

    expx = *U_EXP_12(px);
    expy = *U_EXP_12(py);

    sign = (expx ^ expy) & (u_short)0x8000;
    expx &= 0x7fff;
    expy &= 0x7fff;
    expsum = expx+expy;
    if (expx >= LD_MAXEXP
        || expy >= LD_MAXEXP
        || expsum > LD_MAXEXP+ LD_BIASM1){
        /* overflow to infinity */
        PUT_INF_12(px,sign);
        return;
    }
    if (expsum <= LD_BIASM1-63) {
        /* underflow to zero */
        PUT_ZERO_12(px);
        return;
    }
    if (expx == 0) {
        /*
         * If this is a denormal temp real then the mantissa
         * was shifted right once to set bit 63 to zero.
         */
        expsum++; /* Correct for this */
        if (ISZERO_12(px)) {
            /* put positive sign */
            *U_EXP_12(px) = 0;
            return;
        }
    }
    if (expy == 0) {
        expsum++; /* because arg2 is denormal */
        if (ISZERO_12(py)) {
            PUT_ZERO_12(px);
            return;
        }
    }

    roffs = 0;
    for (i=0;i<5;i++) {
        int j;
        poffs = i<<1;
        qoffs = 8;
        for (j=5-i;j>0;j--) {
	    u_long prod;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
            /* a variable to hold temprary sums */
            u_long sum;
#endif
            int carry;
            u_short *p, *q;
            u_long *r;
            p = USHORT_12(px,poffs);
            q = USHORT_12(py,qoffs);
            r = ULONG_12(&tempman,roffs);
            prod = (u_long)*p * (u_long)*q;
#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
            /* handle misalignment problems */
            if (i&0x1){ /* i is odd */
                carry = __addl(*ALIGN(r), prod, &sum);
                *ALIGN(r) =  sum;
            }
            else /* i is even */
                carry = __addl(*r, prod, r);
#else
            carry = __addl(*r,prod,r);
#endif
            if (carry) {
                /* roffs should be less than 8 in this case */
                (*USHORT_12(&tempman,roffs+4))++;
            }
            poffs+=2;
            qoffs-=2;
        }
        roffs+=2;
    }

    expsum -= LD_BIASM1;

    /* normalize */
    while ((s_short)expsum > 0 &&
           ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {
         __shl_12(&tempman);
         expsum--;
    }

    if ((s_short)expsum <= 0) {
        expsum--;
        while ((s_short)expsum < 0) {
            if (*U_XT_12(&tempman) & 0x1)
                sticky++;
            __shr_12(&tempman);
            expsum++;
        }
        if (sticky)
            *U_XT_12(&tempman) |= 0x1;
    }

    if (*U_XT_12(&tempman) > 0x8000 ||
         ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {
        /* round up */
        if (*UL_MANLO_12(&tempman) == MAX_ULONG) {
            *UL_MANLO_12(&tempman) = 0;
            if (*UL_MANHI_12(&tempman) == MAX_ULONG) {
                *UL_MANHI_12(&tempman) = 0;
                if (*U_EXP_12(&tempman) == MAX_USHORT) {
                    /* 12-byte mantissa overflow */
                    *U_EXP_12(&tempman) = MSB_USHORT;
                    expsum++;
                }
                else
                    (*U_EXP_12(&tempman))++;
            }
            else
                (*UL_MANHI_12(&tempman))++;
        }
        else
            (*UL_MANLO_12(&tempman))++;
    }


    /* check for exponent overflow */
    if (expsum >= 0x7fff){
        PUT_INF_12(px, sign);
        return;
    }

    /* put result in px */
    *U_XT_12(px) = *USHORT_12(&tempman,2);
    *UL_MANLO_12(px) = *UL_MED_12(&tempman);
    *UL_MANHI_12(px) = *UL_HI_12(&tempman);
    *U_EXP_12(px) = expsum | sign;
}



void _CALLTYPE5
__multtenpow12(_LDBL12 *pld12, int pow, unsigned mult12)
{
    _LDBL12 *pow_10p = _pow10pos-8;
    if (pow == 0)
        return;
    if (pow < 0) {
        pow = -pow;
        pow_10p = _pow10neg-8;
    }

    if (!mult12)
        *U_XT_12(pld12) = 0;


    while (pow) {
        int last3; /* the 3 LSBits of pow */
        _LDBL12 unround;
        _LDBL12 *py;

        pow_10p += 7;
        last3 = pow & 0x7;
        pow >>= 3;
        if (last3 == 0)
            continue;
        py = pow_10p + last3;

#ifdef _LDSUPPORT
        if (mult12) {
#endif
            /* do an exact 12byte multiplication */
            if (*U_XT_12(py) >= 0x8000) {
                /* copy number */
                unround = *py;
                /* unround adjacent byte */
                (*UL_MANLO_12(&unround))--;
                /* point to new operand */
                py = &unround;
            }
            __ld12mul(pld12,py);
#ifdef _LDSUPPORT
        }
        else {
            /* do a 10byte multiplication */
            py = (_LDBL12 *)TEN_BYTE_PART(py);
            *(long double *)TEN_BYTE_PART(pld12) *=
                *(long double *)py;
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\strgtold.c ===
/***
*strgtold.c - conversion of a string into a long double
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose: convert a fp constant into a 10 byte long double (IEEE format)
*
*Revision History:
*	07-17-91  GDP	Initial version (ported from assembly)
*	04-03-92  GDP	Preserve sign of -0
*	04-30-92  GDP	Now returns _LDBL12 instead of _LDOUBLE
*	06-17-92  GDP	Added __strgtold entry point again (68k code uses it)
*	06-22-92  GDP	Use scale, decpt and implicit_E for FORTRAN support
*	11-06-92  GDP	Made char-to-int conversions usnigned for 'isdigit'
*	03-11-93  JWM	Added minimal support for _INTL decimal point - one byte only!
*	07-01-93  GJF	Made buf[] a local array, rather than static array of
*			local scope (static is evil in multi-thread!).
*	09-15-93  SKS	Change _decimal_point to __decimal_point for CFW.
*	09-06-94  CFW	Remove _INTL switch.
*
*******************************************************************************/

#include <ctype.h>  /* for 'isdigit' macro */
#include <cv.h>
#include <nlsint.h>

/* local macros */
#define ISNZDIGIT(x) ((x)>='1' && (x)<='9' )
#define ISWHITE(x) ((x)==' ' || (x)=='\t' || (x)=='\n' || (x)=='\r' )


/****
*unsigned int __strgtold12( _LDBL12 *pld12,
*			  char * * pEndPtr,
*			  char * str,
*			  int Mult12,
*			  int scale,
*			  int decpt,
*			  int implicit_E)
*
*Purpose:
*   converts a character string into a 12byte long double (_LDBL12)
*   This has the same format as a 10byte long double plus two extra
*   bytes for the mantissa
*
*Entry:
*   pld12   - pointer to the _LDBL12 where the result should go.
*   pEndStr - pointer to a far pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _LDBL12 multiply should be used instead of
*		the long double mulitiply.
*   scale   - FORTRAN scale factor (0 for C)
*   decpt   - FORTRAN decimal point factor (0 for C)
*   implicit_E - if true, E, e, D, d can be implied (FORTRAN syntax)
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int
__strgtold12(_LDBL12 *pld12,
	    const char * *p_end_ptr,
	    const char * str,
	    int mult12,
	    int scale,
	    int decpt,
	    int implicit_E)
{
    typedef enum {
	S_INIT,  /* initial state */
	S_EAT0L, /* eat 0's at the left of mantissa */
	S_SIGNM, /* just read sign of mantissa */
	S_GETL,  /* get integer part of mantissa */
	S_GETR,  /* get decimal part of mantissa */
	S_POINT, /* just found decimal point */
	S_E,	 /* just found	'E', or 'e', etc  */
	S_SIGNE, /* just read sign of exponent */
	S_EAT0E, /* eat 0's at the left of exponent */
	S_GETE,  /* get exponent */
	S_END,	 /* final state */
	S_E_IMPLICIT  /* check for implicit exponent */
    } state_t;

    /* this will accomodate the digits of the mantissa in BCD form*/
    char buf[LD_MAX_MAN_LEN1];
    char *manp = buf;

    /* a temporary _LDBL12 */
    _LDBL12 tmpld12;

    u_short man_sign = 0; /* to be ORed with result */
    int exp_sign = 1; /* default sign of exponent (values: +1 or -1)*/
    /* number of decimal significant mantissa digits so far*/
    unsigned manlen = 0;
    int found_digit = 0;
    int found_decpoint = 0;
    int found_exponent = 0;
    int overflow = 0;
    int underflow = 0;
    int pow = 0;
    int exp_adj = 0;  /* exponent adjustment */
    u_long ul0,ul1;
    u_short u,uexp;

    unsigned int result_flags = 0;

    state_t state = S_INIT;

    char c;  /* the current input symbol */
    const char *p; /* a pointer to the next input symbol */
    const char *savedp;

    for(savedp=p=str;ISWHITE(*p);p++); /* eat up white space */

    while (state != S_END) {
	c = *p++;
	switch (state) {
	case S_INIT:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_POINT;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '+':
		    state = S_SIGNM;
		    man_sign = 0x0000;
		    break;
		case '-':
		    state = S_SIGNM;
		    man_sign = 0x8000;
		    break;
		default:
		    state = S_END;
		    p--;
		    break;
		}
	    break;
	case S_EAT0L:
	    found_digit = 1;
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_GETR;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case 'E':
		case 'e':
		case 'D':
		case 'd':
		    state = S_E;
		    break;
		case '+':
		case '-':
		    p--;
		    state = S_E_IMPLICIT;
		    break;
		default:
		    state = S_END;
		    p--;
		}
	    break;
	case S_SIGNM:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
		else if (c == *__decimal_point)
	    	state = S_POINT;
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETL:
	    found_digit = 1;
	    for (;isdigit((int)(unsigned char)c);c=*p++) {
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		}
		else
		   exp_adj++;
	    }
		if (c == *__decimal_point)
	    	state = S_GETR;
	    else
	    switch (c) {
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    case '+':
	    case '-':
		p--;
		state = S_E_IMPLICIT;
		break;
	    default:
		state = S_END;
		p--;
	    }
	break;
	case S_GETR:
	    found_digit = 1;
	    found_decpoint = 1;
	    if (manlen == 0)
		for (;c=='0';c=*p++)
		    exp_adj--;
	    for(;isdigit((int)(unsigned char)c);c=*p++){
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		    exp_adj--;
		}
	    }
	    switch (c){
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    case '+':
	    case '-':
		p--;
		state = S_E_IMPLICIT;
		break;
	    default:
		state = S_END;
		p--;
	    }
	    break;
	case S_POINT:
	    found_decpoint = 1;
	    if (isdigit((int)(unsigned char)c)){
		state = S_GETR;
		p--;
	    }
	    else{
		state = S_END;
		p = savedp;
	    }
	    break;
	case S_E:
	    savedp = p-2; /* savedp points to 'E' */
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	break;
	case S_EAT0E:
	    found_exponent = 1;
	    for(;c=='0';c=*p++);
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else {
		state = S_END;
		p--;
	    }
	    break;
	case S_SIGNE:
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETE:
	    found_exponent = 1;
	    {
		long longpow=0; /* TMAX10*10 should fit in a long */
		for(;isdigit((int)(unsigned char)c);c=*p++){
		    longpow = longpow*10 + (c - '0');
		    if (longpow > TMAX10){
			longpow = TMAX10+1; /* will force overflow */
			break;
		    }
		}
		pow = (int)longpow;
	    }
	    for(;isdigit((int)(unsigned char)c);c=*p++); /* eat up remaining digits */
	    state = S_END;
	    p--;
	    break;
	case S_E_IMPLICIT:
	    if (implicit_E) {
		savedp = p-1; /* savedp points to whatever precedes sign */
		switch (c){
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    }
	    else {
		 state = S_END;
		 p--;
	    }
	    break;
	}  /* switch */
    }  /* while */

    *p_end_ptr = p;	/* set end pointer */

    /*
     * Compute result
     */

    if (found_digit && !overflow && !underflow) {
	if (manlen>LD_MAX_MAN_LEN){
	    if (buf[LD_MAX_MAN_LEN-1]>=5) {
	       /*
		* Round mantissa to MAX_MAN_LEN digits
		* It's ok to round 9 to 0ah
		*/
		buf[LD_MAX_MAN_LEN-1]++;
	    }
	    manlen = LD_MAX_MAN_LEN;
	    manp--;
	    exp_adj++;
	}
	if (manlen>0) {
	   /*
	    * Remove trailing zero's from mantissa
	    */
	    for(manp--;*manp==0;manp--) {
		/* there is at least one non-zero digit */
		manlen--;
		exp_adj++;
	    }
	    __mtold12(buf,manlen,&tmpld12);

	    if (exp_sign < 0)
		pow = -pow;
	    pow += exp_adj;

	    /* new code for FORTRAN support */
	    if (!found_exponent) {
		pow += scale;
	    }
	    if (!found_decpoint) {
		pow -= decpt;
	    }


	    if (pow > TMAX10)
		overflow = 1;
	    else if (pow < TMIN10)
		underflow = 1;
	    else {
		__multtenpow12(&tmpld12,pow,mult12);

		u = *U_XT_12(&tmpld12);
		ul0 =*UL_MANLO_12(&tmpld12);
		ul1 = *UL_MANHI_12(&tmpld12);
		uexp = *U_EXP_12(&tmpld12);

	    }
	}
	else {
	    /* manlen == 0, so	return 0 */
	    u = (u_short)0;
	    ul0 = ul1 = uexp = 0;
	}
    }

    if (!found_digit) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_NODIGITS;
    }
    else if (overflow) {
	/* return +inf or -inf */
	uexp = (u_short)0x7fff;
	ul1 = 0x80000000;
	ul0 = 0;
	u = (u_short)0;
	result_flags |= SLD_OVERFLOW;
    }
    else if (underflow) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_UNDERFLOW;
    }

    /*
     * Assemble	result
     */

    *U_XT_12(pld12) = u;
    *UL_MANLO_12(pld12) = ul0;
    *UL_MANHI_12(pld12) = ul1;
    *U_EXP_12(pld12) = uexp | man_sign;

    return result_flags;
}



/****
*unsigned int _CALLTYPE5 __stringtold( LDOUBLE	*pLd,
*				   char * * pEndPtr,
*				   char * str,
*				   int	      Mult12 )
*
*Purpose:
*   converts a character string into a long double
*
*Entry:
*   pLD     - pointer to the long double where the result should go.
*   pEndStr - pointer to a pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _LDBL12 multiply should be used instead of
*		the long double mulitiply.
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int _CALLTYPE5
__STRINGTOLD(_LDOUBLE *pld,
	    const char * *p_end_ptr,
	    const char *str,
	    int mult12)
{
    unsigned int retflags;
    INTRNCVT_STATUS intrncvt;
    _LDBL12 ld12;

    retflags = __strgtold12(&ld12, p_end_ptr, str, mult12, 0, 0, 0);

    intrncvt = _ld12told(&ld12, pld);

    if (intrncvt == INTRNCVT_OVERFLOW) {
	    retflags |= SLD_OVERFLOW;
    }

    return retflags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\cmacros.inc ===
comment $
SCCSID = "@(#)cmacros.mas:1.9"
cmacros - assembly macros for interfacing to hhls
Copyright (C) 1984-2001 Microsoft Corporation. All rights reserved.
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
%out e r r o r ----- msg
.err e r r o r ----- msg
endm
.xcref ??error2
??error2 macro msg
if2
%out e r r o r ----- msg
.err e r r o r ----- msg
endif
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized,memS32,sizeI,wordI
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
ifdef ?SMALL32
memS32=1
endif
??_out <cMacros Version 3.06f - 05/12/89>
??_out <Copyright (C) 1984-2001 Microsoft Corporation. All rights reserved.>
outif memS,0,<Small Model>
outif memM,0,<Medium model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
outif memS32,0,<32 Bit Small Model>
memMOD= memS + memM + memL + memC + memH + memS32
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small model>
else
??error <must have only 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
if memS32
sizeI = 4
wordI equ <dword>
asmdI equ <dd>
else
sizeI = 2
wordI equ <word>
asmdI equ <dw>
endif
outif ?DF,0,<No segments or groups will be defined>
outif ?DFDATA,0,<No data segments will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
outif ?COW,0,<Characters Windows support>
outif ?PLM,1,<PL/M calling convention>
outif ?NOATOMIC,0,<ATOMIC disabled>
outif ?NODATA,0,<NODATA module>
outif ?FORCEFRAME,0,<Forced BP stack frame.>
outif ?RETFLAGS,0,<Epilog preserves flags.>
ife ?NODATA
?nodata1=0
else
?nodata1=1
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
ifndef ?NO_BP
?no_bp1=0
else
?no_bp1=1
??_out <! NO_BP is default>
endif
else
ASMpass=2
endif
if memS32
.386
IAX equ <eax>
ICX equ <ecx>
IDX equ <edx>
IBX equ <ebx>
ISP equ <esp>
IBP equ <ebp>
ISI equ <esi>
IDI equ <edi>
IPUSHF equ pushfd
IPOPF equ popfd
IPUSHA equ pushad
IPOPA equ popad
IIRET equ iretd
else
IAX equ <ax>
ICX equ <cx>
IDX equ <dx>
IBX equ <bx>
ISP equ <sp>
IBP equ <bp>
ISI equ <si>
IDI equ <di>
IPUSHF equ pushf
IPOPF equ popf
IIRET equ iret
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?n,?AX,?AH,?AL,?BX,?BH
.xcref ?BL,?CX,?CH,?CL,?DX,?DH
.xcref ?DL,?SI,?DI,?ES,?DS,?BP
.xcref ?SP,?SS,?CS
.xcref ?EAX,?EBX,?ECX,?EDX,?ESI,?EDI,?ESP,?EBP
.xcref ?eax,?ebx,?ecx,?edx,?esi,?edi,?esp,?ebp
.xcref ?IAX,?IBX,?ICX,?IDX,?ISI,?IDI,?ISP,?IBP
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc,?no_bp1,?no_bp2
.xcref ?cbe,?pcbe
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = ?FORCEFRAME
?dd2 = 0
?cCall1 = 0
?pcc = ?PLM
?PLMPrevParm = 0
?no_bp2 = ?no_bp1
?cbe = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
?AX = 0000000000000011b
?AH = 0000000000000001b
?AL = 0000000000000010b
?BX = 0000000000001100b
?BH = 0000000000000100b
?BL = 0000000000001000b
?CX = 0000000000110000b
?CH = 0000000000010000b
?CL = 0000000000100000b
?DX = 0000000011000000b
?DH = 0000000001000000b
?DL = 0000000010000000b
?SI = 0000000100000000b
?DI = 0000001000000000b
?ES = 0000010000000000b
?DS = 0000100000000000b
?BP = 0001000000000000b
?SP = 0010000000000000b
?SS = 0100000000000000b
?CS = 1000000000000000b
?EAX = 0000000000000011b
?EBX = 0000000000001100b
?ECX = 0000000000110000b
?EDX = 0000000011000000b
?ESI = 0000000100000000b
?EDI = 0000001000000000b
?EBP = 0001000000000000b
?ESP = 0010000000000000b
?eax = 0000000000000011b
?ebx = 0000000000001100b
?ecx = 0000000000110000b
?edx = 0000000011000000b
?esi = 0000000100000000b
?edi = 0000001000000000b
?ebp = 0001000000000000b
?esp = 0010000000000000b
?IAX = 0000000000000011b
?IBX = 0000000000001100b
?ICX = 0000000000110000b
?IDX = 0000000011000000b
?ISI = 0000000100000000b
?IDI = 0000001000000000b
?IBP = 0001000000000000b
?ISP = 0010000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<IAX,IBX,ICX,IDX,ISI,IDI,es,ds,IBP,ISP,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,ISP,IBP,ds,es,IDI,ISI,IDX,ICX,IBX,IAX>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
else
??error2 <unknown register x>
.err
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH,parmI
.cref
parmB macro n
?pp <n>,<byte>,sizeI,1
endm
parmW macro n
?pp <n>,<word>,sizeI,2
endm
parmI macro n
?pp <n>,wordI,sizeI,sizeI
endm
parmD macro n
ife ?pcc
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmH macro n
?pp <n>,<word>,4,2
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmI <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?pcc
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error2 <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?pcc
if ?no_bp2
n equ (t ptr [+b])
else
n equ (t ptr [IBP][+b])
endif
else
.xcref
.xcref ?PLMParm&cpc
.cref
if ?no_bp2
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
else
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [IBP][+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
if ?no_bp2
n equ (dword ptr [-o-2])
else
n equ (dword ptr [bp][-o-2])
endif
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error2 <invalid parmR encountered: &n,&r>
exitm
endif
if ?no_bp2
n equ (word ptr [-o])
else
n equ (word ptr [bp][-o])
endif
.xcref ?t&n
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
if ?no_bp2
n equ (byte ptr [-o])
else
n equ (byte ptr [bp][-o])
endif
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV,localI
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localI macro n
?aloc <n>,&wordI&< ptr>,sizeI,sizeI,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localI <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
if memS32 and l GT 2
???=((??? + 3) and 0fffffffch)
else
???=((??? + 1) and 0fffeh)
endif
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error2 <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
if ?no_bp2
n equ (t [-o])
else
n equ (t [IBP][-o])
endif
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP,globalI
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalI macro n,i,s,c
?ad <n>,2
?dd n,1,wordI,%asmdI,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ word ptr n[0]
seg_&n equ word ptr n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalI n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP,staticI
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticI macro n,i,s
?ad <n>,sizeI
?dd n,0,wordI,%asmdI,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticI n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticI n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externI,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externI macro n,c
?ex1 <n>,sizeI,<wordI>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap <n>
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=2*sizeI
?rp=0
?uf=0
?wfp=?WIN
?ff=?FORCEFRAME
?pas=0
?pcc=?PLM
?no_bp2=?no_bp1
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifdef ??_cproc_&&x
??_cproc_&&x
else
??error2 <e r r o r - unknown keyword x>
.err
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error2 <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
ife ?COW
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
endif
?adj=?adj+sizeI
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error2 <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error2 <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc,<nnu>,%???
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
?cbe = 0
ifnb <g>
?pcbe <g>,<nnu>,<cBegin>
endif
if ?cbe eq 1
if ???+a+?rp
if2
??_out <cBegin - nogen>
endif
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
ife ?cbe
if w
ife ?nd
	mov	IAX,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	IBP
endif
	push	IBP
	mov	IBP,ISP
ife ?COW
	push	ds
endif
else
if ?ff+???+?po+?rp
	push	IBP
	mov	IBP,ISP
endif
endif
ife ?nd
	mov	ds,IAX
endif
else
if ?ff+???+?po+?rp
	push	IBP
	mov	IBP,ISP
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	IAX,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	ISP,???
endif
endif
else
if ?rp
??error2 <cBegin - parmRs encountered with partial frame>
else
if ???
	lea	ISP,[IBP][-???-?ia]
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error2 <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc,nnu,lc
.xcref
.xcref cEnd
parm_bytes_&nnu = o
cEnd &macro g
.xcref
?ba=0
?cbe = 0
ifnb <g>
?pcbe <g>,<nnu>,<cEnd>
endif
if ?cbe eq 1
if a+r+lc
if2
??_out <cEnd - nogen>
endif
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
ife ?COW
if (?TF eq 0) or (???+r)
	lea	sp,-2[bp]
endif
	pop	ds
else
if (?TF eq 0) or (???+r)
mov sp,bp
endif
endif
	pop	IBP
ife ?DOS5
if ?RETFLAGS
lea IBP,[IBP-1]
else
	dec	IBP
endif
endif
else
if memS32
leave
else
if (?TF eq 0) or (???+r)
	mov	ISP,IBP
endif
if ???+?po+r
	pop	IBP
endif
endif
endif
else
if ?ff+???+?po+r
if (?TF eq 0) or (???+r)
	mov	ISP,IBP
endif
	pop	IBP
endif
endif
if ?cbe ne 4
ife cc
	ret
else
	ret	o
endif
endif
endif
endif
if ?cbe ne 4
n endp
.cref
purge cEnd
else
.cref
endif
&endm
.cref
endm
.xcref
.xcref cleanframe
cleanframe macro
cEnd <??cleanframe??>
endm
.cref
.xcref
.xcref ??_cproc_FAR,??_cproc_NEAR,??_cproc_PUBLIC,??_cproc_SMALL
.xcref ??_cproc_DATA,??_cproc_NODATA,??_cproc_ATOMIC,??_cproc_C
.xcref ??_cproc_PLM,??_cproc_PASCAL,??_cproc_WIN,??_cproc_NONWIN
.xcref ??_cproc_NO_BP,??_cproc_BP
.xcref ??_cproc_far,??_cproc_near,??_cproc_public,??_cproc_small
.xcref ??_cproc_data,??_cproc_nodata,??_cproc_atomic,??_cproc_c
.xcref ??_cproc_plm,??_cproc_pascal,??_cproc_win,??_cproc_nonwin
.xcref ??_cproc_no_bp,??_cproc_bp
.cref
??_cproc_FAR macro
?pc=1
endm
??_cproc_NEAR macro
?pc=0
endm
??_cproc_PUBLIC macro
?pu=1
endm
??_cproc_SMALL macro
?uf=1
endm
??_cproc_DATA macro
?nd=0
endm
??_cproc_NODATA macro
?nd=1
endm
??_cproc_ATOMIC macro
?nx=1
endm
??_cproc_C macro
?pcc=0
endm
??_cproc_PLM macro
?pcc=1
endm
??_cproc_PASCAL macro
?pcc=1
endm
??_cproc_WIN macro
?wfp=1
endm
??_cproc_NONWIN macro
?wfp=0
endm
??_cproc_NO_BP macro
?no_bp2=1
endm
??_cproc_BP macro
?no_bp2=0
endm
??_cproc_far macro
?pc=1
endm
??_cproc_near macro
?pc=0
endm
??_cproc_public macro
?pu=1
endm
??_cproc_small macro
?uf=1
endm
??_cproc_data macro
?nd=0
endm
??_cproc_nodata macro
?nd=1
endm
??_cproc_atomic macro
?nx=1
endm
??_cproc_c macro
?pcc=0
endm
??_cproc_plm macro
?pcc=1
endm
??_cproc_pascal macro
?pcc=1
endm
??_cproc_win macro
?wfp=1
endm
??_cproc_nonwin macro
?wfp=0
endm
??_cproc_no_bp macro
?no_bp2=1
endm
??_cproc_bp macro
?no_bp2=0
endm
??_cproc_FORCEFRAME macro
?ff=1
endm
?pcbe macro g,nnu,mt
ifidn <g>,<NOGEN>
?cbe = 1
else
ifidn <g>,<nogen>
?cbe = 1
else
ifidn <mt>,<cBegin>
ifidn <g>,<PARTIAL>
?cbe = 2
else
ifidn <g>,<partial>
?cbe = 2
else
ifdif <g>,<nnu>
??error2 <mt - unknown keyword g>
endif
endif
endif
else
ifidn <g>,<??cleanframe??>
?cbe = 4
else
ifdif <g>,<nnu>
??error2 <mt - unknown keyword g>
endif
endif
endif
endif
endif
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,CODE,%wordI,public,CODE
ife ?nodata1
createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
defgrp DGROUP,DATA
else
ife ?DFDATA
createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
defgrp DGROUP,DATA
endif
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\x10fout.c ===
/***
*x10fout.c - floating point output for 10-byte long double
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Support conversion of a long double into a string
*
*Revision History:
*   07/15/91	GDP	Initial version in C (ported from assembly)
*   01/23/92	GDP	Support MIPS encoding for NaN
*
*******************************************************************************/

#include <string.h>
#include <cv.h>

#define STRCPY strcpy

#define PUT_ZERO_FOS(fos)	 \
		fos->exp = 0,	 \
		fos->sign = ' ', \
		fos->ManLen = 1, \
		fos->man[0] = '0',\
		fos->man[1] = 0;

#define SNAN_STR      "1#SNAN"
#define SNAN_STR_LEN  6
#define QNAN_STR      "1#QNAN"
#define QNAN_STR_LEN  6
#define INF_STR	      "1#INF"
#define INF_STR_LEN   5
#define IND_STR	      "1#IND"
#define IND_STR_LEN   5


/***
*int _CALLTYPE5
* _$i10_output(_LDOUBLE ld,
*	    int ndigits,
*	    unsigned output_flags,
*	    FOS *fos) - output conversion of a 10-byte _LDOUBLE
*
*Purpose:
*   Fill in a FOS structure for a given _LDOUBLE
*
*Entry:
*   _LDOUBLE ld:  The long double to be converted into a string
*   int ndigits: number of digits allowed in the output format.
*   unsigned output_flags: The following flags can be used:
*	SO_FFORMAT: Indicates 'f' format
*	(default is 'e' format)
*   FOS *fos: the structure that i10_output will fill in
*
*Exit:
*   modifies *fos
*   return 1 if original number was ok, 0 otherwise (infinity, NaN, etc)
*
*Exceptions:
*
*******************************************************************************/


int _CALLTYPE5 $I10_OUTPUT(_LDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS *fos)
{
    u_short expn;
    u_long manhi,manlo;
    u_short sign;

    /* useful constants (see algorithm explanation below) */
    u_short const log2hi = 0x4d10;
    u_short const log2lo = 0x4d;
    u_short const log4hi = 0x9a;
    u_long const c = 0x134312f4;
#if defined(L_END)
    _LDBL12 ld12_one_tenth = {
	   {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}
    };
#elif defined(B_END)
    _LDBL12 ld12_one_tenth = {
	   {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
    };
#endif

    _LDBL12 ld12; /* space for a 12-byte long double */
    _LDBL12 tmp12;
    u_short hh,ll; /* the bytes of the exponent grouped in 2 words*/
    u_short mm; /* the two MSBytes of the mantissa */
    s_long r; /* the corresponding power of 10 */
    s_short ir; /* ir = floor(r) */
    int retval = 1; /* assume valid number */
    char round; /* an additional character at the end of the string */
    char *p;
    int i;
    int ub_exp;
    int digcount;

    /* grab the components of the long double */
    expn = *U_EXP_LD(&ld);
    manhi = *UL_MANHI_LD(&ld);
    manlo = *UL_MANLO_LD(&ld);
    sign = expn & MSB_USHORT;
    expn &= 0x7fff;

    if (sign)
	fos->sign = '-';
    else
	fos->sign = ' ';

    if (expn==0 && manhi==0 && manlo==0) {
	PUT_ZERO_FOS(fos);
	return 1;
    }

    if (expn == 0x7fff) {
	fos->exp = 1; /* set a positive exponent for proper output */

	/* check for special cases */
	if (_IS_MAN_SNAN(sign, manhi, manlo)) {
	    /* signaling NAN */
	    STRCPY(fos->man,SNAN_STR);
	    fos->ManLen = SNAN_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_IND(sign, manhi, manlo)) {
	    /* indefinite */
	    STRCPY(fos->man,IND_STR);
	    fos->ManLen = IND_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_INF(sign, manhi, manlo)) {
	    /* infinity */
	    STRCPY(fos->man,INF_STR);
	    fos->ManLen = INF_STR_LEN;
	    retval = 0;
	}
	else {
	    /* quiet NAN */
	    STRCPY(fos->man,QNAN_STR);
	    fos->ManLen = QNAN_STR_LEN;
	    retval = 0;
	}
    }
    else {
       /*
	*    Algorithm for the decoding of a valid real number x
	*
	* In the  following  INT(r)  is	the largest integer less than or
	* equal to r (i.e. r rounded toward -infinity).	We want a result
	* r equal  to  1  + log(x), because then x = mantissa
	* * 10^(INT(r)) so that	.1  <=	mantissa  <  1.   Unfortunately,
	* we cannot  compute  s	exactly  so  we must alter the procedure
	* slightly.  We will  instead  compute	an  estimate  r	of  1  +
	* log(x) which	is  always  low.   This	will either result
	* in the correctly normalized number on	the  top  of  the  stack
	* or perhaps  a	number	which  is  a factor of 10 too large.  We
	* will then check to see that if  x  is	larger	 than  one
	* and if so multiply x by 1/10.
	*
	* We will  use	a  low	precision  (fixed  point 24 bit) estimate
	* of of 1 + log base 10 of x.  We  have	approximately  .mm
	* * 2^hhll  on	the  top of the stack where m, h, and l represent
	* hex digits,  mm  represents  the  high  2  hex  digits  of  the
	* mantissa, hh	represents the high 2 hex digits of the exponent,
	* and ll represents the low 2 hex digits of the exponent.   Since
	* .mm is  a  truncated	representation	of the mantissa, using it
	* in this  monotonically  increasing   polynomial   approximation
	* of the  logarithm  will  naturally  give  a  low result.  Let's
	* derive a formula for a lower	bound  r  on  1	+  log(x):
	*
	*      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
	*	  .9A20H < log(4)=.60205999...(base 10) < .9A21H
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) >= .mm * log(4) - log(4)
	*
	* Substituting in  truncated  hex  constants in the formula above
	* gives r = 1 + .4D104DH * hhll.  + .9AH *  .mm	-  .9A21H.   Now
	* multiplication of  hex  digits  5  and 6 of log(2) by ll has an
	* insignificant effect on the first 24	bits  of  the  result  so
	* it will  not	be  calculated.	 This  gives  the expression r =
	* 1 + .4D10H * hhll.  +	.4DH  *  .hh  +  .9A  *  .mm  -  .9A21H.
	* Finally we  must  add	terms to our formula to subtract out the
	* effect of the exponent bias.	We obtain the following	formula:
	*
	*			(implied decimal point)
	*   <				  >.<				   >
	*   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
	*   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
	* + <		  1		  >
	* + <			    .4D10H * hhll.			   >
	* +				    <	    .00004DH * hh00.	   >
	* +				    <	       .9AH * .mm	   >
	* -				    <		 .9A21H 	   >
	* - <			    .4D10H * 3FFEH			   >
	* -				    <	    .00004DH * 3F00H	   >
	*
	*  ==>	r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
	*
	* The difference  between  the	lower bound r and the upper bound
	* s is calculated as follows:
	*
	*  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
	*
	* so tenatively	s  =  r  +  log(4)  - [1/ln(10) - log(1/ln(4))],
	* but we must also add in terms to ensure we will have	an  upper
	* bound even  after  the  truncation  of various values.  Because
	* log(2) * hh00.  is truncated	to  .4D104DH  *	hh00.	we  must
	* add .0043H,  because	log(2)	*  ll.	is truncated to .4D10H *
	* ll.  we  must	add  .0005H,  because  <mantissa>  *  log(4)  is
	* truncated to .mm * .9AH we must add .009AH and .0021H.
	*
	* Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
	*	= r + .07A6H
	*  ==>	s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
	*
	* r is	equal  to  1  +	log(x) more than (10000H - 7A6H) /
	* 10000H = 97% of the time.
	*
	* In the above formula, a u_long is use to accomodate r, and
	* there is an implied decimal point in the middle.
	*/

	hh = expn >> 8;
	ll = expn & (u_short)0xff;
	mm = (u_short) (manhi >> 24);
	r = (s_long)log2hi*(s_long)expn + log2lo*hh + log4hi*mm - c;
	ir = (s_short)(r >> 16);

       /*
	*
	* We stated that we wanted to normalize x so that
	*
	*  .1 <= x < 1
	*
	* This was	a  slight  oversimplification.	 Actually  we  want a
	* number which when rounded to 16 significant digits  is  in  the
	* desired range.   To  do  this we must normalize x so that
	*
	*  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
	*
	* and then round.
	*
	* If we  had f = INT(1+log(x)) we could multiply by 10^(-f)
	* to get x into the desired range.	We do  not  quite  have
	* f but  we  do  have  INT(r)  from  the last step which is equal
	* to f 97% of the time and 1 less than f the rest  of  the	time.
	* We can  multiply	by  10^-[INT(r)] and if the result is greater
	* than 1 - 5*10^(-17) we can then multiply by 1/10.   This	final
	* result will lie in the proper range.
	*/

	/* convert _LDOUBLE to _LDBL12) */
	*U_EXP_12(&ld12) = expn;
	*UL_MANHI_12(&ld12) = manhi;
	*UL_MANLO_12(&ld12) = manlo;
	*U_XT_12(&ld12) = 0;

	/* multiply by 10^(-ir) */
	__multtenpow12(&ld12,-ir,1);

	/* if ld12 >= 1.0 then divide by 10.0 */
	if (*U_EXP_12(&ld12) >= 0x3fff) {
	    ir++;
	    __ld12mul(&ld12,&ld12_one_tenth);
	}

	fos->exp = ir;
	if (output_flags & SO_FFORMAT){
	    /* 'f' format, add exponent to ndigits */
	    ndigits += ir;
	    if (ndigits <= 0) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	if (ndigits > MAX_MAN_DIGITS)
	    ndigits = MAX_MAN_DIGITS;

	ub_exp = *U_EXP_12(&ld12) - 0x3ffe; /* unbias exponent */
	*U_EXP_12(&ld12) = 0;

	/*
	 * Now the mantissa has to be converted to fixed point.
	 * Then we will use the MSB of ld12 for generating
	 * the decimal digits. The next 11 bytes will hold
	 * the mantissa (after it has been converted to
	 * fixed point).
	 */

	for (i=0;i<8;i++)
	    __shl_12(&ld12); /* make space for an extra byte,
			      in case we shift right later */
	if (ub_exp < 0) {
	    int shift_count = (-ub_exp) & 0xff;
	    for (;shift_count>0;shift_count--)
		__shr_12(&ld12);
	}

	p = fos->man;
	for(digcount=ndigits+1;digcount>0;digcount--) {
	    tmp12 = ld12;
	    __shl_12(&ld12);
	    __shl_12(&ld12);
	    __add_12(&ld12,&tmp12);
	    __shl_12(&ld12);	/* ld12 *= 10 */

	    /* Now we have the first decimal digit in the msbyte of exponent */
	    *p++ = (char) (*UCHAR_12(&ld12,11) + '0');
	    *UCHAR_12(&ld12,11) = 0;
	}

	round = *(--p);
	p--; /* p points now to the last character of the string
		   excluding the rounding digit */
	if (round >= '5') {
	    /* look for a non-9 digit starting from the end of string */
	    for (;p>=fos->man && *p=='9';p--) {
		*p = '0';
	    }
	    if (p < fos->man){
		p++;
		fos->exp ++;
	    }
	    (*p)++;
	}
	else {
	    /* remove zeros */
	    for (;p>=fos->man && *p=='0';p--);
	    if (p < fos->man) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	fos->ManLen = (char) (p - fos->man + 1);
	fos->man[fos->ManLen] = '\0';
    }
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\conv\intrncvt.c ===
/***
* intrncvt.c - internal floating point conversions
*
*	Copyright (c) 1992-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   All fp string conversion routines use the same core conversion code
*   that converts strings into an internal long double representation
*   with an 80-bit mantissa field. The mantissa is represented
*   as an array (man) of 32-bit unsigned longs, with man[0] holding
*   the high order 32 bits of the mantissa. The binary point is assumed
*   to be between the MSB and MSB-1 of man[0].
*
*   Bits are counted as follows:
*
*
*     +-- binary point
*     |
*     v 		 MSB	       LSB
*   ----------------	 ------------------	 --------------------
*   |0 1    .... 31|	 | 32 33 ...	63|	 | 64 65 ...	  95|
*   ----------------	 ------------------	 --------------------
*
*   man[0]		    man[1]		     man[2]
*
*   This file provides the final conversion routines from this internal
*   form to the single, double, or long double precision floating point
*   format.
*
*   All these functions do not handle NaNs (it is not necessary)
*
*
*Revision History:
*   04-29-92	GDP	written
*   06-18-92	GDP	now ld12told returns INTRNCVT_STATUS
*   06-22-92	GDP	use new __strgtold12 interface (FORTRAN support)
*   10-25-92	GDP	_atoldbl bug fix (cuda 1345): if the mantissa overflows
*			set its MSB to 1)
*   06-08-98	JWM	fixed long-standing off-by-1 error in _RoundMan().
*
*******************************************************************************/


#include <cv.h>


#define INTRNMAN_LEN  3	      /* internal mantissa length in int's */

//
//  internal mantissaa representation
//  for string conversion routines
//

typedef u_long *intrnman;


typedef struct {
   int max_exp;      // maximum base 2 exponent (reserved for special values)
   int min_exp;      // minimum base 2 exponent (reserved for denormals)
   int precision;    // bits of precision carried in the mantissa
   int exp_width;    // number of bits for exponent
   int format_width; // format width in bits
   int bias;	     // exponent bias
} FpFormatDescriptor;



static FpFormatDescriptor
DoubleFormat = {
    0x7ff - 0x3ff,  //	1024, maximum base 2 exponent (reserved for special values)
    0x0   - 0x3ff,  // -1023, minimum base 2 exponent (reserved for denormals)
    53, 	    // bits of precision carried in the mantissa
    11, 	    // number of bits for exponent
    64, 	    // format width in bits
    0x3ff,	    // exponent bias
};

static FpFormatDescriptor
FloatFormat = {
    0xff - 0x7f,    //	128, maximum base 2 exponent (reserved for special values)
    0x0  - 0x7f,    // -127, minimum base 2 exponent (reserved for denormals)
    24, 	    // bits of precision carried in the mantissa
    8,		    // number of bits for exponent
    32, 	    // format width in bits
    0x7f,	    // exponent bias
};



//
// function prototypes
//

int _RoundMan (intrnman man, int nbit);
int _ZeroTail (intrnman man, int nbit);
int _IncMan (intrnman man, int nbit);
void _CopyMan (intrnman dest, intrnman src);
void _CopyMan (intrnman dest, intrnman src);
void _FillZeroMan(intrnman man);
void _Shrman (intrnman man, int n);

INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format);

/***
* _ZeroTail - check if a mantissa ends in 0's
*
*Purpose:
*   Return TRUE if all mantissa bits after nbit (including nbit) are 0,
*   otherwise return FALSE
*
*
*Entry:
*   man: mantissa
*   nbit: order of bit where the tail begins
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _ZeroTail (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;


    //
    //		     |<---- tail to be checked --->
    //
    //	--  ------------------------	       ----
    //	|...	|		  |  ...	  |
    //	--  ------------------------	       ----
    //	^	^    ^
    //	|	|    |<----nb----->
    //	man	nl   nbit
    //



    u_long bitmask = ~(MAX_ULONG << nb);

    if (man[nl] & bitmask)
	return 0;

    nl++;

    for (;nl < INTRNMAN_LEN; nl++)
	if (man[nl])
	    return 0;

    return 1;
}




/***
* _IncMan - increment mantissa
*
*Purpose:
*
*
*Entry:
*   man: mantissa in internal long form
*   nbit: order of bit that specifies the end of the part to be incremented
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _IncMan (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;

    //
    //	|<--- part to be incremented -->|
    //
    //	--	       ---------------------------     ----
    //	|...		  |			|   ...	  |
    //	--	       ---------------------------     ----
    //	^		  ^		^
    //	|		  |		|<--nb-->
    //	man		  nl		nbit
    //

    u_long one = (u_long) 1 << nb;
    int carry;

    carry = __addl(man[nl], one, &man[nl]);

    nl--;

    for (; nl >= 0 && carry; nl--) {
	carry = (u_long) __addl(man[nl], (u_long) 1, &man[nl]);
    }

    return carry;
}




/***
* _RoundMan -  round mantissa
*
*Purpose:
*   round mantissa to nbit precision
*
*
*Entry:
*   man: mantissa in internal form
*   precision: number of bits to be kept after rounding
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _RoundMan (intrnman man, int precision)
{
    int i,rndbit,nl,nb;
    u_long rndmask;
    int nbit;
    int retval = 0;

    //
    // The order of the n'th bit is n-1, since the first bit is bit 0
    // therefore decrement precision to get the order of the last bit
    // to be kept
    //
    nbit = precision - 1;

    rndbit = nbit+1;

    nl = rndbit / 32;
    nb = 31 - rndbit % 32;

    //
    // Get value of round bit
    //

    rndmask = (u_long)1 << nb;

    if ((man[nl] & rndmask) &&
	 !_ZeroTail(man, rndbit)) {

	//
	// round up
	//

	retval = _IncMan(man, nbit);
    }


    //
    // fill rest of mantissa with zeroes
    //

    man[nl] &= MAX_ULONG << nb;
    for(i=nl+1; i<INTRNMAN_LEN; i++) {
	man[i] = (u_long)0;
    }

    return retval;
}


/***
* _CopyMan - copy mantissa
*
*Purpose:
*    copy src to dest
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _CopyMan (intrnman dest, intrnman src)
{
    u_long *p, *q;
    int i;

    p = src;
    q = dest;

    for (i=0; i < INTRNMAN_LEN; i++) {
	*q++ = *p++;
    }
}



/***
* _FillZeroMan - fill mantissa with zeroes
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _FillZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	man[i] = (u_long)0;
}



/***
* _IsZeroMan - check if mantissa is zero
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _IsZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	if (man[i])
	    return 0;

    return 1;
}





/***
* _ShrMan - shift mantissa to the right
*
*Purpose:
*  shift man by n bits to the right
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ShrMan (intrnman man, int n)
{
    int i, n1, n2, mask;
    int carry_from_left;

    //
    // declare this as volatile in order to work around a C8
    // optimization bug
    //

    volatile int carry_to_right;

    n1 = n / 32;
    n2 = n % 32;

    mask = ~(MAX_ULONG << n2);


    //
    // first deal with shifts by less than 32 bits
    //

    carry_from_left = 0;
    for (i=0; i<INTRNMAN_LEN; i++) {

	carry_to_right = man[i] & mask;

	man[i] >>= n2;

	man[i] |= carry_from_left;

	carry_from_left = carry_to_right << (32 - n2);
    }


    //
    // now shift whole 32-bit ints
    //

    for (i=INTRNMAN_LEN-1; i>=0; i--) {
	if (i >= n1) {
	    man[i] = man[i-n1];
	}
	else {
	    man[i] = 0;
	}
    }
}




/***
* _ld12tocvt - _LDBL12 floating point conversion
*
*Purpose:
*   convert a internal _LBL12 structure into an IEEE floating point
*   representation
*
*
*Entry:
*   pld12:  pointer to the _LDBL12
*   format: pointer to the format descriptor structure
*
*Exit:
*   *d contains the IEEE representation
*   returns the INTRNCVT_STATUS
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12cvt(_LDBL12 *pld12, void *d, FpFormatDescriptor *format)
{
    u_long man[INTRNMAN_LEN];
    u_long saved_man[INTRNMAN_LEN];
    u_long msw;
    unsigned int bexp;			// biased exponent
    int exp_shift;
    int exponent, sign;
    INTRNCVT_STATUS retval;

    exponent = (*U_EXP_12(pld12) & 0x7fff) - 0x3fff;   // unbias exponent
    sign = *U_EXP_12(pld12) & 0x8000;


    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;


    //
    // bexp is the final biased value of the exponent to be used
    // Each of the following blocks should provide appropriate
    // values for man, bexp and retval. The mantissa is also
    // shifted to the right, leaving space for the exponent
    // and sign to be inserted
    //

    if (exponent == 0 - 0x3fff) {

	// either a denormal or zero
	bexp = 0;

	if (_IsZeroMan(man)) {

	    retval = INTRNCVT_OK;
	}
	else {

	    _FillZeroMan(man);

	    // denormal has been flushed to zero

	    retval = INTRNCVT_UNDERFLOW;
	}
    }
    else {

	// save mantissa in case it needs to be rounded again
	// at a different point (e.g., if the result is a denormal)

	_CopyMan(saved_man, man);

	if (_RoundMan(man, format->precision)) {
	    exponent ++;
	}

	if (exponent < format->min_exp - format->precision ) {

	    //
	    // underflow that produces a zero
	    //

	    _FillZeroMan(man);
	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;
	}

	else if (exponent <= format->min_exp) {

	    //
	    // underflow that produces a denormal
	    //
	    //

	    // The (unbiased) exponent will be MIN_EXP
	    // Find out how much the mantissa should be shifted
	    // One shift is done implicitly by moving the
	    // binary point one bit to the left, i.e.,
	    // we treat the mantissa as .ddddd instead of d.dddd
	    // (where d is a binary digit)

	    int shift = format->min_exp - exponent;

	    // The mantissa should be rounded again, so it
	    // has to be restored

	    _CopyMan(man,saved_man);

	    _ShrMan(man, shift);
	    _RoundMan(man, format->precision); // need not check for carry

	    // make room for the exponent + sign

	    _ShrMan(man, format->exp_width + 1);

	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;

	}

	else if (exponent >= format->max_exp) {

	    //
	    // overflow, return infinity
	    //

	    _FillZeroMan(man);
	    man[0] |= (1 << 31); // set MSB

	    // make room for the exponent + sign

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    bexp = format->max_exp + format->bias;

	    retval = INTRNCVT_OVERFLOW;
	}

	else {

	    //
	    // valid, normalized result
	    //

	    bexp = exponent + format->bias;


	    // clear implied bit

	    man[0] &= (~( 1 << 31));

	    //
	    // shift right to make room for exponent + sign
	    //

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    retval = INTRNCVT_OK;

	}
    }


    exp_shift = 32 - (format->exp_width + 1);
    msw =  man[0] |
	   (bexp << exp_shift) |
	   (sign ? 1<<31 : 0);

    if (format->format_width == 64) {

	*UL_HI_D(d) = msw;
	*UL_LO_D(d) = man[1];
    }

    else if (format->format_width == 32) {

	*(u_long *)d = msw;

    }

    return retval;
}


/***
* _ld12tod - convert _LDBL12 to double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tod(_LDBL12 *pld12, DOUBLE *d)
{
    return _ld12cvt(pld12, d, &DoubleFormat);
}



/***
* _ld12tof - convert _LDBL12 to float
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tof(_LDBL12 *pld12, FLOAT *f)
{
    return _ld12cvt(pld12, f, &FloatFormat);
}


/***
* _ld12told - convert _LDBL12 to 80 bit long double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12told(_LDBL12 *pld12, _LDOUBLE *pld)
{

    //
    // This implementation is based on the fact that the _LDBL12 format is
    // identical to the long double and has 2 extra bytes of mantissa
    //

    u_short exp, sign;
    u_long man[INTRNMAN_LEN];
    INTRNCVT_STATUS retval = 0;

    exp = *U_EXP_12(pld12) & (u_short)0x7fff;
    sign = *U_EXP_12(pld12) & (u_short)0x8000;

    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;

    if (_RoundMan(man, 64)) {
	// The MSB of the mantissa is explicit and should be 1
	// since we had a carry, the mantissa is now 0.
	man[0] = MSB_ULONG;
	exp ++;
    }

    if (exp == 0x7fff)
	retval = INTRNCVT_OVERFLOW;

    *UL_MANHI_LD(pld) = man[0];
    *UL_MANLO_LD(pld) = man[1];
    *U_EXP_LD(pld) = sign | exp;

    return retval;
}


void _atodbl(DOUBLE *d, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );
    _ld12tod(&ld12, d);
}


void _atoldbl(_LDOUBLE *ld, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 1, 0, 0, 0 );
    _ld12told(&ld12, ld);
}


void _atoflt(FLOAT *f, char *str)
{
    const char *EndPtr;
    _LDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0, 0, 0, 0 );
    _ld12tof(&ld12, f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\mathver.inc ===
;***
;mathver.inc - defines current math model
;
;	Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines what math version is being built.
;
;Revision History:
;	02-21-88  WAJ	Combined all mathver.* into this file.
;	09-14-88  WAJ	Added to 386 tree
;
;*******************************************************************************



;       This file contains special version specific information -
;
;       Floating point format definition -
;
;           MBinFmt     Microsoft Binary Format
;           DecFmt      Microsoft Decimal Format
;           IEEEFmt     IEEE Binary Format
;
;       Size definition -
;
;           Single      Single Precision Format
;           Double      Double Precision Format
;
;       Language definition -
;
;           BASIC       BASIC Interpreter
;           BASCOM      BASIC Compiler
;           CC          C Compiler
;           FORTRAN     FORTRAN Compiler
;           PASCAL      PASCAL Compiler
;
;       The above switches should be defined in this include file only if
;       they are being set.  They should only be set to 1.


ifdef  MATHVERDBL

IEEEFmt=    1                               ; IEEE
Double=     1                               ; Double

FORTRAN=    1
PASCAL=     1

endif	;MATHVERDBL


ifdef  MATHVERU87

IEEEFmt=        1                               ; IEEE
Double=         1                               ; Double

FORTRAN=        1
PASCAL=         1
Denormal=       1
Use8087=        1
 
endif	;MATHVERU87


ifdef  MATHVERSNG


IEEEFmt=    1                               ; IEEE
Single=     1                               ; Single
 
FORTRAN=    1
PASCAL=     1


endif	;MATHVERSNG


ifdef  MATHVERDEC

DecFmt=     1                               ; Decimal
Double=     1                               ; Double

FORTRAN=    1
PASCAL=     1


endif	;MATHVERDEC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\memmacs.inc ===
;***
;memmacs.inc - defines macros to to handle different memory models easier.
;
;   Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines the macros that handle different memory models.
;
;Revision History:
;
;   01-23-89  WAJ   Initial version copied from cruntime.inc
;   11-01-89  WAJ   Added IWORD/ISIZE
;   11-01-89  WAJ   Added PCS
;   11-01-89  WAJ   Added short condition jmps for 386 code
;
;*******************************************************************************



;*******************************************************************************
;*
;*  Define load pointer and segment override macros.
;*
;*******************************************************************************

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

ifdef I386
    PCS   equ <>
else
    PCS   equ <cs:>
endif


;*******************************************************************************
;*
;*  Define IWORD and ISIZE.
;*
;*******************************************************************************

ifdef  I386
    IWORD   equ     <dword>
    ISIZE   equ     4
else
    IWORD   equ     <word>
    ISIZE   equ     2
endif


;*******************************************************************************
;*
;*  Define short conditional jumps for 386 code.
;*
;*******************************************************************************

	irp	x,<Z,E,S,C,P,PE,PO,A,AE,B,BE,G,GE,L,LE,O>
JS&x	equ   <j&x short>
JSN&x	equ   <jn&x short>
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\convert.inc ===
page	,132
;***
;convert.inc - macros and defines for floating point/ascii convertion routines
;
;	Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	Macros and defines for floating point/ascii convertion routines
;
;Revision History:
;
;   04/17/89  WAJ   Initial version.  Assembeler version of convert.h
;   04/20/89  WAJ   Now defines constants for $i10_output() OutputFlags
;
;*******************************************************************************



;*******************************************************************************
;
;   Constants
;
;*******************************************************************************


MAX_MAN_DIGITS	equ   21		; Largest number of decimal digits returned


;*
;*  Flags returned by __StrToLd()
;*

SLD_UNDERFLOW	equ	1	; Underflow occurred. Zero returned.
SLD_OVERFLOW	equ	2	; Overflow occured.  Infinity returned.
SLD_NODIGITS	equ	4	; No digits were found. Zero returned.


;*
;*  Output flags for $i10_output()
;*

SO_FFORMAT	equ	1	; 'f' format.  Use precision as number of digits to right of decimal.




;*******************************************************************************
;
;   Structures
;
;*******************************************************************************


FloatOutStruct	struc
    FloatExp	dw	?
    FloatSign	db	?
    FloatStrLen db	?
    FloatStr	db	(MAX_MAN_DIGITS + 1) dup(?)
FloatOutStruct	ends
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\errno.inc ===
;***
;errno.inc - defines standard C error codes
;
;	Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file contains definitions for the standard C error codes
;	used by XENIX (many of these have little significance for
;	MS-DOS).
;
;Revision History:
;
;*******************************************************************************


err	MACRO	num,name,text
name	equ	num
	ENDM


err	1,	EPERM,		<Not owner>
err	2,	ENOENT, 	<No such file or directory>
err	3,	ESRCH,		<No such process>
err	4,	EINTR,		<Interrupted system call>
err	5,	EIO,		<I/O error>
err	6,	ENXIO,		<No such device or address>
err	7,	E2BIG,		<Arg list too long>
err	8,	ENOEXEC,	<Exec format error>
err	9,	EBADF,		<Bad file number>
err	10,	ECHILD, 	<No child processes>
err	11,	EAGAIN, 	<No more processes>
err	12,	ENOMEM, 	<Not enough space>
err	13,	EACCES, 	<Permission denied>
err	14,	EFAULT, 	<Bad address>
err	15,	ENOTBLK,	<Block device required>
err	16,	EBUSY,		<Mount device busy>
err	17,	EEXIST, 	<File exists>
err	18,	EXDEV,		<Cross-device link>
err	19,	ENODEV, 	<No such device>
err	20,	ENOTDIR,	<Not a directory>
err	21,	EISDIR, 	<Is a directory>
err	22,	EINVAL, 	<Invalid argument>
err	23,	ENFILE, 	<File table overflow>
err	24,	EMFILE, 	<Too many open files>
err	25,	ENOTTY, 	<Not a typewriter>
err	26,	ETXTBSY,	<Text file busy>
err	27,	EFBIG,		<File too large>
err	28,	ENOSPC, 	<No space left on device>
err	29,	ESPIPE, 	<Illegal seek>
err	30,	EROFS,		<Read-only file system>
err	31,	EMLINK, 	<Too many links>
err	32,	EPIPE,		<Broken pipe>
err	33,	EDOM,		<Math argument>
err	34,	ERANGE, 	<Result too large>
err	35,	EUCLEAN,	<file system needs cleaning>
err	36,	EDEADLOCK,	<would deadlock>

;	end of errno.inc
;-----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\defsegs.inc ===
;***
;defsegs.inc - defines segments.
;
;   Copyright (c) 1989-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines segments for the math libs.
;
;Revision History:
;   11-14-89  WAJ   Initial version.
;
;*******************************************************************************


CrtDefSegs macro   SegList
    irp     seg, <SegList>

	ifidni	<seg>,<code>
	    ifdef I386
		createSeg _TEXT,code,dword,public,code,FLAT
		defGrp FLAT,<code>
	    else
		ifdef  FAR_CODE
		    createSeg _RTEXT,code,word,public,code
		else
		    createSeg _RTEXT,code,word,public,code
		endif
	    endif

	elseifidni <seg>,<data>
	    ifdef I386
		createSeg DATA,data,dword,public,DATA,FLAT
		defGrp FLAT,<data>
	    else
		createSeg DATA,data,word,public,DATA,DGROUP
		defGrp DGROUP,<data>
	    endif

	elseifidni <seg>,<init>
	    ifdef I386
		createSeg XIB,	xibseg, dword, public, DATA, FLAT
		createSeg XI,	xiseg,	dword, public, DATA, FLAT
		createSeg XIE,	xieseg, dword, public, DATA, FLAT
		defGrp FLAT,<xibseg,xiseg,xieseg>
	    else
		createSeg XIB,	xibseg, word, public, DATA, DGROUP
		createSeg XI,	xiseg,	word, public, DATA, DGROUP
		createSeg XIE,	xieseg, word, public, DATA, DGROUP
		defGrp DGROUP,<xibseg,xiseg,xieseg>
	    endif

	else
	    %out <Error in CrtDefSeg:  Unknown segment &seg.>
	    .err
	endif

    endm    ;; irp loop
endm	    ;; CrtDefSeg macro
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\elem87.inc ===
;***
;elem87.inc -
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:   Include file for 8087 transcendental dunctions.
;	    Has jump table and common dispatch code definitions
;
;
;Revision History:
;
;   04/21/88	WAJ	Added this header.  Added wUser1/wUser2/bUser3 to
;			common dispatch code stack frame.  These are used
;			for multi thread fortran.
;
;   08/25/88	WAJ	386 version
;
;   11/16/91	GDP	put exception structure on stack frame
;
;   02/05/01	GDP	modified DispLocals, added DOMAIN_QNAN
;
;   03/25/92	GDP	added IEEE exception opcodes
;
;   09/06/94	CFW	Replace MTHREAD with _MT.
;
;   08-28-96    JWM     Added default_CW & DEFAULT_CW_without_precision for Intel mods.
;
;*******************************************************************************


SBUFSIZE EQU   108	     ; length of buffer used by fsave


;	local temps for common dispatch code

DispLocals  struc

wUser1	    dw	    ?
wUser2	    dw	    ?
savCntrl    dw	    ?
setCntrl    dw	    ?
StatusWord  dw	    ?
Fac	    dt	    ?

ifdef I386
Function    dd	    ?
else
Function    dw	    ?
endif

ErrorType   db	    ?

ifdef  _MT
__cpower    db	    ?
else
bUser3	    db	    ?
endif

typ	    dd	    ?
nam	    dd	    ?
arg1	    dq	    ?
arg2	    dq	    ?
retval	    dq	    ?
savebuf     db	    SBUFSIZE dup (?)	; buffer used for fsave'ing

DispLocals  ends

DSFISize    equ     ((size DispLocals) + ISIZE - 1) and (not (ISIZE-1))

DSF	equ	[rbp-DSFISize]			; Dispatch Stack Frame

CondCode    equ     byte ptr [DSF.StatusWord+1]
savCntrlbyte equ    byte ptr [DSF.savCntrl+1]


ifdef  _MT
_cpower equ  <DSF.__cpower>
endif



;	8087 control word structure

tranCntrl=	13h			; 64 bits, round even, affine inf
Affine= 	10h			; affine inf
default_CW=     027fh                   ; C default control word
DEFAULT_CW_without_precision = 007fh    ; C default control word, with zero precision bits


;	error types for matherr

CHECKRANGE=	-2			; check for possible overflow or underflow
CHECKOVER=	-1			; check for possible overflow
DOMAIN= 	1
SING=		2
OVERFLOW=	3
UNDERFLOW=	4
TLOSS=		5
PLOSS=		6
DOMAIN_QNAN=	7			; should be changed to DOMAIN
					; before calling matherr
INEXACT=	8


;	function jump table structure

funtab		struc
  fnamlen	db	?
  fnam		db	6 dup (?)
  fuseval	db	6 dup (?)
  fnumarg	db	?
  fnumber	db	?
		db	?	;; padding
funtab		ends


jmptab	macro	nam,namlen,strnam,useval,numarg
labelW		_&nam&jmptab, PUBLIC
	db	namlen		;; 1
	db	strnam		;; 6
	db	useval		;; 6
	db	numarg		;; 1
	db	nam		;; 1
	db	?		;; 1
	endm


Z = 1*ISIZE		    ; 0.0
H = 2*ISIZE		    ; HUGE
mH = 3*ISIZE		    ; -HUGE


Pentry	macro	pnam,nam,narg
extrn		__&nam&jmptab:word
extrn		__ptrandisp&narg&s:near
extrn		__ptrandisp&narg&d"near
labelP	pnam&SRQQ, PUBLIC
	mov	rdx, dataoffset __&nam&jmptab
	jmp	__ptrandisp&narg&s
labelP	pnam&DRQQ, PUBLIC
	mov	rdx, dataoffset __&nam&jmptab
	jmp	__ptrandisp&narg&d
	endm

; This macro is used to generate the necessary code and declarations
; for Fortran intrinsics with one argument

F1ArgEntry	macro	nam
extrn		_&nam&jmptab:word
extrn		_ctrand1:near
labelP	_FI&nam, PUBLIC
	mov	rdx, dataoffset _&nam&jmptab
	jmp	_ctrand1
	endm

; This macro is used to generate the necessary code and declarations
; for Fortran intrinsics with two arguments

F2ArgEntry	macro	nam
extrn		_&nam&jmptab:word
extrn		_ctrand2:near
labelP	_FI&nam, PUBLIC
	mov	rdx, dataoffset _&nam&jmptab
	jmp	_ctrand2
	endm


;	C/FORTRAN/BASIC floatcall macro

fc	macro	JSS,JDS,FCNAM,INS,SIZE,WAITI
;;		JSS - SS:BX and ES:BX offset
;;		    JDS - DS:BX offset
;;			FCNAM - float call name suffix
;;			      INS - 8087 instruction.
;;				  SIZE - byte,word,dword,qword,tbyte
;;				       WAIT - 8087 wait.
;;
;;	if large model, then frame floatcalls for BASIC error recovery

ifnb	   <JSS>
  labelP  _s&FCNAM, PUBLIC
	  push	  ss
	  pop	  es
  _e&FCNAM  proc
	  f&ins&size& ptr es:[rbx]  ;; Perform instruction.
	  waiti
	  ret
  _e&FCNAM  endp
endif	   ;;JES

ifnb	   <JDS>
  _f&FCNAM  proc
  ifnb	     <SIZE>
	  f&ins&size& ptr [rbx]     ;; Perform instruction.
	  waiti
  else
    ifnb    <ins>
	    f&ins
	    waiti
    endif
  endif    ;;SIZE

  _f&FCNAM  endp

endif	   ;;JDS
endm


; IEEE exception opcodes
; should be in sync with fpieee.h, ntxcapi.h

OP_SQRT    = 05h
OP_ACOS    = 0dh
OP_ASIN    = 0eh
OP_ATAN    = 0fh
OP_ATAN2   = 10h
OP_COS	   = 12h
OP_COSH    = 13h
OP_EXP	   = 14h
OP_FMOD    = 16h
OP_LOG	   = 1ah
OP_LOG10   = 1bh
OP_POW	   = 1dh
OP_SIN	   = 1eh


OP_SINH    = 1fh
OP_TAN	   = 20h
OP_TANH    = 21h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file defines the current memory model being used.
;
;Revision History:
;	08-04-88  SJM	Initial version to handle all four memory models
;			in 16-bit mode and small model in 32-bit mode
;	08-08-88  JCR	Added CPDIST, ?WIN, PCS, ISHIFT/LSHIFT, OS2,
;			DNPTR/DFPTR, DFLOAT/DDOUBLE/DLDOUBLE
;	08-16-88  PHG	Added FPES, LFPES, CBI, ZXAL, ZXBL, ZXCL, ZXDL
;	08-17-88  JCR	Added CAXDX, modified FPSIZE
;	08-20-88  PHG	Added diagnostic messages, removed 386 16-bit support
;			and 386 large code/data support, added mucho comments,
;			PSS now defined as es: only if SS_NEQ_GROUP defined
;	08-24-88  JCR	Added RBXSAVE and RBXONLY for use in 'proc uses'
;	08-25-88  JCR	Added savereg macro, removed rbxsave/rbxonly...
;	08-26-88  GJF	Added codeseg (text) macro
;	09-15-88  JCR	Corrected savelist/reglist macro to go with new MASM
;	09-21-88  WAJ	Added JS*, static*, global*, and label*, and lab macros
;	09-22-88  JCR	Change 'plm' to 'pascal' in label macro
;	09-26-88  WAJ	Added PUSH16 which will do a 16 bit push in a USE32 seg.
;	09-28-88  WAJ	Added CPWORD and DPWORD
;	09-29-88  WAJ	Added JMPFAR16 macro
;	10-12-88  JCR	Made PCS evaluate to 'cs:' for 16/32 stub testbed
;	04-24-89  JCR	Added 'assume seg:flat' for 386 to avoid masm/link bug
;	05-25-89  GJF	Added APIEXT, a macro that expands to the proper extrn
;			declaration for an API function
;	06-13-89  JCR	Added 'flat:' to DCPTR and DDPTR
;	09-15-89  JCR	Added DCPTR? and DDPTR?, always use "FLAT" not "flat"
;	09-06-94  CFW	Replace MTHREAD with _MT.
;	01-11-95  SKS	Remove MASM 5.X support
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86		8086/8088 processor
;   -DI286		80286 processor
;   -DI386		80386 processor with 32-bit code/data segment
;
;   -Dmem_S		Small memory model   (near code, near data)
;   -Dmem_M		Medium memory model  (far code, near data)
;   -Dmem_C		Compact memory model (near code, fat data)
;   -Dmem_L		Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP	SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu 			86, 286, or 386
;   sizeC			code distance; 1 = far code, 0 = near code
;   sizeD			data distance; 1 = far data, 0 = near data
;   mmodel			english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE 	size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE	size of float, double, long double
;   NPSIZE, FPSIZE		size of near/far pointers
;   CPSIZE, DPSIZE		size of code/data pointers
;   ISHIFT, LSHIFT		bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx, 	expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ			jump when rcx is zero
;   CBI 			convert byte to int (al to rax)
;   CAXDX			convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL	zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES			load data pointer with ES or DS
;   PDS, PES			segment overrides when pointer loaded as above
;   PCS, PSS			segment override to get at code/stack segment
;   LFPDS, LFPES		load far pointer with ES or DS
;   FPDS, FPES			segment overrides when pointer loaded as above
;   CPTR			data type of code pointer
;   CPDIST			distance of code (near/far)
;   DNPTR, DFPTR		define near/far pointer
;   DCPTR, DDPTR		define code/data pointer
;   DCPTR?, DDPTR?		define uninitialized code/data pointer
;   CPWORD, DPWORD		data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD 	data type of int, long, short
;   DINT, DLONG, DSHORT 	define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE	define float, double, long double
; Offsets:
;   codeoffset, dataoffset	offsets from code and data segments
; API calls:
;   APIDIST			distance of API calls (near/far)
;   APIEXT ApiName		extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg			define/declare code segment
;   error <msg> 		stop assembly with message
;   display <msg>		display a message, unless QUIET defined
;   savelist [<reg> ...]	init list of regs to be save by 'proc uses'
;   _if cond <instruction>	assemble instruction only if cond is TRUE
;   _ife cond <instruction>	assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>	assemble instruction only if symbol defined
;   _ifnd symbol <instruction>	assemble instruction only if symbol not defined
;
;   lab  LabelName		assembles to "LabelName:" If DEBUG is defined
;				LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)	assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat	 defines a static variable of type *
;   global* Name, InitialValue, Repeat	 defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}	 defines a label of type *
;
;   PUSH16  SegmentReg		pushes 16 bits in a use32 segment
;   JMPFAR16  label		will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>	-    Output message and generate error

error	MACRO	msg
if2			;; only on pass 2 can we generate errors
	%out	**********************************************************
	%out	*** E r r o r  --  msg
	%out	**********************************************************
	.err
endif
        ENDM

; display msg	-    Output message unless QUIET defined

display MACRO	msg
ifndef QUIET		;; only when quiet flag not set
if1			;; and on pass 1, then display message
	%out msg
endif
endif
	ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;					       push  ds
;					   endif

_if	MACRO	cond,text
    if	cond
	text
    endif
	ENDM

_ife	MACRO	cond,text
    ife cond
	text
    endif
	ENDM

_ifd	MACRO	cond,text
    ifdef   cond
	text
    endif
	ENDM

_ifnd	MACRO	cond,text
    ifndef  cond
	text
    endif
	ENDM

; set windows flag to 0

	?WIN	equ	0	; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
	; Medium model
	sizeC	equ	1
	sizeD	equ	0
	mmodel	equ	<Medium>
elseifdef  mem_C
	; Compact model
	sizeC	equ	0
	sizeD	equ	1
	mmodel	equ	<Compact>
elseifdef  mem_L
	; Large model
	sizeC	equ	1
	sizeD	equ	1
	mmodel	equ	<Large>
else
	; Small model - default
	sizeC	equ	0
	sizeD	equ	0
	mmodel	equ	<Small>
endif

; Process processor arguments

ifdef	    I286
	display <Processor:		80286>
	cpu equ 286
	.286
elseifdef   I386
	display <Processor:		80386>
	cpu equ 386
	OS2   equ <>	; Define "OS2" since 386 can only run on that OS
	.386
else
	display <Processor:		8086/8088>
	cpu equ 86
	.8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
	error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
	error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
	error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%	display <Memory model:		mmodel>
%	.model	mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef	I386
	; ensure that MASM recognizes 'FLAT'
	assume	gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>	 ; convert byte to int (al to rax)
    CAXDX equ <cdq>		 ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>	 ; zero extend al
    ZXBL  equ <movzx ebx, bl>	 ; zero extend bl
    ZXCL  equ <movzx ecx, cl>	 ; zero extend cl
    ZXDL  equ <movzx edx, dl>	 ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>		 ; convert byte to int (al to rax)
    CAXDX equ <cwd>		 ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>	 ; zero extend al
    ZXBL  equ <xor bh, bh>	 ; zero extend bl
    ZXCL  equ <xor ch, ch>	 ; zero extend cl
    ZXDL  equ <xor dh, dh>	 ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>		; large code model or non-386
else
 IF 1	;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <> 		; 386 small code model
 ENDIF	;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>		; SS != DS
else
    PSS   equ <>		; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset	equ <offset FLAT:>
    dataoffset	equ <offset FLAT:>
else
    codeoffset	equ <offset @code:>
    dataoffset	equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386	 ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>		; near pointer
    DFPTR equ <dd>		; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>		; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>		; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword> 	; code pointers are dwords
    DPWORD  equ <dword> 	; data pointers are dwords

    APIDIST equ <near>		; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:near
endm

else	;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1		; byte-to-int shift count
    LSHIFT  equ 2		; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>		; near pointer
    DFPTR equ <dd>		; far pointer

    if sizeC
	DCPTR	equ <dd>       ; 16 bit segment and 16 bit offset
	DCPTR?	equ <dd>
	CPSIZE	equ 4
	CPDIST	equ <far>      ; code pointers are far
	CPTR	equ <far ptr>
	CPWORD	equ <dword>    ; code pointers are dwords
    else
	DCPTR	equ <dw>       ; 16 bit offset only
	DCPTR?	equ <dw>
	CPSIZE	equ 2
	CPDIST	equ <near>     ; code pointers are near
	CPTR	equ <near ptr>
	CPWORD	equ <word>     ; code pointers are words
    endif

    if sizeD
	DDPTR	equ <dd>
	DDPTR?	equ <dd>
	DPSIZE	equ 4
	DPWORD	equ <dword>    ; data pointers are dwords
    else
	DDPTR	equ <dw>
	DDPTR?	equ <dw>
	DPSIZE	equ 2
	DPWORD	equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>		; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI	macro	apiname
	extrn pascal apiname:far
endm

endif	; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ	4	; float
DBLSIZE  equ	8	; double
LDBLSIZE equ	10	; long double

DFLOAT	 equ	<dd>
DDOUBLE  equ	<dq>
DLDOUBLE equ	<dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;	reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;	reglist = text string of registers that can be passed to the 'uses'
;	option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
	local	ws, listsize
	ws	catstr	< >		; whitespace char

	IFNDEF	I386
	 rbx equ <>			; 8086/286 don't save rbx
	ENDIF

	IFNB	    <reg4>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
	ELSEIFNB    <reg3>
	 reglist     catstr  reg1, ws, reg2, ws, reg3, ws
	ELSEIFNB    <reg2>
	 reglist     catstr  reg1, ws, reg2, ws,       ws
	ELSEIFNB    <reg1>
	 reglist     catstr  reg1, ws,	     ws,       ws
	ELSE
	 reglist     catstr  <>
	ENDIF

	listsize sizestr reglist	; size of register list

	IF	listsize LE 3		; if list is only the 3 ws chars...
	 reglist catstr  <>
	ENDIF

	IFNDEF	I386
	 rbx equ <bx>			; restore rbx
	ENDIF

	ENDM	; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;	.code _TEXT	; for large code models
;	.code		; for small code models
;	assume	cs:FLAT ; for 386
;	assume	ds:FLAT ; for 386
;	assume	es:FLAT ; for 386
;	assume	ss:FLAT ; for 386
;

codeseg MACRO

if	sizeC
	.code _TEXT
else
	.code
endif

ifdef	I386
	assume	ds:FLAT
	assume	es:FLAT
	assume	ss:FLAT
endif

	ENDM

;***************************************************************
;*
;*  Debug lab macro
;*
;***************************************************************

lab	macro name
ifdef	DEBUG
    public  pascal name	    ;; define label public for Symdeb
endif
name:
	endm


;***************************************************************
;*
;*  Conditional jump short macros
;*
;***************************************************************


	irp	x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x	equ   <j&x short>
	endm


;***************************************************************
;*
;*  Global data definition macros
;*
;*  Usage:
;*	globalI   Name, InitialValue, Repeat
;*
;***************************************************************


MakeGlobal  macro   suffix, DataType	    ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public	name
ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeGlobal	T, dt			; globalT
    MakeGlobal	Q, dq			; globalQ
    MakeGlobal	D, dd			; globalD
    MakeGlobal	W, dw			; globalW
    MakeGlobal	B, db			; globalB

%   MakeGlobal	I, <DINT>		; globalI

%   MakeGlobal	DP, <DDPTR>		; globalDP
%   MakeGlobal	CP, <DCPTR>		; globalCP
%   MakeGlobal	FP, <DFPTR>		; globalFP
%   MakeGlobal	NP, <DNPTR>		; globalNP



;***************************************************************
;*
;*  Static data definition macros
;*
;*  Usage:
;*	staticI   Name, InitialValue, Repeat
;*
;***************************************************************


MakeStatic  macro   suffix, DataType	    ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name			    ;; make statics public if DEBUG
endif

ifb	<rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name	&DataType  _repeat dup( data )
	endm

	endm


    MakeStatic	T, dt			; staticT
    MakeStatic	Q, dq			; staticQ
    MakeStatic	D, dd			; staticD
    MakeStatic	W, dw			; staticW
    MakeStatic	B, db			; staticB

%   MakeStatic	I, <DINT>		; staticI

%   MakeStatic	DP, <DDPTR>		; staticDP
%   MakeStatic	CP, <DCPTR>		; staticCP
%   MakeStatic	FP, <DFPTR>		; staticFP
%   MakeStatic	NP, <DNPTR>		; staticNP

;***************************************************************
;*
;*  Label definition macros
;*
;***************************************************************
;*
;*  Label definition macros
;*
;*  Usage:
;*	labelI	 Name, {PUBLIC, PASCAL, C}
;*
;***************************************************************

__MakePublic	macro	name, option	;; decides if a label should be
ifidni	<option>, <PUBLIC>		;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
	public	pascal name	;; make public if DEBUG
    endif
endif
		endm


MakeLabel   macro suffix, LabelType	;; makes all of the label* macros

%@CatStr(<label>,<suffix>)	macro	name, option
	__MakePublic	<name>,<option>
name	label	&LabelType
	endm

	endm


	MakeLabel   T, tbyte	; make labelT
	MakeLabel   Q, qword	; make labelQ
	MakeLabel   D, dword	; make labelD
	MakeLabel   W, word	; make labelW
	MakeLabel   B, byte	; make labelB

	MakeLabel   P, proc	; make labelP
	MakeLabel   FP, far	; make labelFP
	MakeLabel   NP, near	; make labelNP

%	MakeLabel   I, IWORD	; make labelI


labelDP macro	name, option		    ;; labelDP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeD
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeD
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm

labelCP macro	name, option		    ;; labelCP
	__MakePublic	<name>,<option>
ifdef  I386
    if sizeC
	name	label	fword
    else
	name	label	dword
    endif
else	;not I386
    if sizeC
	name	label	dword
    else
	name	label	word
    endif
endif	;not I386
	endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16	macro	SegReg

ifdef I386
	nop
	db	66h	    ; operand size over-ride
endif	; I386

	push	SegReg
	endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro	label

ifndef I386
	error  <JMPFAR16 can only be used in a use32 code segment>
endif	;I386

	nop
	db	66h	    ;; operand size over-ride
	db	0eah	    ;; jmp far immediate op code
	dw	offset label
	dw	seg label
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\mathmac.inc ===
;---------------        Standard MATHMAC.INC
;
;       Standard Math Macro Definition File
;
;       Gregory F. Whitten
;       07/28/83
;
;       Copyright (c) 1983-2001, Microsoft Corporation. All rights reserved.
;
;
;       Revision History
;
;       10/18/83        Greg Whitten
;                       changed LCL FLT option to have 2 values for IEEE
;
;       05/02/84        Greg Whitten
;                       added CSconst switch support
;
;       07/23/84        Greg Whitten
;                       changed public/extrn to lower case
;
;       09/03/84        Greg Whitten
;                       added movcnp macro for constant pointers (with CSconst)
;                       fixed CSconst bug in f_movcs (only used 1 place)
;
;       10/29/84        Greg Whitten
;                       added debugger switch for fout changes
;
;	06/17/87	Jamie Bariteau
;			changed outif macro for MASM 5.0 compatibility
;
;	02/22/88	Bill johnston
;			outif now checks to see if QUIET was defined.
;
;---------------


if1     ; Pass 1 only

;       Helper macros for undefined symbols


;***    OUTIF   name,msg
;
; Function:
;       Output msg if name is non-zero.  If name is undefined, set name = 0.
;

outif   MACRO   name,msg
ifndef          Name
  Name=           0
else
  if    Name
    if1
	ifndef QUIET
	    %out    ! msg
	endif
    endif
  endif
	Name=Name
endif
	ENDM


;***    ERROR   msg
;
; Function:
;       Output msg and generate an assembly time error
;

error   MACRO   msg
	bug
	%OUT    E r r o r ----- msg
	ENDM

endif   ; Pass 1

;       Define standard math package switches

ifdef  DEBUG
	%out <+++++++++++++++++++++++>
	%out <+++  DEBUG version  +++>
	%out <+++++++++++++++++++++++>
endif	;DEBUG

outif   XENIX3,         <+++  XENIX 3.0 and later version  +++>

outif   BASIC,          <BASIC Interpreter>
outif   BASCOM,         <BASIC Compiler>
outif   CC,             <C Compiler>
outif   FORTRAN,        <FORTRAN Compiler>
outif   PASCAL,         <PASCAL Compiler>
outif   Frontends,      <  compiler front-end version>
outif   LOGO,           <LOGO Interpreter>
outif   IBMASM,         <IBM Assembler Library>
outif   ASSEMBLER,      <Macro Assembler>
outif   debugger,       <Symbolic Assembly Debugger>

outif   DecFmt,         <- Decimal Microsoft Format>
outif   MBinFmt,        <- Binary Microsoft Format>
outif   IEEEFmt,        <- IEEE Format>
if      IEEEFmt and (Frontends or debugger)
Denormal=       1                               ; front-ends need denormals
endif
outif   Denormal,       <-   denormal number support>
outif   Use8087,        <-   8087 instructions>

outif   Single,         <-   Single precision>
outif   Double,         <-   Double precision>
outif   CSconst,        <-   Constants in CS>



if      DecFmt+IEEEFmt+MBinFmt ne 1
	error   <Improper math format specified>
endif

if      Single+Double ne 1
	error   <Improper math size specified>
endif


poly1   =   8000h                       ; flag for leading 1 in poly

if      Single                          ; Defined on both passes
  DefTyp= 4
  DefWrd= 2
else    ;Double
  DefTyp= 8
  DefWrd= 4
endif


;       offsets to sign and exponent fields

if      IEEEFmt
  if      single
expmask=        07F80h
expbias=        03F80h
expshft=        7
manbits=        24
of_exp=         2
of_sgn=         3
  else    ;double
expmask=        07FF0h
expbias=        03FF0h
expshft=        4
manbits=        53
of_exp=         6
of_sgn=         7
  endif
endif   ;IEEEFmt

if      MBinFmt
  if      single
manbits=        24
of_exp=         3
of_sgn=         2
  else    ;double
manbits=        56
of_exp=         7
of_sgn=         6
  endif
endif   ;MBinFmt

if      DecFmt
of_exp=         0
of_sgn=         0
endif   ;DecFmt



if1     ; Pass 1 only

;       Helper macros for elementary functions


;***    LCL     name,type,value
;
; Function:
;       LCL declares data with the specified name, type, and value.
;       If the type is FLT for IEEE numbers, then either DD or DQ is
;       substituted depending on the size of the variable.
;

lcl     MACRO  name,type,value,value2
ifidn   <type>,<FLT>
  if      IEEEFmt
    if      Single
      name    DD      value
    else    ;;Double
      name    DQ      value2
    endif
  else
	  error   <FLT not implemented for this type>
  endif
else
  name    type    value
endif
	ENDM


;***    GENHELP typ,siz
;
; Function:
;       GENHELP generates the following macros with the typ and siz
;       information embedded in the macro.
;
;           PUB     name
;           PUB4    name
;           PUB8    name
;           GBL     name,type,value
;           GBL4    name,type,value
;           GBL8    name,type,value
;           EXT     name,type
;           EXT4    name,type
;           EXT8    name,type
;           F_DW    rout
;           F4_DW   rout
;           F8_DW   rout
;           F_JMP   rout
;           F4_JMP  rout
;           F8_JMP  rout
;           F_CALL  rout
;           F4_CALL rout
;           F8_CALL rout
;
;       Global names are considered to be names with the type and size prefix.
;       Local names have no prefix.  I.e., $I8_ONE and ONE, respectively.
;
;       Macros with a size in the name create local names with the size at the
;       end.  I.e., RESULT4
;

genhelp MACRO   typ,siz


;***    PUB     name
;
; Function:
;       PUB declares both the global and local names as labels.
;

pub     &MACRO   name
	public  $&typ&&siz&_&&name
$&typ&&siz&_&&name:
name:
	&ENDM


pub4    &MACRO   name
	public  $&typ&4_&&name
$&typ&4_&&name:
name&&4:
	&ENDM


pub8    &MACRO   name
	public  $&typ&8_&&name
$&typ&8_&&name:
name&&8:
	&ENDM

;***    PUBX     name
;
; Function:
;       PUBX declares both the global and local names as labels.
;	Added for MASM 5.0 compatibility.  Adds leading underscore
;	to local names to avoid conflict with MASM 5.0 reserved words.
;
pubx     &MACRO   name
	public  $&typ&&siz&_&&name
$&typ&&siz&_&&name:
_&&name:
	&ENDM

pub4x   &MACRO   name
	public  $&typ&4_&&name
$&typ&4_&&name:
_name&&4:
	&ENDM


pub8x   &MACRO   name
	public  $&typ&8_&&name
$&typ&8_&&name:
_name&&8:
	&ENDM

;***    GLB     name,type,value
;
; Function:
;       GLB declares the global name for the data value and aliases the local
;       name to it.
;

glb     &MACRO  name,type,value
	public  $&typ&&siz&_&&name
	lcl     $&typ&&siz&_&&name,type,<value>
name    equ     $&typ&&siz&_&&name
	&ENDM


glb4    &MACRO  name,type,value
	public  $&typ&4_&&name
	lcl     $&typ&4_&&name,type,<value>
name&&4 equ     $&typ&4_&&name
	&ENDM


glb8    &MACRO  name,type,value
	public  $&typ&8_&&name
	lcl     $&typ&8_&&name,type,<value>
name&&8 equ     $&typ&8_&&name
	&ENDM


;***    EXT     name,type
;
; Function:
;       EXT declares the global name to be external with the specified type.
;       It also aliases the local name to the global name.
;

ext     &MACRO  name,type
	extrn   $&typ&&siz&_&&name:type
name    equ     $&typ&&siz&_&&name
	&ENDM


ext4    &MACRO  name,type
	extrn   $&typ&4_&&name:type
name&&4 equ     $&typ&8_&&name
	&ENDM


ext8    &MACRO  name,type
	extrn   $&typ&8_&&name:type
name&&8 equ     $&typ&8_&&name
	&ENDM


;***    F_DW    name
;
; Function:
;       F_DW declares the code address of the global name
;

f_dw    &MACRO  name
	dwcp    $&typ&&siz&_&&name
	&ENDM


f4_dw   &MACRO  name
	dwcp    $&typ&4_&&name
	&ENDM


f8_dw   &MACRO  name
	dwcp    $&typ&8_&&name
	&ENDM


;***    F_CALL  name
;
; Function:
;       F_CALL declares the global name to be external and issues a call.
;

f_call  &MACRO  name
	extrn   $&typ&&siz&_&&name:near
	  call    $&typ&&siz&_&&name
	&ENDM


f4_call &MACRO  name
	extrn   $&typ&4_&&name:near
	  call    $&typ&4_&&name
	&ENDM


f8_call &MACRO  name
	extrn   $&typ&8_&&name:near
	  call    $&typ&8_&&name
	&ENDM


;***    F_JMP   name
;
; Function:
;       F_JMP declares the global name to be external and issues a jmp.
;

f_jmp   &MACRO  name
	extrn   $&typ&&siz&_&&name:near
	  jmp     $&typ&&siz&_&&name
	&ENDM


f4_jmp  &MACRO  name
	extrn   $&typ&4_&&name:near
	  jmp     $&typ&4_&&name
	&ENDM


f8_jmp  &MACRO  name
	extrn   $&typ&8_&&name:near
	  jmp     $&typ&8_&&name
	&ENDM


	ENDM                            ;; End of genhelp



;       Invoke GENHELP with the appropriate type and size information.

if      DecFmt
  if      Single
	  genhelp d,4
  else    ;;Double
	  genhelp d,8
  endif
endif

if      IEEEFmt
  if      Single
	  genhelp i,4
  else    ;;Double
	  genhelp i,8
  endif
endif

if      MBinFmt
  if      Single
	  genhelp m,4
  else    ;;Double
	  genhelp m,8
  endif
endif

	purge   genhelp                         ; toss genhelp macro


;       cs mover macros - generate code iff CSconst nonzero

movcssi macro
if      CSconst
	f_call  mvcssi
endif
	endm

movcsdi macro
if      CSconst
	f_call  mvcsdi
endif
	endm


movcnp  macro   dest,name,off
if  CSconst
	movcp   dest,name,off
else
	movp    dest,name,off
endif
	endm


;       f_movcs macro
;       f_mov   macro
;       f4_mov  macro
;       f8_mov  macro
;
; Special forms         f_mov
;
;       op1/DI          op2/SI          Routine         Res SI          Use
;
;       ARG             AC              movarg_ac       AC              DI
;       ARG             <>              movarg          SI              DI
;       AC              ARG             movac_arg       AC              DI
;       AC              <>              movac           AC              DI
;       TEMP            <>              movtemp         SI              DI
;       any             any             gen code        used            SI.DI
;
; Special forms         f_movcs
;
;       op1/DI          op2/SI          Routine         Res SI          Use
;
;       AC              any             gencode         AC              DI
;       any             any             gen code        used            SI.DI

f_movcs macro   op1,op2
if      CSconst
	movp    di,op1
	movcp   si,op2                ;; op2 is source
	&rept   DefWrd
	movs    word ptr es:[di],word ptr cs:[si]
	&endm
  ifidn <op1>,<AC>
	movp    si,AC
  endif
else
	f_mov   op1,op2
endif
	endm

f_mov   MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f_call  movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f_call  movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f_call  movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f_call  movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f_call  movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  &rept    DefWrd
	    movsw
	  &endm
    endif
  endif
endif
	ENDM


f4_mov  MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f4_call movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f4_call movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f4_call movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f4_call movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f4_call movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  movsw
	  movsw
    endif
  endif
endif
	ENDM


f8_mov  MACRO   op1,op2
ifidn   <op1>,<ARG>
  ifidn   <op2>,<AC>
	  f8_call movarg_ac
  else
    ifnb    <op2>
	  movp    si,op2                ;; op2 is source
    endif
	  f8_call movarg
  endif
else
  ifidn   <op1>,<AC>
    ifidn   <op2>,<ARG>
	  f8_call movac_arg
    else
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f8_call movac
    endif
  else
    ifidn   <op1>,<TEMP>
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  f8_call movtemp
    else
      ifnb    <op1>
	  movp    di,op1                ;; op1 is dest
      endif
      ifnb    <op2>
	  movp    si,op2                ;; op2 is source
      endif
	  movsw
	  movsw
	  movsw
	  movsw
    endif
  endif
endif
	ENDM


;       f_push  macro
;
; Special forms
;
;       op1             Routine         Res SI          Use
;
;       AC              pushac          AC              AX
;       ARG             pusharg         ARG             AX
;       SI              pushsi          SI              AX
;       any             gen code        SI              ---

f_push  MACRO   op1
ifidn   <op1>,<AC>
	  f_call   pshac
else
  ifidn   <op1>,<ARG>
	  f_call   psharg
  else
    ifidn   <op1>,<SI>
	  f_call   pshsi
    else
      if      Double
	  push    [op1+6]
	  push    [op1+4]
      endif
	  push    [op1+2]
	  push    [op1]
    endif
  endif
endif
	ENDM


;       f_pop   macro
;
; Special forms
;
;       op1             Routine         Res SI          Use
;
;       AC              popac           AC              AX
;       ARG             poparg          ARG             AX
;       SI              popsi           SI              AX
;       any             gen code        SI              ---

f_pop   MACRO   op1
ifidn   <op1>,<AC>
	  f_call   popac
else
  ifidn   <op1>,<ARG>
	  f_call   poparg
  else
    ifidn   <op1>,<SI>
	  f_call   popsi
    else
	  pop     [op1]
	  pop     [op1+2]
      if      Double
	  pop     [op1+4]
	  pop     [op1+6]
      endif
    endif
  endif
endif
	ENDM


;       f_opr    macro
;
; Special forms
;
;       op1/SI          op2/DI          routine         operations
;
;       AC              ARG             xxxf            add,sub,mul,div,cmp
;       <>              ARG             xxxfsi          add,sub,mul,div,cmp
;       ARG             AC              xxxr            sub,div,cmp
;       ARG             <>              xxxrdi          sub,div,cmp
;       any             any             gen moves and call

genoper  MACRO   op
f_&op   &MACRO  op1,op2
ifidn   <op2>,<ARG>
  ifidn   <op1>,<AC>
	  f_call   op&f
  else
    ifb     <op1>
	  f_call   op&fsi
    else
	  movp    si,op1
	  movp    di,ARG
	  f_call   op
    endif
  endif
else
  ifidn   <op1>,<ARG>
    ifidn   <op2>,<AC>
	  f_call   op&r
    else
      ifb     <op2>
	  f_call   op&rdi
      else
	  movp    si,ARG
	  movp    di,op2
	  f_call   op
      endif
    endif
  else
    ifnb    <op1>
	  movp    si,op1
    endif
    ifnb    <op2>
	  movp    di,op2
    endif
	  f_call   op
  endif
endif
	&ENDM
	ENDM

genoper add
genoper sub
genoper mul
genoper div
genoper cmp

	purge   genoper


endif   ; Pass 1

;---------------        End of Standard MATHMAC.INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\os2supp.inc ===
;*** 
;os2supp.inc - helper macros for OS/2, MTHREAD, and DLL support
;
;	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for OS/2, MTHREAD, and DLL support
;
;Revision History:
;
;   08-25-88 WAJ    Added this header.	Added to 386 tree.
;   09-06-94 CFW    Replace MTHREAD with _MT.
;
;*******************************************************************************


ifdef	_MT
    OS2SUPP equ     1
else
    OS2SUPP equ     0
endif

__MsgString equ     <>

ifdef	_MT
__MsgString catstr __MsgString, < _MT>
endif

ifdef	SS_NEQ_DGROUP
__MsgString catstr __MsgString, < SS_NEQ_DGROUP>
endif

ifdef	DLL
__MsgString catstr __MsgString, < DLL>
endif

__SMsgString  sizestr __MsgString

if  __SMsgString
    if OS2SUPP
	__MsgString catstr <OS/2 Support Lib ->, __MsgString
    else
	__MsgString catstr <Support Lib ->, __MsgString
    endif
    ifndef QUIET
%	display __MsgString
    endif
endif


_loadds 	macro		;; code for loading ds with DGROUP
	push	ds
	mov	ax,DGROUP
	mov	ds,ax
endm	

_reloadds	macro		;; code for resetting ds
	pop	ds
endm	




ifmt	macro	code
    ifdef   _MT
	code
    endif
endm

nomt	macro	code
    ifndef  _MT
	code
    endif
endm

ifdll	macro	code
    ifdef   DLL
	code
    endif
endm


if_LOAD_DGROUP	macro	code
    ifdef  _LOAD_DGROUP
	code
    endif
endm

no_LOAD_DGROUP	macro	code
    ifndef  _LOAD_DGROUP
	code
    endif
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\include\cv.h ===
/***
*cv.h - definitions for floating point conversion
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   define types, macros, and constants used in floating point
*   conversion routines
*
*Revision History:
*       07-17-91  GDP   initial version
*       09-21-91  GDP   restructured 'ifdef' directives
*       10-29-91  GDP   MIPS port: new defs for ALIGN and DOUBLE
*       03-03-92  GDP   removed os2 16-bit stuff
*       04-30-92  GDP   support intrncvt.c --cleanup and reorganize
*       05-13-92  XY    fixed B_END macros
*       06-16-92  GDP   merged changes from \\orville and \\vangogh trees
*       09-05-92  GDP   included fltintrn.h, new calling convention macros
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       11-17-93  GJF   Merged in NT version. Replaced _ALPHA_ with _M_ALPHA,
*                       MIPS with _M_MRX000, MTHREAD with _MT, and deleted
*                       M68K stuff.
*       10-02-94  BWT   PPC merge
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-05-99  RDL   Added _M_IA64 to #if def's for alignment.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#ifndef _INC_CV

#ifdef __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <fltintrn.h>


/* define little endian or big endian memory */

#if     defined(_M_IX86) || defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define L_END
#endif

typedef unsigned char   u_char;   /* should have 1 byte */
typedef char            s_char;   /* should have 1 byte */
typedef unsigned short  u_short;  /* should have 2 bytes */
typedef signed short    s_short;  /* should have 2 bytes */
typedef unsigned int    u_long;   /* sholuld have 4 bytes */
typedef int             s_long;   /* sholuld have 4 bytes */

/* calling conventions */
#define _CALLTYPE5


/*
 * defining _LDSUPPORT enables using long double computations
 * for string conversion. We do not do this even for i386,
 * since we want to avoid using floating point code that
 * may generate IEEE exceptions.
 *
 * Currently our string conversion routines do not conform
 * to the special requirements of the IEEE standard for
 * floating point conversions
 */


#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    u_char ld[10];
} _LDOUBLE;
#pragma pack()

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#else

typedef long double _LDOUBLE;

#define PTR_LD(x) ((u_char  *)(x))

#endif


#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _LDBL12;
#pragma pack()

typedef struct {
    float f;
} FLOAT;



/*
 * return values for internal conversion routines
 * (12-byte to long double, double, or float)
 */

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;


/*
 * return values for strgtold12 routine
 */

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

#define MAX_MAN_DIGITS 21


/* specifies '%f' format */

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
                    short   exp;
                    char    sign;
                    char    ManLen;
                    char    man[MAX_MAN_DIGITS+1];
                    } FOS;



#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200       /* maximum temporary decimal exponent */
#define TMIN10 -5200      /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS 0x3fff    /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS  0x3ff    /* exponent bias for double */
#define D_BIASM1 0x3fe  /* D_BIAS - 1 */
#define D_MAXEXP 0x7ff  /* maximum biased exponent */


/*
 * end of definitions from crt32\h\fltintrn.h
 */

/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
        ( (manhi)==MSB_ULONG && (manlo)==0x0 )


/* i386 and Alpha use same NaN format */
#if     defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define _IS_MAN_IND(signbit, manhi, manlo) \
        ((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
        ( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
        (!( _IS_MAN_INF(signbit, manhi, manlo) || \
           _IS_MAN_QNAN(signbit, manhi, manlo) ))


#elif defined(_M_MRX000) 
#define _IS_MAN_IND(signbit, manhi, manlo) \
        (!(signbit) && (manhi)==0xbfffffff && (manlo)==0xfffff800)

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
        ( (manhi)&NAN_BIT )

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
        (!( _IS_MAN_INF(signbit, manhi, manlo) || \
           _IS_MAN_SNAN(signbit, manhi, manlo) ))
#endif



#if     defined (L_END) && !( defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) )
/* "little endian" memory */
/* Note: MIPS and Alpha have alignment requirements and have different
 * macros */
/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */
/*
 * byte layout:
 *
 *              +-----+--------+--------+-------+
 *              |XT(2)|MANLO(4)|MANHI(4)|EXP(2) |
 *              +-----+--------+--------+-------+
 *              |<-UL_LO->|<-UL_MED->|<-UL_HI ->|
 *                  (4)       (4)        (4)
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short  *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long  *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long  *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif

/* big endian */
#if defined (B_END)

/*
 * byte layout:
 *
 *              +------+-------+---------+------+
 *              |EXP(2)|MANHI(4)|MANLO(4)|XT(2) |
 *              +------+-------+---------+------+
 *              |<-UL_HI->|<-UL_MED->|<-UL_LO ->|
 *                  (4)       (4)        (4)
 */


#define U_EXP_12(p) ((u_short  *)PTR_12(p))
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+2))
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+6))
#define U_XT_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_LO_12(p) ((u_long  *)(PTR_12(p)+8))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)PTR_12(p))

#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(11-(i)))
#define USHORT_12(p,i)  ((u_short  *)((u_char  *)PTR_12(p)+10-(i)))
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+8-(i)))
#define TEN_BYTE_PART(p) (u_char  *)PTR_12(p)

#define U_EXP_LD(p) ((u_short  *)PTR_LD(p))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+2))
#define UL_MANLO_LD(p) ((u_long  *)(PTR_LD(p)+6))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p))
#define UL_HI_D(p) ((u_long  *)(p))
#define UL_LO_D(p) ((u_long  *)(p) + 1)

#endif

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)

#define ALIGN(x)  ( (unsigned long  __unaligned *) (x))

#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_MANHI_12(p) ((u_long  __unaligned *) (PTR_12(p)+6) )
#define UL_MANLO_12(p) ((u_long  __unaligned *) (PTR_12(p)+2) )


#define U_XT_12(p) ((u_short  *)PTR_12(p))
#define UL_LO_12(p) ((u_long  *)PTR_12(p))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* the following 3 macros do not take care of proper alignment */
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))
#define ULONG_12(p,i) ((u_long  *) ((u_char  *)PTR_12(p)+(i) ))

#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))

#define UL_MANHI_LD(p) ((u_long  *) (PTR_LD(p)+4) )
#define UL_MANLO_LD(p) ((u_long  *) PTR_LD(p) )

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif


#define PUT_INF_12(p,sign) \
                  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
                      *UL_MED_12(p) == 0 && \
                      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
                  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
                  *UL_MANHI_LD(p) = 0x8000; \
                  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
                  *UL_MANHI_LD(p) = 0; \
                  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
                      *UL_MANHI_LD(p) == 0 && \
                      *UL_MANLO_LD(p) == 0 )


/*********************************************************
 *
 *   Function Prototypes
 *
 *********************************************************/

/* from mantold.c */
void _CALLTYPE5 __mtold12(char  *manptr, unsigned manlen,_LDBL12 *ld12);
int  _CALLTYPE5 __addl(u_long x, u_long y, u_long  *sum);
void _CALLTYPE5 __shl_12(_LDBL12  *ld12);
void _CALLTYPE5 __shr_12(_LDBL12  *ld12);
void _CALLTYPE5 __add_12(_LDBL12  *x, _LDBL12  *y);

/* from tenpow.c */
void _CALLTYPE5 __multtenpow12(_LDBL12  *pld12,int pow, unsigned mult12);
void _CALLTYPE5 __ld12mul(_LDBL12  *px, _LDBL12  *py);

/* from strgtold.c */
unsigned int __strgtold12(_LDBL12 *pld12,
            const char * *p_end_ptr,
            const char * str,
            int mult12,
            int scale,
            int decpt,
            int implicit_E);

unsigned _CALLTYPE5 __STRINGTOLD(_LDOUBLE *pld,
            const char  * *p_end_ptr,
            const char  *str,
            int mult12);


/* from x10fout.c */
/* this is defined as void in convert.h
 * After porting the asm files to c, we need a return value for
 * i10_output, that used to reside in reg. ax
 */
int _CALLTYPE5  $I10_OUTPUT(_LDOUBLE ld, int ndigits,
                    unsigned output_flags, FOS  *fos);


/* for cvt.c and fltused.c */
/* The following functions are #defined as macros in fltintrn.h */
#undef _cfltcvt
#undef _cropzeros
#undef _fassign
#undef _forcdecpt
#undef _positive

void __cdecl _cfltcvt(double *arg, char *buffer,
                         int format, int precision,
                         int caps);
void __cdecl _cropzeros(char *buf);
void __cdecl _fassign(int flag, char  *argument, char *number);
void __cdecl _forcdecpt(char *buf);
int __cdecl _positive(double *arg);

/* from intrncvt.c */
void _atodbl(DOUBLE *d, char *str);
void _atoldbl(_LDOUBLE *ld, char *str);
void _atoflt(FLOAT *f, char *str);
INTRNCVT_STATUS _ld12tod(_LDBL12 *ifp, DOUBLE *d);
INTRNCVT_STATUS _ld12tof(_LDBL12 *ifp, FLOAT *f);
INTRNCVT_STATUS _ld12told(_LDBL12 *ifp, _LDOUBLE *ld);

#ifdef __cplusplus
}
#endif

#define _INC_CV
#endif  /* _INC_CV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\os2dll.inc ===
;***
;os2dll.inc - DynaLib/Multi-thread parameter definitions
;
;	Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;	10-22-87  JCR	Module created
;	11-13-87  SKS	Added _HEAP_LOCK
;	11-16-87  JCR	Added _mlock/_munlock macros
;	12-15-87  JCR	Added _EXIT_LOCK
;	01-07-88  BCM	Added _SIGNAL_LOCK; upped MAXTHREADID from 16 to 32
;	02-01-88  JCR	Added _dll_mlock/_dll_munlock macros
;	05-03-88  JCR	Added _BHEAP_LOCK
;	08-03-88  JCR	Bumped maximum file count to 256
;	08-09-88  GJF	Added _lock_str/_unlock_str macros
;	08-12-88  JCR	386 version
;	06-02-89  JCR	386 mthread support
;	06-09-89  JCR	386: Added values to _tiddata struc (for _beginthread)
;	07-11-89  JCR	386mt: Corrected _DEBUG_LOCK_SIZE value
;	07-13-89  JCR	386: Added _LOCKTAB_LOCK and some macros
;	09-14-90  GJF	Added __pxcptacttab, __pxcptinfoptr and __fpecode
;			fields to _tiddata struc.
;	10-03-91  JCR	Added _cvtbuf to _tiddata structure
;	09-06-94  CFW	Replace MTHREAD with _MT.
;
;*******************************************************************************

_NFILE_ = 256		;maximum number of streams

;Lock table offsets
;------------------
;[NOTE: These values must coincide with the values in os2dll.h.]

;[NOTE: do not change _SIGNAL_LOCK without changing emulator's os2dll.inc.]
_SIGNAL_LOCK	equ	1	; lock for signal() and emulator SignalAddress
				; emulator uses \math\include\os2dll.inc

_IOB_SCAN_LOCK	equ	2	; _iob[] table lock
_TMPNAM_LOCK	equ	3	; lock global tempnam variables
_INPUT_LOCK	equ	4	; lock for _input() routine
_OUTPUT_LOCK	equ	5	; lock for _output() routine
_CSCANF_LOCK	equ	6	; lock for _cscanf() routine
_CPRINTF_LOCK	equ	7	; lock for _cprintf() routine
_CONIO_LOCK	equ	8	; lock for conio routines
_HEAP_LOCK	equ	9	; lock for heap allocator routines
_BHEAP_LOCK	equ	10	; lock for based heap routines
_TIME_LOCK	equ	11	; lock for time functions
_ENV_LOCK	equ	12	; lock for environment variables
_EXIT_LOCK1	equ	13	; lock #1 for exit code
_EXIT_LOCK2	equ	14	; lock #2 for exit code
_THREADDATA_LOCK equ	15	; lock for thread data table
_POPEN_LOCK	equ	16	; lock for _popen/_pclose database
_SSCANF_LOCK	equ	17	; lock for sscanf() iob
_SPRINTF_LOCK	equ	18	; lock for sprintf() iob
_VSPRINTF_LOCK	equ	19	; lock for vsprintf() iob
_LOCKTAB_LOCK	equ	20	; lock to protect semaphore lock table
_OSFHND_LOCK	equ     21	; lock to protect _osfhnd array
_STREAM_LOCKS	equ	21	; Table of stream locks

_LAST_STREAM_LOCK equ	(_STREAM_LOCKS+_NFILE_-1) ; Last stream lock

_FH_LOCKS	equ	(_LAST_STREAM_LOCK+1)	; Table of fh locks
_LAST_FH_LOCK	equ	(_FH_LOCKS+_NFILE_-1)	; Last fh lock

_TOTAL_LOCKS	equ	_LAST_FH_LOCK+1 	; Total number of locks

_LOCK_BIT_INTS	equ	(_TOTAL_LOCKS/(ISIZE*8))+1; # of ints to hold lock bits

;*** THE FH-LOCK TABLE SHOULD REALLY BASED ON __nfile NOT _NFILE_ ***


IFDEF DEBUG
;General multi-thread values
;---------------------------

MAXTHREADID	EQU	32	; max thread id supported
THREADINTS	EQU	(MAXTHREADID/(ISIZE*8)) ; # of ints to hold thread bits

;Semaphore debugging lock structure
;----------------------------------

debug_lock	struc
%	holder	DINT	THREADINTS dup (0) ;bit set for thread holding lock
%	waiters DINT	THREADINTS dup (0) ;bit(s) set for threads waiting
%	lockcnt DINT	0		;total # of times lock has been aquired
%	collcnt DINT	0		;total # of lock collisions
debug_lock	ends

DEBUG_LOCK_SIZE EQU (2*(THREADINTS*ISIZE))+(2*ISIZE) ;size of debug_lock struct
ENDIF


; Tid Table Definitions
; ---------------------

IFDEF	_MT

; Structure for each thread's data
; [NOTE: Tid structure and data must agree with os2dll.h.  In addition,
; startup depends on __stkhqq being the third entry in the structure.]

_tiddata struc
%	__terrno	DINT 0		; errno value
%	__tdoserrno	DINT 0		; _doserrno value
%	__stkhqq	DINT 0		; stack limit
%	__fpds		DINT 0		; Floating Point data segment
%	__holdrand	DLONG 0 	; rand() seed value
%	__token 	DDPTR 0 	; * to strtok() token
	;following pointers get malloc'd at runtime
%	__errmsg	DDPTR 0 	; * to strerror()/_strerror() buffer
%	__namebuf	DDPTR 0 	; * to tmpfile() buffer
%	__asctimebuf	DDPTR 0 	; * to asctime() buffer
%	__gmtimebuf	DDPTR 0 	; * to gmtime() structure
%	__cvtbuf	DDPTR 0 	; * to ecvt()/fcvt() buffer
	;following three values needed by _beginthread code
%	__initaddr	DCPTR 0 	; initial user thread address
%	__initarg	DDPTR 0 	; initial user thread argument
%	__initstksz	DINT 0		; initial stack size (specified by user)
	;following three fields are needed to support signal handling and
	;runtime errors
%	__pxcptacttab	DDPTR 0 	; * to exception-action table
%	__tpxcptinfoptrs DDPTR 0	; * to exception info pointers
%	__tfpecode	DINT 0		; * float point exception code
_tiddata ends

_TIDDATASIZE =	(size _tiddata) 	; size of _tiddata entry (bytes)
_TIDSHIFT =	6			; # of bits to shift to get _TIDSIZE
_TIDSIZE =	(1 shl _TIDSHIFT)	; # of bytes in each tid entry (rounded
					; to next power of two).

_TID_INCSIZE  equ     1000h		; grow thread table a page at a time
_TIDTABGROW = (_TID_INCSIZE/_TIDSIZE)	; table increment (# of tid's per page)
					; (must be power of 2!!!)
_TIDTABMASK = (NOT (_TIDTABGROW -1))	; mask off grow bits

_TID_MAXTID = 1024			; max # of tids supported
_TID_REGSIZE = (_TID_MAXTID * _TIDSIZE) ; size of tid table region

.ERRE (_TIDSIZE GE _TIDDATASIZE)	; make sure _TIDSIZE >= _TIDDATASIZE
.ERRE ((_TIDSIZE SHR 1) LT _TIDDATASIZE); make sure _TIDSIZE/2 < _TIDDATASIZE
.ERRE (_TIDTABGROW GE 1)		; must be at least 1 !!!
.ERRE (_TID_MAXTID GE _TIDTABGROW)	; make sure _TID_MAXTID >= _TIDTABGROW

ENDIF	;_MT

;Declarations
;------------

;Multi-thread Macros
;-------------------

;_mlock -- Aquire a lock
;Arg = lock number

IFDEF	_MT
_mlock		MACRO	locknum
		push	locknum
		call	_lock
		add	rsp,ISIZE
		ENDM
ELSE
_mlock		MACRO	locknum
		ENDM
ENDIF

;_munlock -- Release a lock
;Arg = lock number

IFDEF	_MT
_munlock	MACRO	locknum
		push	locknum
		call	_unlock
		add	rsp,ISIZE
		ENDM
ELSE
_munlock	MACRO	locknum
		ENDM
ENDIF

;_mwait -- Wait for a lock but don't aquire it
;Arg = lock number

IFDEF	_MT
_mwait		MACRO	locknum
		push	locknum
		call	_waitlock
		add	rsp,ISIZE
		ENDM
ELSE
_mwait		MACRO	locknum
		ENDM
ENDIF

;_lock_fh -- Lock file handle
;Arg = file handle

IFDEF	_MT
_lock_fh	MACRO	fh
		push	fh
		call	_lock_file
		add	rsp,ISIZE
		ENDM
ELSE
_lock_fh	MACRO	fh
		ENDM
ENDIF

;_unlock_fh -- Unlock file handle
;Arg = register containing file handle

IFDEF	_MT
_unlock_fh	MACRO	fh
		push	fh
		call	_unlock_file
		add	rsp,ISIZE
		ENDM
ELSE
_unlock_fh	MACRO	fh
		ENDM
ENDIF

;_unlock_fh_check -- Unlock file handle if flag is set
;Args:	reg = register to use in the macro (e.g., ax)
;	file = file handle (e.g., bx or [fh])
;	flag = lock/unlock flag (e.g., [lock_flag])
;	       (0 = no lock/unlock operation)

IFDEF _MT
_unlock_fh_check MACRO	reg,file,flag
		LOCAL	no_unlock	;; local label
		mov	reg,flag	;; get lock flag
		or	reg,reg 	;; test it
		jz	no_unlock	;; 0 = no lock/unlock
		push	file		;; unlock file
		call	_unlock_file
		add	rsp,ISIZE
no_unlock:
		ENDM
ELSE
_unlock_fh_check MACRO	reg,file,flag
		ENDM
ENDIF

;_lock_fh_check -- Lock file handle if flag is set
;Args:	reg = register to use in the macro (e.g., ax)
;	file = file handle (e.g., bx or [fh])
;	flag = lock/unlock flag (e.g., [lock_flag])
;		(0 = no lock/unlock operation)

IFDEF _MT
_lock_fh_check	MACRO	reg,file,flag
		LOCAL	no_lock 	;; local label
		mov	reg,flag	;; get lock flag
		or	reg,reg 	;; test it
		jz	no_unlock	;; 0 = no lock/unlock
		push	file		;; lock the file
		call	_lock_file
		add	rsp,ISIZE
no_lock:
		ENDM
ELSE
_lock_fh_check	MACRO	reg,file,flag
		ENDM
ENDIF

;_lock_str -- Acquire stream lock
;Arg:	str = index of stream in _iob[]

IFDEF _MT
_lock_str	MACRO	str
		push	str
		call	_lock_stream
		add	rsp,ISIZE
		ENDM
ELSE
_lock_str	MACRO	str
		ENDM
ENDIF

;_unlock_str -- Unlock stream
;Arg:	str = index of stream in _iob[]

IFDEF _MT
_unlock_str	MACRO	str
		push	str
		call	_unlock_stream
		add	rsp,ISIZE
		ENDM
ELSE
_unlock_str	MACRO	str
		ENDM
ENDIF

;_dll_mlock -- Aquire a lock (set/clear DS)
;Arg = lock number

IFDEF	_LOAD_DGROUP
IFDEF	_MT
_dll_mlock	MACRO	locknum
		push	locknum
		call	_dll_lock
		add	rsp,ISIZE
		ENDM
ELSE
_dll_mlock	MACRO	locknum
		ENDM
ENDIF
ENDIF

;_dll_munlock -- Release a lock (set/clear DS)
;Arg = lock number

IFDEF	_LOAD_DGROUP
IFDEF	_MT
_dll_munlock	MACRO	locknum
		push	locknum
		call	_dll_unlock
		add	rsp,ISIZE
		ENDM
ELSE
_dll_munlock	MACRO	locknum
		ENDM
ENDIF
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\mrt386.inc ===
;***
;mrt386.inc - include to aid in generating 386 code
;
;	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	This file reproduces a few of the cMacro macros.
;
;Revision History:
;	08-24-88  WAJ	Initial version.
;
;*******************************************************************************



ifdef  I386		    ; Define Near Code Pointer
    DNCPTR  equ     <dd>
else
    DNCPTR  equ     <dw>
endif


ifdef  I386
    if	sizeD
	DPWORD	equ  <fword>
    else
	DPWORD	equ  <dword>
    endif
    DFPWORD  equ  <fword>
    DNPWORD  equ  <dword>

else	;not I386
    if	sizeD
	DPWORD	equ  <dword>
    else
	DPWORD	equ  <word>
    endif
    DFPWORD  equ  <dword>
    DNPWORD  equ  <word>
endif	;not I386


ifdef  I386
    if	sizeC
	CPWORD	equ  <fword>
    else
	CPWORD	equ  <dword>
    endif
    CFPWORD  equ  <fword>
    CNPWORD  equ  <dword>

else	;not I386
    if	sizeC
	CPWORD	equ  <dword>
    else
	CPWORD	equ  <word>
    endif
    CFPWORD  equ  <dword>
    CNPWORD  equ  <word>
endif	;not I386



MOVRW	macro	reg, word   ;; move a word into a register
ifdef  I386
%	movzx	reg, (word)
else
%	mov	reg, (word)
endif
	endm


ifdef  I386
RBXONLY equ	<rbx>
RBXUSED equ	<rbx>

else	;not I386
RBXONLY equ	<nothing>
RBXUSED equ	<>
endif	;not I386


ifdef I386
    ife sizeC
	ife sizeD
	    FLAT386 equ <DEFINED>
	endif
    endif
endif

ifflat	macro code
ifdef  FLAT386
	code
endif
	endm


noflat	macro code
ifndef	FLAT386
	code
endif
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\include\testfdiv.h ===
/***
* testfdiv.h - user include file for detection of flawed Pentium chips.
*
*   Copyright (c) 1994-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   User include file for detection of early steppings of
*   Pentium chips with incorrect FDIV tables.
*
*Revision History:
*	12-19-94  JWM	file added
*	 1-13-95  JWM	underscores added to prototypes for ANSI compatibility
*/


#ifndef _TEST_FDIV
#define _TEST_FDIV

#ifdef __cplusplus
extern "C" {
#endif


int _ms_p5_test_fdiv();
int _ms_p5_mp_test_fdiv();

#ifdef __cplusplus
}
#endif

#endif	/* _TEST_FDIV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\inc\i386\version.inc ===
;***
;version.inc - defines current memory model
;
;   Copyright (c) 1987-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines the current memory model being used.
;
;Revision History:
;   10-22-87  JCR   Single version to handle all four memory models
;   02-11-88  WAJ   Added to math project
;   12-02-88  WAJ   Added definition of CallDist
;   09-22-89  WAJ   Removed CallDist.  Added "ifdef WIN".
;   10-16-89  WAJ   Added "?WIN = 1".
;   11-20-89  WAJ   Added ?QUIET
;
;*******************************************************************************

?PLM = 0

ifdef  WIN
    ?WIN = 1
else
    ?WIN = 0
endif

ifdef  mem_s
    memS    equ     1		    ; small model
endif

ifdef  mem_c
    memC    equ     1		    ; compact model
endif

ifdef  mem_m
    memM    equ     1		    ; medium model
endif

ifdef  mem_l
    memL    equ     1		    ; large model
endif

ifdef  I386
    memS32  equ     1		    ; small 32 bit model
endif

ifdef  QUIET
    ?QUIET  equ     1
endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\include\trans.h ===
/***
*trans.h - definitions for computing transcendentals
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Define constants and macros that are used for computing
*       transcendentals. Some of the definitions are machine dependent.
*       Double is assumed to conform to the IEEE 754 std format.
*
*Revision History:
*       08-14-91  GDP   written
*       10-29-91  GDP   removed unused prototypes, added _frnd
*       01-20-92  GDP   significant changes -- IEEE exc. support
*       03-27-92  GDP   put IEEE definitions in fpieee.h
*       03-31-92  GDP   add internal constants for _ctrlfp, _statfp
*       05-08-92  PLM   added M68K switch
*       05-18-92  XY    added exception macro under M68K switch
*       06-23-92  GDP   added macro for negative zero
*       09-06-92  GDP   include cruntime.h, calling convention macros
*       07-16-93  SRW   ALPHA Merge
*       11-17-93  GJF   Merged in NT SDK version. Replaced MIPS with
*                       _M_MRX000, _ALPHA_ with _M_ALPHA, deleted old M68K
*                       stuff (obsolete).
*       01-13-94  RDL   Added #ifndef _LANGUAGE_ASSEMBLY for asm includes.
*       01-25-94  GJF   Merged in 01-13 change above from Roger Lanser (from
*                       fp32 tree on \\orville\razzle).
*       03-11-94  GJF   Picked up latest changes from Dec (from fp32 tree
*                       on \\orville\razzle for Alpha build).
*       10-02-94  BWT   PPC merge
*       02-06-95  JWM   Mac merge
*       02-07-95  JWM   powhlp() prototype restored to Intel version.
*       10-07-97  RDL   Added IA64.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       10-06-99  PML   Add _W64 modifier to types which are 32 bits in Win32,
*                       64 bits in Win64.
*
*******************************************************************************/

#ifndef _INC_TRANS

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#include <cruntime.h>

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif


#include <fpieee.h>

#define D_BIASM1 0x3fe /* off by one to compensate for the implied bit */

#ifdef B_END
/* big endian */
#define D_EXP(x) ((unsigned short *)&(x))
#define D_HI(x) ((unsigned long *)&(x))
#define D_LO(x) ((unsigned long *)&(x)+1)
#else
#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))
#endif

/* return the int representation of the exponent
 * if x = .f * 2^n, 0.5<=f<1, return n (unbiased)
 * e.g. INTEXP(3.0) == 2
 */
#define INTEXP(x) ((signed short)((*D_EXP(x) & 0x7ff0) >> 4) - D_BIASM1)


/* check for infinity, NAN */
#define D_ISINF(x) ((*D_HI(x) & 0x7fffffff) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_SPECIAL(x) ((*D_EXP(x) & 0x7ff0) == 0x7ff0)
#define IS_D_NAN(x) (IS_D_SPECIAL(x) && !D_ISINF(x))

#ifdef  _M_MRX000

#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
#else

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
#endif

#define IS_D_DENORM(x)  ((*D_EXP(x) & 0x7ff0) == 0  && \
                         (*D_HI(x) << 12 || *D_LO(x)))


#define IS_D_INF(x)  (*D_HI(x) == 0x7ff00000 && *D_LO(x) == 0)
#define IS_D_MINF(x) (*D_HI(x) == 0xfff00000 && *D_LO(x) == 0)


#ifdef  _M_MRX000
#define D_IND_HI 0x7ff7ffff
#define D_IND_LO 0xffffffff
#else
#define D_IND_HI 0xfff80000
#define D_IND_LO 0x0
#endif


typedef union   {
    long lng[2];
    double dbl;
    } _dbl;

extern _dbl _d_inf;
extern _dbl _d_ind;
extern _dbl _d_max;
extern _dbl _d_min;
extern _dbl _d_mzero;

#define D_INF  (_d_inf.dbl)
#define D_IND  (_d_ind.dbl)
#define D_MAX  (_d_max.dbl)
#define D_MIN  (_d_min.dbl)
#define D_MZERO (_d_mzero.dbl)       /* minus zero */

/* min and max exponents for normalized numbers in the
 * form: 0.xxxxx... * 2^exp (NOT 1.xxxx * 2^exp !)
 */
#define MAXEXP 1024
#define MINEXP -1021

#endif  /* #ifndef __assembler */


#if defined(_M_IX86)

/* Control word for computation of transcendentals */
#define ICW        0x133f

#define IMCW       0xffff

#define IMCW_EM         0x003f          /* interrupt Exception Masks */
#define IEM_INVALID     0x0001          /*   invalid */
#define IEM_DENORMAL    0x0002          /*   denormal */
#define IEM_ZERODIVIDE  0x0004          /*   zero divide */
#define IEM_OVERFLOW    0x0008          /*   overflow */
#define IEM_UNDERFLOW   0x0010          /*   underflow */
#define IEM_INEXACT     0x0020          /*   inexact (precision) */


#define IMCW_RC 0x0c00                  /* Rounding Control */
#define IRC_CHOP        0x0c00          /*   chop */
#define IRC_UP          0x0800          /*   up */
#define IRC_DOWN        0x0400          /*   down */
#define IRC_NEAR        0x0000          /*   near */

#define ISW_INVALID     0x0001          /* invalid */
#define ISW_DENORMAL    0x0002          /* denormal */
#define ISW_ZERODIVIDE  0x0004          /* zero divide */
#define ISW_OVERFLOW    0x0008          /* overflow */
#define ISW_UNDERFLOW   0x0010          /* underflow */
#define ISW_INEXACT     0x0020          /* inexact (precision) */

#define IMCW_PC         0x0300          /* Precision Control */
#define IPC_24          0x0000          /*    24 bits */
#define IPC_53          0x0200          /*    53 bits */
#define IPC_64          0x0300          /*    64 bits */

#define IMCW_IC         0x1000          /* Infinity Control */
#define IIC_AFFINE      0x1000          /*   affine */
#define IIC_PROJECTIVE  0x0000          /*   projective */

#elif defined(_M_IA64)

/* Control word for computation of transcendentals */
#define ICW (IMCW_EM | IRC_NEAR | IPC_64)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID | ISW_DENORMAL)
#define IMCW (0xffffffff ^ ISW)

#define IMCW_EM         0x003f          /* interrupt Exception Masks */
#define IEM_INVALID     0x0001          /*   invalid */
#define IEM_DENORMAL    0x0002          /*   denormal */
#define IEM_ZERODIVIDE  0x0004          /*   zero divide */
#define IEM_OVERFLOW    0x0008          /*   overflow */
#define IEM_UNDERFLOW   0x0010          /*   underflow */
#define IEM_INEXACT     0x0020          /*   inexact (precision) */


#define IMCW_RC 0x0c00                  /* Rounding Control */
#define IRC_CHOP        0x0c00          /*   chop */
#define IRC_UP          0x0800          /*   up */
#define IRC_DOWN        0x0400          /*   down */
#define IRC_NEAR        0x0000          /*   near */

#define ISW_INVALID     0x02000         /* invalid */
#define ISW_DENORMAL    0x04000         /* denormal */
#define ISW_ZERODIVIDE  0x08000         /* zero divide */
#define ISW_OVERFLOW    0x10000         /* overflow */
#define ISW_UNDERFLOW   0x20000         /* underflow */
#define ISW_INEXACT     0x40000         /* inexact (precision) */

#define IMCW_PC         0x0300          /* Precision Control */
#define IPC_24          0x0000          /*    24 bits */
#define IPC_53          0x0200          /*    53 bits */
#define IPC_64          0x0300          /*    64 bits */

#elif defined(_M_MRX000)


#define ICW             0x00000f80              /* Internal CW for transcendentals */
#define IMCW            0xffffff83              /* Internal CW Mask */

#define IMCW_EM         0x00000f80              /* interrupt Exception Masks */
#define IEM_INVALID     0x00000800              /*   invalid */
#define IEM_ZERODIVIDE  0x00000400              /*   zero divide */
#define IEM_OVERFLOW    0x00000200              /*   overflow */
#define IEM_UNDERFLOW   0x00000100              /*   underflow */
#define IEM_INEXACT     0x00000080              /*   inexact (precision) */


#define IMCW_RC         0x00000003              /* Rounding Control */
#define IRC_CHOP        0x00000001              /*   chop */
#define IRC_UP          0x00000002              /*   up */
#define IRC_DOWN        0x00000003              /*   down */
#define IRC_NEAR        0x00000000              /*   near */


#define ISW_INVALID     (1<<6)  /* invalid */
#define ISW_ZERODIVIDE  (1<<5)  /* zero divide */
#define ISW_OVERFLOW    (1<<4)  /* overflow */
#define ISW_UNDERFLOW   (1<<3)  /* underflow */
#define ISW_INEXACT     (1<<2)  /* inexact (precision) */


#elif defined(_M_ALPHA)

//
// ICW is the Internal Control Word for transcendentals: all five exceptions
// are masked and round to nearest mode is set. IMCW is the mask: all bits
// are set, except for the ISW bits.
//

#define ICW (IEM_INEXACT | IEM_UNDERFLOW | IEM_OVERFLOW | IEM_ZERODIVIDE | IEM_INVALID | IRC_NEAR)
#define ISW (ISW_INEXACT | ISW_UNDERFLOW | ISW_OVERFLOW | ISW_ZERODIVIDE | ISW_INVALID)
#define IMCW (0xffffffff ^ ISW)

//
// The defines for the internal control word match the format of the Alpha
// AXP software FPCR except for the rounding mode which is obtained from the
// Alpha AXP hardware FPCR and shifted right 32 bits.
//

//
// Internal Exception Mask bits.
// Each bit _disables_ an exception (they are not _enable_ bits).
//

#define IMCW_EM         0x0000003e      /* interrupt Exception Masks */

#define IEM_INEXACT     0x00000020      /*   inexact (precision) */
#define IEM_UNDERFLOW   0x00000010      /*   underflow */
#define IEM_OVERFLOW    0x00000008      /*   overflow */
#define IEM_ZERODIVIDE  0x00000004      /*   zero divide */
#define IEM_INVALID     0x00000002      /*   invalid */

//
// Internal Rounding Control values.
//

#define IMCW_RC         (0x3 << 26)     /* Rounding Control */

#define IRC_CHOP        (0x0 << 26)     /*   chop */
#define IRC_DOWN        (0x1 << 26)     /*   down */
#define IRC_NEAR        (0x2 << 26)     /*   near */
#define IRC_UP          (0x3 << 26)     /*   up */

//
// Internal Status Word bits.
//

#define ISW_INEXACT     0x00200000      /* inexact (precision) */
#define ISW_UNDERFLOW   0x00100000      /* underflow */
#define ISW_OVERFLOW    0x00080000      /* overflow */
#define ISW_ZERODIVIDE  0x00040000      /* zero divide */
#define ISW_INVALID     0x00020000      /* invalid */


#elif defined(_M_PPC)

#define IMCW_EM         0x000000f8      /* Exception Enable Mask    */

#define IEM_INVALID     0x00000080      /*   invalid                */
#define IEM_OVERFLOW    0x00000040      /*   overflow               */
#define IEM_UNDERFLOW   0x00000020      /*   underflow              */
#define IEM_ZERODIVIDE  0x00000010      /*   zero divide            */
#define IEM_INEXACT     0x00000008      /*   inexact (precision)    */


#define IMCW_RC         0x00000003      /* Rounding Control Mask    */

#define IRC_NEAR        0x00000000      /*   near                   */
#define IRC_CHOP        0x00000001      /*   chop                   */
#define IRC_UP          0x00000002      /*   up                     */
#define IRC_DOWN        0x00000003      /*   down                   */


#define IMCW_SW         0x3E000000      /* Status Mask              */

#define ISW_INVALID     0x20000000      /*   invalid summary        */
#define ISW_OVERFLOW    0x10000000      /*   overflow               */
#define ISW_UNDERFLOW   0x08000000      /*   underflow              */
#define ISW_ZERODIVIDE  0x04000000      /*   zero divide            */
#define ISW_INEXACT     0x02000000      /*   inexact (precision)    */


#define IMCW_VX         0x01F80700      /* Invalid Cause Mask       */

#define IVX_SNAN        0x01000000      /*   SNaN                   */
#define IVX_ISI         0x00800000      /*   infinity - infinity    */
#define IVX_IDI         0x00400000      /*   infinity / infinity    */
#define IVX_ZDZ         0x00200000      /*   zero / zero            */
#define IVX_IMZ         0x00100000      /*   infinity * zero        */
#define IVX_VC          0x00080000      /*   inv flpt compare       */
#define IVX_SOFT        0x00000400      /*   software request       */
#define IVX_SQRT        0x00000200      /*   sqrt of negative       */
#define IVX_CVI         0x00000100      /*   inv integer convert    */


/* Internal CW for transcendentals */

#define ICW             (IMCW_EM)

/* Internal CW Mask (non-status bits) */

#define IMCW           (0xffffffff & (~(IMCW_SW|IMCW_VX)))

#endif

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#define RETURN(fpcw,result) return _rstorfp(fpcw),(result)

#define RETURN_INEXACT1(op,arg1,res,cw)                 \
        if (cw & IEM_INEXACT) {                         \
            _rstorfp(cw);                               \
            return res;                                 \
        }                                               \
        else {                                          \
            return _except1(FP_P, op, arg1, res, cw);   \
        }


#define RETURN_INEXACT2(op,arg1,arg2,res,cw)            \
        if (cw & IEM_INEXACT) {                         \
            _rstorfp(cw);                               \
            return res;                                 \
        }                                               \
        else {                                          \
            return _except2(FP_P, op, arg1, arg2, res, cw);     \
        }


#ifdef _M_ALPHA

//
// Since fp32 is not compiled in IEEE exception mode perform Alpha NaN
// propagation in software to avoid hardware/kernel trap involvement.
//

extern double _nan2qnan(double);

#define _d_snan2(x,y)   _nan2qnan(y)
#define _s2qnan(x)      _nan2qnan(x)

#else
//handle NaN propagation
#define _d_snan2(x,y)   ((x)+(y))
#define _s2qnan(x)      ((x)+1.0)
#endif


#define _maskfp() _ctrlfp(ICW, IMCW)
#ifdef  _M_ALPHA
#define _rstorfp(cw) 0
#else
#define _rstorfp(cw) _ctrlfp(cw, IMCW)
#endif


#define ABS(x) ((x)<0 ? -(x) : (x) )


int _d_inttype(double);

#endif  /* #ifndef __assembler */

#define _D_NOINT 0
#define _D_ODD 1
#define _D_EVEN 2


// IEEE exceptions
#define FP_O         0x01
#define FP_U         0x02
#define FP_Z         0x04
#define FP_I         0x08
#define FP_P         0x10

// An extra flag for matherr support
// Set together with FP_I from trig functions when the argument is too large
#define FP_TLOSS     0x20


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */
#ifdef B_END
#define SET_DBL(msw, lsw)     msw, lsw
#else
#define SET_DBL(msw, lsw)     lsw, msw
#endif
#endif  /* #ifndef __assembler */


// special types
#define T_PINF  1
#define T_NINF  2
#define T_QNAN  3
#define T_SNAN  4


// exponent adjustment for IEEE overflow/underflow exceptions
// used before passing the result to the trap handler

#define IEEE_ADJUST 1536

// QNAN values

#define INT_NAN         (~0)

#define QNAN_SQRT       D_IND
#define QNAN_LOG        D_IND
#define QNAN_LOG10      D_IND
#define QNAN_POW        D_IND
#define QNAN_SINH       D_IND
#define QNAN_COSH       D_IND
#define QNAN_TANH       D_IND
#define QNAN_SIN1       D_IND
#define QNAN_SIN2       D_IND
#define QNAN_COS1       D_IND
#define QNAN_COS2       D_IND
#define QNAN_TAN1       D_IND
#define QNAN_TAN2       D_IND
#define QNAN_ACOS       D_IND
#define QNAN_ASIN       D_IND
#define QNAN_ATAN2      D_IND
#define QNAN_CEIL       D_IND
#define QNAN_FLOOR      D_IND
#define QNAN_MODF       D_IND
#define QNAN_LDEXP      D_IND
#define QNAN_FMOD       D_IND
#define QNAN_FREXP      D_IND


/*
 * Function prototypes
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

double _set_exp(double x, int exp);
double _set_bexp(double x, int exp);
double _add_exp(double x, int exp);
double _frnd(double);
double _fsqrt(double);
double _except1(int flags, int opcode, double arg, double res, uintptr_t cw);
double _except2(int flags, int opcode, double arg1, double arg2, double res, uintptr_t cw);
int _sptype(double);
int _get_exp(double);
double _decomp(double, int *);
int _powhlp(double x, double y, double * result);
extern unsigned int _fpstatus;
double _frnd(double);
double _exphlp(double, int *);
double _handle_qnan1(unsigned int op, double arg, uintptr_t cw);
double _handle_qnan2(unsigned int op,double arg1,double arg2,uintptr_t cw);
unsigned int _clhwfp(void);
unsigned int _setfpcw(uintptr_t);
int _errcode(unsigned int flags);
void _set_errno(int matherrtype);
int _handle_exc(unsigned int flags, double * presult, uintptr_t cw);
uintptr_t _clrfp(void);
uintptr_t _ctrlfp(uintptr_t,uintptr_t);
uintptr_t _statfp(void);
void _set_statfp(uintptr_t);

#endif  /* #ifndef __assembler */

#ifdef __cplusplus
}
#endif

#define _INC_TRANS
#endif  /* _INC_TRANS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\asincos.c ===
/***
*asincos.c - inverse sin, cos
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-26-91  GDP   support IEEE exceptions
*       06-23-92  GDP   asin(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(asin, acos)
#endif

static double _asincos(double x, int flag);
static double const a[2] = {
    0.0,
    0.78539816339744830962
};

static double const b[2] = {
    1.57079632679489661923,
    0.78539816339744830962
};

static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */

/* constants for the rational approximation */
static double const p1 = -0.27368494524164255994e+2;
static double const p2 =  0.57208227877891731407e+2;
static double const p3 = -0.39688862997504877339e+2;
static double const p4 =  0.10152522233806463645e+2;
static double const p5 = -0.69674573447350646411e+0;
static double const q0 = -0.16421096714498560795e+3;
static double const q1 =  0.41714430248260412556e+3;
static double const q2 = -0.38186303361750149284e+3;
static double const q3 =  0.15095270841030604719e+3;
static double const q4 = -0.23823859153670238830e+2;
/*  q5 = 1 is not needed (avoid myltiplying by 1) */

#define Q(g)  (((((g + q4) * g + q3) * g + q2) * g + q1) * g + q0)
#define R(g)  (((((p5 * g + p4) * g + p3) * g + p2) * g + p1) * g) / Q(g)

/***
*double asin(double x) - inverse sin
*double acos(double x) - inverse cos
*
*Purpose:
*   Compute arc sin, arc cos.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
*  (denormals are accepted)
*******************************************************************************/
double asin(double x)
{
    return _asincos(x,0);
}

double acos(double x)
{
    return _asincos(x,1);
}

static double _asincos(double x, int flag)
{
    uintptr_t savedcw;
    double qnan;
    int who;
    double y,result;
    double g;
    int i;

    /* save user fp control word */
    savedcw = _maskfp();

    if (flag) {
        who = OP_ACOS;
        qnan = QNAN_ACOS;
    }
    else {
        who = OP_ASIN;
        qnan = QNAN_ASIN;
    }

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,who,x,qnan,savedcw);
        case T_QNAN:
            return _handle_qnan1(who,x,savedcw);
        default: //T_SNAN
            return _except1(FP_I,who,x,_s2qnan(x),savedcw);
        }
    }


    // do test for zero after making sure that x is not special
    // because the compiler does not handle NaNs for the time
    if (x == 0.0 && !flag) {
        RETURN(savedcw, x);
    }

    y = ABS(x);
    if (y < EPS) {
        i = flag;
        result = y;
        if (IS_D_DENORM(result)) {
            // this should only happen for sin(denorm). Use x as a result
            return _except1(FP_U | FP_P,who,x,_add_exp(x, IEEE_ADJUST),savedcw);
        }
    }
    else {
        if (y > .5) {
            i = 1-flag;
            if (y > 1.0) {
                return _except1(FP_I,who,x,qnan,savedcw);
            }
            else if (y == 1.0) {
                /* separate case to avoid domain error in sqrt */
                if (flag && x >= 0.0) {
                    //
                    // acos(1.0) is exactly computed as 0.0
                    //
                    RETURN(savedcw, 0.0);
                }
                y = 0.0;
                g = 0.0;

            }
            else {
                /* now even if y is as close to 1 as possible,
                 * 1-y is still not a denormal.
                 * e.g. for y=3fefffffffffffff, 1-y is about 10^(-16)
                 * So we can speed up division
                 */
                g = _add_exp(1.0 - y,-1);
                /* g and sqrt(g) are not denomrals either,
                 * even in the worst case
                 * So we can speed up multiplication
                 */
                y = _add_exp(-_fsqrt(g),1);
            }
        }
        else {
            /* y <= .5 */
            i = flag;
            g = y*y;
        }
        result = y + y * R(g);
    }

    if (flag == 0) {
        /* compute asin */
        if (i) {
            /* a[i] is non zero if i is nonzero */
            result = (a[i] + result) + a[i];
        }
        if (x < 0)
            result = -result;
    }
    else {
        /* compute acos */
        if (x < 0)
            result = (b[i] + result) + b[i];
        else
            result = (a[i] - result) + a[i];
    }

    RETURN_INEXACT1 (who,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\floor.c ===
/***
*floor.c - floor
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   floor(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);

/***
*double floor(double x) - floor
*
*Purpose:
*   Return a double representing the largest integer that is
*   less than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I, P
*******************************************************************************/
static unsigned int newcw = (ICW & ~IMCW_RC) | (IRC_DOWN & IMCW_RC);


#if !defined(_M_IX86) || defined(_XBOX)
double floor(double x)
#else
double _floor_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round down */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_FLOOR, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FLOOR, x, _s2qnan(x), savedcw);
        }
    }


    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_FLOOR, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\ceil.c ===
/***
*ceil.c - ceiling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   ceil(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);


/***
*double ceil(double x) - ceiling
*
*Purpose:
*   Return a double representing the smallest integer that is
*   greater than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    P, I
*******************************************************************************/
static uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_UP & IMCW_RC);



#if !defined(_M_IX86) || defined(_XBOX)
double ceil(double x)
#else
double _ceil_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round up */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_CEIL, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_CEIL, x, _s2qnan(x), savedcw);
        }
    }

    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_CEIL, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\atan.c ===
/***
*atan.c - arctangent of x and x/y
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-30-91  GDP   support IEEE exceptions
*        3-27-92  GDP   support UNDERFLOW
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(atan, atan2)
#endif

static double _atanhlp(double x);

static double const a[4] = {
    0.0,
    0.52359877559829887308,   /* pi/6 */
    1.57079632679489661923,   /* pi/2 */
    1.04719755119659774615    /* pi/3 */
};

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI_OVER_TWO = 1.57079632679489661923;
static double const PI          = 3.14159265358979323846;
static double const TWO_M_SQRT3 = 0.26794919243112270647;
static double const SQRT3_M_ONE = 0.73205080756887729353;
static double const SQRT3       = 1.73205080756887729353;

/* chose MAX_ARG s.t. 1/MAX_ARG does not underflow */
static double const MAX_ARG     = 4.494232837155790e+307;

/* constants for rational approximation */
static double const p0 = -0.13688768894191926929e+2;
static double const p1 = -0.20505855195861651981e+2;
static double const p2 = -0.84946240351320683534e+1;
static double const p3 = -0.83758299368150059274e+0;
static double const q0 =  0.41066306682575781263e+2;
static double const q1 =  0.86157349597130242515e+2;
static double const q2 =  0.59578436142597344465e+2;
static double const q3 =  0.15024001160028576121e+2;
static double const q4 =  0.10000000000000000000e+1;


#define Q(g)  (((((g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define R(g)  ((((p3 * (g) + p2) * (g) + p1) * (g) + p0) * (g)) / Q(g)

/***
*double atan(double x) - arctangent
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
\*******************************************************************************/
double atan(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            result = PI_OVER_TWO;
            break;
        case T_NINF:
            result = -PI_OVER_TWO;
            break;
        case T_QNAN:
            return _handle_qnan1(OP_ATAN,x,savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_ATAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw,x);

    result = _atanhlp(x);
    RETURN_INEXACT1(OP_ATAN,x,result,savedcw);
}

/***
*double atan2(double x, double y) - arctangent (x/y)
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN or both args 0: DOMAIN error
*******************************************************************************/
double atan2(double v, double u)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(v) || IS_D_SPECIAL(u)){
        if (IS_D_SNAN(v) || IS_D_SNAN(u)){
            return _except2(FP_I,OP_ATAN2,v,u,_d_snan2(v,u),savedcw);
        }
        if (IS_D_QNAN(v) || IS_D_QNAN(u)){
            return _handle_qnan2(OP_ATAN2,v,u,savedcw);
        }
        if ((IS_D_INF(v) || IS_D_MINF(v)) &&
            (IS_D_INF(u) || IS_D_MINF(u))){
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        /* the other combinations of infinities will be handled
         * later by the division v/u
         */
    }


    if (u == 0) {
        if (v == 0) {
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        else {
            result = PI_OVER_TWO;
        }
    }
    else if (INTEXP(v) - INTEXP(u) > MAXEXP - 3) {
        /* v/u overflow */
        result = PI_OVER_TWO;
    }
    else {
        double arg = v/u;


        if (ABS(arg) < D_MIN) {

            if (v == 0.0 || IS_D_INF(u) || IS_D_MINF(u)) {
                result = (u < 0) ? PI : 0;
                if (v < 0) {
                    result = -result;
                }
                if (result == 0) {
                     RETURN(savedcw,  result);
                }
                else {
                     RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }
            }
            else {

                double v1, u1;
                int vexp, uexp;
                int exc_flags;

                //
                // in this case an underflow has occurred
                // re-compute the result in order to raise
                // an IEEE underflow exception
                //

                if (u < 0) {
                    result = v < 0 ? -PI: PI;
                    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }

                v1 = _decomp(v, &vexp);
                u1 = _decomp(u, &uexp);
                result = _add_exp(v1/u1, vexp-uexp+IEEE_ADJUST);
                result = ABS(result);

                if (v < 0) {
                    result = -result;
                }

                // this is not a perfect solution. In the future
                // we may want to have a way to let the division
                // generate an exception and propagate the IEEE result
                // to the user's handler

                exc_flags = FP_U;
                if (_statfp() & ISW_INEXACT) {
                    exc_flags  |= FP_P;
                }
                return _except2(exc_flags,OP_ATAN2,v,u,result,savedcw);

            }
        }

        else {
           result = _atanhlp( ABS(arg) );
        }

    }

    /* set sign of the result */
    if (u < 0) {
        result = PI - result;
    }
    if (v < 0) {
        result = -result;
    }


    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
}





/***
*double _atanhlp(double x) - arctangent helper
*
*Purpose:
*   Compute arctangent of x, assuming x is a valid, non infinite
*   number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
static double _atanhlp(double x)
{
    double f,g,result;
    int n;


    f = ABS(x);
    if (f > MAX_ARG) {
        // if this step is ommited, 1.0/f might underflow in the
        // following block
        return x > 0.0 ? PI_OVER_TWO : -PI_OVER_TWO;
    }
    if (f > 1.0) {
        f = 1.0/f;
        n = 2;
    }
    else {
        n = 0;
    }

    if (f > TWO_M_SQRT3) {
        f = (((SQRT3_M_ONE * f - .5) - .5) + f) / (SQRT3 + f);
        n++;
    }

    if (ABS(f) < EPS) {
        result = f;
    }
    else {
        g = f*f;
        result = f + f * R(g);
    }

    if (n > 1)
        result = -result;

    result += a[n];

    if (x < 0.0)
        result = -result;


    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\fabs.c ===
/***
*fabs.c - absolute value of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       12-10-91  GDP   Domain error for NAN, use fp negation
*        1-13-91  GDP   support IEEE exceptions
*        6-23-92  GDP   fabs(-0) is now +0 (NCEG spec)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if     defined(_M_IX86) || defined(_M_PPC) || defined(_M_IA64)
#pragma function(fabs)
#endif


/***
*double fabs(double x)
*
*Purpose:
*   Compute |x|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I
*
*******************************************************************************/
double fabs(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,-x);
        case T_QNAN:
            return _handle_qnan1(OP_ABS, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_ABS, x, _s2qnan(x), savedcw);
        }
    }


    *D_HI(result) = *D_HI(x) & ~(1<<31);
    *D_LO(result) = *D_LO(x);
    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\fmod.c ===
/***
*fmod.c - floating point remainder
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        3-04-92  GDP   complete rewrite for improved accuracy
*        3-16-92  GDP   restore cw properly, do not raise Inexact exception
*       06-23-92  GDP   support NCEG special return values (signed 0's etc)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(fmod)
#endif

/***
*double fmod(double x, double y)
*
*Purpose:
*   Return f, s.t. x = i*y + f, where i is an integer, f has the same
*   sign as x, and |f| < |y|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I,P
*******************************************************************************/
#define SCALE  53

double fmod(double x, double y)
{
    uintptr_t savedcw;
    int neg=0;
    int denorm=0;
    double d,tx,ty,fx,fy;
    int nx, ny, nexp;



    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(y) || IS_D_SPECIAL(x)){
        if (IS_D_SNAN(y) || IS_D_SNAN(x)){
            return _except2(FP_I,OP_FMOD,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(y) || IS_D_QNAN(x)){
            return _handle_qnan2(OP_FMOD,x,y,savedcw);
        }

        if (IS_D_INF(x) || IS_D_MINF(x)) {
            return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
        }

        RETURN(savedcw, x);
    }


    if (y == 0) {
        return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
    }

    if (x == 0) {
        RETURN(savedcw, x);      // NCEG spec
    }


    if (x < 0) {
        tx = -x;
        neg = 1;
    }
    else {
        tx = x;
    }

    ty = ABS(y);


    while (tx >= ty) {
        fx = _decomp(tx, &nx);
        fy = _decomp(ty, &ny);

        if (nx < MINEXP) {
            // tx is a denormalized number
            denorm = 1;
            nx += SCALE;
            ny += SCALE;
            tx = _set_exp(fx, nx);
            ty = _set_exp(fy, ny);
        }


        if (fx >= fy) {
            nexp = nx ;
        }
        else {
            nexp = nx - 1;
        }
        d = _set_exp(fy, nexp);
        tx -= d;
    }

    if (denorm) {

        //
        // raise only FP_U exception
        //

        return _except2(FP_U,
                        OP_FMOD,
                        x,
                        y,
                        _add_exp(tx, IEEE_ADJUST-SCALE),
                        savedcw);
    }

    if (neg) {
        tx = -tx;
    }

    RETURN(savedcw,tx);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\bessel.c ===
/***
*bessel.c - defines the bessel functions for C.
*
*       Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*  This is a collection of routines for computing the bessel functions j0, j1,
*  y0, y1, jn and yn.  The approximations used for j0, j1, y0, and y1 are
*  from the approximations listed in Hart, Computer Approximations, 1978.
*  For these functions, a rational approximation with 18 places of accuracy
*  after the decimal point has been selected.  jn and yn are computed using
*  the recursive formula that the bessel functions satisfy.  Using these
*  formulas their values can be computed from the values of the bessel
*  functions of order 0 and 1.  In the case of jn, the recursive formula
*
*                 jn(n-1,x) = (2.0*n/x)*jn(n,x) - jn(n+1,x)
*
*  is used to stabily compute in the downward direction, normalizing in the
*  the end by j0(x) in the usual manner.  In the case of yn, the recursive
*  formula
*
*                 yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
*
*  is used to stably compute the functions in the forward direction.
*
*
*  Note: upon testing and experimentation the low range approximations were
*        found to have an error on the order of 1.0e-14 in the neighborhood of
*        8.0.  Moving the boundary point between the low range and high
*        range approximations down to 7.5 reduced this error to less than
*        1.0e-14.  This is not suprising.  The high range asymptotoic is
*        likely to have greater precision in the neighborhood of 8.0.
*
*Revision History:
*
*       06/05/89  WAJ   Added this header. Made changes for C6 and -W3
*       06/06/89  WAJ   Moved some of the routines into _RTEXT if MTHREAD.
*       08/17/90  WAJ   Now uses _stdcall.
*       01/13/92  GDP   changed domain_err. No full IEEE support yet
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       08-28-96  JWM   Disabled warning 4056.
*
*******************************************************************************/


/*
 *  The functions sqrt, sin, cos, and log from the math library are used in
 *  the computations of the bessel functions.
 */

#include <math.h>
#include <trans.h>

#ifdef _M_IX86
#pragma warning(disable:4056)
#endif

#ifdef _X86SEG_
#include <os2supp.h>
#define _CALLTYPE1 _PASCAL
#else
#include <cruntime.h>
#endif

#ifdef LD_VER
#define D_TYPE  long double

#else
#define D_TYPE  double
#endif



static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 ); /* error routine for y0, y1, yn */
static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 );


#ifdef FAR_CODE
    #ifdef LD_VER
        #pragma alloc_text( _RTEXT, _y0l, _y1l, _ynl, _j0l, _j1l, _jnl )
    #else
        #pragma alloc_text( _RTEXT, _y0, _y1, _yn, _j0, _j1, _jn )
    #endif
#endif



/*
 *  Following are the constants needed for the computations of the bessel
 *  functions as in Hart.
 */

#define PI 3.14159265358979323846264338327950288


/* coefficients for Hart JZERO 5848, the low range approximation for _j0 */

static D_TYPE J0p[12] = {
                         0.1208181340866561224763662419e+12 ,
                        -0.2956513002312076810191727211e+11 ,
                         0.1729413174598080383355729444e+10 ,
                        -0.4281611621547871420502838045e+08 ,
                         0.5645169313685735094277826749e+06 ,
                        -0.4471963251278787165486324342e+04 ,
                         0.2281027164345610253338043760e+02 ,
                        -0.7777570245675629906097285039e-01 ,
                         0.1792464784997734953753734861e-03 ,
                        -0.2735011670747987792661294323e-06 ,
                         0.2553996162031530552738418047e-09 ,
                        -0.1135416951138795305302383379e-12
                        };

static D_TYPE J0q[5] =  {
                        0.1208181340866561225104607422e+12 ,
                        0.6394034985432622416780183619e+09 ,
                        0.1480704129894421521840387092e+07 ,
                        0.1806405145147135549477896097e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart 6548, P0 of the high range approximation for j0
   and _y0 */

static D_TYPE P0p[6] =  {
                        0.2277909019730468430227002627e+05 ,
                        0.4134538663958076579678016384e+05 ,
                        0.2117052338086494432193395727e+05 ,
                        0.3480648644324927034744531110e+04 ,
                        0.1537620190900835429577172500e+03 ,
                        0.8896154842421045523607480000e+00
                        };

static D_TYPE P0q[6] =  {
                        0.2277909019730468431768423768e+05 ,
                        0.4137041249551041663989198384e+05 ,
                        0.2121535056188011573042256764e+05 ,
                        0.3502873513823560820735614230e+04 ,
                        0.1571115985808089364906848200e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart 6948, Q0 of the high range approximation for _j0
   and _y0 */

static D_TYPE Q0p[6] =  {
                        -0.8922660020080009409846916000e+02 ,
                        -0.1859195364434299380025216900e+03 ,
                        -0.1118342992048273761126212300e+03 ,
                        -0.2230026166621419847169915000e+02 ,
                        -0.1244102674583563845913790000e+01 ,
                        -0.8803330304868075181663000000e-02
                        };

static D_TYPE Q0q[6] =  {
                        0.5710502412851206190524764590e+04 ,
                        0.1195113154343461364695265329e+05 ,
                        0.7264278016921101883691345060e+04 ,
                        0.1488723123228375658161346980e+04 ,
                        0.9059376959499312585881878000e+02 ,
                        0.1e+01
                        };



/* coefficients for Hart JONE 6047, the low range approximation for _j1 */

static D_TYPE J1p[11] = {
                         0.4276440148317146125749678272e+11 ,
                        -0.5101551390663600782363700742e+10 ,
                         0.1928444249391651825203957853e+09 ,
                        -0.3445216851469225845312168656e+07 ,
                         0.3461845033978656620861683039e+05 ,
                        -0.2147334276854853222870548439e+03 ,
                         0.8645934990693258061130801001e+00 ,
                        -0.2302415336775925186376173217e-02 ,
                         0.3991878933072250766608485041e-05 ,
                        -0.4179409142757237977587032616e-08 ,
                         0.2060434024597835939153003596e-11
                        };


 static D_TYPE J1q[5] = {
                        0.8552880296634292263013618479e+11 ,
                        0.4879975894656629161544052051e+09 ,
                        0.1226033111836540909388789681e+07 ,
                        0.1635396109098603257687643236e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart PONE 6749, P1 of the high range approximation for
   _j1 and y1 */

static D_TYPE P1p[6] =  {
                        0.3522466491336797983417243730e+05 ,
                        0.6275884524716128126900567500e+05 ,
                        0.3135396311091595742386698880e+05 ,
                        0.4985483206059433843450045500e+04 ,
                        0.2111529182853962382105718000e+03 ,
                        0.1257171692914534155849500000e+01
                        };

static D_TYPE P1q[6] =  {
                        0.3522466491336797980683904310e+05 ,
                        0.6269434695935605118888337310e+05 ,
                        0.3124040638190410399230157030e+05 ,
                        0.4930396490181088978386097000e+04 ,
                        0.2030775189134759322293574000e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart QONE 7149, Q1 of the high range approximation for _j1
   and y1 */

static D_TYPE Q1p[6] =  {
                        0.3511751914303552822533318000e+03 ,
                        0.7210391804904475039280863000e+03 ,
                        0.4259873011654442389886993000e+03 ,
                        0.8318989576738508273252260000e+02 ,
                        0.4568171629551226706440500000e+01 ,
                        0.3532840052740123642735000000e-01
                        };

static D_TYPE Q1q[6] =  {
                        0.7491737417180912771451950500e+04 ,
                        0.1541417733926509704998480510e+05 ,
                        0.9152231701516992270590472700e+04 ,
                        0.1811186700552351350672415800e+04 ,
                        0.1038187587462133728776636000e+03 ,
                        0.1e+01
                        };


/* coeffiecients for Hart YZERO 6245, the low range approximation for y0 */

static D_TYPE Y0p[9] =  {
                        -0.2750286678629109583701933175e+20 ,
                         0.6587473275719554925999402049e+20 ,
                        -0.5247065581112764941297350814e+19 ,
                         0.1375624316399344078571335453e+18 ,
                        -0.1648605817185729473122082537e+16 ,
                         0.1025520859686394284509167421e+14 ,
                        -0.3436371222979040378171030138e+11 ,
                         0.5915213465686889654273830069e+08 ,
                        -0.4137035497933148554125235152e+05
                        };

static D_TYPE Y0q[9] =  {
                        0.3726458838986165881989980739e+21 ,
                        0.4192417043410839973904769661e+19 ,
                        0.2392883043499781857439356652e+17 ,
                        0.9162038034075185262489147968e+14 ,
                        0.2613065755041081249568482092e+12 ,
                        0.5795122640700729537480087915e+09 ,
                        0.1001702641288906265666651753e+07 ,
                        0.1282452772478993804176329391e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart YONE 6444, the low range approximation for y1 */

static D_TYPE Y1p[8] =  {
                        -0.2923821961532962543101048748e+20 ,
                         0.7748520682186839645088094202e+19 ,
                        -0.3441048063084114446185461344e+18 ,
                         0.5915160760490070618496315281e+16 ,
                        -0.4863316942567175074828129117e+14 ,
                         0.2049696673745662182619800495e+12 ,
                        -0.4289471968855248801821819588e+09 ,
                         0.3556924009830526056691325215e+06
                        };


static D_TYPE Y1q[9] =  {
                        0.1491311511302920350174081355e+21 ,
                        0.1818662841706134986885065935e+19 ,
                        0.1131639382698884526905082830e+17 ,
                        0.4755173588888137713092774006e+14 ,
                        0.1500221699156708987166369115e+12 ,
                        0.3716660798621930285596927703e+09 ,
                        0.7269147307198884569801913150e+06 ,
                        0.1072696143778925523322126700e+04 ,
                        0.1e+01
                        };



/*
 *  Function name:  evaluate
 *
 *  Arguments:      x  -  double
 *                  p, q  -  double arrays of coefficients
 *                  n1, n2  -  the order of the numerator and denominator
 *                             polynomials
 *
 *  Description:    evaluate is meant strictly as a helper routine for the
 *                  bessel function routines to evaluate the rational polynomial
 *                  aproximations appearing in _j0, _j1, y0, and y1.  Given the
 *                  coefficient arrays in p and q, it evaluates the numerator
 *                  and denominator polynomials through orders n1 and n2
 *                  respectively, returning p(x)/q(x).  This routine is not
 *                  available to the user of the bessel function routines.
 *
 *  Side Effects:   evaluate uses the global data stored in the coefficients
 *                  above.  No other global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 )
{
D_TYPE  numerator, denominator;
int     i;

    numerator = x*p[n1];
    for ( i = n1-1 ; i > 0 ; i-- )
        numerator = x*(p[i] + numerator);
    numerator += p[0];

    denominator = x*q[n2];
    for ( i = n2-1 ; i > 0 ; i-- )
        denominator = x*(q[i] + denominator);
    denominator += q[0];

    return( numerator/denominator );
}


/*
 *  Function name:  _j0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j0 computes the bessel function of the first kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  double precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _
cdecl _j0l( D_TYPE x )
#else
    D_TYPE __cdecl _j0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;

    /* if the argument is negative, take the absolute value */

    if ( x < 0.0 )
        x = - x;

    /* if x <= 7.5  use Hart JZERO 5847 */

    if ( x <= 7.5 )
        return( evaluate( x*x, J0p, 11, J0q, 4) );

    /* else if x >= 7.5  use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*cos(x-PI/4) - Q0*sin(x-PI/4)) );
        }
}


/*
 *  Function name:  _j1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j1 computes the bessel function of the first kind of the
 *                  first order for real values of its argument x, where x can
 *                  range from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  D_TYPE precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _j1l( D_TYPE x )
#else
    D_TYPE __cdecl _j1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;
int     sign;

     /* if the argument is negative, take the absolute value and set sign */

     sign = 1;
     if( x < 0.0 ){
        x = -x;
        sign = -1;
        }

     /* if x <= 7.5  use Hart JONE 6047 */

     if ( x <= 7.5 )
        return( sign*x*evaluate( x*x, J1p, 10, J1q, 4) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return( sign*sqrt(2.0/(PI*x))*
                           ( P1*cos(x-3.0*PI/4.0) - Q1*sin(x-3.0*PI/4.0) )  );
        }
}



/*
 *  Function name:  _y0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y0 computes the bessel function of the second kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y0l( D_TYPE x )
#else
    D_TYPE __cdecl _y0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y0 , x, D_IND) );


    /* if x <= 7.5 use Hart YZERO 6245, the low range approximation */

    if ( x <= 7.5 )
        return( evaluate( x*x, Y0p, 8, Y0q, 8) + (2.0/PI)*_j0(x)*log(x) );


    /* else if x > 7.5 use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*sin(x-PI/4) + Q0*cos(x-PI/4)) );
        }
}


/*
 *  Function name:  _y1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y1 computes the bessel function of the second kind of first
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y1l( D_TYPE x )
#else
    D_TYPE __cdecl _y1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y1, x, D_IND) );

    /* if x <= 7.5  use Hart YONE 6444, the low range approximation */

    if ( x <= 7.5 )
        return( x*evaluate( x*x, Y1p, 7, Y1q, 8)
                               + (2.0/PI)*(_j1(x)*log(x) - 1.0/x) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return(  sqrt(2.0/(PI*x))*
                         ( P1*sin(x-3.0*PI/4.0) + Q1*cos(x-3.0*PI/4.0) )   );
        }
}


/*
 *  Function name:  _jn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    _jn computes the bessel function of the first kind of order
 *                  n for real values of its argument, where x can range from
 *                  - infinity to + infinity, and n can range over the integers
 *                  from - infinity to + infinity.  The function is computed
 *                  by recursion, using the formula
 *
 *                               _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)
 *
 *                  stabilly in the downward direction, normalizing by _j0(x)
 *                  in the end in the usual manner.
 *
 *  Side Effects:   the routines _j0, y0, and yn are called during the
 *                  execution of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              07/29/85        Greg Whitten
 *                              rewrote _jn to use Hart suggested algorithm
 */

#ifdef  LD_VER
    D_TYPE _cdecl _jnl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _jn( int n, D_TYPE x )
#endif
{
int     i;
D_TYPE  x2, jm1, j, jnratio, hold;

    /*  use symmetry relationships:  _j(-n,x) = _j(n,-x) */

    if( n < 0 ){
        n = -n;
        x = -x;
        }

    /*  if n = 0 use _j0(x) and if n = 1 use _j1(x) functions */

    if (n == 0)
        return (_j0(x));

    if (n == 1)
        return (_j1(x));

    /*  if x = 0.0 then _j(n,0.0) = 0.0 for n > 0   (_j(0,x) = 1.0) */

    if (x == 0.0)
        return (0.0);

    /*  otherwise - must use the recurrence relation
     *
     *      _jn(n+1,x) = (2.0*n/x)*_jn(n,x) - _jn(n-1,x)  forward
     *      _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)  backward
     */

    if( (double)n < fabs(x) ) {

        /*  stably compute _jn using forward recurrence above */

        n <<= 1;  /* n *= 2  (n is positive) */
        jm1 = _j0(x);
        j = _j1(x);
        i = 2;
        for(;;) {
            hold = j;
            j = ((double)(i))*j/x - jm1;
            i += 2;
            if (i == n)
                return (j);
            jm1 = hold;
            }
        }
    else {
        /*  stably compute _jn using backward recurrence above */

        /*  use Hart continued fraction formula for j(n,x)/j(n-1,x)
         *  so that we can compute a normalization factor
         */

        n <<= 1;                /* n *= 2  (n is positive) */
        x2 = x*x;
        hold = 0.0;             /* initial continued fraction tail value */
        for (i=n+36; i>n; i-=2)
            hold = x2/((double)(i) - hold);
        jnratio = j = x/((double)(n) - hold);
        jm1 = 1.0;

        /*  have jn/jn-1 ratio - now use backward recurrence */

        i = n-2;
        for (;;) {
            hold = jm1;
            jm1 = ((double)(i))*jm1/x - j;
            i -= 2;
            if (i == 0)
                    break;
            j = hold;
            }

        /*  jm1 is relative j0(x) so normalize it for final result
         *
         *  jnratio = K*j(n,x) and jm1 = K*_j0(x)
         */

        return(_j0(x)*jnratio/jm1);
        }
}


/*
 *  Function name:  _yn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    yn computes the bessel function of the second kind of order
 *                  n for real values of its argument x, where x can range from
 *                  0 to + infinity, and n can range over the integers from
 *                  - infinity to + infinity. The function is computed by
 *                  recursion from y0 and y1, using the recursive formula
 *
 *                          yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
 *
 *                  in the forward direction.
 *
 *  Side Effects:   the routines y0 and y1 are called during the execution
 *                  of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              08/09/85        Greg Whitten
 *                              added check for n==0 and n==1
 *              04/20/87        Barry McCord
 *                              eliminated use of "const" as an identifier for ANSI conformance
 */

#ifdef  LD_VER
    D_TYPE _cdecl _ynl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _yn( int n, D_TYPE x )
#endif
{
int     i;
int     sign;
D_TYPE  constant, yn2, yn1, yn0;


    /* if the argument is negative, set EDOM error, print an error message,
         * and return -HUGE
         */

    if (x < 0.0)
        return(domain_err(OP_YN, x, D_IND));


     /* take the absolute value of n, and set sign accordingly */

     sign = 1;
     if( n < 0 ){
        n = -n;
        if( n&1 )
            sign = -1;
        }

     if( n == 0 )
        return( sign*_y0(x) );

     if (n == 1)
        return( sign*_y1(x) );

     /* otherwise go ahead and compute the function by iteration */

     yn0 = _y0(x);
     yn1 = _y1(x);

     constant = 2.0/x;
     for( i = 1 ; i < n ; i++ ){
        yn2 = constant*i*yn1 - yn0;
        yn0 = yn1;
        yn1 = yn2;
        }
     return( sign*yn2 );
}


static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 )
{
#ifdef  LD_VER
#error long double version not supported
#endif

    uintptr_t savedcw;
    savedcw = _maskfp();
    return _except1(FP_I, who, arg1, arg2, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\exp.c ===
/***
*exp.c - exponential
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute exp(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-21-91  GDP   support IEEE exceptions
*       02-03-92  GDP   added _exphlp for use by exp, sinh, and cosh
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(exp)
#endif

double _exphlp(double, int *);

/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double.
 * OVFX: ln(XMAX * 2^IEEE_ADJ)
 * UFLX: ln(XIN * 2^(-IEEE_ADJ)
 */

static _dbl const ovfx = {SET_DBL(0x40862e42, 0xfefa39f8)}; /*  709.782712893385 */
static _dbl const uflx = {SET_DBL(0xc086232b, 0xdd7abcda)};     /* -708.396418532265 */

#define OVFX    ovfx.dbl
#define UFLX    uflx.dbl


static double const  EPS    =  5.16987882845642297e-26;   /* 2^(-53) / 2 */
static double const  LN2INV =  1.442695040889634074;      /* 1/ln(2) */
static double const  C1     =  0.693359375000000000;
static double const  C2     = -2.1219444005469058277e-4;

/* constants for the rational approximation */
static double const p0 = 0.249999999999999993e+0;
static double const p1 = 0.694360001511792852e-2;
static double const p2 = 0.165203300268279130e-4;
static double const q0 = 0.500000000000000000e+0;
static double const q1 = 0.555538666969001188e-1;
static double const q2 = 0.495862884905441294e-3;

#define P(z)  ( (p2 * (z) + p1) * (z) + p0 )
#define Q(z)  ( (q2 * (z) + q1) * (z) + q0 )

/***
*double exp(double x) - exponential
*
*Purpose:
*   Compute the exponential of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions: O, U, P, I
*
*******************************************************************************/

double exp (double x)
{
    uintptr_t savedcw;
    int newexp;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,0.0);
        case T_QNAN:
            return _handle_qnan1(OP_EXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_EXP, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw, 1.0);
    }

    if (x > OVFX) {

        // even after scaling the exponent of the result,
        // it is still too large.
        // Deliver infinity to the trap handler

        return _except1(FP_O | FP_P, OP_EXP, x, D_INF, savedcw);
    }

    if (x < UFLX) {

        // even after scaling the exponent of the result,
        // it is still too small.
        // Deliver 0 to the trap handler

        return _except1(FP_U | FP_P, OP_EXP, x, 0.0, savedcw);
    }

    if (ABS(x) < EPS) {
        result = 1.0;
    }

    else {
        result = _exphlp(x, &newexp);
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O | FP_P, OP_EXP, x, result, savedcw);
        }
        else if (newexp < MINEXP) {
            result = _set_exp(result, newexp+IEEE_ADJUST);
            return _except1(FP_U | FP_P, OP_EXP, x, result, savedcw);
        }
        else
            result = _set_exp(result, newexp);
    }

    RETURN_INEXACT1(OP_EXP, x, result, savedcw);
}




/***
*double _exphlp(double x, int * pnewexp) - exp helper routine
*
*Purpose:
*   Provide the mantissa and  the exponent of e^x
*
*Entry:
*   x : a (non special) double precision number
*
*Exit:
*   *newexp: the exponent of e^x
*   return value: the mantissa m of e^x scaled by a factor
*                 (the value of this factor has no significance.
*                  The mantissa can be obtained with _set_exp(m, 0).
*
*   _set_exp(m, *pnewexp) may be used for constructing the final
*   result, if it is within the representable range.
*
*Exceptions:
*   No exceptions are raised by this function
*
*******************************************************************************/



double _exphlp(double x, int * pnewexp)
{

    double xn;
    double g,z,gpz,qz,rg;
    int n;

    xn = _frnd(x * LN2INV);
    n = (int) xn;

    /* assume guard digit is present */
    g = (x - xn * C1) - xn * C2;
    z = g*g;
    gpz = g * P(z);
    qz = Q(z);
    rg = 0.5 + gpz/(qz-gpz);

    n++;

    *pnewexp = _get_exp(rg) + n;
    return rg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\fpexcept.c ===
/***
*fpexcept.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-24-91  GDP   written
*       09-26-91  GDP   changed DOMAIN error handling
*       10-10-91  GDP   use fp addition for propagating NaNs
*       01-14-92  GDP   IEEE exception support
*       03-20-92  GDP   major changes, reorganized code
*       03-31-92  GDP   new interface, use internal fp control functions
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version. Cleaned up preprocessing
*                       conditional: replaced #if _NTSUBSET_ with #ifdef
*                       _NTSUBSET_, i386 with _M_IX86, MIPS with _M_MRX000,
*                       _ALPHA_ with _M_ALPHA.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       09-05-94  SKS   Change another #ifdef i386 to #ifdef _M_IX86
*       10-02-94  BWT   PPC merge and change NTSUBSET includes to use nt.h
*       02-19-95  BWT   Define _KERNEL32_ before including windows.h for _NTSUBSET_
*                       build (otherwise declspec(dllimport) will be on for
*                       RaiseException)
*       03-29-95  BWT   Add casts to fix warnings.
*       05-10-96  BWT   POSIX fix
*       06-21-00  GB    Add OP_LOGB in _get_fname.
*
*******************************************************************************/

#if defined(_NTSUBSET_) || defined (_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _KERNEL32_          // Don't Export RaiseException
#endif  // _NTSUBSET_


#include <trans.h>
#include <errno.h>
#include <math.h>
#ifdef _XBOX
#include <xtl.h>
#else !_XBOX
#include <windows.h>
#endif !_XBOX

#ifdef  _NTSUBSET_
VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST DWORD_PTR *lpArguments
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);

}
#endif  // _NTSUBSET_


//
// copy a double without generating floating point instructions
// (avoid invalid operation on x87)
//

#define COPY_DOUBLE(pdest, psrc) \
      ( *(unsigned int *)pdest = *(unsigned int *)psrc,   \
        *((unsigned int *)pdest+1) = *((unsigned int *)psrc+1) )



//
// _matherr_flag is a communal variable. It is equal to zero
// if the user has redefined matherr(). Otherwise it has a
// non zero value. The default matherr routine does nothing
// and returns 0.
//

int _matherr_flag;

//
// a routine for artificially setting the fp status bits in order
// to signal a software generated masked fp exception.
//

extern void _set_statfp(uintptr_t);


void _raise_exc(_FPIEEE_RECORD *prec,uintptr_t *pcw,
    int flags, int opcode, double *parg1, double *presult);

double _umatherr(int type, unsigned int opcode,
                 double arg1, double arg2, double presult,
                 uintptr_t cw);

static char *_get_fname(unsigned int opcode);

/***
* _handle_qnan1, _handle_qnan2 - handle quiet NaNs as function arguments
*
*Purpose:
*   Do all necessary work for handling the case where the argument
*   or one of the arguments of a floating point function is a quiet NaN
*
*Entry:
*   unsigned int opcode: The operation code of the fp function
*   double x: the fp function argument
*   double y: the fp function second argument (_handle_qnan2 only)
*   uintptr_t savedcw: the user's control word
*
*Exit:
*   restore the user's control word,  and
*   return the suggested return value for the fp function
*
*Exceptions:
*
*******************************************************************************/

double _handle_qnan1(unsigned int opcode,
                     double x,
                     uintptr_t savedcw)
{
    if (! _matherr_flag) {

        //
        // QNaN arguments are treated as domain errors
        // invoke the user's matherr routine
        // _umatherr will take care of restoring the
        // user's control word
        //

        return _umatherr(_DOMAIN,opcode,x,0.0,x,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return x;
    }
}


double _handle_qnan2(unsigned int opcode,
                     double x,
                     double y,
                     uintptr_t savedcw)
{
    double result;

    //
    // NaN propagation should be handled by the underlying fp h/w
    //

    result = x+y;

    if (! _matherr_flag) {
        return _umatherr(_DOMAIN,opcode,x,y,result,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return result;
    }
}



/***
* _except1 - exception handling shell for fp functions with one argument
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg: the argument of the fp function
*   double result: default result
*   uintptr_t cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except1(int flags,
                int opcode,
                double arg,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // At this point _handle_exception has failed to deal
        // with the error
        // An IEEE exception should be raised
        //

        _FPIEEE_RECORD rec;

        // The rec structure will be filled in by _raise_exc,
        // except for the Operand2 information

        rec.Operand2.OperandValid = 0;
        _raise_exc(&rec, &cw, flags, opcode, &arg, &result);
    }


    //
    // At this point we have either the masked response of the
    // exception, or a value supplied by the user's IEEE exception
    // handler. The _matherr mechanism is supported for backward
    // compatibility.
    //

    type = _errcode(flags);

    // Inexact result fp exception does not have a matherr counterpart;
    // in that case type is 0.

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg, 0.0, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _except2 - exception handling shell for fp functions with two arguments
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg1: the first argument of the fp function
*   double arg2: the second argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except2(int flags,
                int opcode,
                double arg1,
                double arg2,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // trap should be taken
        //

        _FPIEEE_RECORD rec;

        //
        // fill in operand2 info. The rest of rec will be
        // filled in by _raise_exc
        //

        rec.Operand2.OperandValid = 1;
        rec.Operand2.Format = _FpFormatFp64;
        rec.Operand2.Value.Fp64Value = arg2;

        _raise_exc(&rec, &cw, flags, opcode, &arg1, &result);

    }

    type = _errcode(flags);

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg1, arg2, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _raise_exc - raise fp IEEE exception
*
*Purpose:
*   fill in an fp IEEE record struct and raise a fp exception
*
*
*Entry / Exit:
*   IN _FPIEEE_RECORD prec   pointer to an IEEE record
*   IN OUT unsigned int *pcw     pointer to user's fp control word
*   IN int flags,       exception flags
*   IN int opcode,      fp operation code
*   IN double *parg1,        pointer to first argument
*   IN double *presult)      pointer to result
*
*Exceptions:
*
*******************************************************************************/

void _raise_exc( _FPIEEE_RECORD *prec,
                 uintptr_t *pcw,
                 int flags,
                 int opcode,
                 double *parg1,
                 double *presult)
{
    DWORD exc_code;
    uintptr_t sw;

    //
    // reset all control bits
    //

    *(int *)&(prec->Cause) = 0;
    *(int *)&(prec->Enable) = 0;
    *(int *)&(prec->Status) = 0;

    //
    // Precision exception may only coincide with overflow
    // or underflow. If this is the case, overflow (or
    // underflow) take priority over precision exception.
    // The order of checks is from the least important
    // to the most important exception
    //

    if (flags & FP_P) {
        exc_code = (DWORD) STATUS_FLOAT_INEXACT_RESULT;
        prec->Cause.Inexact = 1;
    }
    if (flags & FP_U) {
        exc_code = (DWORD) STATUS_FLOAT_UNDERFLOW;
        prec->Cause.Underflow = 1;
    }
    if (flags & FP_O) {
        exc_code = (DWORD) STATUS_FLOAT_OVERFLOW;
        prec->Cause.Overflow = 1;
    }
    if (flags & FP_Z) {
        exc_code = (DWORD) STATUS_FLOAT_DIVIDE_BY_ZERO;
        prec->Cause.ZeroDivide = 1;
    }
    if (flags & FP_I) {
        exc_code = (DWORD) STATUS_FLOAT_INVALID_OPERATION;
        prec->Cause.InvalidOperation = 1;
    }


    //
    // Set exception enable bits
    //

    prec->Enable.InvalidOperation = (*pcw & IEM_INVALID) ? 0 : 1;
    prec->Enable.ZeroDivide = (*pcw & IEM_ZERODIVIDE) ? 0 : 1;
    prec->Enable.Overflow = (*pcw & IEM_OVERFLOW) ? 0 : 1;
    prec->Enable.Underflow = (*pcw & IEM_UNDERFLOW) ? 0 : 1;
    prec->Enable.Inexact = (*pcw & IEM_INEXACT) ? 0 : 1;


    //
    // Set status bits
    //

    sw = _statfp();


    if (sw & ISW_INVALID) {
        prec->Status.InvalidOperation = 1;
    }
    if (sw & ISW_ZERODIVIDE) {
        prec->Status.ZeroDivide = 1;
    }
    if (sw & ISW_OVERFLOW) {
        prec->Status.Overflow = 1;
    }
    if (sw & ISW_UNDERFLOW) {
        prec->Status.Underflow = 1;
    }
    if (sw & ISW_INEXACT) {
        prec->Status.Inexact = 1;
    }


    switch (*pcw & IMCW_RC) {
    case IRC_CHOP:
        prec->RoundingMode = _FpRoundChopped;
        break;
    case IRC_UP:
        prec->RoundingMode = _FpRoundPlusInfinity;
        break;
    case IRC_DOWN:
        prec->RoundingMode = _FpRoundMinusInfinity;
        break;
    case IRC_NEAR:
        prec->RoundingMode = _FpRoundNearest;
        break;
    }

#ifdef _M_IX86

    switch (*pcw & IMCW_PC) {
    case IPC_64:
        prec->Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        prec->Precision = _FpPrecision53;
        break;
    case IPC_24:
        prec->Precision = _FpPrecision24;
        break;
    }

#endif


#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
    prec->Precision = _FpPrecision53;
#endif

    prec->Operation = opcode;

    prec->Operand1.OperandValid = 1;
    prec->Operand1.Format = _FpFormatFp64;
    prec->Operand1.Value.Fp64Value = *parg1;

    prec->Result.OperandValid = 1;
    prec->Result.Format = _FpFormatFp64;
    prec->Result.Value.Fp64Value = *presult;

    //
    // By convention software exceptions use the first exception
    // parameter in order to pass a pointer to the _FPIEEE_RECORD
    // structure.
    //

    _clrfp();

    RaiseException(exc_code,0,1,(uintptr_t *)&prec);


    //
    // user's trap handler may have changed either the fp environment
    // or the result
    //

    //
    // Update exception mask
    //

    if (prec->Enable.InvalidOperation)
        (*pcw) &= ~IEM_INVALID;
    if (prec->Enable.ZeroDivide)
        (*pcw) &= ~IEM_ZERODIVIDE;
    if (prec->Enable.Overflow)
        (*pcw) &= ~IEM_OVERFLOW;
    if (prec->Enable.Underflow)
        (*pcw) &= ~IEM_UNDERFLOW;
    if (prec->Enable.Inexact)
        (*pcw) &= ~IEM_INEXACT;

    //
    // Update Rounding mode
    //

    switch (prec->RoundingMode) {
    case _FpRoundChopped:
         *pcw = *pcw & ~IMCW_RC | IRC_CHOP;
         break;
    case _FpRoundPlusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_UP;
         break;
    case _FpRoundMinusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_DOWN;
         break;
    case _FpRoundNearest:
         *pcw = *pcw & ~IMCW_RC | IRC_NEAR;
         break;
    }


#ifdef _M_IX86

    //
    // Update Precision Control
    //

    switch (prec->Precision) {
    case _FpPrecisionFull:
         *pcw = *pcw & ~IMCW_RC | IPC_64;
         break;
    case _FpPrecision53:
         *pcw = *pcw & ~IMCW_RC | IPC_53;
         break;
    case _FpPrecision24:
         *pcw = *pcw & ~IMCW_RC | IPC_24;
         break;
    }

#endif

    //
    // Update result
    //

    *presult = prec->Result.Value.Fp64Value;
}



/***
* _handle_exc - produce masked response for IEEE fp exception
*
*Purpose:
*
*Entry:
*   unsigned int flags      the exception flags
*   double *presult         the default result
*   unsigned int cw         user's fp control word
*
*Exit:
*   returns 1 on successful handling, 0 on failure
*   On success, *presult becomes the masked response
*
*Exceptions:
*
*******************************************************************************/

int _handle_exc(unsigned int flags, double * presult, uintptr_t cw)
{
    //
    // flags_p is useful for deciding whether there are still unhandled
    // exceptions in case multiple exceptions have occurred
    //

    int flags_p = flags & (FP_I | FP_Z | FP_O | FP_U | FP_P);

    if (flags & FP_I && cw & IEM_INVALID) {

        //
        // Masked response for invalid operation
        //

        _set_statfp(ISW_INVALID);
        flags_p &= ~FP_I;
    }

    else if (flags & FP_Z && cw & IEM_ZERODIVIDE) {

        //
        // Masked response for Division by zero
        // result should already have the proper value
        //

        _set_statfp( ISW_ZERODIVIDE);
        flags_p &= ~FP_Z;
    }

    else if (flags & FP_O && cw & IEM_OVERFLOW) {

        //
        // Masked response for Overflow
        //

        _set_statfp(ISW_OVERFLOW);
        switch (cw & IMCW_RC) {
        case IRC_NEAR:
            *presult = *presult > 0.0 ? D_INF : -D_INF;
            break;
        case IRC_UP:
            *presult = *presult > 0.0 ? D_INF : -D_MAX;
            break;
        case IRC_DOWN:
            *presult = *presult > 0.0 ? D_MAX : -D_INF;
            break;
        case IRC_CHOP:
            *presult = *presult > 0.0 ? D_MAX : -D_MAX;
            break;
        }

        flags_p &= ~FP_O;
    }

    else if (flags & FP_U && cw & IEM_UNDERFLOW) {

        //
        // Masked response for Underflow:
        // According to the IEEE standard, when the underflow trap is not
        // enabled, underflow shall be signaled only when both tininess
        // and loss of accuracy have been detected
        //

        int aloss=0;    // loss of accuracy flag

        if (flags & FP_P) {
            aloss = 1;
        }

        //
        // a zero value in the result denotes
        // that even after ieee scaling, the exponent
        // was too small.
        // in this case the masked response is also
        // zero (sign is preserved)
        //

        if (*presult != 0.0) {
            double result;
            int expn, newexp;

            result = _decomp(*presult, &expn);
            newexp = expn - IEEE_ADJUST;

            if (newexp < MINEXP - 53) {
                result *= 0.0;          // produce a signed zero
                aloss = 1;
            }
            else {
                int neg = result < 0;       // save sign

                //
                // denormalize result
                //

                (*D_EXP(result)) &= 0x000f; /* clear exponent field */
                (*D_EXP(result)) |= 0x0010; /* set hidden bit */

                for (;newexp<MINEXP;newexp++) {
                    if (*D_LO(result) & 0x1 && !aloss) {
                        aloss = 1;
                    }

                    /* shift mantissa to the right */
                    (*D_LO(result)) >>= 1;
                    if (*D_HI(result) & 0x1) {
                        (*D_LO(result)) |= 0x80000000;
                    }
                    (*D_HI(result)) >>= 1;
                }
                if (neg) {
                    result = -result;       // restore sign
                }
            }

            *presult = result;
        }
        else {
            aloss = 1;
        }

        if (aloss) {
            _set_statfp(ISW_UNDERFLOW);
        }

        flags_p &= ~FP_U;
    }


    //
    // Separate check for precision exception
    // (may coexist with overflow or underflow)
    //

    if (flags & FP_P && cw & IEM_INEXACT) {

        //
        // Masked response for inexact result
        //

        _set_statfp(ISW_INEXACT);
        flags_p &= ~FP_P;
    }

    return flags_p ? 0: 1;
}



/***
* _umatherr - call user's matherr routine
*
*Purpose:
*   call user's matherr routine and set errno if appropriate
*
*
*Entry:
*     int type              type of excpetion
*     unsigned int opcode   fp function that caused the exception
*     double arg1           first argument of the fp function
*     double arg2           second argument of the fp function
*     double retval         return value of the fp function
*     unsigned int cw       user's fp control word
*
*Exit:
*     fp control word       becomes the user's fp cw
*     errno                 modified if user's matherr returns 0
*     return value          the retval entered by the user in
*                           the _exception matherr struct
*
*Exceptions:
*
*******************************************************************************/

double _umatherr(
              int type,
              unsigned int opcode,
              double arg1,
              double arg2,
              double retval,
              uintptr_t cw
              )
{
    struct _exception exc;

    //
    // call matherr only if the name of the function
    // is registered in the table, i.e., only if exc.name is valid
    //

    if (exc.name = _get_fname(opcode)) {
        exc.type = type;

        COPY_DOUBLE(&exc.arg1,&arg1);
        COPY_DOUBLE(&exc.arg2,&arg2);
        COPY_DOUBLE(&exc.retval,&retval);

        _rstorfp(cw);

        if (_matherr(&exc) == 0) {
            _set_errno(type);
        }
        return  exc.retval;
    }
    else {

        //
        // treat this case as if matherr returned 0
        //

        _rstorfp(cw);
        _set_errno(type);
        return retval;
    }

}



/***
* _set_errno - set errno
*
*Purpose:
*   set correct error value for errno
*
*Entry:
*   int matherrtype:    the type of math error
*
*Exit:
*   modifies errno
*
*Exceptions:
*
*******************************************************************************/

void _set_errno(int matherrtype)
{
    switch(matherrtype) {
    case _DOMAIN:
        errno = EDOM;
        break;
    case _OVERFLOW:
    case _SING:
        errno = ERANGE;
        break;
    }
}



/***
* _get_fname -  get function name
*
*Purpose:
*  returns the _matherr function name that corresponds to a
*  floating point opcode
*
*Entry:
*  _FP_OPERATION_CODE opcode
*
*Exit:
*   returns a pointer to a string
*
*Exceptions:
*
*******************************************************************************/
#define OP_NUM  29   /* number of fp operations */

static char *_get_fname(unsigned int opcode)
{

    static struct {
        unsigned int opcode;
        char *name;
    } _names[OP_NUM] = {
        { OP_EXP,   "exp" },
        { OP_POW,   "pow" },
        { OP_LOG,   "log" },
        { OP_LOG10, "log10"},
        { OP_SINH,  "sinh"},
        { OP_COSH,  "cosh"},
        { OP_TANH,  "tanh"},
        { OP_ASIN,  "asin"},
        { OP_ACOS,  "acos"},
        { OP_ATAN,  "atan"},
        { OP_ATAN2, "atan2"},
        { OP_SQRT,  "sqrt"},
        { OP_SIN,   "sin"},
        { OP_COS,   "cos"},
        { OP_TAN,   "tan"},
        { OP_CEIL,  "ceil"},
        { OP_FLOOR, "floor"},
        { OP_ABS,   "fabs"},
        { OP_MODF,  "modf"},
        { OP_LDEXP, "ldexp"},
        { OP_CABS,  "_cabs"},
        { OP_HYPOT, "_hypot"},
        { OP_FMOD,  "fmod"},
        { OP_FREXP, "frexp"},
        { OP_Y0,    "_y0"},
        { OP_Y1,    "_y1"},
        { OP_YN,    "_yn"},
        { OP_LOGB,  "_logb"},
        { OP_NEXTAFTER, "_nextafter"}
    };

    int i;
    for (i=0;i<OP_NUM;i++) {
        if (_names[i].opcode == opcode)
            return _names[i].name;
    }
    return (char *)0;
}



/***
* _errcode - get _matherr error code
*
*Purpose:
*   returns matherr type that corresponds to exception flags
*
*Entry:
*   flags: exception flags
*
*Exit:
*   returns matherr type
*
*Exceptions:
*
*******************************************************************************/

int _errcode(unsigned int flags)
{
    unsigned int errcode;

    if (flags & FP_TLOSS) {
        errcode = _TLOSS;
    }
    else if (flags & FP_I) {
        errcode = _DOMAIN;
    }
    else if (flags & FP_Z) {
        errcode = _SING;
    }
    else if (flags & FP_O) {
        errcode = _OVERFLOW;
    }
    else if (flags & FP_U) {
        errcode = _UNDERFLOW;
    }
    else {

        // FP_P

        errcode = 0;
    }
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\ldexp.c ===
/***
*ldexp.c - multiply by a power of two
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   rewritten to support IEEE exceptions
*        5-05-92  GDP   bug fix for x denormal
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK verion.
*
*******************************************************************************/
#include <math.h>
#include <float.h>
#include <trans.h>
#include <limits.h>

/***
*double ldexp(double x, int exp)
*
*Purpose:
*   Compute x * 2^exp
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I  U  O  P
*
*******************************************************************************/
double ldexp(double x, int exp)
{
    uintptr_t savedcw;
    int oldexp;
    long newexp; /* for checking out of bounds exponents */
    double result, mant;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan2(OP_LDEXP, x, (double)exp, savedcw);
        default: //T_SNAN
            return _except2(FP_I,OP_LDEXP,x,(double)exp,_s2qnan(x),savedcw);
        }
    }


    if (x == 0.0) {
        RETURN(savedcw,x);
    }

    mant = _decomp(x, &oldexp);

    if (ABS(exp) > INT_MAX)
        newexp = exp; // avoid possible integer overflow
    else
        newexp = oldexp + exp;


    /* out of bounds cases */
    if (newexp > MAXEXP + IEEE_ADJUST) {
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,_copysign(D_INF,mant),savedcw);
    }
    if (newexp > MAXEXP) {
        result = _set_exp(mant, newexp-IEEE_ADJUST);
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }
    if (newexp < MINEXP - IEEE_ADJUST) {
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,mant*0.0,savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(mant, newexp+IEEE_ADJUST);
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }

    result = _set_exp(mant, (int)newexp);

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\frexp.c ===
/***
*frexp.c - get mantissa and exponent of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*       02-06-95  JWM   Mac merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

/***
*double frexp(double x, double *expptr)
*
*Purpose:
*   The nomalized fraction f is returned: .5<=f<1
*   The exponent is stored in the object pointed by expptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN: domain error
*
*******************************************************************************/
double frexp(double x, int *expptr)
{
    uintptr_t savedcw;
    double man;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *expptr = INT_NAN;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I, OP_FREXP, x, QNAN_FREXP, savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_FREXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FREXP, x, _s2qnan(x), savedcw);
        }
    }

    man = _decomp(x, expptr);
    RETURN(savedcw,man);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\hypot.c ===
/***
*hypot.c - hypotenuse and complex absolute value
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-15-91  GDP   written
*       10-20-91  GDP   removed inline assembly for calling sqrt
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

static double _hypothlp(double x, double y, int who);

/*
 *  Function name:  hypot
 *
 *  Arguments:      x, y  -  double
 *
 *  Description:    hypot returns sqrt(x*x + y*y), taking precautions against
 *                  unwarrented over and underflows.
 *
 *  Side Effects:   no global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *      03/13/89  WAJ   Minor changes to source.
 *      04/13/89  WAJ   Now uses _cdecl for _CDECL
 *      06/07/91  JCR   ANSI naming (_hypot)
 *      08/26/91  GDP   NaN support, error handling
 *      01/13/91  GDP   IEEE exceptions support
 */

double _hypot(double x, double y)
{
    return _hypothlp(x,y,OP_HYPOT);
}

/***
*double _cabs(struct _complex z) - absolute value of a complex number
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
double _cabs(struct _complex z)
{
    return( _hypothlp(z.x, z.y, OP_CABS ) );
}



static double _hypothlp(double x, double y, int who)
{
    double max;
    double result, sum;
    uintptr_t savedcw;
    int exp1, exp2, newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,who,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(who,x,y,savedcw);
        }
        /* there is at least one infinite argument ... */
        RETURN(savedcw,D_INF);
    }


    /* take the absolute values of x and y, compute the max, and then scale by
       max to prevent over or underflowing */

    if ( x < 0.0 )
        x = - x;

    if ( y < 0.0 )
        y = - y;

    max = ( ( y > x ) ?  y : x );

    if ( max == 0.0 )
        RETURN(savedcw, 0.0 );

    x /= max;   //this may pollute the fp status word (underflow flag)
    y /= max;

    sum = x*x + y*y;

    result = _decomp(sqrt(sum),&exp1) * _decomp(max,&exp2);
    newexp = exp1 + exp2 + _get_exp(result);

    // in case of overflow or underflow
    // adjusting exp by IEEE_ADJUST will certainly
    // bring the result in the representable range

    if (newexp > MAXEXP) {
        result = _set_exp(result, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, who, x, y, result, savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(result, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, who, x, y, result, savedcw);
    }

    result = _set_exp(result, newexp);
    // fix needed: P exception is raised even if the result is exact

    RETURN_INEXACT2(who, x, y, result, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\pow.c ===
/***
*pow.c - raise to a power
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions & denormals
*        1-11-92  GDP   special handling of small powers
*                       special handling of u1, u2 when cancellation occurs
*        3-22-92  GDP   changed handling of int exponents, pow(0, neg)
*                       added check to avoid internal overflow due to large y
*        6-23-92  GDP   adjusted special return values according to NCEG spec
*       02-06-95  JWM   Mac merge
*       02-07-95  JWM   powhlp() usage restored to Intel version.
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

#if defined(_M_IA64)
#pragma function(pow)
#endif

static double _reduce(double);

static double const a1[18] = {
    0.00000000000000000000e+000,   /* dummy element */
    1.00000000000000000000e+000,
    9.57603280698573646910e-001,
    9.17004043204671231754e-001,
    8.78126080186649741555e-001,
    8.40896415253714543073e-001,
    8.05245165974627154042e-001,
    7.71105412703970411793e-001,
    7.38413072969749655712e-001,
    7.07106781186547524436e-001,
    6.77127773468446364133e-001,
    6.48419777325504832961e-001,
    6.20928906036742024317e-001,
    5.94603557501360533344e-001,
    5.69394317378345826849e-001,
    5.45253866332628829604e-001,
    5.22136891213706920173e-001,
    5.00000000000000000000e-001
};

static double const a2[9] = {
    0.00000000000000000000e+000,   /* dummy element */
   -5.31259064517897172664e-017,
    1.47993596544271355242e-017,
    1.23056946577104753260e-017,
   -1.74014448683923461658e-017,
    3.84891771232354074073e-017,
    2.33103467084383453312e-017,
    4.45607092891542322377e-017,
    4.27717757045531499216e-017
};

static double const log2inv = 1.44269504088896340739e+0; //  1/log(2)
static double const K = 0.44269504088896340736e+0;

static double const p1 = 0.83333333333333211405e-1;
static double const p2 = 0.12500000000503799174e-1;
static double const p3 = 0.22321421285924258967e-2;
static double const p4 = 0.43445775672163119635e-3;

#define P(v) (((p4 * v + p3) * v + p2) * v + p1)

static double const q1 = 0.69314718055994529629e+0;
static double const q2 = 0.24022650695909537056e+0;
static double const q3 = 0.55504108664085595326e-1;
static double const q4 = 0.96181290595172416964e-2;
static double const q5 = 0.13333541313585784703e-2;
static double const q6 = 0.15400290440989764601e-3;
static double const q7 = 0.14928852680595608186e-4;

#define Q(w)   ((((((q7 * w + q6) * w + q5) * w + q4) * w + \
                              q3) * w + q2) * w + q1)


/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double. An infinity or 0
 * is delivered to the trap handler instead
 */

static _dbl const _ovfx ={SET_DBL(0x40e40000,0)}; // 16*log2(XMAX*2^IEEE_ADJ)
static _dbl const _uflx ={SET_DBL(0xc0e3fc00,0)}; // 16*log2(XMIN*2^(-IEEE_ADJ))

#define OVFX _ovfx.dbl
#define UFLX _uflx.dbl

#define INT_POW_LIMIT   128.0

static double ymax = 1e20;

static double _reduce(double x)
{
    return 0.0625 * _frnd( 16.0 * x);
}

/***
*double pow(double x, double y) - x raised to the power of y
*
*Purpose:
*   Calculate x^y
*   Algorithm from Cody & Waite
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   All 5 IEEE exceptions may occur
*
*******************************************************************************/
double pow(double x, double y)
{
    uintptr_t savedcw;
    int m,mprim;
    int p,pprim;
    int i,iw1;
    int iy;
    int newexp;
    double diw1;
    double sign;
    double g,z,bigz,v,rz,result;
    double u1,u2,y1,y2,w,w1,w2;
    double savedx;

    /* save user fp control word */
    savedcw = _maskfp();
    savedx = x;         // save original value of first argument

    if (_fpclass(y) & (_FPCLASS_NZ | _FPCLASS_PZ)) {
        RETURN(savedcw, 1.0);
    }

    /* Check for zero^y */
    if (_fpclass(x) & (_FPCLASS_NZ | _FPCLASS_PZ)) { /* x==0? */
        int type;

        type = _d_inttype(y);

        if (y < 0.0) {
            result = (type == _D_ODD ? _copysign(D_INF,x) : D_INF);
            return _except2(FP_Z,OP_POW,savedx,y,result,savedcw|ISW_ZERODIVIDE);
        }
        else if (y > 0.0) {
            result = (type == _D_ODD ? x : 0.0);
                RETURN(savedcw, result);
        }
    }

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)) {
      double absx = fabs(x);

      if (IS_D_SNAN(x) || IS_D_SNAN(y)) {
        return _except2(FP_I,OP_POW,savedx,y,_d_snan2(x,y),savedcw | (ISW_INVALID>>5) );
      }
      if (IS_D_QNAN(x) || IS_D_QNAN(y)){
        return _handle_qnan2(OP_POW,x,y,savedcw | (ISW_INVALID>>5) );
      }
      
      /* there is at least one infinite argument ... */
      if (_powhlp(x, y, &result)) { /* removed "<" 0. */
        return _except2(FP_I,OP_POW,savedx,y,result,savedcw | (ISW_INVALID>>5) );
      }
      RETURN(savedcw, result);
    }

    sign = 1.0;
    if (x < 0) {
        switch (_d_inttype(y)) {
        case _D_ODD: /* y is an odd integral value */
            sign = -1.0;
            /* NO BREAK */
        case _D_EVEN:
            x = -x;
            break;
        default: /* y is not an integral value */
            return _except2(FP_I,OP_POW,savedx,y,D_IND,savedcw|(ISW_INVALID>>5));
        }
    }

    //
    // This is here in order to prevent internal overflows
    // due to a large value of y
    // The following relation holds on overflow with a scaled
    // result out of range
    // (lg stands for log base 2)
    //      |y| * |lg(x)| > MAXEXP + IEEE_ADJUST        <=>
    //      |y| >  2560 / |lg(x)|
    // The values of lg(x) closer to 0 are:
    //      x                                    lg(x)
    //  3fefffffffffffff    (0,99...9)        -1.601e-16
    //  3ff0000000000000    (1.0)              0.0
    //  3ff0000000000001    (1.00...1)         3.203e-16
    //
    // So if |y| > 2560/1.6e-16 = 1.6e19 overflow occurs
    // We set ymax to 1e20 in order to have a safety margin
    //

    if (ABS(y) > ymax) {
        if (y < 0) {
            y = -y;
            //
            // this may cause an underflow
            // there is no problem with fp sw pollution because
            // a FP_U exception is going to be raised anyway.
            //
            x = 1.0 / x;
        }
        if (x > 1.0) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw|ISW_OVERFLOW);
        }
        else if (x < 1.0){
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw|ISW_UNDERFLOW);
        }
        else {
            RETURN(savedcw, sign*1.0);
        }
    }


    /* determine m, g */
    g = _decomp(x, &m);


    /* handle small integer powers
     * for small integer powers this is faster that Cody&Waite's
     * algorithm, and yields better precision
     * Without this piece of code there was not enough precision
     * to satisfy all requirements of the 'paranoia' test.
     * We choose INT_POW_LIMIT such that (1) no overflow or underflow
     * occurs while computing bigz (g is in the range
     * [0.5, 1.0) or (1.0, 2.0] so INT_POW_LIMIT should be less than
     * approximately 10^3) and (2) no extraordinary loss of precision
     * occurs because of repeated multiplications (this practically
     * restricts the maximum INT_POW_LIMIT to 128).
     */

    if (y <= INT_POW_LIMIT &&
        _d_inttype(x) != _D_NOINT &&
        _d_inttype(y) != _D_NOINT &&
        y > 0.0 ) {

        iy = (int)y;
        mprim = m * iy;

        for (bigz=1 ; iy ; iy >>= 1, g *= g) {
            if (iy & 0x1)
                bigz *= g;
        }

        newexp = _get_exp(bigz) + mprim;
        if (newexp > MAXEXP + IEEE_ADJUST) {
            return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*bigz*D_INF, savedcw);
        }
        if (newexp < MINEXP - IEEE_ADJUST) {
            return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*bigz*0.0, savedcw);
        }

    }


    else {

        /* determine p using binary search */
        p = 1;
        if (g <= a1[9])
            p = 9;
        if (g <= a1[p+4])
            p += 4;
        if (g <= a1[p+2])
            p += 2;


        /* C&W's algorithm is not very accurate when m*16-p == 1,
         * because there is cancellation between u1 and u2.
         * Handle this separately.
         */
        if (ABS(m*16-p) == 1) {
            u1 = log(x) * log2inv;
            u2 = 0.0;
        }
        else {
            /* determine z */
            z = ( (g - a1[p+1]) - a2[(p+1)/2] ) / ( g + a1[p+1] );
            z += z;


            /* determine u2 */
            v = z * z;
            rz = P(v) * v * z;
            rz += K * rz;
            u2 = (rz + z * K) + z;

            u1 = (m * 16 - p) * 0.0625;
        }

        /* determine w1, w2 */
        y1 = _reduce(y);
        y2 = y - y1;
        w = u2 * y + u1 * y2;
        w1 = _reduce(w);
        w2 = w - w1;
        w = w1 + u1 * y1;
        w1 = _reduce(w);
        w2 += w - w1;
        w = _reduce(w2);
        diw1 = 16 * (w1 + w); /* iw1 might overflow here, so use diw1 */
        w2 -= w;

        if (diw1 > OVFX) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw | ISW_OVERFLOW);
        }
        if (diw1 < UFLX) {
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw | ISW_UNDERFLOW);
        }

        iw1 = (int) diw1;        /* now it is safe to cast to int */


        /* make sure w2 <= 0 */
        if (w2 > 0) {
            iw1 += 1;
            w2 -= 0.0625;
        }

        /* determine mprim, pprim */
        i = iw1 < 0 ? 0 : 1;
        mprim = iw1 / 16 + i;
        pprim = 16 * mprim - iw1;

        /* determine 2^w2 */
        bigz = Q(w2) * w2;

        /* determine  final result */
        bigz = a1[pprim + 1] + a1[pprim + 1] * bigz;
        newexp = _get_exp(bigz) + mprim;
    }


    if (newexp > MAXEXP) {
        result = sign * _set_exp(bigz, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*D_INF, savedcw|ISW_OVERFLOW);
    }
    if (newexp < MINEXP) {
        result = sign * _set_exp(bigz, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*0.0, savedcw|ISW_UNDERFLOW);
    }

    result = sign * _set_exp(bigz, newexp);
    RETURN_INEXACT2(OP_POW, savedx, y, result, savedcw|ISW_INEXACT);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\log.c ===
/***
*log.c - logarithmic functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute log(x) and log10(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(log, log10)
#endif

static double _log_hlp( double x, int flag);

/* constants */
static double const c0 =  0.70710678118654752440;       /* sqrt(0.5) */
static double const c1 =  0.69335937500000000000;
static double const c2 = -2.121944400546905827679e-4;
static double const c3 =  0.43429448190325182765;

/* coefficients for rational approximation */
static double const a0 = -0.64124943423745581147e2 ;
static double const a1 =  0.16383943563021534222e2 ;
static double const a2 = -0.78956112887491257267e0 ;
static double const b0 = -0.76949932108494879777e3 ;
static double const b1 =  0.31203222091924532844e3 ;
static double const b2 = -0.35667977739034646171e2 ;
/* b3=1.0  is not used -avoid multiplication by 1.0 */

#define A(w) (((w) * a2 + a1) * (w) + a0)
#define B(w) ((((w) + b2) * (w) + b1) * (w) + b0)

/***
*double log(double x) -  natural logarithm
*double log10(double x) - base-10 logarithm
*
*Purpose:
*   Compute the natural and base-10 logarithm of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P Z
*******************************************************************************/

double log10(double x)
{
    return(_log_hlp(x,OP_LOG10));
}

double log(double x)
{
    return(_log_hlp(x,OP_LOG));
}

static double _log_hlp(double x, int opcode)
{
    uintptr_t savedcw;
    int n;
    double f,result;
    double z,w,znum,zden;
    double rz,rzsq;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(opcode, x, savedcw);
        case T_SNAN:
            return _except1(FP_I, opcode, x, _s2qnan(x), savedcw);
        }
        /* NINF will be handled in the x<0 case */
    }

    if (x <= 0.0) {
        double qnan;
        if (x == 0.0) {
            return _except1(FP_Z,opcode,x,-D_INF,savedcw);
        }
        qnan = (opcode == OP_LOG ? QNAN_LOG : QNAN_LOG10);
        return _except1(FP_I,opcode,x,qnan,savedcw);
    }

    if (x == 1.0) {
        // no precision ecxeption
        RETURN(savedcw, 0.0);
    }

    f = _decomp(x, &n);

    if (f > c0) {
        znum = (f - 0.5) - 0.5;
        zden = f * 0.5 + 0.5;
    }
    else {
        n--;
        znum = f - 0.5;
        zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z;

    rzsq = w * A(w)/B(w) ;
    rz = z + z*rzsq;

    result = (n * c2 + rz) + n * c1;
    if (opcode == OP_LOG10) {
        result *= c3;
    }

    RETURN_INEXACT1(opcode,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\ieeemisc.c ===
/***
* ieeemisc.c - IEEE miscellaneous recommended functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        5-04-92  GDP   written
*        8-13-96  JWM   Order of tests in _fpclass() rearranged, since
*                       "if (x==0.0)" now uses FP hardware.
*       11-25-00  PML   IA64 _logb and _isnan supplied by libm .s code.
*
*******************************************************************************/

#include <trans.h>
#include <math.h>
#include <float.h>


/***
* _copysign - copy sign
*
*Purpose:
*   copysign(x,y) returns x with the sign of y. Hence, abs(x) := copysign
*   even if x is NaN [IEEE std 854-1987 Appendix]
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if one of the arguments is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _copysign (double x, double y)
{
    double retval;
    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1<<31) |
                    *D_HI(y) &  (1<<31) ;

    return retval;
}



/***
* _chgsign - change sign
*
*Purpose:
*  x is copied with its sign reversed, not 0-x; the distinction is germane
*  when x is +0, -0, or NaN
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if x is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _chgsign (double x)
{
    double retval;

    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1 << 31)  |
                    ~*D_HI(x) & (1<<31);

    return retval;
}


/***
* _scalb - scale by power of 2
*
*Purpose:
*   _scalb(x,n) returns x * 2^n for integral values of n without
*   computing 2^n
*   Special case:
*      If x is infinity or zero, _scaleb returns x
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Overflow, Underflow
*
*******************************************************************************/

double _scalb(double x, long n)
{
    //
    // It turns out that our implementation of ldexp matces the IEEE
    // description of _scalb. The only problem with calling ldexp
    // is that if an exception occurs, the operation code reported
    // to the handler will be the one that corresponds to ldexp
    // (i.e., we do not define a new operation code for _scalb
    //

    return ldexp(x,n);
}


#if !defined(_M_IA64)

/***
* _logb - extract exponent
*
*Purpose:
*   _logb(x) returns the unbiased exponent of x, a signed integer in the
*   format of x, except that logb(NaN) is a NaN, logb(+INF) is +INF,and
*   logb(0) is is -INF and signals the division by zero exception.
*   For x positive and finite, 1<= abs(scalb(x, -logb(x))) < 2
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Division by zero
*
*******************************************************************************/
double _logb(double x)
{
    uintptr_t savedcw;
    int exp;
    double retval;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_LOGB, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_LOGB, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0) {
         return _except1(FP_Z, OP_LOGB, x, -D_INF, savedcw);
    }

    (void) _decomp(x, &exp);

    //
    // x == man * 2^exp, where .5 <= man < 1. According to the spec
    // of this function, we should compute the exponent so that
    // 1<=man<2, i.e., we should decrement the computed exp by one
    //

    retval = (double) (exp - 1);

    RETURN(savedcw, retval);

}

#endif  // !defined(_M_IA64)



/***
* _nextafter - next representable neighbor
*
*Purpose:
*  _nextafter(x,y) returns the next representable neighbor of x in
*  the direction toward y. The following special cases arise: if
*  x=y, then the result is x without any exception being signaled;
*  otherwise, if either x or y is a quiet NaN, then the result is
*  one or the other of the input NaNs. Overflow is sibnaled when x
*  is finite but nextafter(x,y) is infinite; underflow is signaled
*  when nextafter(x,y) lies strictly between -2^Emin, 2^Emin; in
*  both cases, inexact is signaled.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   O, U, I, P
*
*******************************************************************************/

double _nextafter(double x, double y)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,OP_NEXTAFTER,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(OP_NEXTAFTER,x,y,savedcw);
        }

        //
        // infinite arguments are not treated as special cases
        //
    }

    if (y == x) {

        //
        // no exceptions are raised in this case
        //

        RETURN(savedcw, x);
    }

    if (x == 0) {

        *D_LO(result) = 1;

        if (y > x) {
            *D_HI(result) = 0;
        }

        else {

            //
            // result should be negative
            //

            *D_HI(result) = (unsigned long)(1<<31);
        }

    }


    //
    // At this point x!=y, and x!=0. x can be treated as a 64bit
    // integer in sign/magnitude representation. To get the next
    // representable neighbor we add or subtract one from this
    // integer. (Note that for boundary cases like x==INF, need to
    // add one will never occur --this would mean that y should
    // be greater than INF, which is impossible)
    //

    if (x > 0 && y < x ||
        x < 0 && y > x) {

        //
        // decrease value by one
        //

        *D_LO(result) = *D_LO(x) - 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(x) == 0) {

            //
            // a borrow should propagate to the high order dword
            //

            (*D_HI(result)) --;
        }
    }

    else if (x > 0 && y > x ||
             x < 0 && y < x) {

        //
        // increase value by one
        //

        *D_LO(result) = *D_LO(x) + 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(result) == 0) {

            //
            // a carry should propagate to the high order dword
            //

            (*D_HI(result)) ++;
        }
    }


    //
    // check if an exception should be raised
    //


    if ( IS_D_DENORM(result) ) {

        //
        // should signal underflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp+IEEE_ADJUST);

        return _except2(FP_U|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }



    if ( IS_D_INF(result) || IS_D_MINF(result) ) {

        //
        // should signal overflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp-IEEE_ADJUST);

        return _except2(FP_O|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }


    RETURN(savedcw, result);
}




/***
* _finite -
*
*Purpose:
*   finite(x) returns the value TRUE if -INF < x < +INF and returns
*   false otherwise [IEEE std]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _finite(double x)
{
    if (IS_D_SPECIAL(x)) {

        //
        // x is INF or NaN
        //

        return 0;
    }
    return 1;
}



#if !defined(_M_IA64)

/***
* _isnan -
*
*Purpose:
*   isnan(x) returns the value TRUE if x is a NaN, and returns FALSE
*   otherwise.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
        return 1;
    }
    return 0;
}

#endif  // !defined(_M_IA64)


/***
*double _fpclass(double x) - floating point class
*
*Purpose:
*   Compute the floating point class of a number, according
*   to the recommendations of the IEEE std. 754
*
*Entry:
*
*Exit:
*
*Exceptions:
*   This function is never exceptional, even when the argument is SNAN
*
*******************************************************************************/

int _fpclass(double x)
{
    int sign;

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            return _FPCLASS_PINF;
        case T_NINF:
            return _FPCLASS_NINF;
        case T_QNAN:
            return _FPCLASS_QNAN;
        default: //T_SNAN
            return _FPCLASS_SNAN;
        }
    }
    sign = (*D_EXP(x)) & 0x8000;

    if (IS_D_DENORM(x))
        return sign? _FPCLASS_ND : _FPCLASS_PD;

    if (x == 0.0)
        return sign? _FPCLASS_NZ : _FPCLASS_PZ;

    return sign? _FPCLASS_NN : _FPCLASS_PN;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\modf.c ===
/***
*modf.c - modf()
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        6-23-92  GDP   modified special return values for NCEG conformance
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*       02-28-01  PML   Make sure 0.0 fraction return has correct sign
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

extern double _frnd(double);
extern double _copysign (double x, double y);

/***
*double modf(double x, double *intptr)
*
*Purpose:
*   Split x into fractional and integer part
*   The signed fractional portion is returned
*   The integer portion is stored as a floating point value at intptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I
*******************************************************************************/
static  uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_CHOP & IMCW_RC);

#if !defined(_M_IX86) || defined(_XBOX)
double modf(double x, double *intptr)
#else
double _modf_default(double x, double *intptr)
#endif
{
    uintptr_t savedcw;
    double result,intpart;

    /* save user fp control word */
    savedcw = _ctrlfp(0, 0);     /* get old control word */
    _ctrlfp(newcw,IMCW);        /* round towards 0 */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *intptr = QNAN_MODF;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            *intptr = x;
            result = _copysign(0, x);
            RETURN(savedcw,result);
        case T_QNAN:
            *intptr = x;
            return _handle_qnan1(OP_MODF, x, savedcw);
        default: //T_SNAN
            result = _s2qnan(x);
            *intptr = result;
            return _except1(FP_I, OP_MODF, x, result, savedcw);
        }
    }

    intpart = _frnd(x); //fix needed: this may set the P exception flag
                        //and pollute the fp status word

    *intptr = intpart;
    result = x - intpart;

    if (result == 0.0) {
	/* Make sure fractional part of 0.0 has the correct sign */
	*D_EXP(result) |= (*D_EXP(x) & 0x8000);
    }

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\matherr.c ===
/***
*matherr.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       08-03-94  GJF   Revised to support user-supplied version of _matherr
*                       in clients of msvcrt*.dll.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <math.h>
#include <stddef.h>

int _matherr_flag = 9876;

#if     defined(CRTDLL) && !defined(_NTSDK)

/*
 * Pointer to user-supplied _matherr routine if one has been supplied.
 */
int (__cdecl * pusermatherr)(struct _exception *) = NULL;

/***
*void __setusermatherr ( int (__cdecl *pf)(struct exception *) )
*
*Purpose:
*       Copy pointer to user-supplied matherr routine into pusermatherr
*
*Entry:
*       pf  - pointer to an implementation of _matherr supplied by the user
*Exit:
*
*Exceptions:
*******************************************************************************/

_CRTIMP void __setusermatherr( int (__cdecl *pf)(struct _exception *) )
{
        pusermatherr = pf;
        _matherr_flag = 0;
}

#endif

/***
*int _matherr(struct _exception *except) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
int _matherr(struct _exception *pexcept)
{
#if     defined(CRTDLL) && !defined(_NTSDK)

        /*
         * If user has supplied a _matherr implementation, pass control to
         * it and let it handle the error.
         */
        if ( pusermatherr != NULL )
                return pusermatherr(pexcept);
#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\powhlp.c ===
/***
*powhlp.c - pow() helper routines for handling special cases
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	pow(x,y) helper routine. Handles +inf, -inf
*
*Revision History:
*   11-09-91	GDP
*   06-23-92	GDP	adjusted return values according to the NCEG spec
*   02-06-95	JWM	Mac merge
*	02-07-95	JWM	powhlp() restored to Intel version.
*
*******************************************************************************/
#include <trans.h>
#include <float.h>

/***
*int _powhlp(double x, double y, double * result) - pow() helper
*
*Purpose:
*   Calculate x^(sign)inf
*
*Entry:
*   double x: the base
*   int sign: the sign of the infinite exponent (0: pos, non-0: neg)
*   double *result: pointer to the result
*
*Exit:
*   0: normal exit
*   -1: indicates domain error for pow(x,inf)
*
*Exceptions:
*
***************************************************************************/

int _powhlp(double x, double y, double * result)
{
    double absx;
    int err = 0;


    absx = ABS(x);

    if (IS_D_INF(y)) {
	if (absx > 1.0) {
	    *result = D_INF;
	}
	else if (absx < 1.0) {
	    *result = 0.0;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_MINF(y)) {
	if (absx > 1.0) {
	    *result = 0.0;
	}
	else if (absx < 1.0) {
	    *result = D_INF;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_INF(x)) {
	if (y > 0)
	    *result = D_INF;
	else if (y < 0.0)
	    *result = 0.0;
	else {
	    *result = 1.0;
	}
    }

    else if (IS_D_MINF(x)) {
	int type;

	type = _d_inttype(y);

	if (y > 0.0) {
	    *result = (type == _D_ODD ? -D_INF : D_INF);
	}
	else if (y < 0.0) {
	    *result = (type == _D_ODD ? D_MZERO : 0.0);
	}
	else {
	    *result = 1;
	}

    }

    return err;
}




int _d_inttype(double y)
{
    double rounded;
    /* check if y is an integral value */
    if (_fpclass(y) & (_FPCLASS_PD | _FPCLASS_ND))
      return _D_NOINT;
    rounded = _frnd(y);
    if (rounded == y) {
	if (_frnd(y/2.0) == y/2.0)
	    return _D_EVEN;
	else
	    return _D_ODD;
    }
    return _D_NOINT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\sqrt.c ===
/***
*sqrt.c - square root
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        1-29-91  GDP   Kahan's algorithm for final rounding
*        3-11-92  GDP   new interval and initial approximation
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#ifndef R4000

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sqrt)
#endif

//
// Coefficients for initial approximation (Hart & al)
//

static double p00 =  .2592768763e+0;
static double p01 =  .1052021187e+1;
static double p02 = -.3163221431e+0;


/***
*double sqrt(double x) - square root
*
*Purpose:
*   Compute the square root of a number.
*   This function should be provided by the underlying
*   hardware (IEEE spec).
*Entry:
*
*Exit:
*
*Exceptions:
*  I P
*******************************************************************************/
double sqrt(double x)
{
    uintptr_t savedcw, sw;
    double result,t;
    uintptr_t stat,rc;

    savedcw = _ctrlfp(ICW, IMCW);

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_SQRT, x, savedcw);
        case T_SNAN:
            return _except1(FP_I,OP_SQRT,x,QNAN_SQRT,savedcw);
        }
        /* -INF will be handled in the x<0 case */
    }
    if (x < 0.0) {
        return _except1(FP_I, OP_SQRT, x, QNAN_SQRT,savedcw);
    }

    if (x == 0.0) {
        RETURN (savedcw, x);
    }


    result = _fsqrt(x);

    _ctrlfp(IRC_DOWN, IMCW_RC);


    //
    // Kahan's algorithm
    //

    sw = _clrfp();
    t = x / result;
    stat = _statfp();
    if (! (stat & ISW_INEXACT)) {
        // exact
        if (t == result) {
            _set_statfp(sw);            // restore status word
            RETURN(savedcw, result);
        }
        else {
            // t = t-1
            if (*D_LO(t) == 0) {
                (*D_HI(t)) --;
            }
            (*D_LO(t)) --;
        }

    }

    rc = savedcw & IMCW_RC;
    if (rc == IRC_UP  || rc == IRC_NEAR) {
        // t = t+1
        (*D_LO(t)) ++;
        if (*D_LO(t) == 0) {
            (*D_HI(t)) ++;
        }
        if (rc == IRC_UP) {
            // y = y+1
            (*D_LO(t)) ++;
            if (*D_LO(t) == 0) {
                (*D_HI(t)) ++;
            }
        }
    }

    result = 0.5 * (t + result);

    _set_statfp(sw | ISW_INEXACT);      // update status word
    RETURN_INEXACT1(OP_SQRT, x, result, savedcw);
}



/***
* _fsqrt - non IEEE conforming square root
*
*Purpose:
*   compute a square root of a normal number without performing
*   IEEE rounding. The argument is a finite number (no NaN or INF)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _fsqrt(double x)
{
    double f,y,result;
    int n;

    f = _decomp(x,&n);

    if (n & 0x1) {
        // n is odd
        n++;
        f = _add_exp(f, -1);
    }

    //
    // approximation for sqrt in the interval [.25, 1]
    // (Computer Approximationsn, Hart & al.)
    // gives more than 7 bits of accuracy
    //

    y =  p00 + f * (p01 + f *  p02);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    n >>= 1;
    result = _add_exp(y,n);

    return result;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\util.c ===
/***
*util.c - utilities for fp transcendentals
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   _set_exp and _add_exp are as those defined in Cody & Waite
*
*Revision History:
*   08-15-91	GDP	written
*   10-20-91	GDP	removed _rint, unsafe_intrnd
*   02-05-92	GDP	added _fpclass
*   03-27-92	GDP	added _d_min
*   06-23-92	GDP	added _d_mzero
*
*******************************************************************************/
#include "trans.h"

/* define special values */

_dbl _d_inf = {SET_DBL (0x7ff00000, 0x0) };	  //positive infinity
_dbl _d_ind = {SET_DBL (D_IND_HI, D_IND_LO)};	  //real indefinite
_dbl _d_max = {SET_DBL (0x7fefffff, 0xffffffff)}; //max double
_dbl _d_min = {SET_DBL (0x00100000, 0x00000000)}; //min normalized double
_dbl _d_mzero = {SET_DBL (0x80000000, 0x00000000)}; //negative zero



double _set_exp(double x, int exp)
/* does not check validity of exp */
{
    double retval;
    int biased_exp;
    retval = x;
    biased_exp = exp + D_BIASM1;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));
    return retval;
}


int _get_exp(double x)
{
    signed short exp;
    exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
    exp -= D_BIASM1; //unbias
    return (int) exp;
}


double _add_exp(double x, int exp)
{
    return _set_exp(x, INTEXP(x)+exp);
}


double _set_bexp(double x, int bexp)
/* does not check validity of bexp */
{
    double retval;
    retval = x;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (bexp << 4));
    return retval;
}


int _sptype(double x)
{
    if (IS_D_INF(x))
	return T_PINF;
    if (IS_D_MINF(x))
	return T_NINF;
    if (IS_D_QNAN(x))
	return T_QNAN;
    if (IS_D_SNAN(x))
	return T_SNAN;
    return 0;
}



/***
*double _decomp(double x, double *expptr)
*
*Purpose:
*   decompose a number to a normalized mantisa and exponent
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _decomp(double x, int *pexp)
{
    int exp;
    double man;

    if (x == 0) {
	man = 0;
	exp = 0;
    }
    else if (IS_D_DENORM(x)) {
	int neg;

	exp = 1-D_BIASM1;
	neg = x < 0.0;
	while((*D_EXP(x) & 0x0010) == 0) {
	    /* shift mantissa to the left until bit 52 is 1 */
	    (*D_HI(x)) <<= 1;
	    if (*D_LO(x) & 0x80000000)
		(*D_HI(x)) |= 0x1;
	    (*D_LO(x)) <<= 1;
	    exp--;
	}
	(*D_EXP(x)) &= 0xffef; /* clear bit 52 */
	if (neg) {
	    (*D_EXP(x)) |= 0x8000; /* set sign bit */
	}
	man = _set_exp(x,0);
    }
    else {
	man = _set_exp(x,0);
	exp = INTEXP(x);
    }

    *pexp = exp;
    return man;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\tanh.c ===
/***
*tanh.c - hyperbolic tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-22-91  GDP   support IEEE exceptions
*       06-23-92  GDP   tanh(denormal) now raises underflow exception (NCEG)
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

/* constants */
static double const EPS  = 5.16987882845642297e-26;     /* 2^(-53) / 2 */
static double const XBIG = 1.90615474653984960096e+001; /* ln(2)(53+2)/2 */
static double const C0   = 0.54930614433405484570;      /* ln(3)/2 */

/* constants for rational approximation */
static double const p0 = -0.16134119023996228053e+4;
static double const p1 = -0.99225929672236083313e+2;
static double const p2 = -0.96437492777225469787e+0;
static double const q0 =  0.48402357071988688686e+4;
static double const q1 =  0.22337720718962312926e+4;
static double const q2 =  0.11274474380534949335e+3;
static double const q3 =  0.10000000000000000000e+1;


#define Q(g)    ((((g) + q2) * (g) + q1) * (g) + q0)
#define R(g)    ((((p2 * (g) + p1) * (g) + p0) * (g)) / Q(g))

#if !defined(_M_PPC)
#pragma function(tanh)
#endif

/***
*double tanh(double x) - hyperbolic tangent
*
*Purpose:
*   Compute the hyperbolic tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*******************************************************************************/
double tanh(double x)
{
    uintptr_t savedcw;
    double f,g;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,1.0);
        case T_NINF:
            RETURN(savedcw,-1.0);
        case T_QNAN:
            return _handle_qnan1(OP_TANH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TANH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no precision exception
        RETURN(savedcw,x);
    }

    f = ABS(x);
    if (f > XBIG) {
        result = 1;
    }
    else if (f > C0) {
        result = 0.5 - 1.0 / (exp(f+f) + 1.0);
        result = result + result;
    }
    else if (f < EPS) {
        result = f;
        if (IS_D_DENORM(result)) {
            return _except1(FP_U | FP_P,OP_TANH,x,_add_exp(x, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f * f;
        result = f + f * R(g);
    }

    if (x < 0)
        result = -result;

    RETURN_INEXACT1(OP_TANH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\sources.inc ===
!INCLUDE ..\..\fp32.inc

MAJORCOMP=fp
MINORCOMP=tran

TARGETNAME=tran

INCLUDES=..\..\include;..\..\inc;..\..\inc\i386;..\..\..\crtw32\h;$(INCLUDES)

C_FLAGS=$(C_FLAGS) -Op

#removed *pentium4.asm cpu_disp.c

SOURCES=\
    ..\bessel.c    \
    ..\fpexcept.c  \
    ..\frexp.c     \
    ..\ieeemisc.c  \
    ..\ldexp.c     \
    ..\matherr.c   \
    ..\util.c

i386_SOURCES=\
    ..\87cdisp.asm   \
    ..\87ctran.asm   \
    ..\87ctriga.asm  \
    ..\87ctrigh.asm  \
    ..\87disp.asm    \
    ..\87except.c  \
    ..\87fmod.asm    \
    ..\87sqrt.asm    \
    ..\87tran.asm    \
    ..\87trig.asm    \
    ..\87triga.asm   \
    ..\87trigh.asm   \
    ..\adj_fdiv.asm  \
    ..\ceil.asm      \
    ..\common.asm    \
    ..\fabs.asm      \
    ..\filter.c    \
    ..\filter_simd.c    \
    ..\floor.asm     \
    ..\fpctrl.c    \
    ..\frnd.asm      \
    ..\fsqrt.asm     \
    ..\ftol.asm      \
    ..\ftol2.asm     \
    ..\genexcep.asm  \
    ..\huge.asm      \
    ..\hypot.c     \
    ..\ieee87.c    \
    ..\modf.asm      \
    ..\powhlp.asm    \
    ..\testfdiv.c  \
    ..\asin.asm      \
    ..\acos.asm      \
    ..\atan.asm      \
    ..\sin.asm       \
    ..\cos.asm       \
    ..\tan.asm       \
    ..\log.asm       \
    ..\log10.asm     \
    ..\pow.asm       \
    ..\sqrt.asm      \
    ..\xmmi_fp_emul.c      \
    ..\xmmi2_fp_emul.c  \
    ..\atan_table.c  \
    ..\libm_error.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\sincos.c ===
/***
*sincos.c - sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        9-29-91  GDP   added missing ABS() for cosine
*       12-26-91  GDP   IEEE exceptions support
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS, use _frnd for rounding
*       06-23-92  GDP   sin(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sin, cos)
#endif

static double _sincos(double x, double y, double sin);

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI     = 3.14159265358979323846;
static double const PI2    = 1.57079632679489661923; /* pi/2 */
static double const PI_INV = 0.31830988618379067154; /* 1/pi */
static double const YMAX   = 2.2e8; /* approx. pi * 2 ^(t/2), where t=53 */

//
// The sum of C1 and C2 is a representation of PI with 66 bits in the
// significand (same as x87). (PI = 4 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x400921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3de0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the polynomial approximation of sin, cos */
static double const r1 = -0.16666666666666665052e+0;
static double const r2 =  0.83333333333331650314e-2;
static double const r3 = -0.19841269841201840457e-3;
static double const r4 =  0.27557319210152756119e-5;
static double const r5 = -0.25052106798274584544e-7;
static double const r6 =  0.16058936490371589114e-9;
static double const r7 = -0.76429178068910467734e-12;
static double const r8 =  0.27204790957888846175e-14;

#define R(g)  ((((((((r8 * (g) + r7) * (g) + r6) * (g) + r5) * (g) + r4) \
                         * (g) + r3) * (g) + r2) * (g) + r1) * (g))


/***
*double sin(double x) - sine
*
*Purpose:
*   Compute the sine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I, P, U
*   if x is denormal: raise Underflow
*******************************************************************************/
double sin (double x)
{
    uintptr_t savedcw;
    double result;
    double sign,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_SIN,x,QNAN_SIN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_SIN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SIN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no P exception
        RETURN(savedcw,x);
    }

    if (x < 0) {
        sign = -1;
        y = -x;
    }
    else {
        sign = 1;
        y = x;
    }
    if (y >= YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_SIN,x,QNAN_SIN2,savedcw);
    }

    result = _sincos(x,y,sign);

    if (IS_D_DENORM(result)) {
        return _except1(FP_U | FP_P,OP_SIN,x,_add_exp(result, IEEE_ADJUST),savedcw);
    }

    RETURN_INEXACT1(OP_SIN,x,result,savedcw);
}


/***
*double cos(double x) - cosine
*
*Purpose:
*   Compute the cosine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
*   if x is denormal: return 1
*******************************************************************************/

double cos (double x)
{
    uintptr_t savedcw;
    double result,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_COS,x,QNAN_COS1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_COS,x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COS,x,_s2qnan(x),savedcw);
        }
    }

    /* this will handle small arguments */
    if (ABS(x) < EPS) {
        if (x == 0.0) {
            RETURN(savedcw,1.0);
        }
        result = 1.0;
    }

    else {
        y = ABS(x) + PI2;
        if (y >= YMAX) {

            // The argument is too large to produce a meaningful result,
            // so this is treated as an invalid operation.
            // We also set the (extra) FP_TLOSS flag for matherr
            // support

            return _except1(FP_TLOSS | FP_I,OP_COS,x,QNAN_COS2,savedcw);
        }

        result = _sincos(x,y,1.0);
    }

    RETURN_INEXACT1(OP_COS,x,result,savedcw);
}



/***
*double _sincos(double x, double y,double sign) - cos sin helper
*
*Purpose:
*   Help computing sin or cos of a valid, within correct range
*   number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static double _sincos(double x, double y, double sign)
{
    unsigned long n;
    double xn,f,g,r,result;

    xn = _frnd(y * PI_INV);
    n = (int) xn;

    if (n & 0x1) {
        /* n is odd */
        sign = -sign;
    }
    if (ABS(x) != y) {
        /* cosine wanted */
        xn -= .5;
    }

    /* assume there is a guard digit for addition */
    f = (ABS(x) - xn * C1) - xn * C2;
    if (ABS(f) < EPS)
        result = f;
    else {
        g = f*f;
        r = R(g);
        result = f + f*r;
    }
    result *= sign;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\sincosh.c ===
/***
*sincosh.c - hyperbolic sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       02-03-92  GDP   use _exphlp for computing e^x
*       06-23-92  GDP   sinh(denormal) now raises underflow exception (NCEG)
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version.
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

extern double _exphlp(double, int *);

static double const EPS  = 5.16987882845642297e-26;    /* 2^(-53) / 2 */
/* exp(YBAR) should be close to but less than XMAX
 * and 1/exp(YBAR) should not underflow
 */
static double const YBAR = 7.00e2;

/* WMAX=ln(OVFX)+0.69 (Cody & Waite),ommited LNV, used OVFX instead of BIGX */

static double const WMAX = 1.77514678223345998953e+003;

/* constants for the rational approximation */
static double const p0 = -0.35181283430177117881e+6;
static double const p1 = -0.11563521196851768270e+5;
static double const p2 = -0.16375798202630751372e+3;
static double const p3 = -0.78966127417357099479e+0;
static double const q0 = -0.21108770058106271242e+7;
static double const q1 =  0.36162723109421836460e+5;
static double const q2 = -0.27773523119650701667e+3;
/* q3 = 1 is not used (avoid myltiplication by 1) */

#define P(f)   (((p3 * (f) + p2) * (f) + p1) * (f) + p0)
#define Q(f)   ((((f) + q2) * (f) + q1) * (f) + q0)

#if !defined(_M_PPC)
#pragma function(sinh, cosh)
#endif

/***
*double sinh(double x) - hyperbolic sine
*
*Purpose:
*   Compute the hyperbolic sine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*       I P
*       no exception if x is denormal: return x
*******************************************************************************/

double sinh(double x)
{
    uintptr_t savedcw;
    double result;
    double y,f,z,r;
    int newexp;
    int sgn;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_SINH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SINH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,x); // no precision ecxeption
    }

    y = ABS(x);
    sgn = x<0 ? -1 : +1;

    if (y > 1.0) {
        if (y > YBAR) {
            if (y > WMAX) {
                // result too large, even after scaling
                return _except1(FP_O | FP_P,OP_SINH,x,x*D_INF,savedcw);
            }

            //
            // result = exp(y)/2
            //

            result = _exphlp(y, &newexp);
            newexp --;      //divide by 2
            if (newexp > MAXEXP) {
                result = _set_exp(result, newexp-IEEE_ADJUST);
                return _except1(FP_O|FP_P,OP_SINH,x,result,savedcw);
            }
            else {
                result = _set_exp(result, newexp);
            }

        }
        else {
            z = _exphlp(y, &newexp);
            z = _set_exp(z, newexp);
            result = (z - 1/z) / 2;
        }

        if (sgn < 0) {
            result = -result;
        }
    }
    else {
        if (y < EPS) {
            result = x;
            if (IS_D_DENORM(result)) {
                return _except1(FP_U | FP_P,OP_SINH,x,_add_exp(result, IEEE_ADJUST),savedcw);
            }
        }
        else {
            f = x * x;
            r = f * (P(f) / Q(f));
            result = x + x * r;
        }
    }

    RETURN_INEXACT1(OP_SINH,x,result,savedcw);
}



/***
*double cosh(double x) - hyperbolic cosine
*
*Purpose:
*   Compute the hyperbolic cosine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*   no exception if x is denormal: return 1
*******************************************************************************/
double cosh(double x)
{
    uintptr_t savedcw;
    double y,z,result;
    int newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,D_INF);
        case T_QNAN:
            return _handle_qnan1(OP_COSH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COSH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,1.0);
    }

    y = ABS(x);
    if (y > YBAR) {
        if (y > WMAX) {
            return _except1(FP_O | FP_P,OP_COSH,x,D_INF,savedcw);
        }

        //
        // result =     exp(y)/2
        //

        result = _exphlp(y, &newexp);
        newexp --;          //divide by 2
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O|FP_P,OP_COSH,x,result,savedcw);
        }
        else {
            result = _set_exp(result, newexp);
        }
    }
    else {
        z = _exphlp(y, &newexp);
        z = _set_exp(z, newexp);
        result = (z + 1/z) / 2;
    }

    RETURN_INEXACT1(OP_COSH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\tan.c ===
/***
*tan.c - tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-30-91  GDP   support IEEE exceptions
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS
*       06-23-92  GDP   tan(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(tan)
#endif

/* constants */
static double const TWO_OVER_PI = 0.63661977236758134308;
static double const EPS  = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const YMAX = 2.98156826864790199324e8; /* 2^(53/2)*PI/2 */

//
// The sum of C1 and C2 is a representation of PI/2 with 66 bits in the
// significand (same as x87). (PI/2 = 2 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x3ff921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3dd0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the rational approximation */
/* p0 = 1.0  is not used (avoid mult by 1) */
static double const p1 = -0.13338350006421960681e+0;
static double const p2 =  0.34248878235890589960e-2;
static double const p3 = -0.17861707342254426711e-4;
static double const q0 =  0.10000000000000000000e+1;
static double const q1 = -0.46671683339755294240e+0;
static double const q2 =  0.25663832289440112864e-1;
static double const q3 = -0.31181531907010027307e-3;
static double const q4 =  0.49819433993786512270e-6;


#define Q(g)   ((((q4 * (g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define P(g,f)  (((p3 * (g) + p2) * (g) + p1) * (g) * (f) + (f))

#define ISODD(i) ((i)&0x1)


/***
*double tan(double x) - tangent
*
*Purpose:
*   Compute the tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I, U
*   if x is denormal: raise underflow
*******************************************************************************/
double tan(double x)
{
    uintptr_t savedcw;
    unsigned long n;
    double xn,xnum,xden;
    double f,g,result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_TAN,x,QNAN_TAN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_TAN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw, x);

    if (ABS(x) > YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_TAN,x,QNAN_TAN2,savedcw);
    }

    xn = _frnd(x * TWO_OVER_PI);
    n = (unsigned long) fabs(xn);


    /* assume there is a guard digit for addition */
    f = (x - xn * C1) - xn * C2;
    if (ABS(f) < EPS) {
        xnum = f;
        xden = 1;
        if (IS_D_DENORM(f)) {
            return _except1(FP_U | FP_P,OP_TAN,x,_add_exp(f, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f*f;
        xnum = P(g,f);
        xden = Q(g);
    }

    if (ISODD(n)) {
        xnum = -xnum;
        result = xden/xnum;
    }
    else
        result = xnum/xden;

    RETURN_INEXACT1(OP_TAN,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87cdisp.asm ===
page	,132
	title	87cdisp  - C transcendental function dispatcher
;*** 
;87cdisp.asm - C transcendental function dispatcher (80x87/emulator version)
;
;   Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common dispatch code and error handling for C transcendental functions
;
;Revision History:
;   07-04-84  GFW   initial version
;   12-21-84  GFW   correctly point to name in matherr struct
;   05-12-85  GFW   return HUGE correctly signed on ERANGE errors
;		    fill 2nd operand for matherr structure correctly
;   07-05-85  GFW   check for possible overflow on PLOSS errors
;		    in this case OVERFLOW overrides PLOSS
;   07-08-85  GFW   added FWAIT in useHUGE
;   11-20-85  GFW   faster RANGE checking
;   09-30-86  JMB   internationalized error message handling
;   03-09-87  BCM   changed writestr to _wrt2err (extern)
;   04-14-87  BCM   log(0.0) and log10(0.0) sets errno to ERANGE
;		    for MS C 5.0 (ANSI compatible); errno is still
;		    set to EDOM for IBM C 2.0 (System V compatible).
;   04-28-87  BCM   Added _cintrindisp1 and _cintrindisp2
;		    for C "intrinsic" versions of pow, log, log10, exp,
;		    cos, sin, tan, acos, asin, atan, atan2,
;		    cosh, sinh, tanh, sqrt, ... for MS C 5.0
;   08-04-87  BCM   Removed "externP write" declaration.
;   08-17-87  BCM   Changed _wrt2err from near to model-dependent
;		    except for IMBC20; this is because of QC core lib
;   10-12-87  BCM   OS/2 support C library changes
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt, nomt
;   02-10-88  WAJ   MTHREAD libraries now lock stderr  when printing errors
;   04-25-88  WAJ   _cpower is on the stack for MTHREAD so must be set to 1
;   07-11-88  WAJ   address of matherr structure was incorrect in MTHREAD case
;   08-24-88  WAJ   386 version.
;   11-20-89  WAJ   386 MTHREAD is no longer _pascal.
;   08-17-90  WAJ   Now uses _stdcall.
;   10-15-90  WAJ   Fixed intrinsic/2 argument problems.
;   05-17-91  WAJ   Added _STDCALL ifdefs.
;   08-27-91  JCR   ANSI naming
;   09-15-91  GDP   Added _cwrt2err. _NMSG_WRITE is no longer _pascal
;   11-15-91  GDP   Removed error message display stuff
;		    moved exception structure to stack frame, even for
;			single thread code (allow recursive calls of
;			transcendentals through matherr)
;		    call _87except after fsave
;		    put Localfac on the stack for multi thread
;   02-10-92  GDP   changed error handling avoid polluting the fp status word
;   03-15-92  GDP   extensive changes in error detection scheme
;   10-27-92  SKS   Re-arranged some code to make this work with MASM 6.10
;   11-06-92  GDP   merged changes from the fp tree on \\vangogh: removed
;		    saveflag, added __fastflag, new range error checking
;   09-06-94  CFW   Replace MTHREAD with _MT.
;   04-06-01  PML   CHECKOVER should check overflow, not underflow (vs7#132450)
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include os2supp.inc
	include elem87.inc
.list


EDOM =		33		; math error numbers
ERANGE =	34

EDOMAIN =	120		; internal error number for DOMAIN
ESING = 	121		; internal error number for SING
ETLOSS =	122		; internal error number for TLOSS



	.data

comm	_matherr_flag:dword
extrn	__fastflag:dword

	.const

staticQ DblMax,	      07fefffffffffffffR
staticQ DblMin,       00010000000000000R
staticQ IeeeAdjO,     0c098000000000000R
staticQ IeeeAdjU,     04098000000000000R
staticQ _infinity,    07ff0000000000000R
staticQ _zero,	      00000000000000000R

ifndef	_MT

	.data?

staticQ LocalFac,     ?
intrinflag  db	    ?

else	;_MT


MTStackFrame	struc
    MTS_LocalFac   dq	?
    MTS_cdispflags db	?
MTStackFrame	ends

MTSFISize equ	((size MTStackFrame) + ISIZE - 1) and (not (ISIZE-1))


LocalFac    equ     <MTSF.MTS_LocalFac>
cdispflags  equ     <MTSF.MTS_cdispflags>

INTRINFLAG = 01h
TWOARGFLAG = 02h

endif	;_MT

;	error value action table

;labelW	retvaltab
;    DNCPTR  codeOFFSET useretval
page


	CODESEG

extrn	_trandisp1:near
extrn	_trandisp2:near
extrn	_87except:proc




;----------------------------------------------------------
;
;	intrinsic versions: TRANSCENDENTAL DISPATCH ROUTINES
;
;----------------------------------------------------------
;
;	_cintrindisp1 - Intrinsic Dispatch for 1 arg DP transcendental
;	_cintrindisp2 - Intrinsic Dispatch for 2 arg DP transcendental
;
;	rdx - function dispatch table address
;
;----------------------------------------------------------


_cintrindisp2	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	fwait

	; store the args in case they are needed by matherr.
	; Generally avoid storing since this may generate
	; various exceptions (overflow, underflow, inexact, invalid)
	; Args will not be available to an exception handler and
	; users should not use /Oi if interested in IEEE conformance

	cmp	[_matherr_flag], 0
	JSE	save2arg

lab resume2

;ifmt	<mov	 [_cpower], 1>	; set _cpower to C semantics
				; DISABLED this feature since pow(0,0)
				; will return 1 in C (NCEG spec) which
				; is the same as in FORTRAN  --GDP


	call	_trandisp2

ifmt	<or	 [cdispflags], (INTRINFLAG OR TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save2arg
	fxch 
	fst	[DSF.arg1]
	fxch
	fst	[DSF.arg2]
	jmp	resume2

_cintrindisp2	endp


_cintrindisp1	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	cmp	[_matherr_flag], 0
	JSE	save1arg

lab resume1

	call	_trandisp1

ifmt	<or	 [cdispflags],INTRINFLAG>
ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save1arg
	fst	[DSF.arg1]
	jmp	resume1


_cintrindisp1	endp




;*******************************************************************************
;*
;*	TRANSCENDENTAL DISPATCH ROUTINES
;*
;*******************************************************************************
;*
;*	_ctrandisp1 - Dispatch for 1 arg DP transcendental
;*	_ctrandisp2 - Dispatch for 2 arg DP transcendental
;*
;*	edx - function dispatch table address
;*
;*******************************************************************************

;*
;*  Two arg standard dispatch.
;*

_ctrandisp2  proc  uses ebx, parm1:qword, parm2:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local  MTSF[MTSFISize]:IWORD>


	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif
	push	dword ptr [parm2+4]	 ; load arg2
	push	dword ptr [parm2]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<or	 [cdispflags], TWOARGFLAG>
ifmt	<mov	 [_cpower], 1>		    ; set _cpower to C semantics

	call	_trandisp2

	call	ctranexit

ifdef _STDCALL
	ret	16
else
	ret
endif

;*
;*  Check for overflow and errors.
;*



ctranexit::

ifmt	<and	 [cdispflags], (NOT INTRINFLAG)>
nomt	<mov	 [intrinflag], 0>

cintrinexit::
	cmp	__fastflag, 0
	JSNZ	restoreCW

	fst	qword ptr [LocalFac]	; cast result to double precision

	;
	; PROBLEM: Since the intrinsics may be given an argument anywhere
	; in the long double range, functions that are not normally
	; expected to overflow (like sqrt) may generate IEEE exceptions
	; at this point. We can cure this by making the checkrange test
	; standard.
	;


	mov	al, [DSF.ErrorType]	; check for errors
	or	al, al
	JE	checkinexact
	cmp	al, CHECKOVER
	JE	checkoverflow
	cmp	al, CHECKRANGE
	JSE	checkrng
	or	al, al
	JSE	restoreCW
	CBI
	mov	[DSF.typ], rax		; set exception type
	jmp	haveerror


lab checkinexact

	; This will be the most common path because of
	; the nature of transcendentals. If inexact is
	; unmasked in user's cw and active, raise it

	mov	ax, [DSF.savCntrl]
	and	ax, 20h
	JSNZ	restoreCW		; inexact exception masked
	fstsw	ax
	and	ax, 20h
	JSZ	restoreCW
	mov	[DSF.typ], INEXACT
	jmp	haveerror


lab restoreCW
lab restoreCW2
	fldcw	[DSF.savCntrl]		; load old control word
	fwait

	retn



lab checkrng
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	or	ax, ax
	JSE	haveunderflow
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab checkoverflow
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab haveunderflow
	mov	[DSF.typ], UNDERFLOW
	fld	IeeeAdjU
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMin]
	fstsw	ax
	sahf
	JSAE	haveerror
	fmul	[_zero]
	jmp	short haveerror

lab haveoverflow
	mov	[DSF.typ], OVERFLOW
	fld	IeeeAdjO
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMax]
	fstsw	ax
	sahf
	JSBE	haveerror
	fmul	[_infinity]

lab haveerror
;	fill error structure and call matherr

	push	rsi			; save si
	push	rdi

	mov	rbx, [DSF.Function]	; get function jmp table address
	inc	rbx

	mov	[DSF.nam], rbx		; save name address


ifmt	<test	 cdispflags, INTRINFLAG>
nomt	<cmp	 [intrinflag], 0>

	JSNE	aftercopy
;
; copy function args (for matherr structure) 
;
	cld
	lea	esi, [parm1]
	lea	edi, [DSF.arg1]
	movsd
	movsd
	cmp	[rbx-1].fnumarg, 1	; check for 2nd parameter
	JSE	aftercopy
	lea	esi, [parm2]
	lea	edi, [DSF.arg2]
	movsd
	movsd

lab aftercopy
lab useretval
	fstp	[DSF.retval]		; store return value


	;
	; If intrinsic calling convention, an 'fsave' is required
	; before matherr starts doing any fp operations.
	; (This needs to be documented.)

	lea	rax, [DSF.typ]
	lea	rbx, [DSF.savCntrl]
	push	rbx
	push	rax
	mov	rbx, [DSF.function]
	mov	al, [rbx].fnumber
	CBI
	push	rax
	call	_87except		; _fpexcept(&exception, &savedcw)
ifndef _STDCALL
	add	esp, 12			; clear arguments if _cdecl.
endif

lab movretval
	pop	rdi			; restore di
	pop	rsi			; restore si
	fld	[DSF.retval]		; this assumes that the user
					; does not want to return a
					; signaling NaN

	jmp	restoreCW		;  restore CW and return

_ctrandisp2  endp




;*
;*  One arg standard dispatch.
;*

_ctrandisp1 proc  uses ebx, parm1:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local	MTSF[MTSFISize]:IWORD>

	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>

	call	_trandisp1

	call	ctranexit

ifdef _STDCALL
	ret	8
else
	ret
endif


_ctrandisp1  endp



;
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
;


_fload	proc	uses ebx, parm:qword
	local	tmp:tbyte

	mov	ax, word ptr [parm+6]  ; get exponent field
	mov	bx, ax		       ; save it
	and	ax, 07ff0h
	cmp	ax, 07ff0h	       ; check for special exponent
	JSNE	fpload
				       ; have special argument (NaN or INF)
	or	bx, 07fffh	       ; preserve sign, set max long double exp
	mov	word ptr [tmp+8], bx
				       ; convert to long double
	mov	eax, dword ptr [parm+4]
	mov	ebx, dword ptr [parm]
	shld	eax, ebx, 11
				       ; the MSB of the significand is
				       ; already 1 because of the exponent value
	mov	dword ptr [tmp+4], eax
	mov	dword ptr [tmp], ebx
	fld	tmp
	jmp	short return

lab fpload
	fld	parm
lab return
ifdef _STDCALL
	ret	8
else
	ret
endif

_fload endp





end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87ctrigh.asm ===
page	,132
	title	87ctrigh - C interfaces - sinh, cosh, tanh
;***
;87ctrigh.asm - hyperbolic trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for sinh, cosh, tanh functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_SINHjmptab:word
extrn _OP_COSHjmptab:word
extrn _OP_TANHjmptab:word

page

	CODESEG

extrn _ctrandisp1:near
extrn _ctrandisp2:near


	public	sinh
sinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
disp1::
	jmp	_ctrandisp1

sinh	endp


	public	cosh
cosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	disp1

cosh	endp


	public	tanh
tanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	disp1

tanh	endp


extrn _cintrindisp1:near
extrn _cintrindisp2:near


	public	_CIsinh
_CIsinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
idisp1::
	jmp	_cintrindisp1

_CIsinh	endp


	public	_CIcosh
_CIcosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	idisp1

_CIcosh	endp


	public	_CItanh
_CItanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	idisp1

_CItanh	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87ctrig.asm ===
page	,132
	title	87ctrig - C interfaces - sin, cos, tan
;***
;87ctrig.asm - trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sin, cos, and tan functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data
extrn _OP_SINjmptab:word
extrn _OP_COSjmptab:word
extrn _OP_TANjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near
extrn	_ctrandisp2:near


	public	oldsin
oldsin	proc

	mov	edx, OFFSET _OP_SINjmptab
trigdisp::
	jmp	_ctrandisp1

oldsin	endp


	public	oldcos
oldcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	trigdisp

oldcos	endp


	public	oldtan
oldtan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	trigdisp

oldtan	endp


extrn	_cintrindisp1:near
extrn	_cintrindisp2:near


	public	_old_CIsin
_old_CIsin	proc

	mov	edx, OFFSET _OP_SINjmptab
itrigdisp::
	jmp	_cintrindisp1

_old_CIsin	endp


	public	_old_CIcos
_old_CIcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	itrigdisp

_old_CIcos	endp


	public	_old_CItan
_old_CItan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	itrigdisp

_old_CItan	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87ctriga.asm ===
page	,132
	title	87ctriga - C interfaces - asin, acos, atan, atan2
;***
;87ctriga.asm - inverse trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for asin, acos, atan, atan2 (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_ATAN2jmptab:word

page

	CODESEG

extrn _ctrandisp2:near

	public	atan2
atan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_ctrandisp2

atan2	endp


extrn _cintrindisp2:near

	public	_CIatan2
_CIatan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_cintrindisp2

_CIatan2	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87disp.asm ===
page	,132
	title	87disp - common transcendental dispatch routine
;*** 
;87disp.asm - common transcendental dispatch routine (80x87/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common transcendental dispatch routine (80x87/emulator version)
;
;Revision History:
;   07-07-84  GFW initial version
;   11-20-85  GFW mask overflow/underflow/precision exceptions;
;		  fixed affine/projective infinity confusion
;   09-12-86  BCM added _Flanguage to distinguish languages
;   10-21-86  BCM use _cpower rather than _Flanguage to
;		  distinguish C and FORTRAN exponentiation semantics
;   06-11-87  GFW faster dispatch code - all in-line
;   10-26-87  BCM minor changes for new cmacros.inc
;   04-25-88  WAJ _cpower is now on stack for MTHREAD
;   08-24-88  WAJ 386 version
;   02-01-92  GDP ported to NT
;   09-06-94  CFW Replace MTHREAD with _MT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

globalT _indefinite,  0FFFFC000000000000000R
globalT _piby2,       03FFFC90FDAA22168C235R
staticQ One,	      03FF0000000000000R


ifndef	_MT 	        ; by default assume C pow() semantics
globalB _cpower, 1	; if zero, assume FORTRAN (or other) exponentiation
endif	;_MT	        ;    semantics



labelB	XAMtoTagTab
			    ; C2 C1 C0 C3   Meaning	   Meaning  Tag   0
	db	2 * ISIZE   ;  0  0  0	0  +Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  0  0	1  +Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  0  1	0  +NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  0  1	1   Empty     =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  0	0  -Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  1  0	1  -Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  1  1	0  -NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  0  0	0  +Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  0  0	1  +Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  0  1	0  +Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  0  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  1  0	0  -Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  1  0	1  -Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  1  1	0  -Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  1  1	1   Empty     =>   NAN	     10   0


	CODESEG

xamTOS	macro
	cmp	[rdx].fnumber, OP_SQRT	; check for sqrt
	JSNE	cwdefault
	mov	bx, word ptr (DSF.savCntrl)
	or	bh, 2			; set precision control to 53 bits
	and	bh, 0feh
	mov	bl, 03fh		; mask exceptions
	jmp	setcw
lab cwdefault
	mov	bx, 133fh		; default cw
lab setcw
	mov	DSF.setCntrl, bx	; set new control word
	fldcw	DSF.setCntrl		; load new control word
	mov	rbx, dataoffset XAMtoTagTab	; Prepare for XLAT
	fxam
	mov	DSF.Function, rdx	; save function jmp table address
	fstsw	DSF.StatusWord
	mov	DSF.ErrorType, 0	; clear error code
	endm

comdisp macro
	CBI
	and	rcx, 0404h		; clear all but signs from CX
	mov	rbx, rdx
	add	rbx, rax
	add	rbx, size funtab	; skip over name, error vals, etc.
	jmp	[rbx]			; jmp to function
	endm

; Will dispatch  to  the  special  case routines for the single argument
; transcendental functions.  It assumes on  entry  that  the  8087 stack
; has the  argument  on  the  top  of its stack and that DX has been set
; to the address of the dispatch table (which should be in  Tag  order).
; This routine	will  FXAM  the top of the 8087 stack, generate Tag info
; from the condition code, and jump to the corresponding dispatch  table
; entry.  In the process of creating the offset for the XLAT instruction
; bit 2 of CL will be loaded with  the sign of the argument.  DI may not
; be used in any computations.

_trandisp1  proc    near

	xamTOS				; setup control word and check TOS

	fwait
	mov	cl, CondCode
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat

	comdisp

_trandisp1  endp


; Will dispatch to the special case routines  for  the	double	argument
; transcendental functions.   It  assumes on entry that the 8087 has arg1
; next to the top and arg2 on top of the 8087  stack  and  that  DX  has
; been set  to	the  address  of  the dispatch table (which should be in
; Tag-arg1,Tag-arg2  order).   This  routine  will  FXAM  the  top   two
; registers of	the  8087  stack,generate  Tag info from the condition
; codes, and jump to the corresponding	dispatch  table entry.	 In  the
; process of  creating	the  offsets  for  the	XLAT statements bit 2 of
; CH and bit 2 of CL will be loaded with  the  signs  of  the  arguments
; next to the  top and on top, respectively, of  the 8087 stack.  DI may
; not be used in any computations.

_trandisp2  proc    near

	xamTOS				; setup control word and check TOS

	fxch
	mov	cl, CondCode
	fxam
	fstsw	DSF.StatusWord
	fxch
	mov	ch, CondCode
	shl	ch, 1
	sar	ch, 1
	rol	ch, 1
	mov	al, ch
	and	al, 0fh
	xlat
	mov	ah, al
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat
	shl	ah, 1
	shl	ah, 1
	or	al, ah

	comdisp

_trandisp2  endp



page
;----------------------------------------------------------
;
;	SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The signs of the last, second to last
;		 arguments are in CH, CL respectively.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rttospopde, PUBLIC
	call	setDOMAIN

labelNP _rttospop, PUBLIC
	fxch				; remove ST(1)

labelNP _rtnospop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rttosnpop, PUBLIC
	ret				; return TOS

labelNP _rtnospopde, PUBLIC
	call	setDOMAIN
	jmp	_rtnospop


;----------------------------------------------------------

labelNP _rtzeropop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtzeronpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fldz				; push 0.0 onto stack
	ret

;----------------------------------------------------------

labelNP _rtonepop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtonenpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld1				; push 1.0 onto stack
	ret

;----------------------------------------------------------

isQNAN macro
	fstp	DSF.Fac 		; use ten byte storage
	fld	DSF.Fac
	test	byte ptr [DSF.Fac+7], 40h ; Test for QNaN or SNaN
	endm


labelNP _tosnan1, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan1
	mov	DSF.Errortype, DOMAIN_QNAN
	ret
lab _tossnan1
	mov	DSF.Errortype, DOMAIN
	fadd	[One]			; Convert SNaN to QNaN
	ret

labelNP _nosnan2, PUBLIC		; ST(1) is a NaN
	fxch
labelNP _tosnan2, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_tosnan2ret
lab _tossnan2
	mov	DSF.Errortype, DOMAIN
lab _tosnan2ret
	fadd				; Propagate NaN and pop
	ret

labelNP _nan2, PUBLIC
	isQNAN
	JSZ	_snan2
	fxch
	isQNAN
	JSZ	_snan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_nan2ret
lab _snan2
	mov	DSF.Errortype, DOMAIN
lab _nan2ret
	fadd				; Propagate NaN and pop
	ret




;----------------------------------------------------------

labelNP _rtindfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtindfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_indefinite]		; push real indefinite onto stack
	cmp	DSF.ErrorType, 0	; if error set
	JSG	retj			;   must be SING, don't set DOMAIN

labelNP _rttosnpopde, PUBLIC
lab setDOMAIN
	mov	DSF.ErrorType, DOMAIN
lab retj
	or	cl, cl			; test sign in cl
	ret


;----------------------------------------------------------

labelNP _rtchsifneg, PUBLIC
	or	cl, cl			; if arg is negative
	JSZ	chsifnegret		;    negate top of stack
	fchs
lab chsifnegret
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87csqrt.asm ===
page	,132
	title	87csqrt - C interfaces - sqrt
;***
;87csqrt.asm - sqrt functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sqrt function (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CIsqrt)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version.
;   11-20-89  WAJ   Don't need pascal for 386 MTHREAD.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list


	.data
extrn	_OP_SQRTjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near


	public	oldsqr
oldsqr	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_ctrandisp1

oldsqr	endp


extrn	_cintrindisp1:near


	public	_old_CIsqrt
_old_CIsqrt	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_cintrindisp1

_old_CIsqrt	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87ctran.asm ===
page	,132
	title	87ctran - C interfaces - exp, log, log10, pow
;***
;87ctran.asm - exp, log, log10, pow functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for exp, log, log10, pow functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

_FUNC_     equ	<exp>
_FUNC_DEF_ equ	<_exp_default>
_FUNC_P4_  equ	<_exp_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIexp>
_FUNC_DEF_ equ	<_CIexp_default>
_FUNC_P4_  equ	<_CIexp_pentium4>
	include	disp_pentium4.inc

	.data

extrn _OP_EXPjmptab:word


page

	CODESEG

extrn	_ctrandisp1:near

	public	_exp_default
_exp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_ctrandisp1

_exp_default endp


extrn	_cintrindisp1:near

	public	_CIexp_default
_CIexp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_cintrindisp1

_CIexp_default endp



	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87fmod.asm ===
page	,132
	title	87fmod	 - fmod function
;***
;87fmod.asm - fmod function (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Implements fmod() library function for computing floating-point
;   remainder.	Uses FPREM 8087 instruction or its emulated equivalent.
;
;Revision History:
;	12-09-84  GFW	Added copyright message
;	05-12-85  GFW	Changed fmod(x,0) = 0 for System V.2 compatibility
;	10-15-86  GFW	In-line instructions rather than call _fpmath
;	05-08-87  BCM	Added intrinsic version (_CIfmod)
;	10-12-87  BCM	OS/2 support C library changes
;			Including pascal naming and calling conv. & no _fac
;	01-18-88  BCM	Eliminated IBMC20 switches; ifos2,noos2 ==> ifmt,nomt
;			OS2_SUPPORT ==> MTHREAD
;	08-26-88  WAJ	386 version.
;	08-17-90  WAJ	Now uses _stdcall.
;	05-17-91  WAJ	Added _STDCALL ifdefs.
;	03-04-92  GDP	Changed behavior for INF args
;	03-22-92  GDP	Fixed bug: removed fxch out of the remloop
;	09-22-93  SKS	Removed obsolete _FIamod (no longer needed by FORTRAN)
;	12-09-94  JWM	Modified fFMOD to test for bogus Pentiums and call an FPREM workaround
;	12-13-94  SKS	Correct spelling of _adjust_fdiv
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************


.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

    .data

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif

jmptab	OP_FMOD,4,<'fmod',0,0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFMOD	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtzeropop	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtindfpop	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf


page

	CODESEG

extrn	_ctrandisp2:near
extrn	_cintrindisp2:near


extrn	_rtindfpop:near
extrn	_rtnospop:near
extrn	_rtzeropop:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

ifndef NT_BUILD
extrn	_adj_fprem:near
endif

.386

;***
;fFMOD - floating-point remainder (8087/emulator intrinsic version)
;Purpose:
;	fmod(x,y) computes floating-point remainder of x/y, i.e. the
;	floating-point number f such that x = iy + f where f and x have
;	the same sign, and |f| < |y|, and i is an integer.
;
;	Uses the FPREM instruction to compute the remainder.
;	(Formerly used FDIV.)
;
;Entry:
;	floating-point numerator in ST(1)
;	floating-point denominator in ST(0)
;
;Exit:
;	floating-point result in ST(0);
;	(pops one of the arguments, replaces the other with the result)	
;
;Uses:
;	AX, Flags.
;
;Exceptions:
;	fmod(x, 0.0) currently returns 0.0 -- see System V specification
;*******************************************************************************


	public	fmod
fmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp     _ctrandisp2

fmod	endp


	public	_CIfmod
_CIfmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp	_cintrindisp2

_CIfmod	endp


lab fFMOD
	fxch

lab remloop

ifdef NT_BUILD				; NT handles the P5 bug in the OS
	fprem				; do fprem's until reduction is done
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fprem
	fprem				; do fprem's until reduction is done
	jmp		fprem_done
lab badP5_fprem
	call	_adj_fprem
lab fprem_done
endif
	fstsw	ax
	fwait
	sahf				; load fprem flags into flags
	JSPE	remloop 		;   not done with range reduction

	fstp	st(1)			; get rid of divisor
	ret


end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87except.c ===
/***
*87except.c - floating point exception handling
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*   8-24-91	GDP	written
*   9-26-91	GDP	changed DOMAIN error handling
*   1-29-91	GDP	renamed to 87exept.c
*   3-15-92	GDP	support raising exceptions
*
*******************************************************************************/
#include <errno.h>
#include <math.h>
#include <trans.h>


#define _DOMAIN_QNAN	7 /* should be in sync with elem87.inc */
#define _INEXACT	8 /* should be in sync with elem87.inc */

int _matherr_flag;
extern void _raise_exc(_FPIEEE_RECORD *prec,unsigned int *pcw,
    int flags, int opcode, double *parg1, double *presult);
extern void _set_errno(int matherrtype);
extern int _handle_exc(unsigned int flags, double * presult, unsigned int cw);




/***
*double _87except(struct _exception *except, unsigned int *cw)
*
*Purpose:
*   Handle floating point exceptions.
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/

void _87except(int opcode, struct _exception *exc, unsigned short *pcw16)
{
    int fixed;
    unsigned int flags;
    unsigned int cw, *pcw;

    //
    // convert fp control word into an unsigned int
    //

    cw = *pcw16;
    pcw = &cw;

    switch (exc->type) {
    case _DOMAIN:
    case _TLOSS:
	flags = FP_I;
	break;
    case _OVERFLOW:
	flags = FP_O | FP_P;
	break;
    case _UNDERFLOW:
	flags = FP_U | FP_P;
	break;
    case _SING:
	flags = FP_Z;
	break;
    case _INEXACT:
	flags = FP_P;
	break;
    case _DOMAIN_QNAN:
	exc->type = _DOMAIN;
	// no break
    default:
	flags = 0;
    }



    if (flags && _handle_exc(flags, &exc->retval, *pcw) == 0) {

	//
	// trap should be taken
	//

	_FPIEEE_RECORD rec;

	//
	// fill in operand2 info. The rest of rec will be
	// filled in by _raise_exc
	//

	switch (opcode) {
	case OP_POW:
	case OP_FMOD:
	case OP_ATAN2:
	    rec.Operand2.OperandValid = 1;
	    rec.Operand2.Format = _FpFormatFp64;
	    rec.Operand2.Value.Fp64Value = exc->arg2;
	    break;
	default:
	    rec.Operand2.OperandValid = 0;
	}

	_raise_exc(&rec,
		   pcw,
		   flags,
		   opcode,
		   &exc->arg1,
		   &exc->retval);
    }


    /* restore cw  */
    _rstorfp(*pcw);

    fixed = 0;

    if (exc->type != _INEXACT &&
	! _matherr_flag) {
	fixed = _matherr(exc);
    }
    if (!fixed) {
	_set_errno(exc->type);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87sqrt.asm ===
page	,132
	title	87sqrt	 - square root - SQRT
;*** 
;87sqrt.asm - common square root support (80x87/emulator version)
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Common support for the sqrt function (80x87/emulator version)
;
;Revision History:
;	07-04-84  GFW initial version
;	10-26-87  BCM minor changes for new cmacros.inc
;	08-24-88  WAJ 386 version
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	CODESEG

extrn	_rtindfnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	SQUARE ROOT FUNCTIONS
;
;----------------------------------------------------------

lab fFSQRT
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop		;    return indefinite if negative
	fsqrt				; calculate the square root of TOS
	ret

lab _rtforsqrtinf
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop
	ret				; return infinity

lab _rtforsqrtzero			; zero or denormal
	ftst
	fstsw	ax
	fwait
	sahf
	JSNZ	fFSQRT			; denormal operand
	ret				; return +0 or -0 (IEEE std)

lab sqrtindfnpop
	jmp	_rtindfnpop		; return indefinite

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\acos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ACOS_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87trigh.asm ===
page	,132
	title   87trigh   - hyperbolic trigonometric functions - SINH, COSH, TANH
;*** 
;87trigh.asm - hyperbolic trigonometric functions - SINH, COSH, TANH
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for SINH, COSH, TANH
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/31/85	Jamie Bariteau
;		made _fFSINH and _fFCOSH public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port --used CHECKOVER for detection of overflow
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

extrn	_logemax:tbyte
extrn	_infinity:tbyte
staticT _tanhmaxarg,	04003987E0C9996699000R

jmptab	OP_SINH,4,<'sinh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFSINH	; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforsnhinf ; 0011 TOS Inf

jmptab	OP_COSH,4,<'cosh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFCOSH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforcshinf	; 0011 TOS Inf

jmptab	OP_TANH,4,<'tanh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFTANH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtfortnhinf ; 0011 TOS Inf

page

	CODESEG

extrn	_ffexpm1:near
extrn	_rtchsifneg:near
extrn	_rtindfnpop:near
extrn	_rtinfnpop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;       HYPERBOLIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The argument is the stack top.
;                The sign of the argument is bit 2 of CL.
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------


labelNP _fFSINH, PUBLIC
lab fFSINH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforsnhlarge		;    return as if x = affine infinity
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	jmp	short SinhCoshReturn


lab fFTANH
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_tanhmaxarg]		; get largest arg, roughly ln(2)(55)/2
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041h		; if abs(arg) > XBIG (see tanh.h)
	JSNZ	_rtfortnhlarge		;    return as if x = affine infinity
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtfortnhlarge		;    return as if x = affine infinity
	fld	st(0)			; copy TOS
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics
	fxch				; get copy of e^x
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	fdivrp	st(1), st(0)		; now TOS = tanh(x)
	ret


labelNP _fFCOSH, PUBLIC
lab fFCOSH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforcnhlarge		;    return as if x = affine infinity
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics

lab SinhCoshReturn
	fld1
	fchs
	fxch
	fscale				; divide result by 2
	jmp	_rttospop

page

lab _rtforsnhinf
	fstp	st(0)
	fld	[_infinity]
	jmp	_rtchsifneg		; change sign if argument -ve

lab _rtforcshinf
	fstp	st(0)
	fld	[_infinity]
	ret

lab infpositive
	ret

lab _rtforsnhlarge
	call	_rtinfnpop		; TOS = infinity

lab chsifneg
	jmp	_rtchsifneg		; change sign if argument -ve


lab _rtforcnhlarge
	jmp	_rtinfnpop		; TOS = infinity


lab _rtfortnhlarge
	mov	DSF.ErrorType, INEXACT
lab _rtfortnhinf
	call	_rtonenpop		; TOS = one
	jmp	chsifneg		; change sign if argument -ve

page

lab fFEXPH
	fldl2e
	fmul				; convert log base e to log base 2
	xor	rbx, rbx		; clear e^x, finite result flags
	call	_ffexpm1		; TOS = e^|x|-1 unscaled, NOS = scale
	not	bl			; set finite result flag
	test	CondCode, 1		; if fraction > 0 (TOS > 0)
	JSZ	ExpHypNoInvert		;    bypass e^x-1 invert
	call	ExpHypCopyInv		; TOS = e^(-x)-1, NOS = e^x-1
	fxch
	fstp	st(0)			; remove NOS

lab ExpHypNoInvert
	test	dl, 040h		; if integer part was zero
	JSNZ	ExpHypScaled		;    bypass scaling to avoid bug
	not	bh			; set e^x flag
	fld1
	fadd				; TOS = e^x unscaled
	fscale				; now TOS = e^x

lab ExpHypScaled
	jmp	_rttospop		; TOS = e^x-1 or e^x scaled

lab ExpHypSum
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fadd				; TOS = e^x + e^(-x)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypSumReturn 	;    bypass e^x-1 adjust
	fld1
	fadd	st(1),st
	fadd				; add 2 to result

lab ExpHypSumReturn
	ret

lab ExpHypCopyInv
	fld	st(0)			; TOS = e^x (or e^x-1)
	fld1				; TOS = 1, NOS = e^x (or e^x-1)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypCopyInvReturn	;    bypass e^x-1 adjust
	fadd	st, st(1)		; TOS = e^x, NOS = e^x-1
	fchs				; TOS = -e^x, NOS = e^x-1
	fxch				; TOS = e^x-1, NOS = -e^x

lab ExpHypCopyInvReturn
	fdivrp	st(1), st(0)		; TOS = e^(-x) (or e^(-x)-1)
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87trig.asm ===
page	,132
	title	87trig	 - trigonometric functions - SIN, COS, TAN
;*** 
;87trig.asm - trigonometric functions - SIN, COS, TAN
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for SIN, COS, TAN
;
;Revision History:
;
;    11-06-91	 GDP	rewritten for 386
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	.data

extrn	_piby2:tbyte

staticT _piby4,     03FFEC90FDAA22168C235R  ; pi/4
staticD _plossval,  04D000000R		    ; 2^27
staticD _tlossval,  04F000000R		    ; 2^31


	CODESEG

extrn	_rtindfnpop:near
extrn	_rtonenpop:near
extrn	_rttosnpop:near
extrn	_rtinfnpopse:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	FORWARD TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The argument is the stack top.
;		 The sign of argument is the 04h bit of CL.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

jmponC2 macro	tag
	fstsw	ax
	fwait
	sahf
	JSP	tag
	endm



labelNP _fFCOS, PUBLIC
lab fFCOS
	fcos
	jmponC2	ArgTooLarge
	ret


labelNP _fFSIN, PUBLIC
lab fFSIN
	fsin
	jmponC2	ArgTooLarge
	ret


lab fFTAN
	fptan
	fstsw	ax
	fstp	st(0)		    ; pop TOS (fptan pushed an extra value)
	sahf
	JSP	ArgTooLarge
	ret


lab ArgTooLarge
	mov	DSF.ErrorType, TLOSS	; set TLOSS error
	jmp	_rtindfnpop



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87tran.asm ===
page	,132
	title	87tran	 - elementary functions - EXP, LOG, LN, X^Y
;***
;87tran.asm - elementary functions - EXP, LOG, LN, X^Y
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for  EXP, LOG, LN, X^Y (80x87/emulator version)
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   07/05/85	Greg Whitten
;		support x ^ y where x < 0 and y is an integer
;
;   07/08/85	Greg Whitten
;		corrected value of infinity (was a NaN)
;
;   07/26/85	Greg Whitten
;		make XENIX version truely System V compatible
;
;   10/31/85	Jamie Bariteau
;		made _fFEXP and _fFLN public labels
;
;   05/29/86	Jamie Bariteau
;		make pow return values conform to System V and
;		ANSI C standards
;
;   09/12/86	Barry McCord
;		added FORTRAN specific code to deal
;		with zero**nonpositive;
;		it requires run-time switching on language
;		for mixed-language support
;
;   10/09/86	Barry McCord
;		cotan(0.0) ==> SING error (jmp _rtinfnpopse),
;		return infinity
;
;   06/11/87	Greg Whitten
;		faster transcendental functions
;
;   06/24/87	Barry McCord
;		fixed FORTRAN 4.01 bug (bcp #1801) in which
;		an expression of the form
;		   (small positive less than one) ** (large positive)
;		was overflowing instead of underflowing to zero
;
;   10/30/87	Bill Johnston
;		made changes for os/2 support.
;
;   04/25/88	Bill Johnston
;		_cpower is now on stack for MTHREAD
;
;   05/01/88	Bill Johnston
;		si was being trashed in MTHREAD
;
;   06/03/88	Bill Johnston
;		fixed neg ^ int int MTHREAD case
;
;   08/24/88	Bill Johnston
;		386 version
;
;   11/15/91	Georgios Papagiannakopoulos
;		NT port. call _powhlp to handle special cases for pow()
;
;   04/01/91	Georgios Papagiannakopoulos
;		fixed special values: log(-INF), log(0), pow(0, neg)
;
;   10/27/92    Steve Salisbury
;		Move declaration of _powhlp out of .data declarations
;		This fix is required for use with MASM 6.10.
;
;   11/06/92	Georgios Papagiannakopoulos
;		changed special return values for NCEG conformance
;
;   09/06/94    Chris Weight
;               Change MTHREAD to _MT.
;
;   12/09/94	Jamie MacCalman
;		Modified fFEXP to test for bogus Pentiums and call an FDIV workaround
;
;   12/13/94	SKS	Correct spelling of _adjust_fdiv
;
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

	.data

globalT _infinity,	07FFF8000000000000000R
globalT _minfinity,	0FFFF8000000000000000R
globalT _logemax,	0400DB1716685B9D7A7DCR

staticT _log2max,	0400DFFFF000000000000R
staticT _smallarg,	03FFD95F619980C4336F7R
staticQ _half,		03fe0000000000000R

SBUFSIZE EQU	108

ifndef _MT
staticT _temp, 0
extrn	_cpower:byte
endif

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif


jmptab	OP_EXP,3,<'exp',0,0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFEXP       ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforexpinf ; 0011 TOS Inf

page

	CODESEG


extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonepop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near
extrn	_powhlp:proc

ifndef NT_BUILD
extrn	_safe_fdivr:near
endif

;----------------------------------------------------------
;
;	LOG AND EXPONENTIAL FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - For single argument functions the argument
;		 is the stack top.  For fFYTOX the base
;		 is next to stack top, the exponent is
;		 the stack top.
;		 For single argument functions the sign is
;		 in bit 2 of CL.  For fFYTOX the base
;		 sign is bit 2 of CH, the exponent
;		 sign is bit 2 of CL.
;
;	OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFYTOX
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	or	ch,ch		    ; base < 0
	JSNZ	negYTOX 	    ;	 check for integer power
	fxch			    ; TOS = base , NOS = exponent


lab fFXTOY
	fyl2x			    ; compute y*log2(x)
	jmp	short fF2X	    ; compute 2^(y*log2(x))



;-----------------------------------------------
;
;   Entry for exponential function (exp)
;
;-----------------------------------------------

labelNP _fFEXP, PUBLIC
lab fFEXP
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	xor	ch,ch		    ; result is always positive
	fldl2e
	fmul			    ; convert log base e to log base 2

lab fF2X
	call	_ffexpm1	    ; get exponent and (2^fraction)-1
	fld1
	fadd
	test	CondCode,1	    ; if fraction > 0 (TOS > 0)
	JSZ	ExpNoInvert	    ;	 bypass 2^x invert
	fld1
ifdef NT_BUILD			    ; NT always handles the P5 bug in the OS
	fdivrp	st(1),st(0)
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fdivr
	fdivrp	st(1),st(0)
	jmp		fdivr_done
lab badP5_fdivr
	call	_safe_fdivr
lab fdivr_done

endif

lab ExpNoInvert
	test	dl,040h 	    ; if integer part was zero
	JSNZ	ExpScaled	    ;	 bypass scaling to avoid bug
	fscale			    ; now TOS = 2^x

lab ExpScaled
	or	ch,ch		    ; check for negate flag
	JSZ	expret
	fchs			    ; negate result (negreal ^ odd integer)
lab expret
	jmp	_rttospop



lab negYTOX			    ; check for negreal ^ integer
	call	_isintTOS
	or	eax, eax
	JSE	negYTOXerror
	xor	ch,ch
	cmp	eax, 2
	JSE	evenexp
	not	ch		    ; ch <> 0 means negative result
lab evenexp
	fxch
	fabs			    ; x is positive
	jmp	fFXTOY		    ; continue with ch <> 0 for neg result


lab _rtfor0to0
	;cmp	[_cpower], 1	    ; DISABLED (conform to NCEG spec)
	;JSE	c_0to0		    ; C requires a DOMAIN error for System V compat.
	jmp	_rtonepop	    ; MS FORTRAN has 0.0**0.0 == 1.0


c_0to0::			; System V needs DOMAIN error with 0.0 return

lab negYTOXerror
lab Yl2XArgNegative
	jmp 	_rtindfpop	; DOMAIN error or SING error
				; top of stack now has a NAN
				; 	code in 87cdisp replaces this with
				;		proper System V return value
				;		(for C only)
				;	FORTRAN keeps indefinite value but
				;		currently aborts on DOMAIN
				;		and SING errors


; FORTRAN SING error (return infinity)
;	e.g. 0.0**negative
;	and  cotan(0.0)
;

labelNP _rtinfpopse, PUBLIC
	fstp	st(0)		

labelNP _rtinfnpopse, PUBLIC
	fstp	st(0)
	fld	tbyte ptr [_infinity]
	mov	DSF.ErrorType, SING
	ret

labelNP _fFLN, PUBLIC
lab fFLN
	fldln2
	fxch
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if arg is negative or zero
	JSNZ	Yl2XArgNegative 	;    return a NAN

	fyl2x				; compute y*log2(x)
	ret


;-------------------------------------------------------
;
; Logarithmic functions (log and log 10) entry points
;
;-------------------------------------------------------

lab _rtforln0				; (we don't distinguish +0, -0)
	mov	DSF. ErrorType, SING	; set SING error
	fstp	st(0)
	fld	tbyte ptr [_minfinity]
	ret

lab _rtforloginf
	or	cl, cl			; check sign
	JSNZ	tranindfnpop		; if negetive return indefinite
	ret				; else return +INF
					; no overflow in this case (IEEE)





lab fFLOGm
	fldlg2				; main LOG10 entry point
	jmp	short fFYL2Xm

lab fFLNm				; main LN entry point
	fldln2

lab fFYL2Xm
	fxch
	or	cl, cl			; if arg is negative
	JSNZ	Yl2XArgNegative 	;    return a NAN
	fyl2x				; compute y*log2(x)
	ret

page

lab _rtforyto0
	jmp	_rtonepop		; return 1.0


lab _rtfor0tox
	call	_isintTOS
	fstp	st(0)
	fstp	st(0)
	or	cl, cl			; if 0^(-valid)
	JSNZ	_rtfor0toneg		;    do more checking
	fldz
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
lab zerotoxdone
	ret


lab _rtfor0toneg
	mov	DSF.ErrorType, SING
	fld	tbyte ptr [_infinity]
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
	jmp	zerotoxdone


lab tranzeropop
	fstp	st(0)			; toss 1 stack entry

lab tranzeronpop
	jmp	_rtzeronpop


lab tranindfpop
	fstp	st(0)			; toss 1 stack entry

lab tranindfnpop
	jmp	_rtindfnpop


lab ExpArgOutOfRange
	pop	rax			; remove return address from stack
					; We need to check the sign of the
					; exponent to distinguish underflow
					; from overflow.  We cannot just check
					; CL directly since for the XtoY case,
					; the exponent is a product of Y*log2(x)
					; and not an original argument that
					; has already been thru FXAM.  So,
					; the following instructions were
					; substituted to fix FORTRAN 4.01
					; bcp #1801)

	ftst				; check if exponent was negative large
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 01h		; if valid^(-large)
	JSNZ	zeronpopue		; underflow error/return zero
	fstp	st(0)			; else return infinity/overflow
	fld	[_infinity]
	or	ch, ch
	JSZ	_expbigret
	fchs
lab _expbigret
	ret

lab zeronpopue
	mov	DSF.ErrorType, UNDERFLOW
	jmp	_rtzeronpop


labelNP _rtinfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtinfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_infinity]		; push infinity onto stack
lab setOVERFLOW
	mov	DSF.ErrorType, OVERFLOW ;  set OVERFLOW error
	ret


lab _rtforexpinf
	or	cl, cl
	JSNZ	tranzeronpop		; if exp(-infinity) return +zero
	fstp	st(0)
	fld	[_infinity]		; return infinity, no overflow
	ret

labelNP _ffexpm1, PUBLIC
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_log2max]		; get log2 of largest number
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if abs(arg) >= 2^15-.5
	JSNZ	ExpArgOutOfRange	;    perform arg out of range routine
	fld	st(0)			; copy TOS
	frndint 			; near round to integer
	ftst
	fstsw	DSF.StatusWord
	fwait
	mov	dl, CondCode		; save sign of integer part
	fxch				; NOS gets integer part
	fsub	st,st(1)		; TOS gets fraction
	ftst
	fstsw	DSF.StatusWord		; store sign of fraction
	fabs
	f2xm1
	ret

;
; returns 0, 1, 2 if TOS is non-int, odd int or even int respectively
;

lab _isintTOS
	fld	st(0)
	frndint
	fcomp
	fstsw	ax
	sahf
	JSNE	notanint
	fld	st(0)		    ; it is an integer
	fmul	[_half]
	fld	st(0)
	frndint
	fcompp
	fstsw	ax
	sahf
	JSE	evenint
	mov	eax, 1
lab _isintTOSret
	ret
lab notanint
	mov	eax, 0
	jmp	_isintTOSret
lab evenint
	mov	eax, 2
	jmp	_isintTOSret






lab _usepowhlp

	push	rsi			; save rsi
	sub	rsp, SBUFSIZE+8 	; get storage for _retval and savebuf
	mov	rsi, rsp
	push	rsi			; push address for result

	sub	rsp, 8
	fstp	qword ptr [rsp]
	sub	rsp, 8
	fstp	qword ptr [rsp]

	fsave	[rsi+8]
	call	_powhlp
ifndef _STDCALL
	add	esp, 16+ISIZE		; clear arguments if _cdecl.
endif
	frstor	[rsi+8]
	fld	qword ptr [rsi] 	; load result on the NDP stack
	add	rsp, SBUFSIZE+8		; get rid of storage
	pop	rsi			; restore rsi

	test	rax, rax		; check return value for domain error
	JSZ	noerror
	jmp	_rttosnpopde

lab	noerror
	ret



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\crt\fpw32\tran\i386\87triga.asm ===
page	,132
        title   87triga   - inverse trigonometric functions - ASIN, ACOS, ATAN
;*** 
;87triga.asm - inverse trigonometric functions - ASIN, ACOS, ATAN
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for ASIN, ACOS, ATAN
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/01/84	Brad Verheiden
;		Fixed bug in _rtforatnby0 which did not remove an
;		element from the floating stack
;
;   10/28/85	Jamie Bariteau
;		Added comment about inputs to fFATN2, made fFATN2
;		public
;		made _fFATN2 and _rtpiby2 public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port -- Bug fix for atan(-INF)
;
;   03/27/92	GDP  support underflow
;
;   01/03/96	JWM  Modify return value of atan2(0,0)
;
;   05/10/00    GB   Modify return value for atan2(-0.0, 1.0)
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list



	.data

extrn	_indefinite:tbyte
extrn	_piby2:tbyte

jmptab	OP_ATAN2,5,<'atan2',0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFATN2	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0 ; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtforatn20	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatn20  ; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtforatnby0	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf

page


	CODESEG

extrn	_rtchsifneg:near
extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

;----------------------------------------------------------
;
;       INVERSE TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - For single argument function