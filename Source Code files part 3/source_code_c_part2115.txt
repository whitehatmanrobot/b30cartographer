R lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	CString strSection;
	strSection.Format(AFX_REG_PARAMS_FMT, (LPCTSTR)strProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	return reg.Read(AFX_REG_ENTRY_LARGE_ICONS, m_bLargeIcons);
}

void CMFCToolBar::OnSetFocus(CWnd* pOldWnd)
{
	CMFCBaseToolBar::OnSetFocus(pOldWnd);

	if (m_bLeaveFocus && pOldWnd != NULL && ::IsWindow(pOldWnd->GetSafeHwnd()) && DYNAMIC_DOWNCAST(CMFCToolBar, pOldWnd) == NULL &&
		DYNAMIC_DOWNCAST(CMFCToolBar, pOldWnd->GetParent()) == NULL && DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent()) == NULL)
	{
		m_hwndLastFocus = pOldWnd->GetSafeHwnd();
	}
}

void CMFCToolBar::RestoreFocus()
{
	if (::IsWindow(m_hwndLastFocus))
	{
		::SetFocus(m_hwndLastFocus);
	}

	m_hwndLastFocus = NULL;

	if (afxGlobalData.m_bUnderlineKeyboardShortcuts && !afxGlobalData.m_bSysUnderlineKeyboardShortcuts && !CMFCToolBar::IsCustomizeMode ())
	{
		afxGlobalData.m_bUnderlineKeyboardShortcuts = FALSE;
		RedrawUnderlines ();
	}
}

void CMFCToolBar::OnToolbarNewMenu()
{
	CMFCToolBarMenuButton* pMenuButton = new CMFCToolBarMenuButton;
	pMenuButton->m_bText = TRUE;
	pMenuButton->m_bImage = FALSE;

	CMFCToolBarButtonCustomizeDialog dlg(pMenuButton, m_pUserImages, this, 0, IsPureMenuButton(pMenuButton));
	if (dlg.DoModal() != IDOK)
	{
		delete pMenuButton;
		return;
	}

	m_iSelected = InsertButton(pMenuButton, m_iSelected);

	AdjustLayout();
	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);

	pMenuButton->OnClick(this, FALSE);
}

void CMFCToolBar::SetToolBarBtnText(UINT nBtnIndex, LPCTSTR szText, BOOL bShowText, BOOL bShowImage)
{
	CMFCToolBarButton* pButton = GetButton(nBtnIndex);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT(!(pButton->m_nStyle & TBBS_SEPARATOR));

	if (bShowText)
	{
		if (szText == NULL)
		{
			OnSetDefaultButtonText(pButton);
		}
		else
		{
			SetButtonText(nBtnIndex, szText);
		}
	}

	pButton->m_bText = bShowText;
	pButton->m_bImage = bShowImage;
}

void __stdcall CMFCToolBar::SetLargeIcons(BOOL bLargeIcons/* = TRUE*/)
{
	m_bLargeIcons = bLargeIcons;

	if (m_bLargeIcons)
	{
		m_sizeCurButton.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeButton.cx);
		m_sizeCurButton.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeButton.cy);

		m_sizeCurImage.cx = (int)(.5 + m_dblLargeImageRatio * m_sizeImage.cx);
		m_sizeCurImage.cy = (int)(.5 + m_dblLargeImageRatio * m_sizeImage.cy);
	}
	else
	{
		m_sizeCurButton = m_sizeButton;
		m_sizeCurImage = m_sizeImage;
	}

	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			BOOL bNeedAdjustLayout = FALSE;

			if (pToolBar->m_bLocked)
			{
				// Locked toolbars have its individual sizes
				if (m_bLargeIcons)
				{
					if (pToolBar->m_sizeCurButtonLocked.cx != (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeButtonLocked.cx) ||
						pToolBar->m_sizeCurButtonLocked.cy != (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeButtonLocked.cy) ||
						pToolBar->m_sizeCurImageLocked.cx != (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeImageLocked.cx) ||
						pToolBar->m_sizeCurImageLocked.cy != (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeImageLocked.cy))
					{
						pToolBar->m_sizeCurButtonLocked.cx = (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeButtonLocked.cx);
						pToolBar->m_sizeCurButtonLocked.cy = (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeButtonLocked.cy);

						bNeedAdjustLayout = TRUE;

						pToolBar->m_sizeCurImageLocked.cx = (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeImageLocked.cx);
						pToolBar->m_sizeCurImageLocked.cy = (int)(.5 + m_dblLargeImageRatio * pToolBar->m_sizeImageLocked.cy);
					}
				}
				else
				{
					if (pToolBar->m_sizeCurButtonLocked != pToolBar->m_sizeButtonLocked || pToolBar->m_sizeCurImageLocked != pToolBar->m_sizeImageLocked)
					{
						bNeedAdjustLayout = TRUE;

						pToolBar->m_sizeCurButtonLocked = pToolBar->m_sizeButtonLocked;
						pToolBar->m_sizeCurImageLocked = pToolBar->m_sizeImageLocked;
					}
				}
			}
			else
			{
				bNeedAdjustLayout = TRUE;
			}

			if (bNeedAdjustLayout)
			{
				pToolBar->AdjustLayout();

				if (pToolBar->m_bLocked)
				{
					CBasePane* pParentBar = DYNAMIC_DOWNCAST(CBasePane, pToolBar->GetParent());
					if (pParentBar != NULL)
					{
						pParentBar->AdjustLayout();
					}
				}
			}
		}
	}
}

BOOL __stdcall CMFCToolBar::IsCommandRarelyUsed(UINT uiCmd)
{
	if (IsCustomizeMode() || uiCmd == 0 || uiCmd == (UINT) -1 || IsStandardCommand(uiCmd) || m_lstBasicCommands.IsEmpty())
	{
		return FALSE;
	}

	if ((uiCmd == ID_AFXBARRES_TASKPANE_BACK) || (uiCmd == ID_AFXBARRES_TASKPANE_FORWARD) || (uiCmd == ID_AFXBARRES_TASKPANE_OTHER))
	{
		return FALSE;
	}

	return !IsBasicCommand(uiCmd) && !m_UsageCount.IsFreqeuntlyUsedCmd(uiCmd);
}

BOOL __stdcall CMFCToolBar::SetCommandUsageOptions(UINT nStartCount, UINT nMinUsagePercentage)
{
	return m_UsageCount.SetOptions(nStartCount, nMinUsagePercentage);
}

void CMFCToolBar::EnableLargeIcons(BOOL bEnable)
{
	ASSERT(GetSafeHwnd() == NULL); // Should not be created yet!
	m_bLargeIconsAreEnbaled = bEnable;
}

void CMFCToolBar::EnableCustomizeButton(BOOL bEnable, int iCustomizeCmd, const CString& strCustomizeText, BOOL bQuickCustomize)
{
	if (bEnable)
	{
		if (m_pCustomizeBtn != NULL)
		{
			ASSERT_VALID(m_pCustomizeBtn);

			m_pCustomizeBtn->m_iCustomizeCmdId = iCustomizeCmd;
			m_pCustomizeBtn->m_strText =  strCustomizeText;
		}
		else
		{
			if (InsertButton(CMFCCustomizeButton(iCustomizeCmd, strCustomizeText)) < 0)
			{
				ASSERT(FALSE);
				return;
			}

			m_pCustomizeBtn = DYNAMIC_DOWNCAST(CMFCCustomizeButton, m_Buttons.GetTail());
			ASSERT_VALID(m_pCustomizeBtn);
		}

		m_bQuickCustomize = bQuickCustomize;
	}
	else if (m_pCustomizeBtn != NULL)
	{
		ASSERT_VALID(m_pCustomizeBtn);
		ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last

		m_Buttons.RemoveTail();
		delete m_pCustomizeBtn;
		m_pCustomizeBtn = NULL;
	}

	UpdateVirtualRect();
}

void CMFCToolBar::EnableCustomizeButton(BOOL bEnable, int iCustomizeCmd, UINT uiCustomizeTextResId, BOOL bQuickCustomize)
{
	CString strCustomizeText;
	ENSURE(strCustomizeText.LoadString(uiCustomizeTextResId));

	EnableCustomizeButton(bEnable, iCustomizeCmd, strCustomizeText, bQuickCustomize);
}

void CMFCToolBar::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	CMFCBaseToolBar::OnWindowPosChanging(lpwndpos);

	CMFCReBar* pBar = DYNAMIC_DOWNCAST(CMFCReBar, GetParent());
	if (pBar != NULL)
	{
		AdjustLayout();
	}
}

void CMFCToolBar::EnableTextLabels(BOOL bEnable/* = TRUE*/)
{
	if (m_bMenuMode)
	{
		ASSERT(FALSE);
		return;
	}

	m_bTextLabels = bEnable;
	AdjustLayout();
}

int CMFCToolBar::CalcMaxButtonHeight()
{
	ASSERT_VALID(this);

	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;
	m_bDrawTextLabels = FALSE;

	if (!m_bTextLabels || !bHorz)
	{
		return 0;
	}

	int nMaxBtnHeight = 0;
	CClientDC dc(this);

	CFont* pOldFont = SelectDefaultFont(&dc);
	ENSURE(pOldFont != NULL);

	// To better look, I'm assuming that all rows shoud be of the same height.
	// Calculate max. button height:
	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_bTextBelow)
		{
			if (pButton->m_strText.IsEmpty())
			{
				OnSetDefaultButtonText(pButton);
			}

			CSize sizeButton = pButton->OnCalculateSize(&dc, GetButtonSize(), bHorz);

			nMaxBtnHeight = max(nMaxBtnHeight, sizeButton.cy);
		}
	}

	m_bDrawTextLabels = (nMaxBtnHeight > GetButtonSize().cy);
	dc.SelectObject(pOldFont);
	return nMaxBtnHeight;
}

void __stdcall CMFCToolBar::ResetAllImages()
{
	m_Images.Clear();
	m_ColdImages.Clear();
	m_DisabledImages.Clear();
	m_MenuImages.Clear();
	m_DisabledMenuImages.Clear();
	m_LargeImages.Clear();
	m_LargeColdImages.Clear();
	m_LargeDisabledImages.Clear();
	m_sizeImage = CSize (16, 15);
}

void CMFCToolBar::ResetImages()
//
// Reset all toolbar images exept user-derfined to the default
//
{
	ASSERT_VALID(this);

	if (m_bLocked)
	{
		return;
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		pButton->ResetImageToDefault();
	}

	if (IsFloating())
	{
		AdjustLayout();
	}
}

BOOL CMFCToolBar::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CMFCToolBar::OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const
{
	ASSERT_VALID(pButton);

	CFrameWnd* pTopFrame = AFXGetParentFrame(this);
	if (pTopFrame == NULL)
	{
		return FALSE;
	}

	CMFCDropDownFrame* pDropFrame = DYNAMIC_DOWNCAST(CMFCDropDownFrame, pTopFrame);
	if (pDropFrame != NULL)
	{
		pTopFrame = AFXGetParentFrame(pDropFrame);
		if (pTopFrame == NULL)
		{
			return FALSE;
		}
	}

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopFrame);
	if (pMainFrame != NULL)
	{
		return pMainFrame->GetToolbarButtonToolTipText(pButton, strTTText);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pTopFrame);
		if (pFrame != NULL)
		{
			return pFrame->GetToolbarButtonToolTipText(pButton, strTTText);
		}
		else // Maybe, MDIChild frame
		{
			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTopFrame);

			if (pMDIChild != NULL)
			{
				return pMDIChild->GetToolbarButtonToolTipText(pButton, strTTText);
			}
			else // Maybe, OLE frame...
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pFrame);
				if (pOleFrame != NULL)
				{
					return pOleFrame->GetToolbarButtonToolTipText(pButton, strTTText);
				}
			}
		}
	}

	return FALSE;
}

void CMFCToolBar::OnKillFocus(CWnd* pNewWnd)
{
	CMFCBaseToolBar::OnKillFocus(pNewWnd);

	if (!IsCustomizeMode())
	{
		CMFCPopupMenu* pMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pNewWnd);
		if (pMenu == NULL || pMenu->GetParentToolBar() != this)
		{
			Deactivate();
		}
	}
}

void __stdcall CMFCToolBar::ResetAll()
{
	afxCommandManager->ClearAllCmdImages();

	POSITION pos = NULL;

	// Fill image hash by the default image ids:
	for (pos = CMFCToolBar::m_DefaultImages.GetStartPosition(); pos != NULL;)
	{
		UINT uiCmdId;
		int iImage;

		CMFCToolBar::m_DefaultImages.GetNextAssoc(pos, uiCmdId, iImage);
		afxCommandManager->SetCmdImage(uiCmdId, iImage, FALSE);
	}

	for (pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (pToolBar->CanBeRestored())
		{
			pToolBar->RestoreOriginalstate();
		}
	}
}

BOOL CMFCToolBar::TranslateChar(UINT nChar)
{
	if (!CKeyboardManager::IsKeyPrintable(nChar))
	{
		return FALSE;
	}

	UINT nUpperChar = CKeyboardManager::TranslateCharToUpper(nChar);

	CMFCToolBarButton* pButton = NULL;
	if (!m_AccelKeys.Lookup(nUpperChar, pButton))
	{
		return FALSE;
	}

	ASSERT_VALID(pButton);

	// Save animation type and disable animation:
	CMFCPopupMenu::ANIMATION_TYPE animType = CMFCPopupMenu::GetAnimationType();
	CMFCPopupMenu::SetAnimationType(CMFCPopupMenu::NO_ANIMATION);

	BOOL bRes = DropDownMenu(pButton);

	// Restore animation:
	CMFCPopupMenu::SetAnimationType(animType);

	if (bRes)
	{
		return TRUE;
	}

	return ProcessCommand(pButton);
}

const CObList& __stdcall CMFCToolBar::GetAllToolbars()
{
	return afxAllToolBars;
}

void CMFCToolBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CMFCBaseToolBar::OnSettingChange(uFlags, lpszSection);

	if (uFlags == SPI_SETNONCLIENTMETRICS || uFlags == SPI_SETWORKAREA || uFlags == SPI_SETICONTITLELOGFONT)
	{
		afxGlobalData.UpdateFonts();
		AdjustLayout();
	}
}

BOOL CMFCToolBar::IsUserDefined() const
{
	ASSERT_VALID(this);

	CFrameWnd* pTopFrame = AFXGetTopLevelFrame(this);
	if (pTopFrame == NULL)
	{
		return FALSE;
	}

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopFrame);
	if (pMainFrame != NULL)
	{
		return pMainFrame->m_Impl.IsUserDefinedToolbar(this);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pTopFrame);
		if (pFrame != NULL)
		{
			return pFrame->m_Impl.IsUserDefinedToolbar(this);
		}
		else // Maybe, OLE frame...
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pFrame);
			if (pOleFrame != NULL)
			{
				return pOleFrame->m_Impl.IsUserDefinedToolbar(this);
			}
		}
	}

	return FALSE;
}

void __stdcall CMFCToolBar::CleanUpImages()
{
	m_Images.Clear();
	m_ColdImages.Clear();
	m_MenuImages.Clear();
	m_DisabledImages.Clear();
	m_DisabledMenuImages.Clear();
	m_LargeImages.Clear();
	m_LargeColdImages.Clear();
	m_LargeDisabledImages.Clear();

	m_DefaultImages.RemoveAll();
	m_UsageCount.Reset();

	CMFCToolBarImages::CleanUp();
}

void CMFCToolBar::CleanUpLockedImages()
{
	if (!m_bLocked)
	{
		return;
	}

	m_ImagesLocked.Clear();
	m_ColdImagesLocked.Clear();
	m_DisabledImagesLocked.Clear();
	m_LargeImagesLocked.Clear();
	m_LargeColdImagesLocked.Clear();
	m_LargeDisabledImagesLocked.Clear();
	m_MenuImagesLocked.Clear();
	m_DisabledMenuImagesLocked.Clear();
}

LRESULT CMFCToolBar::OnGetButtonCount(WPARAM,LPARAM)
{
	return GetCount();
}

LRESULT CMFCToolBar::OnGetItemRect(WPARAM wParam, LPARAM lParam)
{
	GetItemRect((int) wParam, (LPRECT)lParam );
	return TRUE;
}

LRESULT CMFCToolBar::OnGetButton(WPARAM wParam, LPARAM lParam)
{
	int idx = int(wParam);
	TBBUTTON * pButton = (TBBUTTON *)lParam;
	UINT style = GetButtonStyle( idx );
	pButton->fsStyle = LOBYTE( LOWORD( style ) );
	pButton->fsState = LOBYTE( HIWORD( style ) );
	pButton->idCommand = GetItemID( idx );
	pButton->iBitmap = 0;
	pButton->dwData = 0;
	pButton->iString = 0;
	return TRUE;
}

LRESULT CMFCToolBar::OnGetButtonText(WPARAM wParam, LPARAM lParam)
{
	int idx = CommandToIndex((UINT) wParam);
	CString strBuffer = GetButtonText(idx);

	if (lParam != 0)
	{
		lstrcpy((LPTSTR) lParam, (LPCTSTR) strBuffer);
	}

	return strBuffer.GetLength();
}

BOOL CMFCToolBar::SmartUpdate(const CObList& lstPrevButtons)
{
	POSITION posPrev = NULL;

	m_bResourceWasChanged = FALSE;

	// Looking for deleted buttons:
	for (posPrev = lstPrevButtons.GetHeadPosition(); posPrev != NULL;)
	{
		CMFCToolBarButton* pButtonPrev = DYNAMIC_DOWNCAST(CMFCToolBarButton, lstPrevButtons.GetNext(posPrev));
		ASSERT_VALID(pButtonPrev);

		if (pButtonPrev)
		{
			// Find item in the curr.data:
			BOOL bFound = FALSE;

			for (POSITION posCurr = m_OrigButtons.GetHeadPosition(); posCurr != NULL;)
			{
				CMFCToolBarButton* pButtonCurr = DYNAMIC_DOWNCAST(CMFCToolBarButton, m_OrigButtons.GetNext(posCurr));
				ASSERT_VALID(pButtonCurr);

				if (pButtonCurr && pButtonCurr->CompareWith(*pButtonPrev))
				{
					bFound = TRUE;
					break;
				}
			}

			if (!bFound) // Not found, item was deleted
			{
				m_bResourceWasChanged = TRUE;

				int iIndex = CommandToIndex(pButtonPrev->m_nID);
				if (iIndex >= 0)
				{
					RemoveButton(iIndex);

					//Update ResetState
					if (IsAddRemoveQuickCustomize())
					{
						RemoveResetStateButton(pButtonPrev->m_nID);
					}
				}
			}
		}
	}

	// Looking for the new buttons:
	int i = 0;
	POSITION posCurr = NULL;

	for (posCurr = m_OrigButtons.GetHeadPosition(); posCurr != NULL; i++)
	{
		CMFCToolBarButton* pButtonCurr = DYNAMIC_DOWNCAST(CMFCToolBarButton, m_OrigButtons.GetNext(posCurr));
		ASSERT_VALID(pButtonCurr);

		if (pButtonCurr)
		{
			// Find item in the prev.data:
			BOOL bFound = FALSE;

			for (posPrev = lstPrevButtons.GetHeadPosition(); posPrev != NULL;)
			{
				CMFCToolBarButton* pButtonPrev = DYNAMIC_DOWNCAST(CMFCToolBarButton, lstPrevButtons.GetNext(posPrev));
				ASSERT_VALID(pButtonPrev);

				if (pButtonPrev && pButtonCurr->CompareWith(*pButtonPrev))
				{
					bFound = TRUE;
					break;
				}
			}

			if (!bFound) // Not found, new item!
			{
				m_bResourceWasChanged = TRUE;

				UINT uiCmd = pButtonCurr->m_nID;
				int iIndex = min((int) m_Buttons.GetCount(), i);

				if (uiCmd == 0) // Separator
				{
					InsertSeparator(iIndex);
				}
				else
				{
					int iImage = -1;
					m_DefaultImages.Lookup(uiCmd, iImage);

					InsertButton(CMFCToolBarButton(uiCmd, iImage, NULL, FALSE, m_bLocked), iIndex);

					//Update ResetState
					if (IsAddRemoveQuickCustomize())
					{
						InsertResetStateButton(CMFCToolBarButton(uiCmd, iImage, NULL, FALSE, m_bLocked), iIndex);
					}
				}
			}
		}
	}

	// Compare current and prev. data:
	if (lstPrevButtons.GetCount() != m_OrigButtons.GetCount())
	{
		m_bResourceWasChanged = TRUE;
	}
	else
	{
		for (posCurr = m_OrigButtons.GetHeadPosition(),
			posPrev = lstPrevButtons.GetHeadPosition(); posCurr != NULL;)
		{
			ENSURE(posPrev != NULL);

			CMFCToolBarButton* pButtonCurr = DYNAMIC_DOWNCAST(CMFCToolBarButton, m_OrigButtons.GetNext(posCurr));
			ASSERT_VALID(pButtonCurr);

			CMFCToolBarButton* pButtonPrev = DYNAMIC_DOWNCAST(CMFCToolBarButton, lstPrevButtons.GetNext(posPrev));
			ASSERT_VALID(pButtonPrev);

			if (pButtonCurr && pButtonPrev && !pButtonCurr->CompareWith(*pButtonPrev))
			{
				m_bResourceWasChanged = TRUE;
				break;
			}
		}
	}

	return m_bResourceWasChanged;
}

void CMFCToolBar::UpdateTooltips()
{
	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return;
	}

	while (m_nTooltipsCount-- >= 0)
	{
		m_pToolTip->DelTool(this, m_nTooltipsCount);
	}

	m_nTooltipsCount = 0;
	for (int i = 0; i < m_Buttons.GetCount(); i++)
	{
		CMFCToolBarButton* pButton = GetButton(i);
		ASSERT_VALID(pButton);

		if (pButton->m_nStyle != TBBS_SEPARATOR)
		{
			TCHAR szFullText [256];
			CString strTipText;

			AfxLoadString(pButton->m_nID, szFullText);
			AfxExtractSubString(strTipText, szFullText, 1, '\n');

			if (!pButton->OnUpdateToolTip(this, i, *m_pToolTip, strTipText))
			{
				m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, pButton->Rect(), i + 1);
			}

			m_nTooltipsCount ++;
		}
	}
}

BOOL CMFCToolBar::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	CPoint point;
	::GetCursorPos(&point);
	ScreenToClient(&point);

	TOOLINFO ti; memset(&ti, 0, sizeof(TOOLINFO));
	ti.cbSize = sizeof(AFX_OLDTOOLINFO);
	INT_PTR nHit = (INT_PTR) OnToolHitTest(point, &ti);

	if (nHit < 0 || ti.lpszText == NULL || ti.lpszText == LPSTR_TEXTCALLBACK)
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	strTipText = ti.lpszText;
	free(ti.lpszText);

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);

	m_pToolTip->SetFont(&afxGlobalData.fontRegular, FALSE);
	return TRUE;
}

void CMFCToolBar::OnAfterFloat()
{
	CMFCBaseToolBar::OnAfterFloat();

	StretchPane(m_nMRUWidth, FALSE);

	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->SizeToContent();
	}
	m_bFloating = TRUE;
}

void CMFCToolBar::OnAfterDock(CBasePane* pBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod)
{
	m_bFloating = FALSE;
	CMFCBaseToolBar::OnAfterDock(pBar, lpRect, dockMethod);

	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		CRect rect;
		GetWindowRect (rect);

		pParent->ScreenToClient (rect);
		pParent->RedrawWindow (rect);
	}
}

void CMFCToolBar::OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay)
{
	CMFCBaseToolBar::OnBeforeChangeParent(pWndNewParent, bDelay);
	m_bFloating = pWndNewParent != NULL && pWndNewParent->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd));
}

BOOL CMFCToolBar::OnSetAccData(long lVal)
{
	ASSERT_VALID(this);

	CPoint pt(LOWORD(lVal), HIWORD(lVal));
	ScreenToClient(&pt);

	int nHit = HitTest(pt);
	if (nHit < 0)
	{
		return FALSE;
	}

	m_AccData.Clear();

	CMFCToolBarButton* pButton = GetButton(nHit);
	ASSERT_VALID(pButton);

	if (pButton != NULL)
	{
		pButton->SetACCData(this, m_AccData);
	}

	return TRUE;
}

void CMFCToolBar::AccNotifyObjectFocusEvent(int iButton)
{
	if (!afxGlobalData.IsAccessibilitySupport())
	{
		return;
	}

	CMFCToolBarButton * pButton = GetButton(iButton);
	if (pButton != NULL)
	{
		ASSERT_VALID(pButton);
		pButton->SetACCData(this, m_AccData);

		::NotifyWinEvent(EVENT_OBJECT_FOCUS, GetSafeHwnd(), OBJID_CLIENT, iButton + 1);
	}
}

void CMFCToolBar::EnableDocking(DWORD dwAlignment)
{
	m_dwControlBarStyle = AFX_CBRS_FLOAT;
	CMFCBaseToolBar::EnableDocking(dwAlignment);
}

void CMFCToolBar::SaveOriginalState(CSettingsStore& reg)
{
	if (!m_OrigButtons.IsEmpty())
	{
		reg.Write(AFX_REG_ENTRY_ORIG_ITEMS, m_OrigButtons);
	}
}

BOOL CMFCToolBar::LoadLastOriginalState(CSettingsStore& reg)
{
	BOOL bIsUpdated = FALSE;

	CObList lstOrigButtons; // Original(resource) data in the last session
	if (reg.Read(AFX_REG_ENTRY_ORIG_ITEMS, lstOrigButtons))
	{
		bIsUpdated = SmartUpdate(lstOrigButtons);
	}

	while (!lstOrigButtons.IsEmpty())
	{
		delete lstOrigButtons.RemoveHead();
	}

	return bIsUpdated;
}

void __stdcall CMFCToolBar::AddCommandUsage(UINT uiCommand)
{
	m_UsageCount.AddCmd(uiCommand);
}

CMFCToolBarImages* CMFCToolBar::GetImageList(CMFCToolBarImages& images, CMFCToolBarImages& imagesLocked, CMFCToolBarImages& largeImages, CMFCToolBarImages& largeImagesLocked) const
{
	if (m_bLocked)
	{
		return(!m_bMenuMode && m_bLargeIcons && largeImagesLocked.GetCount() > 0) ? &largeImagesLocked : &imagesLocked;
	}
	else
	{
		return(!m_bMenuMode && m_bLargeIcons && largeImages.GetCount() > 0) ? &largeImages : &images;
	}
}

void CMFCToolBar::AdjustSize()
{
	CFrameWnd* pParent = AFXGetParentFrame(this);
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		BOOL bMode = (m_pParentDockBar == NULL);
		CSize sizeCurr = CalcFixedLayout(bMode, IsHorizontal());

		if (sizeCurr.cx == 32767 || sizeCurr.cy == 32767)
		{
			CRect rectParent;
			GetParent()->GetClientRect(&rectParent);

			if (sizeCurr.cx == 32767)
			{
				sizeCurr.cx = rectParent.Width();

				if (m_nMaxLen != 0)
				{
					sizeCurr.cx = min(sizeCurr.cx, m_nMaxLen);
				}
			}
			else
			{
				sizeCurr.cy = rectParent.Height();

				if (m_nMaxLen != 0)
				{
					sizeCurr.cy = min(sizeCurr.cy, m_nMaxLen);
				}
			}
		}

		CRect rect;
		GetWindowRect(rect);

		CMFCTabCtrl* pTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, GetParent());
		if (pTab != NULL)
		{
			CRect rectWndArea;
			pTab->GetWndArea(rectWndArea);
			SetWindowPos(NULL, -1, -1, rectWndArea.Width(), rectWndArea.Height(), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
		}
		else
		{
			if (IsCustomizeMode())
			{
				if (rect.Height() != sizeCurr.cy && sizeCurr.cy != 32767 && IsHorizontal() ||
					rect.Width() != sizeCurr.cx && sizeCurr.cx != 32767 && !IsHorizontal())
				{
					SetWindowPos(NULL, 0, 0, sizeCurr.cx, sizeCurr.cy, SWP_NOMOVE  | SWP_NOACTIVATE | SWP_NOZORDER);
					UpdateVirtualRect();
				}
			}
			else
			{
				if (rect.Height() != sizeCurr.cy && sizeCurr.cy != 32767 && IsHorizontal() ||
					rect.Width() != sizeCurr.cx && sizeCurr.cx != 32767 && !IsHorizontal())
				{
					CSize sizeMin;
					GetMinSize(sizeMin);

					int nNewWidth = max(sizeMin.cx, sizeCurr.cx);
					int nNewHeight = max(sizeMin.cy, sizeCurr.cy);

					SetWindowPos(NULL, 0, 0, nNewWidth, nNewHeight, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
					UpdateVirtualRect();
				}
			}
		}

		if (!IsFloating() && IsVisible() && m_pParentDockBar != NULL && m_pDockBarRow != NULL)
		{
			CRect rectWnd;
			BOOL bIsHorz = IsHorizontal();
			BOOL bResize = FALSE;

			m_pDockBarRow->GetClientRect(rectWnd);

			if (rectWnd.Height() != sizeCurr.cy && bIsHorz)
			{
				rectWnd.bottom = rectWnd.top + sizeCurr.cy;
				bResize = TRUE;
			}
			else if (rectWnd.Width() != sizeCurr.cx && !bIsHorz)
			{
				rectWnd.right = rectWnd.left + sizeCurr.cx;
				bResize = TRUE;
			}

			if (bResize)
			{
				m_pParentDockBar->ResizeRow(m_pDockBarRow, bIsHorz ? sizeCurr.cy : sizeCurr.cx);
			}

			if (IsCustomizeMode())
			{
				UpdateVirtualRect(sizeCurr);
				m_pDockBarRow->ArrangePanes(this);
			}

			pParent->RecalcLayout();
		}
		else
		{
			CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
			if (pParentMiniFrame != NULL && GetParent() == pParentMiniFrame)
			{
				pParentMiniFrame->SizeToContent();
				pParentMiniFrame->RedrawWindow();
			}
			else if (!IsKindOf(RUNTIME_CLASS(CMFCDropDownToolBar)))
			{
				pParent->RecalcLayout();
			}
		}
	}
}

void CMFCToolBar::OnCalcSeparatorRect(CMFCToolBarButton* pButton, CRect& rectSeparator, BOOL bHorz)
{
	CRect rectClient;
	GetClientRect(rectClient);

	rectSeparator = pButton->Rect();

	if (pButton->m_bWrap && bHorz)
	{
		rectSeparator.left = rectClient.left;
		rectSeparator.right = rectClient.right;

		rectSeparator.top = pButton->Rect().bottom;
		rectSeparator.bottom = rectSeparator.top + AFX_TOOLBAR_LINE_OFFSET;
	}
}

void CMFCToolBar::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CMFCBaseToolBar::OnShowWindow(bShow, nStatus);

	if (!IsCustomizeMode() || g_pWndCustomize == NULL || m_bLocked)
	{
		return;
	}

	ASSERT_VALID(g_pWndCustomize);

	if (!bShow)
	{
		g_pWndCustomize->ShowToolBar(this, FALSE);

		if (m_pSelToolbar == this)
		{
			m_pSelToolbar = NULL;
			m_iSelected = -1;
		}
	}
	else
	{
		g_pWndCustomize->ShowToolBar(this, TRUE);
	}
}

LRESULT CMFCToolBar::OnPromptReset(WPARAM, LPARAM)
{
	//Get Toolbar caption
	CString strCaption;
	GetWindowText(strCaption);
	strCaption.TrimLeft(); strCaption.TrimRight();

	if (strCaption.IsEmpty ())
	{
		ENSURE(strCaption.LoadString(IDS_AFXBARRES_UNTITLED_TOOLBAR));
	}

	CString strPrompt;
	strPrompt.Format(IDS_AFXBARRES_RESET_TOOLBAR_FMT, strCaption);

	//Ask for reset
	if (AfxMessageBox(strPrompt, MB_OKCANCEL|MB_ICONWARNING) == IDOK)
	{
		RestoreOriginalstate();
	}

	return 0;
}

void CMFCToolBar::SaveResetOriginalState(CSettingsStore& reg)
{
	if (!m_OrigResetButtons.IsEmpty())
	{
		reg.Write(AFX_REG_ENTRY_RESET_ITEMS, m_OrigResetButtons);
	}
}

BOOL CMFCToolBar::LoadResetOriginalState(CSettingsStore& reg)
{
	CObList lstOrigButtons;
	if (reg.Read(AFX_REG_ENTRY_RESET_ITEMS, lstOrigButtons))
	{
		if (lstOrigButtons.GetCount() > 0)
		{
			while (!m_OrigResetButtons.IsEmpty())
			{
				delete m_OrigResetButtons.RemoveHead();
			}

			int i = 0;
			for (POSITION pos = lstOrigButtons.GetHeadPosition(); pos != NULL; i++)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) lstOrigButtons.GetNext(pos);

				if (pButton != NULL && pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarButton)))
					m_OrigResetButtons.AddTail(pButton);
			}
		}
	}

	return TRUE;
}

void CMFCToolBar::SetSiblingToolBar(CMFCToolBar* pBrotherToolbar)
{
	m_bHasBrother = TRUE;
	m_pBrotherToolBar = pBrotherToolbar;
	pBrotherToolbar->m_bHasBrother = TRUE;
	pBrotherToolbar->m_pBrotherToolBar = this;
	m_bElderBrother = TRUE;
	pBrotherToolbar->m_bElderBrother = FALSE;

}

BOOL CMFCToolBar::IsOneRowWithSibling()
{
	CDockingPanesRow* pRowThis = GetPaneRow();
	CDockingPanesRow* pRowBrother = m_pBrotherToolBar->GetPaneRow();
	if (pRowThis == pRowBrother)
	{
		return TRUE;
	}

	return FALSE;
}

void CMFCToolBar::SetOneRowWithSibling()
{
	if (!m_bHasBrother || m_pBrotherToolBar == NULL)
	{
		return;
	}

	CDockingPanesRow* pRowThis = GetPaneRow();
	CDockingPanesRow* pRowBrother = m_pBrotherToolBar->GetPaneRow();
	if (pRowThis != pRowBrother)
	{
		if (m_bElderBrother)
		{
			pRowBrother->RemovePane(m_pBrotherToolBar);
			pRowThis->AddPane(m_pBrotherToolBar, DM_STANDARD);
		}
		else
		{
			pRowThis->RemovePane(this);
			pRowBrother->AddPane(this, DM_STANDARD);
		}
	}
}

void CMFCToolBar::SetTwoRowsWithSibling()
{
	if (!m_bHasBrother || m_pBrotherToolBar == NULL)
	{
		return;
	}

	CDockingPanesRow* pRowThis = GetPaneRow();
	CDockingPanesRow* pRowBrother = m_pBrotherToolBar->GetPaneRow();
	if (pRowThis == pRowBrother)
	{

		if (m_bElderBrother)
		{
			pRowBrother->RemovePane(this);
			CDockSite* pDockBar = m_pBrotherToolBar->GetParentDockSite();
			const CObList& list = pDockBar->GetDockSiteRowsList();
			CSize szBarSize = CalcFixedLayout(FALSE, TRUE);

			POSITION pos = list.Find(pRowBrother);
			CDockingPanesRow* pNewRow = pDockBar->AddRow(pos, szBarSize.cy);
			pNewRow->AddPane(this, DM_STANDARD);

			HDWP hdwp = BeginDeferWindowPos(10);
			pNewRow->MovePane(m_pBrotherToolBar, 0, hdwp);
			EndDeferWindowPos(hdwp);
		}
		else
		{
			pRowThis->RemovePane(m_pBrotherToolBar);
			CDockSite* pDockBar = this->GetParentDockSite();
			const CObList& list = pDockBar->GetDockSiteRowsList();
			CSize szBarSize = m_pBrotherToolBar->CalcFixedLayout(FALSE, TRUE);

			POSITION pos = list.Find(pRowThis);
			CDockingPanesRow* pNewRow = pDockBar->AddRow(pos, szBarSize.cy);
			pNewRow->AddPane(m_pBrotherToolBar, DM_STANDARD);

			HDWP hdwp = BeginDeferWindowPos(10);
			pNewRow->MovePane(this, 0, hdwp);
			EndDeferWindowPos(hdwp);
		}
	}
}

BOOL CMFCToolBar::CanHandleSiblings()
{
	if (!m_bHasBrother || m_pBrotherToolBar == NULL)
	{
		return FALSE;
	}

	CDockSite* pDockBarCurrent = GetParentDockSite();
	CDockSite* pDockBarBrother = m_pBrotherToolBar->GetParentDockSite();

	if (pDockBarBrother != NULL && pDockBarCurrent == pDockBarBrother)
	{
		return TRUE;
	}

	return FALSE;
}

void CMFCToolBar::OnGlobalFontsChanged()
{
	ASSERT_VALID(this);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		pButton->OnGlobalFontsChanged();
	}
}

void __stdcall CMFCToolBar::AutoGrayInactiveImages(BOOL bEnable/* = TRUE*/, int nGrayImagePercentage /* = 0 */, BOOL bRedrawAllToolbars/* = TRUE*/)
{
	m_bAutoGrayInactiveImages = bEnable;
	m_nGrayImagePercentage = nGrayImagePercentage;

	if (m_bAutoGrayInactiveImages)
	{
		m_Images.CopyTo(m_ColdImages);
		m_ColdImages.GrayImages(m_nGrayImagePercentage);
	}
	else
	{
		m_ColdImages.Clear();
	}

	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			if (pToolBar->IsLocked())
			{
				ASSERT_VALID(pToolBar);

				if (m_bAutoGrayInactiveImages)
				{
					pToolBar->m_ImagesLocked.CopyTo(pToolBar->m_ColdImagesLocked);
					pToolBar->m_ColdImagesLocked.GrayImages(m_nGrayImagePercentage);
				}
				else
				{
					pToolBar->m_ColdImagesLocked.Clear();
				}
			}

			if (bRedrawAllToolbars)
			{
				pToolBar->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
			}
		}
	}
}

BOOL CMFCToolBar::RemoveResetStateButton(UINT uiCmdId)
{
	int i = 0;
	int nIndex = -1;
	for (POSITION pos = m_OrigResetButtons.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_OrigResetButtons.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (i >= 0 && pButton->m_nID == uiCmdId)
		{
			nIndex = i;
			break;
		}
	}

	if (nIndex < 0 || nIndex >= m_OrigResetButtons.GetCount())
	{
		return FALSE;
	}

	POSITION posButton = m_OrigResetButtons.FindIndex(nIndex);
	if (posButton == NULL)
	{
		return FALSE;
	}

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_OrigResetButtons.GetAt(posButton);
	ASSERT_VALID(pButton);

	m_OrigResetButtons.RemoveAt(posButton);

	return TRUE;
}

int CMFCToolBar::InsertResetStateButton(const CMFCToolBarButton& button, int iInsertAt)
{
	if (iInsertAt != -1 &&
		(iInsertAt < 0 || iInsertAt > m_OrigResetButtons.GetCount()))
	{
		return -1;
	}

	CRuntimeClass* pClass = button.GetRuntimeClass();
	ENSURE(pClass != NULL);

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	pButton->CopyFrom(button);

	if (iInsertAt == -1 || iInsertAt == m_OrigResetButtons.GetCount())
	{
		// Add to the tail:
		m_OrigResetButtons.AddTail(pButton);
		return(int) m_OrigResetButtons.GetCount() - 1;
	}

	POSITION pos = m_OrigResetButtons.FindIndex(iInsertAt);
	ENSURE(pos != NULL);

	m_OrigResetButtons.InsertBefore(pos, pButton);

	return(int) iInsertAt;
}

void CMFCToolBar::SetOrigButtons(const CObList& lstOrigButtons)
{
	while (!m_OrigButtons.IsEmpty())
	{
		delete m_OrigButtons.RemoveHead();
	}

	m_OrigButtons.AddTail((CObList*) &lstOrigButtons);
}

void CMFCToolBar::OnRButtonDown(UINT nFlags, CPoint point)
{
	CMFCBaseToolBar::OnRButtonDown(nFlags, point);

	if (!IsCustomizeMode() && DYNAMIC_DOWNCAST(CPane, GetParent()) != NULL)
	{
		GetParent()->SetFocus();
	}
}

void CMFCToolBar::OnChangeVisualManager()
{
	m_bRoundShape = CMFCVisualManager::GetInstance()->IsToolbarRoundShape(this);

	if (m_bRoundShape)
	{
		SetRoundedRgn();
	}
	else
	{
		SetWindowRgn(NULL, FALSE);
	}

	if (!IsLocked() && !IsTabbed())
	{
		AdjustSizeImmediate();
	}

	UpdateImagesColor();
}

void CMFCToolBar::SetRoundedRgn()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	if (!m_bRoundShape || GetParentDockSite() == NULL)
	{
		SetWindowRgn(NULL, FALSE);
		return;
	}

	CRect rectWindow;
	GetWindowRect(rectWindow);

	CRgn rgn;
	rgn.CreateRoundRectRgn(0, 0, rectWindow.Width() + 1, rectWindow.Height() + 1, 4, 4);

	SetWindowRgn(rgn, FALSE);
}

void CMFCToolBar::RedrawCustomizeButton()
{
	if (GetSafeHwnd() == NULL || m_pCustomizeBtn == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pCustomizeBtn);

	CRect rect = m_pCustomizeBtn->GetInvalidateRect();
	rect.InflateRect(m_pCustomizeBtn->GetExtraSize());

	rect.right += 10;
	rect.bottom += 10;

	RedrawWindow(rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
}

LRESULT CMFCToolBar::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (nTypes & AFX_TOOLTIP_TYPE_TOOLBAR)
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_TOOLBAR);
		UpdateTooltips();
	}

	return 0;
}

void __stdcall CMFCToolBar::RedrawUnderlines()
{
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, afxAllToolBars.GetNext(posTlb));

		if (pToolBar != NULL && CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			BOOL bRedrawButtons = FALSE;
				
			for (POSITION pos = pToolBar->m_Buttons.GetHeadPosition(); pos != NULL;)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*)pToolBar->m_Buttons.GetNext(pos);
				if (pButton == NULL)
				{
					break;
				}

				ASSERT_VALID(pButton);

				if ((pButton->m_nStyle & TBBS_SEPARATOR) || !pButton->m_bText)
				{
					continue;
				}

				if (pButton->m_strText.Find(_T('&')) >= 0)
				{
					pToolBar->InvalidateRect(pButton->Rect());
					bRedrawButtons = TRUE;
				}
			}

			if (bRedrawButtons)
			{
				pToolBar->UpdateWindow();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmenuhash.h"
#include "afxglobals.h"
#include "afxcommandmanager.h"
#include "afxvisualmanager.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbar.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxframewndex.h"
#include "afxtoolbarmenubutton.h"
#include "afxcustomizebutton.h"
#include "afxkeyboardmanager.h"

IMPLEMENT_SERIAL(CMFCToolBarButton, CObject, VERSIONABLE_SCHEMA | 1)

CLIPFORMAT CMFCToolBarButton::m_cFormat = 0;
CString CMFCToolBarButton::m_strClipboardFormatName;
BOOL CMFCToolBarButton::m_bWrapText = TRUE;

static const int nTextMargin = 3;
static const int nSeparatorWidth = 8;
static const CString strDummyAmpSeq = _T("\001\001");

CList<UINT, UINT> CMFCToolBarButton::m_lstProtectedCommands;
BOOL CMFCToolBarButton::m_bUpdateImages = TRUE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarButton::CMFCToolBarButton()
{
	Initialize();
}

CMFCToolBarButton::CMFCToolBarButton(UINT uiID, int iImage, LPCTSTR lpszText, BOOL bUserButton, BOOL bLocked)
{
	Initialize();

	m_bLocked = bLocked;

	m_nID = uiID;
	m_bUserButton = bUserButton;
	SetImage(iImage);

	m_strText = (lpszText == NULL) ? _T("") : lpszText;

	if (m_nID != 0 && !m_bLocked)
	{
		if (m_bUserButton)
		{
			if (m_iUserImage != -1)
			{
				afxCommandManager->SetCmdImage(m_nID, m_iUserImage, TRUE);
			}
			else
			{
				m_iUserImage = afxCommandManager->GetCmdImage(m_nID, TRUE);
			}
		}
		else
		{
			if (m_iImage != -1)
			{
				afxCommandManager->SetCmdImage(m_nID, m_iImage, FALSE);
			}
			else
			{
				m_iImage = afxCommandManager->GetCmdImage(m_nID, FALSE);
			}
		}
	}
}

void CMFCToolBarButton::Initialize()
{
	m_nID = 0;
	m_nStyle = TBBS_BUTTON;
	m_iImage = -1;
	m_iUserImage = -1;
	m_bUserButton = FALSE;
	m_bDragFromCollection = FALSE;
	m_bText = FALSE;
	m_bImage = TRUE;
	m_bWrap = FALSE;
	m_bWholeText = TRUE;
	m_bLocked = FALSE;
	m_bIsHidden = FALSE;
	m_bTextBelow = FALSE;
	m_dwdItemData = 0;

	m_rect.SetRectEmpty();
	m_sizeText = CSize(0, 0);
	m_bDisableFill = FALSE;
	m_bExtraSize = FALSE;
	m_bHorz = TRUE;
	m_bVisible = TRUE;
	m_pWndParent = NULL;
}

CMFCToolBarButton::~CMFCToolBarButton()
{
}

void CMFCToolBarButton::CopyFrom(const CMFCToolBarButton& src)
{
	m_nID = src.m_nID;
	m_bLocked = src.m_bLocked;
	m_bUserButton = src.m_bUserButton;
	m_nStyle = src.m_nStyle;
	SetImage(src.m_bUserButton ? src.m_iUserImage : src.m_iImage);
	m_strText = src.m_strText;
	m_bText = src.m_bText;
	m_bImage = src.m_bImage;
	m_bWrap = src.m_bWrap;
	m_strTextCustom = src.m_strTextCustom;
	m_bVisible = src.m_bVisible;
	m_dwdItemData = src.m_dwdItemData;

	m_bDragFromCollection = FALSE;
}

void CMFCToolBarButton::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if (ar.IsLoading())
	{
		int iImage;

		ar >> m_nID;
		ar >> m_nStyle;
		ar >> iImage;
		ar >> m_strText;
		ar >> m_bUserButton;
		ar >> m_bDragFromCollection;
		ar >> m_bText;
		ar >> m_bImage;
		ar >> m_bVisible;

		SetImage(iImage);
	}
	else
	{
		ar << m_nID;
		ar << m_nStyle;
		ar << GetImage();
		ar << m_strText;
		ar << m_bUserButton;
		ar << m_bDragFromCollection;
		ar << m_bText;
		ar << m_bImage;
		ar << m_bVisible;
	}
}

CLIPFORMAT __stdcall CMFCToolBarButton::GetClipboardFormat()
{
	if (m_cFormat == 0) // Not registered yet
	{
		CString strFormat = m_strClipboardFormatName;

		if (strFormat.IsEmpty())
		{
			strFormat.Format(_T("ToolbarButton%p"), static_cast<void *>(AfxGetMainWnd()));
			// Format should be unique per application
		}

		m_cFormat = (CLIPFORMAT)::RegisterClipboardFormat(strFormat);
		ENSURE(m_cFormat != NULL);
	}

	return m_cFormat;
}

CMFCToolBarButton* __stdcall CMFCToolBarButton::CreateFromOleData(COleDataObject* pDataObject)
{
	ENSURE(pDataObject != NULL);
	ENSURE(pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat));

	CMFCToolBarButton* pButton = NULL;

	try
	{
		// Get file refering to clipboard data:
		CFile* pFile = pDataObject->GetFileData(GetClipboardFormat());
		if (pFile == NULL)
		{
			return FALSE;
		}

		// Connect the file to the archive and read the contents:
		CArchive ar(pFile, CArchive::load);

		// First, read run-time class information:
		CRuntimeClass* pClass = ar.ReadClass();
		ENSURE(pClass != NULL);

		if (pClass != NULL)
		{
			pButton = (CMFCToolBarButton*) pClass->CreateObject();
			ENSURE(pButton != NULL);

			if ((pButton != NULL) && (pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarButton))))
			{
				pButton->Serialize(ar);
			}
			else if (pButton != NULL)
			{
				delete pButton;
				pButton = NULL;
			}
		}

		ar.Close();
		delete pFile;

		return pButton;
	}
	catch(COleException* pEx)
	{
		TRACE(_T("CMFCToolBarButton::CreateFromOleData. OLE exception: %x\r\n"), pEx->m_sc);
		pEx->Delete();
	}
	catch(CArchiveException* pEx)
	{
		TRACE(_T("CMFCToolBarButton::CreateFromOleData. Archive exception\r\n"));
		pEx->Delete();
	}
	catch(CNotSupportedException *pEx)
	{
		TRACE(_T("CMFCToolBarButton::CreateFromOleData. \"Not Supported\" exception\r\n"));
		pEx->Delete();
	}

	if (pButton != NULL)
	{
		delete pButton;
	}

	return NULL;
}

void CMFCToolBarButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	m_bHorz = bHorz;

	// Fill button interior:
	FillInterior(pDC, rect, bHighlight);

	BOOL bHot = bHighlight;
	CSize sizeImage = (pImages == NULL) ? CSize(0, 0) : pImages->GetImageSize(TRUE);

	CUserTool* pUserTool = NULL;
	if (afxUserToolsManager != NULL && !m_bUserButton)
	{
		pUserTool = afxUserToolsManager->FindTool(m_nID);
	}

	CRect rectInternal = rect;
	CSize sizeExtra = m_bExtraSize ? CMFCVisualManager::GetInstance()->GetButtonExtraBorder() : CSize(0, 0);
	rectInternal.DeflateRect(sizeExtra.cx / 2, sizeExtra.cy / 2);

	int x = rectInternal.left;
	int y = rectInternal.top;

	int iTextLen = 0;

	CString strWithoutAmp = m_strText;
	strWithoutAmp.Replace(_T("&&"), strDummyAmpSeq);
	strWithoutAmp.Remove(_T('&'));
	strWithoutAmp.Replace(strDummyAmpSeq, _T("&"));

	CSize sizeText = pDC->GetTextExtent(strWithoutAmp);

	if (IsDrawText() && !(m_bTextBelow && bHorz))
	{
		int nMargin = IsDrawImage() ? 0 : nTextMargin;
		iTextLen = sizeText.cx + nMargin;
	}

	int dx = 0;
	int dy = 0;

	if (m_bTextBelow && bHorz)
	{
		ASSERT(bHorz);

		dx = rectInternal.Width();
		dy = sizeImage.cy + 2 * nTextMargin;
	}
	else
	{
		dx = bHorz ? rectInternal.Width() - iTextLen : rectInternal.Width();
		dy = bHorz ? rectInternal.Height() : rectInternal.Height() - iTextLen;
	}

	// determine offset of bitmap(centered within button)
	CPoint ptImageOffset;
	ptImageOffset.x = (dx - sizeImage.cx) / 2;
	ptImageOffset.y = (dy - sizeImage.cy) / 2;

	CPoint ptTextOffset(nTextMargin, nTextMargin);

	if (IsDrawText() && !(m_bTextBelow && bHorz))
	{
		TEXTMETRIC tm;
		pDC->GetTextMetrics(&tm);

		if (bHorz)
		{
			ptImageOffset.x -= nTextMargin;
			ptTextOffset.y = (dy - tm.tmHeight - 1) / 2;
		}
		else
		{
			ptImageOffset.y -= nTextMargin;
			ptTextOffset.x = (dx - tm.tmHeight + 1) / 2;
		}
	}

	CPoint ptImageOffsetInButton(0, 0);
	BOOL bPressed = FALSE;

	BOOL bDrawImageShadow = bHighlight && !bCustomizeMode && !IsDroppedDown() && CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() &&\
		!afxGlobalData.IsHighContrastMode() && ((m_nStyle & TBBS_PRESSED) == 0) && ((m_nStyle & TBBS_CHECKED) == 0) && ((m_nStyle & TBBS_DISABLED) == 0);

	if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) && !bCustomizeMode &&
		!CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() && CMFCVisualManager::GetInstance()->IsOffsetPressedButton())
	{
		// pressed in or checked
		ptImageOffset.Offset(1, 1);
		bPressed = TRUE;

		ptTextOffset.y ++;

		if (bHorz)
		{
			ptTextOffset.x ++;
		}
		else
		{
			ptTextOffset.x --;
		}
	}

	BOOL bFadeImage = !bHighlight && CMFCVisualManager::GetInstance()->IsFadeInactiveImage();
	BOOL bImageIsReady = FALSE;

	if ((m_nStyle & TBBS_PRESSED) || !(m_nStyle & TBBS_DISABLED) || bCustomizeMode)
	{
		if (IsDrawImage() && pImages != NULL)
		{
			if (pUserTool != NULL)
			{
				pUserTool->DrawToolIcon(pDC, CRect(CPoint(x + ptImageOffset.x, y + ptImageOffset.y), sizeImage));
			}
			else
			{
				CPoint pt = ptImageOffset;

				if (bDrawImageShadow)
				{
					pt.Offset(1, 1);

					pImages->Draw(pDC, x + pt.x, y + pt.y, GetImage(), FALSE, FALSE, FALSE, TRUE);
					pt.Offset(-2, -2);
				}

				pImages->Draw(pDC, x + pt.x, y + pt.y, GetImage(), FALSE, FALSE, FALSE, FALSE, bFadeImage);
			}
		}

		bImageIsReady = TRUE;
	}

	BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

	if (!bImageIsReady)
	{
		if (IsDrawImage() && pImages != NULL)
		{
			if (pUserTool != NULL)
			{
				pUserTool->DrawToolIcon(pDC, CRect(CPoint(x + ptImageOffset.x, y + ptImageOffset.y), sizeImage));
			}
			else
			{
				if (bDrawImageShadow)
				{
					ptImageOffset.Offset(1, 1);

					pImages->Draw(pDC, x + ptImageOffset.x, y + ptImageOffset.y, GetImage(), FALSE, FALSE, FALSE, TRUE);
					ptImageOffset.Offset(-2, -2);
				}

				pImages->Draw(pDC, x + ptImageOffset.x, y + ptImageOffset.y, GetImage(), FALSE, bDisabled && bGrayDisabledButtons, FALSE, FALSE, bFadeImage);
			}
		}
	}

	if ((m_bTextBelow && bHorz) || IsDrawText())
	{
		// Draw button's text:
		CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

		if (bHighlight)
		{
			state = CMFCVisualManager::ButtonsIsHighlighted;
		}
		else if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
		{
			// Pressed in or checked:
			state = CMFCVisualManager::ButtonsIsPressed;
		}

		COLORREF clrText = CMFCVisualManager::GetInstance()->GetToolbarButtonTextColor(this, state);

		pDC->SetTextColor(clrText);
		CString strText = m_strText;
		CRect rectText = rectInternal;
		UINT uiTextFormat = 0;

		if (m_bTextBelow && bHorz)
		{
			ASSERT(bHorz);

			ptTextOffset.y += sizeImage.cy + nTextMargin;
			uiTextFormat = DT_CENTER;

			if (m_bWrapText)
			{
				uiTextFormat |= DT_WORDBREAK;
			}

			rectText.left = (rectInternal.left + rectInternal.right - m_sizeText.cx) / 2 + ptTextOffset.x;
			rectText.right = (rectInternal.left + rectInternal.right + m_sizeText.cx) / 2;
		}
		else
		{
			if (IsDrawImage())
			{
				const int nExtra = CMFCToolBar::IsLargeIcons() ? 2 * nTextMargin : 0;

				if (bHorz)
				{
					ptTextOffset.x += sizeImage.cx + nExtra;
				}
				else
				{
					ptTextOffset.y += sizeImage.cy + nExtra;
				}

				rectText.left = x + ptTextOffset.x + nTextMargin;
			}
			else
			{
				rectText.left = x + nTextMargin + 1;
			}

			uiTextFormat = DT_SINGLELINE;
		}

		if (bHorz)
		{
			rectText.top += ptTextOffset.y;

			if (m_bTextBelow && m_bExtraSize)
			{
				rectText.OffsetRect(0, CMFCVisualManager::GetInstance()->GetButtonExtraBorder().cy / 2);
			}

			if (!afxGlobalData.m_bUnderlineKeyboardShortcuts && !CMFCToolBar::IsCustomizeMode())
			{
				strText = strWithoutAmp;
			}

			pDC->DrawText(strText, &rectText, uiTextFormat);
		}
		else
		{
			rectText = rectInternal;
			rectText.top += ptTextOffset.y;

			rectText.left = rectText.CenterPoint().x - sizeText.cy / 2;
			rectText.right = rectText.left + sizeText.cy;
			rectText.top += max(0, (rectText.Height() - sizeText.cx) / 2);

			rectText.SwapLeftRight();

			uiTextFormat = DT_NOCLIP | DT_SINGLELINE;

			strText.Replace(_T("&&"), strDummyAmpSeq);
			int iAmpIndex = strText.Find(_T('&')); // Find a SINGLE '&'
			strText.Remove(_T('&'));
			strText.Replace(strDummyAmpSeq, _T("&&"));

			if (iAmpIndex >= 0 && (afxGlobalData.m_bUnderlineKeyboardShortcuts && !CMFCToolBar::IsCustomizeMode()))
			{
				// Calculate underlined character position:
				CRect rectSubText;
				rectSubText.SetRectEmpty();
				CString strSubText = strText.Left(iAmpIndex + 1);

				pDC->DrawText(strSubText, &rectSubText, uiTextFormat | DT_CALCRECT);
				int y1 = rectSubText.right;

				rectSubText.SetRectEmpty();
				strSubText = strText.Left(iAmpIndex);

				pDC->DrawText(strSubText, &rectSubText, uiTextFormat | DT_CALCRECT);
				int y2 = rectSubText.right;

				pDC->DrawText(strWithoutAmp, &rectText, uiTextFormat);

				int xAmp = rect.CenterPoint().x - sizeText.cy / 2;

				CPen* pOldPen = NULL;
				CPen pen(PS_SOLID, 1, pDC->GetTextColor());

				if (pDC->GetTextColor() != 0)
				{
					pOldPen = pDC->SelectObject(&pen);
				}

				pDC->MoveTo(xAmp, rectText.top + y1);
				pDC->LineTo(xAmp, rectText.top + y2);

				if (pOldPen != NULL)
				{
					pDC->SelectObject(pOldPen);
				}
			}
			else
			{
				pDC->DrawText(strWithoutAmp, &rectText, uiTextFormat);
			}
		}
	}

	// Draw button border:
	if (!bCustomizeMode && HaveHotBorder() && bDrawBorder)
	{
		if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
		{
			// Pressed in or checked:
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsPressed);
		}
		else if (bHot && !(m_nStyle & TBBS_DISABLED) && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsHighlighted);
		}
	}
}

SIZE CMFCToolBarButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	ASSERT_VALID(pDC);

	if (!IsVisible())
		return CSize(0,0);

	CSize size = sizeDefault;

	if (m_nStyle & TBBS_SEPARATOR)
	{
		if (bHorz)
		{
			size.cx = m_iImage > 0 ? m_iImage : nSeparatorWidth;
		}
		else
		{
			size.cy = nSeparatorWidth;
		}
	}
	else
	{
		BOOL bHasImage = TRUE;

		if (!IsDrawImage() || GetImage() < 0)
		{
			bHasImage = FALSE;

			CSize sizeExtra = m_bExtraSize ? CMFCVisualManager::GetInstance()->GetButtonExtraBorder() : CSize(0, 0);

			if (bHorz)
			{
				size.cx = sizeExtra.cx;
			}
			else
			{
				size.cy = sizeExtra.cy;
			}
		}

		m_sizeText = CSize(0, 0);

		if (!m_strText.IsEmpty())
		{
			if (m_bTextBelow && bHorz)
			{
				// Try format text that it ocuppies no more tow lines an its
				// width less than 3 images:
				CRect rectText(0, 0, sizeDefault.cx * 3, sizeDefault.cy);

				UINT uiTextFormat = DT_CENTER | DT_CALCRECT;
				if (m_bWrapText)
				{
					uiTextFormat |= DT_WORDBREAK;
				}

				pDC->DrawText( m_strText, rectText, uiTextFormat);
				m_sizeText = rectText.Size();
				m_sizeText.cx += 2 * nTextMargin;

				size.cx = max(size.cx, m_sizeText.cx) + 4 * nTextMargin;
				size.cy += m_sizeText.cy + AFX_CY_BORDER;
			}
			else if (IsDrawText())
			{
				CString strWithoutAmp = m_strText;
				strWithoutAmp.Replace(_T("&&"), strDummyAmpSeq);
				strWithoutAmp.Remove(_T('&'));
				strWithoutAmp.Replace(strDummyAmpSeq, _T("&"));

				int nTextExtra = bHasImage ? 2 * nTextMargin : 3 * nTextMargin;
				int iTextLen = pDC->GetTextExtent(strWithoutAmp).cx + nTextExtra;

				if (bHorz)
				{
					size.cx += iTextLen;
				}
				else
				{
					size.cy += iTextLen;
				}
			}
		}
	}

	return size;
}

BOOL CMFCToolBarButton::PrepareDrag(COleDataSource& srcItem)
{
	if (!CanBeStored())
	{
		return TRUE;
	}

	try
	{
		CSharedFile globFile;
		CArchive ar(&globFile,CArchive::store);

		// Save run-time class information:
		CRuntimeClass* pClass = GetRuntimeClass();
		ENSURE(pClass != NULL);

		ar.WriteClass(pClass);

		// Save button context:
		Serialize(ar);
		ar.Close();

		srcItem.CacheGlobalData(GetClipboardFormat(), globFile.Detach());
	}
	catch(COleException* pEx)
	{
		TRACE(_T("CMFCToolBarButton::PrepareDrag. OLE exception: %x\r\n"), pEx->m_sc);
		pEx->Delete();
		return FALSE;
	}
	catch(CArchiveException* pEx)
	{
		TRACE(_T("CMFCToolBarButton::PrepareDrag. Archive exception\r\n"));
		pEx->Delete();
		return FALSE;
	}

	return TRUE;
}

void CMFCToolBarButton::SetImage(int iImage)
{
	if (m_nStyle & TBBS_SEPARATOR)
	{
		m_iImage = iImage; // Actualy, separator width!
		return;
	}

	if (m_bUserButton)
	{
		m_iUserImage = iImage;
	}
	else
	{
		m_iImage = iImage;
	}

	if (!m_bLocked)
	{
		if (m_nID != 0 && iImage != -1)
		{
			if (m_bUpdateImages || m_bUserButton)
			{
				afxCommandManager->SetCmdImage(m_nID, iImage, m_bUserButton);
			}
		}
		else if (m_nID != 0)
		{
			m_iImage = afxCommandManager->GetCmdImage(m_nID, FALSE);
			m_iUserImage = afxCommandManager->GetCmdImage(m_nID, TRUE);

			if (m_iImage == -1 && !m_bUserButton)
			{
				m_bUserButton = TRUE;
			}
			else if (m_iImage == -1 && m_bUserButton)
			{
				m_bUserButton = FALSE;
			}
		}
	}

	if ((!m_bUserButton && m_iImage < 0) ||
		(m_bUserButton && m_iUserImage < 0))
	{
		m_bImage = FALSE;
		m_bText  = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButton diagnostics

#ifdef _DEBUG
void CMFCToolBarButton::AssertValid() const
{
	CObject::AssertValid();
}

void CMFCToolBarButton::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	CString strId;
	strId.Format(_T("%x"), m_nID);

	dc << "[" << strId << " " << m_strText << "]";
	dc << "\n";
}

#endif

int CMFCToolBarButton::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	BOOL bText = m_bText;
	m_bText = FALSE;

	int iWidth = 0;

	CMFCToolBarImages* pImages = CMFCToolBar::GetImages();
	if (m_bUserButton)
	{
		pImages = CMFCToolBar::GetUserImages();
	}
	else
	{
		CMFCToolBarImages* pMenuImages = CMFCToolBar::GetMenuImages();
		if (pMenuImages != NULL && pMenuImages->GetCount() == pImages->GetCount())
		{
			pImages = pMenuImages;
		}
	}

	CUserTool* pUserTool = NULL;
	if (afxUserToolsManager != NULL && !m_bUserButton)
	{
		pUserTool = afxUserToolsManager->FindTool(m_nID);
	}

	CSize sizeMenuImage = CMFCToolBar::GetMenuImageSize();

	int nMargin = 3;
	CSize sizeButton = CSize( sizeMenuImage.cx + 2 * nMargin, sizeMenuImage.cy + 2 * nMargin);

	CRect rectFill = rect;

	if (bSelected && !CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem() && GetImage() >= 0 && pImages != NULL)
	{
		rectFill.left += sizeButton.cx;

		CRect rectLeftBtn = rect;
		rectLeftBtn.right = rectFill.left;

		CMFCVisualManager::GetInstance()->OnFillButtonInterior(pDC, this, rectLeftBtn, CMFCVisualManager::ButtonsIsHighlighted);

		CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectLeftBtn, CMFCVisualManager::ButtonsIsHighlighted);
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnFillCommandsListBackground(pDC, rectFill, bSelected);

	CRect rectText = rect;
	rectText.left += sizeMenuImage.cx + 2 * AFX_IMAGE_MARGIN + 2;

	iWidth = sizeButton.cx;

	// Draw button image:
	if (GetImage() >= 0 && pImages != NULL)
	{
		if (pUserTool != NULL)
		{
			CRect rectImage = rect;
			rectImage.right = rectImage.left + sizeButton.cx;

			pUserTool->DrawToolIcon(pDC, rectImage);
		}
		else
		{
			BOOL bFadeImage = !bSelected && CMFCVisualManager::GetInstance()->IsFadeInactiveImage();
			BOOL bDrawImageShadow = bSelected && CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() && !afxGlobalData.IsHighContrastMode();

			CSize sizeImageDest(0, 0);
			if (afxGlobalData.GetRibbonImageScale() != 1. && !CMFCToolBar::m_bDontScaleImages)
			{
				sizeImageDest = sizeMenuImage;
			}

			CAfxDrawState ds;
			pImages->PrepareDrawImage(ds, sizeImageDest, bFadeImage);

			CPoint pt = rect.TopLeft();
			pt.x += nMargin;
			pt.y += nMargin;

			if (afxGlobalData.GetRibbonImageScale() != 1. && CMFCToolBar::m_bDontScaleImages)
			{
				pt.x += max (0, (sizeMenuImage.cx - pImages->GetImageSize().cx) / 2);
				pt.y += max (0, (sizeMenuImage.cy - pImages->GetImageSize().cy) / 2);
			}

			if (bDrawImageShadow)
			{
				pt.Offset(1, 1);

				pImages->Draw(pDC, pt.x, pt.y, GetImage(), FALSE, FALSE, FALSE, TRUE);
				pt.Offset(-2, -2);
			}

			pImages->Draw(pDC, pt.x, pt.y, GetImage(), FALSE, FALSE, FALSE, FALSE, bFadeImage);

			pImages->EndDrawImage(ds);
		}
	}

	// Draw button text:
	if (!m_strText.IsEmpty())
	{
		COLORREF clrTextOld = pDC->SetTextColor(clrText);

		pDC->SetBkMode(TRANSPARENT);
		pDC->DrawText(m_strText, rectText, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
		pDC->SetTextColor(clrTextOld);

		int iTextWidth = min(rectText.Width(), pDC->GetTextExtent(m_strText).cx);
		iWidth += iTextWidth;
	}

	m_bText = bText;
	return iWidth;
}

BOOL CMFCToolBarButton::OnToolHitTest(const CWnd* pWnd, TOOLINFO* pTI)
{
	CFrameWnd* pTopFrame = (pWnd == NULL) ? (CFrameWnd*) AfxGetMainWnd() : AFXGetTopLevelFrame(pWnd);

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pTopFrame);
	if (pMainFrame != NULL)
	{
		return pMainFrame->OnMenuButtonToolHitTest(this, pTI);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pTopFrame);
		if (pFrame != NULL)
		{
			return pFrame->OnMenuButtonToolHitTest(this, pTI);
		}
		else // Maybe, OLE frame...
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pFrame);
			if (pOleFrame != NULL)
			{
				return pOleFrame->OnMenuButtonToolHitTest(this, pTI);
			}
		}
	}

	CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pTopFrame);
	if (pFrame != NULL)
	{
		return pFrame->OnMenuButtonToolHitTest(this, pTI);
	}

	return FALSE;
}

BOOL CMFCToolBarButton::ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const
{
	// Text may be undefined, bring it from the tooltip :-(
	if (m_strText.IsEmpty() && m_nID != 0)
	{
		CString strMessage;
		int iOffset;

		if (strMessage.LoadString(m_nID) &&
			(iOffset = strMessage.Find(_T('\n'))) != -1)
		{
			menuButton.m_strText = strMessage.Mid(iOffset + 1);
		}
	}

	return TRUE;
}

void __stdcall CMFCToolBarButton::SetProtectedCommands(const CList<UINT, UINT>& lstCmds)
{
	m_lstProtectedCommands.RemoveAll();
	m_lstProtectedCommands.AddTail((CList<UINT,UINT>*) &lstCmds);
}

void __stdcall CMFCToolBarButton::SetClipboardFormatName(LPCTSTR lpszName)
{
	ENSURE(lpszName != NULL);
	ENSURE(m_cFormat == 0);

	m_strClipboardFormatName = lpszName;
}

void CMFCToolBarButton::FillInterior(CDC* pDC, const CRect& rect, BOOL bHighlight, BOOL bMenuImage)
{
	if (m_bDisableFill)
	{
		return;
	}

	CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

	if (!CMFCToolBar::IsCustomizeMode() || CMFCToolBar::IsAltCustomizeMode() || m_bLocked)
	{
		if (bHighlight)
		{
			state = CMFCVisualManager::ButtonsIsHighlighted;
		}
		else if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
		{
			// Pressed in or checked:
			state = CMFCVisualManager::ButtonsIsPressed;
		}
	}

	if (bMenuImage)
	{
		CMFCVisualManager::GetInstance ()->OnFillMenuImageRect(pDC, this, rect, state);
	}
	else
	{
		CMFCVisualManager::GetInstance()->OnFillButtonInterior(pDC, this, rect, state);
	}
}

void CMFCToolBarButton::ResetImageToDefault()
{
	if (m_bUserButton ||(int) m_nID <= 0)
	{
		return;
	}

	if (afxUserToolsManager != NULL && afxUserToolsManager->FindTool(m_nID) != NULL)
	{
		// User tool has its own image
		return;
	}

	BOOL bWasImage = m_bImage;

	int iImage = CMFCToolBar::GetDefaultImage(m_nID);
	if (iImage >= 0)
	{
		SetImage(iImage);
	}
	else if (bWasImage)
	{
		m_bImage = FALSE;
		m_bText = TRUE;

		if (m_strText.IsEmpty())
		{
			CString strMessage;
			int iOffset;

			if (strMessage.LoadString(m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
			{
				m_strText = strMessage.Mid(iOffset + 1);
			}
		}
	}
}

BOOL CMFCToolBarButton::CompareWith(const CMFCToolBarButton& other) const
{
	return m_nID == other.m_nID;
}

void CMFCToolBarButton::OnChangeParentWnd(CWnd* pWndParent)
{
	m_bExtraSize = FALSE;
	m_pWndParent = pWndParent;

	if (pWndParent == NULL)
	{
		return;
	}

	CMFCToolBar* pParentBar = DYNAMIC_DOWNCAST(CMFCToolBar, pWndParent);
	if (pParentBar != NULL && pParentBar->IsButtonExtraSizeAvailable())
	{
		m_bExtraSize = TRUE;
	}
}

BOOL CMFCToolBarButton::IsFirstInGroup() const
{
	ASSERT_VALID(this);

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, m_pWndParent);
	if (pToolBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pToolBar);

	CMFCCustomizeButton* pCustomizeButton = pToolBar->GetCustomizeButton();
	if (this == pCustomizeButton)
	{
		return FALSE;
	}

	BOOL bIsFirstInGroup = TRUE;

	for (int i = 0; i < pToolBar->GetCount(); i++)
	{
		CMFCToolBarButton* pButton = pToolBar->GetButton(i);
		ASSERT_VALID(pButton);

		if (pButton == this)
		{
			return bIsFirstInGroup;
		}

		if (pButton->IsVisible())
		{
			bIsFirstInGroup = pButton->m_bWrap ||(pButton->m_nStyle & TBBS_SEPARATOR) || pButton->GetHwnd() != NULL;
		}
	}

	return FALSE;
}

BOOL CMFCToolBarButton::IsLastInGroup() const
{
	ASSERT_VALID(this);

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, m_pWndParent);
	if (pToolBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pToolBar);

	CMFCCustomizeButton* pCustomizeButton = pToolBar->GetCustomizeButton();
	if (this == pCustomizeButton)
	{
		return FALSE;
	}

	BOOL bIsLastInGroup = TRUE;

	int nCount = pToolBar->GetCount();
	if (pCustomizeButton != NULL)
	{
		nCount--;
	}

	for (int i = nCount - 1; i >= 0; i--)
	{
		CMFCToolBarButton* pButton = pToolBar->GetButton(i);
		ASSERT_VALID(pButton);

		if (pButton == this)
		{
			return bIsLastInGroup || pButton->m_bWrap;
		}

		if (pButton->IsVisible())
		{
			bIsLastInGroup = (pButton->m_nStyle & TBBS_SEPARATOR) || pButton->GetHwnd() != NULL;
		}
	}

	return FALSE;
}

BOOL CMFCToolBarButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	data.Clear();
	CString strText = m_strText;
	if (strText.IsEmpty() && m_nID != 0 && m_nID != (UINT) -1)
	{
		TCHAR szFullText[256];
		CString strTipText;

		if (AfxLoadString(m_nID, szFullText) && AfxExtractSubString(strTipText, szFullText, 1, '\n'))
		{
			strText = strTipText;
		}
	}

	data.m_strAccName = strText;
	data.m_strAccName.Remove(_T('&'));
	data.m_strAccDefAction = _T("Press");

	CFrameWnd* pFrame  = pParent->GetParentFrame();
	if (pFrame != NULL && pFrame->GetSafeHwnd() != NULL)
	{
		CString strDescr;
		pFrame->GetMessageString(m_nID, strDescr);
		data.m_strDescription = strDescr;
	}

	CWnd* pWnd = GetParentWnd();
	CFrameWnd* pParentFrame = pWnd->GetParentFrame();
	CString strLabel;
	if (pParentFrame != NULL && (CKeyboardManager::FindDefaultAccelerator(m_nID, strLabel, pParentFrame, TRUE) ||
		CKeyboardManager::FindDefaultAccelerator(m_nID, strLabel, pParentFrame->GetActiveFrame(), FALSE)))
	{
		data.m_strAccKeys = strLabel;
	}

	data.m_nAccHit = 1;
	data.m_nAccRole = ROLE_SYSTEM_PUSHBUTTON;
	data.m_bAccState = STATE_SYSTEM_FOCUSABLE;
	if (m_nStyle & TBBS_CHECKED)
	{
		data.m_bAccState |= STATE_SYSTEM_CHECKED;
	}

	if (m_nStyle & TBBS_DISABLED)
	{
		data.m_bAccState |= STATE_SYSTEM_UNAVAILABLE;
	}

	if (m_nStyle & TBBS_PRESSED)
	{
		data.m_bAccState |= STATE_SYSTEM_FOCUSED;
	}
	else
	{
		data.m_bAccState |= STATE_SYSTEM_HOTTRACKED;
	}

	data.m_rectAccLocation = m_rect;
	pParent->ClientToScreen(&data.m_rectAccLocation);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarcomboboxbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtoolbar.h"
#include "afxglobals.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxtoolbarmenubutton.h"
#include "afxmenuimages.h"
#include "afxtrackmouse.h"
#include "afxvisualmanager.h"
#include "afxcontextmenumanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCToolBarComboBoxButton, CMFCToolBarButton, 1)

static const int nDefaultComboHeight = 150;
static const int nDefaultSize = 150;
static const int nHorzMargin = 1;

BOOL CMFCToolBarComboBoxButton::m_bFlat = TRUE;
BOOL CMFCToolBarComboBoxButton::m_bCenterVert = TRUE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarComboBoxButton::CMFCToolBarComboBoxButton()
{
	m_dwStyle = WS_CHILD | WS_VISIBLE | CBS_NOINTEGRALHEIGHT | CBS_DROPDOWNLIST | WS_VSCROLL;
	m_iWidth = nDefaultSize;

	Initialize();
}

CMFCToolBarComboBoxButton::CMFCToolBarComboBoxButton(UINT uiId, int iImage, DWORD dwStyle, int iWidth) :
	CMFCToolBarButton(uiId, iImage)
{
	m_dwStyle = dwStyle | WS_CHILD | WS_VISIBLE | WS_VSCROLL;
	m_iWidth = (iWidth == 0) ? nDefaultSize : iWidth;

	Initialize();
}

void CMFCToolBarComboBoxButton::Initialize()
{
	m_iSelIndex = -1;
	m_pWndCombo = NULL;
	m_pWndEdit = NULL;
	m_bHorz = TRUE;
	m_rectCombo.SetRectEmpty();
	m_rectButton.SetRectEmpty();
	m_nDropDownHeight = nDefaultComboHeight;
	m_bIsHotEdit = FALSE;
	m_uiMenuResID = 0;
	m_bIsRibbon = FALSE;
}

CMFCToolBarComboBoxButton::~CMFCToolBarComboBoxButton()
{
	if (m_pWndCombo != NULL)
	{
		m_pWndCombo->DestroyWindow();
		delete m_pWndCombo;
	}

	if (m_pWndEdit != NULL)
	{
		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
	}
}

void CMFCToolBarComboBoxButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);
	POSITION pos;

	m_lstItems.RemoveAll();

	const CMFCToolBarComboBoxButton& src = (const CMFCToolBarComboBoxButton&) s;
	for (pos = src.m_lstItems.GetHeadPosition(); pos != NULL;)
	{
		m_lstItems.AddTail(src.m_lstItems.GetNext(pos));
	}

	ClearData();

	m_lstItemData.RemoveAll();
	for (pos = src.m_lstItemData.GetHeadPosition(); pos != NULL;)
	{
		m_lstItemData.AddTail(src.m_lstItemData.GetNext(pos));
	}

	DuplicateData();
	ASSERT(m_lstItemData.GetCount() == m_lstItems.GetCount());

	m_dwStyle = src.m_dwStyle;
	m_iWidth = src.m_iWidth;
	m_iSelIndex = src.m_iSelIndex;
	m_nDropDownHeight = src.m_nDropDownHeight;
	m_uiMenuResID = src.m_uiMenuResID;

	m_bIsRibbon = src.m_bIsRibbon;
}

void CMFCToolBarComboBoxButton::Serialize(CArchive& ar)
{
	CMFCToolBarButton::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_iWidth;
		m_rect.right = m_rect.left + m_iWidth;
		ar >> m_dwStyle;
		ar >> m_iSelIndex;
		ar >> m_strEdit;
		ar >> m_nDropDownHeight;
		ar >> m_uiMenuResID;

		m_lstItems.Serialize(ar);

		ClearData();
		m_lstItemData.RemoveAll();

		for (int i = 0; i < m_lstItems.GetCount(); i ++)
		{
			long lData;
			ar >> lData;
			m_lstItemData.AddTail((DWORD_PTR) lData);
		}

		DuplicateData();
		ASSERT(m_lstItemData.GetCount() == m_lstItems.GetCount());

		SelectItem(m_iSelIndex);
	}
	else
	{
		ar << m_iWidth;
		ar << m_dwStyle;
		ar << m_iSelIndex;
		ar << m_strEdit;
		ar << m_nDropDownHeight;
		ar << m_uiMenuResID;

		if (m_pWndCombo != NULL)
		{
			m_lstItems.RemoveAll();
			ClearData();
			m_lstItemData.RemoveAll();

			for (int i = 0; i < m_pWndCombo->GetCount(); i ++)
			{
				CString str;
				m_pWndCombo->GetLBText(i, str);

				m_lstItems.AddTail(str);
				m_lstItemData.AddTail(m_pWndCombo->GetItemData(i));
			}
		}

		m_lstItems.Serialize(ar);

		for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL;)
		{
			DWORD_PTR dwData = m_lstItemData.GetNext(pos);
			ar <<(long) dwData;
		}

		ASSERT(m_lstItemData.GetCount() == m_lstItems.GetCount());
	}
}

SIZE CMFCToolBarComboBoxButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	m_bHorz = bHorz;
	m_sizeText = CSize(0, 0);

	if (!IsVisible())
	{

		if (m_bFlat)
		{
			if (m_pWndEdit->GetSafeHwnd() != NULL &&
				(m_pWndEdit->GetStyle() & WS_VISIBLE))
			{
				m_pWndEdit->ShowWindow(SW_HIDE);
			}

		}

		if (m_pWndCombo->GetSafeHwnd() != NULL &&
			(m_pWndCombo->GetStyle() & WS_VISIBLE))
		{
			m_pWndCombo->ShowWindow(SW_HIDE);
		}

		return CSize(0,0);
	}

	if (m_bFlat && m_pWndCombo->GetSafeHwnd() != NULL &&
		(m_pWndCombo->GetStyle() & WS_VISIBLE))
	{
		m_pWndCombo->ShowWindow(SW_HIDE);
	}

	if (bHorz)
	{
		if (!m_bFlat && m_pWndCombo->GetSafeHwnd() != NULL && !m_bIsHidden)
		{
			m_pWndCombo->ShowWindow(SW_SHOWNOACTIVATE);
		}

		if (m_bTextBelow && !m_strText.IsEmpty())
		{
			CRect rectText(0, 0, m_iWidth, sizeDefault.cy);
			pDC->DrawText(m_strText, rectText, DT_CENTER | DT_CALCRECT | DT_WORDBREAK);
			m_sizeText = rectText.Size();
		}

		int cy = sizeDefault.cy;

		if (m_pWndCombo != NULL && m_pWndCombo->GetSafeHwnd() != NULL)
		{
			CRect rectCombo;
			m_pWndCombo->GetWindowRect(&rectCombo);

			cy = rectCombo.Height();
		}

		if (!m_bIsHidden && m_pWndEdit->GetSafeHwnd() != NULL && (m_pWndCombo->GetStyle() & WS_VISIBLE) == 0)
		{
			m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);
		}

		return CSize(m_iWidth, cy + m_sizeText.cy);

	}
	else
	{
		if (m_pWndCombo->GetSafeHwnd() != NULL && (m_pWndCombo->GetStyle() & WS_VISIBLE))
		{
			m_pWndCombo->ShowWindow(SW_HIDE);
		}

		if (m_pWndEdit->GetSafeHwnd() != NULL && (m_pWndEdit->GetStyle() & WS_VISIBLE))
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}

		return CMFCToolBarButton::OnCalculateSize(pDC, sizeDefault, bHorz);
	}
}

void CMFCToolBarComboBoxButton::OnMove()
{
	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		AdjustRect();
	}
}

void CMFCToolBarComboBoxButton::OnSize(int iSize)
{
	m_iWidth = iSize;
	m_rect.right = m_rect.left + m_iWidth;

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		AdjustRect();
	}
}

void CMFCToolBarComboBoxButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		CWnd* pWndParentCurr = m_pWndCombo->GetParent();
		ENSURE(pWndParentCurr != NULL);

		if (pWndParent != NULL && pWndParentCurr->GetSafeHwnd() == pWndParent->GetSafeHwnd())
		{
			return;
		}

		m_pWndCombo->DestroyWindow();
		delete m_pWndCombo;
		m_pWndCombo = NULL;

		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->DestroyWindow();
			delete m_pWndEdit;
			m_pWndEdit = NULL;
		}
	}

	if (pWndParent == NULL || pWndParent->GetSafeHwnd() == NULL)
	{
		return;
	}

	BOOL bDisabled = CMFCToolBar::IsCustomizeMode() ||(m_nStyle & TBBS_DISABLED);

	CRect rect = m_rect;
	rect.InflateRect(-2, 0);
	rect.bottom = rect.top + m_nDropDownHeight;

	if ((m_pWndCombo = CreateCombo(pWndParent, rect)) == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (m_pWndCombo != NULL && m_pWndCombo->GetSafeHwnd() != NULL)
	{
		m_pWndCombo->EnableWindow(!bDisabled);
		m_pWndCombo->RedrawWindow();
	}

	if (m_bFlat &&(m_pWndCombo->GetStyle() & CBS_DROPDOWNLIST) == CBS_DROPDOWN)
	{
		DWORD dwEditStyle = WS_CHILD | WS_VISIBLE | ES_WANTRETURN | ES_AUTOHSCROLL;
		if (m_pWndCombo->GetStyle() & WS_TABSTOP)
		{
			dwEditStyle |= WS_TABSTOP;
		}

		if ((m_pWndEdit = CreateEdit(pWndParent, rect, dwEditStyle)) == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		m_pWndEdit->SetFont(&afxGlobalData.fontRegular);
		m_pWndEdit->SetOwner(m_pWndCombo->GetParent()->GetOwner());

		if (m_pWndEdit != NULL && m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->EnableWindow(!bDisabled);
			m_pWndEdit->RedrawWindow();
		}
	}

	AdjustRect();

	m_pWndCombo->SetFont(&afxGlobalData.fontRegular);

	if (m_pWndCombo->GetCount() > 0)
	{
		m_lstItems.RemoveAll();

		ClearData();
		m_lstItemData.RemoveAll();

		for (int i = 0; i < m_pWndCombo->GetCount(); i ++)
		{
			CString str;
			m_pWndCombo->GetLBText(i, str);

			m_lstItems.AddTail(str);
			m_lstItemData.AddTail(m_pWndCombo->GetItemData(i));
		}

		m_iSelIndex = m_pWndCombo->GetCurSel();
	}
	else
	{
		m_pWndCombo->ResetContent();
		ASSERT(m_lstItemData.GetCount() == m_lstItems.GetCount());

		POSITION posData = m_lstItemData.GetHeadPosition();
		for (POSITION pos = m_lstItems.GetHeadPosition(); pos != NULL;)
		{
			ENSURE(posData != NULL);

			CString strItem = m_lstItems.GetNext(pos);
			int iIndex = m_pWndCombo->AddString(strItem);

			m_pWndCombo->SetItemData(iIndex, m_lstItemData.GetNext(posData));
		}

		if (m_iSelIndex != CB_ERR)
		{
			m_pWndCombo->SetCurSel(m_iSelIndex);
		}
	}

	if (m_iSelIndex != CB_ERR && m_iSelIndex < m_pWndCombo->GetCount())
	{
		m_pWndCombo->GetLBText(m_iSelIndex, m_strEdit);
		m_pWndCombo->SetWindowText(m_strEdit);

		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->SetWindowText(m_strEdit);
		}
	}
}

INT_PTR CMFCToolBarComboBoxButton::AddItem(LPCTSTR lpszItem, DWORD_PTR dwData)
{
	ENSURE(lpszItem != NULL);

	if (m_strEdit.IsEmpty())
	{
		m_strEdit = lpszItem;
		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->SetWindowText(m_strEdit);
		}
	}

	if (FindItem(lpszItem) < 0)
	{
		m_lstItems.AddTail(lpszItem);
		m_lstItemData.AddTail(dwData);
	}

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		int iIndex = m_pWndCombo->FindStringExact(-1, lpszItem);

		if (iIndex == CB_ERR)
		{
			iIndex = m_pWndCombo->AddString(lpszItem);
		}

		m_pWndCombo->SetCurSel(iIndex);
		m_pWndCombo->SetItemData(iIndex, dwData);
		m_pWndCombo->SetEditSel(-1, 0);
	}

	return m_lstItems.GetCount() - 1;
}

LPCTSTR CMFCToolBarComboBoxButton::GetItem(int iIndex) const
{
	if (iIndex == -1) // Current selection
	{
		if (m_pWndCombo->GetSafeHwnd() == NULL)
		{
			if ((iIndex = m_iSelIndex) == -1)
			{
				return 0;
			}
		}
		else
		{
			iIndex = m_pWndCombo->GetCurSel();
		}
	}

	POSITION pos = m_lstItems.FindIndex(iIndex);
	if (pos == NULL)
	{
		return NULL;
	}

	return m_lstItems.GetAt(pos);
}

DWORD_PTR CMFCToolBarComboBoxButton::GetItemData(int iIndex) const
{
	if (iIndex == -1) // Current selection
	{
		if (m_pWndCombo->GetSafeHwnd() == NULL)
		{
			if ((iIndex = m_iSelIndex) == -1)
			{
				return 0;
			}
		}
		else
		{
			iIndex = m_pWndCombo->GetCurSel();
		}
	}

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		return m_pWndCombo->GetItemData(iIndex);
	}
	else
	{
		POSITION pos = m_lstItemData.FindIndex(iIndex);
		if (pos == NULL)
		{
			return 0;
		}

		return m_lstItemData.GetAt(pos);
	}
}

void CMFCToolBarComboBoxButton::RemoveAllItems()
{
	m_lstItems.RemoveAll();

	ClearData();
	m_lstItemData.RemoveAll();

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		m_pWndCombo->ResetContent();
	}

	m_strEdit.Empty();

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetWindowText(m_strEdit);
	}
}

INT_PTR CMFCToolBarComboBoxButton::GetCount() const
{
	return m_lstItems.GetCount();
}

void CMFCToolBarComboBoxButton::AdjustRect()
{
	if (m_pWndCombo->GetSafeHwnd() == NULL || m_rect.IsRectEmpty() || !m_bHorz)
	{
		m_rectCombo.SetRectEmpty();
		m_rectButton.SetRectEmpty();
		return;
	}

	if (m_bCenterVert &&(!m_bTextBelow || m_strText.IsEmpty()))
	{
		CMFCToolBar* pParentBar = NULL;
		CWnd* pNextBar = m_pWndCombo->GetParent();

		while (pParentBar == NULL && pNextBar != NULL)
		{
			pParentBar = DYNAMIC_DOWNCAST(CMFCToolBar, pNextBar);
			pNextBar = pNextBar->GetParent();
		}

		if (pParentBar != NULL)
		{
			const int nRowHeight = pParentBar->GetRowHeight();
			const int yOffset = max(0, (nRowHeight - m_rect.Height()) / 2);

			m_rectButton.OffsetRect(0, yOffset);
			m_rectCombo.OffsetRect(0, yOffset);
			m_rect.OffsetRect(0, yOffset);
		}
	}

	CRect rectParent;
	m_pWndCombo->SetWindowPos(NULL, m_rect.left + nHorzMargin, m_rect.top, m_rect.Width() - 2 * nHorzMargin, m_nDropDownHeight, SWP_NOZORDER | SWP_NOACTIVATE);
	m_pWndCombo->SetEditSel(-1, 0);

	{
		CRect rect;
		m_pWndCombo->GetWindowRect(&m_rectCombo);
		m_pWndCombo->ScreenToClient(&m_rectCombo);
		m_pWndCombo->MapWindowPoints(m_pWndCombo->GetParent(), &m_rectCombo);

	}

	if (m_bFlat)
	{
		m_rectButton = m_rectCombo;
		m_rectButton.left = m_rectButton.right - CMenuImages::Size().cx * 2;

		m_rectButton.DeflateRect(2, 2);

		m_rect.left = m_rectCombo.left - nHorzMargin;
		m_rect.right = m_rectCombo.right + nHorzMargin;

		if (!m_bTextBelow || m_strText.IsEmpty())
		{
			m_rect.top = m_rectCombo.top;
			m_rect.bottom = m_rectCombo.bottom;
		}

		if (m_pWndEdit != NULL)
		{
			CRect rectEdit = m_rect;

			const int iBorderOffset = 3;

			m_pWndEdit->SetWindowPos(NULL, m_rect.left + nHorzMargin + iBorderOffset, m_rect.top + iBorderOffset,
				m_rect.Width() - 2 * nHorzMargin - m_rectButton.Width() - iBorderOffset - 3, m_rectCombo.Height() - 2 * iBorderOffset, SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}
	else
	{
		m_rectButton.SetRectEmpty();
	}
}

void CMFCToolBarComboBoxButton::SetHotEdit(BOOL bHot)
{
	if (m_bIsHotEdit != bHot)
	{
		m_bIsHotEdit = bHot;

		if (m_pWndCombo->GetParent() != NULL)
		{
			m_pWndCombo->GetParent()->InvalidateRect(m_rectCombo);
			m_pWndCombo->GetParent()->UpdateWindow();
		}
	}
}

BOOL CMFCToolBarComboBoxButton::NotifyCommand(int iNotifyCode)
{
	if (m_pWndCombo->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (m_bFlat && iNotifyCode == 0)
	{
		return TRUE;
	}

	if (m_bFlat && m_pWndCombo->GetParent() != NULL)
	{
		m_pWndCombo->GetParent()->InvalidateRect(m_rectCombo);
		m_pWndCombo->GetParent()->UpdateWindow();
	}

	switch (iNotifyCode)
	{
	case CBN_SELENDOK:
		{
			m_iSelIndex = m_pWndCombo->GetCurSel();
			if (m_iSelIndex < 0)
			{
				return FALSE;
			}

			m_pWndCombo->GetLBText(m_iSelIndex, m_strEdit);
			if (m_pWndEdit != NULL)
			{
				m_pWndEdit->SetWindowText(m_strEdit);
			}

			// Try set selection in ALL comboboxes with the same ID:
			CObList listButtons;
			if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
			{
				for (POSITION posCombo = listButtons.GetHeadPosition(); posCombo != NULL;)
				{
					CMFCToolBarComboBoxButton* pCombo = DYNAMIC_DOWNCAST(CMFCToolBarComboBoxButton, listButtons.GetNext(posCombo));

					if (pCombo != NULL && pCombo != this)
					{
						pCombo->SelectItem(m_pWndCombo->GetCurSel(), FALSE /* Don't notify */);

						if (pCombo->m_pWndCombo->GetSafeHwnd() != NULL && pCombo->m_pWndCombo->GetParent() != NULL)
						{
							pCombo->m_pWndCombo->GetParent()->InvalidateRect(pCombo->m_rectCombo);
							pCombo->m_pWndCombo->GetParent()->UpdateWindow();
						}
					}
				}
			}
		}

		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->SetFocus();
		}

		return TRUE;

	case CBN_KILLFOCUS:
	case CBN_EDITUPDATE:
		return TRUE;

	case CBN_SETFOCUS:
		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->SetFocus();
		}
		return TRUE;

	case CBN_SELCHANGE: // yurig: process selchange
		if (m_pWndEdit != NULL)
		{
			CString strEdit;
			m_pWndCombo->GetLBText(m_pWndCombo->GetCurSel(), strEdit);
			m_pWndEdit->SetWindowText(strEdit);
		}

		return TRUE;

	case CBN_EDITCHANGE:
		{
			m_pWndCombo->GetWindowText(m_strEdit);

			if (m_pWndEdit != NULL && m_pWndEdit->GetSafeHwnd() != NULL)
			{
				CString str;
				m_pWndEdit->GetWindowText(str);
				CComboBox* pBox = GetComboBox();
				if (pBox != NULL && pBox->GetSafeHwnd() != NULL)
				{
					int nCurSel = pBox->GetCurSel();
					int nNextSel = pBox->FindStringExact(nCurSel + 1, str);
					if (nNextSel == -1)
					{
						nNextSel = pBox->FindString(nCurSel + 1, str);
					}

					if (nNextSel != -1)
					{
						pBox->SetCurSel(nNextSel);
					}

					pBox->SetWindowText(str);
				}
			}

			// Try set text of ALL comboboxes with the same ID:
			CObList listButtons;
			if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
			{
				for (POSITION posCombo = listButtons.GetHeadPosition(); posCombo != NULL;)
				{
					CMFCToolBarComboBoxButton* pCombo = DYNAMIC_DOWNCAST(CMFCToolBarComboBoxButton, listButtons.GetNext(posCombo));

					if (pCombo != NULL && pCombo != this)
					{
						if (pCombo->GetComboBox() != NULL)
						{
							pCombo->GetComboBox()->SetWindowText(m_strEdit);
						}

						pCombo->m_strEdit = m_strEdit;
					}
				}
			}
		}
		return TRUE;
	}

	return FALSE;
}

void CMFCToolBarComboBoxButton::OnAddToCustomizePage()
{
	CObList listButtons; // Existing buttons with the same command ID

	if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) == 0)
	{
		return;
	}

	CMFCToolBarComboBoxButton* pOther = (CMFCToolBarComboBoxButton*) listButtons.GetHead();
	ASSERT_VALID(pOther);
	ASSERT_KINDOF(CMFCToolBarComboBoxButton, pOther);

	CopyFrom(*pOther);
}

HBRUSH CMFCToolBarComboBoxButton::OnCtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	pDC->SetTextColor(afxGlobalData.clrWindowText);
	pDC->SetBkColor(afxGlobalData.clrWindow);

	return(HBRUSH) afxGlobalData.brWindow.GetSafeHandle();
}

void CMFCToolBarComboBoxButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	if (m_pWndCombo == NULL || m_pWndCombo->GetSafeHwnd() == NULL || !bHorz)
	{
		CMFCToolBarButton::OnDraw(pDC, rect, pImages, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);
		return;
	}

	BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

	pDC->SetTextColor(bDisabled ? afxGlobalData.clrGrayedText : (bHighlight) ? CMFCToolBar::GetHotTextColor() : afxGlobalData.clrBarText);

	if (m_bFlat)
	{
		if (m_bIsHotEdit)
		{
			bHighlight = TRUE;
		}

		// Draw combbox:
		CRect rectCombo = m_rectCombo;

		// Draw border:
		CMFCVisualManager::GetInstance()->OnDrawComboBorder(pDC, rectCombo, bDisabled, m_pWndCombo->GetDroppedState(), bHighlight, this);

		rectCombo.DeflateRect(2, 2);

		int nPrevTextColor = pDC->GetTextColor();

		pDC->FillSolidRect(rectCombo, bDisabled ? afxGlobalData.clrBtnFace : afxGlobalData.clrWindow);

		if (bDisabled)
		{
			pDC->Draw3dRect(&rectCombo, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
		}

		// Draw drop-down button:
		CRect rectButton = m_rectButton;
		if (afxGlobalData.m_bIsBlackHighContrast)
		{
			rectButton.DeflateRect(1, 1);
		}

		if (rectButton.left > rectCombo.left + 1)
		{
			CMFCVisualManager::GetInstance()->OnDrawComboDropButton(pDC, rectButton, bDisabled, m_pWndCombo->GetDroppedState(), bHighlight, this);
		}

		pDC->SetTextColor(nPrevTextColor);

		// Draw combo text:
		if (!m_strEdit.IsEmpty())
		{
			CRect rectText = rectCombo;
			rectText.right = m_rectButton.left;
			rectText.DeflateRect(2, 2);

			if (m_pWndEdit == NULL)
			{
				if (m_pWndCombo->GetStyle() &(CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))
				{
					DRAWITEMSTRUCT dis;
					memset(&dis, 0, sizeof(DRAWITEMSTRUCT));

					dis.hDC = pDC->GetSafeHdc();
					dis.rcItem = rectText;
					dis.CtlID = m_nID;
					dis.itemID = m_pWndCombo->GetCurSel();
					dis.hwndItem = m_pWndCombo->GetSafeHwnd();
					dis.CtlType = ODT_COMBOBOX;
					dis.itemState |= ODS_COMBOBOXEDIT;
					dis.itemData = m_pWndCombo->GetItemData(dis.itemID);

					if (bDisabled)
					{
						dis.itemState |= ODS_DISABLED;
					}

					m_pWndCombo->DrawItem(&dis);
				}
				else
				{
					COLORREF cltTextOld = pDC->SetTextColor(afxGlobalData.clrWindowText);
					pDC->DrawText(m_strEdit, rectText, DT_VCENTER | DT_SINGLELINE);
					pDC->SetTextColor(cltTextOld);
				}
			}

		}

		pDC->SetTextColor(nPrevTextColor);
	}

	if ((m_bTextBelow && bHorz) && !m_strText.IsEmpty())
	{
		CRect rectText = rect;
		rectText.top = (m_rectCombo.bottom + rect.bottom - m_sizeText.cy) / 2;

		pDC->DrawText(m_strText, &rectText, DT_CENTER | DT_WORDBREAK);
	}
}

BOOL CMFCToolBarComboBoxButton::OnClick(CWnd* pWnd, BOOL /*bDelay*/)
{
	if (m_pWndCombo == NULL || m_pWndCombo->GetSafeHwnd() == NULL || !m_bHorz)
	{
		return FALSE;
	}

	if (m_bFlat)
	{
		if (m_pWndEdit == NULL)
		{
			m_pWndCombo->SetFocus();
		}
		else
		{
			m_pWndEdit->SetFocus();
		}

		m_pWndCombo->ShowDropDown();

		if (pWnd != NULL)
		{
			pWnd->InvalidateRect(m_rectCombo);
		}
	}

	return TRUE;
}

BOOL CMFCToolBarComboBoxButton::SelectItem(int iIndex, BOOL bNotify)
{
	if (iIndex >= m_lstItems.GetCount())
	{
		return FALSE;
	}

	m_iSelIndex = max(-1, iIndex);

	if (m_pWndCombo->GetSafeHwnd() == NULL)
	{
		return TRUE;
	}

	if (m_iSelIndex >= 0)
	{
		m_pWndCombo->GetLBText(iIndex, m_strEdit);
	}
	else
	{
		m_strEdit.Empty();
	}

	if (m_pWndEdit != NULL)
	{
		CString strEdit;
		m_pWndEdit->GetWindowText(strEdit);

		if (strEdit != m_strEdit)
		{
			m_pWndEdit->SetWindowText(m_strEdit);
		}
	}

	if (m_pWndCombo->GetCurSel() == iIndex)
	{
		// Already selected
		return TRUE;
	}

	if (m_pWndCombo->SetCurSel(iIndex) != CB_ERR)
	{
		if (bNotify)
		{
			NotifyCommand(CBN_SELENDOK);
		}

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CMFCToolBarComboBoxButton::SelectItem(DWORD_PTR dwData)
{
	int iIndex = 0;
	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		if (m_lstItemData.GetNext(pos) == dwData)
		{
			return SelectItem(iIndex);
		}
	}

	return FALSE;
}

BOOL CMFCToolBarComboBoxButton::SelectItem(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	int iIndex = FindItem(lpszText);
	if (iIndex < 0)
	{
		return FALSE;
	}

	return SelectItem(iIndex);
}

BOOL CMFCToolBarComboBoxButton::DeleteItem(int iIndex)
{
	if (iIndex < 0 || iIndex >= m_lstItems.GetCount())
	{
		return FALSE;
	}

	POSITION pos = m_lstItems.FindIndex(iIndex);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstItems.RemoveAt(pos);

	pos = m_lstItemData.FindIndex(iIndex);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstItemData.RemoveAt(pos);

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		m_pWndCombo->DeleteString(iIndex);
	}

	if (iIndex == m_iSelIndex)
	{
		int iSelIndex = m_iSelIndex;
		if (iSelIndex >= m_lstItems.GetCount())
		{
			iSelIndex = (int) m_lstItems.GetCount() - 1;
		}

		SelectItem(iSelIndex, FALSE);
	}

	return TRUE;
}

BOOL CMFCToolBarComboBoxButton::DeleteItem(DWORD_PTR dwData)
{
	int iIndex = 0;
	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		if (m_lstItemData.GetNext(pos) == dwData)
		{
			return DeleteItem(iIndex);
		}
	}

	return FALSE;
}

BOOL CMFCToolBarComboBoxButton::DeleteItem(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	int iIndex = FindItem(lpszText);
	if (iIndex < 0)
	{
		return FALSE;
	}

	return DeleteItem(iIndex);
}

int CMFCToolBarComboBoxButton::FindItem(LPCTSTR lpszText) const
{
	ENSURE(lpszText != NULL);

	int iIndex = 0;
	for (POSITION pos = m_lstItems.GetHeadPosition(); pos != NULL; iIndex++)
	{
		if (m_lstItems.GetNext(pos).CompareNoCase(lpszText) == 0)
		{
			return iIndex;
		}
	}

	return CB_ERR;
}

int CMFCToolBarComboBoxButton::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	int iWidth = CMFCToolBarButton::OnDrawOnCustomizeList(pDC, rect, bSelected) + 10;

	// Simulate combobox appearance:
	CRect rectCombo = rect;
	int nComboWidth = max(20, rect.Width() - iWidth);

	rectCombo.left = rectCombo.right - nComboWidth;

	int nMargin = 1;
	rectCombo.DeflateRect(nMargin, nMargin);

	pDC->FillRect(rectCombo, &afxGlobalData.brWindow);

	pDC->Draw3dRect(rectCombo, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	CRect rectBtn = rectCombo;
	rectBtn.left = rectBtn.right - rectBtn.Height() + 2;
	rectBtn.DeflateRect(nMargin, nMargin);

	CMFCVisualManager::GetInstance()->OnDrawComboDropButton(pDC, rectBtn, FALSE, FALSE, FALSE, this);

	return rect.Width();
}

CComboBox* CMFCToolBarComboBoxButton::CreateCombo(CWnd* pWndParent, const CRect& rect)
{
	CComboBox* pWndCombo = new CComboBox;
	if (!pWndCombo->Create(m_dwStyle, rect, pWndParent, m_nID))
	{
		delete pWndCombo;
		return NULL;
	}

	return pWndCombo;
}

CMFCToolBarComboBoxEdit* CMFCToolBarComboBoxButton::CreateEdit(CWnd* pWndParent, const CRect& rect, DWORD dwEditStyle)
{
	CMFCToolBarComboBoxEdit* pWndEdit = new CMFCToolBarComboBoxEdit(*this);

	if (!pWndEdit->Create(dwEditStyle, rect, pWndParent, m_nID))
	{
		delete pWndEdit;
		return NULL;
	}

	return pWndEdit;
}

void CMFCToolBarComboBoxButton::OnShow(BOOL bShow)
{
	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		if (bShow && m_bHorz)
		{
			OnMove();
			m_pWndCombo->ShowWindow(m_bFlat ? SW_HIDE : SW_SHOWNOACTIVATE);
		}
		else
		{
			m_pWndCombo->ShowWindow(SW_HIDE);
		}
	}

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		if (bShow && m_bHorz)
		{
			m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);
		}
		else
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}
	}
}

BOOL CMFCToolBarComboBoxButton::ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const
{
	CString strMessage;
	int iOffset;

	if (strMessage.LoadString(m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
	{
		menuButton.m_strText = strMessage.Mid(iOffset + 1);
	}

	return TRUE;
}

void CMFCToolBarComboBoxButton::SetDropDownHeight(int nHeight)
{
	if (m_nDropDownHeight == nHeight)
	{
		return;
	}

	m_nDropDownHeight = nHeight;
	OnMove();
}

void CMFCToolBarComboBoxButton::SetText(LPCTSTR lpszText)
{
	ENSURE(lpszText != NULL);

	if (!SelectItem(lpszText))
	{
		m_strEdit = lpszText;

		if (m_pWndCombo != NULL && !m_bFlat)
		{
			CString strText;
			m_pWndCombo->GetWindowText(strText);

			if (strText != lpszText)
			{
				m_pWndCombo->SetWindowText(lpszText);
				NotifyCommand(CBN_EDITCHANGE);
			}
		}

		if (m_pWndEdit != NULL)
		{
			CString strText;
			m_pWndEdit->GetWindowText(strText);

			if (strText != lpszText)
			{
				m_pWndEdit->SetWindowText(lpszText);
			}
		}
	}
}

CMFCToolBarComboBoxButton* __stdcall CMFCToolBarComboBoxButton::GetByCmd(UINT uiCmd, BOOL bIsFocus)
{
	CMFCToolBarComboBoxButton* pSrcCombo = NULL;

	CObList listButtons;
	if (CMFCToolBar::GetCommandButtons(uiCmd, listButtons) > 0)
	{
		for (POSITION posCombo= listButtons.GetHeadPosition(); posCombo != NULL;)
		{
			CMFCToolBarComboBoxButton* pCombo = DYNAMIC_DOWNCAST(CMFCToolBarComboBoxButton, listButtons.GetNext(posCombo));
			ENSURE(pCombo != NULL);

			if (pCombo != NULL &&(!bIsFocus || pCombo->HasFocus()))
			{
				pSrcCombo = pCombo;
				break;
			}
		}
	}

	return pSrcCombo;
}

BOOL __stdcall CMFCToolBarComboBoxButton::SelectItemAll(UINT uiCmd, int iIndex)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		pSrcCombo->SelectItem(iIndex);
	}

	return pSrcCombo != NULL;
}

BOOL __stdcall CMFCToolBarComboBoxButton::SelectItemAll(UINT uiCmd, DWORD_PTR dwData)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		pSrcCombo->SelectItem(dwData);
	}

	return pSrcCombo != NULL;
}

BOOL __stdcall CMFCToolBarComboBoxButton::SelectItemAll(UINT uiCmd, LPCTSTR lpszText)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		pSrcCombo->SelectItem(lpszText);
	}

	return pSrcCombo != NULL;
}

int __stdcall CMFCToolBarComboBoxButton::GetCountAll(UINT uiCmd)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return(int) pSrcCombo->GetCount();
	}

	return CB_ERR;
}

int __stdcall CMFCToolBarComboBoxButton::GetCurSelAll(UINT uiCmd)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return pSrcCombo->GetCurSel();
	}

	return CB_ERR;
}

LPCTSTR __stdcall CMFCToolBarComboBoxButton::GetItemAll(UINT uiCmd, int iIndex)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return pSrcCombo->GetItem(iIndex);
	}

	return NULL;
}

DWORD_PTR __stdcall CMFCToolBarComboBoxButton::GetItemDataAll(UINT uiCmd, int iIndex)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return pSrcCombo->GetItemData(iIndex);
	}

	return(DWORD_PTR)CB_ERR;
}

void* __stdcall CMFCToolBarComboBoxButton::GetItemDataPtrAll(UINT uiCmd, int iIndex)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return pSrcCombo->GetComboBox()->GetItemDataPtr(iIndex);
	}

	return NULL;
}

LPCTSTR __stdcall CMFCToolBarComboBoxButton::GetTextAll(UINT uiCmd)
{
	CMFCToolBarComboBoxButton* pSrcCombo = GetByCmd(uiCmd);

	if (pSrcCombo)
	{
		return pSrcCombo->GetText();
	}

	return NULL;
}

void CMFCToolBarComboBoxButton::SetStyle(UINT nStyle)
{
	CMFCToolBarButton::SetStyle(nStyle);

	BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() || !IsEditable() || (m_nStyle & TBBS_DISABLED));

	if (m_pWndCombo != NULL && m_pWndCombo->GetSafeHwnd() != NULL)
	{
		m_pWndCombo->EnableWindow(!bDisabled);
		m_pWndCombo->RedrawWindow();
	}

	if (m_pWndEdit != NULL && m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->EnableWindow(!bDisabled);
		m_pWndEdit->RedrawWindow();
	}
}

BOOL CMFCToolBarComboBoxButton::HasFocus() const
{
	if (m_pWndCombo == NULL)
	{
		return FALSE;
	}

	CWnd* pWndFocus = CWnd::GetFocus();

	if (m_pWndCombo->GetDroppedState() || pWndFocus == m_pWndCombo || m_pWndCombo->IsChild(pWndFocus))
	{
		return TRUE;
	}

	if (m_pWndEdit == NULL)
	{
		return FALSE;
	}

	return pWndFocus == m_pWndEdit || m_pWndEdit->IsChild(pWndFocus);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarComboBoxEdit

CMFCToolBarComboBoxEdit::CMFCToolBarComboBoxEdit(CMFCToolBarComboBoxButton& combo) : m_combo(combo)
{
	m_bTracked = FALSE;
}

CMFCToolBarComboBoxEdit::~CMFCToolBarComboBoxEdit()
{
}

BEGIN_MESSAGE_MAP(CMFCToolBarComboBoxEdit, CEdit)
	//{{AFX_MSG_MAP(CMFCToolBarComboBoxEdit)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEMOVE()
	ON_WM_CONTEXTMENU()
	ON_WM_PAINT()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCToolBarComboBoxEdit::OnMouseLeave)
	ON_CONTROL_REFLECT(EN_CHANGE, &CMFCToolBarComboBoxEdit::OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarComboBoxEdit message handlers

BOOL CMFCToolBarComboBoxEdit::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_MOUSEWHEEL && m_combo.GetComboBox() != NULL && m_combo.GetComboBox()->GetDroppedState())
	{
		m_combo.GetComboBox()->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
		return TRUE;
	}

	if (pMsg->message == WM_KEYDOWN)
	{
		if ((GetKeyState(VK_MENU) >= 0) &&(GetKeyState(VK_CONTROL) >= 0) && m_combo.GetComboBox() != NULL)
		{
			switch (pMsg->wParam)
			{
			case VK_UP:
			case VK_DOWN:
			case VK_HOME:
			case VK_END:
			case VK_NEXT:
			case VK_PRIOR:
				if (!m_combo.GetComboBox()->GetDroppedState())
				{
					break;
				}

			case VK_RETURN:
				SetFocus();

				if (m_combo.GetComboBox()->GetDroppedState())
				{
					m_combo.GetComboBox()->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
				}
				else if (m_combo.GetComboBox()->GetOwner() != NULL)
				{
					GetWindowText(m_combo.m_strEdit);
					m_combo.GetComboBox()->GetOwner()->PostMessage(WM_COMMAND, MAKEWPARAM(m_combo.m_nID, 0), (LPARAM) m_combo.GetComboBox()->GetSafeHwnd());
				}

				return TRUE;
			}
		}

		switch (pMsg->wParam)
		{
		case VK_TAB:
			if (GetParent() != NULL)
			{
				ASSERT_VALID(GetParent());
				GetParent()->GetNextDlgTabItem(this)->SetFocus();
				return TRUE;
			}
			break;

		case VK_ESCAPE:
			if (m_combo.GetComboBox() != NULL)
			{
				m_combo.GetComboBox()->ShowDropDown(FALSE);
			}

			if (GetTopLevelFrame() != NULL)
			{
				GetTopLevelFrame()->SetFocus();
				return TRUE;
			}

			break;

		case VK_UP:
		case VK_DOWN:
			if ((GetKeyState(VK_MENU) >= 0) &&(GetKeyState(VK_CONTROL) >=0) && m_combo.GetComboBox() != NULL)
			{
				if (!m_combo.GetComboBox()->GetDroppedState())
				{
					m_combo.GetComboBox()->ShowDropDown();

					if (m_combo.GetComboBox()->GetParent() != NULL)
					{
						m_combo.GetComboBox()->GetParent()->InvalidateRect(m_combo.m_rectCombo);
					}
				}
				return TRUE;
			}
		}
	}

	return CEdit::PreTranslateMessage(pMsg);
}

void CMFCToolBarComboBoxEdit::OnSetFocus(CWnd* pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	m_combo.SetHotEdit();
	m_combo.NotifyCommand(CBN_SETFOCUS);
}

void CMFCToolBarComboBoxEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);

	if (::IsWindow(m_combo.GetHwnd()))
	{
		m_combo.SetHotEdit(FALSE);
		m_combo.NotifyCommand(CBN_KILLFOCUS);
	}
}

void CMFCToolBarComboBoxEdit::OnChange()
{
	m_combo.NotifyCommand(CBN_EDITCHANGE);
}

void CMFCToolBarComboBoxEdit::OnMouseMove(UINT nFlags, CPoint point)
{
	CEdit::OnMouseMove(nFlags, point);
	m_combo.SetHotEdit();

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}
}

afx_msg LRESULT CMFCToolBarComboBoxEdit::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (CWnd::GetFocus() != this)
	{
		m_combo.SetHotEdit(FALSE);
	}

	return 0;
}

void CMFCToolBarComboBoxEdit::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if (m_combo.m_uiMenuResID != 0)
	{

		CWnd* pWndParent = pWnd->GetParent();

		HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(m_combo.m_uiMenuResID), RT_MENU);

		if (hInst == NULL)
		{
			CEdit::OnContextMenu(pWnd, point) ;
			return;

		}

		HMENU hMenu = ::LoadMenuW(hInst, MAKEINTRESOURCEW(m_combo.m_uiMenuResID));
		if (hMenu == NULL)
		{
			CEdit::OnContextMenu(pWnd, point) ;
			return;
		}

		HMENU hPopupMenu = ::GetSubMenu(hMenu, 0);

		if (hPopupMenu == NULL)
		{
			CEdit::OnContextMenu(pWnd, point) ;
			return;
		}

		if (afxContextMenuManager != NULL)
		{
			afxContextMenuManager->ShowPopupMenu(hPopupMenu, point.x, point.y, pWndParent);

		}
		else
		{
			::TrackPopupMenu(hPopupMenu, TPM_CENTERALIGN | TPM_LEFTBUTTON, point.x, point.y, 0, pWndParent->GetSafeHwnd(), NULL);
		}
	}
	else
	{
		CEdit::OnContextMenu(pWnd, point) ;
	}
}

INT_PTR CMFCToolBarComboBoxButton::AddSortedItem(LPCTSTR lpszItem, DWORD_PTR dwData)
{
	ENSURE(lpszItem != NULL);

	if (m_strEdit.IsEmpty())
	{
		m_strEdit = lpszItem;
		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->SetWindowText(m_strEdit);
		}
	}

	int nIndex = 0;
	BOOL bInserted = FALSE;

	if (FindItem(lpszItem) < 0)
	{
		for (nIndex =0; nIndex < m_lstItems.GetCount(); nIndex++)
		{
			POSITION pos = m_lstItems.FindIndex(nIndex);
			LPCTSTR str = (LPCTSTR) m_lstItems.GetAt(pos);
			if (Compare(lpszItem, str) < 0)
			{
				m_lstItems.InsertBefore(pos, lpszItem);
				POSITION posData = m_lstItemData.FindIndex(nIndex);
				m_lstItemData.InsertBefore(posData, dwData);
				bInserted = TRUE;
				break;
			};
		}

		if (!bInserted)
		{
			m_lstItems.AddTail(lpszItem);
			m_lstItemData.AddTail(dwData);
		}
	}

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		int iIndex = m_pWndCombo->FindStringExact(-1, lpszItem);

		if (iIndex == CB_ERR)
		{
			if (!bInserted)
			{
				iIndex = m_pWndCombo->AddString(lpszItem);
			}
			else
			{
				iIndex = m_pWndCombo->InsertString(nIndex, lpszItem);
			}
		}

		m_pWndCombo->SetCurSel(iIndex);
		m_pWndCombo->SetItemData(iIndex, dwData);
		m_pWndCombo->SetEditSel(-1, 0);
	}

	if (bInserted)
	{
		return nIndex;
	}

	return m_lstItems.GetCount() - 1;

}

int CMFCToolBarComboBoxButton::Compare(LPCTSTR lpszItem1, LPCTSTR lpszItem2)
{
	return _tcscmp(lpszItem1, lpszItem2);
}

void CMFCToolBarComboBoxButton::OnGlobalFontsChanged()
{
	CMFCToolBarButton::OnGlobalFontsChanged();

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetFont(&afxGlobalData.fontRegular);
	}

	if (m_pWndCombo->GetSafeHwnd() != NULL)
	{
		m_pWndCombo->SetFont(&afxGlobalData.fontRegular);
	}
}

BOOL CMFCToolBarComboBoxButton::OnUpdateToolTip(CWnd* pWndParent, int iButtonIndex, CToolTipCtrl& wndToolTip, CString& strTipText)
{
	if (!m_bHorz)
	{
		return FALSE;
	}

	if (!CMFCToolBar::GetShowTooltips ())
	{
		return FALSE;
	}

	CString strTips;

	if (OnGetCustomToolTipText(strTips))
	{
		strTipText = strTips;
	}

	if (CMFCToolBarComboBoxButton::IsFlatMode())
	{
		CComboBox* pCombo = GetComboBox();

		if (pCombo != NULL &&(pCombo->GetStyle() & CBS_DROPDOWNLIST) == CBS_DROPDOWN)
		{
			CEdit* pEdit = GetEditCtrl();
			if (pEdit != NULL)
			{
				wndToolTip.AddTool(pEdit, strTipText, NULL, 0);
			}
		}
		else
		{
			wndToolTip.AddTool(pWndParent, strTipText, Rect(), iButtonIndex + 1);
		}
	}
	else
	{
		CComboBox* pCombo = GetComboBox();
		if (pCombo != NULL)
		{
			wndToolTip.AddTool(pCombo, strTipText, NULL, 0);
		}
	}

	return TRUE;
}

BOOL CMFCToolBarComboBoxButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	if (!CMFCToolBarButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	CComboBox* pCombo = GetComboBox();
	if (pCombo != NULL && (pCombo->GetStyle() & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
	{
		data.m_nAccRole = ROLE_SYSTEM_DROPLIST;
	}
	else
	{
		data.m_nAccRole = ROLE_SYSTEM_COMBOBOX;
	}

	data.m_bAccState = STATE_SYSTEM_FOCUSABLE;

	if (HasFocus())
	{
		data.m_bAccState |= STATE_SYSTEM_FOCUSED;
	}

	data.m_strAccDefAction = _T("Open");
	data.m_strAccValue = GetText();

	return TRUE;
}

void CMFCToolBarComboBoxEdit::OnPaint()
{
	CString str;
	GetWindowText(str);

	if (!str.IsEmpty() || m_combo.GetPrompt().IsEmpty() || GetFocus() == this)
	{
		Default();
		return;
	}

	CRect rect;
	GetClientRect(rect);

	CPaintDC dc(this);
	dc.FillRect(rect, &afxGlobalData.brWindow);

	dc.SetBkMode(TRANSPARENT);
	dc.SetTextColor(afxGlobalData.clrGrayedText);
	CFont* pOldFont = dc.SelectObject(&afxGlobalData.fontRegular);

	rect.DeflateRect(1, 1);
	dc.DrawText(m_combo.GetPrompt(), rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER);

	dc.SelectObject(pOldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbardropsource.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxtoolbardropsource.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropSource

CMFCToolBarDropSource::CMFCToolBarDropSource()
{
	m_bDeleteOnDrop = TRUE;
	m_bEscapePressed = FALSE;
	m_bDragStarted = FALSE;

	m_hcurDelete = NULL;
	m_hcurMove = NULL;
	m_hcurCopy = NULL;
}

CMFCToolBarDropSource::~CMFCToolBarDropSource()
{
	if (m_hcurDelete != NULL)
	{
		::DeleteObject(m_hcurDelete);
	}

	if (m_hcurMove != NULL)
	{
		::DeleteObject(m_hcurMove);
	}

	if (m_hcurCopy != NULL)
	{
		::DeleteObject(m_hcurCopy);
	}
}

BEGIN_MESSAGE_MAP(CMFCToolBarDropSource, COleDropSource)
	//{{AFX_MSG_MAP(CMFCToolBarDropSource)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropSource message handlers

SCODE CMFCToolBarDropSource::GiveFeedback(DROPEFFECT dropEffect)
{
	HCURSOR hcur = NULL;

	switch(dropEffect)
	{
	case DROPEFFECT_MOVE:
		hcur = m_hcurMove;
		break;

	case DROPEFFECT_COPY:
		hcur = m_hcurCopy;
		break;

	default:
		hcur = m_hcurDelete;
		break;
	}

	if (hcur == NULL)
	{
		return COleDropSource::GiveFeedback(dropEffect);
	}

	::SetCursor(hcur);
	return S_OK;
}

SCODE CMFCToolBarDropSource::QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState)
{
	if (m_bDeleteOnDrop && m_hcurDelete != NULL)
	{
		::SetCursor(m_hcurDelete);
	}

	m_bEscapePressed = bEscapePressed;
	return COleDropSource::QueryContinueDrag(bEscapePressed, dwKeyState);
}

BOOL CMFCToolBarDropSource::OnBeginDrag(CWnd* pWnd)
{
	if (m_hcurDelete == NULL)
	{
		m_hcurDelete = AfxGetApp()->LoadCursor(IDC_AFXBARRES_DELETE);
		m_hcurMove = AfxGetApp()->LoadCursor(IDC_AFXBARRES_MOVE);
		m_hcurCopy = AfxGetApp()->LoadCursor(IDC_AFXBARRES_COPY);
	}

	m_bDragStarted = TRUE;
	return COleDropSource::OnBeginDrag(pWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbardroptarget.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxtoolbarbutton.h"
#include "afxtoolbardroptarget.h"
#include "afxtoolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropTarget

CMFCToolBarDropTarget::CMFCToolBarDropTarget()
{
	m_pOwner = NULL;
}

CMFCToolBarDropTarget::~CMFCToolBarDropTarget()
{
}

BEGIN_MESSAGE_MAP(CMFCToolBarDropTarget, COleDropTarget)
END_MESSAGE_MAP()

BOOL CMFCToolBarDropTarget::Register(CMFCToolBar* pOwner)
{
	m_pOwner = pOwner;
	return COleDropTarget::Register(pOwner);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropTarget message handlers

DROPEFFECT CMFCToolBarDropTarget::OnDragEnter(CWnd* /*pWnd*/, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!m_pOwner->IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		return DROPEFFECT_NONE;
	}

	return m_pOwner -> OnDragEnter(pDataObject, dwKeyState, point);
}

void CMFCToolBarDropTarget::OnDragLeave(CWnd* /*pWnd*/)
{
	ENSURE(m_pOwner != NULL);

	m_pOwner->OnDragLeave();
}

DROPEFFECT CMFCToolBarDropTarget::OnDragOver(CWnd* /*pWnd*/, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!m_pOwner->IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		return DROPEFFECT_NONE;
	}

	return m_pOwner -> OnDragOver(pDataObject, dwKeyState, point);
}

DROPEFFECT CMFCToolBarDropTarget::OnDropEx(CWnd* /*pWnd*/, COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT /*dropList*/, CPoint point)
{
	ENSURE(m_pOwner != NULL);

	if (!m_pOwner->IsCustomizeMode() || !pDataObject->IsDataAvailable(CMFCToolBarButton::m_cFormat))
	{
		return DROPEFFECT_NONE;
	}

	return m_pOwner -> OnDrop(pDataObject, dropEffect, point) ? dropEffect : DROPEFFECT_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarbuttonslistbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxribbonres.h"
#include "afxtoolbarbuttonslistbutton.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbarimages.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxtoolbarcomboboxbutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nXOffset = 4;
static const int nYOffset = 5;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonsListButton

CMFCToolBarButtonsListButton::CMFCToolBarButtonsListButton()
{
	m_pSelButton = NULL;
	m_pImages = NULL;

	m_iScrollOffset = 0;
	m_iScrollTotal = 0;
	m_iScrollPage = 0;

	m_bEnableDragFromList = FALSE;
	m_bInited = FALSE;
}

CMFCToolBarButtonsListButton::~CMFCToolBarButtonsListButton()
{
}

BEGIN_MESSAGE_MAP(CMFCToolBarButtonsListButton, CButton)
	//{{AFX_MSG_MAP(CMFCToolBarButtonsListButton)
	ON_WM_ERASEBKGND()
	ON_WM_LBUTTONDOWN()
	ON_WM_VSCROLL()
	ON_WM_ENABLE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SIZE()
	ON_WM_CTLCOLOR()
	ON_WM_KEYDOWN()
	ON_WM_GETDLGCODE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonsListButton message handlers

BOOL CMFCToolBarButtonsListButton::OnEraseBkgnd(CDC* pDC)
{
	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	pDC->FillSolidRect(&rectClient, IsWindowEnabled() ? afxGlobalData.clrWindow : afxGlobalData.clrBtnFace);
	return TRUE;
}

void CMFCToolBarButtonsListButton::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	if (!m_bInited)
	{
		RebuildLocations();
	}

	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	CRect rectClient = lpDIS->rcItem;

	if (m_pImages != NULL)
	{
		m_pImages->SetTransparentColor(afxGlobalData.clrBtnFace);

		CAfxDrawState ds;
		if (!m_pImages->PrepareDrawImage(ds))
		{
			return;
		}

		for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
		{
			CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
			ENSURE(pButton != NULL);

			CRect rect = pButton->Rect();
			rect.OffsetRect(0, -m_iScrollOffset);

			if (rect.top >= rectClient.bottom)
			{
				break;
			}

			if (rect.bottom > rectClient.top)
			{
				int nSaveStyle = pButton->m_nStyle;
				BOOL bLocked = pButton->m_bLocked;
				BOOL bIsHighlight = FALSE;

				if (!IsWindowEnabled())
				{
					pButton->m_nStyle |= TBBS_DISABLED;
				}
				else if (pButton == m_pSelButton)
				{
					bIsHighlight = TRUE;
				}

				pButton->m_bLocked = TRUE;
				pButton->OnDraw(pDC, rect, m_pImages, TRUE, FALSE, bIsHighlight);
				pButton->m_nStyle = nSaveStyle;
				pButton->m_bLocked = bLocked;
			}
		}

		m_pImages->EndDrawImage(ds);
	}

	CMFCToolBarComboBoxButton btnDummy;
	rectClient.InflateRect(1, 1);
	CMFCVisualManager::GetInstance()->OnDrawComboBorder(pDC, rectClient, !IsWindowEnabled(), FALSE, TRUE, &btnDummy);
}

void CMFCToolBarButtonsListButton::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	SetFocus();

	CMFCToolBarButton* pButton = HitTest(point);
	if (pButton == NULL)
	{
		return;
	}

	SelectButton(pButton);

	if (m_bEnableDragFromList)
	{
		COleDataSource srcItem;

		pButton->m_bDragFromCollection = TRUE;
		pButton->PrepareDrag(srcItem);
		pButton->m_bDragFromCollection = TRUE;

		srcItem.DoDragDrop();
	}
}

void CMFCToolBarButtonsListButton::SetImages(CMFCToolBarImages* pImages)
{
	ASSERT_VALID(pImages);
	m_pImages = pImages;

	m_sizeButton.cx = m_pImages->GetImageSize().cx + 6;
	m_sizeButton.cy = m_pImages->GetImageSize().cy + 7;

	RemoveButtons();
}

void CMFCToolBarButtonsListButton::AddButton(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);
	ENSURE(m_pImages != NULL);

	m_Buttons.AddTail(pButton);
	pButton->OnChangeParentWnd(this);

	RebuildLocations();

	HWND hwnd = pButton->GetHwnd();
	if (hwnd != NULL)
	{
		::EnableWindow(hwnd, FALSE);
	}
}

void CMFCToolBarButtonsListButton::RemoveButtons()
{
	SelectButton((CMFCToolBarButton*) NULL);

	while (!m_Buttons.IsEmpty())
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.RemoveHead();
		ASSERT_VALID(pButton);

		pButton->OnChangeParentWnd(NULL);
	}

	m_iScrollOffset = 0;
	m_iScrollTotal = 0;
	m_iScrollPage = 0;

	EnableScrollBarCtrl(SB_VERT, FALSE);
	SetScrollRange(SB_VERT, 0, 0);
}

CMFCToolBarButton* CMFCToolBarButtonsListButton::HitTest(POINT point) const
{
	CRect rectClient;
	GetClientRect(&rectClient);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		CRect rect = pButton->Rect();
		rect.OffsetRect(0, -m_iScrollOffset);

		if (rect.PtInRect(point))
		{
			return pButton;
		}
	}

	return NULL;
}

void CMFCToolBarButtonsListButton::SelectButton(CMFCToolBarButton* pButton)
{
	if (m_pSelButton == pButton)
	{
		RedrawSelection();
		return;
	}

	CMFCToolBarButton* pOldSel = m_pSelButton;
	m_pSelButton = pButton;

	CRect rectClient;
	GetClientRect(&rectClient);

	CRect rectSelected;
	rectSelected.SetRectEmpty();

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pListButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pListButton != NULL);

		CRect rect = pListButton->Rect();
		rect.OffsetRect(0, -m_iScrollOffset);

		if (pListButton == m_pSelButton)
		{
			rectSelected = rect;
		}

		if (pListButton == m_pSelButton || pListButton == pOldSel)
		{
			rect.InflateRect(2, 2);

			CRect rectInter;
			if (rectInter.IntersectRect(rectClient, rect))
			{
				InvalidateRect(&rectInter);
			}
		}
	}

	if (!rectSelected.IsRectEmpty())
	{
		if (rectSelected.top >= rectClient.bottom || rectSelected.bottom <= rectClient.top)
		{
			int iNewOffset = max(0, min(rectSelected.bottom - m_iScrollOffset - rectClient.Height(), m_iScrollTotal));
			SetScrollPos(SB_VERT, iNewOffset);

			m_iScrollOffset = iNewOffset;
			Invalidate();
		}
	}

	UpdateWindow();

	// Trigger mouse up event(to button click notification):
	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
	}
}

BOOL CMFCToolBarButtonsListButton::SelectButton(int iImage)
{
	if (iImage < 0)
	{
		SelectButton((CMFCToolBarButton*) NULL);
		return TRUE;
	}

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pListButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pListButton != NULL);

		if (pListButton->GetImage() == iImage)
		{
			SelectButton(pListButton);
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCToolBarButtonsListButton::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* /*pScrollBar*/)
{
	int iScrollOffset = m_iScrollOffset;

	switch (nSBCode)
	{
	case SB_TOP:
		iScrollOffset = 0;
		break;

	case SB_BOTTOM:
		iScrollOffset = m_iScrollTotal;
		break;

	case SB_LINEUP:
		iScrollOffset -= m_sizeButton.cy + nYOffset;
		break;

	case SB_LINEDOWN:
		iScrollOffset += m_sizeButton.cy + nYOffset;
		break;

	case SB_PAGEUP:
		iScrollOffset -= m_iScrollPage *(m_sizeButton.cy + nYOffset);
		break;

	case SB_PAGEDOWN:
		iScrollOffset += m_iScrollPage *(m_sizeButton.cy + nYOffset);
		break;

	case SB_THUMBPOSITION:
		iScrollOffset = ((m_sizeButton.cy + nYOffset) / 2 + nPos) /
			(m_sizeButton.cy + nYOffset) *(m_sizeButton.cy + nYOffset);
		break;

	default:
		return;
	}

	iScrollOffset = min(m_iScrollTotal, max(iScrollOffset, 0));

	if (iScrollOffset != m_iScrollOffset)
	{
		m_iScrollOffset = iScrollOffset;
		SetScrollPos(SB_VERT, m_iScrollOffset);

		CRect rectClient; // Client area rectangle
		GetClientRect(&rectClient);

		rectClient.right -= ::GetSystemMetrics(SM_CXVSCROLL) + 2;
		rectClient.InflateRect(-1, -1);

		InvalidateRect(rectClient);
	}
}

CScrollBar* CMFCToolBarButtonsListButton::GetScrollBarCtrl(int nBar) const
{
	if (nBar == SB_HORZ || m_wndScrollBar.GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	return(CScrollBar* ) &m_wndScrollBar;
}

void CMFCToolBarButtonsListButton::OnEnable(BOOL bEnable)
{
	CButton::OnEnable(bEnable);

	RedrawWindow();
}

void CMFCToolBarButtonsListButton::OnSysColorChange()
{
	if (m_pImages == NULL)
	{
		return;
	}

	m_pImages->OnSysColorChange();
	RedrawWindow();
}

void CMFCToolBarButtonsListButton::RebuildLocations()
{
	if (GetSafeHwnd() == NULL || m_Buttons.IsEmpty())
	{
		return;
	}

	CRect rectClient;
	GetClientRect(&rectClient);

	CRect rectButtons = rectClient;

	rectButtons.right -= ::GetSystemMetrics(SM_CXVSCROLL) + 1;
	rectButtons.InflateRect(-nXOffset, -nYOffset);

	int x = rectButtons.left;
	int y = rectButtons.top - m_iScrollOffset;

	CClientDC dc(this);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		CSize sizeButton = pButton->OnCalculateSize(&dc, m_sizeButton, TRUE);

		if (x + sizeButton.cx > rectButtons.right)
		{
			if (x == rectButtons.left)
			{
				sizeButton.cx = rectButtons.right - rectButtons.left;
			}
			else
			{
				x = rectButtons.left;
				y += sizeButton.cy + nYOffset;
			}
		}

		pButton->SetRect(CRect(CPoint(x, y), CSize(sizeButton.cx, m_sizeButton.cy)));

		x += sizeButton.cx + nXOffset;
	}

	CMFCToolBarButton* pLastButton = (CMFCToolBarButton*) m_Buttons.GetTail();
	ENSURE(pLastButton != NULL);

	int iVisibleRows = rectButtons.Height() /(m_sizeButton.cy + nYOffset);
	int iTotalRows = pLastButton->Rect().bottom /(m_sizeButton.cy + nYOffset);

	int iNonVisibleRows = iTotalRows - iVisibleRows;
	if (iNonVisibleRows > 0) // Not enouth space.
	{
		if (m_wndScrollBar.GetSafeHwnd() == NULL)
		{
			CRect rectSB;
			GetClientRect(&rectSB);

			rectSB.InflateRect(-1, -1);
			rectSB.left = rectSB.right - ::GetSystemMetrics(SM_CXVSCROLL) - 1;

			m_wndScrollBar.Create(WS_CHILD | WS_VISIBLE | SBS_VERT, rectSB, this, 1);
		}

		m_iScrollTotal = iNonVisibleRows *(m_sizeButton.cy + nYOffset);
		m_iScrollPage = iVisibleRows;

		SetScrollRange(SB_VERT, 0, m_iScrollTotal);
	}

	m_bInited = TRUE;
}

void CMFCToolBarButtonsListButton::OnSize(UINT nType, int cx, int cy)
{
	CButton::OnSize(nType, cx, cy);
	RebuildLocations();
}

HBRUSH CMFCToolBarButtonsListButton::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CWnd::OnCtlColor(pDC, pWnd, nCtlColor);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		HWND hwdList = pButton->GetHwnd();
		if (hwdList == NULL) // No control
		{
			continue;
		}

		if (hwdList == pWnd->GetSafeHwnd() || ::IsChild(hwdList, pWnd->GetSafeHwnd()))
		{
			HBRUSH hbrButton = pButton->OnCtlColor(pDC, nCtlColor);
			return(hbrButton == NULL) ? hbr : hbrButton;
		}
	}

	return hbr;
}

UINT CMFCToolBarButtonsListButton::OnGetDlgCode()
{
	return DLGC_WANTARROWS;
}

void CMFCToolBarButtonsListButton::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	switch (nChar)
	{
	case VK_LEFT:
	case VK_UP:
		if (m_pSelButton != NULL)
		{
			POSITION pos = m_Buttons.Find(m_pSelButton);
			if (pos != NULL)
			{
				m_Buttons.GetPrev(pos);
				if (pos != NULL)
				{
					SelectButton((CMFCToolBarButton*) m_Buttons.GetAt(pos));
				}
			}
		}
		else if (!m_Buttons.IsEmpty())
		{
			SelectButton((CMFCToolBarButton*) m_Buttons.GetHead());
		}

		return;

	case VK_RIGHT:
	case VK_DOWN:
		if (m_pSelButton != NULL)
		{
			POSITION pos = m_Buttons.Find(m_pSelButton);
			if (pos != NULL)
			{
				m_Buttons.GetNext(pos);
				if (pos != NULL)
				{
					SelectButton((CMFCToolBarButton*) m_Buttons.GetAt(pos));
				}
			}
		}
		else if (!m_Buttons.IsEmpty())
		{
			SelectButton((CMFCToolBarButton*) m_Buttons.GetHead());
		}
		return;

	case VK_HOME:
		if (!m_Buttons.IsEmpty())
		{
			SelectButton((CMFCToolBarButton*) m_Buttons.GetHead());
		}
		return;

	case VK_END:
		if (m_Buttons.IsEmpty())
		{
			SelectButton((CMFCToolBarButton*) m_Buttons.GetTail());
		}
		return;
	}

	CButton::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCToolBarButtonsListButton::RedrawSelection()
{
	if (m_pSelButton == NULL)
	{
		return;
	}

	CRect rect = m_pSelButton->Rect();
	rect.OffsetRect(0, -m_iScrollOffset);

	rect.InflateRect(2, 2);

	InvalidateRect(rect);
	UpdateWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarbuttoncustomizedialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxtoolbarbuttoncustomizedialog.h"
#include "afximageeditordialog.h"
#include "afxtoolbarimages.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbar.h"
#include "afxusertoolsmanager.h"
#include "afxusertool.h"
#include "afxglobals.h"
#include "afxtoolbarscustomizedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern CMFCToolBarsCustomizeDialog* g_pWndCustomize;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonCustomizeDialog dialog

CMFCToolBarButtonCustomizeDialog::CMFCToolBarButtonCustomizeDialog(CMFCToolBarButton* pButton, CMFCToolBarImages* pImages, CWnd* pParent, int iStartImage, BOOL bMenuMode) :
	CDialog(CMFCToolBarButtonCustomizeDialog::IDD, pParent), m_pButton(pButton), m_pImages(pImages), m_iStartImage(iStartImage), m_bMenuMode(bMenuMode), m_pUserTool(NULL)
{
	ASSERT_VALID(m_pButton);

	if (afxUserToolsManager != NULL)
	{
		m_pUserTool = afxUserToolsManager->FindTool(m_pButton->m_nID);
		if (m_pUserTool != NULL)
		{
			ASSERT_VALID(m_pUserTool);
		}
	}

	m_bUserButton = pButton->m_bUserButton || (m_pUserTool == NULL && CMFCToolBar::GetDefaultImage(m_pButton->m_nID) < 0);

	m_iSelImage = pButton->GetImage();
	m_bImage = pButton->m_bImage;

	if (m_bMenuMode && afxCommandManager->IsMenuItemWithoutImage(pButton->m_nID))
	{
		m_bImage = FALSE;
	}

	if (m_bMenuMode || m_pButton->m_bTextBelow)
	{
		m_bText = TRUE;
	}
	else
	{
		m_bText = pButton->m_bText;
	}

	//{{AFX_DATA_INIT(CMFCToolBarButtonCustomizeDialog)
	m_strButtonText = _T("");
	m_strButtonDescr = _T("");
	//}}AFX_DATA_INIT
}

CMFCToolBarButtonCustomizeDialog::~CMFCToolBarButtonCustomizeDialog()
{
	while (!m_Buttons.IsEmpty())
	{
		delete m_Buttons.RemoveHead();
	}
}

void CMFCToolBarButtonCustomizeDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarButtonCustomizeDialog)
	DDX_Control(pDX, IDC_AFXBARRES_DEFAULT_IMAGE, m_wndDefautImageBtn);
	DDX_Control(pDX, IDC_AFXBARRES_USER_IMAGE, m_wndUserImageBtn);
	DDX_Control(pDX, IDC_AFXBARRES_DEFAULT_IMAGE_AREA, m_wndDefaultImageArea);
	DDX_Control(pDX, IDC_AFXBARRES_BUTTON_TEXT, m_wndButtonText);
	DDX_Control(pDX, IDC_AFXBARRES_ADD_IMAGE, m_wndAddImage);
	DDX_Control(pDX, IDC_AFXBARRES_IMAGE_LIST, m_wndButtonList);
	DDX_Control(pDX, IDC_AFXBARRES_EDIT_IMAGE, m_wndEditImage);
	DDX_Text(pDX, IDC_AFXBARRES_BUTTON_TEXT, m_strButtonText);
	DDX_Text(pDX, IDC_AFXBARRES_BUTTON_DESCR, m_strButtonDescr);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarButtonCustomizeDialog, CDialog)
	//{{AFX_MSG_MAP(CMFCToolBarButtonCustomizeDialog)
	ON_BN_CLICKED(IDC_AFXBARRES_ADD_IMAGE, &CMFCToolBarButtonCustomizeDialog::OnAddImage)
	ON_BN_CLICKED(IDC_AFXBARRES_EDIT_IMAGE, &CMFCToolBarButtonCustomizeDialog::OnEditImage)
	ON_BN_CLICKED(IDC_AFXBARRES_IMAGE_LIST, &CMFCToolBarButtonCustomizeDialog::OnImageList)
	ON_BN_CLICKED(IDC_AFXBARRES_IMAGE, &CMFCToolBarButtonCustomizeDialog::OnImage)
	ON_BN_CLICKED(IDC_AFXBARRES_IMAGE_TEXT, &CMFCToolBarButtonCustomizeDialog::OnImageText)
	ON_BN_CLICKED(IDC_AFXBARRES_TEXT, &CMFCToolBarButtonCustomizeDialog::OnText)
	ON_BN_CLICKED(IDC_AFXBARRES_USER_IMAGE, &CMFCToolBarButtonCustomizeDialog::OnUserImage)
	ON_BN_CLICKED(IDC_AFXBARRES_DEFAULT_IMAGE, &CMFCToolBarButtonCustomizeDialog::OnDefaultImage)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonCustomizeDialog message handlers

void CMFCToolBarButtonCustomizeDialog::OnAddImage()
{
	ENSURE(m_pImages != NULL);
	ASSERT_VALID(m_pImages);

	CSize sizeImage = m_pImages->GetImageSize();

	try
	{
		CClientDC dc(&m_wndButtonList);
		CBitmap bitmap;
		CDC memDC;

		memDC.CreateCompatibleDC(&dc);

		if (!bitmap.CreateCompatibleBitmap(&dc, sizeImage.cx, sizeImage.cy))
		{
			AfxMessageBox(IDP_AFXBARRES_CANNT_CREATE_IMAGE);
			return;
		}

		CBitmap* pOldBitmap = memDC.SelectObject(&bitmap);

		CRect rect(0, 0, sizeImage.cx, sizeImage.cy);
		memDC.FillRect(CRect(0, 0, sizeImage.cx, sizeImage.cy), &afxGlobalData.brBtnFace);

		memDC.SelectObject(pOldBitmap);

		BITMAP bmp;
		::GetObject(m_pImages->GetImageWell(), sizeof(BITMAP), (LPVOID)&bmp);

		if (g_pWndCustomize != NULL)
		{
			ASSERT_VALID(g_pWndCustomize);

			if (!g_pWndCustomize->OnEditToolbarMenuImage(this, bitmap, bmp.bmBitsPixel))
			{
				return;
			}
		}
		else
		{
			CMFCImageEditorDialog dlg(&bitmap, this, bmp.bmBitsPixel);
			if (dlg.DoModal() != IDOK)
			{
				return;
			}
		}

		int iImageIndex = m_pImages->AddImage((HBITMAP) bitmap);
		if (iImageIndex < 0)
		{
			AfxMessageBox(IDP_AFXBARRES_CANNT_CREATE_IMAGE);
			return;
		}

		RebuildImageList();
		m_wndButtonList.SelectButton(iImageIndex);
	}
	catch(...)
	{
		AfxMessageBox(IDP_AFXBARRES_INTERLAL_ERROR);
	}
}

void CMFCToolBarButtonCustomizeDialog::OnEditImage()
{
	ENSURE(m_pImages != NULL);
	ENSURE(m_iSelImage >= 0);

	CSize sizeImage = m_pImages->GetImageSize();

	try
	{
		CClientDC dc(&m_wndButtonList);
		CBitmap bitmap;
		CDC memDC;
		memDC.CreateCompatibleDC(&dc);

		if (!bitmap.CreateCompatibleBitmap(&dc, sizeImage.cx, sizeImage.cy))
		{
			return;
		}

		const COLORREF clrGrayStd = RGB(192, 192, 192);

		CBitmap* pOldBitmap = memDC.SelectObject(&bitmap);
		COLORREF clrTransparent = m_pImages->SetTransparentColor(clrGrayStd);

		memDC.FillSolidRect(CRect(0, 0, sizeImage.cx, sizeImage.cy), clrGrayStd);

		CAfxDrawState ds;
		if (!m_pImages->PrepareDrawImage(ds))
		{
			return;
		}

		m_pImages->Draw(&memDC, 0, 0, m_iSelImage);
		m_pImages->EndDrawImage(ds);

		m_pImages->SetTransparentColor(clrTransparent);

		memDC.SelectObject(pOldBitmap);

		BITMAP bmp;
		::GetObject(m_pImages->GetImageWell(), sizeof(BITMAP), (LPVOID)&bmp);

		if (g_pWndCustomize != NULL)
		{
			ASSERT_VALID(g_pWndCustomize);

			if (!g_pWndCustomize->OnEditToolbarMenuImage(this, bitmap, bmp.bmBitsPixel))
			{
				return;
			}
		}
		else
		{
			CMFCImageEditorDialog dlg(&bitmap, this, bmp.bmBitsPixel);
			if (dlg.DoModal() != IDOK)
			{
				return;
			}
		}

		m_pImages->UpdateImage(m_iSelImage, (HBITMAP) bitmap);
		m_wndButtonList.Invalidate();
	}
	catch(...)
	{
		AfxMessageBox(IDP_AFXBARRES_INTERLAL_ERROR);
	}
}

void CMFCToolBarButtonCustomizeDialog::OnImageList()
{
	CMFCToolBarButton* pSelButton = m_wndButtonList.GetSelectedButton();
	m_iSelImage = (pSelButton == NULL) ? -1 : pSelButton->GetImage();

	m_wndEditImage.EnableWindow(m_iSelImage >= 0 && m_pImages != NULL && !m_pImages->IsReadOnly());
}

void CMFCToolBarButtonCustomizeDialog::OnImage()
{
	m_bImage = TRUE;
	m_bText = FALSE;

	EnableControls();
}

void CMFCToolBarButtonCustomizeDialog::OnImageText()
{
	m_bImage = TRUE;
	m_bText = TRUE;

	EnableControls();
}

void CMFCToolBarButtonCustomizeDialog::OnText()
{
	m_bImage = FALSE;
	m_bText = TRUE;

	EnableControls();
}

void CMFCToolBarButtonCustomizeDialog::OnOK()
{
	UpdateData();

	int iImage = m_iSelImage;
	if (!m_bUserButton)
	{
		iImage = m_pUserTool != NULL ? 0 : CMFCToolBar::GetDefaultImage(m_pButton->m_nID);
	}

	if (m_bImage && iImage < 0)
	{
		CString str;
		ENSURE(str.LoadString(IDP_AFXBARRES_IMAGE_IS_REQUIRED));

		AfxMessageBox(str);

		m_wndButtonList.SetFocus();
		return;
	}

	if (m_bText && m_strButtonText.IsEmpty())
	{
		CString str;
		ENSURE(str.LoadString(IDP_AFXBARRES_TEXT_IS_REQUIRED));

		AfxMessageBox(str);

		m_wndButtonText.SetFocus();
		return;
	}

	if (!m_pButton->m_bTextBelow)
	{
		m_pButton->m_bText = m_bText;
	}

	if (m_bMenuMode)
	{
		afxCommandManager->EnableMenuItemImage(m_pButton->m_nID, m_bImage, iImage);
	}
	else
	{
		m_pButton->m_bImage = m_bImage;
	}

	m_pButton->m_bUserButton = m_bUserButton;
	m_pButton->SetImage(iImage);
	m_pButton->m_strText = m_strButtonText;

	if (!m_strAccel.IsEmpty())
	{
		m_pButton->m_strText += _T('\t');
		m_pButton->m_strText += m_strAccel;
	}

	CDialog::OnOK();
}

BOOL CMFCToolBarButtonCustomizeDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	CWnd* pWndImage = GetDlgItem(IDC_AFXBARRES_IMAGE);
	ENSURE(pWndImage != NULL);

	CWnd* pWndImageText = GetDlgItem(IDC_AFXBARRES_IMAGE_TEXT);
	ENSURE(pWndImageText != NULL);

	if (AfxGetMainWnd() != NULL &&
		(AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	if (m_pImages != NULL)
	{
		m_wndButtonList.SetImages(m_pImages);
		RebuildImageList();
		m_wndButtonList.SelectButton(m_iSelImage);
	}
	else
	{
		m_wndButtonList.EnableWindow(FALSE);
		m_wndUserImageBtn.EnableWindow(FALSE);

		if (m_iSelImage < 0)
		{
			pWndImage->EnableWindow(FALSE);
			pWndImageText->EnableWindow(FALSE);
		}
	}

	if (m_bUserButton && !m_pButton->IsLocked())
	{
		m_wndUserImageBtn.SetCheck(1);
	}
	else
	{
		m_wndDefautImageBtn.SetCheck(1);
	}

	if (m_bImage)
	{
		if (m_bText)
		{
			CheckDlgButton(IDC_AFXBARRES_IMAGE_TEXT, TRUE);
		}
		else
		{
			CheckDlgButton(IDC_AFXBARRES_IMAGE, TRUE);
		}
	}
	else
	{
		ENSURE(m_bText);
		CheckDlgButton(IDC_AFXBARRES_TEXT, TRUE);
		m_bText = TRUE;

		m_wndButtonList.EnableWindow(FALSE);
	}

	int iTabOffset = m_pButton->m_strText.Find(_T('\t'));
	if (iTabOffset >= 0)
	{
		m_strButtonText = m_pButton->m_strText.Left(iTabOffset);
		m_strAccel = m_pButton->m_strText.Mid(iTabOffset + 1);
	}
	else
	{
		m_strButtonText = m_pButton->m_strText;
	}

	CFrameWnd* pWndFrame = GetParentFrame();
	if (pWndFrame != NULL)
	{
		pWndFrame->GetMessageString(m_pButton->m_nID, m_strButtonDescr);
	}

	if (m_bMenuMode)
	{
		pWndImage->EnableWindow(FALSE);
	}

	if (m_pButton->m_bTextBelow)
	{
		pWndImage->EnableWindow(FALSE);
	}

	m_wndDefaultImageArea.GetClientRect(&m_rectDefaultImage);
	m_wndDefaultImageArea.MapWindowPoints(this, &m_rectDefaultImage);

	CSize sizePreview(16, 16);

	CMFCToolBarImages* pImages = CMFCToolBar::GetImages();
	if (pImages != NULL)
	{
		CSize sizeImage = pImages->GetImageSize();

		sizePreview.cx = min(sizePreview.cx, sizeImage.cx);
		sizePreview.cy = min(sizePreview.cy, sizeImage.cy);
	}

	m_rectDefaultImage.right = m_rectDefaultImage.left + sizePreview.cx;
	m_rectDefaultImage.bottom = m_rectDefaultImage.top + sizePreview.cy;

	EnableControls();
	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCToolBarButtonCustomizeDialog::RebuildImageList()
{
	m_wndButtonList.RemoveButtons();

	while (!m_Buttons.IsEmpty())
	{
		delete m_Buttons.RemoveHead();
	}

	int iEnd = m_pImages->GetCount() - 1;
	for (int iImage = m_iStartImage; iImage <= iEnd; iImage ++)
	{
		CMFCToolBarButton* pButton = new CMFCToolBarButton;

		pButton->SetImage(iImage);

		m_wndButtonList.AddButton(pButton);
		m_Buttons.AddTail(pButton);
	}

	m_wndButtonList.Invalidate();
}

void CMFCToolBarButtonCustomizeDialog::EnableControls()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pButton);

	BOOL bLocked = m_pButton->IsLocked();

	m_wndButtonText.EnableWindow(m_bText &&(!m_bMenuMode || m_pUserTool == NULL) && !CMFCToolBar::m_bDisableLabelsEdit);

	m_wndButtonList.EnableWindow(m_bImage && m_pImages != NULL && m_bUserButton && !bLocked);
	m_wndAddImage.EnableWindow(m_bImage && m_pImages != NULL && m_bUserButton && !m_pImages->IsReadOnly() && !bLocked);
	m_wndEditImage.EnableWindow(m_bImage && m_pImages != NULL && m_iSelImage >= 0 && m_bUserButton && !m_pImages->IsReadOnly() && !bLocked);

	m_wndUserImageBtn.EnableWindow(m_bImage && m_pImages != NULL && !bLocked);

	m_wndDefautImageBtn.EnableWindow(m_pUserTool != NULL || (m_bImage && CMFCToolBar::GetDefaultImage(m_pButton->m_nID) >= 0) && !bLocked);

	InvalidateRect(&m_rectDefaultImage);
}

void CMFCToolBarButtonCustomizeDialog::OnUserImage()
{
	m_iSelImage = -1;
	m_bUserButton = TRUE;
	m_wndDefautImageBtn.SetCheck(0);
	EnableControls();

	m_wndButtonList.SelectButton(-1);
}

void CMFCToolBarButtonCustomizeDialog::OnDefaultImage()
{
	m_iSelImage = m_pButton->GetImage();
	m_bUserButton = FALSE;
	m_wndUserImageBtn.SetCheck(0);
	EnableControls();
}

void CMFCToolBarButtonCustomizeDialog::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (m_pUserTool != NULL)
	{
		m_pUserTool->DrawToolIcon(&dc, m_rectDefaultImage);
		return;
	}

	if (m_pButton->IsLocked())
	{
		BOOL bText = m_pButton->m_bText;
		BOOL bImage = m_pButton->m_bImage;

		m_pButton->m_bText = FALSE;
		m_pButton->m_bImage = TRUE;

		m_pButton->OnDraw(&dc, m_rectDefaultImage, NULL, TRUE, FALSE, FALSE, FALSE, FALSE);

		m_pButton->m_bText = bText;
		m_pButton->m_bImage = bImage;

		return;
	}

	int iImage = CMFCToolBar::GetDefaultImage(m_pButton->m_nID);
	if (iImage < 0 || !m_bImage)
	{
		return;
	}

	CMFCToolBarImages* pImages = CMFCToolBar::GetImages();
	ENSURE(pImages != NULL);

	CAfxDrawState ds;
	pImages->PrepareDrawImage(ds, m_rectDefaultImage.Size());

	pImages->Draw(&dc, m_rectDefaultImage.left, m_rectDefaultImage.top, iImage);
	pImages->EndDrawImage(ds);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbardatetimectrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxglobals.h"
#include "afxtoolbar.h"
#include "afxtoolbarmenubutton.h"
#include "afxmenuimages.h"
#include "afxtoolbardatetimectrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCToolBarDateTimeCtrl, CMFCToolBarButton, 1)

static const int nDefaultSize = 100;
static const int nHorzMargin = 3;
static const int nVertMargin = 3;

BEGIN_MESSAGE_MAP(CMFCToolBarDateTimeCtrlImpl, CDateTimeCtrl)
	//{{AFX_MSG_MAP(CMFCToolBarDateTimeCtrlImpl)
	ON_NOTIFY_REFLECT(DTN_DATETIMECHANGE, &CMFCToolBarDateTimeCtrlImpl::OnDateTimeChange)
	ON_NOTIFY_REFLECT(DTN_DROPDOWN, &CMFCToolBarDateTimeCtrlImpl::OnDateTimeDropDown)
	ON_NOTIFY_REFLECT(DTN_CLOSEUP, &CMFCToolBarDateTimeCtrlImpl::OnDateTimeCloseUp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#pragma warning(disable : 4310)

void CMFCToolBarDateTimeCtrlImpl::OnDateTimeChange(NMHDR* pNotifyStruct, LRESULT* pResult)
{
	ENSURE(pNotifyStruct != NULL);

	// Send a WM_COMMAND message with the DTN_DATETIMECHANGE notification(truncated to lower 16 bits)
	// so that we will process it first then it will get forwarded by CMFCToolBar to the current
	// frame window, otherwise everyone has to subclass this class and reflect the WM_NOTIFY messages.
	// Yeah, a hack, but a pretty safe one.
	if (!m_bMonthCtrlDisplayed)
	{
		LPNMDATETIMECHANGE pNotify = (LPNMDATETIMECHANGE) pNotifyStruct;
		GetOwner()->PostMessage(WM_COMMAND, pNotify->nmhdr.idFrom);
	}

	*pResult = 0;
}

void CMFCToolBarDateTimeCtrlImpl::OnDateTimeDropDown(NMHDR* /* pNotifyStruct */, LRESULT* pResult)
{
	m_bMonthCtrlDisplayed = true;
	*pResult = 0;
}

void CMFCToolBarDateTimeCtrlImpl::OnDateTimeCloseUp(NMHDR* pNotifyStruct, LRESULT* pResult)
{
	ENSURE(pNotifyStruct != NULL);

	m_bMonthCtrlDisplayed = false;

	LPNMDATETIMECHANGE pNotify = (LPNMDATETIMECHANGE) pNotifyStruct;
	GetOwner()->PostMessage(WM_COMMAND, pNotify->nmhdr.idFrom);

	*pResult = 0;
}

#pragma warning(default : 4310)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarDateTimeCtrl::CMFCToolBarDateTimeCtrl()
{
	m_dwStyle = WS_CHILD | WS_VISIBLE;
	m_iWidth = nDefaultSize;

	Initialize();
}

CMFCToolBarDateTimeCtrl::CMFCToolBarDateTimeCtrl(UINT uiId, int iImage, DWORD dwStyle, int iWidth) : CMFCToolBarButton(uiId, iImage)
{
	m_dwStyle = dwStyle | WS_CHILD | WS_VISIBLE;
	m_iWidth = (iWidth == 0) ? nDefaultSize : iWidth;

	Initialize();
}

void CMFCToolBarDateTimeCtrl::Initialize()
{
	m_pWndDateTime = NULL;
	m_bHorz = TRUE;
	m_dwTimeStatus = GDT_VALID;
	m_time = CTime::GetCurrentTime();
}

CMFCToolBarDateTimeCtrl::~CMFCToolBarDateTimeCtrl()
{
	if (m_pWndDateTime != NULL)
	{
		m_pWndDateTime->DestroyWindow();
		delete m_pWndDateTime;
	}
}

void CMFCToolBarDateTimeCtrl::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);

	DuplicateData();

	const CMFCToolBarDateTimeCtrl& src = (const CMFCToolBarDateTimeCtrl&) s;
	m_dwStyle = src.m_dwStyle;
	m_iWidth = src.m_iWidth;
}

void CMFCToolBarDateTimeCtrl::Serialize(CArchive& ar)
{
	CMFCToolBarButton::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_iWidth;
		m_rect.right = m_rect.left + m_iWidth;
		ar >> m_dwStyle;
		ar >> m_dwTimeStatus;
		ar >> m_time;

		if (m_pWndDateTime->GetSafeHwnd () != NULL &&
			m_dwTimeStatus == GDT_VALID)
		{
			m_pWndDateTime->SetTime(&m_time);
		}

		DuplicateData();
	}
	else
	{
		if (m_pWndDateTime->GetSafeHwnd () != NULL)
		{
			m_dwTimeStatus = m_pWndDateTime->GetTime(m_time);
		}

		ar << m_iWidth;
		ar << m_dwStyle;
		ar << m_dwTimeStatus;
		ar << m_time;
	}
}

SIZE CMFCToolBarDateTimeCtrl::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	if (!IsVisible())
	{
		return CSize(0,0);
	}

	m_bHorz = bHorz;
	m_sizeText = CSize(0, 0);

	if (bHorz)
	{
		if (m_pWndDateTime->GetSafeHwnd() != NULL && !m_bIsHidden)
		{
			m_pWndDateTime->ShowWindow(SW_SHOWNOACTIVATE);
		}

		if (m_bTextBelow && !m_strText.IsEmpty())
		{
			CRect rectText(0, 0, m_iWidth, sizeDefault.cy);
			pDC->DrawText(m_strText, rectText, DT_CENTER | DT_CALCRECT | DT_WORDBREAK);
			m_sizeText = rectText.Size();
		}

		return CSize(m_iWidth, sizeDefault.cy + m_sizeText.cy);
	}
	else
	{
		if (m_pWndDateTime->GetSafeHwnd() != NULL && (m_pWndDateTime->GetStyle() & WS_VISIBLE))
		{
			m_pWndDateTime->ShowWindow(SW_HIDE);
		}

		return CMFCToolBarButton::OnCalculateSize(pDC, sizeDefault, bHorz);
	}
}

void CMFCToolBarDateTimeCtrl::OnMove()
{
	if (m_pWndDateTime->GetSafeHwnd() == NULL || (m_pWndDateTime->GetStyle() & WS_VISIBLE) == 0)
	{
		return;
	}

	CRect rectDateTime;
	m_pWndDateTime->GetWindowRect(rectDateTime);

	m_pWndDateTime->SetWindowPos(NULL, m_rect.left + nHorzMargin, m_rect.top +(m_rect.Height() - m_sizeText.cy - rectDateTime.Height()) / 2,
		m_rect.Width() - 2 * nHorzMargin, afxGlobalData.GetTextHeight() + 2 * nVertMargin, SWP_NOZORDER | SWP_NOACTIVATE);

	AdjustRect();
}

void CMFCToolBarDateTimeCtrl::OnSize(int iSize)
{
	m_iWidth = iSize;
	m_rect.right = m_rect.left + m_iWidth;

	if (m_pWndDateTime->GetSafeHwnd() != NULL && (m_pWndDateTime->GetStyle() & WS_VISIBLE))
	{
		m_pWndDateTime->SetWindowPos(NULL, m_rect.left + nHorzMargin, m_rect.top,
			m_rect.Width() - 2 * nHorzMargin, afxGlobalData.GetTextHeight() + 2 * nVertMargin, SWP_NOZORDER | SWP_NOACTIVATE);

		AdjustRect();
	}
}

void CMFCToolBarDateTimeCtrl::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	if (m_pWndDateTime->GetSafeHwnd() != NULL)
	{
		CWnd* pWndParentCurr = m_pWndDateTime->GetParent();
		ENSURE(pWndParentCurr != NULL);

		if (pWndParent != NULL && pWndParentCurr->GetSafeHwnd() == pWndParent->GetSafeHwnd())
		{
			return;
		}

		m_pWndDateTime->DestroyWindow();
		delete m_pWndDateTime;
		m_pWndDateTime = NULL;
	}

	if (pWndParent == NULL || pWndParent->GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rect = m_rect;
	rect.InflateRect(-2, 0);
	rect.bottom = rect.top + afxGlobalData.GetTextHeight() + 2 * nVertMargin;

	if ((m_pWndDateTime = CreateDateTimeCtrl(pWndParent, rect)) == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	AdjustRect();

	m_pWndDateTime->SetFont(&afxGlobalData.fontRegular);
	if (m_dwTimeStatus == GDT_VALID)
	{
		m_pWndDateTime->SetTime(&m_time);
	}
}

void CMFCToolBarDateTimeCtrl::AdjustRect()
{
	if (m_pWndDateTime->GetSafeHwnd() == NULL || (m_pWndDateTime->GetStyle() & WS_VISIBLE) == 0 || m_rect.IsRectEmpty())
	{
		return;
	}

	m_pWndDateTime->GetWindowRect(&m_rect);
	m_pWndDateTime->ScreenToClient(&m_rect);
	m_pWndDateTime->MapWindowPoints(m_pWndDateTime->GetParent(), &m_rect);
	m_rect.InflateRect(nHorzMargin, nVertMargin);
}


#pragma warning(disable : 4310)

BOOL CMFCToolBarDateTimeCtrl::NotifyCommand(int iNotifyCode)
{
	if (m_pWndDateTime->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	switch(iNotifyCode)
	{
	case LOWORD(DTN_DATETIMECHANGE):
	case DTN_DATETIMECHANGE:
		{
			m_dwTimeStatus = m_pWndDateTime->GetTime(m_time);

			//------------------------------------------------------
			// Try set selection in ALL DateTimeCtrl's with the same ID:
			//------------------------------------------------------
			CObList listButtons;
			if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
			{
				for (POSITION posCombo = listButtons.GetHeadPosition(); posCombo != NULL;)
				{
					CMFCToolBarDateTimeCtrl* pDateTime = DYNAMIC_DOWNCAST(CMFCToolBarDateTimeCtrl, listButtons.GetNext(posCombo));
					ENSURE(pDateTime != NULL);

					if (pDateTime != this && m_dwTimeStatus == GDT_VALID)
					{
						pDateTime->m_pWndDateTime->SetTime(&m_time);
					}
				}
			}
		}

		return TRUE;
	}

	return TRUE;
}

#pragma warning(default : 4310)


void CMFCToolBarDateTimeCtrl::OnAddToCustomizePage()
{
	CObList listButtons; // Existing buttons with the same command ID

	if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) == 0)
	{
		return;
	}

	CMFCToolBarDateTimeCtrl* pOther = (CMFCToolBarDateTimeCtrl*) listButtons.GetHead();
	ASSERT_VALID(pOther);
	ASSERT_KINDOF(CMFCToolBarDateTimeCtrl, pOther);

	CopyFrom(*pOther);
}

HBRUSH CMFCToolBarDateTimeCtrl::OnCtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	pDC->SetTextColor(afxGlobalData.clrWindowText);
	pDC->SetBkColor(afxGlobalData.clrWindow);

	return(HBRUSH) afxGlobalData.brWindow.GetSafeHandle();
}

void CMFCToolBarDateTimeCtrl::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages,
	BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	if (m_pWndDateTime->GetSafeHwnd() == NULL || (m_pWndDateTime->GetStyle() & WS_VISIBLE) == 0)
	{
		CMFCToolBarButton::OnDraw(pDC, rect, pImages, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);
	}
	else if ((m_bTextBelow && bHorz) && !m_strText.IsEmpty())
	{
		//--------------------
		// Draw button's text:
		//--------------------
		BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

		pDC->SetTextColor(bDisabled ? afxGlobalData.clrGrayedText : (bHighlight) ? CMFCToolBar::GetHotTextColor() : afxGlobalData.clrBarText);
		CRect rectText;
		rectText.left = (rect.left + rect.right - m_sizeText.cx) / 2;
		rectText.right = (rect.left + rect.right + m_sizeText.cx) / 2;
		rectText.top = rect.bottom + rect.top;
		rectText.bottom = rectText.top + m_sizeText.cy;
		pDC->DrawText(m_strText, &rectText, DT_CENTER | DT_WORDBREAK);
	}
}

BOOL CMFCToolBarDateTimeCtrl::OnClick(CWnd* /*pWnd*/, BOOL /*bDelay*/)
{
	return m_pWndDateTime->GetSafeHwnd() != NULL && (m_pWndDateTime->GetStyle() & WS_VISIBLE);
}

int CMFCToolBarDateTimeCtrl::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	int iWidth = CMFCToolBarButton::OnDrawOnCustomizeList(pDC, rect, bSelected) + 10;

	//------------------------------
	// Simulate DateTimeCtrl appearance:
	//------------------------------
	CRect rectDateTime = rect;
	int iDateTimeWidth = rect.Width() - iWidth;

	if (iDateTimeWidth < 20)
	{
		iDateTimeWidth = 20;
	}

	rectDateTime.left = rectDateTime.right - iDateTimeWidth;
	rectDateTime.DeflateRect(2, 3);

	pDC->FillSolidRect(rectDateTime, afxGlobalData.clrWindow);
	pDC->Draw3dRect(&rectDateTime, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);

	rectDateTime.DeflateRect(1, 1);

	pDC->Draw3dRect(&rectDateTime, afxGlobalData.clrBarShadow, afxGlobalData.clrBarLight);

	CRect rectBtn = rectDateTime;
	rectBtn.left = rectBtn.right - rectBtn.Height();
	rectBtn.DeflateRect(1, 1);

	pDC->FillSolidRect(rectBtn, afxGlobalData.clrBarFace);
	pDC->Draw3dRect(&rectBtn, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectBtn);

	return rect.Width();
}

CMFCToolBarDateTimeCtrlImpl* CMFCToolBarDateTimeCtrl::CreateDateTimeCtrl(CWnd* pWndParent, const CRect& rect)
{
	CMFCToolBarDateTimeCtrlImpl* pWndDateTime = new CMFCToolBarDateTimeCtrlImpl;
	if (!pWndDateTime->Create(m_dwStyle, rect, pWndParent, m_nID))
	{
		delete pWndDateTime;
		return NULL;
	}

	return pWndDateTime;
}

void CMFCToolBarDateTimeCtrl::OnShow(BOOL bShow)
{
	if (m_pWndDateTime->GetSafeHwnd() != NULL)
	{
		if (bShow && m_bHorz)
		{
			m_pWndDateTime->ShowWindow(SW_SHOWNOACTIVATE);
			OnMove();
		}
		else
		{
			m_pWndDateTime->ShowWindow(SW_HIDE);
		}
	}
}

BOOL CMFCToolBarDateTimeCtrl::ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const
{
	CString strMessage;
	int iOffset;

	if (strMessage.LoadString(m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
	{
		menuButton.m_strText = strMessage.Mid(iOffset + 1);
	}

	return TRUE;
}

BOOL CMFCToolBarDateTimeCtrl::SetTime(LPSYSTEMTIME pTimeNew /* = NULL */)
{
	BOOL bResult = m_pWndDateTime->SetTime(pTimeNew);
	NotifyCommand(DTN_DATETIMECHANGE);
	return bResult;
}

BOOL CMFCToolBarDateTimeCtrl::SetTime(const COleDateTime& timeNew)
{
	BOOL bResult = m_pWndDateTime->SetTime(timeNew);
	NotifyCommand(DTN_DATETIMECHANGE);
	return bResult;
}

BOOL CMFCToolBarDateTimeCtrl::SetTime(const CTime* pTimeNew)
{
	BOOL bResult = m_pWndDateTime->SetTime(pTimeNew);
	NotifyCommand(DTN_DATETIMECHANGE);
	return bResult;
}

CMFCToolBarDateTimeCtrl* __stdcall CMFCToolBarDateTimeCtrl::GetByCmd(UINT uiCmd)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = NULL;

	CObList listButtons;
	if (CMFCToolBar::GetCommandButtons(uiCmd, listButtons) > 0)
	{
		for (POSITION posDateTime= listButtons.GetHeadPosition(); pSrcDateTime == NULL && posDateTime != NULL;)
		{
			CMFCToolBarDateTimeCtrl* pDateTime= DYNAMIC_DOWNCAST(CMFCToolBarDateTimeCtrl, listButtons.GetNext(posDateTime));
			ENSURE(pDateTime != NULL);

			pSrcDateTime = pDateTime;
		}
	}

	return pSrcDateTime;
}

BOOL __stdcall CMFCToolBarDateTimeCtrl::SetTimeAll(UINT uiCmd, LPSYSTEMTIME pTimeNew /* = NULL */)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		pSrcDateTime->SetTime(pTimeNew);
	}

	return pSrcDateTime != NULL;
}

BOOL __stdcall CMFCToolBarDateTimeCtrl::SetTimeAll(UINT uiCmd, const COleDateTime& timeNew)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		pSrcDateTime->SetTime(timeNew);
	}

	return pSrcDateTime != NULL;
}

BOOL __stdcall CMFCToolBarDateTimeCtrl::SetTimeAll(UINT uiCmd, const CTime* pTimeNew)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		pSrcDateTime->SetTime(pTimeNew);
	}

	return pSrcDateTime != NULL;
}

DWORD __stdcall CMFCToolBarDateTimeCtrl::GetTimeAll(UINT uiCmd, LPSYSTEMTIME pTimeDest)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		return pSrcDateTime->GetTime(pTimeDest);
	}
	else
		return GDT_NONE;
}

BOOL __stdcall CMFCToolBarDateTimeCtrl::GetTimeAll(UINT uiCmd, COleDateTime& timeDest)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		return pSrcDateTime->GetTime(timeDest);
	}
	else
		return FALSE;
}

DWORD __stdcall CMFCToolBarDateTimeCtrl::GetTimeAll(UINT uiCmd, CTime& timeDest)
{
	CMFCToolBarDateTimeCtrl* pSrcDateTime = GetByCmd(uiCmd);

	if (pSrcDateTime)
	{
		return pSrcDateTime->GetTime(timeDest);
	}
	else
		return GDT_NONE;
}

void CMFCToolBarDateTimeCtrl::SetStyle(UINT nStyle)
{
	CMFCToolBarButton::SetStyle(nStyle);

	if (m_pWndDateTime != NULL && m_pWndDateTime->GetSafeHwnd() != NULL)
	{
		BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() && !IsEditable()) || (!CMFCToolBar::IsCustomizeMode() &&(m_nStyle & TBBS_DISABLED));

		m_pWndDateTime->EnableWindow(!bDisabled);
	}
}

BOOL CMFCToolBarDateTimeCtrl::OnUpdateToolTip(CWnd* /*pWndParent*/, int /*iButtonIndex*/, CToolTipCtrl& wndToolTip, CString& strTipText)
{
	if (!m_bHorz)
	{
		return FALSE;
	}

	CString strTips;
	if (OnGetCustomToolTipText(strTips))
	{
		strTipText = strTips;
	}

	CDateTimeCtrl* pWndDate = GetDateTimeCtrl();
	if (pWndDate != NULL)
	{
		wndToolTip.AddTool(pWndDate, strTipText, NULL, 0);
		return TRUE;
	}

	return FALSE;
}

void CMFCToolBarDateTimeCtrl::OnGlobalFontsChanged()
{
	CMFCToolBarButton::OnGlobalFontsChanged();

	if (m_pWndDateTime->GetSafeHwnd() != NULL)
	{
		m_pWndDateTime->SetFont(&afxGlobalData.fontRegular);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbareditboxbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtoolbar.h"
#include "afxtoolbareditboxbutton.h"
#include "afxvisualmanager.h"
#include "afxtrackmouse.h"
#include "afxcontextmenumanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCToolBarEditBoxButton, CMFCToolBarButton, 1)

static const int nDefaultSize = 150;
static const int nHorzMargin = 3;
static const int nVertMargin = 1;

BOOL CMFCToolBarEditBoxButton::m_bFlat = TRUE;

// Construction/Destruction
CMFCToolBarEditBoxButton::CMFCToolBarEditBoxButton()
{
	m_dwStyle = WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL;
	m_iWidth = nDefaultSize;

	Initialize();
}

CMFCToolBarEditBoxButton::CMFCToolBarEditBoxButton(UINT uiId, int iImage, DWORD dwStyle, int iWidth) :
	CMFCToolBarButton(uiId, iImage)
{
	m_dwStyle = dwStyle | WS_CHILD | WS_VISIBLE;
	m_iWidth = (iWidth == 0) ? nDefaultSize : iWidth;

	Initialize();
}

void CMFCToolBarEditBoxButton::Initialize()
{
	m_pWndEdit = NULL;
	m_bHorz = TRUE;
	m_bChangingText = FALSE;
	m_bIsHotEdit = FALSE;
	m_uiMenuResID = 0;
}

CMFCToolBarEditBoxButton::~CMFCToolBarEditBoxButton()
{
	if (m_pWndEdit != NULL)
	{
		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
	}
}

void CMFCToolBarEditBoxButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);

	const CMFCToolBarEditBoxButton& src = (const CMFCToolBarEditBoxButton&) s;

	m_dwStyle = src.m_dwStyle;
	m_iWidth = src.m_iWidth;
	m_strContents = src.m_strContents;
	m_uiMenuResID = src.m_uiMenuResID;
}

void CMFCToolBarEditBoxButton::Serialize(CArchive& ar)
{
	CMFCToolBarButton::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_iWidth;
		m_rect.right = m_rect.left + m_iWidth;
		ar >> m_dwStyle;
		ar >> m_strContents;
		ar >> m_uiMenuResID;
	}
	else
	{
		ar << m_iWidth;
		ar << m_dwStyle;

		if (m_pWndEdit != NULL)
		{
			m_pWndEdit->GetWindowText(m_strContents);
		}
		else
		{
			m_strContents.Empty();
		}

		ar << m_strContents;
		ar << m_uiMenuResID;
	}
}

SIZE CMFCToolBarEditBoxButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	if (!IsVisible())
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}

		OnShowEditbox(FALSE);
		return CSize(0,0);
	}

	m_bHorz = bHorz;

	if (bHorz)
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL && !m_bIsHidden)
		{
			m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);
			OnShowEditbox(TRUE);
		}

		if (m_bTextBelow && !m_strText.IsEmpty())
		{
			CRect rectText(0, 0, m_iWidth, sizeDefault.cy);
			pDC->DrawText( m_strText, rectText, DT_CENTER | DT_CALCRECT | DT_WORDBREAK);
			m_sizeText = rectText.Size();
		}
		else
			m_sizeText = CSize(0,0);

		return CSize(m_iWidth, sizeDefault.cy + m_sizeText.cy);
	}
	else
	{
		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
			OnShowEditbox(FALSE);
		}

		m_sizeText = CSize(0,0);

		return CMFCToolBarButton::OnCalculateSize(pDC, sizeDefault, bHorz);
	}
}

void CMFCToolBarEditBoxButton::OnMove()
{
	if (m_pWndEdit->GetSafeHwnd() == NULL ||
		(m_pWndEdit->GetStyle() & WS_VISIBLE) == 0)
	{
		return;
	}

	int cy = afxGlobalData.GetTextHeight();
	int yOffset = max(0, (m_rect.Height() - m_sizeText.cy - cy) / 2);

	m_pWndEdit->SetWindowPos(NULL, m_rect.left + nHorzMargin, m_rect.top + yOffset, m_rect.Width() - 2 * nHorzMargin, cy, SWP_NOZORDER | SWP_NOACTIVATE);
	m_pWndEdit->SetSel(-1, 0);
}

void CMFCToolBarEditBoxButton::OnSize(int iSize)
{
	m_iWidth = iSize;
	m_rect.right = m_rect.left + m_iWidth;

	OnMove();
}

void CMFCToolBarEditBoxButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		CWnd* pWndParentCurr = m_pWndEdit->GetParent();
		ENSURE(pWndParentCurr != NULL);

		if (pWndParent != NULL && pWndParentCurr->GetSafeHwnd() == pWndParent->GetSafeHwnd())
		{
			return;
		}

		m_pWndEdit->GetWindowText(m_strContents);

		m_pWndEdit->DestroyWindow();
		delete m_pWndEdit;
		m_pWndEdit = NULL;
	}

	if (pWndParent == NULL || pWndParent->GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rect = m_rect;
	rect.DeflateRect(nHorzMargin, nVertMargin);
	rect.bottom = rect.top + afxGlobalData.GetTextHeight();

	if ((m_pWndEdit = CreateEdit(pWndParent, rect)) == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pWndEdit);

	OnMove();
	m_pWndEdit->SetFont(&afxGlobalData.fontRegular);

	CString sText;
	m_pWndEdit->GetWindowText(sText);
	if (sText.IsEmpty())
	{
		m_bChangingText = TRUE;
		m_pWndEdit->SetWindowText(m_strContents);
		m_bChangingText = FALSE;
	}
	else
	{
		m_strContents = sText;
	}
}

BOOL CMFCToolBarEditBoxButton::NotifyCommand(int iNotifyCode)
{
	if (m_pWndEdit->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	switch (iNotifyCode)
	{
	case EN_UPDATE:
		{
			m_pWndEdit->GetWindowText(m_strContents);

			// Try set selection in ALL editboxes with the same ID:
			CObList listButtons;
			if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
			{
				for (POSITION posCombo = listButtons.GetHeadPosition(); posCombo != NULL;)
				{
					CMFCToolBarEditBoxButton* pEdit = DYNAMIC_DOWNCAST(CMFCToolBarEditBoxButton, listButtons.GetNext(posCombo));

					if ((pEdit != NULL) &&(pEdit != this))
					{
						pEdit->SetContents(m_strContents);
					}
				}
			}
		}

		return !m_bChangingText;
	}

	return FALSE;
}

void CMFCToolBarEditBoxButton::OnAddToCustomizePage()
{
	CObList listButtons; // Existing buttons with the same command ID

	if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) == 0)
	{
		return;
	}

	CMFCToolBarEditBoxButton* pOther =
		(CMFCToolBarEditBoxButton*) listButtons.GetHead();
	ASSERT_VALID(pOther);
	ASSERT_KINDOF(CMFCToolBarEditBoxButton, pOther);

	CopyFrom(*pOther);
}

HBRUSH CMFCToolBarEditBoxButton::OnCtlColor(CDC* pDC, UINT /*nCtlColor*/)
{
	pDC->SetTextColor(afxGlobalData.clrWindowText);
	pDC->SetBkColor(afxGlobalData.clrWindow);

	return(HBRUSH) afxGlobalData.brWindow.GetSafeHandle();
}

void CMFCToolBarEditBoxButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz,
	BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	if (m_pWndEdit->GetSafeHwnd() == NULL ||
		(m_pWndEdit->GetStyle() & WS_VISIBLE) == 0)
	{
		CMFCToolBarButton::OnDraw(pDC, rect, pImages, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);
		return;
	}

	BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

	CRect rectBorder;
	GetEditBorder(rectBorder);

	CMFCVisualManager::GetInstance()->OnDrawEditBorder(pDC, rectBorder, bDisabled, !m_bFlat || m_bIsHotEdit, this);

	if ((m_bTextBelow && bHorz) && !m_strText.IsEmpty())
	{
		// Draw button's text:
		bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

		pDC->SetTextColor(bDisabled ? afxGlobalData.clrGrayedText : (bHighlight) ? CMFCToolBar::GetHotTextColor() : afxGlobalData.clrBtnText);
		CRect rectText = rect;
		rectText.top = (rectBorder.bottom + rect.bottom - m_sizeText.cy) / 2;
		pDC->DrawText(m_strText, &rectText, DT_CENTER | DT_WORDBREAK);
	}
}

void CMFCToolBarEditBoxButton::GetEditBorder(CRect& rectBorder)
{
	ENSURE(m_pWndEdit->GetSafeHwnd() != NULL);

	m_pWndEdit->GetWindowRect(rectBorder);
	m_pWndEdit->GetParent()->ScreenToClient(rectBorder);
	rectBorder.InflateRect(1, 1);
}

BOOL CMFCToolBarEditBoxButton::OnClick(CWnd* /*pWnd*/, BOOL /*bDelay*/)
{
	return m_pWndEdit->GetSafeHwnd() != NULL && (m_pWndEdit->GetStyle() & WS_VISIBLE);
}

int CMFCToolBarEditBoxButton::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	int iWidth = CMFCToolBarButton::OnDrawOnCustomizeList(pDC, rect, bSelected) + 10;

	// Simulate editbox appearance:
	CRect rectEdit = rect;
	int nEditWidth = max(8, rect.Width() - iWidth);

	rectEdit.left = rectEdit.right - nEditWidth;
	rectEdit.DeflateRect(2, 2);

	pDC->FillRect(rectEdit, &afxGlobalData.brWindow);
	pDC->Draw3dRect(rectEdit, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	return rect.Width();
}

CEdit* CMFCToolBarEditBoxButton::CreateEdit(CWnd* pWndParent, const CRect& rect)
{
	ASSERT_VALID(this);

	CMFCToolBarEditCtrl* pWndEdit = new CMFCToolBarEditCtrl(*this);
	if (!pWndEdit->Create(m_dwStyle, rect, pWndParent, m_nID))
	{
		delete pWndEdit;
		return NULL;
	}

	return pWndEdit;
}

void CMFCToolBarEditBoxButton::OnShow(BOOL bShow)
{
	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		if (bShow)
		{
			m_pWndEdit->ShowWindow(SW_SHOWNOACTIVATE);
			OnMove();
		}
		else
		{
			m_pWndEdit->ShowWindow(SW_HIDE);
		}

		OnShowEditbox(bShow);
	}
}

void CMFCToolBarEditBoxButton::SetContents(const CString& sContents)
{
	if (m_strContents == sContents)
		return;

	m_strContents = sContents;
	if (m_pWndEdit != NULL)
	{
		m_bChangingText = TRUE;
		m_pWndEdit->SetWindowText(m_strContents);
		m_bChangingText = FALSE;
	}
}

const CRect CMFCToolBarEditBoxButton::GetInvalidateRect() const
{
	if ((m_bTextBelow && m_bHorz) && !m_strText.IsEmpty())
	{
		CRect rect;
		rect.left = (m_rect.left + m_rect.right - m_sizeText.cx) / 2;
		rect.right = (m_rect.left + m_rect.right + m_sizeText.cx) / 2;
		rect.top = m_rect.top;
		rect.bottom = m_rect.bottom + m_rect.top + m_sizeText.cy;
		return rect;
	}
	else
		return m_rect;
}

CMFCToolBarEditBoxButton* __stdcall CMFCToolBarEditBoxButton::GetByCmd(UINT uiCmd)
{
	CMFCToolBarEditBoxButton* pSrcEdit = NULL;

	CObList listButtons;
	if (CMFCToolBar::GetCommandButtons(uiCmd, listButtons) > 0)
	{
		for (POSITION posEdit= listButtons.GetHeadPosition(); pSrcEdit == NULL && posEdit != NULL;)
		{
			CMFCToolBarEditBoxButton* pEdit= DYNAMIC_DOWNCAST(CMFCToolBarEditBoxButton, listButtons.GetNext(posEdit));
			ENSURE(pEdit != NULL);

			pSrcEdit = pEdit;
		}
	}

	return pSrcEdit;
}

BOOL __stdcall CMFCToolBarEditBoxButton::SetContentsAll(UINT uiCmd, const CString& strContents)
{
	CMFCToolBarEditBoxButton* pSrcEdit = GetByCmd(uiCmd);

	if (pSrcEdit)
	{
		pSrcEdit->SetContents(strContents);
	}

	return pSrcEdit != NULL;
}

CString __stdcall CMFCToolBarEditBoxButton::GetContentsAll(UINT uiCmd)
{
	CMFCToolBarEditBoxButton* pSrcEdit = GetByCmd(uiCmd);
	CString str;

	if (pSrcEdit)
	{
		pSrcEdit->m_pWndEdit->GetWindowText(str);
	}

	return str;
}

void CMFCToolBarEditBoxButton::SetStyle(UINT nStyle)
{
	CMFCToolBarButton::SetStyle(nStyle);

	if (m_pWndEdit != NULL && m_pWndEdit->GetSafeHwnd() != NULL)
	{
		BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() && !IsEditable()) || (!CMFCToolBar::IsCustomizeMode() &&(m_nStyle & TBBS_DISABLED));

		m_pWndEdit->EnableWindow(!bDisabled);
	}
}

void CMFCToolBarEditBoxButton::SetHotEdit(BOOL bHot)
{
	if (m_bIsHotEdit != bHot)
	{
		m_bIsHotEdit = bHot;

		if (m_pWndEdit->GetParent() != NULL)
		{
			CRect rect = m_rect;

			m_pWndEdit->GetParent()->InvalidateRect(m_rect);
			m_pWndEdit->GetParent()->UpdateWindow();
		}
	}
}

BOOL CMFCToolBarEditBoxButton::OnUpdateToolTip(CWnd* /*pWndParent*/, int /*iButtonIndex*/, CToolTipCtrl& wndToolTip, CString& str)
{
	CEdit* pEdit = GetEditBox();

	if ((pEdit != NULL) &&(::IsWindow(pEdit->GetSafeHwnd())))
	{
		CString strTips;

		if (OnGetCustomToolTipText(strTips))
		{
			wndToolTip.AddTool(pEdit, strTips, NULL, 0);
		}
		else
		{
			wndToolTip.AddTool(pEdit, str, NULL, 0);
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCToolBarEditBoxButton::OnGlobalFontsChanged()
{
	CMFCToolBarButton::OnGlobalFontsChanged();

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_pWndEdit->SetFont(&afxGlobalData.fontRegular);
	}
}

BOOL CMFCToolBarEditBoxButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	if (!CMFCToolBarButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	data.m_nAccRole = ROLE_SYSTEM_TEXT;
	data.m_bAccState = STATE_SYSTEM_FOCUSABLE;

	if (HasFocus())
	{
		data.m_bAccState |= STATE_SYSTEM_FOCUSED;
	}

	data.m_strAccDefAction = _T("Edit");
	data.m_strAccValue = m_strText;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarEditCtrl

CMFCToolBarEditCtrl::CMFCToolBarEditCtrl(CMFCToolBarEditBoxButton& edit) : m_buttonEdit(edit)
{
	m_bTracked = FALSE;
}

CMFCToolBarEditCtrl::~CMFCToolBarEditCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCToolBarEditCtrl, CMFCEditBrowseCtrl)
	//{{AFX_MSG_MAP(CMFCToolBarEditCtrl)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEMOVE()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCToolBarEditCtrl::OnMouseLeave)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarEditCtrl message handlers

BOOL CMFCToolBarEditCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN)
	{
		switch (pMsg->wParam)
		{
		case VK_TAB:
			if (GetParent() != NULL)
			{
				ASSERT_VALID(GetParent());
				GetParent()->GetNextDlgTabItem(this)->SetFocus();
				return TRUE;
			}
			break;

		case VK_ESCAPE:
			if (GetTopLevelFrame() != NULL)
			{
				GetTopLevelFrame()->SetFocus();
				return TRUE;
			}

			break;
		}

		if (GetFocus() == this && GetKeyState(VK_CONTROL) & 0x8000 )
		{
			switch (pMsg->wParam)
			{
			case 'V':
				Paste();
				return TRUE;

			case 'C':
				Copy();
				return TRUE;

			case 'X':
				Cut();
				return TRUE;

			case 'Z':
				Undo();
				return TRUE;

			case VK_DELETE:
				Clear();
				return TRUE;
			}
		}
	}

	return CMFCEditBrowseCtrl::PreTranslateMessage(pMsg);
}

void CMFCToolBarEditCtrl::OnSetFocus(CWnd* pOldWnd)
{
	CMFCEditBrowseCtrl::OnSetFocus(pOldWnd);
	m_buttonEdit.SetHotEdit(TRUE);
}

void CMFCToolBarEditCtrl::OnKillFocus(CWnd* pNewWnd)
{
	CMFCEditBrowseCtrl::OnKillFocus(pNewWnd);
	m_buttonEdit.SetHotEdit(FALSE);
}

void CMFCToolBarEditCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	CMFCEditBrowseCtrl::OnMouseMove(nFlags, point);
	m_buttonEdit.SetHotEdit(TRUE);

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		::AFXTrackMouse(&trackmouseevent);
	}
}

LRESULT CMFCToolBarEditCtrl::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (CWnd::GetFocus() != this)
	{
		m_buttonEdit.SetHotEdit(FALSE);
	}

	return 0;
}

void CMFCToolBarEditCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
{

	if (m_buttonEdit.m_uiMenuResID != 0)
	{

		CWnd* pWndParent = pWnd->GetParent();

		HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(m_buttonEdit.m_uiMenuResID), RT_MENU);

		if (hInst == NULL)
		{
			CMFCEditBrowseCtrl::OnContextMenu(pWnd, point) ;
			return;

		}

		HMENU hMenu = ::LoadMenuW(hInst, MAKEINTRESOURCEW(m_buttonEdit.m_uiMenuResID));

		if (hMenu == NULL)
		{
			CMFCEditBrowseCtrl::OnContextMenu(pWnd, point) ;
			return;
		}

		HMENU hPopupMenu = ::GetSubMenu(hMenu, 0);

		if (hPopupMenu == NULL)
		{
			CMFCEditBrowseCtrl::OnContextMenu(pWnd, point) ;
			return;
		}

		if (afxContextMenuManager != NULL)
		{
			afxContextMenuManager->ShowPopupMenu(hPopupMenu, point.x, point.y, pWndParent);

		}
		else
		{
			::TrackPopupMenu(hPopupMenu, TPM_CENTERALIGN | TPM_LEFTBUTTON, point.x, point.y, 0, pWndParent->GetSafeHwnd(), NULL);
		}
	}else
	{
		CMFCEditBrowseCtrl::OnContextMenu(pWnd, point) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarmenubuttonsbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtoolbarmenubuttonsbutton.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCToolBarMenuButtonsButton, CMFCToolBarButton)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarMenuButtonsButton::CMFCToolBarMenuButtonsButton()
{
	m_uiSystemCommand = 0;
}

CMFCToolBarMenuButtonsButton::CMFCToolBarMenuButtonsButton(UINT uiCmdId)
{
	if (uiCmdId != SC_CLOSE && uiCmdId != SC_MINIMIZE && uiCmdId != SC_RESTORE)
	{
		ASSERT(FALSE);
	}

	m_uiSystemCommand = uiCmdId;
}

CMFCToolBarMenuButtonsButton::~CMFCToolBarMenuButtonsButton()
{
}

void CMFCToolBarMenuButtonsButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/,
	BOOL /*bHorz*/, BOOL /*bCustomizeMode*/, BOOL bHighlight, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	CMFCVisualManager::GetInstance()->OnDrawMenuSystemButton(pDC, rect, m_uiSystemCommand, m_nStyle, bHighlight);
}

SIZE CMFCToolBarMenuButtonsButton::OnCalculateSize(CDC* /*pDC*/, const CSize& /*sizeDefault*/, BOOL /*bHorz*/)
{
	return CSize( ::GetSystemMetrics(SM_CXMENUSIZE), ::GetSystemMetrics(SM_CYMENUSIZE)); // Fixed by JX Chen
}

void CMFCToolBarMenuButtonsButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);

	const CMFCToolBarMenuButtonsButton& src = (const CMFCToolBarMenuButtonsButton&) s;
	m_uiSystemCommand = src.m_uiSystemCommand;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarnamedialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtoolbarnamedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarNameDialog dialog


CMFCToolBarNameDialog::CMFCToolBarNameDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CMFCToolBarNameDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMFCToolBarNameDialog)
	m_strToolbarName = _T("");
	//}}AFX_DATA_INIT
}


void CMFCToolBarNameDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarNameDialog)
	DDX_Control(pDX, IDOK, m_btnOk);
	DDX_Text(pDX, IDC_AFXBARRES_TOOLBAR_NAME, m_strToolbarName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMFCToolBarNameDialog, CDialog)
	//{{AFX_MSG_MAP(CMFCToolBarNameDialog)
	ON_EN_UPDATE(IDC_AFXBARRES_TOOLBAR_NAME, &CMFCToolBarNameDialog::OnUpdateToolbarName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarNameDialog message handlers

void CMFCToolBarNameDialog::OnUpdateToolbarName()
{
	UpdateData();
	m_btnOk.EnableWindow(!m_strToolbarName.IsEmpty());
}

BOOL CMFCToolBarNameDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	if (AfxGetMainWnd() != NULL && (AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	m_btnOk.EnableWindow(!m_strToolbarName.IsEmpty());
	return TRUE;  // return TRUE unless you set the focus to a control
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarmenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxmenuhash.h"
#include "afxcontrolbarutil.h"
#include "afxtoolbarmenubutton.h"
#include "afxmenubar.h"
#include "afxpopupmenubar.h"
#include "afxcommandmanager.h"
#include "afxglobals.h"
#include "afxkeyboardmanager.h"

#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"

#include "afxmenuimages.h"
#include "afxusertoolsmanager.h"
#include "afxmenutearoffmanager.h"
#include "afxusertool.h"
#include "afxsettingsstore.h"
#include "afxvisualmanager.h"
#include "afxribbonres.h"

#include "afxtabctrl.h"
#include "afxdropdownlistbox.h"
#include "afxbaseribbonelement.h"
#include "afxribbonbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCToolBarMenuButton, CMFCToolBarButton, VERSIONABLE_SCHEMA | 1)

BOOL CMFCToolBarMenuButton::m_bAlwaysCallOwnerDraw = FALSE;

static const CString strDummyAmpSeq = _T("\001\001");

// Construction/Destruction
CMFCToolBarMenuButton::CMFCToolBarMenuButton()
{
	Initialize();
}

CMFCToolBarMenuButton::CMFCToolBarMenuButton(UINT uiID, HMENU hMenu, int iImage, LPCTSTR lpszText, BOOL bUserButton)
{
	Initialize(uiID, hMenu, iImage, lpszText, bUserButton);
}

void CMFCToolBarMenuButton::Initialize()
{
	m_bDrawDownArrow = FALSE;
	m_bMenuMode = FALSE;
	m_pPopupMenu = NULL;
	m_bDefault = FALSE;
	m_bClickedOnMenu = FALSE;
	m_bHorz = TRUE;
	m_bMenuOnly = FALSE; //JRG
	m_bToBeClosed = FALSE;
	m_uiTearOffBarID = 0;
	m_bIsRadio = FALSE;
	m_pWndMessage = NULL;
	m_bMenuPaletteMode = FALSE;
	m_nPaletteRows = 1;
	m_bQuickCustomMode = FALSE;
	m_bShowAtRightSide = FALSE;
	m_rectArrow.SetRectEmpty();
	m_rectButton.SetRectEmpty();
}

void CMFCToolBarMenuButton::Initialize(UINT uiID, HMENU hMenu, int iImage, LPCTSTR lpszText, BOOL bUserButton)
{
	Initialize();

	m_nID = uiID;
	m_bUserButton = bUserButton;

	SetImage(iImage);
	m_strText = (lpszText == NULL) ? _T("") : lpszText;

	CreateFromMenu(hMenu);
}

CMFCToolBarMenuButton::CMFCToolBarMenuButton(const CMFCToolBarMenuButton& src)
{
	m_nID = src.m_nID;
	m_nStyle = src.m_nStyle;
	m_bUserButton = src.m_bUserButton;

	SetImage(src.GetImage());
	m_strText = src.m_strText;
	m_bDragFromCollection = FALSE;
	m_bText = src.m_bText;
	m_bImage = src.m_bImage;
	m_bDrawDownArrow = src.m_bDrawDownArrow;
	m_bMenuMode = src.m_bMenuMode;
	m_bDefault = src.m_bDefault;
	m_bMenuOnly = src.m_bMenuOnly;
	m_bIsRadio = src.m_bIsRadio;

	SetTearOff(src.m_uiTearOffBarID);

	HMENU hmenu = src.CreateMenu();
	ENSURE(hmenu != NULL);

	CreateFromMenu(hmenu);
	::DestroyMenu(hmenu);

	m_rect.SetRectEmpty();

	m_pPopupMenu = NULL;
	m_pWndParent = NULL;

	m_bClickedOnMenu = FALSE;
	m_bHorz = TRUE;

	m_bMenuPaletteMode = src.m_bMenuPaletteMode;
	m_nPaletteRows = src.m_nPaletteRows;
	m_bQuickCustomMode = src.m_bQuickCustomMode;
	m_bShowAtRightSide = src.m_bShowAtRightSide;
}

CMFCToolBarMenuButton::~CMFCToolBarMenuButton()
{
	if (m_pPopupMenu != NULL)
	{
		m_pPopupMenu->m_pParentBtn = NULL;
	}

	while (!m_listCommands.IsEmpty())
	{
		delete m_listCommands.RemoveHead();
	}

	if (m_uiTearOffBarID != 0 && g_pTearOffMenuManager != NULL)
	{
		g_pTearOffMenuManager->SetInUse(m_uiTearOffBarID, FALSE);
	}
}

//////////////////////////////////////////////////////////////////////
// Overrides:

void CMFCToolBarMenuButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);

	const CMFCToolBarMenuButton& src = (const CMFCToolBarMenuButton&) s;

	m_bDefault = src.m_bDefault;
	m_bMenuOnly = src.m_bMenuOnly;
	m_bIsRadio = src.m_bIsRadio;
	m_pWndMessage = src.m_pWndMessage;
	m_bMenuPaletteMode = src.m_bMenuPaletteMode;
	m_nPaletteRows = src.m_nPaletteRows;
	m_bQuickCustomMode = src.m_bQuickCustomMode;
	m_bShowAtRightSide = src.m_bShowAtRightSide;

	SetTearOff(src.m_uiTearOffBarID);

	while (!m_listCommands.IsEmpty())
	{
		delete m_listCommands.RemoveHead();
	}

	for (POSITION pos = src.m_listCommands.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarMenuButton* pItem = (CMFCToolBarMenuButton*) src.m_listCommands.GetNext(pos);
		ENSURE(pItem != NULL);
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(CMFCToolBarMenuButton, pItem);

		CRuntimeClass* pSrcClass = pItem->GetRuntimeClass();
		ENSURE(pSrcClass != NULL);

		CMFCToolBarMenuButton* pNewItem = (CMFCToolBarMenuButton*) pSrcClass->CreateObject();
		ENSURE(pNewItem != NULL);
		ASSERT_VALID(pNewItem);
		ASSERT_KINDOF(CMFCToolBarMenuButton, pNewItem);

		pNewItem->CopyFrom(*pItem);
		m_listCommands.AddTail(pNewItem);
	}
}

void CMFCToolBarMenuButton::Serialize(CArchive& ar)
{
	CMFCToolBarButton::Serialize(ar);

	if (ar.IsLoading())
	{
		while (!m_listCommands.IsEmpty())
		{
			delete m_listCommands.RemoveHead();
		}

		UINT uiTearOffBarID;
		ar >> uiTearOffBarID;

		SetTearOff(uiTearOffBarID);

		ar >> m_bMenuPaletteMode;
		ar >> m_nPaletteRows;
	}
	else
	{
		ar << m_uiTearOffBarID;

		ar << m_bMenuPaletteMode;
		ar << m_nPaletteRows;
	}

	m_listCommands.Serialize(ar);
}

void CMFCToolBarMenuButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	m_rectArrow.SetRectEmpty();
	m_rectButton.SetRectEmpty();

	if (m_bMenuMode)
	{
		DrawMenuItem(pDC, rect, pImages, bCustomizeMode, bHighlight, bGrayDisabledButtons);
		return;
	}

	BOOL bIsFlatLook = CMFCVisualManager::GetInstance()->IsMenuFlatLook();

	const int nSeparatorSize = 2;

	if (m_bMenuPaletteMode)
	{
		m_nStyle &= ~TBBS_CHECKED;
	}

	//----------------------
	// Fill button interior:
	//----------------------
	FillInterior(pDC, rect, bHighlight || IsDroppedDown());

	CSize sizeImage = CMenuImages::Size();
	if (CMFCToolBar::IsLargeIcons())
	{
		sizeImage.cx *= 2;
		sizeImage.cy *= 2;
	}

	CRect rectInternal = rect;
	CSize sizeExtra = m_bExtraSize ? CMFCVisualManager::GetInstance()->GetButtonExtraBorder() : CSize(0, 0);

	if (sizeExtra != CSize(0, 0))
	{
		rectInternal.DeflateRect(sizeExtra.cx / 2 + 1, sizeExtra.cy / 2 + 1);
	}

	CRect rectParent = rect;
	m_rectArrow = rectInternal;

	const int nMargin = CMFCVisualManager::GetInstance()->GetMenuImageMargin();
	const int nXMargin = bHorz ? nMargin : 0;
	const int nYMargin = bHorz ? 0 : nMargin;

	rectParent.DeflateRect(nXMargin, nYMargin);

	if (m_bDrawDownArrow)
	{
		if (bHorz)
		{
			rectParent.right -= sizeImage.cx + nSeparatorSize - 2 + sizeExtra.cx;
			m_rectArrow.left = rectParent.right + 1;

			if (sizeExtra != CSize(0, 0))
			{
				m_rectArrow.OffsetRect(-sizeExtra.cx / 2 + 1, -sizeExtra.cy / 2 + 1);
			}
		}
		else
		{
			rectParent.bottom -= sizeImage.cy + nSeparatorSize - 1;
			m_rectArrow.top = rectParent.bottom;
		}
	}

	UINT uiStyle = m_nStyle;

	if (bIsFlatLook)
	{
		m_nStyle &= ~(TBBS_PRESSED | TBBS_CHECKED);
	}
	else
	{
		if (m_bClickedOnMenu && m_nID != 0 && m_nID != (UINT) -1 && !m_bMenuOnly)
		{
			m_nStyle &= ~TBBS_PRESSED;
		}
		else if (m_pPopupMenu != NULL)
		{
			m_nStyle |= TBBS_PRESSED;
		}
	}

	BOOL bDisableFill = m_bDisableFill;
	m_bDisableFill = TRUE;

	CMFCToolBarButton::OnDraw(pDC, rectParent, pImages, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);

	m_bDisableFill = bDisableFill;

	if (m_bDrawDownArrow)
	{
		if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) && !bIsFlatLook)
		{
			m_rectArrow.OffsetRect(1, 1);
		}

		if ((bHighlight ||(m_nStyle & TBBS_PRESSED) || m_pPopupMenu != NULL) && m_nID != 0 && m_nID != (UINT) -1 && !m_bMenuOnly)
		{
			//----------------
			// Draw separator:
			//----------------
			CRect rectSeparator = m_rectArrow;

			if (bHorz)
			{
				rectSeparator.right = rectSeparator.left + nSeparatorSize;
			}
			else
			{
				rectSeparator.bottom = rectSeparator.top + nSeparatorSize;
			}

			CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

			if (bHighlight ||(m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)))
			{
				//-----------------------
				// Pressed in or checked:
				//-----------------------
				state = CMFCVisualManager::ButtonsIsPressed;
			}

			if (!m_bClickedOnMenu)
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonSeparator(pDC, this, rectSeparator, state, bHorz);
			}
		}

		BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

		int iImage;
		if (bHorz && !m_bMenuOnly)
		{
			iImage = CMenuImages::IdArrowDown;
		}
		else
		{
			iImage = CMenuImages::IdArrowRight;
		}

		CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, m_rectArrow, bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack, sizeImage);
	}

	m_nStyle = uiStyle;

	if (!bCustomizeMode)
	{
		if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) || m_pPopupMenu != NULL)
		{
			//-----------------------
			// Pressed in or checked:
			//-----------------------
			if (!bIsFlatLook && m_bClickedOnMenu && m_nID != 0 && m_nID != (UINT) -1 && !m_bMenuOnly) //JRG
			{
				rectParent.right++;

				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectParent, CMFCVisualManager::ButtonsIsHighlighted);
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, m_rectArrow, CMFCVisualManager::ButtonsIsPressed);
			}
			else
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsPressed);
			}
		}
		else if (bHighlight && !(m_nStyle & TBBS_DISABLED) && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsHighlighted);
		}
	}
}

SIZE CMFCToolBarMenuButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	m_bHorz = bHorz;

	if (!IsVisible())
	{
		return CSize(0,0);
	}

	int nArrowSize = 0;
	const int nSeparatorSize = 2;

	if (m_bDrawDownArrow || m_bMenuMode)
	{
		if (m_bMenuMode)
		{
			nArrowSize = (bHorz) ? afxGlobalData.GetTextWidth() : afxGlobalData.GetTextHeight();
		}
		else
		{
			nArrowSize = (bHorz) ? CMenuImages::Size().cx : CMenuImages::Size().cy;

			if (CMFCToolBar::IsLargeIcons())
			{
				nArrowSize *= 2;
			}
		}

		nArrowSize += nSeparatorSize - AFX_TEXT_MARGIN - 1;
	}

	//--------------------
	// Change accelerator:
	//--------------------
	if (afxKeyboardManager != NULL && m_bMenuMode && (m_nID < 0xF000 || m_nID >= 0xF1F0)) // Not system.
	{
		//-----------------------------------
		// Remove standard aceleration label:
		//-----------------------------------
		int iTabOffset = m_strText.Find(_T('\t'));
		if (iTabOffset >= 0)
		{
			m_strText = m_strText.Left(iTabOffset);
		}

		//---------------------------------
		// Add an actual accelartion label:
		//---------------------------------
		CString strAccel;
		CFrameWnd* pParent = m_pWndParent == NULL ? DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd()) :
		AFXGetTopLevelFrame(m_pWndParent);

		if (pParent != NULL && (CKeyboardManager::FindDefaultAccelerator(m_nID, strAccel, pParent, TRUE) ||
			CKeyboardManager::FindDefaultAccelerator(m_nID, strAccel, pParent->GetActiveFrame(), FALSE)))
		{
			m_strText += _T('\t');
			m_strText += strAccel;
		}
	}

	CFont* pOldFont = NULL;

	if (m_nID == AFX_MENU_GROUP_ID)
	{
		pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
		ASSERT_VALID(pOldFont);
	}

	CSize size = CMFCToolBarButton::OnCalculateSize(pDC, sizeDefault, bHorz);

	if (pOldFont != NULL)
	{
		pDC->SelectObject(pOldFont);
	}

	CMFCPopupMenuBar* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);

	if (pParentMenu != NULL)
	{
		size.cy = pParentMenu->GetRowHeight();

		if (pParentMenu->IsDropDownListMode())
		{
			CMFCDropDownListBox* pList = DYNAMIC_DOWNCAST(CMFCDropDownListBox, pParentMenu->GetParent());

			if (pList != NULL)
			{
				return pList->OnGetItemSize(pDC, this, size);
			}
		}
	}

	if (bHorz)
	{
		size.cx += nArrowSize;
	}
	else
	{
		size.cy += nArrowSize;
	}

	if (m_bMenuMode)
	{
		size.cx += sizeDefault.cx + 2 * AFX_TEXT_MARGIN;
	}

	if (!m_bMenuMode)
	{
		const int nMargin = CMFCVisualManager::GetInstance()->GetMenuImageMargin();

		if (bHorz)
		{
			size.cx += nMargin * 2;
		}
		else
		{
			size.cy += nMargin * 2;
		}
	}

	return size;
}

BOOL CMFCToolBarMenuButton::OnClick(CWnd* pWnd, BOOL bDelay)
{
	ASSERT_VALID(pWnd);

	m_bClickedOnMenu = FALSE;

	if (m_bDrawDownArrow && !bDelay && !m_bMenuMode)
	{
		if (m_nID == 0 || m_nID == (UINT) -1)
		{
			m_bClickedOnMenu = TRUE;
		}
		else
		{
			CPoint ptMouse;
			::GetCursorPos(&ptMouse);
			pWnd->ScreenToClient(&ptMouse);

			m_bClickedOnMenu = m_rectArrow.PtInRect(ptMouse);
			if (!m_bClickedOnMenu)
			{
				return FALSE;
			}
		}
	}

	if (HasButton() && !bDelay)
	{
		CPoint ptMouse;
		::GetCursorPos(&ptMouse);
		pWnd->ScreenToClient(&ptMouse);

		if (m_rectButton.PtInRect(ptMouse))
		{
			return FALSE;
		}
	}

	if (!m_bClickedOnMenu && m_nID > 0 && m_nID != (UINT) -1 && !m_bDrawDownArrow && !m_bMenuOnly)
	{
		return FALSE;
	}

	CMFCMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCMenuBar, m_pWndParent);

	if (m_pPopupMenu != NULL)
	{
		//-----------------------------------------------------
		// Second click to the popup menu item closes the menu:
		//-----------------------------------------------------
		ASSERT_VALID(m_pPopupMenu);

		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->DestroyWindow();
		m_pPopupMenu = NULL;

		if (pMenuBar != NULL)
		{
			pMenuBar->SetHot(NULL);
		}
	}
	else
	{
		CMFCPopupMenuBar* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);

		if (bDelay && pParentMenu != NULL && !CMFCToolBar::IsCustomizeMode())
		{
			pParentMenu->StartPopupMenuTimer(this);
		}
		else
		{
			if (pMenuBar != NULL)
			{
				CMFCToolBarMenuButton* pCurrPopupMenuButton = pMenuBar->GetDroppedDownMenu();
				if (pCurrPopupMenuButton != NULL)
				{
					pCurrPopupMenuButton->OnCancelMode();
				}
			}

			if (!OpenPopupMenu(pWnd))
			{
				return FALSE;
			}
		}

		if (pMenuBar != NULL)
		{
			pMenuBar->SetHot(this);
		}
	}

	if (m_pWndParent != NULL)
	{
		CRect rect = m_rect;

		const int nShadowSize = CMFCVisualManager::GetInstance()->GetMenuShadowDepth();

		rect.InflateRect(nShadowSize, nShadowSize);
		m_pWndParent->RedrawWindow(rect, NULL, RDW_FRAME | RDW_INVALIDATE);
	}

	return TRUE;
}

void CMFCToolBarMenuButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	if (pWndParent != NULL)
	{
		if (pWndParent->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
		{
			m_bDrawDownArrow = (m_nID != 0 && !m_listCommands.IsEmpty()) || ((CMFCMenuBar *)pWndParent)->GetForceDownArrows();
			m_bText = TRUE;
			m_bImage = FALSE;
		}
		else
		{
			m_bDrawDownArrow = (m_nID == 0 || !m_listCommands.IsEmpty());
		}

		if (pWndParent->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
		{
			m_bMenuMode = TRUE;
			m_bText = TRUE;
			m_bImage = FALSE;
			m_bDrawDownArrow = (m_nID == 0 || !m_listCommands.IsEmpty()) || HasButton();
		}
		else
		{
			m_bMenuMode = FALSE;
		}
	}
}

void CMFCToolBarMenuButton::CreateFromMenu(HMENU hMenu)
{
	while (!m_listCommands.IsEmpty())
	{
		delete m_listCommands.RemoveHead();
	}

	if (!::IsMenu(hMenu))
	{
		return;
	}

	CMenu* pMenu = CMenu::FromHandle(hMenu);
	if (pMenu == NULL)
	{
		return;
	}

	UINT uiDefaultCmd = ::GetMenuDefaultItem(hMenu, FALSE, GMDI_USEDISABLED);

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		CMFCToolBarMenuButton* pItem = STATIC_DOWNCAST(CMFCToolBarMenuButton, GetRuntimeClass()->CreateObject());
		ASSERT_VALID(pItem);

		pItem->m_nID = pMenu->GetMenuItemID(i);
		pMenu->GetMenuString(i, pItem->m_strText, MF_BYPOSITION);

		if (pItem->m_nID == -1) // Sub-menu...
		{
			if (g_pTearOffMenuManager != NULL)
			{
				pItem->SetTearOff(g_pTearOffMenuManager->Parse(pItem->m_strText));
			}

			CMenu* pSubMenu = pMenu->GetSubMenu(i);
			pItem->CreateFromMenu(pSubMenu->GetSafeHmenu());
		}
		else if (pItem->m_nID == uiDefaultCmd)
		{
			pItem->m_bDefault = TRUE;
		}

		UINT uiState = pMenu->GetMenuState(i, MF_BYPOSITION);

		if (uiState & MF_MENUBREAK)
		{
			pItem->m_nStyle |= AFX_TBBS_BREAK;
		}

		if ((uiState & MF_DISABLED) ||(uiState & MF_GRAYED))
		{
			pItem->m_nStyle |= TBBS_DISABLED;
		}

		m_listCommands.AddTail(pItem);
	}
}

HMENU CMFCToolBarMenuButton::CreateMenu() const
{
	if (m_listCommands.IsEmpty() && m_nID != (UINT) -1 && m_nID != 0 && !m_bMenuOnly)
	{
		return NULL;
	}

	CMenu menu;
	if (!menu.CreatePopupMenu())
	{
		TRACE(_T("CMFCToolBarMenuButton::CreateMenu(): Can't create popup menu!\n"));
		return NULL;
	}

	BOOL bRes = TRUE;
	DWORD dwLastError = 0;

	UINT uiDefaultCmd = (UINT) -1;

	int i = 0;
	for (POSITION pos = m_listCommands.GetHeadPosition(); pos != NULL; i ++)
	{
		CMFCToolBarMenuButton* pItem = (CMFCToolBarMenuButton*) m_listCommands.GetNext(pos);
		ENSURE(pItem != NULL);
		ASSERT_VALID(pItem);
		ASSERT_KINDOF(CMFCToolBarMenuButton, pItem);

		UINT uiStyle = MF_STRING;

		if (pItem->m_nStyle & AFX_TBBS_BREAK)
		{
			uiStyle |= MF_MENUBREAK;
		}

		if (pItem->m_nStyle & TBBS_DISABLED)
		{
			uiStyle |= MF_DISABLED;
		}


		if (pItem->IsTearOffMenu())
		{
			uiStyle |= MF_MENUBARBREAK;
		}

		switch(pItem->m_nID)
		{
		case 0: // Separator
			bRes = menu.AppendMenu(MF_SEPARATOR);
			if (!bRes)
			{
				dwLastError = GetLastError();
			}
			break;

		case -1: // Sub-menu
			{
				HMENU hSubMenu = pItem->CreateMenu();
				ENSURE(hSubMenu != NULL);

				CString strText = pItem->m_strText;
				if (pItem->m_uiTearOffBarID != 0 && g_pTearOffMenuManager != NULL)
				{
					g_pTearOffMenuManager->Build(pItem->m_uiTearOffBarID, strText);
				}

				bRes = menu.AppendMenu(uiStyle | MF_POPUP, (UINT_PTR) hSubMenu, strText);
				if (!bRes)
				{
					dwLastError = GetLastError();
				}
			}
			break;

		default:
			if (pItem->m_bDefault)
			{
				uiDefaultCmd = pItem->m_nID;
			}

			bRes = menu.AppendMenu(uiStyle, pItem->m_nID, pItem->m_strText);
			if (!bRes)
			{
				dwLastError = GetLastError();
			}
		}

		if (!bRes)
		{
			TRACE(_T("CMFCToolBarMenuButton::CreateMenu(): Can't add menu item: %d\n Last error = %x\n"), pItem->m_nID, dwLastError);
			return NULL;
		}
	}

	HMENU hMenu = menu.Detach();
	if (uiDefaultCmd != (UINT)-1)
	{
		::SetMenuDefaultItem(hMenu, uiDefaultCmd, FALSE);
	}

	return hMenu;
}

void CMFCToolBarMenuButton::DrawMenuItem(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages,
	BOOL bCustomizeMode, BOOL bHighlight, BOOL bGrayDisabledButtons, BOOL bContentOnly)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	if (m_nID == AFX_MENU_GROUP_ID)
	{
		COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawMenuLabel(pDC, rect);

		COLORREF clrTextOld = pDC->SetTextColor(clrText);

		CRect rectText = rect;
		rectText.DeflateRect(AFX_TEXT_MARGIN, 0);
		rectText.bottom -= 2;

		CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
		ASSERT_VALID(pOldFont);

		pDC->DrawText(m_strText, rectText, DT_SINGLELINE | DT_VCENTER);

		pDC->SetTextColor(clrTextOld);
		pDC->SelectObject(pOldFont);
		return;
	}

	BOOL bDisabled = (bCustomizeMode && !IsEditable()) || (!bCustomizeMode &&(m_nStyle & TBBS_DISABLED));

	CMFCToolBarImages* pLockedImages = NULL;
	CMFCToolBarImages* pUserImages = NULL;
	CAfxDrawState ds;

	CMFCPopupMenuBar* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);

	CSize sizeMenuImage = CMFCToolBar::GetMenuImageSize();

	if (pParentMenu != NULL)
	{
		if (pParentMenu->IsDropDownListMode())
		{
			CMFCDropDownListBox* pList = DYNAMIC_DOWNCAST(CMFCDropDownListBox, pParentMenu->GetParent());

			if (pList != NULL)
			{
				COLORREF clrText = CMFCVisualManager::GetInstance()->GetMenuItemTextColor(this, bHighlight, FALSE);

				if (bHighlight)
				{
					CMFCVisualManager::GetInstance()-> OnHighlightMenuItem(pDC, this, rect, clrText);
				}

				COLORREF clrTextOld = pDC->SetTextColor(clrText);

				pList->OnDrawItem(pDC, this, bHighlight);

				pDC->SetTextColor(clrTextOld);
				return;
			}
		}

		if (pParentMenu->m_pRelatedToolbar != NULL && pParentMenu->m_pRelatedToolbar->IsLocked())
		{
			pLockedImages = (CMFCToolBarImages*) pParentMenu->m_pRelatedToolbar->GetLockedMenuImages();

			if (pLockedImages != NULL)
			{
				CSize sizeDest(0, 0);

				if (sizeMenuImage != pParentMenu->GetCurrentMenuImageSize())
				{
					sizeDest = sizeMenuImage;
				}

				pLockedImages->PrepareDrawImage(ds, sizeDest);

				pImages = pLockedImages;
			}
		}
	}

	BOOL bDisableImage = afxCommandManager->IsMenuItemWithoutImage(m_nID);
	if (m_nID == ID_AFXBARRES_TASKPANE_BACK || m_nID == ID_AFXBARRES_TASKPANE_FORWARD)
	{
		bDisableImage = TRUE;
	}

	CUserTool* pUserTool = NULL;
	if (afxUserToolsManager != NULL && !m_bUserButton)
	{
		pUserTool = afxUserToolsManager->FindTool(m_nID);
	}

	HICON hDocIcon = CMFCTabCtrl::GetDocumentIcon(m_nID);

	CSize sizeImage = CMenuImages::Size();

	if (m_pPopupMenu != NULL && !m_bToBeClosed)
	{
		bHighlight = TRUE;
	}

	COLORREF clrText = CMFCVisualManager::GetInstance()->GetMenuItemTextColor(this, bHighlight, bDisabled);

	BOOL bDrawImageFrame = !CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem();

	if (bHighlight && !bContentOnly && CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem())
	{
		CMFCVisualManager::GetInstance()->OnHighlightMenuItem(pDC, this, rect, clrText);
		bDrawImageFrame = FALSE;
	}

	if ((m_nStyle & TBBS_CHECKED) && !CMFCVisualManager::GetInstance()->IsOwnerDrawMenuCheck())
	{
		bDrawImageFrame = TRUE;
	}

	CFont* pOldFont = NULL;

	if (m_nID != 0 && m_nID != (UINT) -1 && !m_bMenuOnly && pParentMenu != NULL && pParentMenu->GetDefaultMenuId() == m_nID)
	{
		pOldFont = (CFont*) pDC->SelectObject(&afxGlobalData.fontBold);
	}

	CRect rectImage;
	rectImage = rect;
	rectImage.left += CMFCVisualManager::GetInstance()->GetMenuImageMargin();
	rectImage.right = rectImage.left + sizeMenuImage.cx + CMFCVisualManager::GetInstance()->GetMenuImageMargin();

	CRect rectFrameBtn = rectImage;

	if (CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem())
	{
		rectFrameBtn = rect;

		CRect rectOffset = CMFCVisualManager::GetInstance ()->GetMenuImageFrameOffset();

		rectFrameBtn.left += rectOffset.left;
		rectFrameBtn.top += rectOffset.top;
		rectFrameBtn.bottom -= rectOffset.bottom;
		rectFrameBtn.right = rectImage.right;
	}
	else
	{
		rectFrameBtn.InflateRect(1, -1);
	}

	BOOL bIsRarelyUsed = (CMFCMenuBar::IsRecentlyUsedMenus() && CMFCToolBar::IsCommandRarelyUsed(m_nID));

	if (bIsRarelyUsed)
	{
		bIsRarelyUsed = FALSE;

		CMFCPopupMenuBar* pParentMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);

		if (pParentMenuBar != NULL)
		{
			CMFCPopupMenu* pParentMenuCurr = DYNAMIC_DOWNCAST(CMFCPopupMenu, pParentMenuBar->GetParent());
			if (pParentMenuCurr != NULL && pParentMenuCurr->HideRarelyUsedCommands())
			{
				bIsRarelyUsed = TRUE;
			}
		}
	}

	BOOL bLightImage = FALSE;
	BOOL bFadeImage = !bHighlight && CMFCVisualManager::GetInstance()->IsFadeInactiveImage();

	if (bIsRarelyUsed)
	{
		bLightImage = TRUE;
		if (bHighlight &&(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			bLightImage = FALSE;
		}

		if (GetImage() < 0 && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			bLightImage = FALSE;
		}
	}
	else if (m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE))
	{
		bLightImage = !bHighlight;
	}

	//----------------
	// Draw the image:
	//----------------
	if (!IsDrawImage() && hDocIcon == NULL) // Try to find a matched image
	{
		BOOL bImageSave = m_bImage;
		BOOL bUserButton = m_bUserButton;
		BOOL bSuccess = TRUE;

		m_bImage = TRUE; // Always try to draw image!
		m_bUserButton = TRUE;

		if (GetImage() < 0)
		{
			m_bUserButton = FALSE;

			if (GetImage() < 0)
			{
				bSuccess = FALSE;
			}
		}

		if (!bSuccess)
		{
			m_bImage = bImageSave;
			m_bUserButton = bUserButton;
		}

		if (m_bUserButton && pImages != CMFCToolBar::GetUserImages())
		{
			pUserImages = CMFCToolBar::GetUserImages();

			if (pUserImages != NULL)
			{
				ASSERT_VALID(pUserImages);

				pUserImages->PrepareDrawImage(ds);
				pImages = pUserImages;
			}
		}
	}

	BOOL bImageIsReady = FALSE;

	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect(&rectImage);

	if (bDrawImageFrame && !bContentOnly)
	{
		FillInterior(pDC, rectFrameBtn, bHighlight, TRUE);
	}

	if (!bDisableImage &&(IsDrawImage() && pImages != NULL) || hDocIcon != NULL)
	{
		BOOL bDrawImageShadow = bHighlight && !bCustomizeMode && CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() &&
			!afxGlobalData.IsHighContrastMode() && ((m_nStyle & TBBS_CHECKED) == 0) && ((m_nStyle & TBBS_DISABLED) == 0);

		pDC->SelectObject(&rgnClip);

		CPoint ptImageOffset((rectImage.Width() - sizeMenuImage.cx) / 2, (rectImage.Height() - sizeMenuImage.cy) / 2);

		if ((m_nStyle & TBBS_PRESSED) || !(m_nStyle & TBBS_DISABLED) || !bGrayDisabledButtons || bCustomizeMode)
		{
			CRect rectIcon(CPoint(rectImage.left + ptImageOffset.x, rectImage.top + ptImageOffset.y), sizeMenuImage);

			if (hDocIcon != NULL)
			{
				DrawDocumentIcon(pDC, rectIcon, hDocIcon);
			}
			else if (pUserTool != NULL)
			{
				pUserTool->DrawToolIcon(pDC, rectIcon);
			}
			else
			{
				CPoint pt = rectImage.TopLeft();
				pt += ptImageOffset;

				if (afxGlobalData.GetRibbonImageScale() != 1. && CMFCToolBar::m_bDontScaleImages)
				{
					pt.x += max (0, (rectImage.Width() - pImages->GetImageSize().cx) / 2);
					pt.y += max (0, (rectImage.Width() - pImages->GetImageSize().cy) / 2);
				}

				if (bDrawImageShadow)
				{
					pt.Offset(1, 1);

					pImages->Draw(pDC, pt.x, pt.y, GetImage(), FALSE, FALSE, FALSE, TRUE);

					pt.Offset(-2, -2);
				}

				pImages->Draw(pDC, pt.x, pt.y, GetImage(), FALSE, bDisabled && bGrayDisabledButtons, FALSE, FALSE, bFadeImage);
			}

			bImageIsReady = TRUE;
		}

		if (!bImageIsReady)
		{
			CRect rectIcon(CPoint(rectImage.left + ptImageOffset.x, rectImage.top + ptImageOffset.y), sizeMenuImage);

			if (hDocIcon != NULL)
			{
				DrawDocumentIcon(pDC, rectIcon, hDocIcon);
			}
			else if (pUserTool != NULL)
			{
				pUserTool->DrawToolIcon(pDC, rectIcon);
			}
			else
			{
				if (bDrawImageShadow)
				{
					rectImage.OffsetRect(1, 1);
					pImages->Draw(pDC, rectImage.left + ptImageOffset.x, rectImage.top + ptImageOffset.y, GetImage(), FALSE, FALSE, FALSE, TRUE);

					rectImage.OffsetRect(-2, -2);
				}

				pImages->Draw(pDC, rectImage.left + ptImageOffset.x, rectImage.top + ptImageOffset.y, GetImage(), FALSE, bDisabled && bGrayDisabledButtons, FALSE, FALSE, bFadeImage);
			}

			bImageIsReady = TRUE;
		}
	}

	if (m_bAlwaysCallOwnerDraw || !bImageIsReady)
	{
		CFrameWnd* pParentFrame = m_pWndParent == NULL ? DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd()) : AFXGetTopLevelFrame(m_pWndParent);

		//------------------------------------
		// Get chance to user draw menu image:
		//------------------------------------
		CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pParentFrame);
		if (pMainFrame != NULL)
		{
			bImageIsReady = pMainFrame->OnDrawMenuImage(pDC, this, rectImage);
		}
		else // Maybe, SDI frame...
		{
			CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pParentFrame);
			if (pFrame != NULL)
			{
				bImageIsReady = pFrame->OnDrawMenuImage(pDC, this, rectImage);
			}
			else // Maybe, OLE frame...
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pParentFrame);
				if (pOleFrame != NULL)
				{
					bImageIsReady = pOleFrame->OnDrawMenuImage(pDC, this, rectImage);
				}
				else
				{
					COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pParentFrame);
					if (pOleDocFrame != NULL)
					{
						bImageIsReady = pOleDocFrame->OnDrawMenuImage(pDC, this, rectImage);
					}
				}
			}
		}
	}

	pDC->SelectClipRgn(NULL);

	if (m_nStyle & TBBS_CHECKED)
	{
		if (bDrawImageFrame)
		{
			UINT nStyleSaved = m_nStyle;

			if (bHighlight && CMFCVisualManager::GetInstance()->IsFrameMenuCheckedItems())
			{
				m_nStyle |= TBBS_MARKED;
			}

			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectFrameBtn, CMFCVisualManager::ButtonsIsPressed);

			m_nStyle = nStyleSaved;
		}

		if (!bImageIsReady)
		{
			CMFCVisualManager::GetInstance()->OnDrawMenuCheck(pDC, this, rectFrameBtn, bHighlight, m_bIsRadio);
		}
	}
	else if (!bContentOnly && bImageIsReady && bHighlight && bDrawImageFrame)
	{
		CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectFrameBtn, CMFCVisualManager::ButtonsIsHighlighted);
	}

	rectImage.InflateRect(1, 0);
	int iSystemImageId = -1;

	//-------------------------------
	// Try to draw system menu icons:
	//-------------------------------
	if (!bImageIsReady)
	{
		switch(m_nID)
		{
		case SC_MINIMIZE:
			iSystemImageId = CMenuImages::IdMinimize;
			break;

		case SC_RESTORE:
			iSystemImageId = CMenuImages::IdRestore;
			break;

		case SC_CLOSE:
			iSystemImageId = CMenuImages::IdClose;
			break;

		case SC_MAXIMIZE:
			iSystemImageId = CMenuImages::IdMaximize;
			break;
		}

		if (iSystemImageId != -1)
		{
			CRect rectSysImage = rectImage;
			rectSysImage.DeflateRect(CMFCVisualManager::GetInstance()->GetMenuImageMargin(), CMFCVisualManager::GetInstance()->GetMenuImageMargin());

			if (!bContentOnly && bDrawImageFrame)
			{
				FillInterior(pDC, rectFrameBtn, bHighlight, TRUE);
			}

			CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iSystemImageId, rectSysImage, bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);

			if (bHighlight && !bContentOnly && bDrawImageFrame)
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectFrameBtn, CMFCVisualManager::ButtonsIsHighlighted);
			}
		}
	}

	//-------------------------------
	// Fill text area if highlighted:
	//-------------------------------
	CRect rectText = rect;
	rectText.left = rectFrameBtn.right + CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 2;

	if (bHighlight)
	{
		if (!CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem())
		{
			CRect rectFill = rectFrameBtn;

			if ((m_nStyle &(TBBS_CHECKED) || bImageIsReady) || iSystemImageId != -1)
			{
				rectFill.left = rectText.left - 1;
			}

			rectFill.right = rect.right - 1;

			if (!bContentOnly)
			{
				CMFCVisualManager::GetInstance()->OnHighlightMenuItem(pDC, this, rectFill, clrText);
			}
			else
			{
				clrText = CMFCVisualManager::GetInstance()->GetHighlightedMenuItemTextColor(this);
			}
		}
		else if (bContentOnly)
		{
			clrText = CMFCVisualManager::GetInstance()->GetHighlightedMenuItemTextColor(this);
		}
	}

	//-------------------------
	// Find acceleration label:
	//-------------------------
	CString strText = m_strText;
	CString strAccel;

	int iTabOffset = m_strText.Find(_T('\t'));
	if (iTabOffset >= 0)
	{
		strText = strText.Left(iTabOffset);
		strAccel = m_strText.Mid(iTabOffset + 1);
	}

	//-----------
	// Draw text:
	//-----------
	COLORREF clrTextOld = pDC->GetTextColor();

	rectText.left += AFX_TEXT_MARGIN;

	if (!m_bWholeText)
	{
		CString strEllipses(_T("..."));
		while (strText.GetLength() > 0 && pDC->GetTextExtent(strText + strEllipses).cx > rectText.Width())
		{
			strText = strText.Left(strText.GetLength() - 1);
		}

		strText += strEllipses;
	}

	if (!afxGlobalData.m_bUnderlineKeyboardShortcuts && !CMFCToolBar::IsCustomizeMode())
	{
		strText.Replace(_T("&&"), strDummyAmpSeq);
		strText.Remove(_T('&'));
		strText.Replace(strDummyAmpSeq, _T("&&"));
	}

	if (bDisabled && !bHighlight && CMFCVisualManager::GetInstance()->IsEmbossDisabledImage())
	{
		pDC->SetTextColor(afxGlobalData.clrBtnHilite);

		CRect rectShft = rectText;
		rectShft.OffsetRect(1, 1);
		pDC->DrawText(strText, &rectShft, DT_SINGLELINE | DT_VCENTER);
	}

	pDC->SetTextColor(clrText);
	pDC->DrawText(strText, &rectText, DT_SINGLELINE | DT_VCENTER);

	//------------------------
	// Draw accelerator label:
	//------------------------
	if (!strAccel.IsEmpty())
	{
		CRect rectAccel = rectText;
		rectAccel.right -= AFX_TEXT_MARGIN + sizeImage.cx;

		if (bDisabled && !bHighlight && CMFCVisualManager::GetInstance()->IsEmbossDisabledImage())
		{
			pDC->SetTextColor(afxGlobalData.clrBtnHilite);

			CRect rectAccelShft = rectAccel;
			rectAccelShft.OffsetRect(1, 1);
			pDC->DrawText(strAccel, &rectAccelShft, DT_SINGLELINE | DT_RIGHT | DT_VCENTER);
		}

		pDC->SetTextColor(clrText);
		pDC->DrawText(strAccel, &rectAccel, DT_SINGLELINE | DT_RIGHT | DT_VCENTER);
	}

	//--------------------------------------------
	// Draw triangle image for the cascade menues:
	//--------------------------------------------
	if (m_nID == (UINT) -1 || m_bDrawDownArrow || m_bMenuOnly)
	{
		CFont* pRegFont = pDC->SelectObject(&afxGlobalData.fontMarlett);
		ENSURE(pRegFont != NULL);

		CRect rectTriangle = rect;

		CString strTriangle = (m_pWndParent->GetExStyle() & WS_EX_LAYOUTRTL) ? _T("3") : _T("4"); // Marlett's right arrow

		if (m_bQuickCustomMode)
		{
			strTriangle = _T("6");  	// Marlett's down arrow
		}

		if (HasButton())
		{
			m_rectButton = rect;

			m_rectButton.left = m_rectButton.right - pDC->GetTextExtent(strTriangle).cx;

			CMFCVisualManager::GetInstance()->OnDrawMenuItemButton(pDC, this, m_rectButton, bHighlight, bDisabled);
		}

		pDC->DrawText(strTriangle, &rectTriangle, DT_SINGLELINE | DT_RIGHT | DT_VCENTER);

		pDC->SelectObject(pRegFont);
	}

	if (pOldFont != NULL)
	{
		pDC->SelectObject(pOldFont);
	}

	pDC->SetTextColor(clrTextOld);

	if (pLockedImages != NULL)
	{
		pLockedImages->EndDrawImage(ds);
	}

	if (pUserImages != NULL)
	{
		ASSERT_VALID(pUserImages);
		pUserImages->EndDrawImage(ds);
	}
}

void CMFCToolBarMenuButton::OnCancelMode()
{
	if (m_pPopupMenu != NULL && ::IsWindow(m_pPopupMenu->m_hWnd))
	{
		if (m_pPopupMenu->InCommand())
		{
			return;
		}

		for (int i = 0; i < m_pPopupMenu->GetMenuItemCount(); i++)
		{
			CMFCToolBarMenuButton* pSubItem = m_pPopupMenu->GetMenuItem(i);
			if (pSubItem != NULL)
			{
				pSubItem->OnCancelMode();
			}
		}

		m_pPopupMenu->SaveState();
		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->CloseMenu();
	}

	m_pPopupMenu = NULL;

	if (m_pWndParent != NULL && ::IsWindow(m_pWndParent->m_hWnd))
	{
		CRect rect = m_rect;

		const int nShadowSize = CMFCVisualManager::GetInstance()->GetMenuShadowDepth();

		rect.InflateRect(nShadowSize, nShadowSize);

		m_pWndParent->InvalidateRect(rect);
		m_pWndParent->UpdateWindow();
	}

	m_bToBeClosed = FALSE;
}

BOOL CMFCToolBarMenuButton::OpenPopupMenu(CWnd* pWnd)
{
	if (m_pPopupMenu != NULL)
	{
		return FALSE;
	}

	if (pWnd == NULL)
	{
		pWnd = m_pWndParent;
	}

	ENSURE(pWnd != NULL);

	HMENU hMenu = CreateMenu();
	if (hMenu == NULL && !IsEmptyMenuAllowed())
	{
		return FALSE;
	}

	m_pPopupMenu = CreatePopupMenu();

	if (m_pPopupMenu == NULL)
	{
		::DestroyMenu(hMenu);
		return FALSE;
	}

	if (m_pPopupMenu->GetMenuItemCount() > 0 && hMenu != NULL)
	{
		::DestroyMenu(hMenu);
		hMenu = NULL;
	}

	//---------------------------------------------------------------
	// Define a new menu position. Place the menu in the right side
	// of the current menu in the poup menu case or under the current
	// item by default:
	//---------------------------------------------------------------
	CPoint point;
	CMFCPopupMenu::DROP_DIRECTION dropDir = CMFCPopupMenu::DROP_DIRECTION_NONE;

	CMFCPopupMenuBar* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);
	CMFCMenuBar* pParentMenuBar = DYNAMIC_DOWNCAST(CMFCMenuBar, m_pWndParent);

	if (pParentMenu != NULL)
	{
		point = CPoint(0, m_rect.top - 2);
		pWnd->ClientToScreen(&point);

		CRect rectParent;
		pParentMenu->GetWindowRect(rectParent);

		int nMenuGap = CMFCVisualManager::GetInstance()->GetPopupMenuGap();

		if (pParentMenu->GetExStyle() & WS_EX_LAYOUTRTL)
		{
			point.x = rectParent.left - nMenuGap;
			dropDir = CMFCPopupMenu::DROP_DIRECTION_LEFT;
		}
		else
		{
			point.x = rectParent.right + nMenuGap;
			dropDir = CMFCPopupMenu::DROP_DIRECTION_RIGHT;
		}
	}
	else if (pParentMenuBar != NULL && (pParentMenuBar->IsHorizontal()) == 0)
	{
		//------------------------------------------------
		// Parent menu bar is docked vertical, place menu
		// in the left or right side of the parent frame:
		//------------------------------------------------
		point = CPoint(m_rect.right, m_rect.top);
		pWnd->ClientToScreen(&point);

		dropDir = CMFCPopupMenu::DROP_DIRECTION_RIGHT;
	}
	else
	{
		if (m_bShowAtRightSide)
		{
			point = CPoint(m_rect.right - 1, m_rect.top);
		}
		else
		{
			if (m_pPopupMenu->IsRightAlign())
			{
				point = CPoint(m_rect.right - 1, m_rect.bottom - 1);
			}
			else
			{
				point = CPoint(m_rect.left, m_rect.bottom - 1);
			}
		}

		dropDir = CMFCPopupMenu::DROP_DIRECTION_BOTTOM;
		pWnd->ClientToScreen(&point);
	}

	m_pPopupMenu->m_pParentBtn = this;
	m_pPopupMenu->m_DropDirection = dropDir;

	if (!m_pPopupMenu->Create(pWnd, point.x, point.y, hMenu))
	{
		m_pPopupMenu = NULL;
		return FALSE;
	}

	OnAfterCreatePopupMenu();

	if (m_pWndMessage != NULL)
	{
		ASSERT_VALID(m_pWndMessage);
		m_pPopupMenu->SetMessageWnd(m_pWndMessage);
	}
	else
	{
		// If parent menu has a message window, the child should have the same
		CMFCPopupMenu* pCallerMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pWnd->GetParent());
		if (pCallerMenu != NULL && pCallerMenu->GetMessageWnd() != NULL)
		{
			m_pPopupMenu->SetMessageWnd(pCallerMenu->GetMessageWnd());
		}
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarMenuButton diagnostics

#ifdef _DEBUG
void CMFCToolBarMenuButton::AssertValid() const
{
	CObject::AssertValid();
}

void CMFCToolBarMenuButton::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	CString strId;
	strId.Format(_T("%x"), m_nID);

	dc << "[" << m_strText << " >>>>> ]";
	dc.SetDepth(dc.GetDepth() + 1);

	dc << "{\n";
	for (POSITION pos = m_listCommands.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_listCommands.GetNext(pos);
		ASSERT_VALID(pButton);

		pButton->Dump(dc);
		dc << "\n";
	}

	dc << "}\n";
	dc.SetDepth(dc.GetDepth() - 1);
	dc << "\n";
}

#endif


int CMFCToolBarMenuButton::OnDrawOnCustomizeList(
	CDC* pDC, const CRect& rect, BOOL bSelected)
{
	CMFCToolBarButton::OnDrawOnCustomizeList(pDC, rect, bSelected);

	if (m_nID == 0 || !m_listCommands.IsEmpty() || HasButton()) // Popup menu
	{
		CMFCVisualManager::GetInstance()->OnDrawMenuArrowOnCustomizeList(pDC, rect, bSelected);
	}

	return rect.Width();
}

BOOL CMFCToolBarMenuButton::OnBeforeDrag() const
{
	if (m_pPopupMenu != NULL) // Is dropped down
	{
		m_pPopupMenu->CollapseSubmenus();
		m_pPopupMenu->SendMessage(WM_CLOSE);
	}

	return CMFCToolBarButton::OnBeforeDrag();
}

void __stdcall CMFCToolBarMenuButton::GetTextHorzOffsets(int& xOffsetLeft, int& xOffsetRight)
{
	xOffsetLeft = CMFCToolBar::GetMenuImageSize().cx / 2 + AFX_TEXT_MARGIN;
	xOffsetRight = CMenuImages::Size().cx;
}

void CMFCToolBarMenuButton::SaveBarState()
{
	if (m_pWndParent == NULL)
	{
		return;
	}

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, m_pWndParent->GetParent());
	if (pParentMenu == NULL)
	{
		return;
	}

	ASSERT_VALID(pParentMenu);

	CMFCPopupMenu* pTopLevelMenu = pParentMenu;
	while ((pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pParentMenu->GetParent())) != NULL)
	{
		pTopLevelMenu = pParentMenu;
	}

	ASSERT_VALID(pTopLevelMenu);
	pTopLevelMenu->SaveState();
}

void CMFCToolBarMenuButton::GetImageRect(CRect& rectImage)
{
	ASSERT_VALID(this);

	rectImage = m_rect;
	rectImage.left += CMFCVisualManager::GetInstance()->GetMenuImageMargin();

	rectImage.right = rectImage.left + CMFCToolBar::GetMenuImageSize().cx + CMFCVisualManager::GetInstance()->GetMenuImageMargin();
}

void CMFCToolBarMenuButton::SetTearOff(UINT uiBarID)
{
	if (m_uiTearOffBarID == uiBarID)
	{
		return;
	}

	if (g_pTearOffMenuManager != NULL)
	{
		if (m_uiTearOffBarID != 0)
		{
			g_pTearOffMenuManager->SetInUse(m_uiTearOffBarID, FALSE);
		}

		if (uiBarID != 0)
		{
			g_pTearOffMenuManager->SetInUse(uiBarID);
		}
	}

	m_uiTearOffBarID = uiBarID;
}

void CMFCToolBarMenuButton::SetMenuPaletteMode(BOOL bMenuPaletteMode/* = TRUE*/, int nPaletteRows/* = 1*/)
{
	ASSERT_VALID(this);
	ASSERT(!IsDroppedDown());

	m_bMenuPaletteMode = bMenuPaletteMode;
	m_nPaletteRows = nPaletteRows;
}

void CMFCToolBarMenuButton::SetRadio()
{
	m_bIsRadio = TRUE;

	if (m_pWndParent != NULL)
	{
		CRect rectImage;
		GetImageRect(rectImage);

		m_pWndParent->InvalidateRect(rectImage);
		m_pWndParent->UpdateWindow();
	}
}

void CMFCToolBarMenuButton::ResetImageToDefault()
{
	ASSERT_VALID(this);

	CMFCToolBarButton::ResetImageToDefault();

	for (POSITION pos = m_listCommands.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarMenuButton* pItem = (CMFCToolBarMenuButton*) m_listCommands.GetNext(pos);
		ASSERT_VALID(pItem);

		pItem->ResetImageToDefault();
	}
}

BOOL CMFCToolBarMenuButton::CompareWith(const CMFCToolBarButton& other) const
{
	if (m_nID != other.m_nID)
	{
		return FALSE;
	}

	const CMFCToolBarMenuButton& otherMenuBtn = (const CMFCToolBarMenuButton&) other;

	if (m_listCommands.GetCount() != otherMenuBtn.m_listCommands.GetCount())
	{
		return FALSE;
	}

	POSITION pos1 = otherMenuBtn.m_listCommands.GetHeadPosition();

	for (POSITION pos = m_listCommands.GetHeadPosition(); pos != NULL;)
	{
		ENSURE(pos1 != NULL);

		CMFCToolBarMenuButton* pItem = (CMFCToolBarMenuButton*) m_listCommands.GetNext(pos);
		ASSERT_VALID(pItem);

		CMFCToolBarMenuButton* pItem1 = (CMFCToolBarMenuButton*) otherMenuBtn.m_listCommands.GetNext(pos1);
		ASSERT_VALID(pItem1);

		if (!pItem->CompareWith(*pItem1))
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CMFCToolBarMenuButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	if (!CMFCToolBarButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	data.m_nAccRole = ROLE_SYSTEM_MENUITEM;
	data.m_bAccState = STATE_SYSTEM_FOCUSED | STATE_SYSTEM_FOCUSABLE;

	if (m_nStyle & TBBS_CHECKED)
	{
		data.m_bAccState |= STATE_SYSTEM_CHECKED;
	}

	if (m_nStyle & TBBS_DISABLED)
	{
		data.m_bAccState |= STATE_SYSTEM_UNAVAILABLE;
	}

	data.m_strAccHelp = L"CMFCToolBarMenuButton";
	data.m_strAccDefAction = m_bMenuMode ? _T("Execute") : _T("Open");

	return TRUE;
}

void CMFCToolBarMenuButton::DrawDocumentIcon(CDC* pDC, const CRect& rectImage, HICON hIcon)
{
	ASSERT_VALID(pDC);

	int cx = afxGlobalData.m_sizeSmallIcon.cx;
	int cy = afxGlobalData.m_sizeSmallIcon.cy;

	if (cx > rectImage.Width() ||
		cy > rectImage.Height())
	{
		// Small icon is too large, stretch it
		cx = rectImage.Width();
		cy = rectImage.Height();
	}

	int x = max(0, (rectImage.Width() - cx) / 2);
	int y = max(0, (rectImage.Height() - cy) / 2);

	::DrawIconEx(pDC->GetSafeHdc(), rectImage.left + x, rectImage.top + y, hIcon, cx, cy, 0, NULL, DI_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarimages.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <math.h>
#include "afxglobals.h"
#include "afxtoolbarimages.h"
#include "afxtoolbar.h"
#include "afxribbonres.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static BOOL __stdcall WriteDIB( LPCTSTR szFile, HANDLE hDIB);
static HANDLE __stdcall DDBToDIB(HBITMAP bitmap, DWORD dwCompression);

BOOL CMFCToolBarImages::m_bDisableTrueColorAlpha = TRUE;
CCriticalSection CMFCToolBarImages::m_CriticalSection;
BOOL CMFCToolBarImages::m_bMultiThreaded = FALSE;
BOOL CMFCToolBarImages::m_bIsDrawOnGlass = FALSE;
BYTE CMFCToolBarImages::m_nDisabledImageAlpha = 127;
BYTE CMFCToolBarImages::m_nFadedImageAlpha = 150;
BOOL CMFCToolBarImages::m_bIsRTL = FALSE;
CString CMFCToolBarImages::m_strPngResType = _T("PNG");

// globals for fast drawing(shared globals)
static HDC hDCGlyphs = NULL;
static HDC hDCMono = NULL;

/*
DIBs use RGBQUAD format:
0xbb 0xgg 0xrr 0x00

Reasonably efficient code to convert a COLORREF into an
RGBQUAD is byte-order-dependent, so we need different
code depending on the byte order we're targeting.
*/

#define AFX_RGB_TO_RGBQUAD(r,g,b)(RGB(b,g,r))
#define AFX_CLR_TO_RGBQUAD(clr)(RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))
#define AFX_RGBQUAD_TO_CLR(clr)(RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))

// Raster Ops
#define AFX_ROP_DSPDxax  0x00E20746L
#define AFX_ROP_PSDPxax  0x00B8074AL

// Internal images:
#define AFX_IMAGE_LIGHT  0
#define AFX_IMAGE_SHADOW 1

#ifndef M_PI
#define M_PI       3.14159265358979323846
#endif

static inline double clamp(double value, double low, double high)
{
	return value < low ? low : (value > high ? high : value);
}

static inline double clamp_to_byte(double value)
{
	return clamp(value, 0.0, 255.0);
}

class CMFCZoomKernel
{
public:
	typedef double XFilterProc(double dValue);
	typedef XFilterProc* XLPFilterProc;

	struct XKernel
	{
		long   pixel;
		double weight;
	};

	struct XKernelList
	{
		DWORD         count;
		XKernel* stat;
	};

	enum XZoomType
	{
		e_ZoomTypeFirst     = 0,
		e_ZoomTypeStretch   = e_ZoomTypeFirst,
		e_ZoomTypeFitImage  = 1,
		e_ZoomTypeFitWidth  = 2,
		e_ZoomTypeFitHeight = 3,
		e_ZoomTypeLast      = e_ZoomTypeFitHeight
	};

	enum XFilterType
	{
		e_FilterTypeFirst    = 0,
		e_FilterTypeBox      = e_FilterTypeFirst,
		e_FilterTypeBilinear = 1,
		e_FilterTypeBicubic  = 2,
		e_FilterTypeBell     = 3,
		e_FilterTypeBSpline  = 4,
		e_FilterTypeLanczos3 = 5,
		e_FilterTypeMitchell = 6,
		e_FilterTypeLast     = e_FilterTypeMitchell
	};

public:
	CMFCZoomKernel();
	virtual ~CMFCZoomKernel();

	void Create(long sizeSrc, long sizeDst, long originSrc, long widthSrc, XFilterType ft);
	void Create(long sizeSrc, long sizeDst, XFilterType ft);
	void Empty();

	inline  XKernelList& operator [](long index);
	inline  const XKernelList& operator [](long index) const;

	static  double          FilterWidth(XFilterType ft);
	static  XLPFilterProc   FilterProc(XFilterType ft);
	static  double          Filter(XFilterType ft, double value);

	static  void            CorrectZoomSize(const CSize& sizeSrc, CSize& sizeDst, XZoomType zt);

private:
	DWORD        m_Size;
	XKernelList* m_List;
};

void CMFCZoomKernel::CorrectZoomSize(const CSize& sizeSrc, CSize& sizeDst, XZoomType zt)
{
	double ZoomX = (double)sizeDst.cx / (double)sizeSrc.cx;
	double ZoomY = (double)sizeDst.cy / (double)sizeSrc.cy;

	if(zt != e_ZoomTypeStretch)
	{
		switch(zt)
		{
		case e_ZoomTypeFitWidth:
			ZoomY = ZoomX;
			break;
		case e_ZoomTypeFitHeight:
			ZoomX = ZoomY;
			break;
		case e_ZoomTypeFitImage:
			ZoomX = min(ZoomX, ZoomY);
			ZoomY = ZoomX;
			break;
		}

		sizeDst.cx = (long)(sizeSrc.cx * ZoomX);
		sizeDst.cy = (long)(sizeSrc.cy * ZoomY);
	}
}

inline double SinC(double dValue)
{
	if (dValue != 0.0)
	{
		dValue *= M_PI;
		return sin (dValue) / dValue;
	}

	return 1.0;
}

inline double Filter_Box(double dValue)
{
	if ((dValue > -0.5) && (dValue <= 0.5))
	{
		return 1.0;
	}

	return 0.0;
}

// Bilinear filter
// a.k.a. "Linear" or "Triangle" filter
inline double Filter_Bilinear(double dValue)
{
	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	if (dValue < 1.0)
	{
		return 1.0 - dValue;
	}

	return 0.0;
}

inline double Filter_Bicubic(double dValue)
{
	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	if (dValue < 1.0)
	{
		return (2.0 * dValue - 3.0) * dValue * dValue + 1.0;
	}

	return 0.0;
}

// Bell filter
inline double Filter_Bell(double dValue)
{
	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	if (dValue < 0.5)
	{
		return 0.75 - dValue * dValue;
	}
	else
	{
		if (dValue < 1.5)
		{
			dValue = dValue - 1.5;
			return 0.5 * dValue * dValue;
		}
	}

	return 0.0;
}

inline double Filter_BSpline(double dValue)
{
	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	if (dValue < 1.0)
	{
		double tt = dValue * dValue;
		return 0.5 * tt * dValue - tt + 2.0 / 3.0;
	}
	else
	{
		if (dValue < 2.0)
		{
			dValue = 2.0 - dValue;
			return dValue * dValue * dValue / 6.0;
		}
	}

	return 0.0;
}

inline double Filter_Lanczos3(double dValue)
{
	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	if (dValue < 3.0)
	{
		return SinC(dValue) * SinC(dValue / 3.0);
	}

	return 0.0;
}

inline double Filter_Mitchell(double dValue)
{
	static double B = 1.0 / 3.0;
	static double C = B;

	if (dValue < 0.0)
	{
		dValue = -dValue;
	}

	const double tt = dValue * dValue;
	if (dValue < 1.0)
	{
		return ((12.0 - 9.0 * B - 6.0 * C) * (dValue * tt) + 
			(-18.0 + 12.0 * B + 6.0 * C) * tt + 
			(6.0 - 2.0 * B)) / 6.0;
	}
	else
	{
		if (dValue < 2.0)
		{
			return ((-1.0 * B - 6.0 * C) *(dValue * tt) +
				(6.0 * B + 30.0 * C) * tt + 
				(-12.0 * B - 48.0 * C) * dValue +
				(8.0 * B + 24.0 * C)) / 6.0;
		}
	}

	return 0.0;
}

struct CMFCImageResizeFilter
{
	CMFCZoomKernel::XLPFilterProc Proc;
	double        Width;
};

static CMFCImageResizeFilter Filters[7] =
{
	{ &Filter_Box     , 0.5},
	{ &Filter_Bilinear, 1.0},
	{ &Filter_Bicubic , 1.0},
	{ &Filter_Bell    , 1.5},
	{ &Filter_BSpline , 2.0},
	{ &Filter_Lanczos3, 3.0},
	{ &Filter_Mitchell, 2.0}
};

CMFCZoomKernel::XLPFilterProc CMFCZoomKernel::FilterProc(CMFCZoomKernel::XFilterType ft)
{
	return Filters[ft].Proc;
}

double CMFCZoomKernel::FilterWidth(CMFCZoomKernel::XFilterType ft)
{
	return Filters[ft].Width;
}

double CMFCZoomKernel::Filter(CMFCZoomKernel::XFilterType ft, double value)
{
	return Filters[ft].Proc(value);
}

CMFCZoomKernel::CMFCZoomKernel(): m_Size(0), m_List(NULL)
{
}

CMFCZoomKernel::~CMFCZoomKernel()
{
	Empty();
}

void CMFCZoomKernel::Create(long sizeSrc, long sizeDst, long originSrc, long widthSrc, XFilterType ft)
{
	if(sizeSrc <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	if(sizeDst <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	Empty();

	m_Size = sizeDst;
	const double dScale = (double)(m_Size) / (double)(sizeSrc);

	const XLPFilterProc lpFilterProc = Filters[ft].Proc;
	const double dFilterWidth        = Filters[ft].Width;

	m_List = new XKernelList[m_Size];

	double width = dFilterWidth;
	double scale = 1.0;
	double correction = -0.25;
	if (dScale < 1.0)
	{
		width /= dScale;
		scale = dScale;
		correction = -correction;
	}

	for (DWORD i = 0; i < m_Size; i++)
	{
		double center = i / dScale;

		long left  = (long)floor(center - width);
		long right = (long)ceil(center + width);

		const long c_Count = right - left + 1;

		m_List[i].count = 0;

		if (c_Count == 0)
		{
			continue;
		}

		m_List[i].stat  = new XKernel[c_Count];

		bool bCross = false;
		DWORD index = 0;
		double weightSum = 0.0;

		XKernel* pStat = m_List[i].stat;

		bool bFirst = true;
		for(long j = left; j <= right; j++)
		{
			double weight = lpFilterProc((center - (double)j + correction) * scale) * scale;
			if(weight == 0.0)
			{
				if (!bFirst)
				{
					break;
				}

				continue;
			}

			bFirst = false;

			long pixel = j + originSrc;
			if (pixel < 0)
			{
				pixel = -pixel;
				bCross = true;
			}
			else if (pixel >= widthSrc)
			{
				pixel = 2 * widthSrc - pixel - 1;
				bCross = true;
			}

			bool bFound = false;
			if(bCross)
			{
				for(DWORD k = 0; k < index; k++)
				{
					if(pStat[k].pixel == pixel)
					{
						pStat[k].weight += weight;
						bFound = true;
						break;
					}
				}
			}

			if(!bFound)
			{
				pStat[index].pixel  = pixel;
				pStat[index].weight = weight;
				index++;
				m_List[i].count = index;
			}

			weightSum += weight;
		}

		if(weightSum != 0.0)
		{
			for(DWORD j = 0; j <= m_List[i].count; j++)
			{
				m_List[i].stat[j].weight /= weightSum;
			}
		}
	}
}

void CMFCZoomKernel::Create(long sizeSrc, long sizeDst, XFilterType ft)
{
	Create(sizeSrc, sizeDst, 0, sizeSrc, ft);
}

void CMFCZoomKernel::Empty()
{
	if (m_List != NULL)
	{
		for (DWORD i = 0; i < m_Size; i++)
		{
			if (m_List[i].count > 0)
			{
				delete [] m_List[i].stat;
			}
		}

		delete [] m_List;

		m_List = NULL;
		m_Size = 0;
	}
}

CMFCZoomKernel::XKernelList& CMFCZoomKernel::operator [](long index)
{
	return m_List[index];
}

const CMFCZoomKernel::XKernelList& CMFCZoomKernel::operator [](long index) const
{
	return m_List[index];
}

class CMFCScanliner
{
public:
	CMFCScanliner()
	{
		empty();
	}

	CMFCScanliner(LPBYTE data, const CSize& size, size_t height = 0, size_t pitch = 0, BYTE channels = 4, BOOL invert = FALSE)
	{
		attach(data, size, height, pitch, channels, invert);
	}

	CMFCScanliner(LPBYTE data, const CRect& rect, size_t height = 0, size_t pitch = 0, BYTE channels = 4, BOOL invert = FALSE)
	{
		attach(data, rect, height, pitch, channels, invert);
	}

	void attach(LPBYTE data, const CSize& size, size_t height = 0, size_t pitch = 0, BYTE channels = 4, BOOL invert = FALSE)
	{
		attach(data, CRect(CPoint(0, 0), size), height, pitch, channels, invert);
	}

	void attach(LPBYTE data, const CRect& rect, size_t height = 0, size_t pitch = 0, BYTE channels = 4, BOOL invert = FALSE)
	{
		empty();

		ASSERT(data != NULL);

		CPoint point(rect.TopLeft());
		CSize size(rect.Size());
		if(pitch == 0)
		{
			pitch = size.cx;
		}
		if(height == 0)
		{
			height = point.y + size.cy;
		}

		ASSERT((size_t)size.cx <= pitch);
		ASSERT((size_t)(point.y + size.cy) <= height);

		m_rows     = size.cy;
		m_cols     = size.cx * channels;
		m_pitch    = pitch;
		m_offset   = (long)m_pitch;
		if (invert)
		{
			m_offset = -m_offset;
		}
		m_channels = channels;
		m_height   = height;

		m_start_row = point.y;
		m_start_col = point.x;

		m_line_begin = _begin(data);
		m_line_end   = _end(data);
		m_line       = m_line_begin;
	}

	inline LPBYTE begin()
	{
		m_line = m_line_begin;
		return m_line;
	}

	inline LPBYTE end()
	{
		m_line = m_line_end;
		return m_line;
	}

	inline LPBYTE operator[](long index)
	{
		return m_line_begin + m_offset * index;
	}

	inline const LPBYTE operator[](long index) const
	{
		return m_line_begin + m_offset * index;
	}

	inline LPBYTE get()
	{
		return m_line;
	}

	inline const LPBYTE get() const
	{
		return m_line;
	}

	inline size_t pitch() const
	{
		return m_pitch;
	}

	inline DWORD rows() const
	{
		return m_rows;
	}

	inline DWORD cols() const
	{
		return m_cols;
	}

	inline BYTE channels() const
	{
		return m_channels;
	}

	~CMFCScanliner()
	{
		empty();
	}

	inline  const CMFCScanliner& operator += (DWORD line)
	{
		m_line += m_offset * line;
		return *this;
	}

	inline  const CMFCScanliner& operator -= (DWORD line)
	{
		m_line -= m_offset * line;
		return *this;
	}

	inline  const CMFCScanliner& operator ++ ()
	{
		m_line += m_offset;
		return *this;
	}

	inline  const CMFCScanliner& operator ++ (int)
	{
		m_line += m_offset;
		return *this;
	}

	inline  const CMFCScanliner& operator -- ()
	{
		m_line -= m_offset;
		return *this;
	}

	inline  const CMFCScanliner& operator -- (int)
	{
		m_line += m_offset;
		return *this;
	}

protected:
	void empty()
	{
		m_line      = NULL;
		m_pitch     = 0;
		m_start_row = 0;
		m_start_col = 0;
		m_rows      = 0;
		m_cols      = 0;
		m_offset    = 0;
		m_height    = 0;

		m_line_begin = NULL;
		m_line_end   = NULL;
	}

	inline LPBYTE _begin(LPBYTE data) const
	{
		LPBYTE line = data;

		if(m_offset > 0)
		{
			line += m_start_row * m_pitch;
		}
		else
		{
			line += (m_height - m_start_row - 1) * m_pitch;
		}

		if(m_start_col != 0)
		{
			line += m_start_col * m_channels;
		}

		return line;
	}

	inline LPBYTE _end(LPBYTE data) const
	{
		LPBYTE line = data;

		if(m_offset > 0)
		{
			line += (m_start_row + m_rows - 1) * m_pitch;
		}
		else
		{
			line += (m_height - m_start_row - m_rows) * m_pitch;
		}

		if(m_start_col != 0)
		{
			line += m_start_col * m_channels;
		}

		return line;
	}

private:
	LPBYTE  m_line;
	LPBYTE  m_line_begin;
	LPBYTE  m_line_end;
	size_t  m_pitch;
	DWORD   m_start_row;
	DWORD   m_start_col;
	DWORD   m_rows;
	DWORD   m_cols;
	long    m_offset;
	BYTE    m_channels;
	size_t  m_height;
};

class CMFCScanlinerBitmap: public CMFCScanliner
{
public:
	CMFCScanlinerBitmap()
	{
		empty();
	}

	void attach(HBITMAP bitmap, const CPoint& ptBegin = CPoint(0, 0))
	{
		if (bitmap == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		BITMAP bmp;
		if (::GetObject(bitmap, sizeof(BITMAP), &bmp) == 0 ||
			bmp.bmBits == 0 || bmp.bmBitsPixel < 24)
		{
			ASSERT(FALSE);
			return;
		}

		CSize size(bmp.bmWidth, abs(bmp.bmHeight));
		CRect rect(CPoint(0, 0), size);
		rect.IntersectRect(CRect(ptBegin, size), rect);

		int channels = bmp.bmBitsPixel / 8;
		int pitch = channels * size.cx;
		if (pitch % 4)
		{
			pitch += 4 - (pitch % 4);
		}

		CMFCScanliner::attach((LPBYTE) bmp.bmBits, 
			size, size.cy, pitch, (BYTE) channels, bmp.bmHeight < 0);
	}
};

/////////////////////////////////////////////////////////////////////////////
// Init / Term

void __stdcall CMFCToolBarImages::CleanUp()
{
	if (hDCMono != NULL)
	{
		::DeleteDC(hDCMono);
		hDCMono = NULL;
	}

	if (hDCGlyphs != NULL)
	{
		::DeleteDC(hDCGlyphs);
		hDCGlyphs = NULL;
	}

	CPngImage::CleanUp();
}

// a special struct that will cleanup automatically
struct _AFX_TOOLBAR_TERM
{
	~_AFX_TOOLBAR_TERM()
	{
		CMFCToolBarImages::CleanUp();
	}
};

static const _AFX_TOOLBAR_TERM toolbarTerm;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarImages::CMFCToolBarImages()
{
	m_bModified = FALSE;
	m_bReadOnly = FALSE;
	m_bIsTemporary = FALSE;
	m_iCount = 0;
	m_bIsGray = FALSE;
	m_nGrayImageLuminancePercentage = 0;

	m_hbmImageWell = NULL;
	m_hbmImageLight = NULL;
	m_hbmImageShadow = NULL;

	m_bUserImagesList = FALSE;

	// initialize the toolbar drawing engine
	static BOOL bInitialized;
	if (!bInitialized)
	{
		hDCGlyphs = CreateCompatibleDC(NULL);

		// Mono DC and Bitmap for disabled image
		hDCMono = ::CreateCompatibleDC(NULL);

		if (hDCGlyphs == NULL || hDCMono == NULL)
			AfxThrowResourceException();

		bInitialized = TRUE;
	}

	m_clrTransparentOriginal = m_clrTransparent = (COLORREF) -1;

	// UISG standard sizes
	m_sizeImage = CSize(16, 15);
	m_sizeImageOriginal = CSize(0, 0);
	m_sizeImageDest = CSize(0, 0);
	m_rectLastDraw = CRect(0, 0, 0, 0);
	m_rectSubImage = CRect(0, 0, 0, 0);
	m_bStretch = FALSE;
	m_pBmpOriginal = NULL;

	m_bFadeInactive = FALSE;
	m_nBitsPerPixel = 0;

	m_nLightPercentage = 130;
	m_bAlwaysLight = FALSE;

	m_bMapTo3DColors = TRUE;
	m_bAutoCheckPremlt = FALSE;
	m_bCreateMonoDC = TRUE;

	m_dblScale = 1.0;

	OnSysColorChange();
}

CMFCToolBarImages::~CMFCToolBarImages()
{
	ENSURE(m_dcMem.GetSafeHdc() == NULL);
	ENSURE(m_bmpMem.GetSafeHandle() == NULL);
	ENSURE(m_pBmpOriginal == NULL);

	if (!m_bIsTemporary)
	{
		AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);
		AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
		AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	}
}

BOOL CMFCToolBarImages::Load(UINT uiResID, HINSTANCE hinstRes, BOOL bAdd)
{
	return LoadStr(MAKEINTRESOURCE(uiResID), hinstRes, bAdd);
}

BOOL CMFCToolBarImages::LoadStr(LPCTSTR lpszResourceName, HINSTANCE hinstRes, BOOL bAdd)
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (lpszResourceName == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	UINT uiResID = IS_INTRESOURCE(lpszResourceName) ?(UINT)((UINT_PTR)(lpszResourceName)) : 0;

	if (!bAdd)
	{
		AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);     // get rid of old one
		m_lstOrigResIds.RemoveAll();
		m_lstOrigResInstances.RemoveAll();
		m_mapOrigResOffsets.RemoveAll();
	}
	else if (uiResID != 0 && m_lstOrigResIds.Find(uiResID) != NULL) // Already loaded, do nothing
	{
		return TRUE;
	}

	HBITMAP hbmp = NULL;

	// Try to load PNG image first:
	CPngImage pngImage;
	if (pngImage.Load(lpszResourceName, hinstRes))
	{
		hbmp = (HBITMAP) pngImage.Detach();
	}
	else
	{
		if (hinstRes == NULL)
		{
			hinstRes = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
		}

		UINT uiLoadImageFlags = LR_CREATEDIBSECTION;
		if (m_bMapTo3DColors && !afxGlobalData.m_bIsBlackHighContrast)
		{
			uiLoadImageFlags |= LR_LOADMAP3DCOLORS;
		}

		hbmp = (HBITMAP) ::LoadImage(hinstRes, lpszResourceName, IMAGE_BITMAP, 0, 0, uiLoadImageFlags);
	}

	if (hbmp == NULL)
	{
		if (uiResID != 0)
		{
			TRACE(_T("Can't load bitmap: %x. GetLastError() = %x\n"), uiResID, GetLastError());
		}
		else
		{
			TRACE(_T("Can't load bitmap: %s. GetLastError() = %x\n"), lpszResourceName, GetLastError());
		}
		return FALSE;
	}

	BITMAP bmp;
	if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
	{
		ASSERT(FALSE);
		::DeleteObject(hbmp);
		return FALSE;
	}

	if (bmp.bmBitsPixel >= 32)
	{
		PreMultiplyAlpha(hbmp);
	}
	else if ((bmp.bmBitsPixel > 8 && m_bMapTo3DColors) || afxGlobalData.m_bIsBlackHighContrast)
	{
		// LR_LOADMAP3DCOLORS don't support > 8bpp images,
		// we should convert it now:
		MapBmpTo3dColors(hbmp, FALSE);
	}

	m_nBitsPerPixel = max(m_nBitsPerPixel, bmp.bmBitsPixel);

	if (bAdd)
	{
		if (uiResID != 0)
		{
			m_mapOrigResOffsets.SetAt(uiResID, m_iCount);
		}

		AddImage(hbmp);

		if (uiResID != 0)
		{
			m_lstOrigResIds.AddTail(uiResID);
			m_lstOrigResInstances.AddTail(hinstRes);
		}

		::DeleteObject(hbmp);
	}
	else
	{
		m_hbmImageWell = hbmp;
	}

	UpdateCount();

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	return TRUE;
}

BOOL CMFCToolBarImages::Load(LPCTSTR lpszBmpFileName, DWORD dwMaxFileSize /* = 819200 */)
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ENSURE(lpszBmpFileName != NULL);

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);     // get rid of old one

	CString strPath = lpszBmpFileName;

	// If the image path is not defined, try to open it in the EXE directory:
	if (strPath.Find(_T("\\")) == -1 && strPath.Find(_T("/")) == -1 && strPath.Find(_T(":")) == -1)
	{
		TCHAR lpszFilePath [_MAX_PATH];
		if (::GetModuleFileName(NULL, lpszFilePath, _MAX_PATH) > 0)
		{
			TCHAR path_buffer[_MAX_PATH];
			TCHAR drive[_MAX_DRIVE];
			TCHAR dir[_MAX_DIR];
			TCHAR fname[_MAX_FNAME];
			TCHAR ext[_MAX_EXT];

			_tsplitpath_s(lpszFilePath, drive, _MAX_DRIVE, dir, _MAX_DIR, NULL, 0, NULL, 0);
			_tsplitpath_s(lpszBmpFileName, NULL, 0, NULL, 0, fname, _MAX_FNAME, ext, _MAX_EXT);

			_tmakepath_s(path_buffer, _MAX_PATH, drive, dir, fname, ext);

			strPath = path_buffer;
		}
	}

	// Check that file size does not exceed specified limit
	if (dwMaxFileSize > 0)
	{
		HANDLE hFile = CreateFile(lpszBmpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwFileSize = GetFileSize(hFile, NULL);
			CloseHandle(hFile);

			if (dwFileSize > dwMaxFileSize)
			{
				return FALSE;
			}
		}
	}

	// Load images from the disk file:
	UINT uiLoadImageFlags = LR_LOADFROMFILE | LR_CREATEDIBSECTION;
	if (m_bMapTo3DColors)
	{
		uiLoadImageFlags |= LR_LOADMAP3DCOLORS;
	}

	m_hbmImageWell = (HBITMAP) ::LoadImage(AfxGetInstanceHandle(), strPath, IMAGE_BITMAP, 0, 0, uiLoadImageFlags);

	if (m_hbmImageWell == NULL)
	{
		TRACE(_T("Can't load bitmap: %s. GetLastError() = %x\r\n"), lpszBmpFileName, GetLastError());
		return FALSE;
	}

	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		ASSERT(FALSE);
		::DeleteObject(m_hbmImageWell);
		m_hbmImageWell = NULL;
		return FALSE;
	}

	m_bUserImagesList = TRUE;
	m_strUDLPath = strPath;

	if (::GetFileAttributes(strPath) & FILE_ATTRIBUTE_READONLY)
	{
		m_bReadOnly = TRUE;
	}

	m_nBitsPerPixel = bmp.bmBitsPixel;
	if (m_nBitsPerPixel > 8 && m_nBitsPerPixel < 32)
	{
		// LR_LOADMAP3DCOLORS don't support > 8bpp images, // we should convert it now:
		MapTo3dColors(FALSE);
	}

	if (bmp.bmBitsPixel >= 32)
	{
		PreMultiplyAlpha(m_hbmImageWell);
	}

	UpdateCount();

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	return TRUE;
}

BOOL CMFCToolBarImages::PrepareDrawImage(CAfxDrawState& ds, CSize sizeImageDest, BOOL bFadeInactive)
{
	if (m_hbmImageWell == NULL)
	{
		return FALSE;
	}

	if (m_bMultiThreaded)
	{
		m_CriticalSection.Lock();
	}

	if (bFadeInactive && m_nBitsPerPixel < 32 && m_hbmImageLight == NULL)
	{
		UpdateInternalImage(AFX_IMAGE_LIGHT);
	}

	if (m_nBitsPerPixel < 32 && m_hbmImageShadow == NULL && CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() && !afxGlobalData.IsHighContrastMode())
	{
		UpdateInternalImage(AFX_IMAGE_SHADOW);
	}

	m_bStretch = FALSE;

	if (m_hbmImageLight == NULL || (m_nBitsPerPixel > 4 && !m_bAlwaysLight) || m_nBitsPerPixel == 0)
	{
		// Down't fade 256+ or unknown bitmaps
		bFadeInactive = FALSE;
	}

	m_bFadeInactive = bFadeInactive;

	ENSURE(m_hbmImageWell != NULL);
	ENSURE(m_dcMem.GetSafeHdc() == NULL);
	ENSURE(m_bmpMem.GetSafeHandle() == NULL);
	ENSURE(m_pBmpOriginal == NULL);

	// We need to kick-start the bitmap selection process.
	ds.hbmOldGlyphs = (HBITMAP)SelectObject(hDCGlyphs, bFadeInactive && m_nBitsPerPixel < 32 ? m_hbmImageLight : m_hbmImageWell);

	if (ds.hbmOldGlyphs == NULL)
	{
		TRACE0("Error: can't draw toolbar.\r\n");

		if (m_bMultiThreaded)
		{
			m_CriticalSection.Unlock();
		}

		return FALSE;
	}

	if (m_bCreateMonoDC)
	{
		ds.hbmMono = CreateBitmap(m_sizeImage.cx + 2, m_sizeImage.cy + 2, 1, 1, NULL);
		ds.hbmMonoOld = (HBITMAP)SelectObject(hDCMono, ds.hbmMono);

		if (ds.hbmMono == NULL || ds.hbmMonoOld == NULL)
		{
			TRACE0("Error: can't draw toolbar.\r\n");
			AfxDeleteObject((HGDIOBJ*)&ds.hbmMono);

			if (m_bMultiThreaded)
			{
				m_CriticalSection.Unlock();
			}

			return FALSE;
		}
	}

	if (sizeImageDest.cx <= 0 || sizeImageDest.cy <= 0)
	{
		m_sizeImageDest = m_sizeImage;
	}
	else
	{
		m_sizeImageDest = sizeImageDest;
	}

	COLORREF clrTransparent = m_nBitsPerPixel == 32 ? (COLORREF) -1 : m_clrTransparent;

	if (m_sizeImageDest != m_sizeImage || clrTransparent != (COLORREF) -1)
	{
		CWindowDC dc(NULL);

		m_bStretch = (m_sizeImageDest != m_sizeImage);

		m_dcMem.CreateCompatibleDC(NULL); // Assume display!
		m_bmpMem.CreateCompatibleBitmap(&dc, m_sizeImage.cx + 2, m_sizeImage.cy + 2);

		m_pBmpOriginal = m_dcMem.SelectObject(&m_bmpMem);
		ENSURE(m_pBmpOriginal != NULL);
	}

	return TRUE;
}

void CMFCToolBarImages::EndDrawImage(CAfxDrawState& ds)
{
	if (m_bCreateMonoDC)
	{
		SelectObject(hDCMono, ds.hbmMonoOld);
		AfxDeleteObject((HGDIOBJ*)&ds.hbmMono);
	}

	SelectObject(hDCGlyphs, ds.hbmOldGlyphs);

	m_sizeImageDest = CSize(0, 0);
	m_rectLastDraw = CRect(0, 0, 0, 0);

	COLORREF clrTransparent = m_nBitsPerPixel == 32 ? (COLORREF) -1 : m_clrTransparent;

	if (m_bStretch || clrTransparent != (COLORREF) -1)
	{
		ENSURE(m_pBmpOriginal != NULL);

		m_dcMem.SelectObject(m_pBmpOriginal);
		m_pBmpOriginal = NULL;

		::DeleteObject(m_bmpMem.Detach());
		::DeleteDC(m_dcMem.Detach());
	}

	m_bFadeInactive = FALSE;

	if (m_bMultiThreaded)
	{
		m_CriticalSection.Unlock();
	}
}

void CMFCToolBarImages::CreateMask(int iImage, BOOL bHilite, BOOL bHiliteShadow)
{
	// initalize whole area with 0's
	PatBlt(hDCMono, 0, 0, m_sizeImage.cx + 2, m_sizeImage.cy + 2, WHITENESS);

	COLORREF clrTransparent = m_nBitsPerPixel == 32 ? (COLORREF) -1 : m_clrTransparent;

	// create mask based on color bitmap
	// convert this to 1's
	SetBkColor(hDCGlyphs, clrTransparent != -1 ? clrTransparent : afxGlobalData.clrBtnFace);

	::BitBlt(hDCMono, 0, 0, m_sizeImage.cx, m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCCOPY);

	if (bHilite)
	{
		// convert this to 1's
		SetBkColor(hDCGlyphs, afxGlobalData.clrBtnHilite);

		// OR in the new 1's
		::BitBlt(hDCMono, 0, 0, m_sizeImage.cx, m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCPAINT);

		if (bHiliteShadow)
		{
			::BitBlt(hDCMono, 1, 1, m_sizeImage.cx + 1, m_sizeImage.cy + 1, hDCMono, 0, 0, SRCAND);
		}
	}
}

HBITMAP CMFCToolBarImages::GetMask(int iImage)
{
	CAfxDrawState ds;

	PrepareDrawImage(ds, FALSE);
	CreateMask(iImage, FALSE, FALSE);

	CDC memDCDest;
	CDC* pDCMono = CDC::FromHandle(hDCMono);
	ASSERT_VALID(pDCMono);

	memDCDest.CreateCompatibleDC(pDCMono);

	CBitmap bitmapMask;

	if (bitmapMask.CreateBitmap(m_sizeImage.cx, m_sizeImage.cy, 1, 1, NULL))
	{
		CBitmap* pOldBitmapDest = memDCDest.SelectObject(&bitmapMask);

		memDCDest.BitBlt(0, 0, m_sizeImage.cx, m_sizeImage.cy, pDCMono, 0, 0, SRCCOPY);
		memDCDest.SelectObject(pOldBitmapDest);
	}

	EndDrawImage(ds);

	return(HBITMAP) bitmapMask.Detach();
}

BOOL CMFCToolBarImages::Draw(CDC* pDCDest, int xDest, int yDest, int iImage, BOOL bHilite, BOOL bDisabled, BOOL bIndeterminate, BOOL bShadow, BOOL bInactive, BYTE alphaSrc/* = 255*/)
{
	if (iImage < 0 || iImage >= m_iCount)
	{
		return FALSE;
	}

	if (bShadow && afxGlobalData.m_nBitsPerPixel <= 8)
	{
		return TRUE;
	}

	m_rectLastDraw = CRect(CPoint(xDest, yDest), m_sizeImageDest);

	if (m_bStretch)
	{
		bHilite = FALSE;
		bIndeterminate = FALSE;
	}

	HBITMAP hBmpOriginal = NULL;
	if ((!bInactive || bDisabled) && m_bFadeInactive && m_nBitsPerPixel < 32)
	{
		hBmpOriginal = (HBITMAP) SelectObject(hDCGlyphs, m_hbmImageWell);
	}

	BOOL bStretchOld = m_bStretch;
	BOOL bAlphaStretch =
		(m_nBitsPerPixel == 32 && m_bStretch);

	if (bAlphaStretch)
	{
		m_bStretch = FALSE;
	}

	COLORREF clrTransparent = (m_nBitsPerPixel == 32 || m_bIsDrawOnGlass) ?(COLORREF) -1 : m_clrTransparent;

	BOOL bIsTransparent = (clrTransparent != (COLORREF) -1);

	COLORREF clrTransparentDisabled = clrTransparent;

	CDC* pDC = m_bStretch || bIsTransparent ? &m_dcMem : pDCDest;
	ASSERT_VALID(pDC);

	int x = m_bStretch || bIsTransparent ? 0 : xDest;
	int y = m_bStretch || bIsTransparent ? 0 : yDest;

	const int xOffset = m_rectSubImage.left;
	const int yOffset = m_rectSubImage.top;

	const int nWidth = m_rectSubImage.IsRectEmpty() ? m_sizeImage.cx : m_rectSubImage.Width();
	const int nHeight = m_rectSubImage.IsRectEmpty() ? m_sizeImage.cy : m_rectSubImage.Height();

	if (m_bStretch || bIsTransparent)
	{
		CRect rectImage(CPoint(0, 0), m_sizeImage);

		if (bIsTransparent && clrTransparent != afxGlobalData.clrBtnFace)
		{
			CBrush brBackgr(clrTransparent);
			pDC->FillRect(rectImage, &brBackgr);
		}
		else
		{
			pDC->FillRect(rectImage, &afxGlobalData.brBtnFace);
		}

		if (bDisabled && afxGlobalData.m_nBitsPerPixel == 16)
		{
			clrTransparentDisabled = pDC->GetPixel(rectImage.TopLeft());
		}
	}

	BOOL bDisabledTrueColor = FALSE;

	if (bDisabled && m_nBitsPerPixel >= 24)
	{
		bDisabled = FALSE;
		bDisabledTrueColor = TRUE;
	}

	BOOL bShadowTrueColor = FALSE;

	if (bShadow && m_nBitsPerPixel == 32)
	{
		bShadow = FALSE;
		bShadowTrueColor = TRUE;
	}

	if (!bHilite && !bDisabled && !bShadow)
	{
		BOOL bIsReady = FALSE;

		if ((m_nBitsPerPixel == 32 || m_bIsDrawOnGlass))
		{
			BLENDFUNCTION pixelblend = { AC_SRC_OVER, 0, alphaSrc, AC_SRC_ALPHA };

			if (bDisabledTrueColor)
			{
				pixelblend.SourceConstantAlpha = m_nDisabledImageAlpha;
			}

			if (bInactive && m_bFadeInactive)
			{
				pixelblend.SourceConstantAlpha = m_nFadedImageAlpha;
			}

			const CSize sizeDest = bAlphaStretch ? m_sizeImageDest : m_sizeImage;

			if (m_nBitsPerPixel != 32)
			{
				BITMAPINFO bi;

				// Fill in the BITMAPINFOHEADER
				bi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
				bi.bmiHeader.biWidth         = nWidth;
				bi.bmiHeader.biHeight        = nHeight;
				bi.bmiHeader.biPlanes        = 1;
				bi.bmiHeader.biBitCount      = 32;
				bi.bmiHeader.biCompression   = BI_RGB;
				bi.bmiHeader.biSizeImage     = nWidth * nHeight;
				bi.bmiHeader.biXPelsPerMeter = 0;
				bi.bmiHeader.biYPelsPerMeter = 0;
				bi.bmiHeader.biClrUsed       = 0;
				bi.bmiHeader.biClrImportant  = 0;

				COLORREF* pBits = NULL;
				HBITMAP hbmp = CreateDIBSection(NULL, &bi, DIB_RGB_COLORS, (LPVOID*)&pBits, NULL, 0);

				if (hbmp == NULL)
				{
					ASSERT(FALSE);
					return FALSE;
				}

				CBitmap bmpMem;
				bmpMem.Attach(hbmp);

				CDC dcMem;
				dcMem.CreateCompatibleDC(NULL);
				CBitmap* pBmpOld = dcMem.SelectObject(&bmpMem);

				::BitBlt(dcMem.GetSafeHdc(), 0, 0, nWidth, nHeight, hDCGlyphs, iImage * m_sizeImage.cx + xOffset, yOffset, SRCCOPY);

				int nSizeImage = nHeight * nWidth;

				if (m_clrTransparent == -1)
				{
					for (int i = 0; i < nSizeImage; i++)
					{
						*pBits |= 0xFF000000;
						pBits++;
					}
				}
				else
				{
					COLORREF clrTrans = RGB(GetBValue(m_clrTransparent), GetGValue(m_clrTransparent), GetRValue(m_clrTransparent));

					for (int i = 0; i < nSizeImage; i++)
					{
						if (*pBits != clrTrans)
						{
							*pBits |= 0xFF000000;
						}
						else
						{
							*pBits = (COLORREF)0;
						}

						pBits++;
					}
				}

				bIsReady = pDC->AlphaBlend(x, y, sizeDest.cx, sizeDest.cy, &dcMem, 0, 0, nWidth, nHeight, pixelblend);

				dcMem.SelectObject(pBmpOld);
			}
			else
			{
				bIsReady = pDC->AlphaBlend(x, y, sizeDest.cx, sizeDest.cy, CDC::FromHandle(hDCGlyphs), iImage * m_sizeImage.cx + xOffset, yOffset, nWidth, nHeight, pixelblend);
			}
		}

		if (!bIsReady)
		{
			// normal image version:
			::BitBlt(pDC->m_hDC, x, y, nWidth, nHeight, hDCGlyphs, iImage * m_sizeImage.cx + xOffset, yOffset, SRCCOPY);

			if (bDisabledTrueColor)
			{
				CDrawingManager dm(*pDC);
				dm.GrayRect(CRect(x, y, x + nWidth + 2, y + nHeight + 2), -1, clrTransparentDisabled == -1 ? afxGlobalData.clrBtnFace : clrTransparentDisabled, CMFCVisualManager::GetInstance()->GetToolbarDisabledColor());
			}
		}
	}
	else if (bShadow && m_hbmImageShadow != NULL)
	{
		HBITMAP hbmpCurr =
			(HBITMAP) SelectObject(hDCGlyphs, m_hbmImageShadow);

		::BitBlt(pDC->m_hDC, x, y, nWidth, nHeight, hDCGlyphs, iImage * m_sizeImage.cx + xOffset, yOffset, SRCCOPY);

		SelectObject(hDCGlyphs, hbmpCurr);
	}
	else
	{
		if (bDisabled || bIndeterminate || bShadow)
		{
			// disabled or indeterminate version
			CreateMask(iImage, TRUE, FALSE);

			pDC->SetTextColor(bShadow ? m_clrImageShadow : 0L); // 0's in mono -> 0(for ROP)
			pDC->SetBkColor((COLORREF)0x00FFFFFFL); // 1's in mono -> 1

			if (bDisabled && CMFCVisualManager::GetInstance()->IsEmbossDisabledImage())
			{
				// disabled - draw the hilighted shadow
				HGDIOBJ hbrOld = pDC->SelectObject(afxGlobalData.hbrBtnHilite);
				if (hbrOld != NULL)
				{
					// draw hilight color where we have 0's in the mask
					::BitBlt(pDC->m_hDC, x + 1, y + 1, nWidth + 2, nHeight + 2, hDCMono, 0, 0, AFX_ROP_PSDPxax);

					pDC->SelectObject(hbrOld);
				}
			}

			//BLOCK: always draw the shadow
			{
				HGDIOBJ hbrOld = pDC->SelectObject(afxGlobalData.hbrBtnShadow);
				if (hbrOld != NULL)
				{
					// draw the shadow color where we have 0's in the mask
					::BitBlt(pDC->m_hDC, x, y, nWidth + 2, nHeight + 2, hDCMono, 0, 0, AFX_ROP_PSDPxax);

					pDC->SelectObject(hbrOld);
				}
			}
		}

		// if it is checked do the dither brush avoiding the glyph
		if (bHilite || bIndeterminate)
		{
			CBrush* pBrOld = pDC->SelectObject(&afxGlobalData.brLight);
			if (pBrOld != NULL)
			{
				CreateMask(iImage, !bIndeterminate, bDisabled);

				pDC->SetTextColor(0L);              // 0 -> 0
				pDC->SetBkColor((COLORREF)0x00FFFFFFL); // 1 -> 1

				// only draw the dither brush where the mask is 1's
				::BitBlt(pDC->m_hDC, x, y, nWidth, nHeight, hDCMono, 0, 0, AFX_ROP_DSPDxax);

				pDC->SelectObject(pBrOld);
			}
		}
	}

	if (m_bStretch)
	{
		TransparentBlt(pDCDest->GetSafeHdc(), xDest, yDest, nWidth, nHeight, pDC, 0, 0, bIsTransparent ? clrTransparent : afxGlobalData.clrBtnFace, m_sizeImageDest.cx, m_sizeImageDest.cy);
	}
	else if (bIsTransparent)
	{
		TransparentBlt(pDCDest->GetSafeHdc(), xDest, yDest, nWidth, nHeight, pDC, 0, 0, clrTransparent);
	}

	if (hBmpOriginal != NULL)
	{
		SelectObject(hDCGlyphs, hBmpOriginal);
	}

	m_bStretch = bStretchOld;
	return TRUE;
}

BOOL CMFCToolBarImages::DrawEx(CDC* pDC, CRect rect, int iImageIndex, ImageAlignHorz horzAlign/* = ImageAlignHorzLeft*/, ImageAlignVert vertAlign/* = ImageAlignVertTop*/, CRect rectSrc/* = CRect(0, 0, 0, 0)*/, BYTE alphaSrc/* = 255*/)
{
	ASSERT_VALID(pDC);

	if (rectSrc.IsRectEmpty())
	{
		rectSrc = CRect(CPoint(0, 0), m_sizeImage);
	}

	if (rectSrc.IsRectEmpty())
	{
		return FALSE;
	}

	CRect rectDst(rect);

	if (horzAlign != ImageAlignHorzStretch)
	{
		BOOL bUpdate = TRUE;

		if (horzAlign == ImageAlignHorzLeft)
		{
			rectDst.right = rectDst.left + rectSrc.Width();
		}
		else if (horzAlign == ImageAlignHorzRight)
		{
			rectDst.left = rectDst.right - rectSrc.Width();
		}
		else if (horzAlign == ImageAlignHorzCenter)
		{
			rectDst.left += (rectDst.Width() - rectSrc.Width()) / 2;
			rectDst.right = rectDst.left + rectSrc.Width();
		}
		else
		{
			bUpdate = FALSE;
		}

		if (bUpdate)
		{
			CRect rt(rectDst);
			rectDst.IntersectRect(rectDst, rect);

			if (0 < rectDst.Width() && rectDst.Width() !=  rectSrc.Width())
			{
				rectSrc.left += rectDst.left - rt.left;
				rectSrc.right = rectSrc.left + min(rectDst.Width(), rectSrc.Width());
			}
		}
	}

	if (vertAlign != ImageAlignVertStretch)
	{
		BOOL bUpdate = TRUE;

		if (vertAlign == ImageAlignVertTop)
		{
			rectDst.bottom = rectDst.top + rectSrc.Height();
		}
		else if (vertAlign == ImageAlignVertBottom)
		{
			rectDst.top = rectDst.bottom - rectSrc.Height();
		}
		else if (vertAlign == ImageAlignVertCenter)
		{
			rectDst.top += (rectDst.Height() - rectSrc.Height()) / 2;
			rectDst.bottom = rectDst.top + rectSrc.Height();
		}
		else
		{
			bUpdate = FALSE;
		}

		if (bUpdate)
		{
			CRect rt(rectDst);
			rectDst.IntersectRect(rectDst, rect);

			if (0 < rectDst.Height() && rectDst.Height() !=  rectSrc.Height())
			{
				rectSrc.top += rectDst.top - rt.top;
				rectSrc.bottom = rectSrc.top + min(rectDst.Height(), rectSrc.Height());
			}
		}
	}

	if (rectSrc.IsRectEmpty() || rectDst.IsRectEmpty())
	{
		return FALSE;
	}

	HBITMAP hbmOldGlyphs = (HBITMAP)SelectObject (hDCGlyphs, m_hbmImageWell);

	const int xOffset = rectSrc.left;
	const int yOffset = rectSrc.top;

	const int nWidth = rectSrc.IsRectEmpty () ? m_sizeImage.cx : rectSrc.Width ();
	const int nHeight = rectSrc.IsRectEmpty () ? m_sizeImage.cy : rectSrc.Height ();

	BOOL bRes = FALSE;

	if (m_nBitsPerPixel == 32)
	{
		BLENDFUNCTION pixelblend = { AC_SRC_OVER, 0, alphaSrc, AC_SRC_ALPHA };

		bRes = pDC->AlphaBlend(rectDst.left, rectDst.top,
			rectDst.Width (), rectDst.Height (), 
			CDC::FromHandle (hDCGlyphs), iImageIndex * m_sizeImage.cx + xOffset, yOffset, 
			nWidth, nHeight, pixelblend);
	}
	else if (m_clrTransparent == -1)
	{
		bRes = ::StretchBlt (pDC->m_hDC, rectDst.left, rectDst.top,
			rectDst.Width (), rectDst.Height (), 
			hDCGlyphs, iImageIndex * m_sizeImage.cx + xOffset, yOffset, 
			nWidth, nHeight, SRCCOPY);
	}

	SelectObject (hDCGlyphs, hbmOldGlyphs);

	if (bRes)
	{
		return TRUE;
	}

	BOOL bCreateMonoDC = m_bCreateMonoDC;
	m_bCreateMonoDC = FALSE;

	CAfxDrawState ds;
	if (!PrepareDrawImage(ds, rectDst.Size()))
	{
		m_bCreateMonoDC = bCreateMonoDC;
		return FALSE;
	}

	m_rectSubImage = rectSrc;

	bRes = Draw(pDC, rectDst.left, rectDst.top, iImageIndex, FALSE, FALSE, FALSE, FALSE, FALSE, alphaSrc);

	m_rectSubImage.SetRectEmpty();

	EndDrawImage(ds);
	m_bCreateMonoDC = bCreateMonoDC;
	return bRes;
}

void __stdcall CMFCToolBarImages::FillDitheredRect(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(&rect, &afxGlobalData.brLight);
}

void CMFCToolBarImages::OnSysColorChange()
{
	if (m_bIsTemporary)
	{
		return;
	}

	int iOldCount = m_iCount;

	if (m_dblScale != 1.0)
	{
		m_dblScale = 1.0;
		m_nBitsPerPixel = 0;

		if (m_clrTransparentOriginal != (COLORREF)-1)
		{
			m_clrTransparent = m_clrTransparentOriginal;
			m_clrTransparentOriginal = (COLORREF)-1;
		}

		m_sizeImage = m_sizeImageOriginal;
		m_sizeImageOriginal = CSize (0, 0);
		m_sizeImageDest = CSize(0, 0);
		m_rectLastDraw = CRect(0, 0, 0, 0);
		m_rectSubImage = CRect(0, 0, 0, 0);
	}

	// re-color bitmap for toolbar
	if (m_hbmImageWell != NULL)
	{
		if (m_bUserImagesList)
		{
			Load(m_strUDLPath, 0);
		}
		else
		{
			// Image was buit from the resources...
			if (m_lstOrigResIds.IsEmpty())
			{
				return;
			}

			ASSERT(m_lstOrigResInstances.GetCount() == m_lstOrigResIds.GetCount());

			AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);     // get rid of old one

			POSITION posInst = m_lstOrigResInstances.GetHeadPosition();

			for (POSITION pos = m_lstOrigResIds.GetHeadPosition();
				pos != NULL;)
			{
				ENSURE(posInst != NULL);

				UINT uiResId = m_lstOrigResIds.GetNext(pos);
				ENSURE(uiResId > 0);

				HINSTANCE hInst = m_lstOrigResInstances.GetNext(posInst);

				HBITMAP hbmp = NULL;

				CPngImage pngImage;
				if (pngImage.Load(uiResId, hInst))
				{
					hbmp = (HBITMAP) pngImage.Detach();
				}

				if (hbmp == NULL)
				{
					UINT uiLoadImageFlags = LR_CREATEDIBSECTION;

					if (m_bMapTo3DColors && !afxGlobalData.IsHighContrastMode())
					{
						uiLoadImageFlags |= LR_LOADMAP3DCOLORS;
					}

					hbmp = (HBITMAP) ::LoadImageW(hInst, MAKEINTRESOURCEW(uiResId), IMAGE_BITMAP, 0, 0, uiLoadImageFlags);
				}

				BITMAP bmp;
				if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
				{
					ASSERT(FALSE);
				}

				m_nBitsPerPixel = bmp.bmBitsPixel;

				if (bmp.bmBitsPixel >= 32)
				{
					PreMultiplyAlpha(hbmp);
				}
				else if ((bmp.bmBitsPixel > 8 && m_bMapTo3DColors) || afxGlobalData.m_bIsBlackHighContrast)
				{
					// LR_LOADMAP3DCOLORS don't support > 8bpp images, // we should convert it now:
					MapBmpTo3dColors(hbmp, FALSE);
				}

				AddImage(hbmp);

				::DeleteObject(hbmp);
			}
		}
	}

	UpdateCount();
	ASSERT(iOldCount == m_iCount);

	if (m_bIsRTL)
	{
		MirrorBitmap(m_hbmImageWell, m_sizeImage.cx);
	}

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	if (m_bIsGray)
	{
		GrayImages(m_nGrayImageLuminancePercentage);
	}

	m_clrImageShadow = afxGlobalData.clrBtnShadow;
}

void CMFCToolBarImages::UpdateCount()
{
	if (m_hbmImageWell == NULL)
	{
		m_iCount = 0;
		return;
	}

	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		m_iCount = 0;
		return;
	}

	int iWidth = bmp.bmWidth;
	m_iCount = iWidth / m_sizeImage.cx;
}

//////////////////////////////////////////
// Image editing methods:
//////////////////////////////////////////

int CMFCToolBarImages::AddImage(HBITMAP hbmp, BOOL bSetBitPerPixel/* = FALSE*/)
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return -1;
	}

	BOOL bIsMirror = FALSE;

	if (m_bIsRTL)
	{
		bIsMirror = TRUE;

		hbmp = (HBITMAP) ::CopyImage(hbmp, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		MirrorBitmap(hbmp, m_sizeImage.cx);
	}

	if (IsScaled ())
	{
		BITMAP bmpScale;
		if (::GetObject(hbmp, sizeof(BITMAP), &bmpScale) == 0)
		{
			return -1;
		}

		if (bmpScale.bmHeight != m_sizeImage.cy)
		{
			CMFCToolBarImages imageForScale;
			imageForScale.m_hbmImageWell = hbmp;

			imageForScale.m_nBitsPerPixel = bmpScale.bmBitsPixel;

			imageForScale.SetImageSize(m_sizeImageOriginal);
			imageForScale.m_iCount = bmpScale.bmWidth / m_sizeImageOriginal.cx;
			imageForScale.SmoothResize(m_dblScale);
			imageForScale.m_bIsTemporary = TRUE;

			::DeleteObject (hbmp);
			hbmp = imageForScale.GetImageWell();
		}
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = NULL;

	int iBitmapWidth;
	int iBitmapHeight;
	int iNewBitmapWidth;

	BITMAP bmp;
	if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
	{
		return -1;
	}

	if (bSetBitPerPixel)
	{
		m_nBitsPerPixel = bmp.bmBitsPixel;
	}

	iNewBitmapWidth = bmp.bmWidth;
	iBitmapHeight = bmp.bmHeight;

	if (m_hbmImageWell != NULL)
	{
		// Get original bitmap attrbutes:
		if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
		{
			return -1;
		}

		hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(m_hbmImageWell);
		if (hOldBitmapSrc == NULL)
		{
			return -1;
		}

		iBitmapWidth = bmp.bmWidth;
		iBitmapHeight = bmp.bmHeight;
	}
	else
	{
		iBitmapWidth = 0;

		hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(hbmp);
		if (hOldBitmapSrc == NULL)
		{
			return -1;
		}
	}

	// Create a new bitmap compatibel with the source memory DC
	//(original bitmap SHOULD BE ALREADY SELECTED!):
	HBITMAP hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap(memDCSrc, iBitmapWidth + iNewBitmapWidth, iBitmapHeight);
	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return -1;
	}

	// Create memory destination DC and select a new bitmap:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		return -1;
	}

	if (m_hbmImageWell != NULL)
	{
		// Copy original bitmap to new:
		memDCDst.BitBlt(0, 0, iBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);
	}

	// Select a new image and copy it:
	if (memDCSrc.SelectObject(hbmp) == NULL)
	{
		memDCDst.SelectObject(hOldBitmapDst);
		memDCSrc.SelectObject(hOldBitmapSrc);

		::DeleteObject(hNewBitmap);
		return -1;
	}

	memDCDst.BitBlt(iBitmapWidth, 0, iNewBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	if (m_hbmImageWell != NULL)
	{
		::DeleteObject(m_hbmImageWell);
	}

	m_hbmImageWell = hNewBitmap;
	m_bModified = TRUE;

	UpdateCount();

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	if (bIsMirror)
	{
		::DeleteObject(hbmp);
	}

	return m_iCount - 1;
}

int CMFCToolBarImages::AddImage(const CMFCToolBarImages& imageList, int nIndex)
{
	if (nIndex < 0 || nIndex >= imageList.GetCount())
	{
		ASSERT(FALSE);
		return -1;
	}

	CWindowDC dc(NULL);

	if (!IsScaled())
	{
		m_sizeImage = imageList.m_sizeImage;
		m_sizeImageDest = imageList.m_sizeImageDest;	
		m_clrTransparent = imageList.m_clrTransparent;
		m_clrImageShadow = imageList.m_clrImageShadow;
		m_bFadeInactive = imageList.m_bFadeInactive;
		m_nBitsPerPixel = imageList.m_nBitsPerPixel;
	}

	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(imageList.m_hbmImageWell);

	CDC memDCDest;
	memDCDest.CreateCompatibleDC(NULL);

	CBitmap bitmap;
	DIBSECTION ds = {0};

	if (imageList.m_nBitsPerPixel >= 24 && ::GetObject(m_hbmImageWell, sizeof(DIBSECTION), &ds) != 0)
	{
		BITMAPINFO bi = {0};
		bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
		bi.bmiHeader.biWidth       = imageList.m_sizeImage.cx;
		bi.bmiHeader.biHeight      = imageList.m_sizeImage.cy;
		bi.bmiHeader.biPlanes      = ds.dsBmih.biPlanes;
		bi.bmiHeader.biBitCount    = ds.dsBmih.biBitCount;
		bi.bmiHeader.biCompression = BI_RGB;

		COLORREF* pBits = NULL;
		HBITMAP hNewBitmap = ::CreateDIBSection(dc, &bi, DIB_RGB_COLORS, (void **)&pBits, NULL, NULL);
		bitmap.Attach (hNewBitmap);
	}
	else
	{
		bitmap.CreateCompatibleBitmap (&dc, imageList.m_sizeImage.cx, imageList.m_sizeImage.cy);
	}

	CBitmap* pOldBitmapDest = memDCDest.SelectObject(&bitmap);

	memDCDest.BitBlt (0, 0, imageList.m_sizeImage.cx, imageList.m_sizeImage.cy, &memDCSrc, nIndex * imageList.m_sizeImage.cx, 0, SRCCOPY);

	memDCDest.SelectObject(pOldBitmapDest);
	memDCSrc.SelectObject(hOldBitmapSrc);

	return AddImage(bitmap);
}

int CMFCToolBarImages::AddIcon(HICON hIcon, BOOL bAlphaBlend/* = FALSE*/)
{
	CWindowDC dc(NULL);

	if (hIcon == NULL)
	{
		bAlphaBlend = FALSE;
	}

	CDC dcMem;
	dcMem.CreateCompatibleDC(NULL);

	CBitmap bmpMem;

	CSize sizeIcon = m_sizeImage;
	if (IsScaled())
	{
		sizeIcon = m_sizeImageOriginal;
	}

	if (bAlphaBlend)
	{
		BITMAPINFO bi;

		// Fill in the BITMAPINFOHEADER
		bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
		bi.bmiHeader.biWidth = sizeIcon.cx;
		bi.bmiHeader.biHeight = sizeIcon.cy;
		bi.bmiHeader.biPlanes = 1;
		bi.bmiHeader.biBitCount = 32;
		bi.bmiHeader.biCompression = BI_RGB;
		bi.bmiHeader.biSizeImage = sizeIcon.cx * sizeIcon.cy;
		bi.bmiHeader.biXPelsPerMeter = 0;
		bi.bmiHeader.biYPelsPerMeter = 0;
		bi.bmiHeader.biClrUsed = 0;
		bi.bmiHeader.biClrImportant = 0;

		COLORREF* pBits = NULL;
		HBITMAP hbmp = CreateDIBSection(dcMem.m_hDC, &bi, DIB_RGB_COLORS, (void **)&pBits, NULL, NULL);
		if (hbmp == NULL)
		{
			ASSERT(FALSE);
			return -1;
		}

		bmpMem.Attach(hbmp);
	}
	else
	{
		bmpMem.CreateCompatibleBitmap(&dc, sizeIcon.cx, sizeIcon.cy);
	}

	CBitmap* pBmpOriginal = dcMem.SelectObject(&bmpMem);

	if (!bAlphaBlend)
	{
		dcMem.FillRect(CRect(0, 0, sizeIcon.cx, sizeIcon.cy), &afxGlobalData.brBtnFace);
	}

	if (hIcon != NULL)
	{
		dcMem.DrawState(CPoint(0, 0), sizeIcon, hIcon, DSS_NORMAL, (CBrush*) NULL);
	}

	dcMem.SelectObject(pBmpOriginal);

	if (bAlphaBlend)
	{
		m_nBitsPerPixel = 32;
		PreMultiplyAlpha(bmpMem);
	}

	return AddImage(bmpMem);
}

BOOL CMFCToolBarImages::UpdateImage(int iImage, HBITMAP hbmp)
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (!m_bUserImagesList) // Only user images can be edited!
	{
		return FALSE;
	}

	CWindowDC dc(NULL);
	CBitmap bitmap;
	CDC memDCSrc;
	CDC memDCDst;

	memDCSrc.CreateCompatibleDC(&dc);
	memDCDst.CreateCompatibleDC(&dc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(m_hbmImageWell);
	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(hbmp);

	memDCDst.BitBlt(m_sizeImage.cx * iImage, 0, m_sizeImage.cx, m_sizeImage.cy, &memDCSrc, 0, 0, SRCCOPY);

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	m_bModified = TRUE;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	return TRUE;
}

BOOL CMFCToolBarImages::DeleteImage(int iImage)
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (!m_bUserImagesList) // Only user images can be edited!
	{
		return FALSE;
	}

	if (iImage < 0 || iImage >= GetCount()) // Wrong index
	{
		return FALSE;
	}

	// Get original bitmap attrbutes:
	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(m_hbmImageWell);
	if (hOldBitmapSrc == NULL)
	{
		return FALSE;
	}

	// Create a new bitmap compatibel with the source memory DC
	//(original bitmap SHOULD BE ALREADY SELECTED!):
	HBITMAP hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap(memDCSrc, bmp.bmWidth - m_sizeImage.cx, bmp.bmHeight);
	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return FALSE;
	}

	// Create memory destination DC and select a new bitmap:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		return FALSE;
	}

	// Copy original bitmap to new:

	if (iImage != 0)
	{
		memDCDst.BitBlt(0, 0, m_sizeImage.cx * iImage, bmp.bmHeight, &memDCSrc, 0, 0, SRCCOPY);
	}

	if (iImage != m_iCount - 1)
	{
		memDCDst.BitBlt(m_sizeImage.cx * iImage, 0, bmp.bmWidth -(m_iCount - iImage - 1) * m_sizeImage.cx, bmp.bmHeight, &memDCSrc, m_sizeImage.cx *(iImage + 1), 0, SRCCOPY);
	}

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	::DeleteObject(m_hbmImageWell);

	m_hbmImageWell = hNewBitmap;
	m_bModified = TRUE;

	UpdateCount();
	UpdateInternalImage(AFX_IMAGE_LIGHT);
	UpdateInternalImage(AFX_IMAGE_SHADOW);

	return TRUE;
}

HICON CMFCToolBarImages::ExtractIcon(int nIndex)
{
	if (nIndex < 0 || nIndex >= GetCount()) // Wrong index
	{
		return NULL;
	}

	UINT nFlags = (m_nBitsPerPixel == 32) ? 0 : ILC_MASK;

	switch (m_nBitsPerPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	CImageList images;
	images.Create(m_sizeImage.cx, m_sizeImage.cy, nFlags, 0, 0);

	HBITMAP hbmImageWellCopy = (HBITMAP) ::CopyImage(m_hbmImageWell, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

	images.Add(CBitmap::FromHandle(hbmImageWellCopy), m_clrTransparent == -1 ? afxGlobalData.clrBtnFace : m_clrTransparent);

	AfxDeleteObject((HGDIOBJ*)&hbmImageWellCopy);

	return images.ExtractIcon(nIndex);
}

COLORREF __stdcall CMFCToolBarImages::MapToSysColor(COLORREF color, BOOL bUseRGBQUAD)
{
	struct COLORMAP
	{
		// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
		DWORD rgbqFrom;
		int iSysColorTo;
	};
	static const COLORMAP sysColorMap[] = {
		// mapping from color in DIB to system color
		{ AFX_RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
		{ AFX_RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey
		{ AFX_RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey
		{ AFX_RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
	};
	const int nMaps = 4;

	// look for matching RGBQUAD color in original
	for (int i = 0; i < nMaps; i++)
	{
		if (color == sysColorMap[i].rgbqFrom)
		{
			return bUseRGBQUAD ? AFX_CLR_TO_RGBQUAD(afxGlobalData.GetColor(sysColorMap[i].iSysColorTo)) : afxGlobalData.GetColor(sysColorMap[i].iSysColorTo);
		}
	}

	return color;
}

COLORREF __stdcall CMFCToolBarImages::MapToSysColorAlpha(COLORREF color)
{
	BYTE r = GetRValue(color);
	BYTE g = GetGValue(color);
	BYTE b = GetBValue(color);

	const int nDelta = 10;

	if (abs(r - b) > nDelta || abs(r - g) > nDelta || abs(b - g) > nDelta)
	{
		return color;
	}

	return CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 1. +((double) r - 192) / 255, 1. +((double) g - 192) / 255, 1. +((double) b - 192) / 255);
}

COLORREF __stdcall CMFCToolBarImages::MapFromSysColor(COLORREF color, BOOL bUseRGBQUAD)
{
	struct COLORMAP
	{
		// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
		DWORD rgbTo;
		int iSysColorFrom;
	};
	static const COLORMAP sysColorMap[] = {
		// mapping from color in DIB to system color
		{ RGB(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
		{ RGB(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey
		{ RGB(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey
		{ RGB(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
	};
	const int nMaps = 4;

	// look for matching RGBQUAD color in original
	for (int i = 0; i < nMaps; i++)
	{
		COLORREF clrSystem = afxGlobalData.GetColor(sysColorMap[i].iSysColorFrom);

		if (bUseRGBQUAD)
		{
			if (color == AFX_CLR_TO_RGBQUAD(clrSystem))
			{
				return AFX_CLR_TO_RGBQUAD(sysColorMap[i].rgbTo);
			}
		}
		else
		{
			if (color == clrSystem)
			{
				return sysColorMap[i].rgbTo;
			}
		}
	}

	return color;
}

BOOL CMFCToolBarImages::Save(LPCTSTR lpszBmpFileName)
{
	if (!m_bUserImagesList || // Only user-defined bitmaps can be saved!
		m_hbmImageWell == NULL) // Not loaded yet!
	{
		return FALSE;
	}

	if (m_bReadOnly)
	{
		return FALSE;
	}

	CString strFile;
	if (lpszBmpFileName == NULL)
	{
		strFile = m_strUDLPath;
	}
	else
	{
		strFile = lpszBmpFileName;
	}

	if (!m_bModified && strFile == m_strUDLPath)
	{
		return TRUE;
	}

	HANDLE hDib = DDBToDIB(m_hbmImageWell, 0);
	if (hDib == NULL)
	{
		TRACE(_T("CMFCToolBarImages::Save Can't convert DDB to DIB\n"));
		return FALSE;
	}

	BOOL bSuccess = WriteDIB(strFile, hDib);
	::GlobalFree(hDib);

	if (!bSuccess)
	{
		return FALSE;
	}

	m_bModified = FALSE;
	return TRUE;
}

static BOOL __stdcall WriteDIB( LPCTSTR szFile, HANDLE hDIB)
{
	BITMAPFILEHEADER hdr;
	LPBITMAPINFOHEADER lpbi;

	if (!hDIB)
		return FALSE;

	CFile file;
	if ( !file.Open(szFile, CFile::modeWrite | CFile::modeCreate))
	{
		return FALSE;
	}

	lpbi = (LPBITMAPINFOHEADER) hDIB;

	int nColors = 1 << lpbi->biBitCount;
	if (nColors > 256 || lpbi->biBitCount == 32)
		nColors = 0;

	// Fill in the fields of the file header
	hdr.bfType = ((WORD)('M' << 8) | 'B'); // is always "BM"
	hdr.bfSize = (DWORD)(GlobalSize(hDIB) + sizeof(BITMAPFILEHEADER));
	hdr.bfReserved1 = 0;
	hdr.bfReserved2 = 0;
	hdr.bfOffBits = (DWORD)(sizeof( hdr ) + lpbi->biSize + nColors * sizeof(RGBQUAD));

	// Write the file header
	file.Write( &hdr, sizeof(hdr) );

	// Write the DIB header and the bits
	file.Write( lpbi, (UINT) GlobalSize(hDIB) );

	return TRUE;
}

static HANDLE __stdcall DDBToDIB(HBITMAP bitmap, DWORD dwCompression)
{
	BITMAP bm;
	BITMAPINFOHEADER bi;
	LPBITMAPINFOHEADER lpbi;
	DWORD dwLen;
	HANDLE hDIB;
	HANDLE handle;
	HDC hDC;
	HPALETTE hPal;

	// The function has no arg for bitfields
	if ( dwCompression == BI_BITFIELDS)
		return NULL;

	hPal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

	// Get bitmap information
	::GetObject(bitmap, sizeof(bm), (LPSTR)&bm);

	// Initialize the bitmapinfoheader
	bi.biSize = sizeof(BITMAPINFOHEADER);
	bi.biWidth = bm.bmWidth;
	bi.biHeight = bm.bmHeight;
	bi.biPlanes = 1;
	bi.biBitCount = (WORD)(bm.bmPlanes * bm.bmBitsPixel);
	bi.biCompression = dwCompression;
	bi.biSizeImage = 0;
	bi.biXPelsPerMeter = 0;
	bi.biYPelsPerMeter = 0;
	bi.biClrUsed = 0;
	bi.biClrImportant = 0;

	// Compute the size of the  infoheader and the color table
	int nColors = (1 << bi.biBitCount);
	if (nColors > 256 || bi.biBitCount == 32)
		nColors = 0;
	dwLen  = bi.biSize + nColors * sizeof(RGBQUAD);

	// We need a device context to get the DIB from
	hDC = ::CreateCompatibleDC(NULL);
	if (hDC == NULL)
	{
		return FALSE;
	}

	HBITMAP bmp = ::CreateBitmap(1, 1, 1, bi.biBitCount, NULL);
	if (bmp == NULL)
	{
		::DeleteDC(hDC);
		return NULL;
	}

	HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hDC, bmp);

	hPal = SelectPalette(hDC,hPal,FALSE);
	RealizePalette(hDC);

	// Allocate enough memory to hold bitmapinfoheader and color table
	hDIB = GlobalAlloc(GMEM_FIXED,dwLen);

	if (!hDIB)
	{
		::SelectPalette(hDC,hPal,FALSE);

		if (hOldBitmap != NULL)
		{
			::SelectObject(hDC, hOldBitmap);
		}

		::DeleteObject(bmp);
		::DeleteDC(hDC);
		return NULL;
	}

	lpbi = (LPBITMAPINFOHEADER)hDIB;

	*lpbi = bi;

	// Call GetDIBits with a NULL lpBits param, so the device driver
	// will calculate the biSizeImage field
	GetDIBits(hDC, bitmap, 0L, (DWORD)bi.biHeight,
		(LPBYTE)NULL, (LPBITMAPINFO)lpbi, (DWORD)DIB_RGB_COLORS);

	bi = *lpbi;

	// If the driver did not fill in the biSizeImage field, then compute it
	// Each scan line of the image is aligned on a DWORD(32bit) boundary
	if (bi.biSizeImage == 0){bi.biSizeImage = ((((bi.biWidth * bi.biBitCount) + 31) & ~31) / 8) * bi.biHeight;

	// If a compression scheme is used the result may infact be larger
	// Increase the size to account for this.
	if (dwCompression != BI_RGB)
		bi.biSizeImage = (bi.biSizeImage * 3) / 2;
	}

	// Realloc the buffer so that it can hold all the bits
	dwLen += bi.biSizeImage;
	handle = GlobalReAlloc(hDIB, dwLen, GMEM_MOVEABLE);
	if (handle != NULL)
		hDIB = handle;
	else
	{
		GlobalFree(hDIB);

		// Reselect the original palette
		SelectPalette(hDC,hPal,FALSE);
		if (hOldBitmap != NULL)
		{
			::SelectObject(hDC, hOldBitmap);
		}
		::DeleteObject(bmp);
		::DeleteDC(hDC);
		return NULL;
	}

	// Get the bitmap bits
	lpbi = (LPBITMAPINFOHEADER)hDIB;

	// FINALLY get the DIB
	BOOL bGotBits = GetDIBits( hDC, bitmap, 0L, // Start scan line
		(DWORD)bi.biHeight, // # of scan lines
		(LPBYTE)lpbi 			// address for bitmap bits
		+(bi.biSize + nColors * sizeof(RGBQUAD)),
		(LPBITMAPINFO)lpbi, // address of bitmapinfo
		(DWORD)DIB_RGB_COLORS); // Use RGB for color table

	if ( !bGotBits )
	{
		GlobalFree(hDIB);

		SelectPalette(hDC,hPal,FALSE);
		if (hOldBitmap != NULL)
		{
			::SelectObject(hDC, hOldBitmap);
		}
		::DeleteObject(bmp);
		::DeleteDC(hDC);
		return NULL;
	}

	// Convert color table to the standard 3-d colors:
	DWORD* pColorTable = (DWORD*)(((LPBYTE)lpbi) +(UINT) lpbi->biSize);
	for (int iColor = 0; iColor < nColors; iColor ++)
	{
		pColorTable[iColor] = CMFCToolBarImages::MapFromSysColor(pColorTable[iColor]);
	}

	SelectPalette(hDC,hPal,FALSE);

	if (hOldBitmap != NULL)
	{
		::SelectObject(hDC, hOldBitmap);
	}

	::DeleteObject(bmp);
	::DeleteDC(hDC);

	return hDIB;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarImages diagnostics

#ifdef _DEBUG
void CMFCToolBarImages::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_hbmImageWell != NULL);
}

void CMFCToolBarImages::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "\nm_bUserImagesList = " << m_bUserImagesList;
	dc << "\nm_sizeImage = " << m_sizeImage;

	if (m_bUserImagesList)
	{
		dc << "\nm_strUDLPath = " << m_strUDLPath;
	}

	if (dc.GetDepth() > 0)
	{
	}

	dc << "\n";
}

#endif

BOOL CMFCToolBarImages::CopyImageToClipboard(int iImage)
{
	try
	{
		CWindowDC dc(NULL);

		// Create a bitmap copy:
		CDC memDCDest;
		memDCDest.CreateCompatibleDC(NULL);

		CBitmap bitmapCopy;
		if (!bitmapCopy.CreateCompatibleBitmap(&dc, m_sizeImage.cx, m_sizeImage.cy))
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return FALSE;
		}

		CBitmap* pOldBitmapDest = memDCDest.SelectObject(&bitmapCopy);

		memDCDest.FillRect(CRect(0, 0, m_sizeImage.cx, m_sizeImage.cy), &afxGlobalData.brBtnFace);

		CAfxDrawState ds;
		PrepareDrawImage(ds, FALSE);

		Draw(&memDCDest, 0, 0, iImage);
		EndDrawImage(ds);

		memDCDest.SelectObject(pOldBitmapDest);

		if (!AfxGetMainWnd()->OpenClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return FALSE;
		}

		if (!::EmptyClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			::CloseClipboard();
			return FALSE;
		}

		HANDLE hclipData = ::SetClipboardData(CF_BITMAP, bitmapCopy.Detach());
		if (hclipData == NULL)
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			TRACE(_T("CMFCToolBarImages::CopyImageToClipboard error. Error code = %x\n"), GetLastError());
		}

		::CloseClipboard();
		return TRUE;
	}
	catch(...)
	{
		AfxMessageBox(IDP_AFXBARRES_INTERLAL_ERROR);
	}

	return FALSE;
}

BOOL CMFCToolBarImages::CopyTo(CMFCToolBarImages& dest)
{
	if (dest.m_bIsTemporary)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (dest.IsValid())
	{
		dest.Clear();
	}

	if (afxGlobalData.bIsWindowsVista)
	{
		BITMAP bmp;
		if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == sizeof(BITMAP))
		{
			CSize sizeImage (bmp.bmWidth, abs(bmp.bmHeight));

			// Create memory source DC and select an original bitmap:
			CDC memDCSrc;
			memDCSrc.CreateCompatibleDC(NULL);

			HBITMAP hOldBitmapSrc = (HBITMAP)memDCSrc.SelectObject(m_hbmImageWell);
			if (hOldBitmapSrc != NULL)
			{
				// Create a new bitmap compatible with the source memory DC
				// (original bitmap SHOULD BE ALREADY SELECTED!):
				HBITMAP hNewBitmap = NULL;

				DIBSECTION ds = {0};
				if (bmp.bmBitsPixel >= 24 && ::GetObject (m_hbmImageWell, sizeof (DIBSECTION), &ds) != 0)
				{
					BITMAPINFO bi = {0};
					bi.bmiHeader.biSize        = sizeof (BITMAPINFOHEADER);
					bi.bmiHeader.biWidth       = bmp.bmWidth;
					bi.bmiHeader.biHeight      = bmp.bmHeight;
					bi.bmiHeader.biPlanes      = bmp.bmPlanes;
					bi.bmiHeader.biBitCount    = bmp.bmBitsPixel;
					bi.bmiHeader.biCompression = BI_RGB;

					COLORREF* pBits = NULL;
					hNewBitmap = ::CreateDIBSection (
						memDCSrc, &bi, DIB_RGB_COLORS, (void **)&pBits,
						NULL, NULL);
				}
				else
				{
					hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap (memDCSrc,
						sizeImage.cx, sizeImage.cy);
				}

				if (hNewBitmap != NULL)
				{
					//------------------------------------------------------
					// Create memory destination DC and select a new bitmap:
					//------------------------------------------------------
					CDC memDCDst;
					memDCDst.CreateCompatibleDC (&memDCSrc);

					HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject (hNewBitmap);
					if (hOldBitmapDst != NULL)
					{
						//-----------------------------
						// Copy original bitmap to new:
						//-----------------------------
						memDCDst.BitBlt (0, 0, sizeImage.cx, sizeImage.cy,
							&memDCSrc, 0, 0, SRCCOPY);

						memDCDst.SelectObject (hOldBitmapDst);

						dest.m_hbmImageWell = hNewBitmap;
					}
					else
					{
						::DeleteObject (hNewBitmap);
					}
				}

				memDCSrc.SelectObject (hOldBitmapSrc);
			}
		}
	}
	else
	{
		dest.m_hbmImageWell = (HBITMAP) ::CopyImage(m_hbmImageWell, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		if (m_hbmImageLight != NULL)
		{
			dest.m_hbmImageLight = (HBITMAP) ::CopyImage(m_hbmImageLight, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		}
		if (m_hbmImageShadow != NULL)
		{
			dest.m_hbmImageShadow = (HBITMAP) ::CopyImage(m_hbmImageShadow, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		}
	}

	dest.m_sizeImage = m_sizeImage;
	dest.m_sizeImageDest = m_sizeImageDest;
	dest.m_bUserImagesList = m_bUserImagesList;
	dest.m_strUDLPath = m_strUDLPath;
	dest.m_bModified = m_bModified;
	dest.m_iCount = m_iCount;
	dest.m_clrTransparent = m_clrTransparent;
	dest.m_bReadOnly = m_bReadOnly;
	dest.m_clrImageShadow = m_clrImageShadow;
	dest.m_bFadeInactive = m_bFadeInactive;
	dest.m_nBitsPerPixel = m_nBitsPerPixel;
	dest.m_dblScale = m_dblScale;

	for (POSITION pos = m_lstOrigResIds.GetHeadPosition(); pos != NULL;)
	{
		UINT uiResId = m_lstOrigResIds.GetNext(pos);

		dest.m_lstOrigResIds.AddTail(uiResId);

		int iOffset = -1;
		if (m_mapOrigResOffsets.Lookup(uiResId, iOffset))
		{
			dest.m_mapOrigResOffsets.SetAt(uiResId, iOffset);
		}
	}

	for (POSITION posInst = m_lstOrigResInstances.GetHeadPosition(); posInst != NULL;)
	{
		HINSTANCE hInst = m_lstOrigResInstances.GetNext(posInst);
		dest.m_lstOrigResInstances.AddTail(hInst);
	}

	return TRUE;
}

void CMFCToolBarImages::Clear()
{
	if (m_bIsTemporary)
	{
		ASSERT(FALSE);
		return;
	}

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);
	m_hbmImageWell = NULL;
	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;
	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	m_lstOrigResIds.RemoveAll();
	m_mapOrigResOffsets.RemoveAll();
	m_lstOrigResInstances.RemoveAll();
	m_strUDLPath.Empty();

	m_bUserImagesList = FALSE;
	m_iCount = 0;
	m_bModified = FALSE;
	m_bIsGray = FALSE;
	m_nGrayImageLuminancePercentage = 0;
	m_nBitsPerPixel = 0;

	if (m_dblScale != 1.0)
	{
		m_sizeImage = m_sizeImageOriginal;
		m_sizeImageOriginal = CSize (0, 0);
		m_dblScale = 1.0;
	}
}

void __stdcall CMFCToolBarImages::TransparentBlt( HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
												 CDC* pDcSrc, int nXSrc, int nYSrc, COLORREF colorTransparent, int nWidthDest/* = -1*/, int nHeightDest/* = -1*/)
{
	int cx = nWidthDest == -1 ? nWidth : nWidthDest;
	int cy = nHeightDest == -1 ? nHeight : nHeightDest;

	if (!m_bIsRTL)
	{
		if (::TransparentBlt(hdcDest, nXDest, nYDest, cx, cy, pDcSrc->GetSafeHdc(), nXSrc, nYSrc, nWidth, nHeight, colorTransparent))
		{
			return;
		}
	}

	CDC dc, memDC, maskDC;
	dc.Attach( hdcDest );
	maskDC.CreateCompatibleDC(&dc);
	CBitmap maskBitmap;

	//add these to store return of SelectObject() calls
	CBitmap* pOldMemBmp = NULL;
	CBitmap* pOldMaskBmp = NULL;

	memDC.CreateCompatibleDC(&dc);
	CBitmap bmpImage;
	bmpImage.CreateCompatibleBitmap( &dc, cx, cy);
	pOldMemBmp = memDC.SelectObject( &bmpImage );

	if (nWidthDest == -1 ||(nWidthDest == nWidth && nHeightDest == nHeight))
	{
		memDC.BitBlt( 0,0,nWidth, nHeight, pDcSrc, nXSrc, nYSrc, SRCCOPY);
	}
	else
	{
		memDC.StretchBlt(0,0, nWidthDest, nHeightDest, pDcSrc, nXSrc, nYSrc, nWidth, nHeight, SRCCOPY);
	}

	// Create monochrome bitmap for the mask
	maskBitmap.CreateBitmap(cx, cy, 1, 1, NULL );
	pOldMaskBmp = maskDC.SelectObject( &maskBitmap );
	memDC.SetBkColor( colorTransparent );

	// Create the mask from the memory DC
	maskDC.BitBlt(0, 0, cx, cy, &memDC, 0, 0, SRCCOPY);

	// Set the background in memDC to black. Using SRCPAINT with black
	// and any other color results in the other color, thus making
	// black the transparent color
	memDC.SetBkColor(RGB(0,0,0));
	memDC.SetTextColor(RGB(255,255,255));
	memDC.BitBlt(0, 0, cx, cy, &maskDC, 0, 0, SRCAND);

	// Set the foreground to black. See comment above.
	dc.SetBkColor(RGB(255,255,255));
	dc.SetTextColor(RGB(0,0,0));

	dc.BitBlt(nXDest, nYDest, cx, cy, &maskDC, 0, 0, SRCAND);

	// Combine the foreground with the background
	dc.BitBlt(nXDest, nYDest, cx, cy, &memDC, 0, 0, SRCPAINT);

	if (pOldMaskBmp)
		maskDC.SelectObject( pOldMaskBmp );
	if (pOldMemBmp)
		memDC.SelectObject( pOldMemBmp );

	dc.Detach();
}

BOOL __stdcall CMFCToolBarImages::MapBmpTo3dColors( HBITMAP& hBmp, BOOL bUseRGBQUAD/* = TRUE*/, COLORREF clrSrc/* = (COLORREF)-1*/, COLORREF clrDest/* = (COLORREF)-1*/)
{
	if (hBmp == NULL)
	{
		return FALSE;
	}

	if (clrSrc != (COLORREF)-1 && clrDest == (COLORREF)-1)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = NULL;

	int iBitmapWidth;
	int iBitmapHeight;

	// Get original bitmap attrbutes:
	BITMAP bmp;
	if (::GetObject(hBmp, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(hBmp);
	if (hOldBitmapSrc == NULL)
	{
		return FALSE;
	}

	iBitmapWidth = bmp.bmWidth;
	iBitmapHeight = bmp.bmHeight;

	// Create a new bitmap compatibel with the source memory DC:
	// (original bitmap SHOULD BE ALREADY SELECTED!):
	HBITMAP hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap(memDCSrc, iBitmapWidth, iBitmapHeight);
	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return FALSE;
	}

	// Create memory destination DC:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		return FALSE;
	}

	// Copy original bitmap to new:
	memDCDst.BitBlt(0, 0, iBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);

	// Change a specific colors to system:
	for (int x = 0; x < iBitmapWidth; x ++)
	{
		for (int y = 0; y < iBitmapHeight; y ++)
		{
			COLORREF clrOrig = ::GetPixel(memDCDst, x, y);

			if (clrSrc != (COLORREF)-1)
			{
				if (clrOrig == clrSrc)
				{
					::SetPixel(memDCDst, x, y, clrDest);
				}
			}
			else
			{
				COLORREF clrNew = bmp.bmBitsPixel == 24 && !m_bDisableTrueColorAlpha ? MapToSysColorAlpha(clrOrig) : MapToSysColor(clrOrig, bUseRGBQUAD);

				if (clrOrig != clrNew)
				{
					::SetPixel(memDCDst, x, y, clrNew);
				}
			}
		}
	}

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	::DeleteObject(hBmp);
	hBmp = hNewBitmap;

	return TRUE;
}

BOOL CMFCToolBarImages::MapTo3dColors(BOOL bUseRGBQUAD/* = TRUE*/, COLORREF clrSrc/* = (COLORREF)-1*/, COLORREF clrDest/* = (COLORREF)-1*/)
{
	return MapBmpTo3dColors(m_hbmImageWell, bUseRGBQUAD, clrSrc, clrDest);
}

void CMFCToolBarImages::CopyTemp(CMFCToolBarImages& imagesDest)
{
	imagesDest.Clear();
	imagesDest.m_bIsTemporary = TRUE;

	imagesDest.m_sizeImage = m_sizeImage;
	imagesDest.m_sizeImageDest = m_sizeImageDest;
	imagesDest.m_hbmImageWell = m_hbmImageWell;
	imagesDest.m_bUserImagesList = m_bUserImagesList;
	imagesDest.m_iCount = m_iCount;
	imagesDest.m_bReadOnly = TRUE;
	imagesDest.m_nBitsPerPixel = m_nBitsPerPixel;
}

BOOL CMFCToolBarImages::UpdateInternalImage(int nIndex)
{
	HBITMAP& hbmpInternal = (nIndex == AFX_IMAGE_LIGHT) ? m_hbmImageLight : m_hbmImageShadow;

	if (nIndex == AFX_IMAGE_LIGHT)
	{
		if ((m_nBitsPerPixel > 4 && !m_bAlwaysLight) || m_nBitsPerPixel == 0)
		{
			// Down't fade 256+ or unknown bitmaps
			return FALSE;
		}
	}

	AfxDeleteObject((HGDIOBJ*)&hbmpInternal);
	hbmpInternal = NULL;

	if (m_hbmImageWell == NULL)
	{
		return TRUE;
	}

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		return TRUE;
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	int iBitmapWidth = bmp.bmWidth;
	int iBitmapHeight = bmp.bmHeight;

	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(m_hbmImageWell);
	if (hOldBitmapSrc == NULL)
	{
		return FALSE;
	}

	// Create memory destination DC and select a new bitmap:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	BITMAPINFO bi;

	// Fill in the BITMAPINFOHEADER
	bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bi.bmiHeader.biWidth = iBitmapWidth;
	bi.bmiHeader.biHeight = iBitmapHeight;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = iBitmapWidth * iBitmapHeight;
	bi.bmiHeader.biXPelsPerMeter = 0;
	bi.bmiHeader.biYPelsPerMeter = 0;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;

	COLORREF* pBits = NULL;
	hbmpInternal = CreateDIBSection(memDCDst.m_hDC, &bi, DIB_RGB_COLORS, (void **)&pBits, NULL, NULL);

	if (hbmpInternal == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return FALSE;
	}

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hbmpInternal);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hbmpInternal);
		hbmpInternal = NULL;
		return FALSE;
	}

	// Copy original bitmap to new:
	COLORREF clrTransparent = m_nBitsPerPixel == 32 ? (COLORREF) -1 : m_clrTransparent;

	memDCDst.BitBlt(0, 0, iBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);

	if (nIndex == AFX_IMAGE_LIGHT)
	{
		CDrawingManager dm(memDCDst);

		dm.HighlightRect(CRect(0, 0, iBitmapWidth, iBitmapHeight), m_nLightPercentage, clrTransparent == -1 ? afxGlobalData.clrBtnFace : clrTransparent);
	}
	else
	{
		COLORREF clrTr = clrTransparent == -1 ? afxGlobalData.clrBtnFace : clrTransparent;

		COLORREF clrHL = CMFCVisualManager::GetInstance()->GetToolbarHighlightColor();
		COLORREF clrShadow = afxGlobalData.m_nBitsPerPixel <= 8 ? afxGlobalData.clrBtnShadow : CDrawingManager::PixelAlpha(clrHL, 67);

		for (int x = 0; x < iBitmapWidth; x++)
		{
			for (int y = 0; y < iBitmapHeight; y++)
			{
				COLORREF clr = memDCDst.GetPixel(x, y);
				if (clr != clrTr)
				{
					memDCDst.SetPixel(x, y, clrShadow);
				}
			}
		}
	}

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	return TRUE;
}

BOOL __stdcall CMFCToolBarImages::PreMultiplyAlpha(HBITMAP hbmp, BOOL bAutoCheckPremlt)
{
	DIBSECTION ds;
	if (::GetObject(hbmp, sizeof(DIBSECTION), &ds) == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (ds.dsBm.bmBitsPixel != 32)
	{
		return FALSE;
	}

	if (ds.dsBm.bmBits == NULL)
	{
		return FALSE;
	}

	int i = 0;

	RGBQUAD* pBits = (RGBQUAD*) ds.dsBm.bmBits;
	const int length = ds.dsBm.bmWidth * ds.dsBm.bmHeight;

	if (bAutoCheckPremlt)
	{
		BOOL bPremultiply = FALSE;

		RGBQUAD* pBit = pBits;
		for (i = 0; i < length; i++)
		{
			if (pBit->rgbRed   > pBit->rgbReserved || pBit->rgbGreen > pBit->rgbReserved || pBit->rgbBlue  > pBit->rgbReserved)
			{
				bPremultiply = TRUE;
				break;
			}

			pBit++;
		}

		if (!bPremultiply)
		{
			return TRUE;
		}
	}

	// Premultiply the R,G and B values with the Alpha channel values:
	RGBQUAD* pBit = pBits;
	for (i = 0; i < length; i++)
	{
		pBit->rgbRed   = (BYTE)(pBit->rgbRed   * pBit->rgbReserved / 255);
		pBit->rgbGreen = (BYTE)(pBit->rgbGreen * pBit->rgbReserved / 255);
		pBit->rgbBlue  = (BYTE)(pBit->rgbBlue  * pBit->rgbReserved / 255);
		pBit++;
	}

	return TRUE;
}

BOOL CMFCToolBarImages::PreMultiplyAlpha(HBITMAP hbmp)
{
	return PreMultiplyAlpha(hbmp, m_bAutoCheckPremlt);
}

BOOL CMFCToolBarImages::CreateFromImageList(const CImageList& imageList)
{
	ENSURE(imageList.GetSafeHandle() != NULL);
	ENSURE(imageList.GetImageCount() > 0);

	Clear();

	IMAGEINFO info;
	imageList.GetImageInfo(0, &info);

	CRect rectImage = info.rcImage;
	m_sizeImage = rectImage.Size();

	for (int i = 0; i < imageList.GetImageCount(); i++)
	{
		HICON hIcon = ((CImageList&) imageList).ExtractIcon(i);
		ENSURE(hIcon != NULL);

		AddIcon(hIcon);

		::DestroyIcon(hIcon);
	}

	return TRUE;
}

BOOL __stdcall CMFCToolBarImages::Is32BitTransparencySupported()
{
	return TRUE;
}

BOOL CMFCToolBarImages::GrayImages(int nGrayImageLuminancePercentage)
{
	m_bIsGray = TRUE;
	m_nGrayImageLuminancePercentage = nGrayImageLuminancePercentage;

	if (m_hbmImageWell == NULL)
	{
		return TRUE;
	}

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		return TRUE;
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	int iBitmapWidth = bmp.bmWidth;
	int iBitmapHeight = bmp.bmHeight;

	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(m_hbmImageWell);
	if (hOldBitmapSrc == NULL)
	{
		return FALSE;
	}

	// Create memory destination DC and select a new bitmap:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	BITMAPINFO bi;

	// Fill in the BITMAPINFOHEADER
	bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bi.bmiHeader.biWidth = iBitmapWidth;
	bi.bmiHeader.biHeight = iBitmapHeight;
	bi.bmiHeader.biPlanes = 1;
	bi.bmiHeader.biBitCount = 32;
	bi.bmiHeader.biCompression = BI_RGB;
	bi.bmiHeader.biSizeImage = iBitmapWidth * iBitmapHeight;
	bi.bmiHeader.biXPelsPerMeter = 0;
	bi.bmiHeader.biYPelsPerMeter = 0;
	bi.bmiHeader.biClrUsed = 0;
	bi.bmiHeader.biClrImportant = 0;

	COLORREF* pBits = NULL;
	HBITMAP hNewBitmap = CreateDIBSection(memDCDst.m_hDC, &bi, DIB_RGB_COLORS, (void **)&pBits, NULL, NULL);

	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return FALSE;
	}

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		hNewBitmap = NULL;
		return FALSE;
	}

	// Copy original bitmap to new:
	memDCDst.BitBlt(0, 0, iBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);

	int nPercentage = m_nGrayImageLuminancePercentage <= 0 ? 130 : m_nGrayImageLuminancePercentage;

	if (m_nBitsPerPixel == 32)
	{
		DIBSECTION ds;
		if (::GetObject(hNewBitmap, sizeof(DIBSECTION), &ds) == 0)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBitsPixel != 32)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBits == NULL)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		RGBQUAD* pBits32 = (RGBQUAD*) ds.dsBm.bmBits;

		// Premultiply the R,G and B values with the Alpha channel values:
		for (int i = 0; i < ds.dsBm.bmWidth * ds.dsBm.bmHeight; i++)
		{
			RGBQUAD* pBit = pBits32 + i;

			double H,S,L;
			CDrawingManager::RGBtoHSL(RGB(pBit->rgbRed, pBit->rgbGreen, pBit->rgbBlue), &H, &S, &L);
			COLORREF color = CDrawingManager::PixelAlpha(CDrawingManager::HLStoRGB_ONE(H,L,0), .01 * nPercentage, .01 * nPercentage, .01 * nPercentage);

			pBit->rgbRed = (BYTE)(GetRValue(color) * pBit->rgbReserved / 255);
			pBit->rgbGreen = (BYTE)(GetGValue(color) * pBit->rgbReserved / 255);
			pBit->rgbBlue = (BYTE)(GetBValue(color) * pBit->rgbReserved / 255);
		}
	}
	else
	{
		CDrawingManager dm(memDCDst);

		dm.GrayRect(CRect(0, 0, iBitmapWidth, iBitmapHeight), nPercentage, m_clrTransparent == -1 ? afxGlobalData.clrBtnFace : m_clrTransparent);
	}

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	::DeleteObject(m_hbmImageWell);
	m_hbmImageWell = hNewBitmap;

	return TRUE;
}

BOOL __stdcall CMFCToolBarImages::MirrorBitmap(HBITMAP& hbmp, int cxImage)
{
	if (hbmp == NULL)
	{
		return TRUE;
	}

	BITMAP bmp;
	if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	const int cx = bmp.bmWidth;
	const int cy = bmp.bmHeight;
	const int iCount = cx / cxImage;

	if (bmp.bmBitsPixel == 32)
	{
		DIBSECTION ds;
		if (::GetObject(hbmp, sizeof(DIBSECTION), &ds) == 0)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBitsPixel != 32)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBits == NULL)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		DWORD* pBits = (DWORD*) ds.dsBm.bmBits;

		for (int iImage = 0; iImage < iCount; iImage++)
		{
			for (int y = 0; y < cy; y++)
			{
				DWORD* pRow1 = pBits + cx * y + iImage * cxImage;
				DWORD* pRow2 = pRow1 + cxImage - 1;

				for (int x = 0; x < cxImage / 2; x++)
				{
					DWORD color = *pRow1;

					*pRow1 = *pRow2;
					*pRow2 = color;

					pRow1++;
					pRow2--;
				}
			}
		}

		return TRUE;
	}

	CDC memDC;
	memDC.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmap = (HBITMAP) memDC.SelectObject(hbmp);
	if (hOldBitmap == NULL)
	{
		return FALSE;
	}

	for (int iImage = 0; iImage < iCount; iImage++)
	{
		for (int y = 0; y < cy; y++)
		{
			int x1 = iImage * cxImage;
			int x2 = x1 + cxImage - 1;

			for (int x = 0; x < cxImage / 2; x++)
			{
				COLORREF color = memDC.GetPixel(x1, y);

				memDC.SetPixel(x1, y, memDC.GetPixel(x2, y));
				memDC.SetPixel(x2, y, color);

				x1++;
				x2--;
			}
		}
	}

	memDC.SelectObject(hOldBitmap);

	return TRUE;
}

BOOL CMFCToolBarImages::Mirror()
{
	if (!MirrorBitmap(m_hbmImageWell, m_sizeImage.cx))
	{
		return FALSE;
	}

	if (m_hbmImageLight != NULL)
	{
		MirrorBitmap(m_hbmImageLight, m_sizeImage.cx);
	}

	if (m_hbmImageShadow != NULL)
	{
		MirrorBitmap(m_hbmImageShadow, m_sizeImage.cx);
	}

	return TRUE;
}

BOOL __stdcall CMFCToolBarImages::MirrorBitmapVert(HBITMAP& hbmp, int cyImage)
{
	if (hbmp == NULL)
	{
		return TRUE;
	}

	BITMAP bmp;
	if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
	{
		return FALSE;
	}

	const int cx = bmp.bmWidth;
	const int cy = bmp.bmHeight;
	const int iCount = cy / cyImage;

	if (bmp.bmBitsPixel >= 16)
	{
		DIBSECTION ds;
		if (::GetObject(hbmp, sizeof(DIBSECTION), &ds) == 0)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBitsPixel != bmp.bmBitsPixel)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		if (ds.dsBm.bmBits == NULL)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		LPBYTE pBits    = (LPBYTE)ds.dsBm.bmBits;
		DWORD pitch     = cx * ds.dsBm.bmBitsPixel / 8;
		if (pitch % 4)
		{
			pitch = (DWORD)(pitch / 4) * 4 + 4;
		}

		LPBYTE pRowTemp = new BYTE[pitch];

		for (int iImage = 0; iImage < iCount; iImage++)
		{
			LPBYTE pRowBits1 = pBits + iImage * cyImage * pitch;
			LPBYTE pRowBits2 = pRowBits1 +(cyImage - 1) * pitch;

			for (int y = 0; y < cyImage / 2; y++)
			{
				memcpy(pRowTemp, pRowBits1, pitch);
				memcpy(pRowBits1, pRowBits2, pitch);
				memcpy(pRowBits2, pRowTemp, pitch);

				pRowBits1 += pitch;
				pRowBits2 -= pitch;
			}
		}

		delete [] pRowTemp;

		return TRUE;
	}

	CDC memDC;
	memDC.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmap = (HBITMAP) memDC.SelectObject(hbmp);
	if (hOldBitmap == NULL)
	{
		return FALSE;
	}

	for (int iImage = 0; iImage < iCount; iImage++)
	{
		int y1 = iImage * cyImage;
		int y2 = y1 + cyImage - 1;

		for (int y = 0; y < cyImage / 2; y++)
		{
			for (int x = 0; x < cx; x++)
			{
				COLORREF color = memDC.GetPixel(x, y1);

				memDC.SetPixel(x, y1, memDC.GetPixel(x, y2));
				memDC.SetPixel(x, y2, color);
			}

			y1++;
			y2--;
		}
	}

	memDC.SelectObject(hOldBitmap);

	return TRUE;
}

BOOL CMFCToolBarImages::MirrorVert()
{
	if (!MirrorBitmapVert(m_hbmImageWell, m_sizeImage.cy))
	{
		return FALSE;
	}

	if (m_hbmImageLight != NULL)
	{
		MirrorBitmapVert(m_hbmImageLight, m_sizeImage.cy);
	}

	if (m_hbmImageShadow != NULL)
	{
		MirrorBitmapVert(m_hbmImageShadow, m_sizeImage.cy);
	}

	return TRUE;
}

void __stdcall CMFCToolBarImages::EnableRTL(BOOL bIsRTL/* = TRUE*/)
{
	m_bIsRTL = bIsRTL;
}

void CMFCToolBarImages::AdaptColors(COLORREF clrBase, COLORREF clrTone)
{
	double dSrcH, dSrcS, dSrcL;
	CDrawingManager::RGBtoHSL(clrBase, &dSrcH, &dSrcS, &dSrcL);

	double dDestH, dDestS, dDestL;
	CDrawingManager::RGBtoHSL(clrTone, &dDestH, &dDestS, &dDestL);

	double DH = dDestH - dSrcH;
	double DL = dDestL - dSrcL;
	double DS = dDestS - dSrcS;

	if (m_nBitsPerPixel == 32)
	{
		DIBSECTION ds;
		if (::GetObject(m_hbmImageWell, sizeof(DIBSECTION), &ds) == 0)
		{
			ASSERT(FALSE);
			return;
		}

		if (ds.dsBm.bmBitsPixel != 32)
		{
			ASSERT(FALSE);
			return;
		}

		if (ds.dsBm.bmBits == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		RGBQUAD* pBits = (RGBQUAD*) ds.dsBm.bmBits;

		for (int i = 0; i < ds.dsBm.bmWidth * ds.dsBm.bmHeight; i++)
		{
			RGBQUAD* pBit = pBits + i;

			if (pBit->rgbReserved == 0)
			{
				continue;
			}

			COLORREF clrOrig = RGB(pBit->rgbRed, pBit->rgbGreen, pBit->rgbBlue);

			double H,S,L;
			CDrawingManager::RGBtoHSL(clrOrig, &H, &S, &L);

			double HNew = max(0, min(1., H + DH));
			double SNew = max(0, min(1., S + DS));
			double LNew = max(0, min(1., L + DL));

			COLORREF color = CDrawingManager::HLStoRGB_ONE(HNew, dDestH > 0.5 ? L : LNew, SNew);

			pBit->rgbRed = (BYTE)(GetRValue(color));
			pBit->rgbGreen = (BYTE)(GetGValue(color));
			pBit->rgbBlue = (BYTE)(GetBValue(color));
		}

		return;
	}

	// Create memory source DC and select an original bitmap:
	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = NULL;

	int iBitmapWidth;
	int iBitmapHeight;

	// Get original bitmap attrbutes:
	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		return;
	}

	hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(m_hbmImageWell);
	if (hOldBitmapSrc == NULL)
	{
		return;
	}

	iBitmapWidth = bmp.bmWidth;
	iBitmapHeight = bmp.bmHeight;

	// Create a new bitmap compatibel with the source memory DC:
	//(original bitmap SHOULD BE ALREADY SELECTED!):
	HBITMAP hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap(memDCSrc, iBitmapWidth, iBitmapHeight);
	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return;
	}

	// Create memory destination DC:
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		return;
	}

	// Copy original bitmap to new:
	memDCDst.BitBlt(0, 0, iBitmapWidth, iBitmapHeight, &memDCSrc, 0, 0, SRCCOPY);

	COLORREF clrTransparent = m_clrTransparent == (COLORREF)-1 ? afxGlobalData.clrBtnFace : m_clrTransparent;

	for (int x = 0; x < iBitmapWidth; x ++)
	{
		for (int y = 0; y < iBitmapHeight; y ++)
		{
			COLORREF clrOrig = ::GetPixel(memDCDst, x, y);

			if (clrOrig == clrTransparent)
			{
				continue;
			}

			double H, L, S;
			CDrawingManager::RGBtoHSL(clrOrig, &H, &S, &L);

			double HNew = max(0, min(1., H + DH));
			double SNew = max(0, min(1., S + DS));
			double LNew = max(0, min(1., L + DL));

			COLORREF clrNew = CDrawingManager::HLStoRGB_ONE(HNew, dDestH > 0.5 ? L : LNew, SNew);

			if (clrOrig != clrNew)
			{
				::SetPixel(memDCDst, x, y, clrNew);
			}
		}
	}

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	::DeleteObject(m_hbmImageWell);
	m_hbmImageWell = hNewBitmap;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;
}

HRGN __stdcall CMFCToolBarImages::CreateRegionFromImage(HBITMAP hbmp, COLORREF clrTransparent)
{
	if (hbmp == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	BITMAP bmp;
	if (::GetObject(hbmp, sizeof(BITMAP), &bmp) == 0)
	{
		ASSERT(FALSE);
		return NULL;
	}

	CDC dc;
	dc.CreateCompatibleDC(NULL);

	HBITMAP hbmpOld = (HBITMAP) dc.SelectObject(hbmp);

	int iBitmapWidth = bmp.bmWidth;
	int iBitmapHeight = bmp.bmHeight;

	CRgn rgnAll;
	rgnAll.CreateRectRgn(0, 0, iBitmapWidth, iBitmapHeight);

	for (int y = 0; y < iBitmapHeight; y++)
	{
		for (int x = 0; x < iBitmapWidth; x++)
		{
			COLORREF color = dc.GetPixel(x, y);

			if (color == clrTransparent)
			{
				CRgn rgnPoint;
				rgnPoint.CreateRectRgn(x, y, x + 1, y + 1);

				rgnAll.CombineRgn(&rgnAll, &rgnPoint, RGN_DIFF);
			}
		}
	}

	dc.SelectObject(hbmpOld);

	return(HRGN) rgnAll.Detach();
}

void CMFCToolBarImages::SetSingleImage()
{
	if (m_hbmImageWell == NULL)
	{
		return;
	}

	BITMAP bmp;
	if (::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmp) == 0)
	{
		ASSERT(FALSE);
		return;
	}

	m_sizeImage.cx = bmp.bmWidth;
	m_sizeImage.cy = bmp.bmHeight;

	m_iCount = 1;

	UpdateInternalImage(AFX_IMAGE_LIGHT);
	UpdateInternalImage(AFX_IMAGE_SHADOW);
}
//////////////////////////////////////////////////////////////////////
// CPngImage

CImage* CPngImage::m_pImage;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPngImage::CPngImage()
{
}

CPngImage::~CPngImage()
{
}

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

BOOL CPngImage::Load(UINT uiResID, HINSTANCE hinstRes)
{
	return Load(MAKEINTRESOURCE(uiResID), hinstRes);
}

BOOL CPngImage::Load(LPCTSTR lpszResourceName, HINSTANCE hinstRes)
{
	if (hinstRes == NULL)
	{
		hinstRes = AfxFindResourceHandle(lpszResourceName, CMFCToolBarImages::m_strPngResType);
	}

	HRSRC hRsrc = ::FindResource(hinstRes, lpszResourceName, CMFCToolBarImages::m_strPngResType);
	if (hRsrc == NULL)
	{
		return FALSE;
	}

	HGLOBAL hGlobal = LoadResource(hinstRes, hRsrc);
	if (hGlobal == NULL)
	{
		return FALSE;
	}

	LPVOID lpBuffer = ::LockResource(hGlobal);
	if (lpBuffer == NULL)
	{
		FreeResource(hGlobal);
		return FALSE;
	}

	BOOL bRes = LoadFromBuffer((LPBYTE) lpBuffer, (UINT) ::SizeofResource(hinstRes, hRsrc));

	UnlockResource(hGlobal);
	FreeResource(hGlobal);

	return bRes;
}
//*******************************************************************************
BOOL CPngImage::LoadFromFile(LPCTSTR lpszPath)
{
	if (CMFCToolBarImages::m_bMultiThreaded)
	{
		CMFCToolBarImages::m_CriticalSection.Lock();
	}

	BOOL bRes = FALSE;

	if (m_pImage == NULL)
	{
		m_pImage = new CImage;
		ENSURE(m_pImage != NULL);
	}

	if (m_pImage->Load(lpszPath) == S_OK)
	{
		bRes = Attach(m_pImage->Detach());
	}

	if (CMFCToolBarImages::m_bMultiThreaded)
	{
		CMFCToolBarImages::m_CriticalSection.Unlock();
	}

	return bRes;
}
//*******************************************************************************
BOOL CPngImage::LoadFromBuffer(LPBYTE lpBuffer, UINT uiSize)
{
	ASSERT(lpBuffer != NULL);

	HGLOBAL hRes = ::GlobalAlloc(GMEM_MOVEABLE, uiSize);
	if (hRes == NULL)
	{
		return FALSE;
	}

	IStream* pStream = NULL;
	LPVOID lpResBuffer = ::GlobalLock(hRes);
	ASSERT (lpResBuffer != NULL);

	memcpy(lpResBuffer, lpBuffer, uiSize);

	HRESULT hResult = ::CreateStreamOnHGlobal(hRes, FALSE, &pStream);

	if (hResult != S_OK)
	{
		return FALSE;
	}

	if (CMFCToolBarImages::m_bMultiThreaded)
	{
		CMFCToolBarImages::m_CriticalSection.Lock();
	}

	if (m_pImage == NULL)
	{
		m_pImage = new CImage;
		ENSURE(m_pImage != NULL);
	}

	m_pImage->Load(pStream);
	pStream->Release();

	BOOL bRes = Attach(m_pImage->Detach());

	if (CMFCToolBarImages::m_bMultiThreaded)
	{
		CMFCToolBarImages::m_CriticalSection.Unlock();
	}

	return bRes;
}

HBITMAP CMFCToolBarImages::Copy(HBITMAP hbmpSrc)
{
	if (hbmpSrc == NULL)
	{
		ASSERT (FALSE);
		return NULL;
	}

	if (!afxGlobalData.bIsWindowsVista)
	{
		return (HBITMAP) ::CopyImage(hbmpSrc, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
	}

	//-------------------------------------------------------
	// Windows Vista has some problems in ::CopyImage method,
	// copy bitmap not using this method:
	//-------------------------------------------------------

	CDC memDCSrc;
	memDCSrc.CreateCompatibleDC(NULL);

	HBITMAP hOldBitmapSrc = (HBITMAP) memDCSrc.SelectObject(hbmpSrc);
	if (hOldBitmapSrc == NULL)
	{
		return NULL;
	}

	BITMAP bmp;
	::GetObject(hbmpSrc, sizeof(BITMAP), &bmp);

	//----------------------------------------------------------
	// Create a new bitmap compatibel with the source memory DC:
	//----------------------------------------------------------
	HBITMAP hNewBitmap = (HBITMAP) ::CreateCompatibleBitmap(memDCSrc, bmp.bmWidth, bmp.bmHeight);
	if (hNewBitmap == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		return NULL;
	}

	//------------------------------------------------------
	// Create memory destination DC and select a new bitmap:
	//------------------------------------------------------
	CDC memDCDst;
	memDCDst.CreateCompatibleDC(&memDCSrc);

	HBITMAP hOldBitmapDst = (HBITMAP) memDCDst.SelectObject(hNewBitmap);
	if (hOldBitmapDst == NULL)
	{
		memDCSrc.SelectObject(hOldBitmapSrc);
		::DeleteObject(hNewBitmap);
		return NULL;
	}

	//-----------------------------
	// Copy original bitmap to new:
	//-----------------------------
	memDCDst.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight, &memDCSrc, 0, 0, SRCCOPY);

	memDCDst.SelectObject(hOldBitmapDst);
	memDCSrc.SelectObject(hOldBitmapSrc);

	return hNewBitmap;
}

BOOL CMFCToolBarImages::SmoothResize(double dblImageScale)
{
	if (m_hbmImageWell == NULL)
	{
		return FALSE;
	}

	if (m_nBitsPerPixel < 24)
	{
		return FALSE;
	}

	if (dblImageScale == 0.0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (dblImageScale == 1.0)
	{
		return TRUE;
	}

	CSize sizeNew((int)(.5 + m_sizeImage.cx * dblImageScale), (int)(.5 + m_sizeImage.cy * dblImageScale));

	if (sizeNew == m_sizeImage || m_sizeImage.cx <= 0 || m_sizeImage.cy <= 0 || sizeNew.cx <= 0 || sizeNew.cy <= 0)
	{
		return TRUE;
	}

	int nImageCount = GetCount();
	if (nImageCount == 0)
	{
		return TRUE;
	}

	BOOL bInvert = FALSE;
	CSize  sizeIW(0, 0);
	{
		BITMAP bmp;
		if (::GetObject(GetImageWell(), sizeof(BITMAP), &bmp) == 0)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		sizeIW.cx = bmp.bmWidth;
		sizeIW.cy = abs(bmp.bmHeight);
		bInvert = bmp.bmHeight < 0;
	}

	m_dblScale *= dblImageScale;

	CPoint offSrc(m_sizeImage.cx, 0);
	CPoint offDst(0, 0);

	if (nImageCount == 1)
	{
		if (sizeIW.cy > m_sizeImage.cy)
		{
			nImageCount = sizeIW.cy / m_sizeImage.cy;
			offSrc = CPoint(0, m_sizeImage.cy);
		}
	}


	HBITMAP hBmpSrc = CDrawingManager::CreateBitmap_32(m_hbmImageWell, m_clrTransparent);
	if (hBmpSrc == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CSize sizeNewIW(sizeNew);
	if (offSrc.x > 0)
	{
		sizeNewIW.cx *= nImageCount;
		offDst.x = sizeNew.cx;
	}
	else
	{
		sizeNewIW.cy *= nImageCount;
		offDst.y = sizeNew.cy;
	}

	if (bInvert)
	{
		sizeNewIW.cy = -sizeNewIW.cy;
	}

	HBITMAP hBmpDst = CDrawingManager::CreateBitmap_32(sizeNewIW, NULL);

	sizeNewIW.cy = abs(sizeNewIW.cy);

	if (hBmpDst == NULL)
	{
		ASSERT(FALSE);
		::DeleteObject(hBmpSrc);
		return FALSE;
	}

	CMFCZoomKernel::XFilterType ft = dblImageScale < 1.0
		? CMFCZoomKernel::e_FilterTypeLanczos3
		: CMFCZoomKernel::e_FilterTypeMitchell;


	CMFCScanlinerBitmap ms;
	ms.attach(hBmpSrc);
	CMFCScanlinerBitmap md;
	md.attach(hBmpDst);

	DWORD channel = ms.channels();

	CMFCZoomKernel KernelX;
	KernelX.Create(m_sizeImage.cx, sizeNew.cx, 0, m_sizeImage.cx, ft);

	CMFCZoomKernel KernelY;
	KernelY.Create(m_sizeImage.cy, sizeNew.cy, 0, m_sizeImage.cy, ft);

	double* values  = new double[channel];
	double* values2 = new double[channel];

	CPoint offSrcSum(0, 0);
	CPoint offDstSum(0, 0);

	for (int index = 0; index < nImageCount; index++)
	{
		const DWORD val_size   = sizeof(double) * channel;
		const DWORD offsetDstX = offDstSum.x * channel;

		for (DWORD dy = 0; dy < (DWORD)sizeNew.cy; dy++)
		{
			const CMFCZoomKernel::XKernelList& listY = KernelY[dy];

			LPBYTE pRowDst = md[dy + offDstSum.y] + offsetDstX;

			for (DWORD dx = 0; dx < (DWORD)sizeNew.cx; dx++)
			{
				const CMFCZoomKernel::XKernelList& listX = KernelX[dx];

				memset(values, 0, val_size);

				for (DWORD sy = 0; sy < listY.count; sy++)
				{
					const CMFCZoomKernel::XKernel& statY = listY.stat[sy];

					const LPBYTE pRowSrc = ms[statY.pixel + offSrcSum.y];
					double weight    = statY.weight;

					memset(values2, 0, val_size);

					for (DWORD sx = 0; sx < listX.count; sx++)
					{
						const CMFCZoomKernel::XKernel& statX = listX.stat[sx];

						LPBYTE pRowSrc2 = pRowSrc + (statX.pixel + offSrcSum.x) * channel;
						double weight2    = statX.weight;

						for(DWORD c = 0; c < channel; c++)
						{
							values2[c] += (double)(*pRowSrc2) * weight2;
							pRowSrc2++;
						}
					}

					for(DWORD c = 0; c < channel; c++)
					{
						values[c] += values2[c] * weight;
					}
				}

				if (channel == 4)
				{
					values[0] = min(values[0], values[3]);
					values[1] = min(values[1], values[3]);
					values[2] = min(values[2], values[3]);
				}

				for(DWORD c = 0; c < channel; c++)
				{
					*pRowDst = (BYTE)clamp_to_byte(values[c]);
					pRowDst++;
				}
			}
		}

		offSrcSum.x += offSrc.x;
		offSrcSum.y += offSrc.y;
		offDstSum.x += offDst.x;
		offDstSum.y += offDst.y;
	}

	delete [] values;
	delete [] values2;

	::DeleteObject(hBmpSrc);

	int nOldCount = m_iCount;

	if (m_sizeImageOriginal == CSize(0, 0))
	{
		m_sizeImageOriginal = m_sizeImage;
	}

	SetImageSize(sizeNew);
	m_clrTransparentOriginal = m_clrTransparent;
	m_clrTransparent = (COLORREF)-1;
	m_hbmImageWell = hBmpDst;
	m_iCount = nOldCount;
	m_nBitsPerPixel = 32;
	UpdateInternalImage(AFX_IMAGE_LIGHT);
	UpdateInternalImage(AFX_IMAGE_SHADOW);

	return IsValid();
}

BOOL CMFCToolBarImages::ConvertTo32Bits(COLORREF clrTransparent)
{
	if (!IsValid())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_nBitsPerPixel == 32)
	{
		return TRUE;
	}

	HBITMAP hbmpNew = CDrawingManager::CreateBitmap_32(m_hbmImageWell, clrTransparent == (COLORREF)-1 ? m_clrTransparent : clrTransparent);
	if (hbmpNew == NULL)
	{
		return FALSE;
	}

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);

	m_hbmImageWell = hbmpNew;
	m_clrTransparent = (COLORREF)-1;
	m_nBitsPerPixel = 32;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageLight);
	m_hbmImageLight = NULL;

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageShadow);
	m_hbmImageShadow = NULL;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarscustomizedialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxpriv.h"
#include "afxribbonres.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"
#include "afxmousemanager.h"
#include "afxcontextmenumanager.h"
#include "afxmenutearoffmanager.h"
#include "afxtoolbarscommandslistbox.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxkeyboardmanager.h"
#include "afxusertoolsmanager.h"
#include "afxtoolbarmenubutton.h"
#include "afxoutlookbar.h"
#include "afxusertool.h"
#include "afxvisualmanager.h"
#include "afxdocksite.h"
#include "afxrebar.h"
#include "afximageeditordialog.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"

CMFCToolBarsCustomizeDialog* g_pWndCustomize = NULL;

static const int nButtonMargin = 8;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCustomizeDialog

IMPLEMENT_DYNAMIC(CMFCToolBarsCustomizeDialog, CPropertySheet)

CMFCToolBarsCustomizeDialog::CMFCToolBarsCustomizeDialog(CFrameWnd* pWndParentFrame, BOOL bAutoSetFromMenus /* = FALSE */,
		UINT uiFlags /* = 0xFFFF */, CList<CRuntimeClass*,CRuntimeClass*>* plistCustomPages /* = NULL */) :
	CPropertySheet(_T(""), pWndParentFrame), m_bAutoSetFromMenus(bAutoSetFromMenus), m_uiFlags(uiFlags)
{

	if ((m_uiFlags & AFX_CUSTOMIZE_MENUAMPERS) == 0)
	{
		m_bSaveMenuAmps = FALSE;
	}
	else
	{
		m_bSaveMenuAmps = TRUE;
	}

	// Add optional custom pages:
	if (plistCustomPages != NULL)
	{
		// does not use lib local resources, so moved to front
		ASSERT_VALID(plistCustomPages);
		for (POSITION pos=plistCustomPages->GetHeadPosition(); pos; )
		{
			CRuntimeClass* pClass = plistCustomPages->GetNext(pos);
			m_listCustomPages.AddTail((CPropertyPage*) pClass->CreateObject() );
		}
	}

	ENSURE(pWndParentFrame != NULL);
	m_pParentFrame = pWndParentFrame;

	m_pCustomizePage = new CMFCToolBarsCommandsPropertyPage;
	m_pToolbarsPage = new CMFCToolBarsListPropertyPage(m_pParentFrame);
	m_pKeyboardPage = new CMFCToolBarsKeyboardPropertyPage(m_pParentFrame, m_bAutoSetFromMenus);
	m_pMenuPage = new CMFCToolBarsMenuPropertyPage(m_pParentFrame, m_bAutoSetFromMenus);
	m_pMousePage = new CMFCMousePropertyPage;

	// Add two main pages(available always):
	AddPage(m_pCustomizePage);
	AddPage(m_pToolbarsPage);

	// Add tools page:
	if (m_uiFlags & AFX_CUSTOMIZE_NOTOOLS)
	{
		m_pToolsPage = NULL;
	}
	else
	{
		m_pToolsPage = new CMFCToolBarsToolsPropertyPage();
		if (afxUserToolsManager != NULL)
		{
			AddPage(m_pToolsPage);
		}
	}

	// Add keyboard customization page(available only if
	// the main application windows accelerator table is exist):
	if (afxKeyboardManager != NULL && pWndParentFrame->m_hAccelTable != NULL)
	{
		AddPage(m_pKeyboardPage);
	}

	// Add menu customization page(available only if the menu bar or
	// context menu manager are available):
	BOOL bMenuBarIsAvailable = FALSE;

	CMDIFrameWndEx* pMainMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentFrame);
	if (pMainMDIFrame != NULL)
	{
		bMenuBarIsAvailable = (pMainMDIFrame->IsMenuBarAvailable());
	}
	else
	{
		CFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CFrameWndEx, m_pParentFrame);
		if (pMainFrame != NULL)
		{
			bMenuBarIsAvailable = (pMainFrame->IsMenuBarAvailable());
		}
	}

	if (afxContextMenuManager != NULL || bMenuBarIsAvailable)
	{
		AddPage(m_pMenuPage);
	}

	if (afxMouseManager != NULL)
	{
		AddPage(m_pMousePage);
	}

	// Add optional custom pages:
	for (POSITION pos=m_listCustomPages.GetHeadPosition(); pos; )
	{
		AddPage( m_listCustomPages.GetNext(pos) );
	}

	m_pOptionsPage = new CMFCToolBarsOptionsPropertyPage(bMenuBarIsAvailable);
	AddPage(m_pOptionsPage);

	// Set property sheet caption:
	CString strCaption;
	ENSURE(strCaption.LoadString(IDS_AFXBARRES_PROPSHT_CAPTION));

	ENSURE(m_strAllCommands.LoadString(IDS_AFXBARRES_ALL_COMMANDS));
	m_pCustomizePage->SetAllCategory(m_strAllCommands);

	if (m_pKeyboardPage != NULL)
	{
		m_pKeyboardPage->SetAllCategory(m_strAllCommands);
	}

	SetTitle(strCaption);

	if (m_bAutoSetFromMenus)
	{
		SetupFromMenus();
	}

	// Add a "New menu" button:
	CString strNewMenu;
	ENSURE(strNewMenu.LoadString(IDS_AFXBARRES_NEW_MENU));

	AddButton(strNewMenu, CMFCToolBarMenuButton(0, NULL, -1, strNewMenu));
}

CMFCToolBarsCustomizeDialog::~CMFCToolBarsCustomizeDialog()
{
	POSITION pos = m_ButtonsByCategory.GetStartPosition();
	while (pos != NULL)
	{
		CObList* pCategoryButtonsList;
		CString string;

		m_ButtonsByCategory.GetNextAssoc(pos, string, pCategoryButtonsList);
		ASSERT_VALID(pCategoryButtonsList);

		while (!pCategoryButtonsList->IsEmpty())
		{
			delete pCategoryButtonsList->RemoveHead();
		}

		delete pCategoryButtonsList;
	}

	m_ButtonsByCategory.RemoveAll();

	delete m_pCustomizePage;
	delete m_pToolbarsPage;
	delete m_pKeyboardPage;
	delete m_pMenuPage;
	delete m_pMousePage;
	delete m_pOptionsPage;

	if (m_pToolsPage != NULL)
	{
		delete m_pToolsPage;
	}

	// delete all optional custom pages:
	while (!m_listCustomPages.IsEmpty())
	{
		delete m_listCustomPages.RemoveHead();
	}
}

BEGIN_MESSAGE_MAP(CMFCToolBarsCustomizeDialog, CPropertySheet)
	//{{AFX_MSG_MAP(CMFCToolBarsCustomizeDialog)
	ON_WM_CREATE()
	ON_WM_HELPINFO()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCustomizeDialog message handlers

int CMFCToolBarsCustomizeDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}

	if (m_uiFlags & AFX_CUSTOMIZE_CONTEXT_HELP)
	{
		ModifyStyleEx(0, WS_EX_CONTEXTHELP);
	}

	g_pWndCustomize = this;
	return 0;
}

void CMFCToolBarsCustomizeDialog::PostNcDestroy()
{
	g_pWndCustomize = NULL;
	SetFrameCustMode(FALSE);

	CPropertySheet::PostNcDestroy();
	delete this;
}

void CMFCToolBarsCustomizeDialog::AddButton(UINT uiCategoryId, const CMFCToolBarButton& button, int iInsertBefore)
{
	CString strCategory;
	ENSURE(strCategory.LoadString(uiCategoryId));

	AddButton(strCategory, button, iInsertBefore);
}

void CMFCToolBarsCustomizeDialog::AddButton(LPCTSTR lpszCategory, const CMFCToolBarButton& button, int iInsertBefore)
{
	int iId = (int) button.m_nID;

	if (!button.IsEditable())
	{
		// Don't add protected, MRU, system and Window commands:
		return;
	}

	if (!CMFCToolBar::IsCommandPermitted(button.m_nID))
	{
		return;
	}

	CString strText = button.m_strText;
	strText.TrimLeft();
	strText.TrimRight();

	BOOL bToolBtn = FALSE;

	if (afxUserToolsManager != NULL && afxUserToolsManager->IsUserToolCmd(iId))
	{
		CUserTool* pTool = afxUserToolsManager->FindTool(iId);

		if (pTool == NULL)
		{
			// Undefined user tool, skip it
			return;
		}

		ASSERT_VALID(pTool);

		// Use tool name as label:
		strText = pTool->m_strLabel;
		bToolBtn = TRUE;
	}

	if (strText.IsEmpty())
	{
		// Try to find the command name in resources:
		CString strMessage;
		int iOffset;
		if (strMessage.LoadString(button.m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
		{
			strText = strMessage.Mid(iOffset + 1);
		}

		if (strText.IsEmpty() && lpszCategory == m_strAllCommands)
		{
			return;
		}
	}
	else
	{
		if (!m_bSaveMenuAmps)
		{
			strText.Remove(_T('&'));
		}

		// Remove trailing label(ex.:"\tCtrl+S"):
		int iOffset = strText.Find(_T('\t'));
		if (iOffset != -1)
		{
			strText = strText.Left(iOffset);
		}
	}

	// If text is still empty, assume dummy command and don't add it:
	if (strText.IsEmpty())
	{
		return;
	}

	// Find a category entry or create new if not exist:
	CObList* pCategoryButtonsList;
	if (!m_ButtonsByCategory.Lookup(lpszCategory, pCategoryButtonsList))
	{
		// Category not found! Create new:
		pCategoryButtonsList = new CObList;
		m_ButtonsByCategory.SetAt(lpszCategory, pCategoryButtonsList);

		if (lpszCategory != m_strAllCommands)
		{
			m_strCategoriesList.AddTail(lpszCategory);
		}
	}
	else
	{
		// Category is not a new. Maybe the button is exist also?
		ENSURE(pCategoryButtonsList != NULL);

		for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL;)
		{
			CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
			ENSURE(pButton != NULL);
			ASSERT_VALID(pButton);

			if ((pButton->m_nID == button.m_nID && pButton->m_nID != (UINT) -1) ||(pButton->m_nID == (UINT) -1 && pButton->m_strText == button.m_strText))
				// The same exist...
			{
				if (pButton->m_strText.IsEmpty())
				{
					pButton->m_strText = button.m_strText;
				}

				return;
			}
		}
	}

	// Create a new CMFCToolBarButton object(MFC class factory is used):
	CRuntimeClass* pClass = button.GetRuntimeClass();
	ENSURE(pClass != NULL);

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);

	pButton->CopyFrom(button);
	pButton->m_strText = strText;

	if (bToolBtn)
	{
		pButton->SetImage(0);
	}

	// Add a new button to the specific category:
	BOOL bInserted = FALSE;
	if (iInsertBefore != -1)
	{
		POSITION pos = pCategoryButtonsList->FindIndex(iInsertBefore);
		if (pos != NULL)
		{
			pCategoryButtonsList->InsertBefore(pos, pButton);
			bInserted = TRUE;
		}
	}

	if (!bInserted)
	{
		pCategoryButtonsList->AddTail(pButton);
	}

	if (lpszCategory != m_strAllCommands)
	{
		AddButton(m_strAllCommands, button);
	}

	pButton->OnAddToCustomizePage();
}

int CMFCToolBarsCustomizeDialog::RemoveButton(UINT uiCategoryId, UINT uiCmdId)
{
	if (uiCategoryId == (UINT) -1) // Remove from ALL caregories
	{
		BOOL bFinish = FALSE;
		for (POSITION posCategory = m_strCategoriesList.GetHeadPosition(); !bFinish;)
		{
			CString strCategory;
			if (posCategory == NULL)
			{
				strCategory = m_strAllCommands;
				bFinish = TRUE;
			}
			else
			{
				strCategory = m_strCategoriesList.GetNext(posCategory);
			}

			RemoveButton(strCategory, uiCmdId);
		}

		return 0;
	}

	CString strCategory;
	ENSURE(strCategory.LoadString(uiCategoryId));

	return RemoveButton(strCategory, uiCmdId);
}

int CMFCToolBarsCustomizeDialog::RemoveButton(LPCTSTR lpszCategory, UINT uiCmdId)
{
	ENSURE(lpszCategory != NULL);

	CObList* pCategoryButtonsList;
	if (!m_ButtonsByCategory.Lookup(lpszCategory, pCategoryButtonsList))
	{
		// Category not found!
		return -1;
	}

	int i = 0;
	for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL; i ++)
	{
		POSITION posSave = pos;

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_nID == uiCmdId)
		{
			pCategoryButtonsList->RemoveAt(posSave);
			delete pButton;
			return i;
		}
	}

	return -1;
}

BOOL CMFCToolBarsCustomizeDialog::AddToolBar(UINT uiCategory, UINT uiToolbarResId)
{
	CString strCategory;
	ENSURE(strCategory.LoadString(uiCategory));

	return AddToolBar(strCategory, uiToolbarResId);
}

BOOL CMFCToolBarsCustomizeDialog::AddToolBar(LPCTSTR lpszCategory, UINT uiToolbarResId)
{
	struct CToolBarData
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;

		WORD* items()
		{ return(WORD*)(this+1); }
	};

	ENSURE(uiToolbarResId != 0);

	// determine location of the bitmap in resource fork:
	HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiToolbarResId), RT_TOOLBAR);
	HRSRC hRsrc = ::FindResourceW(hInst, MAKEINTRESOURCEW(uiToolbarResId), (LPWSTR) RT_TOOLBAR);
	if (hRsrc == NULL)
	{
		TRACE(_T("CMFCToolBarsCustomizeDialog::AddToolBar: Can't load toolbar %x\n"), uiToolbarResId);
		return FALSE;
	}

	HGLOBAL hGlobal = ::LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)
	{
		TRACE(_T("CMFCToolBarsCustomizeDialog::AddToolBar: Can't load toolbar %x\n"), uiToolbarResId);
		return FALSE;
	}

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL)
	{
		TRACE(_T("CMFCToolBarsCustomizeDialog::AddToolBar: Can't load toolbar %x\n"), uiToolbarResId);
		::FreeResource(hGlobal);
		return FALSE;
	}

	ASSERT(pData->wVersion == 1);

	for (int i = 0; i < pData->wItemCount; i++)
	{
		UINT uiCmd = pData->items() [i];
		if (uiCmd > 0 && uiCmd != (UINT) -1)
		{
			AddButton(lpszCategory, CMFCToolBarButton(uiCmd, -1));
		}
	}

	::UnlockResource(hGlobal);
	::FreeResource(hGlobal);

	return TRUE;
}

BOOL CMFCToolBarsCustomizeDialog::AddMenu(UINT uiMenuResId)
{
	CMenu menu;
	if (!menu.LoadMenu(uiMenuResId))
	{
		TRACE(_T("CMFCToolBarsCustomizeDialog::AddMenu: Can't load menu %x\n"), uiMenuResId);
		return FALSE;
	}

	AddMenuCommands(&menu, FALSE);
	return TRUE;
}

// Rename automatically imported categories(e.g. "?"->"Help")
BOOL CMFCToolBarsCustomizeDialog::RenameCategory(LPCTSTR lpszCategoryOld, LPCTSTR lpszCategoryNew)
{
	// New Name must not be present
	POSITION pos = m_strCategoriesList.Find(lpszCategoryNew);
	if (pos)
		return FALSE;

	// ...but the old one must be
	pos = m_strCategoriesList.Find(lpszCategoryOld);
	if (!pos)
		return FALSE;

	// Change Name in Button-map too:
	CObList* pCategoryButtonsList;

	// new Category must not be present yet
	if (m_ButtonsByCategory.Lookup(lpszCategoryNew, pCategoryButtonsList))
		return FALSE;

	// ...but the old one must be
	if (!m_ButtonsByCategory.Lookup(lpszCategoryOld, pCategoryButtonsList))
		return FALSE;

	// change both or nothing
	m_strCategoriesList.SetAt(pos, lpszCategoryNew);
	m_ButtonsByCategory.RemoveKey(lpszCategoryOld);
	m_ButtonsByCategory.SetAt(lpszCategoryNew, pCategoryButtonsList);

	return TRUE;
}

void CMFCToolBarsCustomizeDialog::ReplaceButton(UINT uiCmd, const CMFCToolBarButton& button)
{
	CRuntimeClass* pClass = button.GetRuntimeClass();
	ENSURE(pClass != NULL);

	BOOL bFinish = FALSE;
	for (POSITION posCategory = m_strCategoriesList.GetHeadPosition(); !bFinish;)
	{
		CString strCategory;
		if (posCategory == NULL)
		{
			strCategory = m_strAllCommands;
			bFinish = TRUE;
		}
		else
		{
			strCategory = m_strCategoriesList.GetNext(posCategory);
		}

		CObList* pCategoryButtonsList;
		if (!m_ButtonsByCategory.Lookup(strCategory, pCategoryButtonsList) ||
			pCategoryButtonsList == NULL)
		{
			ASSERT(FALSE);
			continue;
		}

		ASSERT_VALID(pCategoryButtonsList);

		for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL;)
		{
			POSITION posSave = pos;
			CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
			ENSURE(pButton != NULL);
			ASSERT_VALID(pButton);

			if (pButton->m_nID == uiCmd) // Found!
			{
				CMFCToolBarButton* pNewButton = (CMFCToolBarButton*) pClass->CreateObject();
				ASSERT_VALID(pNewButton);

				pNewButton->CopyFrom(button);
				if (pNewButton->m_strText.IsEmpty())
				{
					pNewButton->m_strText = pButton->m_strText;
				}

				pCategoryButtonsList->SetAt(posSave, pNewButton);
				delete pButton;
			}
		}
	}
}

BOOL CMFCToolBarsCustomizeDialog::SetUserCategory(LPCTSTR lpszCategory)
{
	ENSURE(lpszCategory != NULL);

	CObList* pCategoryButtonsList;
	if (!m_ButtonsByCategory.Lookup(lpszCategory, pCategoryButtonsList))
	{
		TRACE(_T("CMFCToolBarsCustomizeDialog::SetUserCategory: Can't find category '%s'\n"), lpszCategory);
		return FALSE;
	}

	m_pCustomizePage->SetUserCategory(lpszCategory);
	return TRUE;
}

void CMFCToolBarsCustomizeDialog::SetFrameCustMode(BOOL bCustMode)
{
	ASSERT_VALID(m_pParentFrame);

	CWaitCursor wait;

	// Enable/disable all parent frame child windows(except docking bars
	// and our toolbars):
	CWnd* pWndChild = m_pParentFrame->GetWindow(GW_CHILD);
	while (pWndChild != NULL)
	{
		CRuntimeClass* pChildClass = pWndChild->GetRuntimeClass();
		if (pChildClass == NULL || (!pChildClass->IsDerivedFrom(RUNTIME_CLASS(CDockBar)) &&
			!pChildClass->IsDerivedFrom(RUNTIME_CLASS(CDockSite)) && !pChildClass->IsDerivedFrom(RUNTIME_CLASS(CMFCOutlookBar)) &&
			!pChildClass->IsDerivedFrom(RUNTIME_CLASS(CMFCReBar)) && !pChildClass->IsDerivedFrom(RUNTIME_CLASS(CMFCToolBar))))
		{
			pWndChild->EnableWindow(!bCustMode);
		}

		pWndChild = pWndChild->GetNextWindow();
	}

	// Enable/Disable floating frames:
	CDockingManager* pDockManager = NULL;

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentFrame);
	if (pMainFrame != NULL)
	{
		pDockManager = pMainFrame->GetDockingManager();
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, m_pParentFrame);
		if (pFrame != NULL)
		{
			pDockManager = pFrame->GetDockingManager();

		}
		else // Maybe, OLE frame
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, m_pParentFrame);
			if (pOleFrame != NULL)
			{
				pDockManager = pOleFrame->GetDockingManager();
			}
			else
			{
				COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, m_pParentFrame);
				if (pOleDocFrame != NULL)
				{
					pDockManager = pOleDocFrame->GetDockingManager();
				}
			}
		}
	}

	if (pDockManager != NULL)
	{
		ASSERT_VALID(pDockManager);

		const CObList& lstMiniFrames = pDockManager->GetMiniFrames();
		for (POSITION pos = lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, lstMiniFrames.GetNext(pos));
			if (pMiniFrame != NULL && DYNAMIC_DOWNCAST(CMFCBaseToolBar, pMiniFrame->GetPane()) == NULL)
			{
				pMiniFrame->EnableWindow(!bCustMode);
			}
		}
	}

	m_pParentFrame->LockWindowUpdate();

	// Set/reset costumize mode for ALL our toolbars:
	CMFCToolBar::SetCustomizeMode(bCustMode);

	// Inform the parent frame about mode(for additional actions):
	m_pParentFrame->SendMessage(AFX_WM_CUSTOMIZETOOLBAR, (WPARAM) bCustMode);

	m_pParentFrame->UnlockWindowUpdate();

	if (!bCustMode && m_pParentFrame->GetActiveFrame() != NULL)
	{
		// Restore active view:
		m_pParentFrame->GetActiveFrame()->PostMessage(WM_SETFOCUS);
	}
}

BOOL CMFCToolBarsCustomizeDialog::Create()
{
	DWORD dwExStyle = 0;

	if ((m_pParentFrame != NULL) &&(m_pParentFrame->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		dwExStyle |= WS_EX_LAYOUTRTL;
	}

	if (!CPropertySheet::Create(m_pParentFrame, (DWORD)-1, dwExStyle))
	{
		return FALSE;
	}

	SetFrameCustMode(TRUE);
	return TRUE;
}

void CMFCToolBarsCustomizeDialog::ShowToolBar(CMFCToolBar* pToolBar, BOOL bShow)
{
	m_pToolbarsPage->ShowToolBar(pToolBar, bShow);
}

BOOL CMFCToolBarsCustomizeDialog::OnInitDialog()
{
	BOOL bResult = CPropertySheet::OnInitDialog();

	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	// Show "Cancel" button:
	CWnd *pWndCancel = GetDlgItem(IDCANCEL);
	if (pWndCancel == NULL)
	{
		return bResult;
	}

	pWndCancel->ShowWindow(SW_SHOW);
	pWndCancel->EnableWindow();

	CRect rectClientCancel;
	pWndCancel->GetClientRect(&rectClientCancel);
	pWndCancel->MapWindowPoints(this, &rectClientCancel);

	// Enlarge property sheet window:
	CRect rectWnd;
	GetWindowRect(rectWnd);

	SetWindowPos(NULL, 0, 0, rectWnd.Width(), rectWnd.Height() + rectClientCancel.Height() + 2 * nButtonMargin, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	// Move "Cancel" button to the right bottom corner:
	pWndCancel->SetWindowPos(NULL, rectClient.right - rectClientCancel.Width() - nButtonMargin,
		rectClientCancel.top + nButtonMargin / 2, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

	// Change "Cancel" button's style to "DEFPUSHBUTTON":
	CWnd *pWndOk = GetDlgItem(IDOK);
	if (pWndOk != NULL)
	{
		pWndOk->ModifyStyle(BS_DEFPUSHBUTTON, 0);
	}

	pWndCancel->ModifyStyle(0, BS_DEFPUSHBUTTON);

	// Replace "Cancel" text to "Close"
	//(CPropertyPage::CancelToClose method does nothing in a
	// modeless property sheet):
	CString strCloseText;
	ENSURE(strCloseText.LoadString(IDS_AFXBARRES_CLOSE));

	pWndCancel->SetWindowText(strCloseText);

	// Ensure that the dialog is fully visible on screen
	CRect rectDialog;
	GetWindowRect(&rectDialog);

	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYMAXIMIZED) - (GetSystemMetrics(SM_CYSCREEN) - GetSystemMetrics(SM_CYMAXIMIZED));

	if ((rectDialog.left < 0) || (rectDialog.top < 0))
	{
		SetWindowPos(NULL, rectDialog.left < 0 ? 0 : rectDialog.left, rectDialog.top < 0 ? 0 : rectDialog.top, 0, 0, SWP_NOSIZE);
	}
	else if ((rectDialog.right > cxScreen) || (rectDialog.bottom > cyScreen))
	{
		SetWindowPos(NULL, rectDialog.right > cxScreen ? cxScreen - rectDialog.Width() : rectDialog.left, rectDialog.bottom > cyScreen ? cyScreen - rectDialog.Height() : rectDialog.top, 0, 0, SWP_NOSIZE);
	}

	// Adjust the Help button:
	CButton *pWndHelp = (CButton*) GetDlgItem(IDHELP);
	if (pWndHelp == NULL)
	{
		return bResult;
	}

	if (m_uiFlags & AFX_CUSTOMIZE_NOHELP)
	{
		pWndHelp->ShowWindow(SW_HIDE);
		pWndHelp->EnableWindow(FALSE);
	}
	else
	{
		m_btnHelp.SubclassWindow(pWndHelp->GetSafeHwnd());
		m_btnHelp.ShowWindow(SW_SHOW);
		m_btnHelp.EnableWindow();

		// Set Help button image:
		m_btnHelp.SetImage(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_HELP32 : IDB_AFXBARRES_HELP);
		m_btnHelp.SetWindowText(_T(""));

		// Move "Help" button to the left bottom corner and
		// adjust its size by the bitmap size:

		CSize sizeHelp = m_btnHelp.SizeToContent(TRUE);

		m_btnHelp.SetWindowPos(NULL, rectClient.left + nButtonMargin, rectClientCancel.top, sizeHelp.cx, sizeHelp.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return bResult;
}

void CMFCToolBarsCustomizeDialog::OnClose()
{
	if (afxUserToolsManager != NULL && m_pToolsPage != NULL)
	{
		if (!CheckToolsValidity(afxUserToolsManager->GetUserTools()))
		{
			// Continue customization....
			if (GetActivePage() != m_pToolsPage)
			{
				SetActivePage(m_pToolsPage);
			}

			return;
		}
	}

	CPropertySheet::OnClose();
}

BOOL CMFCToolBarsCustomizeDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (LOWORD(wParam))
	{
	case IDCANCEL:
		if (afxUserToolsManager != NULL && m_pToolsPage != NULL)
		{
			if (!CheckToolsValidity(afxUserToolsManager->GetUserTools()))
			{
				// Continue customization....
				if (GetActivePage() != m_pToolsPage)
				{
					SetActivePage(m_pToolsPage);
				}

				return TRUE;
			}
		}

		DestroyWindow();
		return TRUE;

	case IDHELP:
		ASSERT_VALID(m_pParentFrame);
		m_pParentFrame->SendMessage(AFX_WM_CUSTOMIZEHELP, GetActiveIndex(), (LPARAM) this);
		return TRUE;
	}

	return CPropertySheet::OnCommand(wParam, lParam);
}

void CMFCToolBarsCustomizeDialog::EnableUserDefinedToolbars(BOOL bEnable)
{
	m_pToolbarsPage->EnableUserDefinedToolbars(bEnable);
}

void CMFCToolBarsCustomizeDialog::AddMenuCommands(const CMenu* pMenu, BOOL bPopup, LPCTSTR lpszCategory, LPCTSTR lpszMenuPath)
{
	ENSURE(pMenu != NULL);
	ASSERT_VALID(pMenu);

	BOOL bIsWindowsMenu = FALSE;
	int iCount = pMenu->GetMenuItemCount();

	for (int i = 0; i < iCount; i ++)
	{
		UINT uiCmd = pMenu->GetMenuItemID(i);

		CString strText;
		pMenu->GetMenuString(i, strText, MF_BYPOSITION);

		if (!m_bSaveMenuAmps)
		{
			strText.Remove(_T('&'));
		}

		switch (uiCmd)
		{
		case 0: // Separator, ignore it.
			break;

		case -1: // Submenu
			{
				CMenu* pSubMenu = pMenu->GetSubMenu(i);

				UINT uiTearOffId = 0;
				if (g_pTearOffMenuManager != NULL)
				{
					uiTearOffId = g_pTearOffMenuManager->Parse(strText);
				}

				CString strCategory = strText;
				strCategory.Remove(_T('&'));

				if (lpszCategory != NULL)
				{
					strCategory = lpszCategory;
				}

				if (m_bAutoSetFromMenus)
				{
					if (bPopup)
					{
						CMFCToolBarMenuButton menuButton((UINT) -1, pSubMenu->GetSafeHmenu(), -1, strText);

						menuButton.SetTearOff(uiTearOffId);
						AddButton(strCategory, menuButton);
					}

					CString strPath;
					if (lpszMenuPath != NULL)
					{
						strPath = lpszMenuPath;
					}

					strPath += strText;
					AddMenuCommands(pSubMenu, bPopup, strCategory, strPath);
				}
				else
				{
					AddMenuCommands(pSubMenu, bPopup);
				}

			}
			break;

		default:
			if (bPopup && uiCmd >= AFX_IDM_WINDOW_FIRST && uiCmd <= AFX_IDM_WINDOW_LAST)
			{
				bIsWindowsMenu = TRUE;
			}

			if (lpszCategory != NULL && afxUserToolsManager != NULL && afxUserToolsManager->GetToolsEntryCmd() == uiCmd)
			{
				// Replace tools entry by the actual tools list:
				AddUserTools(lpszCategory);
			}
			else
			{
				CMFCToolBarButton button(uiCmd, -1, strText);

				if (lpszMenuPath != NULL)
				{
					CString strCustom = CString(lpszMenuPath) + button.m_strText;

					LPTSTR pszCustom = strCustom.GetBuffer(strCustom.GetLength() + 1);

					for (int j = 0; j < lstrlen(pszCustom) - 1; j++)
					{
						if (pszCustom [j] == _TCHAR(' '))
						{
							CharUpperBuff(&pszCustom [j + 1], 1);
						}
					}

					strCustom.ReleaseBuffer();

					strCustom.Remove(_T(' '));
					button.m_strTextCustom = strCustom.SpanExcluding(_T("\t"));
				}

				AddButton(lpszCategory == NULL ? m_strAllCommands : lpszCategory, button);
			}
		}
	}

	// Add windows manager item:
	if (bIsWindowsMenu && lpszCategory != NULL)
	{
		CMDIFrameWndEx* pMainMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentFrame);
		if (pMainMDIFrame != NULL && pMainMDIFrame->m_uiWindowsDlgMenuId != 0 && pMainMDIFrame->m_bShowWindowsDlgAlways)
		{
			AddButton(lpszCategory, CMFCToolBarButton(pMainMDIFrame->m_uiWindowsDlgMenuId, -1, pMainMDIFrame->m_strWindowsDlgMenuText));
		}
	}
}

void CMFCToolBarsCustomizeDialog::FillCategoriesComboBox(CComboBox& wndCategory, BOOL bAddEmpty) const
{
	CObList* pCategoryButtonsList;

	for (POSITION pos = m_strCategoriesList.GetHeadPosition(); pos != NULL;)
	{
		CString strCategory = m_strCategoriesList.GetNext(pos);

		if (!m_ButtonsByCategory.Lookup(strCategory, pCategoryButtonsList))
		{
			ASSERT(FALSE);
		}

		ASSERT_VALID(pCategoryButtonsList);

		BOOL bIsEmpty = FALSE;

		if (!bAddEmpty)
		{
			bIsEmpty = TRUE;
			for (POSITION posCat = pCategoryButtonsList->GetHeadPosition(); posCat != NULL;)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(posCat);
				ASSERT_VALID(pButton);

				if (pButton->m_nID > 0 && pButton->m_nID != (UINT) -1)
				{
					bIsEmpty = FALSE;
					break;
				}
			}
		}

		if (!bIsEmpty)
		{
			int iIndex = wndCategory.AddString(strCategory);
			wndCategory.SetItemData(iIndex, (DWORD_PTR) pCategoryButtonsList);
		}
	}

	// "All" category should be last!
	if (!m_ButtonsByCategory.Lookup(m_strAllCommands, pCategoryButtonsList))
	{
		ASSERT(FALSE);
	}

	ASSERT_VALID(pCategoryButtonsList);

	int iIndex = wndCategory.AddString(m_strAllCommands);
	wndCategory.SetItemData(iIndex, (DWORD_PTR) pCategoryButtonsList);
}

void CMFCToolBarsCustomizeDialog::FillCategoriesListBox(CListBox& wndCategory, BOOL bAddEmpty) const
{
	CObList* pCategoryButtonsList;

	for (POSITION pos = m_strCategoriesList.GetHeadPosition(); pos != NULL;)
	{
		CString strCategory = m_strCategoriesList.GetNext(pos);

		if (!m_ButtonsByCategory.Lookup(strCategory, pCategoryButtonsList))
		{
			ASSERT(FALSE);
		}

		ASSERT_VALID(pCategoryButtonsList);

		BOOL bIsEmpty = FALSE;

		if (!bAddEmpty)
		{
			bIsEmpty = TRUE;
			for (POSITION posCat = pCategoryButtonsList->GetHeadPosition(); posCat != NULL;)
			{
				CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(posCat);
				ASSERT_VALID(pButton);

				if (pButton->m_nID > 0 && pButton->m_nID != (UINT) -1)
				{
					bIsEmpty = FALSE;
					break;
				}
			}
		}

		if (!bIsEmpty)
		{
			int iIndex = wndCategory.AddString(strCategory);
			wndCategory.SetItemData(iIndex, (DWORD_PTR) pCategoryButtonsList);
		}
	}

	// "All" category should be last!
	if (!m_ButtonsByCategory.Lookup(m_strAllCommands, pCategoryButtonsList))
	{
		ASSERT(FALSE);
	}

	ASSERT_VALID(pCategoryButtonsList);

	int iIndex = wndCategory.AddString(m_strAllCommands);
	wndCategory.SetItemData(iIndex, (DWORD_PTR) pCategoryButtonsList);
}

void CMFCToolBarsCustomizeDialog::FillAllCommandsList(CListBox& wndListOfCommands) const
{
	wndListOfCommands.ResetContent();

	CObList* pAllButtonsList;
	if (!m_ButtonsByCategory.Lookup(m_strAllCommands, pAllButtonsList))
	{
		return;
	}

	ASSERT_VALID(pAllButtonsList);

	for (POSITION pos = pAllButtonsList->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pAllButtonsList->GetNext(pos);
		ASSERT_VALID(pButton);

		int iIndex = wndListOfCommands.AddString(pButton->m_strTextCustom.IsEmpty() ? pButton->m_strText : pButton->m_strTextCustom);
		wndListOfCommands.SetItemData(iIndex, (DWORD) pButton->m_nID);
	}
}

BOOL CMFCToolBarsCustomizeDialog::OnHelpInfo(HELPINFO* /*pHelpInfo*/)
{
	ASSERT_VALID(m_pParentFrame);
	m_pParentFrame->SendMessage(AFX_WM_CUSTOMIZEHELP, GetActiveIndex(), (LPARAM) this);

	return TRUE;
}

LPCTSTR CMFCToolBarsCustomizeDialog::GetCommandName(UINT uiCmd) const
{
	CObList* pAllButtonsList;
	if (!m_ButtonsByCategory.Lookup(m_strAllCommands, pAllButtonsList))
	{
		return NULL;
	}

	ENSURE(pAllButtonsList != NULL);
	ASSERT_VALID(pAllButtonsList);

	for (POSITION pos = pAllButtonsList->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pAllButtonsList->GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_nID == uiCmd)
		{
			return pButton->m_strText;
		}
	}

	return NULL;
}

void CMFCToolBarsCustomizeDialog::SetupFromMenus()
{
	// Find all application document templates and add menue items to the
	// "All commands" category:
	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplate* pTemplate = DYNAMIC_DOWNCAST( CMultiDocTemplate, pDocManager->GetNextDocTemplate(pos));
			if (pTemplate != NULL)
			{
				CMenu* pDocMenu = CMenu::FromHandle(pTemplate->m_hMenuShared);
				if (pDocMenu != NULL)
				{
					AddMenuCommands(pDocMenu, FALSE);
				}
			}
		}
	}

	// Add commands from the default menu:
	CMenu* pFrameMenu = CMenu::FromHandle(m_pParentFrame->m_hMenuDefault);
	if (pFrameMenu == NULL)
	{
		CMDIFrameWndEx* pMainMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentFrame);
		const CMFCMenuBar* pMenuBar = NULL;

		if (pMainMDIFrame != NULL)
		{
			pMenuBar = pMainMDIFrame->GetMenuBar();
		}
		else
		{
			CFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CFrameWndEx, m_pParentFrame);
			if (pMainFrame != NULL)
			{
				pMenuBar = pMainFrame->GetMenuBar();
			}
		}

		if (pMenuBar != NULL)
		{
			pFrameMenu = CMenu::FromHandle(pMenuBar->GetDefaultMenu());
		}
	}

	if (pFrameMenu != NULL)
	{
		AddMenuCommands(pFrameMenu, FALSE);
	}
}

void CMFCToolBarsCustomizeDialog::AddUserTools(LPCTSTR lpszCategory)
{
	ENSURE(lpszCategory != NULL);
	ASSERT_VALID(afxUserToolsManager);

	const CObList& lstTools = afxUserToolsManager->GetUserTools();
	for (POSITION pos = lstTools.GetHeadPosition(); pos != NULL;)
	{
		CUserTool* pTool = (CUserTool*) lstTools.GetNext(pos);
		ASSERT_VALID(pTool);

		AddButton(lpszCategory, CMFCToolBarButton(pTool->GetCommandId(), 0, pTool->m_strLabel));
	}
}

int CMFCToolBarsCustomizeDialog::GetCountInCategory(LPCTSTR lpszItemName, const CObList& lstCommands) const
{
	int nCount = 0;

	for (POSITION pos = lstCommands.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) lstCommands.GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		if (pButton->m_strText == lpszItemName)
		{
			nCount++;
		}
	}

	return nCount;
}

BOOL CMFCToolBarsCustomizeDialog::OnEditToolbarMenuImage(CWnd* pWndParent, CBitmap& bitmap, int nBitsPerPixel)
{
	CMFCImageEditorDialog dlg(&bitmap, pWndParent, nBitsPerPixel);
	return(dlg.DoModal() == IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarfontcombobox.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxtoolbar.h"
#include "afxribbonres.h"
#include "afxtoolbarfontcombobox.h"
#include "afxfontcombobox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CMFCToolBarFontComboBox

IMPLEMENT_SERIAL(CMFCToolBarFontComboBox, CMFCToolBarComboBoxButton, 1)

CObList CMFCToolBarFontComboBox::m_lstFonts;
int CMFCToolBarFontComboBox::m_nCount = 0;
int CMFCToolBarFontComboBox::m_nFontHeight = 0;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarFontComboBox::CMFCToolBarFontComboBox() :
	m_nCharSet(DEFAULT_CHARSET), m_nFontType(DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE), m_nPitchAndFamily(DEFAULT_PITCH)
{
	m_pLstFontsExternal = NULL;
	m_nCount++;
}

CMFCToolBarFontComboBox::CMFCToolBarFontComboBox(UINT uiID, int iImage, int nFontType, BYTE nCharSet, DWORD dwStyle, int iWidth, BYTE nPitchAndFamily) :
	CMFCToolBarComboBoxButton(uiID, iImage, dwStyle, iWidth), m_nFontType(nFontType), m_nCharSet(nCharSet), m_nPitchAndFamily(nPitchAndFamily)
{
	m_pLstFontsExternal = NULL;

	if (m_nCount++ == 0)
	{
		RebuildFonts();
	}

	SetContext();
}

CMFCToolBarFontComboBox::CMFCToolBarFontComboBox(CObList* pLstFontsExternal, int nFontType, BYTE nCharSet, BYTE nPitchAndFamily) :
	m_nFontType(nFontType), m_nCharSet(nCharSet), m_nPitchAndFamily(nPitchAndFamily), m_pLstFontsExternal(pLstFontsExternal)
{
	ASSERT_VALID(m_pLstFontsExternal);
	RebuildFonts();
}

CMFCToolBarFontComboBox::~CMFCToolBarFontComboBox()
{
	if (m_pLstFontsExternal == NULL)
	{
		if (--m_nCount == 0)
		{
			ClearFonts();
		}
	}
}

void CMFCToolBarFontComboBox::RebuildFonts()
{
	CObList& lstFonts = m_pLstFontsExternal != NULL ? *m_pLstFontsExternal : m_lstFonts;
	ASSERT(lstFonts.IsEmpty());

	// First, take the screen fonts:
	CWindowDC dc(NULL);

	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));
	lf.lfCharSet = m_nCharSet;

	::EnumFontFamiliesEx(dc.GetSafeHdc(), &lf, (FONTENUMPROC) EnumFamScreenCallBackEx, (LPARAM) this, NULL);

	// Now, take the printer fonts:
	CPrintDialog dlgPrint(FALSE);

	if (AfxGetApp()->GetPrinterDeviceDefaults(&dlgPrint.m_pd))
	{
		HDC hDCPrint = dlgPrint.CreatePrinterDC();
		ENSURE(hDCPrint != NULL);

		::EnumFontFamiliesEx(hDCPrint, &lf, (FONTENUMPROC) EnumFamPrinterCallBackEx, (LPARAM) this, NULL);

		::DeleteObject(hDCPrint);
	}
}

void __stdcall CMFCToolBarFontComboBox::ClearFonts()
{
	while (!m_lstFonts.IsEmpty())
	{
		delete(CMFCFontInfo*) m_lstFonts.RemoveHead();
	}
}

void CMFCToolBarFontComboBox::SetContext()
{
	for (POSITION pos = m_lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) m_lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if ((m_nFontType & pDesc->m_nType) != 0)
		{
			BOOL bIsUnique = GetFontsCount(pDesc->m_strName) <= 1;
			AddItem(bIsUnique ? pDesc->m_strName : pDesc->GetFullName(), (DWORD_PTR) pDesc);
		}
	}
}

BOOL CALLBACK AFX_EXPORT CMFCToolBarFontComboBox::EnumFamScreenCallBackEx(ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	CMFCToolBarFontComboBox* pCombo = (CMFCToolBarFontComboBox*) pThis;
	ASSERT_VALID(pCombo);

	pCombo->AddFont((ENUMLOGFONT*)pelf, FontType, CString(pelf->elfScript));
	return 1;
}

BOOL CALLBACK AFX_EXPORT CMFCToolBarFontComboBox::EnumFamPrinterCallBackEx(ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	CMFCToolBarFontComboBox* pCombo = (CMFCToolBarFontComboBox*) pThis;
	ASSERT_VALID(pCombo);

	CString strName = pelf->elfLogFont.lfFaceName;

	pCombo->AddFont((ENUMLOGFONT*)pelf, FontType, CString(pelf->elfScript));
	return 1;
}

BOOL CMFCToolBarFontComboBox::AddFont(ENUMLOGFONT* pelf, int nType, LPCTSTR lpszScript)
{
	LOGFONT& lf = pelf->elfLogFont;

	CObList& lstFonts = m_pLstFontsExternal != NULL ? *m_pLstFontsExternal : m_lstFonts;

	// Don't put in MAC fonts, commdlg doesn't either
	if (lf.lfCharSet == MAC_CHARSET)
	{
		return FALSE;
	}

	BYTE bFontPitch    = lf.lfPitchAndFamily & 0x0F;
	BYTE bFontFamily   = lf.lfPitchAndFamily & 0xF0;
	BYTE bFilterPitch  = m_nPitchAndFamily & 0x0F;
	BYTE bFilterFamily = m_nPitchAndFamily & 0xF0;

	if ((bFilterPitch != DEFAULT_PITCH) && (bFilterPitch != bFontPitch))
	{
		return FALSE;
	}

	if ((bFilterFamily != FF_DONTCARE) && (bFilterFamily != bFontFamily))
	{
		return FALSE;
	}

	POSITION pos = NULL;
	for (pos = lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if (pDesc->m_strName == lf.lfFaceName)
		{
			// Already in list
			return FALSE;
		}
	}

	// Don't display vertical font for FE platform:
	if ((GetSystemMetrics(SM_DBCSENABLED)) &&(lf.lfFaceName[0] == '@'))
	{
		return FALSE;
	}

	CMFCFontInfo* pDesc = new CMFCFontInfo(lf.lfFaceName, lpszScript, lf.lfCharSet, lf.lfPitchAndFamily, nType);
	ASSERT_VALID(pDesc);

	// Fonts list is sorted by name:
	BOOL bInserted = FALSE;
	for (pos = lstFonts.GetHeadPosition(); !bInserted && pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCFontInfo* pDescList = (CMFCFontInfo*) lstFonts.GetNext(pos);
		ASSERT_VALID(pDescList);

		if (pDescList->GetFullName() >= pDesc->GetFullName())
		{
			lstFonts.InsertBefore(posSave, pDesc);
			bInserted = TRUE;
		}
	}

	if (!bInserted)
	{
		lstFonts.AddTail(pDesc);
	}

	return TRUE;
}

void CMFCToolBarFontComboBox::Serialize(CArchive& ar)
{
	// Override to disable item's data serialization!

	CMFCToolBarButton::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_iWidth;
		m_rect.right = m_rect.left + m_iWidth;
		ar >> m_dwStyle;
		ar >> m_iSelIndex;
		ar >> m_strEdit;
		ar >> m_nDropDownHeight;
		ar >> m_nFontType;
		ar >> m_nCharSet;

		if (m_lstFonts.IsEmpty())
		{
			RebuildFonts();
		}

		SetContext();
		SelectItem(m_iSelIndex);
	}
	else
	{
		ar << m_iWidth;
		ar << m_dwStyle;
		ar << m_iSelIndex;
		ar << m_strEdit;
		ar << m_nDropDownHeight;
		ar << m_nFontType;
		ar << m_nCharSet;
	}
}

int __stdcall CMFCToolBarFontComboBox::GetFontsCount(LPCTSTR lpszName)
{
	ASSERT(!m_lstFonts.IsEmpty());

	int nCount = 0;

	for (POSITION pos = m_lstFonts.GetHeadPosition(); pos != NULL;)
	{
		CMFCFontInfo* pDesc = (CMFCFontInfo*) m_lstFonts.GetNext(pos);
		ASSERT_VALID(pDesc);

		if (pDesc->m_strName == lpszName)
		{
			nCount++;
		}
	}

	return nCount;
}

CComboBox* CMFCToolBarFontComboBox::CreateCombo(CWnd* pWndParent, const CRect& rect)
{
	CMFCFontComboBox* pWndCombo = new CMFCFontComboBox;
	if (!pWndCombo->Create(m_dwStyle | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED, rect, pWndParent, m_nID))
	{
		delete pWndCombo;
		return NULL;
	}

	return pWndCombo;
}

BOOL CMFCToolBarFontComboBox::SetFont(LPCTSTR lpszName, BYTE nCharSet, BOOL bExact)
{
	ENSURE(lpszName != NULL);
	CString strNameFind = lpszName;
	strNameFind.MakeLower();

	for (POSITION pos = m_lstItemData.GetHeadPosition(); pos != NULL;)
	{
		BOOL bFound = FALSE;

		CMFCFontInfo* pDesc = (CMFCFontInfo*) m_lstItemData.GetNext(pos);
		ASSERT_VALID(pDesc);

		CString strName = pDesc->GetFullName();
		strName.MakeLower();

		if (bExact)
		{
			if (strName == strNameFind || (pDesc->m_strName.CompareNoCase(lpszName) == 0 && (nCharSet == pDesc->m_nCharSet || nCharSet == DEFAULT_CHARSET)))
			{
				bFound = TRUE;
			}
		}
		else if (strName.Find(strNameFind) == 0 && (nCharSet == DEFAULT_CHARSET || pDesc->m_nCharSet == nCharSet))
		{
			bFound = TRUE;
		}

		if (bFound)
		{
			SelectItem((DWORD_PTR) pDesc);
			return TRUE;
		}
	}

	return FALSE;
}

//////////////////////////////////////////////////////////////////////
// CMFCToolBarFontSizeComboBox

static int nFontSizes[] = {8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};

IMPLEMENT_SERIAL(CMFCToolBarFontSizeComboBox, CMFCToolBarComboBoxButton, 1)

// Construction/Destruction
CMFCToolBarFontSizeComboBox::CMFCToolBarFontSizeComboBox()
{
	m_nLogVert = 0;
}

CMFCToolBarFontSizeComboBox::CMFCToolBarFontSizeComboBox(UINT uiID, int iImage, DWORD dwStyle, int iWidth) :
	CMFCToolBarComboBoxButton(uiID, iImage, dwStyle, iWidth)
{
	m_nLogVert = 0;
}

CMFCToolBarFontSizeComboBox::~CMFCToolBarFontSizeComboBox()
{
}

void CMFCToolBarFontSizeComboBox::RebuildFontSizes(const CString& strFontName)
{
	if (strFontName.IsEmpty())
	{
		return;
	}

	CString strText = m_strEdit;

	if (m_pWndCombo != NULL)
	{
		m_pWndCombo->SetRedraw(FALSE);
	}

	CWindowDC dc(NULL);

	RemoveAllItems();

	m_nLogVert = dc.GetDeviceCaps(LOGPIXELSY);
	::EnumFontFamilies(dc.GetSafeHdc(), strFontName, (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);

	if (!SelectItem(strText))
	{
		m_strEdit = strText;
		if (m_pWndCombo != NULL)
		{
			m_pWndCombo->SetWindowText(m_strEdit);
		}
	}

	// Synchronize context with other comboboxes with the same ID:
	CObList listButtons;
	if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
	{
		for (POSITION posCombo = listButtons.GetHeadPosition(); posCombo != NULL;)
		{
			CMFCToolBarComboBoxButton* pCombo = DYNAMIC_DOWNCAST(CMFCToolBarComboBoxButton, listButtons.GetNext(posCombo));

			if (pCombo != NULL && pCombo != this)
			{
				if (pCombo->GetComboBox() != NULL)
				{
					pCombo->GetComboBox()->SetRedraw(FALSE);
				}

				pCombo->RemoveAllItems();

				POSITION pos;
				POSITION posData;

				for (pos = m_lstItems.GetHeadPosition(), posData = m_lstItemData.GetHeadPosition(); pos != NULL && posData != NULL;)
				{
					pCombo->AddItem(m_lstItems.GetNext(pos), m_lstItemData.GetNext(posData));
				}

				if (pCombo->GetComboBox() != NULL)
				{
					pCombo->GetComboBox()->SetRedraw();
				}
			}
		}
	}

	if (m_pWndCombo != NULL)
	{
		m_pWndCombo->SetRedraw();
	}
}

BOOL FAR PASCAL CMFCToolBarFontSizeComboBox::EnumSizeCallBack(LOGFONT FAR* /*lplf*/, LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv)
{
	CMFCToolBarFontSizeComboBox* pThis = (CMFCToolBarFontSizeComboBox*) lpv;
	ASSERT_VALID(pThis);

	if ((FontType & TRUETYPE_FONTTYPE) || !((FontType & TRUETYPE_FONTTYPE) ||(FontType & RASTER_FONTTYPE))) // if truetype or vector font
	{
		// this occurs when there is a truetype and nontruetype version of a font
		for (int i = 0; i < 16; i++)
		{
			CString strSize;
			strSize.Format(_T("%d"), nFontSizes[i]);

			pThis->AddItem(strSize);
		}

		return FALSE; // don't call me again
	}

	// calc character height in pixels
	pThis->InsertSize(MulDiv(lpntm->tmHeight-lpntm->tmInternalLeading, 1440, pThis->m_nLogVert));

	return TRUE; // call me again
}

CString CMFCToolBarFontSizeComboBox::TwipsToPointString(int nTwips)
{
	CString str;
	if (nTwips >= 0)
	{
		// round to nearest half point
		nTwips = (nTwips + 5) / 10;

		if ((nTwips % 2) == 0)
		{
			str.Format(_T("%ld"), nTwips/2);
		}
		else
		{
			str.Format(_T("%.1f"), (float) nTwips / 2.F);
		}
	}

	return str;
}

void CMFCToolBarFontSizeComboBox::SetTwipSize(int nTwips)
{
	SetText(TwipsToPointString(nTwips));
}

int CMFCToolBarFontSizeComboBox::GetTwipSize() const
{
	// return values
	// -2 -- error
	// -1 -- edit box empty
	// >=0 -- font size in twips

	CString str = GetItem() == NULL ? m_strEdit : GetItem();
	if (m_lstItems.Find(m_strEdit) == NULL)
	{
		str = m_strEdit;
	}

	LPCTSTR lpszText = str;

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (lpszText[0] == NULL)
		return -1; // no text in control

	double d = _tcstod(lpszText, (LPTSTR*)&lpszText);
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (*lpszText != NULL)
		return -2;   // not terminated properly

	return(d<0.) ? 0 :(int)(d*20.);
}

void CMFCToolBarFontSizeComboBox::InsertSize(int nSize)
{
	ASSERT(nSize > 0);
	AddItem(TwipsToPointString(nSize), (DWORD) nSize);
}

CComboBox* CMFCToolBarFontSizeComboBox::CreateCombo(CWnd* pWndParent, const CRect& rect)
{
	CMFCFontComboBox* pWndCombo = new CMFCFontComboBox;
	if (!pWndCombo->Create(m_dwStyle, rect, pWndParent, m_nID))
	{
		delete pWndCombo;
		return NULL;
	}

	return pWndCombo;
}

void CMFCToolBarFontComboBox::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarComboBoxButton::CopyFrom(s);

	const CMFCToolBarFontComboBox& src = (const CMFCToolBarFontComboBox&) s;

	m_nCharSet = src.m_nCharSet;
	m_nFontType = src.m_nFontType;
	m_nPitchAndFamily = src.m_nPitchAndFamily;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarscommandslistbox.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxtoolbarscommandslistbox.h"
#include "afxtoolbar.h"
#include "afxtoolbarbutton.h"
#include "afxribbonres.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCommandsListBox

CMFCToolBarsCommandsListBox::CMFCToolBarsCommandsListBox() : m_sizeButton(0, 0)
{
}

CMFCToolBarsCommandsListBox::~CMFCToolBarsCommandsListBox()
{
}

BEGIN_MESSAGE_MAP(CMFCToolBarsCommandsListBox, CListBox)
	//{{AFX_MSG_MAP(CMFCToolBarsCommandsListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCommandsListBox message handlers

void CMFCToolBarsCommandsListBox::OnLButtonDown(UINT nFlags, CPoint point)
{
	CListBox::OnLButtonDown(nFlags, point);

	int iIndex = GetCurSel();
	if (iIndex == LB_ERR)
	{
		return;
	}

	// Be sure that we realy click into the item!
	CRect rect;
	GetItemRect(iIndex, &rect);

	if (!rect.PtInRect(point))
	{
		return;
	}

	// Trigger mouse up event(to change selection notification):
	SendMessage(WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));

	// Get selected button:
	CMFCToolBarButton* pButton = (CMFCToolBarButton*) GetItemData(iIndex);
	ASSERT_VALID(pButton);

	// Prepare clipboard data and start drag:
	COleDataSource srcItem;

	pButton->m_bDragFromCollection = TRUE;
	pButton->PrepareDrag(srcItem);
	pButton->m_bDragFromCollection = FALSE;

	{
		::SetCursor(AfxGetApp()->LoadCursor(IDC_AFXBARRES_DELETE));
	}

	srcItem.DoDragDrop(DROPEFFECT_COPY|DROPEFFECT_MOVE, &rect, &CMFCToolBar::m_DropSource);
}

void CMFCToolBarsCommandsListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	ENSURE(lpMIS != NULL);

	UINT uiRowHeight = (UINT) m_sizeButton.cy;
	if (lpMIS->itemHeight < uiRowHeight)
	{
		lpMIS->itemHeight = uiRowHeight;
	}
}

void CMFCToolBarsCommandsListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDC);

	CRect rect = lpDIS->rcItem;

	if (lpDIS->itemID != (UINT)-1)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) GetItemData(lpDIS->itemID);
		ASSERT_VALID(pButton);

		CString strText = pButton->m_strText;
		GetText(lpDIS->itemID, pButton->m_strText);

		CMFCVisualManager::GetInstance()->OnFillCommandsListBackground(pDC, rect);

		pButton->OnDrawOnCustomizeList(pDC, rect, (lpDIS->itemState & ODS_SELECTED) &&(lpDIS->itemState & ODS_FOCUS));
		pButton->m_strText = strText;
	}
}

void CMFCToolBarsCommandsListBox::PreSubclassWindow()
{
	CListBox::PreSubclassWindow();

	CSize sizeMenuImage = CMFCToolBar::GetMenuImageSize();

	m_sizeButton = CSize( sizeMenuImage.cx + 6, sizeMenuImage.cy + 6);
}

BOOL CMFCToolBarsCommandsListBox::OnEraseBkgnd(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(rectClient);

	CMFCVisualManager::GetInstance()->OnFillCommandsListBackground(pDC, rectClient);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarslistcheckbox.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxpriv.h"
#include "afxtoolbarslistcheckbox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsListCheckBox

CMFCToolBarsListCheckBox::CMFCToolBarsListCheckBox()
{
}

CMFCToolBarsListCheckBox::~CMFCToolBarsListCheckBox()
{
}

//{{AFX_MSG_MAP(CMFCToolBarsListCheckBox)
BEGIN_MESSAGE_MAP(CMFCToolBarsListCheckBox, CCheckListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_MESSAGE(LB_ADDSTRING, &CMFCToolBarsListCheckBox::OnLBAddString)
	ON_MESSAGE(LB_INSERTSTRING, &CMFCToolBarsListCheckBox::OnLBInsertString)
	ON_MESSAGE(LB_RESETCONTENT, &CMFCToolBarsListCheckBox::OnLBResetContent)
	ON_MESSAGE(LB_DELETESTRING, &CMFCToolBarsListCheckBox::OnLBDeleteString)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsListCheckBox message handlers

void CMFCToolBarsListCheckBox::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetFocus();

	// determine where the click is
	BOOL bInCheck;
	int nIndex = CheckFromPoint(point, bInCheck);

	if (bInCheck && nIndex != LB_ERR && !IsCheckEnabled(nIndex))
	{
		MessageBeep((UINT) -1);
		return;
	}

	CCheckListBox::OnLButtonDown(nFlags, point);
}

void CMFCToolBarsListCheckBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_SPACE)
	{
		int nIndex = GetCaretIndex();
		if (nIndex != LB_ERR && !IsCheckEnabled(nIndex))
		{
			MessageBeep((UINT) -1);
			return;
		}
	}

	CCheckListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}

LRESULT CMFCToolBarsListCheckBox::OnLBAddString(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRes = CCheckListBox::OnLBAddString(wParam, lParam);
	OnNewString((int) lRes);
	return lRes;
}

LRESULT CMFCToolBarsListCheckBox::OnLBInsertString(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRes = CCheckListBox::OnLBInsertString(wParam, lParam);
	OnNewString((int) lRes);
	return lRes;
}

LRESULT CMFCToolBarsListCheckBox::OnLBDeleteString(WPARAM wParam, LPARAM /*lParam*/)
{
	LRESULT lRes = Default();
	if (lRes != LB_ERR)
	{
		m_arCheckData.RemoveAt((int) wParam);
	}

	return lRes;
}

LRESULT CMFCToolBarsListCheckBox::OnLBResetContent(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	m_arCheckData.SetSize(0);
	return Default();
}

void CMFCToolBarsListCheckBox::EnableCheck(int nIndex, BOOL bEnable)
{
	ASSERT(nIndex >= 0 && nIndex < m_arCheckData.GetSize());
	m_arCheckData.SetAt(nIndex, bEnable);
}

BOOL CMFCToolBarsListCheckBox::IsCheckEnabled(int nIndex) const
{
	ASSERT(nIndex >= 0 && nIndex < m_arCheckData.GetSize());
	return m_arCheckData.GetAt(nIndex);
}

void CMFCToolBarsListCheckBox::OnNewString(int iIndex)
{
	if (iIndex >= 0)
	{
		int iSize = GetCount();
		m_arCheckData.SetSize(iSize);

		for (int i = iSize - 1; i > iIndex; i --)
		{
			m_arCheckData.SetAt(i, m_arCheckData.GetAt(i - 1));
		}

		m_arCheckData.SetAt(iIndex, TRUE); // Enabled by default
	}
}

void CMFCToolBarsListCheckBox::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// determine where the click is
	BOOL bInCheck;
	int nIndex = CheckFromPoint(point, bInCheck);

	if (bInCheck && nIndex != LB_ERR && !IsCheckEnabled(nIndex))
	{
		MessageBeep((UINT) -1);
		return;
	}

	CCheckListBox::OnLButtonDblClk(nFlags, point);
	GetParent()->SendMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), CLBN_CHKCHANGE), (LPARAM)m_hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarslistpropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include <afxpriv.h>
#include "afxribbonres.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxtoolbarslistpropertypage.h"
#include "afxtoolbar.h"
#include "afxtoolbarbutton.h"
#include "afxpopupmenubar.h"
#include "afxtoolbarnamedialog.h"
#include "afxcommandmanager.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxframewndex.h"
#include "afxdropdowntoolbar.h"
#include "afxpaneframewnd.h"

IMPLEMENT_DYNCREATE(CMFCToolBarsCommandsPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CMFCToolBarsListPropertyPage, CPropertyPage)

extern CObList afxAllToolBars;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCommandsPropertyPage property page

CMFCToolBarsCommandsPropertyPage::CMFCToolBarsCommandsPropertyPage() : CPropertyPage(CMFCToolBarsCommandsPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CMFCToolBarsCommandsPropertyPage)
	m_strButtonDescription = _T("");
	//}}AFX_DATA_INIT
}

CMFCToolBarsCommandsPropertyPage::~CMFCToolBarsCommandsPropertyPage()
{
}

void CMFCToolBarsCommandsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsCommandsPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_CATEGORY, m_wndCategory);
	DDX_Control(pDX, IDC_AFXBARRES_USER_TOOLS, m_wndTools);
	DDX_Text(pDX, IDC_AFXBARRES_BUTTON_DESCR, m_strButtonDescription);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarsCommandsPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsCommandsPropertyPage)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_USER_TOOLS, &CMFCToolBarsCommandsPropertyPage::OnSelchangeUserTools)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_CATEGORY, &CMFCToolBarsCommandsPropertyPage::OnSelchangeCategory)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCToolBarsCommandsPropertyPage::OnSelchangeCategory()
{
	UpdateData();

	int iSelIndex = m_wndCategory.GetCurSel();
	if (iSelIndex == LB_ERR)
	{
		ASSERT(FALSE);
		return;
	}

	CWaitCursor wait;
	m_wndTools.SetRedraw(FALSE);

	m_wndTools.ResetContent();

	// Only "All commands" list shoud be sorted!
	CString strCategory;
	m_wndCategory.GetText(iSelIndex, strCategory);

	BOOL bAllCommands = (strCategory == m_strAllCategory);

	OnChangeSelButton(NULL);

	CObList* pCategoryButtonsList =
		(CObList*) m_wndCategory.GetItemData(iSelIndex);
	ASSERT_VALID(pCategoryButtonsList);

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
		ENSURE(pButton != NULL);
		ASSERT_VALID(pButton);

		pButton->m_bUserButton = pButton->m_nID != (UINT) -1 && afxCommandManager->GetCmdImage(pButton->m_nID, FALSE) == -1;

		CString strText = pButton->m_strText;

		if (!pButton->m_strTextCustom.IsEmpty() &&
			(bAllCommands || pWndParent->GetCountInCategory(strText, *pCategoryButtonsList) > 1))
		{
			strText = pButton->m_strTextCustom;
		}

		int iIndex = -1;

		if (bAllCommands)
		{
			// Insert sortable:
			for (int i = 0; iIndex == -1 && i < m_wndTools.GetCount(); i ++)
			{
				CString strCommand;
				m_wndTools.GetText(i, strCommand);

				if (strCommand > strText)
				{
					iIndex = m_wndTools.InsertString(i, strText);
				}
			}
		}

		if (iIndex == -1) // Not inserted yet
		{
			iIndex = m_wndTools.AddString(strText);
		}

		m_wndTools.SetItemData(iIndex, (DWORD_PTR) pButton);
	}

	m_wndTools.SetRedraw(TRUE);
}

void CMFCToolBarsCommandsPropertyPage::OnSelchangeUserTools()
{
	int iIndex = m_wndTools.GetCurSel();
	if (iIndex == LB_ERR)
	{
		OnChangeSelButton(NULL);
	}
	else
	{
		OnChangeSelButton((CMFCToolBarButton*) m_wndTools.GetItemData(iIndex));
	}
}

BOOL CMFCToolBarsCommandsPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	pWndParent->FillCategoriesListBox(m_wndCategory);

	m_wndCategory.SetCurSel(0);
	OnSelchangeCategory();

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CMFCToolBarsCommandsPropertyPage::OnChangeSelButton(CMFCToolBarButton* pSelButton)
{
	m_strButtonDescription = _T("");

	if (pSelButton != NULL)
	{
		if (pSelButton->m_nID == 0)
		{
			m_strButtonDescription = pSelButton->m_strText;
		}
		else
		{
			CFrameWnd* pParent = GetParentFrame();
			if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
			{
				pParent->GetMessageString(pSelButton->m_nID, m_strButtonDescription);
			}
		}
	}

	m_pSelButton = pSelButton;
	UpdateData(FALSE);
}

void CMFCToolBarsCommandsPropertyPage::SetUserCategory(LPCTSTR lpszCategory)
{
	ENSURE(lpszCategory != NULL);
	m_strUserCategory = lpszCategory;
}

void CMFCToolBarsCommandsPropertyPage::SetAllCategory(LPCTSTR lpszCategory)
{
	ENSURE(lpszCategory != NULL);
	m_strAllCategory = lpszCategory;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsListPropertyPage property page

CMFCToolBarsListPropertyPage::CMFCToolBarsListPropertyPage(CFrameWnd* pParentFrame) :
	CPropertyPage(CMFCToolBarsListPropertyPage::IDD), m_bUserDefinedToolbars(FALSE), m_pParentFrame(pParentFrame)
{
	//{{AFX_DATA_INIT(CMFCToolBarsListPropertyPage)
	m_bTextLabels = FALSE;
	//}}AFX_DATA_INIT

	m_pSelectedToolbar = NULL;
	ASSERT_VALID(m_pParentFrame);
}

CMFCToolBarsListPropertyPage::~CMFCToolBarsListPropertyPage()
{
}

void CMFCToolBarsListPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsListPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_TEXT_LABELS, m_wndTextLabels);
	DDX_Control(pDX, IDC_AFXBARRES_RENAME_TOOLBAR, m_bntRenameToolbar);
	DDX_Control(pDX, IDC_AFXBARRES_NEW_TOOLBAR, m_btnNewToolbar);
	DDX_Control(pDX, IDC_AFXBARRES_DELETE_TOOLBAR, m_btnDelete);
	DDX_Control(pDX, IDC_AFXBARRES_RESET, m_btnReset);
	DDX_Control(pDX, IDC_AFXBARRES_TOOLBAR_LIST, m_wndToolbarList);
	DDX_Check(pDX, IDC_AFXBARRES_TEXT_LABELS, m_bTextLabels);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarsListPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsListPropertyPage)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_TOOLBAR_LIST, &CMFCToolBarsListPropertyPage::OnSelchangeToolbarList)
	ON_LBN_DBLCLK(IDC_AFXBARRES_TOOLBAR_LIST, &CMFCToolBarsListPropertyPage::OnDblClkToolBarList)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET, &CMFCToolBarsListPropertyPage::OnResetToolbar)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_ALL, &CMFCToolBarsListPropertyPage::OnResetAllToolbars)
	ON_BN_CLICKED(IDC_AFXBARRES_DELETE_TOOLBAR, &CMFCToolBarsListPropertyPage::OnDeleteToolbar)
	ON_BN_CLICKED(IDC_AFXBARRES_NEW_TOOLBAR, &CMFCToolBarsListPropertyPage::OnNewToolbar)
	ON_BN_CLICKED(IDC_AFXBARRES_RENAME_TOOLBAR, &CMFCToolBarsListPropertyPage::OnRenameToolbar)
	ON_BN_CLICKED(IDC_AFXBARRES_TEXT_LABELS, &CMFCToolBarsListPropertyPage::OnTextLabels)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CMFCToolBarsListPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	if (!m_bUserDefinedToolbars)
	{
		m_btnNewToolbar.EnableWindow(FALSE);

		m_btnNewToolbar.ShowWindow(SW_HIDE);
		m_btnDelete.ShowWindow(SW_HIDE);
		m_bntRenameToolbar.ShowWindow(SW_HIDE);
	}

	for (POSITION pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			// Don't add dropdown toolbars!
			if (!pToolBar->IsKindOf(RUNTIME_CLASS(CMFCDropDownToolBar)))
			{
				// Check, if toolbar belongs to this dialog's parent main frame window
				if (m_pParentFrame->GetTopLevelFrame() == pToolBar->GetTopLevelFrame() && pToolBar->AllowShowOnList() && !pToolBar->m_bMasked)
				{
					CString strName;
					pToolBar->GetWindowText(strName);

					if (strName.IsEmpty())
					{
						ENSURE(strName.LoadString(IDS_AFXBARRES_UNTITLED_TOOLBAR));
					}

					int iIndex = m_wndToolbarList.AddString(strName);
					m_wndToolbarList.SetItemData(iIndex, (DWORD_PTR) pToolBar);

					if (pToolBar->GetStyle() & WS_VISIBLE)
					{
						m_wndToolbarList.SetCheck(iIndex, 1);
					}

					m_wndToolbarList.EnableCheck(iIndex, pToolBar->CanBeClosed());
				}
			}
		}
	}

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	if ((pWndParent->GetFlags() & AFX_CUSTOMIZE_TEXT_LABELS) == 0)
	{
		m_wndTextLabels.ShowWindow(SW_HIDE);
	}

	if (m_wndToolbarList.GetCount() > 0)
	{
		m_wndToolbarList.SetCurSel(0);
		OnSelchangeToolbarList();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CMFCToolBarsListPropertyPage::OnSelchangeToolbarList()
{
	int iIndex = m_wndToolbarList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		m_pSelectedToolbar = NULL;
		m_btnReset.EnableWindow(FALSE);
		m_btnDelete.EnableWindow(FALSE);
		m_bntRenameToolbar.EnableWindow(FALSE);
		m_wndTextLabels.EnableWindow(FALSE);
		return;
	}

	m_pSelectedToolbar = (CMFCToolBar*) m_wndToolbarList.GetItemData(iIndex);
	ASSERT_VALID(m_pSelectedToolbar);

	m_btnReset.EnableWindow(m_pSelectedToolbar->CanBeRestored());
	m_btnDelete.EnableWindow(m_pSelectedToolbar->IsUserDefined());
	m_bntRenameToolbar.EnableWindow(m_pSelectedToolbar->IsUserDefined());
	m_wndTextLabels.EnableWindow(m_pSelectedToolbar->AllowChangeTextLabels());

	m_bTextLabels = m_pSelectedToolbar->AreTextLabels();
	UpdateData(FALSE);
}

void CMFCToolBarsListPropertyPage::OnDblClkToolBarList()
{
	int iIndex = m_wndToolbarList.GetCurSel();
	if (iIndex != LB_ERR)
	{
		m_pSelectedToolbar = (CMFCToolBar*) m_wndToolbarList.GetItemData(iIndex);
		ASSERT_VALID(m_pSelectedToolbar);

		if (m_pSelectedToolbar->CanBeClosed())
		{
			m_wndToolbarList.SetCheck(iIndex, !m_wndToolbarList.GetCheck(iIndex));
		}
		else
		{
			MessageBeep((UINT) -1);
		}
	}

	OnSelchangeToolbarList();
}

void CMFCToolBarsListPropertyPage::ShowToolBar(CMFCToolBar* pToolBar, BOOL bShow)
{
	if (m_wndToolbarList.GetSafeHwnd() == NULL)
	{
		return;
	}

	for (int i = 0; i < m_wndToolbarList.GetCount(); i ++)
	{
		CMFCToolBar* pListToolBar = (CMFCToolBar*) m_wndToolbarList.GetItemData(i);
		ASSERT_VALID(pListToolBar);

		if (pListToolBar == pToolBar)
		{
			m_wndToolbarList.SetCheck(i, bShow);
			break;
		}
	}
}

void CMFCToolBarsListPropertyPage::OnResetToolbar()
{
	if (m_pSelectedToolbar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pSelectedToolbar);
	ASSERT(m_pSelectedToolbar->CanBeRestored());

	CString strName;
	m_pSelectedToolbar->GetWindowText(strName);

	CString strPrompt;
	strPrompt.Format(IDS_AFXBARRES_RESET_TOOLBAR_FMT, strName);

	if (AfxMessageBox(strPrompt, MB_YESNO | MB_ICONQUESTION) != IDYES)
	{
		return;
	}

	m_pSelectedToolbar->RestoreOriginalstate();
}

void CMFCToolBarsListPropertyPage::OnResetAllToolbars()
{
	CString strPrompt;
	ENSURE(strPrompt.LoadString(IDS_AFXBARRES_RESET_ALL_TOOLBARS));

	if (AfxMessageBox(strPrompt, MB_YESNO | MB_ICONQUESTION) != IDYES)
	{
		return;
	}

	afxCommandManager->ClearAllCmdImages();

	// Fill image hash by the default image ids:
	for (POSITION pos = CMFCToolBar::m_DefaultImages.GetStartPosition(); pos != NULL;)
	{
		UINT uiCmdId;
		int iImage;

		CMFCToolBar::m_DefaultImages.GetNextAssoc(pos, uiCmdId, iImage);
		afxCommandManager->SetCmdImage(uiCmdId, iImage, FALSE);
	}

	for (int i = 0; i < m_wndToolbarList.GetCount(); i ++)
	{
		CMFCToolBar* pListToolBar = (CMFCToolBar*) m_wndToolbarList.GetItemData(i);
		ASSERT_VALID(pListToolBar);

		if (pListToolBar->CanBeRestored())
		{
			pListToolBar->RestoreOriginalstate();
		}
	}
}

void CMFCToolBarsListPropertyPage::OnDeleteToolbar()
{
	if (m_pSelectedToolbar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pSelectedToolbar);
	ASSERT(m_pSelectedToolbar->IsUserDefined());

	CFrameWnd* pParentFrame = GetParentFrame();
	if (pParentFrame == NULL)
	{
		MessageBeep(MB_ICONASTERISK);
		return;
	}

	CString strName;
	m_pSelectedToolbar->GetWindowText(strName);

	CString strPrompt;
	strPrompt.Format(IDS_AFXBARRES_DELETE_TOOLBAR_FMT, strName);

	if (AfxMessageBox(strPrompt, MB_YESNO | MB_ICONQUESTION) != IDYES)
	{
		return;
	}

	if (pParentFrame->SendMessage(AFX_WM_DELETETOOLBAR, 0, (LPARAM) m_pSelectedToolbar) == 0)
	{
		MessageBeep(MB_ICONASTERISK);
		return;
	}

	m_wndToolbarList.DeleteString(m_wndToolbarList.GetCurSel());
	m_wndToolbarList.SetCurSel(0);
	OnSelchangeToolbarList();
}

void CMFCToolBarsListPropertyPage::OnNewToolbar()
{
	CMFCToolBarNameDialog dlg(this);
	if (dlg.DoModal() != IDOK)
	{
		return;
	}

	CString strToolbarName = dlg.m_strToolbarName;

	CFrameWnd* pParentFrame = GetParentFrame();
	if (pParentFrame == NULL)
	{
		MessageBeep(MB_ICONASTERISK);
		return;
	}

	CMFCToolBar* pNewToolbar = (CMFCToolBar*)pParentFrame->SendMessage(AFX_WM_CREATETOOLBAR, 0, (LPARAM)(LPCTSTR) strToolbarName);
	if (pNewToolbar == NULL)
	{
		return;
	}

	ASSERT_VALID(pNewToolbar);

	int iIndex = m_wndToolbarList.AddString(strToolbarName);
	m_wndToolbarList.SetItemData(iIndex, (DWORD_PTR) pNewToolbar);

	m_wndToolbarList.SetCheck(iIndex, 1);
	m_wndToolbarList.SetCurSel(iIndex);
	m_wndToolbarList.SetTopIndex(iIndex);

	OnSelchangeToolbarList();
}

void CMFCToolBarsListPropertyPage::OnRenameToolbar()
{
	if (m_pSelectedToolbar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pSelectedToolbar);
	ASSERT(m_pSelectedToolbar->IsUserDefined());

	CMFCToolBarNameDialog dlg(this);
	m_pSelectedToolbar->GetWindowText(dlg.m_strToolbarName);

	if (dlg.DoModal() != IDOK)
	{
		return;
	}

	CString strToolbarName = dlg.m_strToolbarName;

	m_pSelectedToolbar->SetWindowText(strToolbarName);
	if (m_pSelectedToolbar->IsFloating())
	{
		// Change floating frame title:
		CPaneFrameWnd* pParentMiniFrame = m_pSelectedToolbar->GetParentMiniFrame();
		if (pParentMiniFrame != NULL)
		{
			pParentMiniFrame->SetWindowText(strToolbarName);
			pParentMiniFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}
	}

	m_wndToolbarList.DeleteString(m_wndToolbarList.GetCurSel());

	int iIndex = m_wndToolbarList.AddString(strToolbarName);
	m_wndToolbarList.SetItemData(iIndex, (DWORD_PTR) m_pSelectedToolbar);

	if (m_pSelectedToolbar->GetStyle() & WS_VISIBLE)
	{
		m_wndToolbarList.SetCheck(iIndex, 1);
	}

	m_wndToolbarList.SetCurSel(iIndex);
	m_wndToolbarList.SetTopIndex(iIndex);

	OnSelchangeToolbarList();
}

BOOL CMFCToolBarsListPropertyPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
	UINT uiCode = HIWORD(wParam);
	UINT uiID = LOWORD(wParam);

	if (uiCode == CLBN_CHKCHANGE && uiID == IDC_AFXBARRES_TOOLBAR_LIST)
	{
		int iIndex = m_wndToolbarList.GetCurSel();
		if (iIndex != LB_ERR)
		{
			CMFCToolBar* pToolbar = (CMFCToolBar*) m_wndToolbarList.GetItemData(iIndex);
			ASSERT_VALID(pToolbar);

			if (pToolbar->CanBeClosed())
			{
				// Show/hide toolbar:
				pToolbar->ShowPane(m_wndToolbarList.GetCheck(iIndex), FALSE, TRUE);
			}
			else if (m_wndToolbarList.GetCheck(iIndex) == 0)
			{
				// Toolbar should be visible always!
				m_wndToolbarList.SetCheck(iIndex, TRUE);
				MessageBeep((UINT) -1);
			}
		}
	}

	return CPropertyPage::OnCommand(wParam, lParam);
}

void CMFCToolBarsListPropertyPage::OnTextLabels()
{
	UpdateData();

	ASSERT_VALID(m_pSelectedToolbar);
	m_pSelectedToolbar->EnableTextLabels(m_bTextLabels);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarsoptionspropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxribbonres.h"
#include "afxcontrolbarutil.h"
#include "afxtoolbarsoptionspropertypage.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsOptionsPropertyPage property page

IMPLEMENT_DYNCREATE(CMFCToolBarsOptionsPropertyPage, CPropertyPage)

CMFCToolBarsOptionsPropertyPage::CMFCToolBarsOptionsPropertyPage(BOOL bIsMenuBarExist) :
	CPropertyPage(CMFCToolBarsOptionsPropertyPage::IDD), m_bIsMenuBarExist(bIsMenuBarExist)
{
	//{{AFX_DATA_INIT(CMFCToolBarsOptionsPropertyPage)
	m_bShowTooltips = CMFCToolBar::m_bShowTooltips;
	m_bShowShortcutKeys = CMFCToolBar::m_bShowShortcutKeys;
	m_bRecentlyUsedMenus = CMFCMenuBar::m_bRecentlyUsedMenus;
	m_bShowAllMenusDelay = CMFCMenuBar::m_bShowAllMenusDelay;
	m_bLargeIcons = CMFCToolBar::m_bLargeIcons;
	//}}AFX_DATA_INIT
}

CMFCToolBarsOptionsPropertyPage::~CMFCToolBarsOptionsPropertyPage()
{
}

void CMFCToolBarsOptionsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsOptionsPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_LARGE_ICONS, m_wndLargeIcons);
	DDX_Control(pDX, IDC_AFXBARRES_SHOW_RECENTLY_USED_MENUS, m_wndRUMenus);
	DDX_Control(pDX, IDC_AFXBARRES_RESET_USAGE_DATA, m_wndResetUsageBtn);
	DDX_Control(pDX, IDC_AFX_RU_MENUS_TITLE, m_wndRuMenusLine);
	DDX_Control(pDX, IDC_AFX_RU_MENUS_LINE, m_wndRuMenusTitle);
	DDX_Control(pDX, IDC_AFXBARRES_SHOW_MENUS_DELAY, m_wndShowAllMenusDelay);
	DDX_Control(pDX, IDC_AFXBARRES_SHOW_TOOLTIPS_WITH_KEYS, m_wndShowShortcutKeys);
	DDX_Check(pDX, IDC_AFXBARRES_SHOW_TOOLTIPS, m_bShowTooltips);
	DDX_Check(pDX, IDC_AFXBARRES_SHOW_TOOLTIPS_WITH_KEYS, m_bShowShortcutKeys);
	DDX_Check(pDX, IDC_AFXBARRES_SHOW_RECENTLY_USED_MENUS, m_bRecentlyUsedMenus);
	DDX_Check(pDX, IDC_AFXBARRES_SHOW_MENUS_DELAY, m_bShowAllMenusDelay);
	DDX_Check(pDX, IDC_AFXBARRES_LARGE_ICONS, m_bLargeIcons);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarsOptionsPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsOptionsPropertyPage)
	ON_BN_CLICKED(IDC_AFXBARRES_SHOW_TOOLTIPS_WITH_KEYS, &CMFCToolBarsOptionsPropertyPage::OShowTooltipsWithKeys)
	ON_BN_CLICKED(IDC_AFXBARRES_SHOW_TOOLTIPS, &CMFCToolBarsOptionsPropertyPage::OnShowTooltips)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_USAGE_DATA, &CMFCToolBarsOptionsPropertyPage::OnResetUsageData)
	ON_BN_CLICKED(IDC_AFXBARRES_SHOW_RECENTLY_USED_MENUS, &CMFCToolBarsOptionsPropertyPage::OnShowRecentlyUsedMenus)
	ON_BN_CLICKED(IDC_AFXBARRES_SHOW_MENUS_DELAY, &CMFCToolBarsOptionsPropertyPage::OnShowMenusDelay)
	ON_BN_CLICKED(IDC_AFXBARRES_LARGE_ICONS, &CMFCToolBarsOptionsPropertyPage::OnLargeIcons)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsOptionsPropertyPage message handlers

BOOL CMFCToolBarsOptionsPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_wndShowShortcutKeys.EnableWindow(m_bShowTooltips);
	m_wndShowAllMenusDelay.EnableWindow(m_bRecentlyUsedMenus);

	if (CMFCToolBar::m_lstBasicCommands.IsEmpty() || !m_bIsMenuBarExist)
	{
		m_wndRUMenus.ShowWindow(SW_HIDE);
		m_wndRUMenus.EnableWindow(FALSE);

		m_wndResetUsageBtn.ShowWindow(SW_HIDE);
		m_wndResetUsageBtn.EnableWindow(FALSE);

		m_wndRuMenusLine.ShowWindow(SW_HIDE);
		m_wndRuMenusLine.EnableWindow(FALSE);

		m_wndRuMenusTitle.ShowWindow(SW_HIDE);
		m_wndRuMenusTitle.EnableWindow(FALSE);

		m_wndShowAllMenusDelay.ShowWindow(SW_HIDE);
		m_wndShowAllMenusDelay.EnableWindow(FALSE);
	}

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	if (pWndParent->GetFlags() & AFX_CUSTOMIZE_NO_LARGE_ICONS)
	{
		m_wndLargeIcons.ShowWindow(SW_HIDE);
		m_wndLargeIcons.EnableWindow(FALSE);
		m_bLargeIcons = FALSE;
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCToolBarsOptionsPropertyPage::OShowTooltipsWithKeys()
{
	UpdateData();
	CMFCToolBar::m_bShowShortcutKeys = m_bShowShortcutKeys;
}

void CMFCToolBarsOptionsPropertyPage::OnShowTooltips()
{
	UpdateData();
	CMFCToolBar::m_bShowTooltips = m_bShowTooltips;
	m_wndShowShortcutKeys.EnableWindow(m_bShowTooltips);
}

void CMFCToolBarsOptionsPropertyPage::OnResetUsageData()
{
	if (AfxMessageBox(IDS_AFXBARRES_RESET_USAGE_WARNING, MB_YESNO) == IDYES)
	{
		CMFCToolBar::m_UsageCount.Reset();
	}
}

void CMFCToolBarsOptionsPropertyPage::OnShowRecentlyUsedMenus()
{
	UpdateData();
	m_wndShowAllMenusDelay.EnableWindow(m_bRecentlyUsedMenus);
	CMFCMenuBar::m_bRecentlyUsedMenus = m_bRecentlyUsedMenus;
}

void CMFCToolBarsOptionsPropertyPage::OnShowMenusDelay()
{
	UpdateData();
	CMFCMenuBar::m_bShowAllMenusDelay = m_bShowAllMenusDelay;
}

void CMFCToolBarsOptionsPropertyPage::OnLargeIcons()
{
	UpdateData();
	CMFCToolBar::SetLargeIcons(m_bLargeIcons);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarsmenupropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxtoolbarsmenupropertypage.h"
#include "afxmenubar.h"
#include "afxmenuhash.h"
#include "afxpopupmenu.h"
#include "afxcontextmenumanager.h"
#include "afxmultidoctemplateex.h"
#include "afxtoolbarscustomizedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern CObList afxAllToolBars;

CPoint CMFCToolBarsMenuPropertyPage::m_ptMenuLastPos = CPoint(100, 100);

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsMenuPropertyPage property page

IMPLEMENT_DYNCREATE(CMFCToolBarsMenuPropertyPage, CPropertyPage)

CMFCToolBarsMenuPropertyPage::CMFCToolBarsMenuPropertyPage(CFrameWnd* pParentFrame, BOOL bAutoSet) :
	CPropertyPage(CMFCToolBarsMenuPropertyPage::IDD), m_pParentFrame(pParentFrame), m_bAutoSet(bAutoSet)
{
	//{{AFX_DATA_INIT(CMFCToolBarsMenuPropertyPage)
	m_strMenuDescr = _T("");
	m_strContextMenuName = _T("");
	m_strMenuName = _T("");
	m_iMenuAnimationType = (int) CMFCPopupMenu::m_AnimationType;
	m_bMenuShadows = CMFCMenuBar::IsMenuShadows();
	//}}AFX_DATA_INIT

	m_pMenuBar = NULL;
	m_hmenuCurr = NULL;
	m_hmenuSelected = NULL;
	m_pContextMenu = NULL;
	m_bIsDefaultMDIMenu = FALSE;
	m_uiContextMenuResId = 0;
}

CMFCToolBarsMenuPropertyPage::~CMFCToolBarsMenuPropertyPage()
{
}

void CMFCToolBarsMenuPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsMenuPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_MENU_ANIMATION_LABEL, m_wndMenuAnimationsLabel);
	DDX_Control(pDX, IDC_AFXBARRES_MENU_ANIMATION, m_wndMenuAnimations);
	DDX_Control(pDX, IDC_AFXBARRES_MENU_SHADOWS, m_wndMenuShadows);
	DDX_Control(pDX, IDC_AFXBARRES_CONTEXT_FRAME, m_wndContextFrame);
	DDX_Control(pDX, IDC_AFXBARRES_CONTEXT_HINT, m_wndContextHint);
	DDX_Control(pDX, IDC_AFXBARRES_RESET_MENU, m_wndResetMenuButton);
	DDX_Control(pDX, IDC_AFXBARRES_CONTEXT_MENU_CAPTION, m_wndContextMenuCaption);
	DDX_Control(pDX, IDC_AFXBARRES_CONTEXT_MENU_LIST, m_wndContextMenus);
	DDX_Control(pDX, IDC_AFXBARRES_TEMPL_ICON, m_wndIcon);
	DDX_Control(pDX, IDC_AFXBARRES_MENU_LIST, m_wndMenuesList);
	DDX_Text(pDX, IDC_AFXBARRES_MENU_DESCRIPTION, m_strMenuDescr);
	DDX_CBString(pDX, IDC_AFXBARRES_CONTEXT_MENU_LIST, m_strContextMenuName);
	DDX_CBString(pDX, IDC_AFXBARRES_MENU_LIST, m_strMenuName);
	DDX_CBIndex(pDX, IDC_AFXBARRES_MENU_ANIMATION, m_iMenuAnimationType);
	DDX_Check(pDX, IDC_AFXBARRES_MENU_SHADOWS, m_bMenuShadows);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMFCToolBarsMenuPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsMenuPropertyPage)
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_AFXBARRES_MENU_LIST, &CMFCToolBarsMenuPropertyPage::OnSelchangeMenuList)
	ON_CBN_SELCHANGE(IDC_AFXBARRES_CONTEXT_MENU_LIST, &CMFCToolBarsMenuPropertyPage::OnSelchangeContextMenuList)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_MENU, &CMFCToolBarsMenuPropertyPage::OnResetMenu)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_FRAME_MENU, &CMFCToolBarsMenuPropertyPage::OnResetFrameMenu)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsMenuPropertyPage message handlers

BOOL CMFCToolBarsMenuPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	if (m_iMenuAnimationType == (int) CMFCPopupMenu::SYSTEM_DEFAULT_ANIMATION)
	{
		m_iMenuAnimationType = m_wndMenuAnimations.GetCount() - 1;
		UpdateData(FALSE);
	}

	POSITION pos = NULL;

	// Find application Menu Bar object(assume that only one):
	for (pos = afxAllToolBars.GetHeadPosition(); m_pMenuBar == NULL && pos != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);
			m_pMenuBar = DYNAMIC_DOWNCAST(CMFCMenuBar, pToolBar);
		}
	}

	if (m_pMenuBar != NULL)
	{
		m_pMenuBar->m_pMenuPage = this;

		int iCurrMenu = -1;

		// Save MenuBar current menu:
		m_hmenuCurr = m_pMenuBar->GetHMenu();

		m_pMenuBar->OnChangeHot(-1);
		afxMenuHash.SaveMenuBar(m_hmenuCurr, m_pMenuBar);

		// Find all application document templates and fill menues combobox
		// by document template data:
		CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
		if (m_bAutoSet && pDocManager != NULL)
		{
			// Walk all templates in the application:
			for (pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
			{
				CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
				ASSERT_VALID(pTemplate);
				ASSERT_KINDOF(CDocTemplate, pTemplate);

				// We are interessing CMultiDocTemplate objects with
				// the shared menu only....
				if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hMenuShared == NULL)
				{
					continue;
				}

				// Maybe, the template with same ID is already exist?
				BOOL bIsAlreadyExist = FALSE;
				for (int i = 0; !bIsAlreadyExist && i < m_wndMenuesList.GetCount(); i++)
				{
					CMultiDocTemplateEx* pListTemplate = (CMultiDocTemplateEx*) m_wndMenuesList.GetItemData(i);
					bIsAlreadyExist = pListTemplate != NULL && pListTemplate->GetResId() == pTemplate->GetResId();
				}

				if (!bIsAlreadyExist)
				{
					CString strName;
					pTemplate->GetDocString(strName, CDocTemplate::fileNewName);

					int iIndex = m_wndMenuesList.AddString(strName);
					m_wndMenuesList.SetItemData(iIndex, (DWORD_PTR) pTemplate);

					if (pTemplate->m_hMenuShared == m_hmenuCurr)
					{
						iCurrMenu = iIndex;
					}
				}
			}
		}

		// Add a default frame menu:
		CString strName;
		ENSURE(strName.LoadString(IDS_AFXBARRES_DEFUALT_MENU));

		int iIndex = m_wndMenuesList.AddString(strName);
		m_wndMenuesList.SetItemData(iIndex, (DWORD_PTR) NULL);

		if (iCurrMenu == -1)
		{
			m_bIsDefaultMDIMenu = TRUE;
			iCurrMenu = iIndex;
		}

		m_hmenuSelected = m_hmenuCurr;
		m_wndMenuesList.SetCurSel(iCurrMenu);

		// Add menu animation values
		CString strAnimation;

		ENSURE(strAnimation.LoadString(IDS_AFXBARRES_MENU_ANIMATION_NONE));
		m_wndMenuAnimations.InsertString(-1, strAnimation);
		ENSURE(strAnimation.LoadString(IDS_AFXBARRES_MENU_ANIMATION_UNFOLD));
		m_wndMenuAnimations.InsertString(-1, strAnimation);
		ENSURE(strAnimation.LoadString(IDS_AFXBARRES_MENU_ANIMATION_SLIDE));
		m_wndMenuAnimations.InsertString(-1, strAnimation);
		ENSURE(strAnimation.LoadString(IDS_AFXBARRES_MENU_ANIMATION_FADE));
		m_wndMenuAnimations.InsertString(-1, strAnimation);
		ENSURE(strAnimation.LoadString(IDS_AFXBARRES_MENU_ANIMATION_DEFAULT));
		m_wndMenuAnimations.InsertString(-1, strAnimation);

		UpdateData(FALSE);
		OnSelchangeMenuList();
	}
	else
	{
		// No menubar found, disable menu selecting engine:
		m_wndMenuesList.EnableWindow(FALSE);
		GetDlgItem(IDC_AFXBARRES_RESET_FRAME_MENU)->EnableWindow(FALSE);

		ENSURE(m_strMenuDescr.LoadString(IDS_AFXBARRES_NO_MENUBAR));

		UpdateData(FALSE);
	}

	// Initialize context menus:
	{
		CString strNoContextMenu;
		ENSURE(strNoContextMenu.LoadString(IDS_AFXBARRES_NO_CONTEXT));

		m_wndContextMenus.AddString(strNoContextMenu);
		m_wndContextMenus.SetCurSel(0);
	}

	if (afxContextMenuManager != NULL)
	{
		CStringList listOfNames;
		afxContextMenuManager->GetMenuNames(listOfNames);

		for (pos = listOfNames.GetHeadPosition(); pos != NULL;)
		{
			CString strName = listOfNames.GetNext(pos);
			m_wndContextMenus.AddString(strName);
		}

		m_wndContextMenuCaption.EnableWindow(m_wndContextMenus.GetCount() > 1);
		m_wndContextMenus.EnableWindow(m_wndContextMenus.GetCount() > 1);
	}
	else
	{
		// Hide all context menus fields:
		m_wndContextMenuCaption.ShowWindow(SW_HIDE);
		m_wndContextMenus.ShowWindow(SW_HIDE);
		m_wndContextHint.ShowWindow(SW_HIDE);
		m_wndContextFrame.ShowWindow(SW_HIDE);
		m_wndResetMenuButton.ShowWindow(SW_HIDE);
	}

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	if ((pWndParent->GetFlags() & AFX_CUSTOMIZE_MENU_SHADOWS) == 0)
	{
		m_wndMenuShadows.ShowWindow(SW_HIDE);
	}

	if ((pWndParent->GetFlags() & AFX_CUSTOMIZE_MENU_ANIMATIONS) == 0)
	{
		m_wndMenuAnimationsLabel.ShowWindow(SW_HIDE);
		m_wndMenuAnimations.ShowWindow(SW_HIDE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCToolBarsMenuPropertyPage::OnSelchangeMenuList()
{
	UpdateData();

	if (m_pMenuBar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (m_hmenuSelected != NULL)
	{
		m_pMenuBar->OnChangeHot(-1);
		afxMenuHash.SaveMenuBar(m_hmenuSelected, m_pMenuBar);
	}

	int iIndex = m_wndMenuesList.GetCurSel();
	if (iIndex == CB_ERR)
	{
		m_strMenuDescr = _T("");
		m_wndIcon.SetIcon(NULL);
		UpdateData(FALSE);
		m_hmenuSelected = NULL;
		return;
	}

	HICON hicon = NULL;
	HMENU hmenu = NULL;

	CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) m_wndMenuesList.GetItemData(iIndex);
	if (pTemplate != NULL)
	{
		ASSERT_VALID(pTemplate);

		pTemplate->GetDocString(m_strMenuDescr, CDocTemplate::regFileTypeName);

		hicon = AfxGetApp()->LoadIcon(pTemplate->GetResId());
		if (hicon == NULL)
		{
			hicon = ::LoadIcon(NULL, IDI_APPLICATION);
		}

		hmenu = pTemplate->m_hMenuShared;
	}
	else
	{
		ENSURE(m_strMenuDescr.LoadString(IDS_AFXBARRES_DEFAULT_MENU_DESCR));

		CWnd* pWndMain = AfxGetMainWnd();
		if (pWndMain != NULL)
		{
			hicon = (HICON)(LONG_PTR) GetClassLongPtr(*pWndMain, GCLP_HICON);
		}

		hmenu = m_pMenuBar->GetDefaultMenu();
	}

	ENSURE(hmenu != NULL);

	m_pMenuBar->CreateFromMenu(hmenu);
	m_wndIcon.SetIcon(hicon);

	m_hmenuSelected = hmenu;
	UpdateData(FALSE);
}

void CMFCToolBarsMenuPropertyPage::OnDestroy()
{
	UpdateData();

	CMFCPopupMenu::m_AnimationType = m_iMenuAnimationType == m_wndMenuAnimations.GetCount() - 1 ? CMFCPopupMenu::SYSTEM_DEFAULT_ANIMATION :
	(CMFCPopupMenu::ANIMATION_TYPE) m_iMenuAnimationType;

	if (m_pMenuBar != NULL)
	{
		m_pMenuBar->m_pMenuPage = NULL;

		// Save the selected menu state:
		if (m_hmenuSelected != NULL)
		{
			m_pMenuBar->OnChangeHot(-1); // To close and save all popups
			afxMenuHash.SaveMenuBar(m_hmenuSelected, m_pMenuBar);
		}

		// Restore the current menu:
		if (m_hmenuCurr != NULL)
		{
			m_pMenuBar->CreateFromMenu(m_hmenuCurr);
		}
	}

	// Release the context menu resources:
	if (m_pContextMenu != NULL)
	{
		m_pContextMenu->GetMenuBar()->SendMessage(WM_CANCELMODE);
		SaveMenu();
		m_pContextMenu->SendMessage(WM_CLOSE);
	}

	// Update shdows appearance:
	CMFCMenuBar::EnableMenuShadows(m_bMenuShadows);
	CPropertyPage::OnDestroy();
}

void CMFCToolBarsMenuPropertyPage::OnSelchangeContextMenuList()
{
	m_wndResetMenuButton.EnableWindow(FALSE);

	if (afxContextMenuManager == NULL)
	{
		return;
	}

	m_uiContextMenuResId = 0;

	// First, save and close the current menu:
	if (m_pContextMenu != NULL)
	{
		SaveMenu();

		CMFCPopupMenu* pMenu = m_pContextMenu;
		m_pContextMenu = NULL;
		pMenu->SendMessage(WM_CLOSE);
	}

	if (m_wndContextMenus.GetCurSel() <= 0)
	{
		// No is menu selected, nothing to do...
		return;
	}

	UpdateData();

	HMENU hMenu = afxContextMenuManager->GetMenuByName(m_strContextMenuName, &m_uiContextMenuResId);

	if (hMenu == NULL)
	{
		MessageBeep((UINT) -1);
		return;
	}

	HMENU hmenuPopup = ::GetSubMenu(hMenu, 0);
	if (hmenuPopup == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	m_pContextMenu = new CMFCPopupMenu(this, m_strContextMenuName);
	ENSURE(m_pContextMenu != NULL);

	m_pContextMenu->SetAutoDestroy(FALSE);

	if (!m_pContextMenu->Create(GetTopLevelFrame(), m_ptMenuLastPos.x, m_ptMenuLastPos.y, hmenuPopup))
	{
		AfxMessageBox(_T("Can't create context menu!"));
	}
	else
	{
		m_wndResetMenuButton.EnableWindow();
	}
}

void CMFCToolBarsMenuPropertyPage::CloseContextMenu(CMFCPopupMenu* pMenu)
{
	UNUSED_ALWAYS(pMenu);

	if (m_pContextMenu == NULL)
	{
		return;
	}

	ENSURE(m_pContextMenu == pMenu);

	SaveMenu();

	if (m_pContextMenu != NULL)
	{
		m_pContextMenu = NULL;
		m_wndContextMenus.SetCurSel(0);

		m_wndResetMenuButton.EnableWindow(FALSE);
	}

	m_uiContextMenuResId = 0;
}

void CMFCToolBarsMenuPropertyPage::SaveMenu()
{
	if (m_pContextMenu == NULL)
	{
		return;
	}

	// Save current menu position:
	CRect rectMenu;
	m_pContextMenu->GetWindowRect(&rectMenu);
	m_ptMenuLastPos = rectMenu.TopLeft();

	// Save menu context:
	afxMenuHash.SaveMenuBar(m_pContextMenu->m_hMenu, m_pContextMenu->GetMenuBar());
}

void CMFCToolBarsMenuPropertyPage::OnResetMenu()
{
	if (afxContextMenuManager == NULL)
	{
		return;
	}

	ENSURE(m_pContextMenu != NULL);

	{
		CString strPrompt;
		strPrompt.Format(IDS_AFXBARRES_RESET_MENU_FMT, m_strContextMenuName);

		if (AfxMessageBox(strPrompt, MB_YESNO | MB_ICONQUESTION) != IDYES)
		{
			return;
		}
	}

	HMENU hMenu = afxContextMenuManager->GetMenuByName(m_strContextMenuName, &m_uiContextMenuResId);
	if (hMenu == NULL)
	{
		MessageBeep((UINT) -1);
		return;
	}

	m_pContextMenu->GetMenuBar()->ImportFromMenu(::GetSubMenu(hMenu, 0));

	// Send notification to application main frame:
	if (m_pParentFrame != NULL)
	{
		m_pParentFrame->SendMessage(AFX_WM_RESETCONTEXTMENU, (WPARAM) m_uiContextMenuResId, (LPARAM) m_pContextMenu);
	}

	OnSelchangeContextMenuList();

	m_pContextMenu->RecalcLayout();
	m_pContextMenu->GetMenuBar()->Invalidate();
}

void CMFCToolBarsMenuPropertyPage::OnResetFrameMenu()
{
	UpdateData();

	if (m_pMenuBar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	int iIndex = m_wndMenuesList.GetCurSel();
	if (iIndex == CB_ERR)
	{
		ASSERT(FALSE);
		return;
	}

	{
		CString strPrompt;
		strPrompt.Format(IDS_AFXBARRES_RESET_MENU_FMT, m_strMenuName);

		if (AfxMessageBox(strPrompt, MB_YESNO | MB_ICONQUESTION) != IDYES)
		{
			return;
		}
	}

	HMENU hOldMenu = NULL;

	CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) m_wndMenuesList.GetItemData(iIndex);
	if (pTemplate != NULL) // Document's menu
	{
		ASSERT_VALID(pTemplate);

		HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(pTemplate->GetResId()), RT_MENU);

		BOOL bIsCurrent = (pTemplate->m_hMenuShared == m_hmenuCurr);

		hOldMenu = pTemplate->m_hMenuShared;

		pTemplate->m_hMenuShared = ::LoadMenuW(hInst, MAKEINTRESOURCEW(pTemplate->GetResId()));
		m_pMenuBar->CreateFromMenu(pTemplate->m_hMenuShared, FALSE);

		CMFCMenuBar::UpdateMDIChildrenMenus(pTemplate);

		if (m_pParentFrame != NULL)
		{
			if (m_pParentFrame->SendMessage(AFX_WM_RESETMENU, pTemplate->GetResId()))
			{
				m_pMenuBar->AdjustLayout();
			};
		}

		afxMenuHash.SaveMenuBar(pTemplate->m_hMenuShared, m_pMenuBar);

		if (bIsCurrent)
		{
			ASSERT(!m_bIsDefaultMDIMenu);
			m_hmenuCurr = pTemplate->m_hMenuShared;
		}
	}
	else // Frame's default menu
	{
		UINT uiDefMenuResId = m_pMenuBar->GetDefaultMenuResId();
		if (uiDefMenuResId != 0)
		{
			HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiDefMenuResId), RT_MENU);

			hOldMenu = m_pMenuBar->m_hDefaultMenu;

			HMENU hDefaultMenu = ::LoadMenuW(hInst, MAKEINTRESOURCEW(uiDefMenuResId));
			m_pMenuBar->OnDefaultMenuLoaded(hDefaultMenu);

			m_pMenuBar->CreateFromMenu(hDefaultMenu, TRUE);

			if (m_pParentFrame != NULL)
			{
				if (m_pParentFrame->SendMessage(AFX_WM_RESETMENU, uiDefMenuResId))
				{
					m_pMenuBar->AdjustLayout();
				}

				m_pParentFrame->m_hMenuDefault = hDefaultMenu;
			}

			afxMenuHash.SaveMenuBar(hDefaultMenu, m_pMenuBar);

			if (m_bIsDefaultMDIMenu)
			{
				m_hmenuCurr = hDefaultMenu;
			}
		}
	}

	if (m_pParentFrame != NULL)
	{
		m_pParentFrame->OnUpdateFrameMenu(m_hmenuCurr);
	}

	if (hOldMenu != NULL)
	{
		ENSURE(::IsMenu(hOldMenu));

		afxMenuHash.RemoveMenu(hOldMenu);
		::DestroyMenu(hOldMenu);
	}

	m_pMenuBar->Invalidate();
	m_pMenuBar->UpdateWindow();
}

BOOL CMFCToolBarsMenuPropertyPage::SelectMenu(CDocTemplate* pTemplate, BOOL bSaveCurr)
{
	for (int i = 0; i < m_wndMenuesList.GetCount(); i++)
	{
		if ((CDocTemplate*) m_wndMenuesList.GetItemData(i) == pTemplate)
		{
			if (!bSaveCurr)
			{
				m_hmenuSelected = NULL; // To prevent saving
			}

			if (m_pMenuBar != NULL)
			{
				m_hmenuCurr = m_pMenuBar->GetHMenu();
			}

			m_wndMenuesList.SetCurSel(i);
			OnSelchangeMenuList();

			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarspineditboxbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxtoolbarspineditboxbutton.h"
#include "afxaccessibility.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_SERIAL(CMFCToolBarSpinEditBoxButton, CMFCToolBarEditBoxButton, 1)

CMFCToolBarSpinEditBoxButton::CMFCToolBarSpinEditBoxButton()
{
	Init();
}

CMFCToolBarSpinEditBoxButton::CMFCToolBarSpinEditBoxButton(UINT uiId, int iImage, DWORD dwStyle, int iWidth) :
	CMFCToolBarEditBoxButton(uiId, iImage, dwStyle, iWidth)
{
	Init();
}

void CMFCToolBarSpinEditBoxButton::Init()
{
	m_nMin = INT_MIN;
	m_nMax = INT_MAX;
}

CMFCToolBarSpinEditBoxButton::~CMFCToolBarSpinEditBoxButton()
{
	if (m_wndSpin.GetSafeHwnd() != NULL)
	{
		m_wndSpin.DestroyWindow();
	}
}

BOOL CMFCToolBarSpinEditBoxButton::SetACCData(CWnd* pParent, CAccessibilityData& data)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParent);

	if (!CMFCToolBarEditBoxButton::SetACCData(pParent, data))
	{
		return FALSE;
	}

	data.m_strAccValue = m_strText;
	return TRUE;
}

CEdit* CMFCToolBarSpinEditBoxButton::CreateEdit(CWnd* pWndParent, const CRect& rect)
{
	CEdit *pEdit = CMFCToolBarEditBoxButton::CreateEdit(pWndParent,rect);
	if (pEdit == NULL)
	{
		return NULL;
	}

	if (!m_wndSpin.Create(WS_CHILD | WS_VISIBLE | UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT, rect, pWndParent, m_nID))
		return NULL;

	m_wndSpin.SetBuddy(pEdit);
	m_wndSpin.SetRange32(m_nMin, m_nMax);

	return pEdit;
}

void CMFCToolBarSpinEditBoxButton::OnMove()
{
	CMFCToolBarEditBoxButton::OnMove();

	if (m_pWndEdit->GetSafeHwnd() != NULL)
	{
		m_wndSpin.SetBuddy(m_pWndEdit);
	}
}

void CMFCToolBarSpinEditBoxButton::GetEditBorder(CRect& rectBorder)
{
	ASSERT(m_pWndEdit->GetSafeHwnd() != NULL);

	m_pWndEdit->GetWindowRect(rectBorder);
	m_pWndEdit->GetParent()->ScreenToClient(rectBorder);

	CRect rectSpin;
	m_wndSpin.GetWindowRect(rectSpin);
	m_wndSpin.GetParent()->ScreenToClient(rectSpin);

	rectBorder.right = rectSpin.right;

	rectBorder.InflateRect(1, 1);
}

void CMFCToolBarSpinEditBoxButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarEditBoxButton::CopyFrom(s);

	const CMFCToolBarSpinEditBoxButton& src = (const CMFCToolBarSpinEditBoxButton&) s;

	m_nMin = src.m_nMin;
	m_nMax = src.m_nMax;
}

void CMFCToolBarSpinEditBoxButton::Serialize(CArchive& ar)
{
	CMFCToolBarEditBoxButton::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_nMin;
		ar >> m_nMax;
	}
	else
	{
		ar << m_nMin;
		ar << m_nMax;
	}
}

void CMFCToolBarSpinEditBoxButton::SetRange(int nMin, int nMax)
{
	ASSERT_VALID(this);

	m_nMin = nMin;
	m_nMax = nMax;

	if (m_wndSpin.GetSafeHwnd() != NULL)
	{
		m_wndSpin.SetRange32(nMin, nMax);
	}
}

void CMFCToolBarSpinEditBoxButton::GetRange(int& nMin, int& nMax)
{
	ASSERT_VALID(this);

	nMin = m_nMin;
	nMax = m_nMax;
}

BOOL CMFCToolBarSpinEditBoxButton::OnUpdateToolTip(CWnd* /*pWndParent*/, int /*iButtonIndex*/, CToolTipCtrl& wndToolTip, CString& strTipText)
{
	CEdit* pEdit = GetEditBox();
	CSpinButtonCtrl* pSpin = GetSpinControl();

	if ((pEdit != NULL) &&(::IsWindow(pEdit->GetSafeHwnd())))
	{
		CString strTips;

		if (OnGetCustomToolTipText(strTips))
		{
			wndToolTip.AddTool(pEdit, strTips, NULL, 0);
			wndToolTip.AddTool(pSpin, strTips, NULL, 0);
		}
		else
		{
			wndToolTip.AddTool(pEdit, strTipText, NULL, 0);
			wndToolTip.AddTool(pSpin, strTipText, NULL, 0);
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCToolBarSpinEditBoxButton::OnShowEditbox(BOOL bShow)
{
	if (m_wndSpin.GetSafeHwnd() != NULL)
	{
		m_wndSpin.ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarskeyboardpropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxtoolbarskeyboardpropertypage.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxtoolbarbutton.h"
#include "afxacceleratorkey.h"
#include "afxkeyboardmanager.h"
#include "afxmultidoctemplateex.h"
#include "afxtoolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsKeyboardPropertyPage property page

IMPLEMENT_DYNCREATE(CMFCToolBarsKeyboardPropertyPage, CPropertyPage)

CMFCToolBarsKeyboardPropertyPage::CMFCToolBarsKeyboardPropertyPage(CFrameWnd* pParentFrame, BOOL bAutoSet) :
	CPropertyPage(CMFCToolBarsKeyboardPropertyPage::IDD), m_pParentFrame(pParentFrame), m_bAutoSet(bAutoSet)
{
	ASSERT_VALID(m_pParentFrame);

	//{{AFX_DATA_INIT(CMFCToolBarsKeyboardPropertyPage)
	m_strDescription = _T("");
	m_strAssignedTo = _T("");
	//}}AFX_DATA_INIT

	m_hAccelTable = NULL;
	m_lpAccel = NULL;
	m_nAccelSize = 0;
	m_pSelTemplate = NULL;
	m_pSelButton = NULL;
	m_pSelEntry = NULL;
}

CMFCToolBarsKeyboardPropertyPage::~CMFCToolBarsKeyboardPropertyPage()
{
	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
	}
}

void CMFCToolBarsKeyboardPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsKeyboardPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_ASSIGNED_TO_TITLE, m_wndAssignedToTitle);
	DDX_Control(pDX, IDC_AFXBARRES_NEW_SHORTCUT_KEY, m_wndNewKey);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_TYPE, m_wndViewTypeList);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_ICON, m_wndViewIcon);
	DDX_Control(pDX, IDC_AFXBARRES_REMOVE, m_wndRemoveButton);
	DDX_Control(pDX, IDC_AFXBARRES_CURRENT_KEYS_LIST, m_wndCurrentKeysList);
	DDX_Control(pDX, IDC_AFXBARRES_COMMANDS_LIST, m_wndCommandsList);
	DDX_Control(pDX, IDC_AFXBARRES_CATEGORY, m_wndCategoryList);
	DDX_Control(pDX, IDC_AFXBARRES_ASSIGN, m_wndAssignButton);
	DDX_Text(pDX, IDC_AFXBARRES_COMMAND_DESCRIPTION, m_strDescription);
	DDX_Text(pDX, IDC_AFXBARRES_ASSIGNED_TO, m_strAssignedTo);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarsKeyboardPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsKeyboardPropertyPage)
	ON_BN_CLICKED(IDC_AFXBARRES_ASSIGN, &CMFCToolBarsKeyboardPropertyPage::OnAssign)
	ON_BN_CLICKED(IDC_AFXBARRES_REMOVE, &CMFCToolBarsKeyboardPropertyPage::OnRemove)
	ON_BN_CLICKED(IDC_AFXBARRES_RESET_SHORTCUTS, &CMFCToolBarsKeyboardPropertyPage::OnResetAll)
	ON_CBN_SELCHANGE(IDC_AFXBARRES_CATEGORY, &CMFCToolBarsKeyboardPropertyPage::OnSelchangeCategory)
	ON_CBN_SELCHANGE(IDC_AFXBARRES_VIEW_TYPE, &CMFCToolBarsKeyboardPropertyPage::OnSelchangeViewType)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_COMMANDS_LIST, &CMFCToolBarsKeyboardPropertyPage::OnSelchangeCommandsList)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_CURRENT_KEYS_LIST, &CMFCToolBarsKeyboardPropertyPage::OnSelchangeCurrentKeysList)
	ON_EN_UPDATE(IDC_AFXBARRES_NEW_SHORTCUT_KEY, &CMFCToolBarsKeyboardPropertyPage::OnUpdateNewShortcutKey)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsKeyboardPropertyPage message handlers

BOOL CMFCToolBarsKeyboardPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	ENSURE(afxKeyboardManager != NULL);

	// Initialize commands by category:
	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ASSERT_VALID(pWndParent);

	pWndParent->FillCategoriesComboBox(m_wndCategoryList, FALSE);

	m_wndCategoryList.SetCurSel(0);
	OnSelchangeCategory();

	// Find all application document templates and fill menues combobox
	// by document template data:
	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (m_bAutoSet && pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplateEx objects with
			// the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			// Maybe, the template with same ID is already exist?
			BOOL bIsAlreadyExist = FALSE;
			for (int i = 0; !bIsAlreadyExist && i < m_wndViewTypeList.GetCount(); i++)
			{
				CMultiDocTemplateEx* pListTemplate = (CMultiDocTemplateEx*) m_wndViewTypeList.GetItemData(i);
				bIsAlreadyExist = pListTemplate != NULL && pListTemplate->GetResId() == pTemplate->GetResId();
			}

			if (!bIsAlreadyExist)
			{
				CString strName;
				pTemplate->GetDocString(strName, CDocTemplate::fileNewName);

				int iIndex = m_wndViewTypeList.AddString(strName);
				m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) pTemplate);
			}
		}
	}

	// Add a default application:
	CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pParentFrame);
	if (pWndMain != NULL && pWndMain->m_hAccelTable != NULL)
	{
		CString strName;
		ENSURE(strName.LoadString(IDS_AFXBARRES_DEFAULT_VIEW));

		int iIndex = m_wndViewTypeList.AddString(strName);
		m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) NULL);

		m_wndViewTypeList.SetCurSel(iIndex);
		OnSelchangeViewType();
	}

	if (m_wndViewTypeList.GetCurSel() == CB_ERR)
	{
		m_wndViewTypeList.SetCurSel(0);
		OnSelchangeViewType();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCToolBarsKeyboardPropertyPage::OnAssign()
{
	ENSURE(m_lpAccel != NULL);
	ENSURE(m_pSelButton != NULL);

	// Obtain a new acceleration entry from the keyboard control:
	ENSURE(m_wndNewKey.IsKeyDefined());

	ACCEL* pAccel = (ACCEL*) m_wndNewKey.GetAccel();
	ENSURE(pAccel != NULL);

	pAccel->cmd = (USHORT) m_pSelButton->m_nID;

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ASSERT_VALID(pWndParent);

	if (!pWndParent->OnAssignKey(pAccel))
	{
		return;
	}

	// Create a new entries array:
	LPACCEL lpAccelOld = m_lpAccel;

	m_lpAccel = new ACCEL [m_nAccelSize + 1];
	ENSURE(m_lpAccel != NULL);

	memcpy(m_lpAccel, lpAccelOld, sizeof(ACCEL) * m_nAccelSize);

	int listcount = m_wndCurrentKeysList.GetCount();
	for (int i = 0; i < m_nAccelSize; i ++)
	{
		for (int idx=0; idx<listcount; idx++)
		{
			if ( m_wndCurrentKeysList.GetItemData(idx) == (DWORD_PTR) &lpAccelOld [i] )
			{
				m_wndCurrentKeysList.SetItemData(idx, (DWORD_PTR) &m_lpAccel [i]);
				break;
			}
		}
	}

	m_lpAccel [m_nAccelSize ++] = *pAccel;

	delete [] lpAccelOld;

	afxKeyboardManager->UpdateAccelTable(m_pSelTemplate, m_lpAccel, m_nAccelSize);

	AddKeyEntry(&m_lpAccel [m_nAccelSize - 1]);

	m_wndNewKey.ResetKey();
	OnUpdateNewShortcutKey();

	m_wndCommandsList.SetFocus();
}

void CMFCToolBarsKeyboardPropertyPage::OnSelchangeCategory()
{
	UpdateData();

	int iIndex = m_wndCategoryList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		ASSERT(FALSE);
		return;
	}

	m_wndCommandsList.ResetContent();
	m_wndCurrentKeysList.ResetContent();

	CObList* pCategoryButtonsList = (CObList*) m_wndCategoryList.GetItemData(iIndex);
	ASSERT_VALID(pCategoryButtonsList);

	CString strCategory;
	m_wndCategoryList.GetLBText(iIndex, strCategory);

	BOOL bAllCommands = (strCategory == m_strAllCategory);

	CClientDC dcCommands(&m_wndCommandsList);
	CFont* pOldFont = dcCommands.SelectObject(m_wndCommandsList.GetFont());
	ASSERT(pOldFont != NULL);

	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	int cxCommandsExtentMax = 0;

	for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
		ENSURE(pButton != NULL);

		if (pButton->m_nID > 0 && pButton->m_nID != (UINT) -1)
		{
			CString strText = pButton->m_strText;

			if (!pButton->m_strTextCustom.IsEmpty() && (bAllCommands || pWndParent->GetCountInCategory(strText, *pCategoryButtonsList) > 1))
			{
				strText = pButton->m_strTextCustom;
			}

			iIndex = m_wndCommandsList.AddString(strText);
			m_wndCommandsList.SetItemData(iIndex, (DWORD_PTR) pButton);

			cxCommandsExtentMax = max(cxCommandsExtentMax, dcCommands.GetTextExtent(strText).cx);
		}
	}

	m_wndCommandsList.SetHorizontalExtent(cxCommandsExtentMax + ::GetSystemMetrics(SM_CXHSCROLL));
	dcCommands.SelectObject(pOldFont);

	m_wndNewKey.EnableWindow(FALSE);

	m_wndCommandsList.SetCurSel(0);
	OnSelchangeCommandsList();
}

void CMFCToolBarsKeyboardPropertyPage::OnSelchangeCommandsList()
{
	m_strDescription.Empty();
	m_wndCurrentKeysList.ResetContent();
	OnSelchangeCurrentKeysList();

	int iIndex = m_wndCommandsList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		m_pSelButton = NULL;
		m_wndNewKey.EnableWindow(FALSE);

		UpdateData(FALSE);
		return;
	}

	// Set command description:
	m_pSelButton = (CMFCToolBarButton*) m_wndCommandsList.GetItemData(iIndex);
	ASSERT_VALID(m_pSelButton);

	CFrameWnd* pParent = GetParentFrame();
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->GetMessageString(m_pSelButton->m_nID, m_strDescription);
	}

	// Fill keys associated with selected command:
	if (m_lpAccel != NULL)
	{
		for (int i = 0; i < m_nAccelSize; i ++)
		{
			if (m_pSelButton->m_nID == m_lpAccel [i].cmd)
			{
				AddKeyEntry(&m_lpAccel [i]);
			}
		}
	}

	m_wndNewKey.EnableWindow();
	UpdateData(FALSE);
}

void CMFCToolBarsKeyboardPropertyPage::OnSelchangeCurrentKeysList()
{
	int iIndex = m_wndCurrentKeysList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		m_pSelEntry = NULL;
		m_wndRemoveButton.EnableWindow(FALSE);

		return;
	}

	m_pSelEntry = (LPACCEL) m_wndCurrentKeysList.GetItemData(iIndex);
	ENSURE(m_pSelEntry != NULL);

	m_wndRemoveButton.EnableWindow();
}

void CMFCToolBarsKeyboardPropertyPage::OnRemove()
{
	ENSURE(m_pSelEntry != NULL);
	ENSURE(m_lpAccel != NULL);

	// Create a new entries array:
	LPACCEL lpAccelOld = m_lpAccel;

	m_lpAccel = new ACCEL [m_nAccelSize - 1];
	ENSURE(m_lpAccel != NULL);

	int iNewIndex = 0;
	for (int i = 0; i < m_nAccelSize; i ++)
	{
		if (m_pSelEntry != &lpAccelOld [i])
		{
			m_lpAccel [iNewIndex ++] = lpAccelOld [i];

			int listcount = m_wndCurrentKeysList.GetCount();
			for (int idx=0; idx<listcount; idx++)
			{
				if ( m_wndCurrentKeysList.GetItemData(idx) == (DWORD_PTR) &lpAccelOld [i] )
				{
					m_wndCurrentKeysList.SetItemData(idx, (DWORD_PTR) &m_lpAccel [iNewIndex-1]);
					break;
				}
			}
		}
	}

	delete [] lpAccelOld;
	m_nAccelSize --;

	afxKeyboardManager->UpdateAccelTable(m_pSelTemplate, m_lpAccel, m_nAccelSize);

	OnSelchangeCommandsList();
	m_wndCommandsList.SetFocus();
}

void CMFCToolBarsKeyboardPropertyPage::OnResetAll()
{
	CString str;
	ENSURE(str.LoadString(IDS_AFXBARRES_RESET_KEYBOARD));

	if (AfxMessageBox(str, MB_YESNO | MB_ICONQUESTION) != IDYES)
	{
		return;
	}

	afxKeyboardManager->ResetAll();

	// Send notification to application main frame:
	if (m_pParentFrame != NULL)
	{
		m_pParentFrame->SendMessage(AFX_WM_RESETKEYBOARD);
	}

	OnSelchangeViewType();
	OnSelchangeCommandsList();
}

void CMFCToolBarsKeyboardPropertyPage::OnSelchangeViewType()
{
	m_hAccelTable = NULL;
	m_pSelTemplate = NULL;

	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
		m_lpAccel = NULL;
	}

	int iIndex = m_wndViewTypeList.GetCurSel();
	if (iIndex == CB_ERR)
	{
		m_wndViewIcon.SetIcon(NULL);
		return;
	}

	HICON hicon = NULL;

	CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) m_wndViewTypeList.GetItemData(iIndex);
	if (pTemplate != NULL)
	{
		ASSERT_VALID(pTemplate);

		hicon = AfxGetApp()->LoadIcon(pTemplate->GetResId());
		m_hAccelTable = pTemplate->m_hAccelTable;
	}
	else
	{
		CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pParentFrame);
		if (pWndMain != NULL)
		{
			hicon = (HICON)(LONG_PTR) GetClassLongPtr(*pWndMain, GCLP_HICON);
			m_hAccelTable = pWndMain->m_hAccelTable;
		}
	}

	if (hicon == NULL)
	{
		hicon = ::LoadIcon(NULL, IDI_APPLICATION);
	}

	m_wndViewIcon.SetIcon(hicon);

	ENSURE(m_hAccelTable != NULL);

	m_nAccelSize = ::CopyAcceleratorTable(m_hAccelTable, NULL, 0);

	m_lpAccel = new ACCEL [m_nAccelSize];
	ENSURE(m_lpAccel != NULL);

	::CopyAcceleratorTable(m_hAccelTable, m_lpAccel, m_nAccelSize);
	m_pSelTemplate = pTemplate;

	OnSelchangeCommandsList();
}

void CMFCToolBarsKeyboardPropertyPage::AddKeyEntry(LPACCEL pEntry)
{
	ENSURE(pEntry != NULL);

	CMFCAcceleratorKey helper(pEntry);

	CString str;
	helper.Format(str);

	int iIndex = m_wndCurrentKeysList.AddString(str);
	m_wndCurrentKeysList.SetItemData(iIndex, (DWORD_PTR) pEntry);
}

void CMFCToolBarsKeyboardPropertyPage::OnUpdateNewShortcutKey()
{
	ACCEL* pAccel = (ACCEL*) m_wndNewKey.GetAccel();
	ENSURE(pAccel != NULL);

	m_strAssignedTo.Empty();
	m_wndAssignedToTitle.ShowWindow(SW_HIDE);
	m_wndAssignButton.EnableWindow(FALSE);

	if (m_wndNewKey.IsKeyDefined())
	{
		ENSURE(m_lpAccel != NULL);

		BOOL bIsAlreadyDefined = FALSE;
		for (int i = 0; !bIsAlreadyDefined && i < m_nAccelSize; i ++)
		{
			const BYTE fRelFlags = FCONTROL | FALT | FSHIFT | FVIRTKEY;

			if (pAccel->key == m_lpAccel [i].key && (pAccel->fVirt & fRelFlags) == (m_lpAccel [i].fVirt & fRelFlags))
			{
				CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
				ENSURE(pWndParent != NULL);

				LPCTSTR lpszName = pWndParent->GetCommandName(m_lpAccel [i].cmd);
				if (lpszName != NULL)
				{
					m_strAssignedTo = lpszName;
				}
				else
				{
					m_strAssignedTo = _T("????");
				}

				bIsAlreadyDefined = TRUE;
			}
		}

		if (!bIsAlreadyDefined)
		{
			ENSURE(m_strAssignedTo.LoadString(IDP_AFXBARRES_UNASSIGNED));
			m_wndAssignButton.EnableWindow();
		}

		m_wndAssignedToTitle.ShowWindow(SW_SHOW);
	}

	UpdateData(FALSE);
}

void CMFCToolBarsKeyboardPropertyPage::SetAllCategory(LPCTSTR lpszCategory)
{
	ENSURE(lpszCategory != NULL);
	m_strAllCategory = lpszCategory;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarstoolspropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxribbonres.h"
#include "afxtoolbarstoolspropertypage.h"
#include "afxusertoolsmanager.h"
#include "afxtoolbarscustomizedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nBtnNew = 0;
static const int nBtnDelete = 1;
static const int nBtnMoveUp = 2;
static const int nBtnMoveDn = 3;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsToolsPropertyPage property page

#pragma warning(disable : 4355)

CMFCToolBarsToolsPropertyPage::CMFCToolBarsToolsPropertyPage() : CPropertyPage(CMFCToolBarsToolsPropertyPage::IDD), m_wndToolsList(this)
{
	//{{AFX_DATA_INIT(CMFCToolBarsToolsPropertyPage)
	m_strCommand = _T("");
	m_strArguments = _T("");
	m_strInitialDirectory = _T("");
	//}}AFX_DATA_INIT

	m_pSelTool = NULL;
	m_pParentSheet = NULL;
}

#pragma warning(default : 4355)

CMFCToolBarsToolsPropertyPage::~CMFCToolBarsToolsPropertyPage()
{
}

void CMFCToolBarsToolsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCToolBarsToolsPropertyPage)
	DDX_Control(pDX, IDD_AFXBARRES_MENU_INITIAL_DIRECTORY, m_wndInitialDirBtn);
	DDX_Control(pDX, IDD_AFXBARRES_MENU_ARGUMENTS, m_wndArgumentsBtn);
	DDX_Control(pDX, IDD_AFXBARRES_ARGUMENTS, m_wndArgumentsEdit);
	DDX_Control(pDX, IDD_AFXBARRES_INITIAL_DIRECTORY, m_wndInitialDirEdit);
	DDX_Control(pDX, IDD_AFXBARRES_COMMAND, m_wndCommandEdit);
	DDX_Control(pDX, IDD_AFXBARRES_BROWSE_COMMAND, m_wndBrowseBtn);
	DDX_Control(pDX, IDD_AFXBARRES_COMMANDS_LIST, m_wndToolsList);
	DDX_Text(pDX, IDD_AFXBARRES_COMMAND, m_strCommand);
	DDX_Text(pDX, IDD_AFXBARRES_ARGUMENTS, m_strArguments);
	DDX_Text(pDX, IDD_AFXBARRES_INITIAL_DIRECTORY, m_strInitialDirectory);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCToolBarsToolsPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCToolBarsToolsPropertyPage)
	ON_BN_CLICKED(IDD_AFXBARRES_BROWSE_COMMAND, &CMFCToolBarsToolsPropertyPage::OnBrowseCommand)
	ON_BN_CLICKED(IDD_AFXBARRES_MENU_ARGUMENTS, &CMFCToolBarsToolsPropertyPage::OnArgumentsOptions)
	ON_BN_CLICKED(IDD_AFXBARRES_MENU_INITIAL_DIRECTORY, &CMFCToolBarsToolsPropertyPage::OnInitialDirectoryOptions)
	ON_EN_UPDATE(IDD_AFXBARRES_ARGUMENTS, &CMFCToolBarsToolsPropertyPage::OnUpdateTool)
	ON_EN_UPDATE(IDD_AFXBARRES_COMMAND, &CMFCToolBarsToolsPropertyPage::OnUpdateTool)
	ON_EN_UPDATE(IDD_AFXBARRES_INITIAL_DIRECTORY, &CMFCToolBarsToolsPropertyPage::OnUpdateTool)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsToolsPropertyPage message handlers

BOOL CMFCToolBarsToolsPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	ENSURE(afxUserToolsManager != NULL);

	m_pParentSheet = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(m_pParentSheet != NULL);

	//-------------
	// Add buttons:
	//-------------
	m_wndToolsList.SetStandardButtons();
	m_pParentSheet->OnInitToolsPage();

	//------------
	// Fill tools:
	//------------
	const CObList& lstTools = afxUserToolsManager->GetUserTools();
	for (POSITION pos = lstTools.GetHeadPosition(); pos != NULL;)
	{
		CUserTool* pTool = (CUserTool*) lstTools.GetNext(pos);
		ASSERT_VALID(pTool);

		m_wndToolsList.AddItem(pTool->m_strLabel, (DWORD_PTR) pTool);
	}

	UINT uMenuID = 0;
	uMenuID = afxUserToolsManager->GetInitialDirMenuID();
	if (uMenuID)
	{
		m_wndInitialDirBtn.ShowWindow(SW_SHOW);
		m_menuInitialDir.LoadMenu(uMenuID);
		m_wndInitialDirBtn.m_hMenu = m_menuInitialDir.GetSubMenu(0)->GetSafeHmenu();
	}

	uMenuID = afxUserToolsManager->GetArgumentsMenuID();
	if (uMenuID)
	{
		m_wndArgumentsBtn.ShowWindow(SW_SHOW);
		m_menuArguments.LoadMenu(uMenuID);
		m_wndArgumentsBtn.m_hMenu = m_menuArguments.GetSubMenu(0)->GetSafeHmenu();
	}

	m_wndInitialDirBtn.m_bRightArrow = TRUE;
	m_wndArgumentsBtn.m_bRightArrow  = TRUE;

	EnableControls();

	return TRUE;  // return TRUE unless you set the focus to a control
}

BOOL CVSToolsListBox::OnBeforeRemoveItem(int iItem)
{
	CUserTool* pTool = (CUserTool*) GetItemData(iItem);
	ASSERT_VALID(pTool);

	afxUserToolsManager->RemoveTool(pTool);
	m_pParent->m_pSelTool = NULL;

	return TRUE;
}

void CVSToolsListBox::OnAfterAddItem(int iItem)
{
	CUserTool* pTool = m_pParent->CreateNewTool();
	if (pTool == NULL)
	{
		RemoveItem(iItem);
		return;
	}

	ASSERT_VALID(pTool);

	pTool->m_strLabel = GetItemText(iItem);
	SetItemData(iItem, (DWORD_PTR) pTool);

	OnSelectionChanged();
}

void CVSToolsListBox::OnAfterRenameItem(int iItem)
{
	CUserTool* pTool = (CUserTool*) GetItemData(iItem);
	ASSERT_VALID(pTool);

	pTool->m_strLabel = GetItemText(iItem);
}

void CVSToolsListBox::OnAfterMoveItemUp(int iItem)
{
	CUserTool* pTool = (CUserTool*) GetItemData(iItem);
	ASSERT_VALID(pTool);

	afxUserToolsManager->MoveToolUp(pTool);
}

void CVSToolsListBox::OnAfterMoveItemDown(int iItem)
{
	CUserTool* pTool = (CUserTool*) GetItemData(iItem);
	ASSERT_VALID(pTool);

	afxUserToolsManager->MoveToolDown(pTool);
}

void CVSToolsListBox::OnSelectionChanged()
{
	int iSelItem = GetSelItem();
	CUserTool* pSelTool = (iSelItem < 0) ? NULL :(CUserTool*) GetItemData(iSelItem);

	if (pSelTool == NULL)
	{
		m_pParent->m_strCommand.Empty();
		m_pParent->m_strArguments.Empty();
		m_pParent->m_strInitialDirectory.Empty();
	}
	else
	{
		ASSERT_VALID(pSelTool);

		m_pParent->m_strCommand = pSelTool->GetCommand();
		m_pParent->m_strArguments = pSelTool->m_strArguments;
		m_pParent->m_strInitialDirectory = pSelTool->m_strInitialDirectory;
	}

	ASSERT_VALID(m_pParent->m_pParentSheet);
	m_pParent->m_pParentSheet->OnBeforeChangeTool(m_pParent->m_pSelTool);

	m_pParent->m_pSelTool = pSelTool;
	m_pParent->UpdateData(FALSE);

	m_pParent->EnableControls();

	m_pParent->m_pParentSheet->OnAfterChangeTool(m_pParent->m_pSelTool);
}

void CMFCToolBarsToolsPropertyPage::OnBrowseCommand()
{
	CFileDialog dlg(TRUE, afxUserToolsManager->GetDefExt(), NULL, 0, afxUserToolsManager->GetFilter(), this);
	if (dlg.DoModal() == IDOK)
	{
		m_strCommand = dlg.GetPathName();
		UpdateData(FALSE);
		OnUpdateTool();
	}
}

void CMFCToolBarsToolsPropertyPage::OnUpdateTool()
{
	UpdateData();

	int iSelItem = m_wndToolsList.GetSelItem();
	CUserTool* pSelTool = (iSelItem >= 0) ? (CUserTool*) m_wndToolsList.GetItemData(iSelItem) : NULL;

	if (pSelTool == NULL)
	{
		m_strCommand.Empty();
		m_strArguments.Empty();
		m_strInitialDirectory.Empty();

		UpdateData(FALSE);
	}
	else
	{
		ASSERT_VALID(pSelTool);

		pSelTool->SetCommand(m_strCommand);
		pSelTool->m_strArguments = m_strArguments;
		pSelTool->m_strInitialDirectory = m_strInitialDirectory;
	}

	EnableControls();
}

CUserTool* CMFCToolBarsToolsPropertyPage::CreateNewTool()
{
	ASSERT_VALID(m_pParentSheet);

	const int nMaxTools = afxUserToolsManager->GetMaxTools();

	if (afxUserToolsManager->GetUserTools().GetCount() == nMaxTools)
	{
		CString strError;
		strError.Format(IDS_AFXBARRES_TOO_MANY_TOOLS_FMT, nMaxTools);

		AfxMessageBox(strError);
		return NULL;
	}

	CUserTool* pTool = afxUserToolsManager->CreateNewTool();
	ASSERT_VALID(pTool);

	return pTool;
}

void CMFCToolBarsToolsPropertyPage::OnOK()
{
	OnUpdateTool();
	CPropertyPage::OnOK();
}

BOOL CMFCToolBarsToolsPropertyPage::OnKillActive()
{
	ASSERT_VALID(this);
	ASSERT_VALID(m_pParentSheet);

	if (!m_pParentSheet->CheckToolsValidity(afxUserToolsManager->GetUserTools()))
	{
		return FALSE;
	}

	return CPropertyPage::OnKillActive();
}

void CMFCToolBarsToolsPropertyPage::EnableControls()
{
	BOOL bEnableItemProps = (m_wndToolsList.GetSelItem() >= 0);

	m_wndCommandEdit.EnableWindow(bEnableItemProps);
	m_wndArgumentsEdit.EnableWindow(bEnableItemProps);
	m_wndInitialDirEdit.EnableWindow(bEnableItemProps);
	m_wndBrowseBtn.EnableWindow(bEnableItemProps);

	m_wndInitialDirBtn.EnableWindow(bEnableItemProps);
	m_wndArgumentsBtn.EnableWindow(bEnableItemProps);
}

void CMFCToolBarsToolsPropertyPage::OnArgumentsOptions()
{
	if (m_wndArgumentsBtn.m_nMenuResult != 0)
	{
		CString strItem;
		ENSURE(strItem.LoadString(m_wndArgumentsBtn.m_nMenuResult));

		//-----------------------------------------------
		// Insert text to the current arguments position:
		//-----------------------------------------------
		for (int i = 0; i < strItem.GetLength(); i++)
		{
			m_wndArgumentsEdit.SendMessage(WM_CHAR, (TCHAR) strItem [i]);
		}
	}
}

void CMFCToolBarsToolsPropertyPage::OnInitialDirectoryOptions()
{
	if (m_wndInitialDirBtn.m_nMenuResult != 0)
	{
		CString strItem;
		if (strItem.LoadString(m_wndInitialDirBtn.m_nMenuResult))
		{
			//-----------------------------------------------
			// Insert text to the current directory position:
			//-----------------------------------------------
			for (int i = 0; i < strItem.GetLength(); i++)
			{
				m_wndInitialDirEdit.SendMessage(WM_CHAR, (TCHAR) strItem [i]);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtoolbarsystemmenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxpriv.h>
#include "afxtoolbar.h"
#include "afxtoolbarsystemmenubutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMFCToolBarSystemMenuButton, CMFCToolBarMenuButton, VERSIONABLE_SCHEMA | 1)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCToolBarSystemMenuButton::CMFCToolBarSystemMenuButton()
{
	m_hSysMenuIcon = NULL;
	m_hSystemMenu = NULL;
}

CMFCToolBarSystemMenuButton::CMFCToolBarSystemMenuButton(HMENU hSystemMenu, HICON hSystemIcon) :
	CMFCToolBarMenuButton(0, hSystemMenu, -1)
{
	m_hSysMenuIcon = hSystemIcon;
	m_hSystemMenu = hSystemMenu;
}

CMFCToolBarSystemMenuButton::~CMFCToolBarSystemMenuButton()
{
}

void CMFCToolBarSystemMenuButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarMenuButton::CopyFrom(s);

	const CMFCToolBarSystemMenuButton& src = (const CMFCToolBarSystemMenuButton&) s;

	m_hSysMenuIcon = src.m_hSysMenuIcon;
	m_hSystemMenu = src.m_hSystemMenu;
}

SIZE CMFCToolBarSystemMenuButton::OnCalculateSize(CDC* /*pDC*/, const CSize& sizeDefault, BOOL /*bHorz*/)
{
	return CSize(::GetSystemMetrics(SM_CXMENUSIZE), sizeDefault.cy);
}

void CMFCToolBarSystemMenuButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/,
	BOOL /*bHorz*/, BOOL /*bCustomizeMode*/, BOOL /*bHighlight*/, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	if (m_hSysMenuIcon != NULL)
	{

		CSize size(min(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CXMENUSIZE)), min(::GetSystemMetrics(SM_CYSMICON), ::GetSystemMetrics(SM_CYMENUSIZE)));

		int iOffset = (rect.Height() - size.cy) / 2;
		::DrawIconEx(*pDC, rect.left, rect.top + iOffset, m_hSysMenuIcon, size.cx, size.cy, 0, NULL, DI_NORMAL);
	}
}

void CMFCToolBarSystemMenuButton::OnDblClk(CWnd* pWnd)
{
	if (CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	ENSURE(pWnd != NULL);

	//////////////////////////////////////////////
	// Make sure to close the popup menu and
	// find the MDI frame correctly.
	//--------------------------------------------
	OnCancelMode();

	CFrameWnd* pParentFrame = AFXGetParentFrame(pWnd);
	if (pParentFrame != NULL && pParentFrame->IsKindOf(RUNTIME_CLASS(CMiniDockFrameWnd)))
	{
		pParentFrame = (CFrameWnd*) pParentFrame->GetParent();
	}

	CMDIFrameWnd* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, pParentFrame);
	if (pMDIFrame != NULL)
	{
		CMDIChildWnd* pChild = pMDIFrame->MDIGetActive();
		ASSERT_VALID(pChild);

		BOOL bCloseIsDisabled = FALSE;

		CMenu* pSysMenu = pChild->GetSystemMenu(FALSE);
		if (pSysMenu != NULL)
		{
			MENUITEMINFO menuInfo;
			ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
			menuInfo.cbSize = sizeof(MENUITEMINFO);
			menuInfo.fMask = MIIM_STATE;

			pSysMenu->GetMenuItemInfo(SC_CLOSE, &menuInfo);
			bCloseIsDisabled = (menuInfo.fState & MFS_DISABLED);
		}

		if (!bCloseIsDisabled)
		{
			pChild->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
		}
	}
	//--------------------------------------------
	//////////////////////////////////////////////
}

void CMFCToolBarSystemMenuButton::CreateFromMenu(HMENU hMenu)
{
	m_hSystemMenu = hMenu;
}

HMENU CMFCToolBarSystemMenuButton::CreateMenu() const
{
	ENSURE(m_hSystemMenu != NULL);

	HMENU hMenu = CMFCToolBarMenuButton::CreateMenu();
	if (hMenu == NULL)
	{
		return NULL;
	}

	//---------------------------------------------------------------------
	// System menu don't produce updating command statuses via the
	// standard MFC idle command targeting. So, we should enable/disable
	// system menu items according to the standard system menu status:
	//---------------------------------------------------------------------
	CMenu* pMenu = CMenu::FromHandle(hMenu);
	ASSERT_VALID(pMenu);

	CMenu* pSysMenu = CMenu::FromHandle(m_hSystemMenu);
	ASSERT_VALID(pSysMenu);

	int iCount = pSysMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiState = pSysMenu->GetMenuState(i, MF_BYPOSITION);
		UINT uiCmd = pSysMenu->GetMenuItemID(i);

		if (uiState & MF_CHECKED)
		{
			pMenu->CheckMenuItem(uiCmd, MF_CHECKED);
		}

		if (uiState & MF_DISABLED)
		{
			pMenu->EnableMenuItem(uiCmd, MF_DISABLED);
		}

		if (uiState & MF_GRAYED)
		{
			pMenu->EnableMenuItem(uiCmd, MF_GRAYED);
		}
	}

	return hMenu;
}

void CMFCToolBarSystemMenuButton::OnCancelMode()
{
	if (m_pPopupMenu != NULL && ::IsWindow(m_pPopupMenu->m_hWnd))
	{
		if (m_pPopupMenu->InCommand())
		{
			return;
		}

		m_pPopupMenu->SaveState();
		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->CloseMenu();
	}

	m_pPopupMenu = NULL;
	m_bToBeClosed = FALSE;
}

void CMFCToolBarSystemMenuButton::OnAfterCreatePopupMenu()
{
	if (m_pPopupMenu != NULL && ::IsWindow(m_pPopupMenu->m_hWnd))
	{
		CFrameWnd* pParentFrame = AFXGetTopLevelFrame(m_pPopupMenu);
		if (pParentFrame != NULL && pParentFrame->IsKindOf(RUNTIME_CLASS(CMiniDockFrameWnd)))
		{
			pParentFrame = (CFrameWnd*) pParentFrame->GetParent();
		}

		CMDIFrameWnd* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, pParentFrame);

		if (pMDIFrame != NULL)
		{
			CMDIChildWnd* pChild = pMDIFrame->MDIGetActive();
			ASSERT_VALID(pChild);

			m_pPopupMenu->SetMessageWnd(pChild);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtrackmouse.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxtrackmouse.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

VOID CALLBACK AFXTrackMouseTimerProc(HWND hWnd, UINT /*uMsg*/, UINT idEvent, DWORD /*dwTime*/)
{
	RECT rect;
	POINT pt;

	::GetClientRect(hWnd, &rect);
	::MapWindowPoints(hWnd, NULL, (LPPOINT)&rect, 2);

	::GetCursorPos(&pt);
	if (!::PtInRect(&rect, pt) ||(WindowFromPoint(pt) != hWnd))
	{
		if (!::KillTimer(hWnd, idEvent))
		{
			// Error killing the timer!
		}

		::PostMessage(hWnd,WM_MOUSELEAVE, 0, 0);
	}
}

BOOL AFXTrackMouse(LPTRACKMOUSEEVENT ptme)
{
	if (ptme == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (ptme->cbSize < sizeof(TRACKMOUSEEVENT))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (!::IsWindow(ptme->hwndTrack))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (!(ptme->dwFlags & TME_LEAVE))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return(BOOL) ::SetTimer(ptme->hwndTrack, ptme->dwFlags, 100, (TIMERPROC)AFXTrackMouseTimerProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtrace.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _DEBUG       // entire file for debugging


#include "dde.h"


/////////////////////////////////////////////////////////////////////////////
// Build data tables by including data file three times

struct AFX_MAP_MESSAGE
{
	UINT    nMsg;
	LPCSTR  lpszMsg;
};

#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
	DEFINE_MESSAGE(WM_CREATE),
	DEFINE_MESSAGE(WM_DESTROY),
	DEFINE_MESSAGE(WM_MOVE),
	DEFINE_MESSAGE(WM_SIZE),
	DEFINE_MESSAGE(WM_ACTIVATE),
	DEFINE_MESSAGE(WM_SETFOCUS),
	DEFINE_MESSAGE(WM_KILLFOCUS),
	DEFINE_MESSAGE(WM_ENABLE),
	DEFINE_MESSAGE(WM_SETREDRAW),
	DEFINE_MESSAGE(WM_SETTEXT),
	DEFINE_MESSAGE(WM_GETTEXT),
	DEFINE_MESSAGE(WM_GETTEXTLENGTH),
	DEFINE_MESSAGE(WM_PAINT),
	DEFINE_MESSAGE(WM_CLOSE),
	DEFINE_MESSAGE(WM_QUERYENDSESSION),
	DEFINE_MESSAGE(WM_QUIT),
	DEFINE_MESSAGE(WM_QUERYOPEN),
	DEFINE_MESSAGE(WM_ERASEBKGND),
	DEFINE_MESSAGE(WM_SYSCOLORCHANGE),
	DEFINE_MESSAGE(WM_ENDSESSION),
	DEFINE_MESSAGE(WM_SHOWWINDOW),
	DEFINE_MESSAGE(WM_CTLCOLORMSGBOX),
	DEFINE_MESSAGE(WM_CTLCOLOREDIT),
	DEFINE_MESSAGE(WM_CTLCOLORLISTBOX),
	DEFINE_MESSAGE(WM_CTLCOLORBTN),
	DEFINE_MESSAGE(WM_CTLCOLORDLG),
	DEFINE_MESSAGE(WM_CTLCOLORSCROLLBAR),
	DEFINE_MESSAGE(WM_CTLCOLORSTATIC),
	DEFINE_MESSAGE(WM_WININICHANGE),
	DEFINE_MESSAGE(WM_SETTINGCHANGE),
	DEFINE_MESSAGE(WM_DEVMODECHANGE),
	DEFINE_MESSAGE(WM_ACTIVATEAPP),
	DEFINE_MESSAGE(WM_FONTCHANGE),
	DEFINE_MESSAGE(WM_TIMECHANGE),
	DEFINE_MESSAGE(WM_CANCELMODE),
	DEFINE_MESSAGE(WM_SETCURSOR),
	DEFINE_MESSAGE(WM_MOUSEACTIVATE),
	DEFINE_MESSAGE(WM_CHILDACTIVATE),
	DEFINE_MESSAGE(WM_QUEUESYNC),
	DEFINE_MESSAGE(WM_GETMINMAXINFO),
	DEFINE_MESSAGE(WM_ICONERASEBKGND),
	DEFINE_MESSAGE(WM_NEXTDLGCTL),
	DEFINE_MESSAGE(WM_SPOOLERSTATUS),
	DEFINE_MESSAGE(WM_DRAWITEM),
	DEFINE_MESSAGE(WM_MEASUREITEM),
	DEFINE_MESSAGE(WM_DELETEITEM),
	DEFINE_MESSAGE(WM_VKEYTOITEM),
	DEFINE_MESSAGE(WM_CHARTOITEM),
	DEFINE_MESSAGE(WM_SETFONT),
	DEFINE_MESSAGE(WM_GETFONT),
	DEFINE_MESSAGE(WM_QUERYDRAGICON),
	DEFINE_MESSAGE(WM_COMPAREITEM),
	DEFINE_MESSAGE(WM_COMPACTING),
	DEFINE_MESSAGE(WM_NCCREATE),
	DEFINE_MESSAGE(WM_NCDESTROY),
	DEFINE_MESSAGE(WM_NCCALCSIZE),
	DEFINE_MESSAGE(WM_NCHITTEST),
	DEFINE_MESSAGE(WM_NCPAINT),
	DEFINE_MESSAGE(WM_NCACTIVATE),
	DEFINE_MESSAGE(WM_GETDLGCODE),
	DEFINE_MESSAGE(WM_NCMOUSEMOVE),
	DEFINE_MESSAGE(WM_NCLBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCLBUTTONUP),
	DEFINE_MESSAGE(WM_NCLBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_NCRBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCRBUTTONUP),
	DEFINE_MESSAGE(WM_NCRBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_NCMBUTTONDOWN),
	DEFINE_MESSAGE(WM_NCMBUTTONUP),
	DEFINE_MESSAGE(WM_NCMBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_KEYDOWN),
	DEFINE_MESSAGE(WM_KEYUP),
	DEFINE_MESSAGE(WM_CHAR),
	DEFINE_MESSAGE(WM_DEADCHAR),
	DEFINE_MESSAGE(WM_SYSKEYDOWN),
	DEFINE_MESSAGE(WM_SYSKEYUP),
	DEFINE_MESSAGE(WM_SYSCHAR),
	DEFINE_MESSAGE(WM_SYSDEADCHAR),
	DEFINE_MESSAGE(WM_KEYLAST),
	DEFINE_MESSAGE(WM_INITDIALOG),
	DEFINE_MESSAGE(WM_COMMAND),
	DEFINE_MESSAGE(WM_SYSCOMMAND),
	DEFINE_MESSAGE(WM_TIMER),
	DEFINE_MESSAGE(WM_HSCROLL),
	DEFINE_MESSAGE(WM_VSCROLL),
	DEFINE_MESSAGE(WM_INITMENU),
	DEFINE_MESSAGE(WM_INITMENUPOPUP),
	DEFINE_MESSAGE(WM_MENUSELECT),
	DEFINE_MESSAGE(WM_MENUCHAR),
	DEFINE_MESSAGE(WM_ENTERIDLE),
	DEFINE_MESSAGE(WM_MOUSEWHEEL),
	DEFINE_MESSAGE(WM_MOUSEMOVE),
	DEFINE_MESSAGE(WM_LBUTTONDOWN),
	DEFINE_MESSAGE(WM_LBUTTONUP),
	DEFINE_MESSAGE(WM_LBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_RBUTTONDOWN),
	DEFINE_MESSAGE(WM_RBUTTONUP),
	DEFINE_MESSAGE(WM_RBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_MBUTTONDOWN),
	DEFINE_MESSAGE(WM_MBUTTONUP),
	DEFINE_MESSAGE(WM_MBUTTONDBLCLK),
	DEFINE_MESSAGE(WM_PARENTNOTIFY),
	DEFINE_MESSAGE(WM_MDICREATE),
	DEFINE_MESSAGE(WM_MDIDESTROY),
	DEFINE_MESSAGE(WM_MDIACTIVATE),
	DEFINE_MESSAGE(WM_MDIRESTORE),
	DEFINE_MESSAGE(WM_MDINEXT),
	DEFINE_MESSAGE(WM_MDIMAXIMIZE),
	DEFINE_MESSAGE(WM_MDITILE),
	DEFINE_MESSAGE(WM_MDICASCADE),
	DEFINE_MESSAGE(WM_MDIICONARRANGE),
	DEFINE_MESSAGE(WM_MDIGETACTIVE),
	DEFINE_MESSAGE(WM_MDISETMENU),
	DEFINE_MESSAGE(WM_CUT),
	DEFINE_MESSAGE(WM_COPYDATA),
	DEFINE_MESSAGE(WM_COPY),
	DEFINE_MESSAGE(WM_PASTE),
	DEFINE_MESSAGE(WM_CLEAR),
	DEFINE_MESSAGE(WM_UNDO),
	DEFINE_MESSAGE(WM_RENDERFORMAT),
	DEFINE_MESSAGE(WM_RENDERALLFORMATS),
	DEFINE_MESSAGE(WM_DESTROYCLIPBOARD),
	DEFINE_MESSAGE(WM_DRAWCLIPBOARD),
	DEFINE_MESSAGE(WM_PAINTCLIPBOARD),
	DEFINE_MESSAGE(WM_VSCROLLCLIPBOARD),
	DEFINE_MESSAGE(WM_SIZECLIPBOARD),
	DEFINE_MESSAGE(WM_ASKCBFORMATNAME),
	DEFINE_MESSAGE(WM_CHANGECBCHAIN),
	DEFINE_MESSAGE(WM_HSCROLLCLIPBOARD),
	DEFINE_MESSAGE(WM_QUERYNEWPALETTE),
	DEFINE_MESSAGE(WM_PALETTEISCHANGING),
	DEFINE_MESSAGE(WM_PALETTECHANGED),
	DEFINE_MESSAGE(WM_DDE_INITIATE),
	DEFINE_MESSAGE(WM_DDE_TERMINATE),
	DEFINE_MESSAGE(WM_DDE_ADVISE),
	DEFINE_MESSAGE(WM_DDE_UNADVISE),
	DEFINE_MESSAGE(WM_DDE_ACK),
	DEFINE_MESSAGE(WM_DDE_DATA),
	DEFINE_MESSAGE(WM_DDE_REQUEST),
	DEFINE_MESSAGE(WM_DDE_POKE),
	DEFINE_MESSAGE(WM_DDE_EXECUTE),
	DEFINE_MESSAGE(WM_DROPFILES),
	DEFINE_MESSAGE(WM_POWER),
	DEFINE_MESSAGE(WM_WINDOWPOSCHANGED),
	DEFINE_MESSAGE(WM_WINDOWPOSCHANGING),
// MFC specific messages
	DEFINE_MESSAGE(WM_SIZEPARENT),
	DEFINE_MESSAGE(WM_SETMESSAGESTRING),
	DEFINE_MESSAGE(WM_IDLEUPDATECMDUI),
	DEFINE_MESSAGE(WM_INITIALUPDATE),
	DEFINE_MESSAGE(WM_COMMANDHELP),
	DEFINE_MESSAGE(WM_HELPHITTEST),
	DEFINE_MESSAGE(WM_EXITHELPMODE),
	DEFINE_MESSAGE(WM_HELP),
	DEFINE_MESSAGE(WM_NOTIFY),
	DEFINE_MESSAGE(WM_CONTEXTMENU),
	DEFINE_MESSAGE(WM_TCARD),
	DEFINE_MESSAGE(WM_MDIREFRESHMENU),
	DEFINE_MESSAGE(WM_MOVING),
	DEFINE_MESSAGE(WM_STYLECHANGED),
	DEFINE_MESSAGE(WM_STYLECHANGING),
	DEFINE_MESSAGE(WM_SIZING),
	DEFINE_MESSAGE(WM_SETHOTKEY),
	DEFINE_MESSAGE(WM_PRINT),
	DEFINE_MESSAGE(WM_PRINTCLIENT),
	DEFINE_MESSAGE(WM_POWERBROADCAST),
	DEFINE_MESSAGE(WM_HOTKEY),
	DEFINE_MESSAGE(WM_GETICON),
	DEFINE_MESSAGE(WM_EXITMENULOOP),
	DEFINE_MESSAGE(WM_ENTERMENULOOP),
	DEFINE_MESSAGE(WM_DISPLAYCHANGE),
	DEFINE_MESSAGE(WM_STYLECHANGED),
	DEFINE_MESSAGE(WM_STYLECHANGING),
	DEFINE_MESSAGE(WM_GETICON),
	DEFINE_MESSAGE(WM_SETICON),
	DEFINE_MESSAGE(WM_SIZING),
	DEFINE_MESSAGE(WM_MOVING),
	DEFINE_MESSAGE(WM_CAPTURECHANGED),
	DEFINE_MESSAGE(WM_DEVICECHANGE),
	{ 0, NULL, }    // end of message list
};

#undef DEFINE_MESSAGE

/////////////////////////////////////////////////////////////////////////////
// DDE special case

static void AFXAPI TraceDDE(LPCTSTR lpszPrefix, const MSG* pMsg)
{
	ENSURE_ARG(pMsg != NULL);
	if (pMsg->message == WM_DDE_EXECUTE)
	{
		UINT_PTR nDummy;
		HGLOBAL hCommands;
		if (!UnpackDDElParam(WM_DDE_EXECUTE, pMsg->lParam,
			&nDummy, (UINT_PTR*)&hCommands))
		{
			TRACE(traceAppMsg, 0, "Warning: Unable to unpack WM_DDE_EXECUTE lParam %08lX.\n",
				pMsg->lParam);
			return;
		}
		ASSERT(hCommands != NULL);

		LPCTSTR lpszCommands = (LPCTSTR)::GlobalLock(hCommands);
		ENSURE_THROW(lpszCommands != NULL, ::AfxThrowMemoryException() );
		TRACE(traceAppMsg, 0, _T("%s: Execute '%s'.\n"), lpszPrefix, lpszCommands);
		::GlobalUnlock(hCommands);
	}
	else if (pMsg->message == WM_DDE_ADVISE)
	{
		UINT_PTR nItem;
		ATOM aItem;
		HGLOBAL hAdvise;
		if (!UnpackDDElParam(WM_DDE_ADVISE, pMsg->lParam,
			(UINT_PTR*)&hAdvise, &nItem))
		{
			TRACE(traceAppMsg, 0, "Warning: Unable to unpack WM_DDE_ADVISE lParam %08lX.\n",
				pMsg->lParam);
			return;
		}
		aItem = (ATOM)nItem;
		ASSERT(aItem != NULL);
		ASSERT(hAdvise != NULL);

		DDEADVISE* lpAdvise = (DDEADVISE*)::GlobalLock(hAdvise);
		ENSURE_THROW(lpAdvise != NULL, ::AfxThrowMemoryException() );
		TCHAR szItem[80];
		szItem[0] = '\0';

		if (aItem != 0)
			::GlobalGetAtomName(aItem, szItem, _countof(szItem));

		TCHAR szFormat[80];
		szFormat[0] = '\0';
		if (((UINT)0xC000 <= (UINT)lpAdvise->cfFormat) &&
				((UINT)lpAdvise->cfFormat <= (UINT)0xFFFF))
		{
			::GetClipboardFormatName(lpAdvise->cfFormat,
				szFormat, _countof(szFormat));

			// User defined clipboard formats have a range of 0xC000->0xFFFF
			// System clipboard formats have other ranges, but no printable
			// format names.
		}

		AfxTrace(
			_T("%s: Advise item='%s', Format='%s', Ack=%d, Defer Update= %d\n"),
			 lpszPrefix, szItem, szFormat, lpAdvise->fAckReq,
			lpAdvise->fDeferUpd);
		::GlobalUnlock(hAdvise);
	}
}

/////////////////////////////////////////////////////////////////////////////

void AFXAPI _AfxTraceMsg(LPCTSTR lpszPrefix, const MSG* pMsg)
{
	ENSURE_ARG(AfxIsValidString(lpszPrefix));
	ENSURE_ARG(pMsg != NULL);

	if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE ||
		pMsg->message == WM_NCHITTEST || pMsg->message == WM_SETCURSOR ||
		pMsg->message == WM_CTLCOLORBTN ||
		pMsg->message == WM_CTLCOLORDLG ||
		pMsg->message == WM_CTLCOLOREDIT ||
		pMsg->message == WM_CTLCOLORLISTBOX ||
		pMsg->message == WM_CTLCOLORMSGBOX ||
		pMsg->message == WM_CTLCOLORSCROLLBAR ||
		pMsg->message == WM_CTLCOLORSTATIC ||
		pMsg->message == WM_ENTERIDLE || pMsg->message == WM_CANCELMODE ||
		pMsg->message == 0x0118)    // WM_SYSTIMER (caret blink)
	{
		// don't report very frequently sent messages
		return;
	}

	LPCSTR lpszMsgName = NULL;
	char szBuf[80];

	// find message name
	if (pMsg->message >= 0xC000)
	{
		// Window message registered with 'RegisterWindowMessage'
		//  (actually a USER atom)
		if (::GetClipboardFormatNameA(pMsg->message, szBuf, _countof(szBuf)))
			lpszMsgName = szBuf;
	}
	else if (pMsg->message >= WM_USER)
	{
		// User message
		sprintf_s(szBuf, _countof(szBuf), "WM_USER+0x%04X", pMsg->message - WM_USER);
		lpszMsgName = szBuf;
	}
	else
	{
		// a system windows message
		const AFX_MAP_MESSAGE* pMapMsg = allMessages;
		for (/*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++)
		{
			if (pMapMsg->nMsg == pMsg->message)
			{
				lpszMsgName = pMapMsg->lpszMsg;
				break;
			}
		}
	}

	if (lpszMsgName != NULL)
	{
#ifdef WIN64
		TRACE(traceWinMsg, 4, _T("%s: hwnd=%p, msg = %hs (%p, %p)\n"),
			lpszPrefix, pMsg->hwnd, lpszMsgName,
			pMsg->wParam, pMsg->lParam);
#else
		TRACE(traceWinMsg, 4, _T("%s: hwnd=0x%08X, msg = %hs (0x%08X, 0x%08X)\n"),
			lpszPrefix, pMsg->hwnd, lpszMsgName,
			pMsg->wParam, pMsg->lParam);
#endif
	}
	else
	{
#ifdef WIN64
		TRACE(traceWinMsg, 4, _T("%s: hwnd=%p, msg = 0x%04X (%p, %p)\n"),
			lpszPrefix, pMsg->hwnd, pMsg->message,
			pMsg->wParam, pMsg->lParam);
#else
		TRACE(traceWinMsg, 4, _T("%s: hwnd=0x%08X, msg = 0x%04X (0x%08X, 0x%08X)\n"),
			lpszPrefix, pMsg->hwnd, pMsg->message,
			pMsg->wParam, pMsg->lParam);
#endif
	}

	if (pMsg->message >= WM_DDE_FIRST && pMsg->message <= WM_DDE_LAST)
		TraceDDE(lpszPrefix, pMsg);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DEBUG (entire file)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxusertool.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxusertool.h"

#include "afxribbonres.h"

IMPLEMENT_SERIAL(CUserTool, CObject, VERSIONABLE_SCHEMA | 1)

// Construction/Destruction
CUserTool::CUserTool()
{
	m_uiCmdId = 0;
	m_hIcon = NULL;
}

CUserTool::~CUserTool()
{
	DeleteIcon();
}

void CUserTool::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_strLabel;

		CString strCmd;
		ar >> strCmd;
		SetCommand(strCmd);

		ar >> m_strArguments;
		ar >> m_strInitialDirectory;
		ar >> m_uiCmdId;
	}
	else
	{
		ar << m_strLabel;
		ar << m_strCommand;
		ar << m_strArguments;
		ar << m_strInitialDirectory;
		ar << m_uiCmdId;
	}
}

BOOL CUserTool::Invoke()
{
	if (m_strCommand.IsEmpty())
	{
		TRACE(_T("Empty command in user-defined tool: %d\n"), m_uiCmdId);
		return FALSE;
	}

	if (::ShellExecute(AfxGetMainWnd()->GetSafeHwnd(), NULL, m_strCommand, m_strArguments, m_strInitialDirectory, SW_SHOWNORMAL) <(HINSTANCE) 32)
	{
		TRACE(_T("Can't invoke command: %s\n"), m_strCommand);
		return FALSE;
	}

	return TRUE;
}

void CUserTool::DrawToolIcon(CDC* pDC, const CRect& rectImage)
{
	ASSERT_VALID(pDC);

	int cx = afxGlobalData.m_sizeSmallIcon.cx;
	int cy = afxGlobalData.m_sizeSmallIcon.cy;

	int x = max(0, (rectImage.Width() - cx) / 2);
	int y = max(0, (rectImage.Height() - cy) / 2);

	::DrawIconEx(pDC->GetSafeHdc(), rectImage.left + x, rectImage.top + y, m_hIcon, 0, 0, 0, NULL, DI_NORMAL);
}

BOOL CUserTool::CopyIconToClipboard()
{
	try
	{
		CWindowDC dc(NULL);

		int cx = afxGlobalData.m_sizeSmallIcon.cx;
		int cy = afxGlobalData.m_sizeSmallIcon.cy;

		//----------------------
		// Create a bitmap copy:
		//----------------------
		CDC memDCDest;
		memDCDest.CreateCompatibleDC(NULL);

		CBitmap bitmapCopy;
		if (!bitmapCopy.CreateCompatibleBitmap(&dc, cx, cy))
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return FALSE;
		}

		CBitmap* pOldBitmapDest = memDCDest.SelectObject(&bitmapCopy);

		CRect rectIcon(0, 0, cx, cy);
		memDCDest.FillRect(rectIcon, &afxGlobalData.brBtnFace);

		DrawToolIcon(&memDCDest, rectIcon);

		memDCDest.SelectObject(pOldBitmapDest);

		if (!AfxGetMainWnd()->OpenClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return FALSE;
		}

		if (!::EmptyClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			::CloseClipboard();
			return FALSE;
		}

		HANDLE hclipData = ::SetClipboardData(CF_BITMAP, bitmapCopy.Detach());
		if (hclipData == NULL)
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			TRACE(_T("CUserTool::CopyIconToClipboard error. Error code = %x\n"), GetLastError());
		}

		::CloseClipboard();
		return TRUE;
	}
	catch(...)
	{
		AfxMessageBox(IDP_AFXBARRES_INTERLAL_ERROR);
	}

	return FALSE;
}

void CUserTool::SetCommand(LPCTSTR lpszCmd)
{
	if (lpszCmd == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (m_strCommand != lpszCmd)
	{
		m_strCommand = lpszCmd;

		DeleteIcon();
		m_hIcon = SetToolIcon();
	}
}

HICON CUserTool::SetToolIcon()
{
	CString strPath = m_strCommand;

	//--------------------------------------------
	// If the image path is not defined, found it:
	//--------------------------------------------
	if (strPath.Find(_T("\\")) == -1 && strPath.Find(_T("/")) == -1 && strPath.Find(_T(":")) == -1)
	{
		TCHAR lpszPath [MAX_PATH];
		CString strFileName = m_strCommand;

		if (::SearchPath(NULL, strFileName, NULL, MAX_PATH,
			lpszPath, NULL) == 0)
		{
			return LoadDefaultIcon();
		}

		strPath = lpszPath;
	}

	//----------------------------------------
	// Try to obtain a default icon from file:
	//----------------------------------------
	SHFILEINFO sfi;
	if (::SHGetFileInfo(strPath, 0, &sfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SHELLICONSIZE | SHGFI_SMALLICON))
	{
		return sfi.hIcon;
	}

	return LoadDefaultIcon();
}

HICON CUserTool::LoadDefaultIcon()
{
	if (afxGlobalData.m_hiconTool == NULL)
	{
		afxGlobalData.m_hiconTool = (HICON) ::LoadImageW(
			AfxFindResourceHandle(MAKEINTRESOURCE(IDI_AFXRES_TOOL), RT_GROUP_ICON),
			MAKEINTRESOURCEW(IDI_AFXRES_TOOL), IMAGE_ICON, afxGlobalData.m_sizeSmallIcon.cx, afxGlobalData.m_sizeSmallIcon.cy, LR_SHARED);
	}

	return afxGlobalData.m_hiconTool;
}

void CUserTool::DeleteIcon()
{
	if (m_hIcon != NULL && m_hIcon != afxGlobalData.m_hiconTool)
	{
		::DestroyIcon(m_hIcon);
	}

	m_hIcon = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanager.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.


#include "stdafx.h"
#include "afxglobalutils.h"
#include "afxvisualmanager.h"
#include "afxtoolbarbutton.h"
#include "afxoutlookbarpane.h"
#include "afxoutlookbarpanebutton.h"
#include "afxglobals.h"
#include "afxdockablepane.h"
#include "afxbasepane.h"
#include "afxtoolbar.h"
#include "afxtabctrl.h"
#include "afxdrawmanager.h"
#include "afxshowallbutton.h"
#include "afxbutton.h"
#include "afxpaneframewnd.h"
#include "afxcaptionbar.h"
#include "afxoutlookbarpanebutton.h"
#include "afxtaskspane.h"
#include "afxpanedivider.h"
#include "afxmenuimages.h"
#include "afxheaderctrl.h"
#include "afxspinbuttonctrl.h"
#include "afxdockingmanager.h"
#include "afxtabbedpane.h"
#include "afxautohidebutton.h"
#include "afxdesktopalertwnd.h"
#include "afxpropertygridctrl.h"
#include "afxstatusbar.h"
#include "afxribbonbar.h"
#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonlinkctrl.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxribbonedit.h"
#include "afxribbonlabel.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonprogressbar.h"
#include "afxtooltipctrl.h"
#include "afxtooltipmanager.h"
#include "afxribboncolorbutton.h"
#include "afxdocksite.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCVisualManager, CObject)

extern CObList afxAllToolBars;
extern CTooltipManager* afxTooltipManager;

CMFCVisualManager* CMFCVisualManager::m_pVisManager = NULL;
CRuntimeClass* CMFCVisualManager::m_pRTIDefault = NULL;

UINT AFX_WM_CHANGEVISUALMANAGER = ::RegisterWindowMessage(_T("AFX_WM_CHANGEVISUALMANAGER"));

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCVisualManager::CMFCVisualManager(BOOL bIsTemporary)
{
	m_bAutoDestroy = FALSE;
	m_bIsTemporary = bIsTemporary;

	if (!bIsTemporary)
	{
		if (m_pVisManager != NULL)
		{
			ASSERT(FALSE);
		}
		else
		{
			m_pVisManager = this;
		}
	}

	m_bMenuFlatLook = FALSE;
	m_nMenuShadowDepth = 6;
	m_bShadowHighlightedImage = FALSE;
	m_bEmbossDisabledImage = TRUE;
	m_bFadeInactiveImage = FALSE;
	m_bEnableToolbarButtonFill = TRUE;

	m_nVertMargin = 12;
	m_nHorzMargin = 12;
	m_nGroupVertOffset = 15;
	m_nGroupCaptionHeight = 25;
	m_nGroupCaptionHorzOffset = 13;
	m_nGroupCaptionVertOffset = 7;
	m_nTasksHorzOffset = 12;
	m_nTasksIconHorzOffset = 5;
	m_nTasksIconVertOffset = 4;
	m_bActiveCaptions = TRUE;

	m_bOfficeXPStyleMenus = FALSE;
	m_nMenuBorderSize = 2;

	m_b3DTabWideBorder = TRUE;
	m_bAlwaysFillTab = FALSE;
	m_bFrameMenuCheckedItems = FALSE;
	m_clrMenuShadowBase = (COLORREF)-1; // Used in derived classes

	m_ptRibbonMainImageOffset = CPoint(0, 0);

	if (!bIsTemporary)
	{
		CDockingManager::m_bSDParamsModified = TRUE;
		CDockingManager::EnableDockSiteMenu(FALSE);

		CMFCAutoHideButton::m_bOverlappingTabs = TRUE;

		afxGlobalData.UpdateSysColors();
	}

	OnUpdateSystemColors();
}

CMFCVisualManager::~CMFCVisualManager()
{
	if (!m_bIsTemporary)
	{
		m_pVisManager = NULL;
	}
}

void CMFCVisualManager::OnUpdateSystemColors()
{
}

void __stdcall CMFCVisualManager::SetDefaultManager(CRuntimeClass* pRTI)
{
	if (pRTI != NULL && !pRTI->IsDerivedFrom(RUNTIME_CLASS(CMFCVisualManager)))
	{
		ASSERT(FALSE);
		return;
	}

	m_pRTIDefault = pRTI;

	if (m_pVisManager != NULL)
	{
		ASSERT_VALID(m_pVisManager);

		delete m_pVisManager;
		m_pVisManager = NULL;
	}

	afxGlobalData.UpdateSysColors();

	CDockingManager::SetDockingMode(DT_STANDARD);
	CTabbedPane::ResetTabs();

	AdjustFrames();
	AdjustToolbars();

	RedrawAll();

	if (afxTooltipManager != NULL)
	{
		afxTooltipManager->UpdateTooltips();
	}
}

void __stdcall CMFCVisualManager::RedrawAll()
{
	CWnd* pMainWnd = AfxGetMainWnd();
	BOOL bIsMainWndRedrawn = FALSE;

	const CList<CFrameWnd*, CFrameWnd*>& lstFrames = CFrameImpl::GetFrameList();

	for (POSITION pos = lstFrames.GetHeadPosition(); pos != NULL;)
	{
		CFrameWnd* pFrame = lstFrames.GetNext(pos);

		if (CWnd::FromHandlePermanent(pFrame->m_hWnd) != NULL)
		{
			ASSERT_VALID(pFrame);

			pFrame->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN | RDW_FRAME);

			if (pFrame->GetSafeHwnd() == pMainWnd->GetSafeHwnd())
			{
				bIsMainWndRedrawn = FALSE;
			}
		}
	}

	if (!bIsMainWndRedrawn && pMainWnd->GetSafeHwnd() != NULL && CWnd::FromHandlePermanent(pMainWnd->m_hWnd) != NULL)
	{
		pMainWnd->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN | RDW_FRAME);
	}

	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CPane* pToolBar = DYNAMIC_DOWNCAST(CPane, afxAllToolBars.GetNext(posTlb));
		if (pToolBar != NULL)
		{
			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				pToolBar->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
			}
		}
	}

	CPaneFrameWnd::RedrawAll();
}

void __stdcall CMFCVisualManager::AdjustToolbars()
{
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, afxAllToolBars.GetNext(posTlb));
		if (pToolBar != NULL)
		{
			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);
				pToolBar->OnChangeVisualManager();
			}
		}
	}
}

void __stdcall CMFCVisualManager::AdjustFrames()
{
	const CList<CFrameWnd*, CFrameWnd*>& lstFrames = CFrameImpl::GetFrameList();

	for (POSITION pos = lstFrames.GetHeadPosition(); pos != NULL;)
	{
		CFrameWnd* pFrame = lstFrames.GetNext(pos);

		if (CWnd::FromHandlePermanent(pFrame->m_hWnd) != NULL)
		{
			ASSERT_VALID(pFrame);
			pFrame->SendMessage(AFX_WM_CHANGEVISUALMANAGER);
		}
	}
}

void CMFCVisualManager::OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar)
{
	ASSERT_VALID(pDC);

	const COLORREF clrHilite = pBar != NULL && pBar->IsDialogControl() ? afxGlobalData.clrBtnHilite : afxGlobalData.clrBarHilite;
	const COLORREF clrShadow = pBar != NULL && pBar->IsDialogControl() ? afxGlobalData.clrBtnShadow : afxGlobalData.clrBarShadow;

	const int iGripperSize = 3;

	if (bHorz)
	{
		//-----------------
		// Gripper at left:
		//-----------------
		rectGripper.DeflateRect(0, iGripperSize);

		//---------------------
		// Center the grippers:
		//---------------------
		rectGripper.left = rectGripper.CenterPoint().x - iGripperSize / 2;
		rectGripper.right = rectGripper.left + iGripperSize;
	}
	else
	{
		//----------------
		// Gripper at top:
		//----------------
		rectGripper.DeflateRect(iGripperSize, 0);

		//---------------------
		// Center the grippers:
		//---------------------
		rectGripper.top = rectGripper.CenterPoint().y - iGripperSize / 2;
		rectGripper.bottom = rectGripper.top + iGripperSize;
	}

	pDC->Draw3dRect(rectGripper, clrHilite, clrShadow);
}

void CMFCVisualManager::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL /*bNCArea*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (DYNAMIC_DOWNCAST(CReBar, pBar) != NULL || DYNAMIC_DOWNCAST(CReBar, pBar->GetParent()))
	{
		FillReBarPane(pDC, pBar, rectClient);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPane)))
	{
		((CMFCOutlookBarPane*) pBar)->OnEraseWorkArea(pDC, rectClient);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCCaptionBar)))
	{
		CMFCCaptionBar* pCaptionBar = (CMFCCaptionBar*) pBar;

		if (pCaptionBar->IsMessageBarMode())
		{
			pDC->FillRect(rectClip, &afxGlobalData.brBarFace);
		}
		else
		{
			pDC->FillSolidRect(rectClip, pCaptionBar->m_clrBarBackground == -1 ? afxGlobalData.clrBarShadow : pCaptionBar->m_clrBarBackground);
		}
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		CMFCPopupMenuBar* pMenuBar = (CMFCPopupMenuBar*) pBar;

		if (pMenuBar->IsDropDownListMode())
		{
			pDC->FillRect(rectClip, &afxGlobalData.brWindow);
			return;
		}
	}

	// By default, control bar background is filled by
	// the system 3d background color

	pDC->FillRect(rectClip.IsRectEmpty() ? rectClient : rectClip, pBar->IsDialogControl() ? &afxGlobalData.brBtnFace : &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect)
{
	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	if (pBar->IsFloating())
	{
		return;
	}

	DWORD dwStyle = pBar->GetPaneStyle();
	if (!(dwStyle & CBRS_BORDER_ANY))
		return;

	COLORREF clrBckOld = pDC->GetBkColor(); // FillSolidRect changes it

	const COLORREF clrHilite = pBar->IsDialogControl() ? afxGlobalData.clrBtnHilite : afxGlobalData.clrBarHilite;
	const COLORREF clrShadow = pBar->IsDialogControl() ? afxGlobalData.clrBtnShadow : afxGlobalData.clrBarShadow;

	COLORREF clr = clrHilite;

	if (dwStyle & CBRS_BORDER_LEFT)
		pDC->FillSolidRect(0, 0, 1, rect.Height() - 1, clr);
	if (dwStyle & CBRS_BORDER_TOP)
		pDC->FillSolidRect(0, 0, rect.Width()-1 , 1, clr);
	if (dwStyle & CBRS_BORDER_RIGHT)
		pDC->FillSolidRect(rect.right, 0/*RGL~:1*/, -1,
		rect.Height()/*RGL-: - 1*/, clrShadow);
	if (dwStyle & CBRS_BORDER_BOTTOM)
		pDC->FillSolidRect(0, rect.bottom, rect.Width()-1, -1, clrShadow);

	// if undockable toolbar at top of frame, apply special formatting to mesh
	// properly with frame menu
	if (!pBar->CanFloat())
	{
		pDC->FillSolidRect(0,0,rect.Width(),1,clrShadow);
		pDC->FillSolidRect(0,1,rect.Width(),1,clrHilite);
	}

	if (dwStyle & CBRS_BORDER_LEFT)
		++rect.left;
	if (dwStyle & CBRS_BORDER_TOP)
		++rect.top;
	if (dwStyle & CBRS_BORDER_RIGHT)
		--rect.right;
	if (dwStyle & CBRS_BORDER_BOTTOM)
		--rect.bottom;

	// Restore Bk color:
	pDC->SetBkColor(clrBckOld);
}

void CMFCVisualManager::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* /*pMenu*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarLight, afxGlobalData.clrBarDkShadow);
	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

void CMFCVisualManager::OnDrawMenuShadow(CDC* pPaintDC, const CRect& rectClient, const CRect& /*rectExclude*/,
	int nDepth,  int iMinBrightness, int iMaxBrightness, CBitmap* pBmpSaveBottom,  CBitmap* pBmpSaveRight, BOOL bRTL)
{
	ASSERT_VALID(pPaintDC);
	ASSERT_VALID(pBmpSaveBottom);
	ASSERT_VALID(pBmpSaveRight);

	//------------------------------------------------------
	// Simple draw the shadow, ignore rectExclude parameter:
	//------------------------------------------------------
	CDrawingManager dm(*pPaintDC);
	dm.DrawShadow(rectClient, nDepth, iMinBrightness, iMaxBrightness, pBmpSaveBottom, pBmpSaveRight, (COLORREF)-1, !bRTL);
}

void CMFCVisualManager::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCShowAllButton)))
	{
		if (state == ButtonsIsHighlighted)
		{
			CDrawingManager dm(*pDC);
			dm.HighlightRect(rect);
		}

		return;
	}

	if (!m_bEnableToolbarButtonFill)
	{
		BOOL bIsPopupMenu = FALSE;

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
		if (pMenuButton != NULL)
		{
			bIsPopupMenu = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));
		}

		if (!bIsPopupMenu)
		{
			return;
		}
	}

	if (!pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton)) && !CMFCToolBar::IsCustomizeMode() &&
		state != ButtonsIsHighlighted && (pButton->m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
	{
		CRect rectDither = rect;
		rectDither.InflateRect(-afxData.cxBorder2, -afxData.cyBorder2);

		CMFCToolBarImages::FillDitheredRect(pDC, rectDither);
	}
}

COLORREF CMFCVisualManager::GetToolbarHighlightColor()
{
	return afxGlobalData.clrBarFace;
}

COLORREF CMFCVisualManager::GetToolbarDisabledTextColor()
{
	return afxGlobalData.clrGrayedText;
}

void CMFCVisualManager::OnHighlightMenuItem(CDC*pDC, CMFCToolBarMenuButton* /*pButton*/, CRect rect, COLORREF& /*clrText*/)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brHilite);
}

COLORREF CMFCVisualManager::GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton)
{
	ASSERT_VALID(pButton);

	if (pButton->m_nStyle & TBBS_DISABLED)
	{
		return afxGlobalData.clrGrayedText;
	}

	return afxGlobalData.clrTextHilite;
}

void CMFCVisualManager::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);
	dm.HighlightRect(rectRarelyUsed);

	pDC->Draw3dRect(rectRarelyUsed, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
}

void CMFCVisualManager::OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rectCheck, BOOL /*bHighlight*/, BOOL bIsRadio)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	int iImage = bIsRadio ? CMenuImages::IdRadio : CMenuImages::IdCheck;
	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rectCheck, (pButton->m_nStyle & TBBS_DISABLED) ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
}

void CMFCVisualManager::OnDrawMenuItemButton(CDC* pDC, CMFCToolBarMenuButton* /*pButton*/, CRect rectButton, BOOL bHighlight, BOOL /*bDisabled*/)
{
	ASSERT_VALID(pDC);

	CRect rect = rectButton;
	rect.right = rect.left + 1;
	rect.left--;
	rect.DeflateRect(0, bHighlight ? 1 : 4);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
}

void CMFCVisualManager::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	BOOL bIsOutlookButton = pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton));
	COLORREF clrDark = bIsOutlookButton ? afxGlobalData.clrBarDkShadow : afxGlobalData.clrBarShadow;

	switch(state)
	{
	case ButtonsIsPressed:
		pDC->Draw3dRect(&rect, clrDark, afxGlobalData.clrBarHilite);
		return;

	case ButtonsIsHighlighted:
		pDC->Draw3dRect(&rect, afxGlobalData.clrBarHilite, clrDark);
		return;
	}
}

void CMFCVisualManager::OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL /*bHorz*/)
{
	ASSERT_VALID(pButton);

	if (!m_bMenuFlatLook || !pButton->IsDroppedDown())
	{
		OnDrawButtonBorder(pDC, pButton, rect, state);
	}
}

void CMFCVisualManager::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	CRect rectSeparator = rect;

	if (bHorz)
	{
		rectSeparator.left += rectSeparator.Width() / 2 - 1;
		rectSeparator.right = rectSeparator.left + 2;
	}
	else
	{
		rectSeparator.top += rectSeparator.Height() / 2 - 1;
		rectSeparator.bottom = rectSeparator.top + 2;
	}

	const COLORREF clrHilite = pBar->IsDialogControl() ? afxGlobalData.clrBtnHilite : afxGlobalData.clrBarHilite;
	const COLORREF clrShadow = pBar->IsDialogControl() ? afxGlobalData.clrBtnShadow : afxGlobalData.clrBarShadow;

	pDC->Draw3dRect(rectSeparator, clrShadow, clrHilite);
}

COLORREF CMFCVisualManager::OnDrawMenuLabel(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBtnFace);

	CRect rectSeparator = rect;
	rectSeparator.top = rectSeparator.bottom - 2;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);

	return afxGlobalData.clrBtnText;
}

COLORREF CMFCVisualManager::OnDrawPaneCaption(CDC* pDC, CDockablePane* /*pBar*/, BOOL bActive, CRect rectCaption, CRect /*rectButtons*/)
{
	ASSERT_VALID(pDC);

	CBrush br(bActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption);
	pDC->FillRect(rectCaption, &br);

	// get the text color
	return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
}

void CMFCVisualManager::OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID /*= -1*/)
{
	ASSERT_VALID(pDC);
	CRect rc = pButton->GetRect();

	CMenuImages::IMAGES_IDS id = (CMenuImages::IMAGES_IDS)-1;

	if (nImageID != -1)
	{
		id = (CMenuImages::IMAGES_IDS)nImageID;
	}
	else
	{
		id = pButton->GetIconID(bHorz, bMaximized);
	}

	CRect rectImage = rc;

	if (pButton->m_bPushed &&(pButton->m_bFocused || pButton->m_bDroppedDown))
	{
		rectImage.OffsetRect(1, 1);
	}

	CMenuImages::IMAGE_STATE imageState;

	if (bDisabled)
	{
		imageState = CMenuImages::ImageGray;
	}
	else if (pButton->m_clrForeground == (COLORREF)-1)
	{
		imageState = bActive ? CMenuImages::ImageWhite : CMenuImages::ImageBlack;
	}
	else
	{
		if (GetRValue(pButton->m_clrForeground) > 192 && GetGValue(pButton->m_clrForeground) > 192 && GetBValue(pButton->m_clrForeground) > 192)
		{
			imageState = CMenuImages::ImageWhite;
		}
		else
		{
			imageState = CMenuImages::ImageBlack;
		}
	}

	CMenuImages::Draw(pDC, id, rectImage, imageState);

	if (!bDisabled)
	{
		if (pButton->m_bPushed &&(pButton->m_bFocused || pButton->m_bDroppedDown))
		{
			pDC->Draw3dRect(rc, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarLight);
			rc.DeflateRect(1, 1);
			pDC->Draw3dRect(rc, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);
		}
		else if (/*!m_bLook2000*/FALSE)
		{
			pDC->Draw3dRect(rc, afxGlobalData.clrBarLight, afxGlobalData.clrBarDkShadow);
			rc.DeflateRect(1, 1);
			pDC->Draw3dRect(rc, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
		}
		else if (pButton->m_bFocused || pButton->m_bPushed || pButton->m_bDroppedDown)
		{
			pDC->Draw3dRect(rc, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
		}
	}
}

void CMFCVisualManager::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* /*pTabWnd*/)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	COLORREF clrTab = pTabWnd->GetTabBkColor(iTab);

	CRect rectClip;
	pDC->GetClipBox(rectClip);

	if (pTabWnd->IsFlatTab())
	{
		//----------------
		// Draw tab edges:
		//----------------
#define AFX_FLAT_POINTS_NUM 4
		POINT pts [AFX_FLAT_POINTS_NUM];

		const int nHalfHeight = pTabWnd->GetTabsHeight() / 2;

		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
		{
			rectTab.bottom --;

			pts [0].x = rectTab.left;
			pts [0].y = rectTab.top;

			pts [1].x = rectTab.left + nHalfHeight;
			pts [1].y = rectTab.bottom;

			pts [2].x = rectTab.right - nHalfHeight;
			pts [2].y = rectTab.bottom;

			pts [3].x = rectTab.right;
			pts [3].y = rectTab.top;
		}
		else
		{
			rectTab.top ++;

			pts [0].x = rectTab.left + nHalfHeight;
			pts [0].y = rectTab.top;

			pts [1].x = rectTab.left;
			pts [1].y = rectTab.bottom;

			pts [2].x = rectTab.right;
			pts [2].y = rectTab.bottom;

			pts [3].x = rectTab.right - nHalfHeight;
			pts [3].y = rectTab.top;

			rectTab.left += 2;
		}

		CBrush* pOldBrush = NULL;
		CBrush br(clrTab);

		if (!bIsActive && clrTab != (COLORREF)-1)
		{
			pOldBrush = pDC->SelectObject(&br);
		}

		pDC->Polygon(pts, AFX_FLAT_POINTS_NUM);

		if (pOldBrush != NULL)
		{
			pDC->SelectObject(pOldBrush);
		}
	}
	else if (pTabWnd->IsLeftRightRounded())
	{
		CList<POINT, POINT> pts;

		POSITION posLeft = pts.AddHead(CPoint(rectTab.left, rectTab.top));
		posLeft = pts.InsertAfter(posLeft, CPoint(rectTab.left, rectTab.top + 2));

		POSITION posRight = pts.AddTail(CPoint(rectTab.right, rectTab.top));
		posRight = pts.InsertBefore(posRight, CPoint(rectTab.right, rectTab.top + 2));

		int xLeft = rectTab.left + 1;
		int xRight = rectTab.right - 1;

		int y = 0;

		for (y = rectTab.top + 2; y < rectTab.bottom - 4; y += 2)
		{
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y));
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y + 2));

			posRight = pts.InsertBefore(posRight, CPoint(xRight, y));
			posRight = pts.InsertBefore(posRight, CPoint(xRight, y + 2));

			xLeft++;
			xRight--;
		}

		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_TOP)
		{
			xLeft--;
			xRight++;
		}

		const int nTabLeft = xLeft - 1;
		const int nTabRight = xRight + 1;

		for (;y < rectTab.bottom - 1; y++)
		{
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y));
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 1, y + 1));

			posRight = pts.InsertBefore(posRight, CPoint(xRight, y));
			posRight = pts.InsertBefore(posRight, CPoint(xRight - 1, y + 1));

			if (y == rectTab.bottom - 2)
			{
				posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 1, y + 1));
				posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 3, y + 1));

				posRight = pts.InsertBefore(posRight, CPoint(xRight, y + 1));
				posRight = pts.InsertBefore(posRight, CPoint(xRight - 2, y + 1));
			}

			xLeft++;
			xRight--;
		}

		posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 2, rectTab.bottom));
		posRight = pts.InsertBefore(posRight, CPoint(xRight - 2, rectTab.bottom));

		LPPOINT points = new POINT [pts.GetCount()];

		int i = 0;

		for (POSITION pos = pts.GetHeadPosition(); pos != NULL; i++)
		{
			points [i] = pts.GetNext(pos);

			if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_TOP)
			{
				points [i].y = rectTab.bottom -(points [i].y - rectTab.top);
			}
		}

		CRgn rgnClip;
		rgnClip.CreatePolygonRgn(points, (int) pts.GetCount(), WINDING);

		pDC->SelectClipRgn(&rgnClip);

		CBrush br(clrTab == (COLORREF)-1 ? afxGlobalData.clrBtnFace : clrTab);
		OnFillTab(pDC, rectTab, &br, iTab, bIsActive, pTabWnd);

		pDC->SelectClipRgn(NULL);

		CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
		CPen* pOLdPen = pDC->SelectObject(&pen);

		for (i = 0; i < pts.GetCount(); i++)
		{
			if ((i % 2) != 0)
			{
				int x1 = points [i - 1].x;
				int y1 = points [i - 1].y;

				int x2 = points [i].x;
				int y2 = points [i].y;

				if (x1 > rectTab.CenterPoint().x && x2 > rectTab.CenterPoint().x)
				{
					x1--;
					x2--;
				}

				if (y2 >= y1)
				{
					pDC->MoveTo(x1, y1);
					pDC->LineTo(x2, y2);
				}
				else
				{
					pDC->MoveTo(x2, y2);
					pDC->LineTo(x1, y1);
				}
			}
		}

		delete [] points;
		pDC->SelectObject(pOLdPen);

		rectTab.left = nTabLeft;
		rectTab.right = nTabRight;
	}
	else // 3D Tab
	{
		CRgn rgnClip;

		CRect rectClipTab;
		pTabWnd->GetTabsRect(rectClipTab);

		BOOL bIsCutted = FALSE;

		const BOOL bIsOneNote = pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style();
		const int nExtra = bIsOneNote ? ((iTab == 0 || bIsActive || pTabWnd->IsVS2005Style()) ? 0 : rectTab.Height()) : 0;

		if (rectTab.left + nExtra + 10 > rectClipTab.right || rectTab.right - 10 <= rectClipTab.left)
		{
			return;
		}

		const int iVertOffset = 2;
		const int iHorzOffset = 2;
		const BOOL bIs2005 = pTabWnd->IsVS2005Style();

#define AFX_POINTS_NUM 8
		POINT pts [AFX_POINTS_NUM];

		if (!bIsActive || bIsOneNote || clrTab != (COLORREF)-1 || m_bAlwaysFillTab)
		{
			if (clrTab != (COLORREF)-1 || bIsOneNote || m_bAlwaysFillTab)
			{
				CRgn rgn;
				CBrush br(clrTab == (COLORREF)-1 ? afxGlobalData.clrBtnFace : clrTab);

				CRect rectFill = rectTab;

				if (bIsOneNote)
				{
					CRect rectFillTab = rectTab;

					const int nHeight = rectFillTab.Height();

					pts [0].x = rectFillTab.left;
					pts [0].y = rectFillTab.bottom;

					pts [1].x = rectFillTab.left;
					pts [1].y = rectFillTab.bottom;

					pts [2].x = rectFillTab.left + 2;
					pts [2].y = rectFillTab.bottom;

					pts [3].x = rectFillTab.left + nHeight;
					pts [3].y = rectFillTab.top + 2;

					pts [4].x = rectFillTab.left + nHeight + 4;
					pts [4].y = rectFillTab.top;

					pts [5].x = rectFillTab.right - 2;
					pts [5].y = rectFillTab.top;

					pts [6].x = rectFillTab.right;
					pts [6].y = rectFillTab.top + 2;

					pts [7].x = rectFillTab.right;
					pts [7].y = rectFillTab.bottom;

					for (int i = 0; i < AFX_POINTS_NUM; i++)
					{
						if (pts [i].x > rectClipTab.right)
						{
							pts [i].x = rectClipTab.right;
							bIsCutted = TRUE;
						}

						if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
						{
							pts [i].y = rectFillTab.bottom - pts [i].y + rectFillTab.top - 1;
						}
					}

					rgn.CreatePolygonRgn(pts, AFX_POINTS_NUM, WINDING);
					pDC->SelectClipRgn(&rgn);
				}
				else
				{
					rectFill.DeflateRect(1, 0);

					if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
					{
						rectFill.bottom--;
					}
					else
					{
						rectFill.top++;
					}

					rectFill.right = min(rectFill.right, rectClipTab.right);
				}

				OnFillTab(pDC, rectFill, &br, iTab, bIsActive, pTabWnd);
				pDC->SelectClipRgn(NULL);

				if (bIsOneNote)
				{
					CRect rectLeft;
					pTabWnd->GetClientRect(rectLeft);
					rectLeft.right = rectClipTab.left - 1;

					pDC->ExcludeClipRect(rectLeft);

					if (iTab > 0 && !bIsActive && iTab != pTabWnd->GetFirstVisibleTabNum())
					{
						CRect rectLeftTab = rectClipTab;
						rectLeftTab.right = rectFill.left + rectFill.Height() - 10;

						const int nVertOffset = bIs2005 ? 2 : 1;

						if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
						{
							rectLeftTab.top -= nVertOffset;
						}
						else
						{
							rectLeftTab.bottom += nVertOffset;
						}

						pDC->ExcludeClipRect(rectLeftTab);
					}

					pDC->Polyline(pts, AFX_POINTS_NUM);

					if (bIsCutted)
					{
						pDC->MoveTo(rectClipTab.right, rectTab.top);
						pDC->LineTo(rectClipTab.right, rectTab.bottom);
					}

					CRect rectRight = rectClipTab;
					rectRight.left = rectFill.right;

					pDC->ExcludeClipRect(rectRight);
				}
			}
		}

		CPen penLight(PS_SOLID, 1, afxGlobalData.clrBarHilite);
		CPen penShadow(PS_SOLID, 1, afxGlobalData.clrBarShadow);
		CPen penDark(PS_SOLID, 1, afxGlobalData.clrBarDkShadow);

		CPen* pOldPen = NULL;

		if (bIsOneNote)
		{
			pOldPen = (CPen*) pDC->SelectObject(&penLight);
			ENSURE(pOldPen != NULL);

			if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
			{
				if (!bIsCutted)
				{
					int yTop = bIsActive ? pts [7].y - 1 : pts [7].y;

					pDC->MoveTo(pts [6].x - 1, pts [6].y);
					pDC->LineTo(pts [7].x - 1, yTop);
				}
			}
			else
			{
				pDC->MoveTo(pts [2].x + 1, pts [2].y);
				pDC->LineTo(pts [3].x + 1, pts [3].y);

				pDC->MoveTo(pts [3].x + 1, pts [3].y);
				pDC->LineTo(pts [3].x + 2, pts [3].y);

				pDC->MoveTo(pts [3].x + 2, pts [3].y);
				pDC->LineTo(pts [3].x + 3, pts [3].y);

				pDC->MoveTo(pts [4].x - 1, pts [4].y + 1);
				pDC->LineTo(pts [5].x + 1, pts [5].y + 1);

				if (!bIsActive && !bIsCutted && m_b3DTabWideBorder)
				{
					pDC->SelectObject(&penShadow);

					pDC->MoveTo(pts [6].x - 2, pts [6].y - 1);
					pDC->LineTo(pts [6].x - 1, pts [6].y - 1);
				}

				pDC->MoveTo(pts [6].x - 1, pts [6].y);
				pDC->LineTo(pts [7].x - 1, pts [7].y);
			}
		}
		else
		{
			if (rectTab.right > rectClipTab.right)
			{
				CRect rectTabClip = rectTab;
				rectTabClip.right = rectClipTab.right;

				rgnClip.CreateRectRgnIndirect(&rectTabClip);
				pDC->SelectClipRgn(&rgnClip);
			}

			if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
			{
				pOldPen = (CPen*) pDC->SelectObject(&penLight);
				ENSURE(pOldPen != NULL);

				if (!m_b3DTabWideBorder)
				{
					pDC->SelectObject(&penShadow);
				}

				pDC->MoveTo(rectTab.left, rectTab.top);
				pDC->LineTo(rectTab.left, rectTab.bottom - iVertOffset);

				if (m_b3DTabWideBorder)
				{
					pDC->SelectObject(&penDark);
				}

				pDC->LineTo(rectTab.left + iHorzOffset, rectTab.bottom);
				pDC->LineTo(rectTab.right - iHorzOffset, rectTab.bottom);
				pDC->LineTo(rectTab.right, rectTab.bottom - iVertOffset);
				pDC->LineTo(rectTab.right, rectTab.top - 1);

				pDC->SelectObject(&penShadow);

				if (m_b3DTabWideBorder)
				{
					pDC->MoveTo(rectTab.left + iHorzOffset + 1, rectTab.bottom - 1);
					pDC->LineTo(rectTab.right - iHorzOffset, rectTab.bottom - 1);
					pDC->LineTo(rectTab.right - 1, rectTab.bottom - iVertOffset);
					pDC->LineTo(rectTab.right - 1, rectTab.top - 1);
				}
			}
			else
			{
				pOldPen = pDC->SelectObject(m_b3DTabWideBorder ? &penDark : &penShadow);

				ENSURE(pOldPen != NULL);

				pDC->MoveTo(rectTab.right, bIsActive ? rectTab.bottom : rectTab.bottom - 1);
				pDC->LineTo(rectTab.right, rectTab.top + iVertOffset);
				pDC->LineTo(rectTab.right - iHorzOffset, rectTab.top);

				if (m_b3DTabWideBorder)
				{
					pDC->SelectObject(&penLight);
				}

				pDC->LineTo(rectTab.left + iHorzOffset, rectTab.top);
				pDC->LineTo(rectTab.left, rectTab.top + iVertOffset);

				pDC->LineTo(rectTab.left, rectTab.bottom);

				if (m_b3DTabWideBorder)
				{
					pDC->SelectObject(&penShadow);

					pDC->MoveTo(rectTab.right - 1, bIsActive ? rectTab.bottom : rectTab.bottom - 1);
					pDC->LineTo(rectTab.right - 1, rectTab.top + iVertOffset - 1);
				}
			}
		}

		if (bIsActive)
		{
			const int iBarHeight = 1;
			const int y = (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM) ? (rectTab.top - iBarHeight - 1) :(rectTab.bottom);

			CRect rectFill(CPoint(rectTab.left, y), CSize(rectTab.Width(), iBarHeight + 1));

			COLORREF clrActiveTab = pTabWnd->GetTabBkColor(iTab);

			if (bIsOneNote)
			{
				if (bIs2005)
				{
					rectFill.left += 3;
				}
				else
				{
					rectFill.OffsetRect(1, 0);
					rectFill.left++;
				}

				if (clrActiveTab == (COLORREF)-1)
				{
					clrActiveTab = afxGlobalData.clrWindow;
				}
			}

			if (clrActiveTab != (COLORREF)-1)
			{
				CBrush br(clrActiveTab);
				pDC->FillRect(rectFill, &br);
			}
			else
			{
				pDC->FillRect(rectFill, &afxGlobalData.brBarFace);
			}
		}

		pDC->SelectObject(pOldPen);

		if (bIsOneNote)
		{
			const int nLeftMargin = pTabWnd->IsVS2005Style() && bIsActive ? rectTab.Height() * 3 / 4 : rectTab.Height();
			const int nRightMargin = pTabWnd->IsVS2005Style() && bIsActive ? CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN * 3 / 4 : CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN;

			rectTab.left += nLeftMargin;
			rectTab.right -= nRightMargin;

			if (pTabWnd->IsVS2005Style() && bIsActive && pTabWnd->HasImage(iTab))
			{
				rectTab.OffsetRect(CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN, 0);
			}
		}

		pDC->SelectClipRgn(NULL);
	}

	COLORREF clrText = pTabWnd->GetTabTextColor(iTab);

	COLORREF clrTextOld = (COLORREF)-1;
	if (!bIsActive && clrText != (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(clrText);
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style())
	{
		CRect rectClipTab;
		pTabWnd->GetTabsRect(rectClipTab);

		rectTab.right = min(rectTab.right, rectClipTab.right - 2);
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rectClip);

	pDC->SelectClipRgn(&rgn);

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd, (COLORREF)-1);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}

	pDC->SelectClipRgn(NULL);
}

void CMFCVisualManager::OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pbrFill);
	ASSERT_VALID(pTabWnd);

	if (bIsActive && !afxGlobalData.IsHighContrastMode() && (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded()) &&
		pTabWnd->GetTabBkColor(iTab) == (COLORREF)-1)
	{
		pDC->FillRect(rectFill, &afxGlobalData.brWindow);
	}
	else
	{
		pDC->FillRect(rectFill, pbrFill);
	}
}

BOOL CMFCVisualManager::OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	COLORREF clrActiveTab = pTabWnd->GetTabBkColor(pTabWnd->GetActiveTab());

	if (clrActiveTab == (COLORREF)-1)
	{
		return FALSE;
	}

	pDC->FillSolidRect(rect, clrActiveTab);
	return TRUE;
}

void CMFCVisualManager::OnDrawTabContent(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd, COLORREF clrText)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (pTabWnd->IsActiveTabCloseButton() && bIsActive)
	{
		CRect rectClose = pTabWnd->GetTabCloseButton();
		rectTab.right = rectClose.left;

		OnDrawTabCloseButton(pDC, rectClose, pTabWnd, pTabWnd->IsTabCloseButtonHighlighted(), pTabWnd->IsTabCloseButtonPressed(), FALSE /* Disabled */);
	}

	CString strText;
	pTabWnd->GetTabLabel(iTab, strText);

	if (pTabWnd->IsFlatTab())
	{
		//---------------
		// Draw tab text:
		//---------------
		UINT nFormat = DT_SINGLELINE | DT_CENTER | DT_VCENTER;
		if (pTabWnd->IsDrawNoPrefix())
		{
			nFormat |= DT_NOPREFIX;
		}

		pDC->DrawText(strText, rectTab, nFormat);
	}
	else
	{
		CSize sizeImage = pTabWnd->GetImageSize();
		UINT uiIcon = pTabWnd->GetTabIcon(iTab);
		HICON hIcon = pTabWnd->GetTabHicon(iTab);

		if (uiIcon == (UINT)-1 && hIcon == NULL)
		{
			sizeImage.cx = 0;
		}

		if (sizeImage.cx + 2 * CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN <= rectTab.Width())
		{
			if (hIcon != NULL)
			{
				//---------------------
				// Draw the tab's icon:
				//---------------------
				CRect rectImage = rectTab;

				rectImage.top += (rectTab.Height() - sizeImage.cy) / 2;
				rectImage.bottom = rectImage.top + sizeImage.cy;

				rectImage.left += AFX_IMAGE_MARGIN;
				rectImage.right = rectImage.left + sizeImage.cx;

				pDC->DrawState(rectImage.TopLeft(), rectImage.Size(), hIcon, DSS_NORMAL, (HBRUSH) NULL);
			}
			else
			{
				const CImageList* pImageList = pTabWnd->GetImageList();
				if (pImageList != NULL && uiIcon != (UINT)-1)
				{
					//----------------------
					// Draw the tab's image:
					//----------------------
					CRect rectImage = rectTab;

					rectImage.top += (rectTab.Height() - sizeImage.cy) / 2;
					rectImage.bottom = rectImage.top + sizeImage.cy;

					rectImage.left += AFX_IMAGE_MARGIN;
					rectImage.right = rectImage.left + sizeImage.cx;

					ASSERT_VALID(pImageList);
					((CImageList*) pImageList)->Draw(pDC, uiIcon, rectImage.TopLeft(), ILD_TRANSPARENT);
				}
			}

			//------------------------------
			// Finally, draw the tab's text:
			//------------------------------
			CRect rcText = rectTab;
			rcText.left += sizeImage.cx + 2 * AFX_TEXT_MARGIN;

			if (rcText.Width() < sizeImage.cx * 2 && !pTabWnd->IsLeftRightRounded())
			{
				rcText.right -= AFX_TEXT_MARGIN;
			}

			if (clrText == (COLORREF)-1)
			{
				clrText = GetTabTextColor(pTabWnd, iTab, bIsActive);
			}

			if (clrText != (COLORREF)-1)
			{
				pDC->SetTextColor(clrText);
			}

			UINT nFormat = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS;
			if (pTabWnd->IsDrawNoPrefix())
			{
				nFormat |= DT_NOPREFIX;
			}

			if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style())
			{
				nFormat |= DT_CENTER;
			}
			else
			{
				nFormat |= DT_LEFT;
			}

			pDC->DrawText(strText, rcText, nFormat);
		}
	}
}

void CMFCVisualManager::OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* /*pTabWnd*/, BOOL bIsHighlighted, BOOL bIsPressed, BOOL /*bIsDisabled*/)
{
	if (bIsHighlighted)
	{
		pDC->FillRect(rect, &afxGlobalData.brBarFace);
	}

	CMenuImages::Draw(pDC, CMenuImages::IdClose, rect, CMenuImages::ImageBlack);

	if (bIsHighlighted)
	{
		if (bIsPressed)
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);
		}
		else
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);
		}
	}
}

void CMFCVisualManager::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* /*pButton*/, CMFCBaseTabCtrl* /*pWndTab*/)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* /*pWndTab*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsPressed() ||(uiState & ODS_SELECTED))
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);

		rect.left += 2;
		rect.top += 2;
	}
	else
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);
	}

	rect.DeflateRect(2, 2);
}

void CMFCVisualManager::OnDrawTabResizeBar(CDC* pDC, CMFCBaseTabCtrl* /*pWndTab*/, BOOL bIsVert, CRect rect, CBrush* pbrFace, CPen* pPen)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pbrFace);
	ASSERT_VALID(pPen);

	pDC->FillRect(rect, pbrFace);

	CPen* pOldPen = pDC->SelectObject(pPen);
	ASSERT_VALID(pOldPen);

	if (bIsVert)
	{
		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.left, rect.bottom);
	}
	else
	{
		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.right, rect.top);
	}

	pDC->SelectObject(pOldPen);
}

COLORREF CMFCVisualManager::OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	if (bIsSelected)
	{
		pDC->FillRect(rect, &afxGlobalData.brHilite);

		const int nFrameSize = 1;

		rect.DeflateRect(1, 1);
		rect.right--;
		rect.bottom--;

		pDC->PatBlt(rect.left, rect.top + nFrameSize, nFrameSize, rect.Height(), PATINVERT);
		pDC->PatBlt(rect.left, rect.top, rect.Width(), nFrameSize, PATINVERT);
		pDC->PatBlt(rect.right, rect.top, nFrameSize, rect.Height(), PATINVERT);
		pDC->PatBlt(rect.left + nFrameSize, rect.bottom, rect.Width(), nFrameSize, PATINVERT);

		return afxGlobalData.clrTextHilite;
	}

	pDC->FillRect(rect, &afxGlobalData.brBarFace);

	return afxGlobalData.clrBarText;
}

void CMFCVisualManager::OnDrawMenuArrowOnCustomizeList(CDC* pDC, CRect rectCommand, BOOL bSelected)
{
	CRect rectTriangle = rectCommand;
	rectTriangle.left = rectTriangle.right - CMenuImages::Size().cx;

	CMenuImages::Draw(pDC, CMenuImages::IdArrowRightLarge, rectTriangle, bSelected ? CMenuImages::ImageWhite : CMenuImages::ImageBlack);

	CRect rectLine = rectCommand;
	rectLine.right = rectTriangle.left - 1;
	rectLine.left = rectLine.right - 2;
	rectLine.DeflateRect(0, 2);

	pDC->Draw3dRect(&rectLine, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);
}

CMFCVisualManager* __stdcall CMFCVisualManager::CreateVisualManager(CRuntimeClass* pVisualManager)
{
	if (pVisualManager == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	CMFCVisualManager* pVisManagerOld = m_pVisManager;

	CObject* pObj = pVisualManager->CreateObject();
	if (pObj == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	ASSERT_VALID(pObj);

	if (pVisManagerOld != NULL)
	{
		ASSERT_VALID(pVisManagerOld);
		delete pVisManagerOld;
	}

	m_pVisManager = (CMFCVisualManager*) pObj;
	m_pVisManager->m_bAutoDestroy = TRUE;

	return m_pVisManager;
}

void __stdcall CMFCVisualManager::DestroyInstance(BOOL bAutoDestroyOnly)
{
	if (m_pVisManager == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pVisManager);

	if (bAutoDestroyOnly && !m_pVisManager->m_bAutoDestroy)
	{
		return;
	}

	delete m_pVisManager;
	m_pVisManager = NULL;
}

void CMFCVisualManager::OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive)
{
	const int nBorderSize = 2;

	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBarFace);

	rect.DeflateRect(nBorderSize, 1);

	pDC->FillSolidRect(rect, bIsActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption);
}

void CMFCVisualManager::OnDrawMenuResizeBar(CDC* pDC, CRect rect, int /*nResizeFlags*/)
{
	ASSERT_VALID(pDC);

	pDC->FillSolidRect(rect, afxGlobalData.clrInactiveCaption);
}

void CMFCVisualManager::OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL /*bIsPressed*/, BOOL /*bIsDisabled*/)
{
	ASSERT_VALID(pDC);

	CRect rectFill = rect;
	rectFill.top -= 2;

	pDC->FillRect(rectFill, &afxGlobalData.brBarFace);

	CMenuImages::Draw(pDC, bIsScrollDown ? CMenuImages::IdArrowDown : CMenuImages::IdArrowUp, rect);

	if (bIsHighlited)
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}
}

void CMFCVisualManager::OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL /*bHighlight*/)
{
	ASSERT_VALID(pDC);

	UINT uiState = 0;

	switch(uiSystemCommand)
	{
	case SC_CLOSE:
		uiState |= DFCS_CAPTIONCLOSE;
		break;

	case SC_MINIMIZE:
		uiState |= DFCS_CAPTIONMIN;
		break;

	case SC_RESTORE:
		uiState |= DFCS_CAPTIONRESTORE;
		break;

	default:
		return;
	}

	if (nStyle & TBBS_PRESSED)
	{
		uiState |= DFCS_PUSHED;
	}

	if (nStyle & TBBS_DISABLED) // Jan Vasina: Add support for disabled buttons
	{
		uiState |= DFCS_INACTIVE;
	}

	pDC->DrawFrameControl(rect, DFC_CAPTION, uiState);
}

void CMFCVisualManager::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* /*pButton*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	COLORREF clrText = pDC->GetTextColor();

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarHilite);

		if (bIsDropped)
		{
			rect.OffsetRect(1, 1);
			dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrBarShadow);
		}
		else if (bIsHighlighted)
		{
			dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrBarShadow);
		}
	}
	else
	{
		pDC->FillRect(rect, &afxGlobalData.brBarFace);
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);

		if (bIsDropped)
		{
			rect.OffsetRect(1, 1);
			pDC->Draw3dRect(&rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
		}
		else if (bIsHighlighted)
		{
			pDC->Draw3dRect(&rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
		}
	}

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);

	pDC->SetTextColor(clrText);
}

void CMFCVisualManager::OnDrawComboBorder(CDC* pDC, CRect rect, BOOL /*bDisabled*/, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* /*pButton*/)
{
	ASSERT_VALID(pDC);

	if (bIsHighlighted || bIsDropped)
	{
		if (m_bMenuFlatLook)
		{
			CRect rectBorder = rect;
			rectBorder.DeflateRect(1, 1);

			pDC->Draw3dRect(&rectBorder, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
		}
		else
		{
			pDC->Draw3dRect(&rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
		}
	}
}

void CMFCVisualManager::OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* /*pBar*/, CRect rectPane, UINT /*uiID*/, UINT nStyle)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	if (!(nStyle & SBPS_NOBORDERS))
	{
		// draw the borders
		COLORREF clrHilite;
		COLORREF clrShadow;

		if (nStyle & SBPS_POPOUT)
		{
			// reverse colors
			clrHilite = afxGlobalData.clrBarShadow;
			clrShadow = afxGlobalData.clrBarHilite;
		}
		else
		{
			// normal colors
			clrHilite = afxGlobalData.clrBarHilite;
			clrShadow = afxGlobalData.clrBarShadow;
		}

		pDC->Draw3dRect(rectPane, clrShadow, clrHilite);
	}
}

COLORREF CMFCVisualManager::OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	if (DYNAMIC_DOWNCAST(CMFCBaseToolBar, pFrameWnd->GetPane()) != NULL)
	{
		bActive = TRUE;
	}

	CBrush br(bActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption);
	pDC->FillRect(rectCaption, &br);

	// get the text color
	return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
}

void CMFCVisualManager::OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	AFX_PREDOCK_STATE preDockState = pFrameWnd->GetPreDockState();

	if (preDockState == PDS_DOCK_REGULAR)
	{
		// draw outer edge;
		pDC->Draw3dRect(rectBorder, RGB(127, 0, 0), afxGlobalData.clrBarDkShadow);
		rectBorder.DeflateRect(1, 1);
		pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, RGB(127, 0, 0));
	}
	else if (preDockState == PDS_DOCK_TO_TAB)
	{
		// draw outer edge;
		pDC->Draw3dRect(rectBorder, RGB(0, 0, 127), afxGlobalData.clrBarDkShadow);
		rectBorder.DeflateRect(1, 1);
		pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, RGB(0, 0, 127));
	}
	else
	{
		// draw outer edge;
		pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarDkShadow);
		rectBorder.DeflateRect(1, 1);
		pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}

	// draw the inner egde
	rectBorder.DeflateRect(rectBorderSize.right - 2, rectBorderSize.top - 2);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
	rectBorder.InflateRect(1, 1);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

void CMFCVisualManager::OnDrawFloatingToolbarBorder(CDC* pDC, CMFCBaseToolBar* /*pToolBar*/, CRect rectBorder, CRect /*rectBorderSize*/)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarDkShadow);
	rectBorder.DeflateRect(1, 1);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	rectBorder.DeflateRect(1, 1);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

COLORREF CMFCVisualManager::GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pButton);

	BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() && !pButton->IsEditable()) || (!CMFCToolBar::IsCustomizeMode() &&(pButton->m_nStyle & TBBS_DISABLED));

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton)))
	{
		if (afxGlobalData.IsHighContrastMode())
		{
			return bDisabled ? afxGlobalData.clrGrayedText : afxGlobalData.clrWindowText;
		}

		return bDisabled ? afxGlobalData.clrBtnFace : afxGlobalData.clrWindow;
	}

	return(bDisabled ? afxGlobalData.clrGrayedText : (state == ButtonsIsHighlighted) ? CMFCToolBar::GetHotTextColor() : afxGlobalData.clrBarText);
}

void CMFCVisualManager::OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL /*bIsHighlighted*/, BOOL /*bIsPressed*/, COLORREF& clrText)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBarFace);
	clrText = afxGlobalData.clrBarText;
}

void CMFCVisualManager::OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed)
{
	ASSERT_VALID(pDC);

	if (bIsHighlighted && bIsPressed)
	{
		pDC->Draw3dRect(rectBtn, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarFace);
		rectBtn.DeflateRect(1, 1);
		pDC->Draw3dRect(rectBtn, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
	else
	{
		if (bIsHighlighted || bIsPressed)
		{
			pDC->Draw3dRect(rectBtn, afxGlobalData.clrBarFace, afxGlobalData.clrBarDkShadow);
			rectBtn.DeflateRect(1, 1);
		}

		pDC->Draw3dRect(rectBtn, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}

	rectBtn.DeflateRect(1, 1);
}

COLORREF CMFCVisualManager::GetCaptionBarTextColor(CMFCCaptionBar* pBar)
{
	ASSERT_VALID(pBar);

	return pBar->IsMessageBarMode() ? ::GetSysColor(COLOR_INFOTEXT) : afxGlobalData.clrWindow;
}

void CMFCVisualManager::OnDrawCaptionBarBorder(CDC* pDC, CMFCCaptionBar* /*pBar*/, CRect rect, COLORREF clrBarBorder, BOOL bFlatBorder)
{
	ASSERT_VALID(pDC);

	if (clrBarBorder == (COLORREF) -1)
	{
		pDC->FillRect(rect, &afxGlobalData.brBarFace);
	}
	else
	{
		CBrush brBorder;
		brBorder.CreateSolidBrush(clrBarBorder);
		pDC->FillRect(rect, &brBorder);
	}

	if (!bFlatBorder)
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}
}

void CMFCVisualManager::OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* /*pBar*/, CRect rect)
{
	ASSERT_VALID(pDC);

	::FillRect(pDC->GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_INFOBK));

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

COLORREF CMFCVisualManager::OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
	BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton)
{
	UNREFERENCED_PARAMETER(bIsPressed);
	UNREFERENCED_PARAMETER(bIsHighlighted);
	UNREFERENCED_PARAMETER(bIsDisabled);
	UNREFERENCED_PARAMETER(bHasDropDownArrow);
	UNREFERENCED_PARAMETER(bIsSysButton);

	ASSERT_VALID(pBar);

	if (!pBar->IsMessageBarMode())
	{
		return(COLORREF)-1;
	}

	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBarFace);
	return bIsDisabled ? afxGlobalData.clrGrayedText : afxGlobalData.clrBarText;
}

void CMFCVisualManager::OnDrawCaptionBarButtonBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
	BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton)
{
	UNREFERENCED_PARAMETER(bIsDisabled);
	UNREFERENCED_PARAMETER(bHasDropDownArrow);
	UNREFERENCED_PARAMETER(bIsSysButton);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (bIsPressed)
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);
	}
	else if (bIsHighlighted || pBar->IsMessageBarMode())
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);
	}
}

void CMFCVisualManager::OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* /*pStatusBar*/, CRect rectProgress,
	int nProgressTotal, int nProgressCurr, COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText)
{
	ASSERT_VALID(pDC);

	if (nProgressTotal == 0)
	{
		return;
	}

	CRect rectComplete = rectProgress;
	rectComplete.right = rectComplete.left + nProgressCurr * rectComplete.Width() / nProgressTotal;

	if (clrProgressBarDest == (COLORREF)-1)
	{
		// one-color bar
		CBrush br(clrBar);
		pDC->FillRect(rectComplete, &br);
	}
	else
	{
		// gradient bar:
		CDrawingManager dm(*pDC);
		dm.FillGradient(rectComplete, clrBar, clrProgressBarDest, FALSE);
	}

	if (bProgressText)
	{
		CString strText;
		strText.Format(_T("%d%%"), nProgressCurr * 100 / nProgressTotal);

		COLORREF clrText = pDC->SetTextColor(afxGlobalData.clrBarText);

		pDC->DrawText(strText, rectProgress, DT_CENTER | DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);

		CRgn rgn;
		rgn.CreateRectRgnIndirect(rectComplete);
		pDC->SelectClipRgn(&rgn);
		pDC->SetTextColor(clrProgressText == (COLORREF)-1 ? afxGlobalData.clrTextHilite : clrProgressText);
		pDC->DrawText(strText, rectProgress, DT_CENTER | DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX);
		pDC->SelectClipRgn(NULL);
		pDC->SetTextColor(clrText);
	}
}

void CMFCVisualManager::OnFillHeaderCtrlBackground(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, pCtrl->IsDialogControl() ? &afxGlobalData.brBtnFace : &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL /*bIsHighlighted*/)
{
	ASSERT_VALID(pDC);

	if (bIsPressed)
	{
		if (pCtrl->IsDialogControl())
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnShadow);
		}
		else
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
		}

		rect.left++;
		rect.top++;
	}
	else
	{
		if (pCtrl->IsDialogControl())
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnShadow);
		}
		else
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
		}
	}
}

void CMFCVisualManager::OnDrawHeaderCtrlSortArrow(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rectArrow, BOOL bIsUp)
{
	DoDrawHeaderSortArrow(pDC, rectArrow, bIsUp, pCtrl->IsDialogControl());
}

void CMFCVisualManager::OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* /*pStatBar*/, CRect rectSizeBox)
{
	ASSERT_VALID(pDC);

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontMarlett);
	ENSURE(pOldFont != NULL);

	const CString strSizeBox(_T("o")); // Char of the sizing box in "Marlett" font

	UINT nTextAlign = pDC->SetTextAlign(TA_RIGHT | TA_BOTTOM);
	COLORREF clrText = pDC->SetTextColor(afxGlobalData.clrBarShadow);

	pDC->ExtTextOut(rectSizeBox.right, rectSizeBox.bottom,
		ETO_CLIPPED, &rectSizeBox, strSizeBox, NULL);

	pDC->SelectObject(pOldFont);
	pDC->SetTextColor(clrText);
	pDC->SetTextAlign(nTextAlign);
}

void CMFCVisualManager::OnDrawEditBorder(CDC* pDC, CRect rect, BOOL /*bDisabled*/, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* /*pButton*/)
{
	ASSERT_VALID(pDC);

	if (bIsHighlighted)
	{
		pDC->DrawEdge(rect, EDGE_SUNKEN, BF_RECT);
	}
}

void CMFCVisualManager::OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rectWorkArea, &afxGlobalData.brWindow);
}

void CMFCVisualManager::OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted, BOOL bIsSelected, BOOL bCanCollapse)
{
	ENSURE(pGroup != NULL);
	ENSURE(pGroup->m_pPage != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);
	ASSERT_VALID(pGroup->m_pPage);

	CRect rectGroup = pGroup->m_rect;

	// ---------------------------------
	// Draw caption background(Windows)
	// ---------------------------------
	COLORREF clrBckOld = pDC->GetBkColor();
	pDC->FillSolidRect(rectGroup, (pGroup->m_bIsSpecial ? afxGlobalData.clrHilite : afxGlobalData.clrBarFace));
	pDC->SetBkColor(clrBckOld);

	// ---------------------------
	// Draw an icon if it presents
	// ---------------------------
	BOOL bShowIcon = (pGroup->m_hIcon != NULL && pGroup->m_sizeIcon.cx < rectGroup.Width() - rectGroup.Height());
	if (bShowIcon)
	{
		OnDrawTasksGroupIcon(pDC, pGroup, 5, bIsHighlighted, bIsSelected, bCanCollapse);
	}

	// -----------------------
	// Draw group caption text
	// -----------------------
	CFont* pFontOld = pDC->SelectObject(&afxGlobalData.fontBold);
	COLORREF clrTextOld = pDC->GetTextColor();

	if (bCanCollapse && bIsHighlighted)
	{
		clrTextOld = pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ? (pGroup->m_bIsSpecial ? afxGlobalData.clrWindow : afxGlobalData.clrWindowText) : pGroup->m_clrTextHot);
	}
	else
	{
		clrTextOld = pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ? (pGroup->m_bIsSpecial ? afxGlobalData.clrWindow : afxGlobalData.clrWindowText) : pGroup->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	int nTaskPaneHOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionHorzOffset();
	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();
	int nCaptionHOffset = (nTaskPaneHOffset != -1 ? nTaskPaneHOffset : m_nGroupCaptionHorzOffset);

	CRect rectText = rectGroup;
	rectText.left += (bShowIcon ? pGroup->m_sizeIcon.cx + 5: nCaptionHOffset);
	rectText.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectText.right = max(rectText.left, rectText.right -(bCanCollapse ? rectGroup.Height() : nCaptionHOffset));

	pDC->DrawText(pGroup->m_strName, rectText, DT_SINGLELINE | DT_VCENTER);

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);

	// -------------------------
	// Draw group caption button
	// -------------------------
	if (bCanCollapse && !pGroup->m_strName.IsEmpty())
	{
		CSize sizeButton = CMenuImages::Size();
		CRect rectButton = rectGroup;
		rectButton.left = max(rectButton.left, rectButton.right -(rectButton.Height()+1)/2 -(sizeButton.cx+1)/2);
		rectButton.top = max(rectButton.top, rectButton.bottom -(rectButton.Height()+1)/2 -(sizeButton.cy+1)/2);
		rectButton.right = rectButton.left + sizeButton.cx;
		rectButton.bottom = rectButton.top + sizeButton.cy;

		if (rectButton.right <= rectGroup.right && rectButton.bottom <= rectGroup.bottom)
		{
			if (bIsHighlighted)
			{
				// Draw button frame
				CBrush* pBrushOld = (CBrush*) pDC->SelectObject(&afxGlobalData.brBarFace);
				COLORREF clrBckOldFrame = pDC->GetBkColor();

				pDC->Draw3dRect(&rectButton, afxGlobalData.clrWindow, afxGlobalData.clrBarShadow);

				pDC->SetBkColor(clrBckOldFrame);
				pDC->SelectObject(pBrushOld);
			}

			if (pGroup->m_bIsSpecial)
			{
				if (!pGroup->m_bIsCollapsed)
				{
					CMenuImages::Draw(pDC, CMenuImages::IdArrowUp, rectButton.TopLeft());
				}
				else
				{
					CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectButton.TopLeft());
				}
			}
			else
			{
				if (!pGroup->m_bIsCollapsed)
				{
					CMenuImages::Draw(pDC, CMenuImages::IdArrowUp, rectButton.TopLeft());
				}
				else
				{
					CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectButton.TopLeft());
				}
			}
		}
	}
}

void CMFCVisualManager::OnDrawTasksGroupIcon(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, int nIconHOffset, BOOL /*bIsHighlighted*/, BOOL /*bIsSelected*/, BOOL /*bCanCollapse*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);

	if (pGroup->m_hIcon == NULL)
	{
		return;
	}

	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();

	CRect rectImage = pGroup->m_rect;
	rectImage.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectImage.right = rectImage.left + pGroup->m_sizeIcon.cx + nIconHOffset;

	int x = max(0, (rectImage.Width() - pGroup->m_sizeIcon.cx) / 2);
	int y = max(0, (rectImage.Height() - pGroup->m_sizeIcon.cy) / 2);

	::DrawIconEx(pDC->GetSafeHdc(), rectImage.left + x, rectImage.bottom - y - pGroup->m_sizeIcon.cy,
		pGroup->m_hIcon, pGroup->m_sizeIcon.cx, pGroup->m_sizeIcon.cy, 0, NULL, DI_NORMAL);
}

void CMFCVisualManager::OnFillTasksGroupInterior(CDC* /*pDC*/, CRect /*rect*/, BOOL /*bSpecial*/)
{
}

void CMFCVisualManager::OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial, BOOL bNoTitle)
{
	ASSERT_VALID(pDC);

	// Draw caption background:
	CPen* pPenOld = (CPen*) pDC->SelectObject(bSpecial ? &afxGlobalData.penHilite : &afxGlobalData.penBarFace);

	pDC->MoveTo(rect.left, rect.top);
	pDC->LineTo(rect.left, rect.bottom-1);
	pDC->LineTo(rect.right-1, rect.bottom-1);
	pDC->LineTo(rect.right-1, rect.top);
	if (bNoTitle)
	{
		pDC->LineTo(rect.left, rect.top);
	}
	else
	{
		pDC->LineTo(rect.right-1, rect.top-1);
	}
	pDC->SelectObject(pPenOld);
}

void CMFCVisualManager::OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted, BOOL /*bIsSelected*/)
{
	ENSURE(pTask != NULL);
	ENSURE(pIcons != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pIcons);
	ASSERT_VALID(pTask);

	CRect rectText = pTask->m_rect;

	if (pTask->m_bIsSeparator)
	{
		CPen* pPenOld = (CPen*) pDC->SelectObject(&afxGlobalData.penBarFace);

		pDC->MoveTo(rectText.left, rectText.CenterPoint().y);
		pDC->LineTo(rectText.right, rectText.CenterPoint().y);

		pDC->SelectObject(pPenOld);
		return;
	}

	// ---------
	// Draw icon
	// ---------
	CSize sizeIcon(0, 0);
	::ImageList_GetIconSize(pIcons->m_hImageList, (int*) &sizeIcon.cx, (int*) &sizeIcon.cy);
	if (pTask->m_nIcon >= 0 && sizeIcon.cx > 0)
	{
		pIcons->Draw(pDC, pTask->m_nIcon, rectText.TopLeft(), ILD_TRANSPARENT);
	}
	int nTaskPaneOffset = pTask->m_pGroup->m_pPage->m_pTaskPane->GetTasksIconHorzOffset();
	rectText.left += sizeIcon.cx +(nTaskPaneOffset != -1 ? nTaskPaneOffset : m_nTasksIconHorzOffset);

	// ---------
	// Draw text
	// ---------
	BOOL bIsLabel = (pTask->m_uiCommandID == 0);

	CFont* pFontOld = NULL;
	COLORREF clrTextOld = pDC->GetTextColor();
	if (bIsLabel)
	{
		pFontOld = pDC->SelectObject(pTask->m_bIsBold ? &afxGlobalData.fontBold : &afxGlobalData.fontRegular);
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrText);
	}
	else if (!pTask->m_bEnabled)
	{
		pDC->SetTextColor(afxGlobalData.clrGrayedText);
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
	}
	else if (bIsHighlighted)
	{
		pFontOld = pDC->SelectObject(&afxGlobalData.fontUnderline);
		pDC->SetTextColor(pTask->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrTextHot);
	}
	else
	{
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	CMFCTasksPane* pTaskPane = pTask->m_pGroup->m_pPage->m_pTaskPane;
	ASSERT_VALID(pTaskPane);

	BOOL bMultiline = bIsLabel ? pTaskPane->IsWrapLabelsEnabled() : pTaskPane->IsWrapTasksEnabled();

	if (bMultiline)
	{
		pDC->DrawText(pTask->m_strName, rectText, DT_WORDBREAK);
	}
	else
	{
		CString strText = pTask->m_strName;
		strText.Remove (_T('\n'));
		strText.Remove (_T('\r'));
		pDC->DrawText(strText, rectText, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	}

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);
}

void CMFCVisualManager::OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited)
{
	ASSERT_VALID(pDC);

	CRect rectImage(CPoint(0, 0), CMenuImages::Size());

	CRect rectFill = rect;
	rectFill.top -= nBorderSize;

	pDC->FillRect(rectFill, &afxGlobalData.brBarFace);

	if (bHilited)
	{
		CDrawingManager dm(*pDC);
		dm.HighlightRect(rect);

		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);
	}

	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rect);
}

void CMFCVisualManager::OnDrawToolBoxFrame(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

void CMFCVisualManager::OnDrawPaneDivider(CDC* pDC, CPaneDivider* pSlider, CRect rect, BOOL bAutoHideMode)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pSlider);

	CRect rectScreen = afxGlobalData.m_rectVirtual;
	pSlider->ScreenToClient(&rectScreen);

	CRect rectFill = rect;
	rectFill.left = min(rectFill.left, rectScreen.left);

	OnFillBarBackground(pDC, pSlider, rectFill, rect);

	if (bAutoHideMode)
	{
		// draw outer edge;

		DWORD dwAlgn = pSlider->GetCurrentAlignment();
		CRect rectBorder = rect;

		COLORREF clrBorder = afxGlobalData.clrBarDkShadow;

		if (dwAlgn & CBRS_ALIGN_LEFT)
		{
			rectBorder.left = rectBorder.right;
		}
		else if (dwAlgn & CBRS_ALIGN_RIGHT)
		{
			rectBorder.right = rectBorder.left;
			clrBorder = afxGlobalData.clrBarHilite;
		}
		else if (dwAlgn & CBRS_ALIGN_TOP)
		{
			rectBorder.top = rectBorder.bottom;
		}
		else if (dwAlgn & CBRS_ALIGN_BOTTOM)
		{
			rectBorder.bottom = rectBorder.top;
			clrBorder = afxGlobalData.clrBarHilite;
		}
		else
		{
			ASSERT(FALSE);
			return;
		}

		pDC->Draw3dRect(rectBorder, clrBorder, clrBorder);
	}
}

void CMFCVisualManager::OnDrawSplitterBorder(CDC* pDC, CSplitterWndEx* /*pSplitterWnd*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

void CMFCVisualManager::OnDrawSplitterBox(CDC* pDC, CSplitterWndEx* /*pSplitterWnd*/, CRect& rect)
{
	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarShadow);
}

void CMFCVisualManager::OnFillSplitterBackground(CDC* pDC, CSplitterWndEx* /*pSplitterWnd*/, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillSolidRect(rect, afxGlobalData.clrBarFace);
}

void CMFCVisualManager::OnDrawCheckBox(CDC *pDC, CRect rect, BOOL bHighlighted, BOOL bChecked, BOOL bEnabled)
{
	OnDrawCheckBoxEx(pDC, rect, bChecked ? 1 : 0, bHighlighted, FALSE, bEnabled);
}

void CMFCVisualManager::OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL /*bPressed*/, BOOL bEnabled)
{
	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);

		rect.DeflateRect(1, 1);

		dm.DrawRect(rect, bEnabled ? afxGlobalData.clrWindow : afxGlobalData.clrBarFace, afxGlobalData.clrBarShadow);

		if (nState == 1)
		{
			CMenuImages::Draw(pDC, CMenuImages::IdCheck, rect, CMenuImages::ImageBlack);
		}

		return;
	}

	if (bHighlighted)
	{
		pDC->DrawFocusRect(rect);
	}

	rect.DeflateRect(1, 1);
	pDC->FillSolidRect(&rect, bEnabled ? afxGlobalData.clrWindow : afxGlobalData.clrBarFace);
	pDC->Draw3dRect(&rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);

	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(&rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarLight);

	if (nState == 1)
	{
		CMenuImages::Draw(pDC, CMenuImages::IdCheck, rect, CMenuImages::ImageBlack);
	}
	else if (nState == 2)
	{
		rect.DeflateRect(1, 1);

		CBrush br;
		br.CreateHatchBrush(HS_DIAGCROSS, afxGlobalData.clrBtnText);

		pDC->FillRect(rect, &br);
	}
}

void CMFCVisualManager::OnDrawSpinButtons(CDC* pDC, CRect rectSpin, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* /*pSpinCtrl*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	rectSpin.DeflateRect(1, 1);

	CRect rect[2];

	rect[0] = rect[1] = rectSpin;

	if (!bOrientation)
	{
		rect[0].DeflateRect(0, 0, 0, rect[0].Height() / 2);
		rect[1].top = rect[0].bottom + 1;
	}
	else
	{
		rect[0].DeflateRect(0, 0, rect[0].Width() / 2, 0);
		rect[1].left = rect[0].right + 1;
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rectSpin, afxGlobalData.clrBarFace, afxGlobalData.clrBarHilite);
	}
	else
	{
		pDC->FillRect(rectSpin, &afxGlobalData.brBarFace);
		pDC->Draw3dRect(rectSpin, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
	}

	CMenuImages::IMAGES_IDS id[2][2] = {{CMenuImages::IdArrowUp, CMenuImages::IdArrowDown}, {CMenuImages::IdArrowLeft, CMenuImages::IdArrowRight}};

	int idxPressed = (nState &(AFX_SPIN_PRESSEDUP | AFX_SPIN_PRESSEDDOWN)) - 1;
	BOOL bDisabled = nState & AFX_SPIN_DISABLED;

	for (int i = 0; i < 2; i ++)
	{
		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);

			if (idxPressed == i)
			{
				dm.DrawRect(rect[i], (COLORREF)-1, afxGlobalData.clrBarShadow);
			}
			else
			{
				dm.DrawRect(rect[i], (COLORREF)-1, afxGlobalData.clrBarHilite);
			}
		}
		else
		{
			if (idxPressed == i)
			{
				pDC->Draw3dRect(&rect[i], afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
			}
			else
			{
				pDC->Draw3dRect(&rect[i], afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
			}
		}

		CMenuImages::Draw(pDC, id[bOrientation ? 1 : 0][i], rect[i], bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
	}
}

void CMFCVisualManager::OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, colorBox, colorBox);

	rect.DeflateRect(2, 2);

	CPen penLine(PS_SOLID, 1, afxGlobalData.clrBarText);
	CPen* pOldPen = pDC->SelectObject(&penLine);

	CPoint ptCenter = rect.CenterPoint();

	pDC->MoveTo(rect.left, ptCenter.y);
	pDC->LineTo(rect.right, ptCenter.y);

	if (!bIsOpened)
	{
		pDC->MoveTo(ptCenter.x, rect.top);
		pDC->LineTo(ptCenter.x, rect.bottom);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManager::OnDrawControlBorder(CWnd* pWndCtrl)
{
	ASSERT_VALID(pWndCtrl);

	CWindowDC dc(pWndCtrl);

	CRect rect;
	pWndCtrl->GetWindowRect(rect);

	rect.bottom -= rect.top;
	rect.right -= rect.left;
	rect.left = rect.top = 0;

	if (pWndCtrl->GetStyle() & WS_POPUP)
	{
		dc.Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
	}
	else
	{
		dc.Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarHilite);
	}

	rect.DeflateRect(1, 1);
	dc.Draw3dRect(rect, afxGlobalData.clrWindow, afxGlobalData.clrWindow);
}

void CMFCVisualManager::OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE /*state*/)
{
	ASSERT_VALID(pDC);
	CMenuImages::Draw(pDC, CMenuImages::IdArrowShowAll, rect);
}

int CMFCVisualManager::GetShowAllMenuItemsHeight(CDC* /*pDC*/, const CSize& /*sizeDefault*/)
{
	return CMenuImages::Size().cy + 2 * AFX_TEXT_MARGIN;
}

void CMFCVisualManager::GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack,
	COLORREF& clrHighlight, COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack)
{
	ASSERT_VALID(pTabWnd);

	COLORREF clrActiveTab = pTabWnd->GetTabBkColor(pTabWnd->GetActiveTab());

	if (pTabWnd->IsOneNoteStyle() && clrActiveTab != (COLORREF)-1)
	{
		clrFace = clrActiveTab;
	}
	else if (pTabWnd->IsDialogControl())
	{
		clrFace = afxGlobalData.clrBtnFace;
	}
	else
	{
		clrFace = afxGlobalData.clrBarFace;
	}

	if (pTabWnd->IsDialogControl())
	{
		clrDark = afxGlobalData.clrBtnShadow;
		clrBlack = afxGlobalData.clrBtnText;
		clrHighlight = pTabWnd->IsVS2005Style() ? afxGlobalData.clrBtnShadow : afxGlobalData.clrBtnHilite;
		clrDarkShadow = afxGlobalData.clrBtnDkShadow;
		clrLight = afxGlobalData.clrBtnLight;

		pbrFace = &afxGlobalData.brBtnFace;
	}
	else
	{
		clrDark = afxGlobalData.clrBarShadow;
		clrBlack = afxGlobalData.clrBarText;
		clrHighlight = pTabWnd->IsVS2005Style() ? afxGlobalData.clrBarShadow : afxGlobalData.clrBarHilite;
		clrDarkShadow = afxGlobalData.clrBarDkShadow;
		clrLight = afxGlobalData.clrBarLight;

		pbrFace = &afxGlobalData.brBarFace;
	}

	pbrBlack = &afxGlobalData.brBlack;
}

void CMFCVisualManager::OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* /*pButton*/)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* /*pButton*/)
{
	ASSERT_VALID(pDC);

	COLORREF clr = afxGlobalData.clrBarShadow;
	COLORREF clrText = pDC->GetTextColor();

	if (rectBorderSize.left > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.top, rectBounds.left + rectBorderSize.left, rectBounds.bottom, clr);
	}
	if (rectBorderSize.top > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.top, rectBounds.right, rectBounds.top + rectBorderSize.top, clr);
	}
	if (rectBorderSize.right > 0)
	{
		pDC->FillSolidRect(rectBounds.right - rectBorderSize.right, rectBounds.top, rectBounds.right, rectBounds.bottom, clr);
	}
	if (rectBorderSize.bottom > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.bottom - rectBorderSize.bottom, rectBounds.right, rectBounds.bottom, clr);
	}

	pDC->SetTextColor(clrText);
}

COLORREF CMFCVisualManager::GetAutoHideButtonTextColor(CMFCAutoHideButton* /*pButton*/)
{
	return afxGlobalData.clrBarText;
}

void CMFCVisualManager::OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rectSplitter, &afxGlobalData.brBarFace);
	pDC->Draw3dRect(rectSplitter, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

void CMFCVisualManager::OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText)
{

	pDC->FillSolidRect(rectCaption, afxGlobalData.clrBarShadow);
	clrText = afxGlobalData.clrBarHilite;
}

BOOL CMFCVisualManager::OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* /*pEdit*/, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& /*clrText*/)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(&rect, &afxGlobalData.brBtnFace);

	CRect rectFrame = rect;
	rectFrame.InflateRect(0, 1, 1, 1);

	pDC->Draw3dRect(rectFrame, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnDkShadow);

	rectFrame.DeflateRect(1, 1);
	pDC->DrawEdge(rectFrame, state == ButtonsIsPressed ? BDR_SUNKENINNER : BDR_RAISEDINNER, BF_RECT);

	return TRUE;
}

void CMFCVisualManager::GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder)
{
	clrBaseGroupBackground = afxGlobalData.clrBarFace;
	clrBaseGroupBorder = afxGlobalData.clrBarShadow;
}

COLORREF CMFCVisualManager::GetSmartDockingHighlightToneColor()
{
	return afxGlobalData.clrActiveCaption;
}

void CMFCVisualManager::OnFillPopupWindowBackground(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawPopupWindowBorder(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarLight, afxGlobalData.clrBarDkShadow);
	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

COLORREF  CMFCVisualManager::OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* /*pPopupWnd*/)
{
	ASSERT_VALID(pDC);

	CBrush br(afxGlobalData.clrActiveCaption);
	pDC->FillRect(rectCaption, &br);

	// get the text color
	return afxGlobalData.clrCaptionText;
}

void CMFCVisualManager::OnErasePopupWindowButton(CDC* pDC, CRect rect, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsCaptionButton())
	{
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		return;
	}

	CRect rectParent;
	pButton->GetParent()->GetClientRect(rectParent);

	pButton->GetParent()->MapWindowPoints(pButton, rectParent);
	OnFillPopupWindowBackground(pDC, rectParent);
}

void CMFCVisualManager::OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rect, CMFCDesktopAlertWndButton* pButton)
{
	if (pButton->IsPressed())
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarLight);
		rect.DeflateRect(1, 1);
		pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
	else
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarLight, afxGlobalData.clrBarDkShadow);
		rect.DeflateRect(1, 1);
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}
}

void CMFCVisualManager::DoDrawHeaderSortArrow(CDC* pDC, CRect rectArrow, BOOL bIsUp, BOOL bDlgCtrl)
{
	CPen penLight(PS_SOLID, 1, bDlgCtrl ? afxGlobalData.clrBtnHilite : afxGlobalData.clrBarHilite);
	CPen penDark(PS_SOLID, 1, bDlgCtrl ? afxGlobalData.clrBtnDkShadow : afxGlobalData.clrBarDkShadow);

	CPen* pPenOld = pDC->SelectObject(&penLight);
	ASSERT_VALID(pPenOld);

	if (!bIsUp)
	{
		pDC->MoveTo(rectArrow.right, rectArrow.top);
		pDC->LineTo(rectArrow.CenterPoint().x, rectArrow.bottom);

		pDC->SelectObject(&penDark);
		pDC->LineTo(rectArrow.left, rectArrow.top);
		pDC->LineTo(rectArrow.right, rectArrow.top);
	}
	else
	{
		pDC->MoveTo(rectArrow.left, rectArrow.bottom);
		pDC->LineTo(rectArrow.right, rectArrow.bottom);
		pDC->LineTo(rectArrow.CenterPoint().x, rectArrow.top);

		pDC->SelectObject(&penDark);
		pDC->LineTo(rectArrow.left, rectArrow.bottom);
	}

	pDC->SelectObject(pPenOld);
}

COLORREF CMFCVisualManager::GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList)
{
	ASSERT_VALID(pPropList);

	return pPropList->DrawControlBarColors() ? afxGlobalData.clrBarFace : afxGlobalData.clrBtnFace;
}

COLORREF CMFCVisualManager::GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList)
{
	ASSERT_VALID(pPropList);

	return pPropList->DrawControlBarColors() ? afxGlobalData.clrBarDkShadow : afxGlobalData.clrBtnDkShadow;
}

COLORREF CMFCVisualManager::GetMenuItemTextColor(CMFCToolBarMenuButton* /*pButton*/, BOOL bHighlighted, BOOL bDisabled)
{
	if (bHighlighted)
	{
		return bDisabled ? afxGlobalData.clrBtnFace : afxGlobalData.clrTextHilite;
	}

	return bDisabled ? afxGlobalData.clrGrayedText : afxGlobalData.clrWindowText;
}

COLORREF CMFCVisualManager::GetStatusBarPaneTextColor(CMFCStatusBar* /*pStatusBar*/, CMFCStatusBarPaneInfo* pPane)
{
	ENSURE(pPane != NULL);

	return(pPane->nStyle & SBPS_DISABLED) ? afxGlobalData.clrGrayedText : pPane->clrText == (COLORREF)-1 ? afxGlobalData.clrBtnText : pPane->clrText;
}

void CMFCVisualManager::OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rect, CRect rectText)
{
	ASSERT_VALID(pBar);

	CWnd* pWnd = pBar->GetParent();
	ASSERT_VALID(pWnd);

	const BOOL bGlass = pBar->IsTransparentCaption();
	const DWORD dwStyleEx  = pWnd->GetExStyle();
	const BOOL bIsRTL = (dwStyleEx & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
	BOOL bTextCenter = TRUE;

	ASSERT_VALID(pDC);

	if ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ALL) == AFX_RIBBONBAR_HIDE_ALL)
	{
		HICON hIcon = afxGlobalUtils.GetWndIcon(pWnd);

		if (hIcon != NULL)
		{
			CSize szIcon(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));
			CRect rectIcon(rect.TopLeft(), CSize(min(::GetSystemMetrics(SM_CYCAPTION), rect.Height()), rect.Height()));

			long x = rect.left + max(0, (rectIcon.Width()  - szIcon.cx) / 2);
			long y = rect.top  + max(0, (rectIcon.Height() - szIcon.cy) / 2);

			::DrawIconEx(pDC->GetSafeHdc(), x, y, hIcon, szIcon.cx, szIcon.cy, 0, NULL, DI_NORMAL);

			if (rectText.left < rectIcon.right)
			{
				rectText.left = rectIcon.right;
			}
		}

		bTextCenter = TRUE;
	}

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
	ENSURE(pOldFont != NULL);

	int nOldMode = pDC->SetBkMode(TRANSPARENT);

	CString strCaption;
	pWnd->GetWindowText(strCaption);

	DWORD dwTextStyle = DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER | (bIsRTL ? DT_RTLREADING | DT_RIGHT : 0);

	COLORREF clrText = RGB(0, 0, 0);

	int widthFull = rectText.Width();
	int width = pDC->GetTextExtent(strCaption).cx;

	if (bTextCenter && width < widthFull)
	{
		rectText.left += (widthFull - width) / 2;
	}

	rectText.right = min(rectText.left + width, rectText.right);

	if (rectText.right > rectText.left)
	{
		if (bGlass)
		{
			DrawTextOnGlass(pDC, strCaption, rectText, dwTextStyle, 10);
		}
		else
		{
			COLORREF clrOldText = pDC->SetTextColor(clrText);
			pDC->DrawText(strCaption, rectText, dwTextStyle);
			pDC->SetTextColor(clrOldText);
		}
	}

	pDC->SetBkMode(nOldMode);
	pDC->SelectObject(pOldFont);
}

void CMFCVisualManager::OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	OnFillRibbonButton(pDC, pButton);

	CMenuImages::IMAGES_IDS imageID;

	switch(pButton->GetID())
	{
	case SC_CLOSE:
		imageID = CMenuImages::IdClose;
		break;

	case SC_MINIMIZE:
		imageID = CMenuImages::IdMinimize;
		break;

	case SC_MAXIMIZE:
		imageID = CMenuImages::IdMaximize;
		break;

	case SC_RESTORE:
		imageID = CMenuImages::IdRestore;
		break;

	default:
		return;
	}

	CMenuImages::Draw(pDC, imageID, pButton->GetRect(), pButton->IsDisabled() ? CMenuImages::ImageGray : CMenuImages::ImageBlack);

	OnDrawRibbonButtonBorder(pDC, pButton);
}

COLORREF CMFCVisualManager::OnDrawRibbonButtonsGroup(CDC* /*pDC*/, CMFCRibbonButtonsGroup* /*pGroup*/, CRect /*rectGroup*/)
{
	return(COLORREF)-1;
}

void CMFCVisualManager::OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled, BOOL /*bIsPressed*/, BOOL /*bIsHighlighted*/)
{
	ASSERT_VALID(pDC);

	CRect rectBullet(rectImage.CenterPoint(), CSize(1, 1));
	rectBullet.InflateRect(5, 5);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CBrush br(bIsDisabled ? afxGlobalData.clrGrayedText : RGB(0, 127, 0));

		CBrush* pOldBrush = (CBrush*) pDC->SelectObject(&br);
		CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);

		pDC->Ellipse(rectBullet);

		pDC->SelectObject(pOldBrush);
		pDC->SelectObject(pOldPen);
	}
	else
	{
		CDrawingManager dm(*pDC);

		dm.DrawEllipse(rectBullet, bIsDisabled ? afxGlobalData.clrGrayedText : RGB(160, 208, 128), bIsDisabled ? afxGlobalData.clrBtnShadow : RGB(71, 117, 44));
	}
}

void CMFCVisualManager::OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	const BOOL bIsHighlighted = pButton->IsHighlighted() || pButton->IsFocused();
	const BOOL bIsPressed = pButton->IsPressed() || pButton->IsDroppedDown();

	CRect rect = pButton->GetRect();
	rect.DeflateRect(2, 2);

	CDrawingManager dm(*pDC);

	dm.DrawEllipse(rect, bIsPressed ? afxGlobalData.clrBarLight : afxGlobalData.clrBarFace, bIsHighlighted ? afxGlobalData.clrBarDkShadow : afxGlobalData.clrBarShadow);
}

COLORREF CMFCVisualManager::OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* /*pWndRibbonBar*/, CRect rectTab)
{
	ASSERT_VALID(pDC);

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

	pDC->MoveTo(rectTab.left, rectTab.top);
	pDC->LineTo(rectTab.right, rectTab.top);

	pDC->SelectObject(pOldPen);

	return(COLORREF)-1;
}

void CMFCVisualManager::OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pCategory);

	const int nShadowSize = 2;

	rectCategory.right -= nShadowSize;
	rectCategory.bottom -= nShadowSize;

	pDC->FillRect(rectCategory, &afxGlobalData.brBarFace);

	CRect rectActiveTab = pCategory->GetTabRect();

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

	pDC->MoveTo(rectCategory.left, rectCategory.top);
	pDC->LineTo(rectActiveTab.left + 1, rectCategory.top);

	pDC->MoveTo(rectActiveTab.right - 2, rectCategory.top);
	pDC->LineTo(rectCategory.right, rectCategory.top);
	pDC->LineTo(rectCategory.right, rectCategory.bottom);
	pDC->LineTo(rectCategory.left, rectCategory.bottom);
	pDC->LineTo(rectCategory.left, rectCategory.top);

	pDC->SelectObject(pOldPen);

	CDrawingManager dm(*pDC);
	dm.DrawShadow(rectCategory, nShadowSize, 100, 75, NULL, NULL, m_clrMenuShadowBase);
}

void CMFCVisualManager::OnDrawRibbonCategoryScroll(CDC* pDC, CRibbonCategoryScroll* pScroll)
{
	ASSERT_VALID (pDC);
	ASSERT_VALID (pScroll);

	CRect rect = pScroll->GetRect();
	rect.bottom--;

	pDC->FillRect(rect, &afxGlobalData.brBarFace);
	if (pScroll->IsHighlighted())
	{
		CDrawingManager dm(*pDC);
		dm.HighlightRect(rect);
	}

	BOOL bIsLeft = pScroll->IsLeftScroll();
	if (afxGlobalData.m_bIsRTL)
	{
		bIsLeft = !bIsLeft;
	}

	CMenuImages::Draw(pDC,
		bIsLeft ? CMenuImages::IdArrowLeftLarge : CMenuImages::IdArrowRightLarge, 
		rect);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}

COLORREF CMFCVisualManager::OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTab);

	CMFCRibbonCategory* pCategory = pTab->GetParentCategory();
	ASSERT_VALID(pCategory);
	CMFCRibbonBar* pBar = pCategory->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	bIsActive = bIsActive && ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0 || pTab->GetDroppedDown() != NULL);

	const BOOL bIsFocused	= pTab->IsFocused() && (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS);
	const BOOL bIsHighlighted = (pTab->IsHighlighted() || bIsFocused) && !pTab->IsDroppedDown();

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

	CRect rectTab = pTab->GetRect();

	rectTab.top += 3;

	const int nTruncateRatio = pTab->GetParentCategory()->GetParentRibbonBar()->GetTabTruncateRatio();

	if (nTruncateRatio > 0)
	{
		const int nPercent = max(10, 100 - nTruncateRatio / 2);

		COLORREF color = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, nPercent);

		CPen penColor(PS_SOLID, 1, color);
		pDC->SelectObject(&penColor);

		pDC->MoveTo(rectTab.right - 1, rectTab.top);
		pDC->LineTo(rectTab.right - 1, rectTab.bottom);
	}

	if (!bIsActive && !bIsHighlighted)
	{
		pDC->SelectObject(pOldPen);
		return afxGlobalData.clrBarText;
	}

	rectTab.right -= 2;

#define AFX_POINTS_NUM 8
	POINT pts [AFX_POINTS_NUM];

	pts [0] = CPoint(rectTab.left, rectTab.bottom);
	pts [1] = CPoint(rectTab.left + 1, rectTab.bottom - 1);
	pts [2] = CPoint(rectTab.left + 1, rectTab.top + 2);
	pts [3] = CPoint(rectTab.left + 3, rectTab.top);
	pts [4] = CPoint(rectTab.right - 3, rectTab.top);
	pts [5] = CPoint(rectTab.right - 1, rectTab.top + 2);
	pts [6] = CPoint(rectTab.right - 1, rectTab.bottom - 1);
	pts [7] = CPoint(rectTab.right, rectTab.bottom);

	CRgn rgnClip;
	rgnClip.CreatePolygonRgn(pts, AFX_POINTS_NUM, WINDING);

	if (bIsActive)
	{
		pDC->SelectClipRgn(&rgnClip);

		COLORREF clrFill = pTab->IsSelected() ? afxGlobalData.clrBarHilite : RibbonCategoryColorToRGB(pTab->GetParentCategory()->GetTabColor());

		if (clrFill != (COLORREF)-1)
		{
			CBrush br(clrFill);
			pDC->FillRect(rectTab, &br);
		}
		else
		{
			pDC->FillRect(rectTab, bIsHighlighted ? &afxGlobalData.brWindow : &afxGlobalData.brBarFace);
		}

		pDC->SelectClipRgn(NULL);
	}

	pDC->Polyline(pts, AFX_POINTS_NUM);
	pDC->SelectObject(pOldPen);

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManager::OnDrawRibbonPanel(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectPanel, CRect /*rectCaption*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pPanel);

	COLORREF clrText = afxGlobalData.clrBarText;

	if (pPanel->IsCollapsed() && pPanel->GetDefaultButton().IsFocused())
	{
		pDC->FillRect(rectPanel, &afxGlobalData.brHilite);
		clrText = afxGlobalData.clrTextHilite;
	}
	else if (pPanel->IsHighlighted())
	{
		CDrawingManager dm(*pDC);
		dm.HighlightRect(rectPanel);
	}

	pDC->Draw3dRect(rectPanel, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
	rectPanel.OffsetRect(-1, -1);
	pDC->Draw3dRect(rectPanel, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	return clrText;
}

void CMFCVisualManager::OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pPanel);

	COLORREF clrTextOld = pDC->SetTextColor(pPanel->IsHighlighted() ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText);

	rectCaption.DeflateRect(1, 1);
	rectCaption.right -= 2;

	CBrush br(pPanel->IsHighlighted() ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption);
	pDC->FillRect(rectCaption, &br);

	CString str = pPanel->GetName();

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	if (pPanel->GetLaunchButton().GetID() > 0)
	{
		rectCaption.right = pPanel->GetLaunchButton().GetRect().left;
	}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	pDC->DrawText( str, rectCaption, DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX);

	pDC->SetTextColor(clrTextOld);
}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
void CMFCVisualManager::OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pPanel);

	OnFillRibbonButton(pDC, pButton);

	COLORREF clrText = pPanel->IsHighlighted() ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;

	CMenuImages::IMAGE_STATE imageState = CMenuImages::ImageBlack;

	if (pButton->IsDisabled())
	{
		imageState = CMenuImages::ImageGray;
	}
	else if (!pButton->IsHighlighted())
	{
		if (GetRValue(clrText) > 192 && GetGValue(clrText) > 192 && GetBValue(clrText) > 192)
		{
			imageState = CMenuImages::ImageWhite;
		}
		else
		{
			imageState = CMenuImages::ImageBlack;
		}
	}

	CMenuImages::Draw(pDC, CMenuImages::IdLaunchArrow, pButton->GetRect(), imageState);

	OnDrawRibbonButtonBorder(pDC, pButton);
}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

void CMFCVisualManager::OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsQATMode())
	{
		OnFillRibbonButton(pDC, pButton);
		OnDrawRibbonDefaultPaneButtonContext(pDC, pButton);
		OnDrawRibbonButtonBorder(pDC, pButton);
	}
	else
	{
		OnDrawRibbonDefaultPaneButtonContext(pDC, pButton);
	}
}

void CMFCVisualManager::OnDrawRibbonDefaultPaneButtonContext(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CRect rectMenuArrow = pButton->GetRect();;

	if (pButton->IsQATMode())
	{
		pButton->DrawImage(pDC, CMFCRibbonButton::RibbonImageSmall, pButton->GetRect());
		return;
	}

	CRect rectImage = pButton->GetRect();
	rectImage.top += 10;
	rectImage.bottom = rectImage.top + pButton->GetImageSize(CMFCRibbonButton::RibbonImageSmall).cy;

	pButton->DrawImage(pDC, CMFCRibbonButton::RibbonImageSmall, rectImage);

	// Draw text:
	pButton->DrawBottomText(pDC, FALSE);
}

void CMFCVisualManager::OnDrawRibbonDefaultPaneButtonIndicator(CDC* pDC, CMFCRibbonButton* /*pButton*/, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(pDC);

	rect.left = rect.right - rect.Height();
	rect.DeflateRect(1, 1);

	pDC->FillRect(rect, &afxGlobalData.brBarFace);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	CRect rectWhite = rect;
	rectWhite.OffsetRect(0, 1);

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectWhite, CMenuImages::ImageWhite);
	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, CMenuImages::ImageBlack);
}

COLORREF CMFCVisualManager::OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		COLORREF clrBorder = afxGlobalData.clrBarShadow;
		CRect rectCommand = pButton->GetCommandRect();

		CRect rect = pButton->GetRect();
		rect.left = rectCommand.left;

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, afxGlobalData.clrWindow, clrBorder);
		}
		else
		{
			if (pButton->IsDroppedDown() || pButton->IsHighlighted())
			{
				pDC->FillRect(rectCommand, &afxGlobalData.brWindow);
			}
			else
			{
				CDrawingManager dm(*pDC);
				dm.HighlightRect(rectCommand);
			}

			pDC->Draw3dRect(rect, clrBorder, clrBorder);
		}

		return(COLORREF)-1;
	}

	if (pButton->IsMenuMode() && !pButton->IsGalleryIcon())
	{
		if (pButton->IsHighlighted())
		{
			pDC->FillRect(pButton->GetRect(), &afxGlobalData.brHilite);
			return afxGlobalData.clrTextHilite;
		}
	}
	else
	{
		if (pButton->IsChecked() && !pButton->IsHighlighted())
		{
			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);
				dm.DrawRect(pButton->GetRect(), afxGlobalData.clrWindow, (COLORREF)-1);
			}
			else
			{
				CMFCToolBarImages::FillDitheredRect(pDC, pButton->GetRect());
			}
		}
	}

	return(COLORREF)-1;
}

COLORREF CMFCVisualManager::OnFillRibbonMainPanelButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	return OnFillRibbonButton(pDC, pButton);
}

void CMFCVisualManager::OnDrawRibbonMainPanelButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	OnDrawRibbonButtonBorder(pDC, pButton);
}

void CMFCVisualManager::OnFillRibbonEdit( CDC* pDC, CMFCRibbonRichEditCtrl* /*pEdit*/, CRect rect, BOOL bIsHighlighted,
	BOOL /*bIsPaneHighlighted*/, BOOL bIsDisabled, COLORREF& /*clrText*/, COLORREF& /*clrSelBackground*/, COLORREF& /*clrSelText*/)
{
	ASSERT_VALID(pDC);

	if (bIsHighlighted && !bIsDisabled)
	{
		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, afxGlobalData.clrWindow, (COLORREF)-1);
		}
		else
		{
			pDC->FillRect(rect, &afxGlobalData.brWindow);
		}
	}
	else
	{
		CDrawingManager dm(*pDC);

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			dm.DrawRect(rect, afxGlobalData.clrBarFace, (COLORREF)-1);
		}
		else
		{
			pDC->FillRect(rect, &afxGlobalData.brBarFace);
			dm.HighlightRect(rect);
		}
	}
}

void CMFCVisualManager::OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		return;
	}

	CRect rect = pButton->GetRect();

	if (pButton->IsMenuMode() && pButton->IsChecked() && !pButton->IsHighlighted())
	{
		return;
	}

	if (pButton->IsHighlighted() || pButton->IsChecked() || pButton->IsDroppedDown() || pButton->IsFocused())
	{
		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrBarShadow);
		}
		else
		{
			if (pButton->IsPressed() || pButton->IsChecked() || pButton->IsDroppedDown())
			{
				pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
			}
			else
			{
				pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
			}
		}

		CRect rectMenu = pButton->GetMenuRect();

		if (!rectMenu.IsRectEmpty())
		{
			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);

				if (pButton->IsMenuOnBottom())
				{
					dm.DrawLine(rectMenu.left, rectMenu.top, rectMenu.right, rectMenu.top, afxGlobalData.clrBarShadow);
				}
				else
				{
					dm.DrawLine(rectMenu.left, rectMenu.top, rectMenu.left, rectMenu.bottom, afxGlobalData.clrBarShadow);
				}
			}
			else
			{
				CPen* pOldPen = pDC->SelectObject(&afxGlobalData.penBarShadow);
				ENSURE(pOldPen != NULL);

				if (pButton->IsMenuOnBottom())
				{
					pDC->MoveTo(rectMenu.left, rectMenu.top);
					pDC->LineTo(rectMenu.right, rectMenu.top);
				}
				else
				{
					pDC->MoveTo(rectMenu.left, rectMenu.top);
					pDC->LineTo(rectMenu.left, rectMenu.bottom);
				}

				pDC->SelectObject(pOldPen);
			}
		}
	}
}

void CMFCVisualManager::OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* /*pButton*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBtnFace);

	pDC->Draw3dRect(rect, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);
}

void CMFCVisualManager::OnDrawRibbonMainPanelFrame(CDC* pDC, CMFCRibbonMainPanel* /*pPanel*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
	rect.InflateRect(1, 1);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
}

void CMFCVisualManager::OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* /*pPanel*/, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brWindow);
}

void CMFCVisualManager::OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* /*pPanel*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &afxGlobalData.brBtnFace);

	CRect rectSeparator = rect;
	rectSeparator.right = rectSeparator.left + 2;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);
}

void CMFCVisualManager::OnDrawRibbonLabel(CDC* /*pDC*/, CMFCRibbonLabel* /*pLabel*/, CRect /*rect*/)
{
}

void CMFCVisualManager::OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	OnFillRibbonButton(pDC, pButton);
	OnDrawRibbonButtonBorder(pDC, pButton);
}

void CMFCVisualManager::OnDrawRibbonGalleryBorder(CDC* pDC, CMFCRibbonGallery* /*pButton*/, CRect rectBorder)
{
	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}

COLORREF CMFCVisualManager::RibbonCategoryColorToRGB(AFX_RibbonCategoryColor color)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		switch(color)
		{
		case AFX_CategoryColor_Red:
			return RGB(255, 0, 0);

		case AFX_CategoryColor_Orange:
			return RGB(255, 128, 0);

		case AFX_CategoryColor_Yellow:
			return RGB(255, 255, 0);

		case AFX_CategoryColor_Green:
			return RGB(0, 255, 0);

		case AFX_CategoryColor_Blue:
			return RGB(0, 0, 255);

		case AFX_CategoryColor_Indigo:
			return RGB(0, 0, 128);

		case AFX_CategoryColor_Violet:
			return RGB(255, 0, 255);
		}

		return(COLORREF)-1;
	}

	switch(color)
	{
	case AFX_CategoryColor_Red:
		return RGB(255, 160, 160);

	case AFX_CategoryColor_Orange:
		return RGB(239, 189, 55);

	case AFX_CategoryColor_Yellow:
		return RGB(253, 229, 27);

	case AFX_CategoryColor_Green:
		return RGB(113, 190, 89);

	case AFX_CategoryColor_Blue:
		return RGB(128, 181, 196);

	case AFX_CategoryColor_Indigo:
		return RGB(114, 163, 224);

	case AFX_CategoryColor_Violet:
		return RGB(214, 178, 209);
	}

	return(COLORREF)-1;
}

COLORREF CMFCVisualManager::OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pContextCaption);

	COLORREF clrFill = RibbonCategoryColorToRGB(pContextCaption->GetColor());
	CRect rect = pContextCaption->GetRect();

	if (clrFill != (COLORREF)-1)
	{
		CBrush br(clrFill);
		pDC->FillRect(rect, &br);
	}

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManager::OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* /*pBar*/, CMFCRibbonStatusBarPane* pPane)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pPane);

	CRect rect = pPane->GetRect();

	if (pPane->IsHighlighted())
	{
		CRect rectButton = rect;
		rectButton.DeflateRect(1, 1);

		pDC->Draw3dRect(rectButton, pPane->IsPressed() ? afxGlobalData.clrBarShadow : afxGlobalData.clrBarHilite, pPane->IsPressed() ? afxGlobalData.clrBarHilite : afxGlobalData.clrBarShadow);
	}

	return(COLORREF)-1;
}

void CMFCVisualManager::GetRibbonSliderColors(CMFCRibbonSlider* /*pSlider*/, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled, COLORREF& clrLine, COLORREF& clrFill)
{
	clrLine = bIsDisabled ? afxGlobalData.clrBarShadow : afxGlobalData.clrBarDkShadow;
	clrFill = bIsPressed && bIsHighlighted ? afxGlobalData.clrBarShadow :
	bIsHighlighted ? afxGlobalData.clrBarHilite : afxGlobalData.clrBarFace;
}

void CMFCVisualManager::OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	ASSERT_VALID(pDC);

	COLORREF clrLine;
	COLORREF clrFill;

	GetRibbonSliderColors(pSlider, bIsHighlighted, bIsPressed, bIsDisabled, clrLine, clrFill);

	CPoint ptCenter = rect.CenterPoint();
	CRect rectCircle(CPoint(ptCenter.x - 7, ptCenter.y - 7), CSize(15, 15));
	CDrawingManager dm(*pDC);

	dm.DrawEllipse(rectCircle, clrFill, clrLine);

	// Draw +/- sign:
	CRect rectSign(CPoint(ptCenter.x - 3, ptCenter.y - 3), CSize(7, 7));

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		dm.DrawLine(rectSign.left, ptCenter.y, rectSign.right, ptCenter.y, clrLine);

		if (!bIsZoomOut)
		{
			dm.DrawLine(ptCenter.x, rectSign.top, ptCenter.x, rectSign.bottom, clrLine);
		}
	}
	else
	{
		CPen penLine(PS_SOLID, 1, clrLine);
		CPen* pOldPen = pDC->SelectObject(&penLine);

		pDC->MoveTo(rectSign.left, ptCenter.y);
		pDC->LineTo(rectSign.right, ptCenter.y);

		if (!bIsZoomOut)
		{
			pDC->MoveTo(ptCenter.x, rectSign.top);
			pDC->LineTo(ptCenter.x, rectSign.bottom);
		}

		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManager::OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* /*pSlider*/, CRect rect)
{
	ASSERT_VALID(pDC);

	rect.InflateRect(0, 1);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrBarShadow);
	}
	else
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
}

void CMFCVisualManager::OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	ASSERT_VALID(pDC);

	COLORREF clrLine;
	COLORREF clrFill;

	GetRibbonSliderColors(pSlider, bIsHighlighted, bIsPressed, bIsDisabled, clrLine, clrFill);

	rect.DeflateRect(1, 2);

	rect.top = rect.CenterPoint().y - rect.Width();
	rect.bottom = rect.top + 2 * rect.Width();

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, clrFill, clrLine);
	}
	else
	{
		CPen penLine(PS_SOLID, 1, clrLine);
		CPen* pOldPen = pDC->SelectObject(&penLine);

		CBrush br(clrFill);
		CBrush* pOldBrush = pDC->SelectObject(&br);

		POINT pts [5] =
		{
			{ rect.left, rect.top },
			{ rect.left, rect.bottom - rect.Width() / 2 },
			{ rect.left + rect.Width() / 2, rect.bottom },
			{ rect.right, rect.bottom - rect.Width() / 2 },
			{ rect.right, rect.top },
		};

		pDC->Polygon(pts, 5);

		pDC->SelectObject(pOldPen);
		pDC->SelectObject(pOldBrush);
	}
}

void CMFCVisualManager::OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* /*pProgress*/, CRect rectProgress, CRect rectChunk, BOOL /*bInfiniteMode*/)
{
	ASSERT_VALID(pDC);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);

		if (!rectChunk.IsRectEmpty())
		{
			dm.DrawRect(rectChunk, afxGlobalData.clrHilite, (COLORREF)-1);
		}

		dm.DrawRect(rectProgress, (COLORREF)-1, afxGlobalData.clrBarShadow);
	}
	else
	{
		if (!rectChunk.IsRectEmpty())
		{
			pDC->FillRect(rectChunk, &afxGlobalData.brHilite);
		}

		pDC->Draw3dRect(rectProgress, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
}

void CMFCVisualManager::OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* /*pMenuBar*/, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brBarFace);
}

void CMFCVisualManager::OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* /*pSeparator*/, CRect rect)
{
	ASSERT_VALID(pDC);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrBtnShadow);
	}
	else
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
}

void CMFCVisualManager::OnDrawRibbonKeyTip(CDC* pDC, CMFCRibbonBaseElement* pElement, CRect rect, CString str)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pElement);

	::FillRect(pDC->GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_INFOBK));

	str.MakeUpper();

	COLORREF clrTextOld = pDC->SetTextColor( pElement->IsDisabled() ? afxGlobalData.clrGrayedText : ::GetSysColor(COLOR_INFOTEXT));

	pDC->DrawText(str, rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);

	pDC->SetTextColor(clrTextOld);

	pDC->Draw3dRect(rect, ::GetSysColor(COLOR_INFOTEXT), ::GetSysColor(COLOR_INFOTEXT));
}

void CMFCVisualManager::OnDrawRibbonCheckBoxOnList(CDC* pDC, CMFCRibbonCheckBox* /*pCheckBox*/, CRect rect, BOOL /*bIsSelected*/, BOOL /*bHighlighted*/)
{
	ASSERT_VALID(pDC);

	rect.OffsetRect(1, 1);
	CMenuImages::Draw(pDC, CMenuImages::IdCheck, rect, CMenuImages::ImageWhite);

	rect.OffsetRect(-1, -1);
	CMenuImages::Draw(pDC, CMenuImages::IdCheck, rect, CMenuImages::ImageBlack);
}

COLORREF CMFCVisualManager::GetRibbonHyperlinkTextColor(CMFCRibbonLinkCtrl* pHyperLink)
{
	ASSERT_VALID(pHyperLink);

	if (pHyperLink->IsDisabled())
	{
		return GetToolbarDisabledTextColor();
	}

	return pHyperLink->IsHighlighted() ? afxGlobalData.clrHotLinkHoveredText : afxGlobalData.clrHotLinkNormalText;
}

COLORREF CMFCVisualManager::GetRibbonStatusBarTextColor(CMFCRibbonStatusBar* /*pStatusBar*/)
{
	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManager::GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* /*pEdit*/, BOOL bIsHighlighted, BOOL /*bIsPaneHighlighted*/, BOOL bIsDisabled)
{
	return (bIsHighlighted && !bIsDisabled) ? afxGlobalData.clrWindow : afxGlobalData.clrBarFace;
}

void CMFCVisualManager::OnDrawRibbonColorPaletteBox(CDC* pDC, CMFCRibbonColorButton* /*pColorButton*/, CMFCRibbonGalleryIcon* /*pIcon*/,
	COLORREF color, CRect rect, BOOL bDrawTopEdge, BOOL bDrawBottomEdge, BOOL bIsHighlighted, BOOL bIsChecked, BOOL /*bIsDisabled*/)
{
	ASSERT_VALID(pDC);

	CRect rectFill = rect;
	rectFill.DeflateRect(1, 0);

	if (bIsHighlighted || bIsChecked)
	{
		CMFCToolBarImages::FillDitheredRect(pDC, rect);
		rectFill.DeflateRect(1, 2);
	}

	if (color != (COLORREF)-1)
	{
		CBrush br(color);
		pDC->FillRect(rectFill, &br);
	}

	COLORREF clrBorder = afxGlobalData.clrBtnShadow;

	if (bDrawTopEdge && bDrawBottomEdge)
	{
		pDC->Draw3dRect(rect, clrBorder, clrBorder);
	}
	else
	{
		CPen penBorder(PS_SOLID, 1, clrBorder);

		CPen* pOldPen = pDC->SelectObject(&penBorder);
		ENSURE(pOldPen != NULL);

		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.left, rect.bottom);

		pDC->MoveTo(rect.right - 1, rect.top);
		pDC->LineTo(rect.right - 1, rect.bottom);

		if (bDrawTopEdge)
		{
			pDC->MoveTo(rect.left, rect.top);
			pDC->LineTo(rect.right, rect.top);
		}

		if (bDrawBottomEdge)
		{
			pDC->MoveTo(rect.left, rect.bottom - 1);
			pDC->LineTo(rect.right, rect.bottom - 1);
		}

		pDC->SelectObject(pOldPen);
	}

	if (bIsHighlighted)
	{
		pDC->Draw3dRect(&rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
	}
	else if (bIsChecked)
	{
		pDC->Draw3dRect(&rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
	}
}

BOOL CMFCVisualManager::OnSetWindowRegion(CWnd* pWnd, CSize sizeWindow)
{
	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		return FALSE;
	}

	ASSERT_VALID(pWnd);

	CMFCRibbonBar* pRibbonBar = NULL;

	if (pWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		pRibbonBar = ((CFrameWndEx*) pWnd)->GetRibbonBar();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		pRibbonBar = ((CMDIFrameWndEx*) pWnd)->GetRibbonBar();
	}

	if (pRibbonBar == NULL || !pRibbonBar->IsWindowVisible() || !pRibbonBar->IsReplaceFrameCaption())
	{
		return FALSE;
	}

	const int nLeftRadius  = 11;
	const int nRightRadius = 11;

	CRgn rgnWnd;
	rgnWnd.CreateRectRgn(0, 0, sizeWindow.cx, sizeWindow.cy);

	CRgn rgnTemp;

	rgnTemp.CreateRectRgn(0, 0, nLeftRadius / 2, nLeftRadius / 2);
	rgnWnd.CombineRgn(&rgnTemp, &rgnWnd, RGN_XOR);

	rgnTemp.DeleteObject();
	rgnTemp.CreateEllipticRgn(0, 0, nLeftRadius, nLeftRadius);
	rgnWnd.CombineRgn(&rgnTemp, &rgnWnd, RGN_OR);

	rgnTemp.DeleteObject();
	rgnTemp.CreateRectRgn(sizeWindow.cx - nRightRadius / 2, 0, sizeWindow.cx, nRightRadius / 2);
	rgnWnd.CombineRgn(&rgnTemp, &rgnWnd, RGN_XOR);

	rgnTemp.DeleteObject();
	rgnTemp.CreateEllipticRgn(sizeWindow.cx - nRightRadius + 1, 0, sizeWindow.cx + 1, nRightRadius);
	rgnWnd.CombineRgn(&rgnTemp, &rgnWnd, RGN_OR);

	pWnd->SetWindowRgn((HRGN)rgnWnd.Detach(), TRUE);
	return TRUE;
}

BOOL CMFCVisualManager::OnNcPaint(CWnd* /*pWnd*/, const CObList& /*lstSysButtons*/, CRect /*rectRedraw*/)
{
	return FALSE;
}

void CMFCVisualManager::OnActivateApp(CWnd* /*pWnd*/, BOOL /*bActive*/)
{
}

BOOL CMFCVisualManager::OnNcActivate(CWnd* /*pWnd*/, BOOL /*bActive*/)
{
	return FALSE;
}

CSize CMFCVisualManager::GetNcBtnSize(BOOL /*bSmall*/) const
{
	return CSize(0, 0);
}

BOOL CMFCVisualManager::OnEraseMDIClientArea(CDC* /*pDC*/, CRect /*rectClient*/)
{
	return FALSE;
}

BOOL CMFCVisualManager::GetToolTipInfo(CMFCToolTipInfo& params, UINT /*nType*/ /*= (UINT)(-1)*/)
{
	CMFCToolTipInfo dummy;
	params = dummy;

	return TRUE;
}

BOOL CMFCVisualManager::DrawTextOnGlass(CDC* pDC, CString strText, CRect rect, DWORD dwFlags, int nGlowSize, COLORREF clrText)
{
	ASSERT_VALID(pDC);

	COLORREF clrOldText = pDC->GetTextColor();
	pDC->SetTextColor(RGB(0, 0, 0));

	BOOL bRes = afxGlobalData.DrawTextOnGlass(m_hThemeButton, pDC, 0, 0, strText, rect, dwFlags, nGlowSize, clrText);

	pDC->SetTextColor(clrOldText);

	return bRes;
}

COLORREF CMFCVisualManager::OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* /*pParent*/, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected)
{
	ASSERT_VALID(pDC);

	COLORREF clrText = (COLORREF)-1;

	if (bIsSelected)
	{
		pDC->FillRect(rect, &afxGlobalData.brHilite);
		clrText = afxGlobalData.clrTextHilite;
	}

	if (bIsHighlihted)
	{
		pDC->DrawFocusRect(rect);
	}

	return clrText;
}

/////////////////////////////////////////////////////////////////////////////////////
// CMFCBaseVisualManager

CMFCBaseVisualManager::CMFCBaseVisualManager()
{
	m_hThemeWindow = NULL;
	m_hThemeToolBar = NULL;
	m_hThemeButton = NULL;
	m_hThemeStatusBar = NULL;
	m_hThemeRebar = NULL;
	m_hThemeComboBox = NULL;
	m_hThemeProgress = NULL;
	m_hThemeHeader = NULL;
	m_hThemeScrollBar = NULL;
	m_hThemeExplorerBar = NULL;
	m_hThemeTree = NULL;
	m_hThemeStartPanel = NULL;
	m_hThemeTaskBand = NULL;
	m_hThemeTaskBar = NULL;
	m_hThemeSpin = NULL;
	m_hThemeTab = NULL;
	m_hThemeTrack = NULL;
	m_hThemeMenu = NULL;

	m_hinstUXDLL = ::AfxCtxLoadLibraryW(L"UxTheme.dll");

	if (m_hinstUXDLL != NULL)
	{
		m_pfOpenThemeData = (OPENTHEMEDATA)::GetProcAddress(m_hinstUXDLL, "OpenThemeData");
		m_pfCloseThemeData = (CLOSETHEMEDATA)::GetProcAddress(m_hinstUXDLL, "CloseThemeData");
		m_pfDrawThemeBackground = (DRAWTHEMEBACKGROUND)::GetProcAddress(m_hinstUXDLL, "DrawThemeBackground");
		m_pfGetThemeColor = (GETTHEMECOLOR)::GetProcAddress(m_hinstUXDLL, "GetThemeColor");
		m_pfGetThemeSysColor = (GETTHEMESYSCOLOR)::GetProcAddress(m_hinstUXDLL, "GetThemeSysColor");
		m_pfGetCurrentThemeName = (GETCURRENTTHEMENAME)::GetProcAddress(m_hinstUXDLL, "GetCurrentThemeName");
		m_pfGetWindowTheme = (GETWINDOWTHEME)::GetProcAddress(m_hinstUXDLL, "GetWindowTheme");

		UpdateSystemColors();
	}
	else
	{
		m_pfOpenThemeData = NULL;
		m_pfCloseThemeData = NULL;
		m_pfDrawThemeBackground = NULL;
		m_pfGetThemeColor = NULL;
		m_pfGetThemeSysColor = NULL;
		m_pfGetCurrentThemeName = NULL;
		m_pfGetWindowTheme = NULL;
	}
}

CMFCBaseVisualManager::~CMFCBaseVisualManager()
{
	if (m_hinstUXDLL != NULL)
	{
		CleanUpThemes();
		::FreeLibrary(m_hinstUXDLL);
	}
}

void CMFCBaseVisualManager::UpdateSystemColors()
{
	if (m_hinstUXDLL != NULL)
	{
		CleanUpThemes();

		if (m_pfOpenThemeData == NULL ||
			m_pfCloseThemeData == NULL ||
			m_pfDrawThemeBackground == NULL)
		{
			ASSERT(FALSE);
		}
		else
		{
			m_hThemeWindow = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"WINDOW");
			m_hThemeToolBar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TOOLBAR");
			m_hThemeButton = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"BUTTON");
			m_hThemeStatusBar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"STATUS");
			m_hThemeRebar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"REBAR");
			m_hThemeComboBox = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"COMBOBOX");
			m_hThemeProgress = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"PROGRESS");
			m_hThemeHeader = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"HEADER");
			m_hThemeScrollBar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"SCROLLBAR");
			m_hThemeExplorerBar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"EXPLORERBAR");
			m_hThemeTree = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TREEVIEW");
			m_hThemeStartPanel = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"STARTPANEL");
			m_hThemeTaskBand = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TASKBAND");
			m_hThemeTaskBar = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TASKBAR");
			m_hThemeSpin = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"SPIN");
			m_hThemeTab = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TAB");
			m_hThemeTrack = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd(), L"TRACKBAR");
			m_hThemeMenu = (*m_pfOpenThemeData)(AfxGetMainWnd()->GetSafeHwnd (), L"MENU");
		}
	}
}

void CMFCBaseVisualManager::CleanUpThemes()
{
	if (m_pfCloseThemeData == NULL)
	{
		return;
	}

	if (m_hThemeWindow != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeWindow);
	}

	if (m_hThemeToolBar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeToolBar);
	}

	if (m_hThemeRebar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeRebar);
	}

	if (m_hThemeStatusBar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeStatusBar);
	}

	if (m_hThemeButton != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeButton);
	}

	if (m_hThemeComboBox != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeComboBox);
	}

	if (m_hThemeProgress != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeProgress);
	}

	if (m_hThemeHeader != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeHeader);
	}

	if (m_hThemeScrollBar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeScrollBar);
	}

	if (m_hThemeExplorerBar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeExplorerBar);
	}

	if (m_hThemeTree != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeTree);
	}

	if (m_hThemeStartPanel != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeStartPanel);
	}

	if (m_hThemeTaskBand != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeTaskBand);
	}

	if (m_hThemeTaskBar != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeTaskBar);
	}

	if (m_hThemeSpin != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeSpin);
	}

	if (m_hThemeTab != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeTab);
	}

	if (m_hThemeTrack != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeTrack);
	}

	if (m_hThemeMenu != NULL)
	{
		(*m_pfCloseThemeData)(m_hThemeMenu);
	}
}

BOOL CMFCBaseVisualManager::DrawPushButton(CDC* pDC, CRect rect, CMFCButton* pButton, UINT /*uiState*/)
{
	if (m_hThemeButton == NULL)
	{
		return FALSE;
	}

	int nState = PBS_NORMAL;

	if (!pButton->IsWindowEnabled())
	{
		nState = PBS_DISABLED;
	}
	else if (pButton->IsPressed() || pButton->GetCheck())
	{
		nState = PBS_PRESSED;
	}
	else if (pButton->IsHighlighted())
	{
		nState = PBS_HOT;
	}
	else if (CWnd::GetFocus() == pButton)
	{
		nState = PBS_DEFAULTED;
	}

	pButton->OnDrawParentBackground(pDC, rect);

	if (m_pfDrawThemeBackground)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_PUSHBUTTON, nState, &rect, 0);
	}

	return TRUE;
}

BOOL CMFCBaseVisualManager::DrawStatusBarProgress(CDC* pDC, CMFCStatusBar* /*pStatusBar*/, CRect rectProgress, int nProgressTotal,
	int nProgressCurr, COLORREF /*clrBar*/, COLORREF /*clrProgressBarDest*/, COLORREF /*clrProgressText*/, BOOL bProgressText)
{
	if (m_hThemeProgress == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pDC);

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_BAR, 0, &rectProgress, 0);
	}

	if (nProgressTotal == 0)
	{
		return TRUE;
	}

	CRect rectComplete = rectProgress;
	rectComplete.DeflateRect(3, 3);

	rectComplete.right = rectComplete.left + nProgressCurr * rectComplete.Width() / nProgressTotal;

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_CHUNK, 0, &rectComplete, 0);
	}

	if (bProgressText)
	{
		CString strText;
		strText.Format(_T("%d%%"), nProgressCurr * 100 / nProgressTotal);

		COLORREF clrText = pDC->SetTextColor(afxGlobalData.clrBtnText);
		pDC->DrawText(strText, rectProgress, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
		pDC->SetTextColor(clrText);
	}

	return TRUE;
}

BOOL CMFCBaseVisualManager::DrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted)
{
	if (m_hThemeComboBox == NULL)
	{
		return FALSE;
	}

	int nState = bDisabled ? CBXS_DISABLED : bIsDropped ? CBXS_PRESSED : bIsHighlighted ? CBXS_HOT : CBXS_NORMAL;
	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeComboBox, pDC->GetSafeHdc(), CP_DROPDOWNBUTTON, nState, &rect, 0);
	}
	return TRUE;
}

BOOL CMFCBaseVisualManager::DrawComboBorder(CDC* pDC, CRect rect, BOOL /*bDisabled*/, BOOL bIsDropped, BOOL bIsHighlighted)
{
	ASSERT_VALID(pDC);

	if (m_hThemeWindow == NULL)
	{
		return FALSE;
	}

	if (bIsHighlighted || bIsDropped)
	{
		rect.DeflateRect(1, 1);
		pDC->Draw3dRect(&rect,  afxGlobalData.clrHilite, afxGlobalData.clrHilite);
	}

	return TRUE;
}

void CMFCBaseVisualManager::FillReBarPane(CDC* pDC, CBasePane* pBar, CRect rectClient)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (m_pfDrawThemeBackground == NULL || m_hThemeRebar == NULL)
	{
		pDC->FillRect(rectClient, &afxGlobalData.brBarFace);
		return;
	}

	CWnd* pWndParent = AFXGetParentFrame(pBar);
	if (pWndParent->GetSafeHwnd() == NULL)
	{
		pWndParent = pBar->GetParent();
	}

	ASSERT_VALID(pWndParent);

	CRect rectParent;
	pWndParent->GetWindowRect(rectParent);

	pBar->ScreenToClient(&rectParent);

	rectClient.right = max(rectClient.right, rectParent.right);
	rectClient.bottom = max(rectClient.bottom, rectParent.bottom);

	if (!pBar->IsFloating() && pBar->GetParentMiniFrame() == NULL)
	{
		rectClient.left = rectParent.left;
		rectClient.top = rectParent.top;

		if (!pBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			CFrameWnd* pMainFrame = AFXGetTopLevelFrame(pWndParent);
			if (pMainFrame->GetSafeHwnd() != NULL)
			{
				CRect rectMain;
				pMainFrame->GetClientRect(rectMain);
				pMainFrame->MapWindowPoints(pBar, &rectMain);

				rectClient.top = rectMain.top;
			}
		}
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeRebar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
	}
}

BOOL CMFCBaseVisualManager::DrawCheckBox(CDC *pDC, CRect rect, BOOL bHighlighted, int nState, BOOL bEnabled, BOOL bPressed)
{
	if (m_hThemeButton == NULL)
	{
		return FALSE;
	}

	nState = max(0, nState);
	nState = min(2, nState);

	ASSERT_VALID(pDC);

	int nDrawState = nState == 1 ? CBS_CHECKEDNORMAL : nState == 2 ? CBS_MIXEDNORMAL : CBS_UNCHECKEDNORMAL;

	if (!bEnabled)
	{
		nDrawState = nState == 1 ? CBS_CHECKEDDISABLED : nState == 2 ? CBS_MIXEDDISABLED : CBS_UNCHECKEDDISABLED;
	}
	else if (bPressed)
	{
		nDrawState = nState == 1 ? CBS_CHECKEDPRESSED : nState == 2 ? CBS_MIXEDPRESSED : CBS_UNCHECKEDPRESSED;
	}
	else if (bHighlighted)
	{
		nDrawState = nState == 1 ? CBS_CHECKEDHOT : nState == 2 ? CBS_MIXEDHOT : CBS_UNCHECKEDHOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_CHECKBOX, nDrawState, &rect, 0);
	}

	return TRUE;
}

BOOL CMFCBaseVisualManager::DrawRadioButton(CDC *pDC, CRect rect, BOOL bHighlighted, BOOL bChecked, BOOL bEnabled, BOOL bPressed)
{
/*	#define RBS_UNCHECKEDNORMAL 1
	#define RBS_UNCHECKEDHOT 2
	#define RBS_UNCHECKEDPRESSED 3
	#define RBS_UNCHECKEDDISABLED 4
	#define RBS_CHECKEDNORMAL 5
	#define RBS_CHECKEDHOT 6
	#define RBS_CHECKEDPRESSED 7
	#define RBS_CHECKEDDISABLED 8

	#define BP_RADIOBUTTON 2	*/

	if (m_hThemeButton == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pDC);

	int nDrawState = bChecked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;

	if (!bEnabled)
	{
		nDrawState = bChecked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
	}
	else if (bPressed)
	{
		nDrawState = bChecked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
	}
	else if (bHighlighted)
	{
		nDrawState = bChecked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_RADIOBUTTON, nDrawState, &rect, 0);
	}

	return TRUE;
}

CMFCBaseVisualManager::WinXpTheme CMFCBaseVisualManager::GetStandardWindowsTheme()
{
	WCHAR szName [256] = L"";
	WCHAR szColor [256] = L"";

	if (m_pfGetCurrentThemeName == NULL || (*m_pfGetCurrentThemeName)(szName, 255, szColor, 255, NULL, 0) != S_OK)
	{
		return WinXpTheme_None;
	}

	CString strThemeName = szName;
	CString strWinXPThemeColor = szColor;

	TCHAR fname[_MAX_FNAME];
	_tsplitpath_s(strThemeName, NULL, 0, NULL, 0, fname, _MAX_FNAME, NULL, 0);

	strThemeName = fname;

	if (strThemeName.CompareNoCase(_T("Luna")) != 0 && 
		strThemeName.CompareNoCase (_T("Aero")) != 0)
	{
		return WinXpTheme_NonStandard;
	}

	// Check for 3-d party visual managers:
	if (m_pfGetThemeColor != NULL && m_hThemeButton != NULL)
	{
		COLORREF clrTest = 0;
		if ((*m_pfGetThemeColor)(m_hThemeButton, 1, 0, 3823, &clrTest) != S_OK || clrTest == 1)
		{
			return WinXpTheme_NonStandard;
		}
	}

	if (strWinXPThemeColor.CompareNoCase(_T("normalcolor")) == 0)
	{
		return WinXpTheme_Blue;
	}

	if (strWinXPThemeColor.CompareNoCase(_T("homestead")) == 0)
	{
		return WinXpTheme_Olive;
	}

	if (strWinXPThemeColor.CompareNoCase(_T("metallic")) == 0)
	{
		// Check for Royale theme:
		CString strThemeLower = szName;
		strThemeLower.MakeLower();

		if (strThemeLower.Find(_T("royale")) >= 0)
		{
			return WinXpTheme_NonStandard;
		}

		return WinXpTheme_Silver;
	}

	return WinXpTheme_NonStandard;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxusertoolsmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxusertoolsmanager.h"
#include "afxtoolbar.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"

#include "afxribbonres.h"

static const CString strUserToolsProfile = _T("UserToolsManager");
static const CString strUserToolsEntry = _T("Tools");

CUserToolsManager* afxUserToolsManager = NULL;
extern CObList afxAllToolBars;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CUserToolsManager::CUserToolsManager() :
	m_uiCmdToolsDummy(0), m_uiCmdFirst(0), m_uiCmdLast(0), m_pToolRTC(NULL), m_uiArgumentsMenuID(0), m_uiInitialDirMenuID(0)
{
	ENSURE(afxUserToolsManager == NULL);
	afxUserToolsManager = this;
}

CUserToolsManager::CUserToolsManager(const UINT uiCmdToolsDummy, const UINT uiCmdFirst, const UINT uiCmdLast, CRuntimeClass* pToolRTC, UINT uArgMenuID, UINT uInitDirMenuID) :
	m_uiCmdToolsDummy(uiCmdToolsDummy), m_uiCmdFirst(uiCmdFirst), m_uiCmdLast(uiCmdLast), m_pToolRTC(pToolRTC), m_uiArgumentsMenuID(uArgMenuID), m_uiInitialDirMenuID(uInitDirMenuID)
{
	ENSURE(afxUserToolsManager == NULL);
	afxUserToolsManager = this;

	ENSURE(m_pToolRTC != NULL);
	ENSURE(m_pToolRTC->IsDerivedFrom(RUNTIME_CLASS(CUserTool)));

	ENSURE(m_uiCmdFirst <= m_uiCmdLast);

	//---------------------
	// Load default filter:
	//---------------------
	ENSURE(m_strFilter.LoadString(IDS_AFXBARRES_CMD_FILTER));

	m_strDefExt = _T("exe");
}

CUserToolsManager::~CUserToolsManager()
{
	while (!m_lstUserTools.IsEmpty())
	{
		delete m_lstUserTools.RemoveHead();
	}

	afxUserToolsManager = NULL;
}

BOOL CUserToolsManager::LoadState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strUserToolsProfile, lpszProfileName);

	while (!m_lstUserTools.IsEmpty())
	{
		delete m_lstUserTools.RemoveHead();
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.Open(strProfileName))
	{
		return FALSE;
	}

	if (!reg.Read(strUserToolsEntry, m_lstUserTools))
	{
		//---------------------------------------------------------
		// Tools objects may be corrupted, so, I don't delete them.
		// Memory leak is possible!
		//---------------------------------------------------------
		m_lstUserTools.RemoveAll();
		return FALSE;
	}

	return TRUE;
}

BOOL CUserToolsManager::SaveState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strUserToolsProfile, lpszProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.CreateKey(strProfileName))
	{
		return FALSE;
	}

	return reg.Write(strUserToolsEntry, m_lstUserTools);
}

CUserTool* CUserToolsManager::CreateNewTool()
{
	if (m_pToolRTC == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	if (m_lstUserTools.GetCount() >= GetMaxTools())
	{
		TRACE(_T("Too many user-defined tools. The max. number is %d"), GetMaxTools());
		return NULL;
	}

	//-----------------------------------
	// Find a first available command id:
	//-----------------------------------
	UINT uiCmdId = 0;
	for (uiCmdId = m_uiCmdFirst; uiCmdId <= m_uiCmdLast; uiCmdId ++)
	{
		BOOL bIsCmdAvailable = TRUE;

		for (POSITION pos = m_lstUserTools.GetHeadPosition(); pos != NULL;)
		{
			CUserTool* pListTool = (CUserTool*) m_lstUserTools.GetNext(pos);
			ASSERT_VALID(pListTool);

			if (pListTool->GetCommandId() == uiCmdId)
			{
				bIsCmdAvailable = FALSE;
				break;
			}
		}

		if (bIsCmdAvailable)
		{
			break;
		}
	}

	if (uiCmdId > m_uiCmdLast)
	{
		return NULL;
	}

	CUserTool* pTool = (CUserTool*) m_pToolRTC->CreateObject();
	if (pTool == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	ASSERT_VALID(pTool);

	pTool->m_uiCmdId = uiCmdId;

	m_lstUserTools.AddTail(pTool);
	return pTool;
}

BOOL CUserToolsManager::RemoveTool(CUserTool* pTool)
{
	ASSERT_VALID(pTool);
	POSITION pos = m_lstUserTools.Find(pTool);

	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_lstUserTools.RemoveAt(pos);

	UINT uiCmdId = pTool->GetCommandId();
	delete pTool;

	//------------------------------------
	// Remove user tool from all toolbars:
	//------------------------------------
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		BOOL bToolIsFound = FALSE;

		int iIndex = -1;
		while ((iIndex = pToolBar->CommandToIndex(uiCmdId)) >= 0)
		{
			pToolBar->RemoveButton(iIndex);
			bToolIsFound = TRUE;
		}

		if (bToolIsFound)
		{
			pToolBar->AdjustLayout();
		}
	}

	return TRUE;
}

BOOL CUserToolsManager::MoveToolUp(CUserTool* pTool)
{
	ASSERT_VALID(pTool);

	POSITION pos = m_lstUserTools.Find(pTool);
	if (pos == NULL)
	{
		return FALSE;
	}

	POSITION posPrev = pos;
	m_lstUserTools.GetPrev(posPrev);
	if (posPrev == NULL)
	{
		return FALSE;
	}

	m_lstUserTools.RemoveAt(pos);
	m_lstUserTools.InsertBefore(posPrev, pTool);

	return TRUE;
}

BOOL CUserToolsManager::MoveToolDown(CUserTool* pTool)
{
	ASSERT_VALID(pTool);

	POSITION pos = m_lstUserTools.Find(pTool);
	if (pos == NULL)
	{
		return FALSE;
	}

	POSITION posNext = pos;
	m_lstUserTools.GetNext(posNext);
	if (posNext == NULL)
	{
		return FALSE;
	}

	m_lstUserTools.RemoveAt(pos);
	m_lstUserTools.InsertAfter(posNext, pTool);

	return TRUE;
}

BOOL CUserToolsManager::InvokeTool(UINT uiCmdId)
{
	CUserTool* pTool = FindTool(uiCmdId);
	if (pTool == NULL)
	{
		return FALSE;
	}

	return pTool->Invoke();
}

CUserTool* CUserToolsManager::FindTool(UINT uiCmdId) const
{
	if (uiCmdId < m_uiCmdFirst || uiCmdId > m_uiCmdLast)
	{
		return NULL;
	}

	for (POSITION pos = m_lstUserTools.GetHeadPosition(); pos != NULL;)
	{
		CUserTool* pListTool = (CUserTool*) m_lstUserTools.GetNext(pos);
		ASSERT_VALID(pListTool);

		if (pListTool->GetCommandId() == uiCmdId)
		{
			return pListTool;
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtooltipctrl.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxtooltipctrl.h"

#include "afxtoolbarimages.h"
#include "afxtoolbar.h"
#include "afxtoolbarbutton.h"
#include "afxdrawmanager.h"
#include "afxvisualmanager.h"
#include "afxoutlookbarpane.h"
#include "afxribbonbutton.h"
#include "afxribbonbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifndef TTS_BALLOON
#define TTS_BALLOON 0x40
#endif

#ifndef TTM_SETTITLE
#define TTM_SETTITLE (WM_USER + 32)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolTipCtrl

IMPLEMENT_DYNCREATE(CMFCToolTipCtrl, CToolTipCtrl)

CMFCToolTipCtrl::CMFCToolTipCtrl(CMFCToolTipInfo* pParams/* = NULL*/)
{
	SetParams(pParams);

	m_pToolBar = NULL;
	m_pToolBarImages = NULL;
	m_pHotButton = NULL;
	m_sizeImage = CSize(0, 0);
	m_ptMargin = CPoint(0, 0);
	m_ptLocation = CPoint(-1, -1);
	m_pRibbonButton = NULL;
	m_nRibbonImageType = 0;
	m_nFixedWidthRegular = 0;
	m_nFixedWidthWithImage = 0;
}

CMFCToolTipCtrl::~CMFCToolTipCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCToolTipCtrl, CToolTipCtrl)
	//{{AFX_MSG_MAP(CMFCToolTipCtrl)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_NOTIFY_REFLECT(TTN_SHOW, &CMFCToolTipCtrl::OnShow)
	ON_NOTIFY_REFLECT(TTN_POP, &CMFCToolTipCtrl::OnPop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCToolTipCtrl message handlers

void CMFCToolTipCtrl::OnPaint()
{
	if (m_Params.m_bBalloonTooltip)
	{
		CToolTipCtrl::OnPaint();
		return;
	}

	CPaintDC dcPaint(this); // device context for painting

	CMemDC memDC (dcPaint, this);
	CDC* pDC = &memDC.GetDC ();


	CRect rect;
	GetClientRect(rect);

	CRect rectMargin;
	GetMargin(rectMargin);

	CRect rectText = rect;

	rectText.DeflateRect(rectMargin);
	rectText.DeflateRect(m_ptMargin.x, m_ptMargin.y);

	COLORREF clrLine = m_Params.m_clrBorder == (COLORREF)-1 ? ::GetSysColor(COLOR_INFOTEXT) : m_Params.m_clrBorder;
	COLORREF clrText = m_Params.m_clrText == (COLORREF)-1 ? ::GetSysColor(COLOR_INFOTEXT) : m_Params.m_clrText;

	// Fill background:
	OnFillBackground(pDC, rect, clrText, clrLine);

	CPen penLine(PS_SOLID, 1, clrLine);
	CPen* pOldPen = pDC->SelectObject(&penLine);

	// Draw border:
	OnDrawBorder(pDC, rect, clrLine);

	// Draw icon:
	if (m_sizeImage != CSize(0, 0) && m_Params.m_bDrawIcon)
	{
		CRect rectImage = rectText;
		rectImage.right = rectImage.left + m_sizeImage.cx;
		rectImage.bottom = rectImage.top + m_sizeImage.cy;

		OnDrawIcon(pDC, rectImage);

		rectText.left += m_sizeImage.cx + m_ptMargin.x;
	}

	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(clrText);

	// Draw label:
	int nTextHeight = OnDrawLabel(pDC, rectText, FALSE).cy;

	// Draw separator + description:
	if (!m_strDescription.IsEmpty() && m_Params.m_bDrawDescription)
	{
		CRect rectDescr = rectText;
		rectDescr.top += nTextHeight + 3 * m_ptMargin.y / 2;

		if (m_Params.m_bDrawSeparator)
		{
			OnDrawSeparator(pDC, rectDescr.left, rectDescr.right, rectDescr.top - m_ptMargin.y / 2);
		}

		OnDrawDescription(pDC, rectDescr, FALSE);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCToolTipCtrl::OnShow(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	*pResult = 0;

	if (m_Params.m_bVislManagerTheme)
	{
		CMFCVisualManager::GetInstance()->GetToolTipInfo(m_Params);
		m_Params.m_bVislManagerTheme = TRUE;
	}

	if (m_Params.m_bBalloonTooltip)
	{
		return;
	}

	CPoint ptCursor;
	::GetCursorPos(&ptCursor);

	GetHotButton();

	m_sizeImage = m_Params.m_bDrawIcon ? GetIconSize() : CSize(0, 0);
	m_ptMargin = m_Params.m_bRoundedCorners ? CPoint(6, 4) : CPoint(4, 2);

	CRect rectMargin;
	GetMargin(rectMargin);

	CRect rectText;
	GetClientRect(rectText);

	CClientDC dc(this);
	CSize sizeText = OnDrawLabel(&dc, rectText, TRUE);

	int cx = sizeText.cx;
	int cy = sizeText.cy;

	CSize sizeDescr(0, 0);

	if (!m_Params.m_bDrawDescription || m_strDescription.IsEmpty())
	{
		cy = max(cy, m_sizeImage.cy);
	}
	else
	{
		sizeDescr = OnDrawDescription(&dc, rectText, TRUE);

		cy += sizeDescr.cy + 2 * m_ptMargin.y;
		cx = max(cx, sizeDescr.cx);
		cy = max(cy, m_sizeImage.cy);
	}

	if (m_sizeImage.cx > 0 && m_Params.m_bDrawIcon)
	{
		cx += m_sizeImage.cx + m_ptMargin.x;
	}

	cx += 2 * m_ptMargin.x;
	cy += 2 * m_ptMargin.y;

	const int nFixedWidth = GetFixedWidth();
	if (nFixedWidth > 0 && sizeDescr != CSize(0, 0))
	{
		cx = max(cx, nFixedWidth);
	}

	CRect rectWindow;
	GetWindowRect(rectWindow);

	int x = rectWindow.left;
	int y = rectWindow.top;

	if (m_ptLocation != CPoint(-1, -1))
	{
		x = m_ptLocation.x;
		y = m_ptLocation.y;

		*pResult = 1;
	}

	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(rectWindow.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	int nBottom = max(ptCursor.y + cy + ::GetSystemMetrics(SM_CYCURSOR), y + cy + 2);
	if (nBottom > rectScreen.bottom)
	{
		y = ptCursor.y - cy - 1;
		
		if (m_pRibbonButton != NULL && m_ptLocation != CPoint(-1, -1))
		{
			ASSERT_VALID(m_pRibbonButton);

			CMFCRibbonBar* pRibbon = m_pRibbonButton->GetTopLevelRibbonBar();
			if (pRibbon->GetSafeHwnd() != NULL)
			{
				CRect rectRibbon;
				pRibbon->GetWindowRect(rectRibbon);

				y = rectRibbon.top - cy;
			}
		}

		*pResult = 1;
	}

	if (x + cx + 2 > rectScreen.right)
	{
		if ((*pResult) == 1) // Y has been changed
		{
			x = ptCursor.x - cx - 1;
		}
		else
		{
			x = rectScreen.right - cx - 1;
			*pResult = 1;
		}
	}

	if ((*pResult) == 1)
	{
		SetWindowPos(NULL, x, y, cx, cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}
	else
	{
		SetWindowPos(NULL, -1, -1, cx, cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	}

	if (m_Params.m_bRoundedCorners)
	{
		CRgn rgn;
		rgn.CreateRoundRectRgn(0, 0, cx + 1, cy + 1, 4, 4);

		SetWindowRgn(rgn, FALSE);
	}
}

void CMFCToolTipCtrl::OnPop(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	m_pHotButton = NULL;
	m_pToolBarImages = NULL;
	m_strDescription.Empty();
	m_ptLocation = CPoint(-1, -1);
	m_pRibbonButton = NULL;
	m_nRibbonImageType = 0;
	*pResult = 0;
}

void CMFCToolTipCtrl::OnFillBackground(CDC* pDC, CRect rect, COLORREF& /*clrText*/, COLORREF& /*clrLine*/)
{
	ASSERT_VALID(pDC);

	if (m_Params.m_clrFill == (COLORREF)-1)
	{
		::FillRect(pDC->GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_INFOBK));
	}
	else
	{
		if (m_Params.m_clrFillGradient == (COLORREF)-1)
		{
			CBrush br(m_Params.m_clrFill);
			pDC->FillRect(rect, &br);
		}
		else
		{
			CDrawingManager dm(*pDC);

			dm.FillGradient2(rect, m_Params.m_clrFillGradient, m_Params.m_clrFill, m_Params.m_nGradientAngle == -1 ? 90 : m_Params.m_nGradientAngle);
		}
	}
}

CSize CMFCToolTipCtrl::GetIconSize()
{

	if (m_pRibbonButton != NULL)
	{
		ASSERT_VALID(m_pRibbonButton);

		if (!m_pRibbonButton->IsDrawTooltipImage())
		{
			return CSize(0, 0);
		}

		if (m_pRibbonButton->GetIcon() != NULL)
		{
			m_nRibbonImageType = m_pRibbonButton->IsLargeImage() ? CMFCRibbonButton::RibbonImageLarge : CMFCRibbonButton::RibbonImageSmall;

			return m_pRibbonButton->GetImageSize((CMFCRibbonBaseElement::RibbonImageType)m_nRibbonImageType);
		}

		CSize sizeLarge(0, 0);

		if (m_pRibbonButton->IsLargeImage() && m_pRibbonButton->GetImageIndex(TRUE) >= 0)
		{
			sizeLarge = m_pRibbonButton->GetImageSize(CMFCRibbonButton::RibbonImageLarge);
		}

		if (sizeLarge != CSize(0, 0))
		{
			m_nRibbonImageType = CMFCRibbonButton::RibbonImageLarge;
			return sizeLarge;
		}

		CSize sizeSmall(0, 0);

		if (m_pRibbonButton->GetImageIndex(FALSE) >= 0)
		{
			sizeSmall = m_pRibbonButton->GetImageSize(CMFCRibbonButton::RibbonImageSmall);
		}

		m_nRibbonImageType = CMFCRibbonButton::RibbonImageSmall;

		return sizeSmall;
	}

	if (m_pHotButton == NULL || m_pToolBarImages == NULL || m_pToolBarImages->GetCount() == 0)
	{
		return CSize(0, 0);
	}

	ASSERT_VALID(m_pHotButton);

	return m_pHotButton->GetImage() >= 0 ? m_pToolBarImages->GetImageSize() : CSize(0, 0);
}

void CMFCToolTipCtrl::OnDrawBorder(CDC* pDC, CRect rect, COLORREF clrLine)
{
	ASSERT_VALID(pDC);

	if (!m_Params.m_bRoundedCorners)
	{
		pDC->Draw3dRect(rect, clrLine, clrLine);
		return;
	}

	const int nOffset = 2;

	pDC->MoveTo(rect.left + nOffset, rect.top);
	pDC->LineTo(rect.right - nOffset - 1, rect.top);

	pDC->LineTo(rect.right - 1, rect.top + nOffset);
	pDC->LineTo(rect.right - 1, rect.bottom - 1 - nOffset);

	pDC->LineTo(rect.right - nOffset - 1, rect.bottom - 1);
	pDC->LineTo(rect.left + nOffset, rect.bottom - 1);

	pDC->LineTo(rect.left, rect.bottom - 1 - nOffset);
	pDC->LineTo(rect.left, rect.top + nOffset);

	pDC->LineTo(rect.left + nOffset, rect.top);
}

BOOL CMFCToolTipCtrl::OnDrawIcon(CDC* pDC, CRect rectImage)
{
	ASSERT_VALID(pDC);

	if (m_pRibbonButton != NULL)
	{
		ASSERT_VALID(m_pRibbonButton);

		BOOL bIsDisabled = m_pRibbonButton->m_bIsDisabled;
		m_pRibbonButton->m_bIsDisabled = FALSE;

		m_pRibbonButton->DrawImage(pDC, (CMFCRibbonBaseElement::RibbonImageType) m_nRibbonImageType, rectImage);

		m_pRibbonButton->m_bIsDisabled = bIsDisabled;
		return TRUE;
	}

	if (m_pHotButton == NULL || m_pToolBarImages == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pHotButton);
	ASSERT_VALID(m_pToolBarImages);

	CAfxDrawState ds;
	m_pToolBarImages->PrepareDrawImage(ds);

	UINT nSaveStyle = m_pHotButton->m_nStyle;
	BOOL bSaveText = m_pHotButton->m_bText;
	BOOL bSaveImage = m_pHotButton->m_bImage;

	BOOL bSaveLargeIcons = CMFCToolBar::m_bLargeIcons;
	CMFCToolBar::m_bLargeIcons = FALSE;

	m_pHotButton->m_bText = FALSE;
	m_pHotButton->m_bImage = TRUE;

	m_pHotButton->m_nStyle = 0;

	m_pHotButton->CMFCToolBarButton::OnDraw(pDC, rectImage, m_pToolBarImages);

	m_pHotButton->m_nStyle = nSaveStyle;
	m_pHotButton->m_bText = bSaveText;
	m_pHotButton->m_bImage = bSaveImage;

	CMFCToolBar::m_bLargeIcons = bSaveLargeIcons;

	m_pToolBarImages->EndDrawImage(ds);
	return TRUE;
}

CSize CMFCToolTipCtrl::OnDrawLabel(CDC* pDC, CRect rect, BOOL bCalcOnly)
{
	ASSERT_VALID(pDC);

	CSize sizeText(0, 0);

	CString strText;
	GetWindowText(strText);

	strText.Replace(_T("\t"), _T("    "));

	BOOL bDrawDescr = m_Params.m_bDrawDescription && !m_strDescription.IsEmpty();

	CFont* pOldFont = (CFont*) pDC->SelectObject(m_Params.m_bBoldLabel && bDrawDescr ? &afxGlobalData.fontBold : &afxGlobalData.fontTooltip);

	if (strText.Find(_T('\n')) >= 0) // Multi-line text
	{
		UINT nFormat = DT_NOPREFIX;
		if (bCalcOnly)
		{
			nFormat |= DT_CALCRECT;
		}

		if (m_pRibbonButton != NULL)
		{
			nFormat |= DT_NOPREFIX;
		}

		int nHeight = pDC->DrawText(strText, rect, nFormat);
		sizeText = CSize(rect.Width(), nHeight);
	}
	else
	{
		if (bCalcOnly)
		{
			sizeText = pDC->GetTextExtent(strText);
		}
		else
		{
			UINT nFormat = DT_LEFT | DT_NOCLIP | DT_SINGLELINE;

			if (!bDrawDescr)
			{
				nFormat |= DT_VCENTER;
			}

			if (m_pRibbonButton != NULL)
			{
				nFormat |= DT_NOPREFIX;
			}

			sizeText.cy = pDC->DrawText(strText, rect, nFormat);
			sizeText.cx = rect.Width();
		}
	}

	pDC->SelectObject(pOldFont);

	return sizeText;
}

CSize CMFCToolTipCtrl::OnDrawDescription(CDC* pDC, CRect rect, BOOL bCalcOnly)
{
	ASSERT_VALID(pDC);

	CSize sizeText(0, 0);

	if (!m_Params.m_bDrawDescription)
	{
		return sizeText;
	}

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontTooltip);
	int nFixedWidth = GetFixedWidth ();

	if (nFixedWidth > 0 && m_sizeImage.cx <= 32)
	{
		rect.right = rect.left + nFixedWidth;

		if (m_sizeImage.cx > 0 && m_Params.m_bDrawIcon)
		{
			rect.right -= m_sizeImage.cx + m_ptMargin.x;
		}
	}
	else
	{
		rect.right = rect.left + m_Params.m_nMaxDescrWidth;
	}

	UINT nFormat = DT_WORDBREAK;
	if (bCalcOnly)
	{
		nFormat |= DT_CALCRECT;
	}

	int nDescrHeight = pDC->DrawText(m_strDescription, rect, nFormat);
	pDC->SelectObject(pOldFont);

	return CSize(rect.Width(), nDescrHeight);
}

void CMFCToolTipCtrl::OnDrawSeparator(CDC* pDC, int x1, int x2, int y)
{
	ASSERT_VALID(pDC);

	pDC->MoveTo(x1, y);
	pDC->LineTo(x2, y);
}

int CMFCToolTipCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CToolTipCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, CWnd::FromHandlePermanent(lpCreateStruct->hwndParent));

	if (m_pToolBar != NULL && m_pToolBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPane)))
	{
		m_pToolBar = NULL;
	}

	ModifyStyle(WS_BORDER, 0);

	if (m_Params.m_bBalloonTooltip)
	{
		ModifyStyle(0, TTS_BALLOON);
	}

	return 0;
}

BOOL CMFCToolTipCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rect;
    GetClientRect (rect);

    COLORREF clrDummy;
    OnFillBackground (pDC, rect, clrDummy, clrDummy);

	return TRUE;
}

void CMFCToolTipCtrl::SetParams(CMFCToolTipInfo* pParams)
{
	ASSERT_VALID(this);

	if (pParams == NULL)
	{
		CMFCToolTipInfo paramsDefault;
		m_Params = paramsDefault;
	}
	else
	{
		m_Params = *pParams;
	}
}

void CMFCToolTipCtrl::SetDescription(const CString strDescription)
{
	ASSERT_VALID(this);

	GetHotButton();
	m_strDescription = strDescription;

	m_strDescription.Replace(_T("\t"), _T("    "));
}

void CMFCToolTipCtrl::GetHotButton()
{
	m_pHotButton = NULL;
	m_pToolBarImages = NULL;

	if (m_pRibbonButton != NULL)
	{
		return;
	}

	if (m_pToolBar != NULL)
	{
		CPoint ptToolBar;

		::GetCursorPos(&ptToolBar);
		m_pToolBar->ScreenToClient(&ptToolBar);

		m_pHotButton = m_pToolBar->GetButton(m_pToolBar->HitTest(ptToolBar));

		if (m_pHotButton != NULL)
		{
			if (m_pToolBar->IsLocked())
			{
				m_pToolBarImages = m_pToolBar->GetLockedMenuImages();
			}
			else
			{
				if (m_pHotButton->m_bUserButton)
				{
					m_pToolBarImages = CMFCToolBar::GetUserImages();
				}
				else
				{
					m_pToolBarImages = CMFCToolBar::GetMenuImages();
					if (m_pToolBarImages == NULL || m_pToolBarImages->GetCount() <= 0)
					{
						m_pToolBarImages = CMFCToolBar::GetImages();
					}
				}
			}
		}
	}
}

void CMFCToolTipCtrl::SetLocation(CPoint pt)
{
	ASSERT_VALID(this);
	m_ptLocation = pt;
}

void CMFCToolTipCtrl::SetHotRibbonButton(CMFCRibbonButton* pRibbonButton)
{
	ASSERT_VALID(this);
	m_pRibbonButton = pRibbonButton;
}

int CMFCToolTipCtrl::GetFixedWidth()
{
	ASSERT_VALID(this);

	if (m_sizeImage.cx <= (int)(afxGlobalData.GetRibbonImageScale() * 32))
	{
		return m_nFixedWidthRegular;
	}
	else
	{
		return m_nFixedWidthWithImage;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanageroffice2003.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.


#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxvisualmanageroffice2003.h"
#include "afxdrawmanager.h"
#include "afxpopupmenubar.h"
#include "afxmenubar.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxcustomizebutton.h"
#include "afxmenuimages.h"
#include "afxcaptionbar.h"
#include "afxbasetabctrl.h"
#include "afxcolorbar.h"
#include "afxtabctrl.h"
#include "afxtaskspane.h"
#include "afxstatusbar.h"
#include "afxautohidebutton.h"
#include "afxheaderctrl.h"
#include "afxrebar.h"
#include "afxdesktopalertwnd.h"
#include "afxdropdowntoolbar.h"
#include "afxribboncategory.h"
#include "afxribbonquickaccesstoolbar.h"
#include "afxribbonbar.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxtooltipctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCVisualManagerOffice2003, CMFCVisualManagerOfficeXP)

BOOL CMFCVisualManagerOffice2003::m_bUseGlobalTheme = TRUE;
BOOL CMFCVisualManagerOffice2003::m_bStatusBarOfficeXPLook = TRUE;
BOOL CMFCVisualManagerOffice2003::m_bDefaultWinXPColors = TRUE;

// Construction/Destruction
CMFCVisualManagerOffice2003::CMFCVisualManagerOffice2003()
{
	m_WinXPTheme = WinXpTheme_None;

	m_bShadowHighlightedImage = FALSE;
	m_bFadeInactiveImage = FALSE;
	m_nMenuShadowDepth = 3;

	m_nVertMargin = 8;
	m_nHorzMargin = 8;
	m_nGroupVertOffset = 8;
	m_nGroupCaptionHeight = 18;
	m_nGroupCaptionHorzOffset = 3;
	m_nGroupCaptionVertOffset = 3;
	m_nTasksHorzOffset = 8;
	m_nTasksIconHorzOffset = 5;
	m_nTasksIconVertOffset = 4;
	m_bActiveCaptions = TRUE;

	OnUpdateSystemColors();
}

CMFCVisualManagerOffice2003::~CMFCVisualManagerOffice2003()
{
}

void CMFCVisualManagerOffice2003::DrawCustomizeButton(CDC* pDC, CRect rect, BOOL bIsHorz, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bIsCustomize, BOOL bIsMoreButtons)
{
	ASSERT_VALID(pDC);

	COLORREF clrDark = state == ButtonsIsRegular ? m_clrCustomizeButtonGradientDark : m_clrHighlightGradientDark;
	COLORREF clrLight = state == ButtonsIsRegular ? m_clrCustomizeButtonGradientLight : m_clrHighlightGradientLight;

#define AFX_PTS_NUM 6
	POINT pts [AFX_PTS_NUM];

	if (bIsHorz)
	{
		pts [0] = CPoint(rect.left, rect.top);
		pts [1] = CPoint(rect.left + 2, rect.top + 1);
		pts [2] = CPoint(rect.left + 3, rect.bottom - 3);
		pts [3] = CPoint(rect.left, rect.bottom);
		pts [4] = CPoint(rect.right, rect.bottom);
		pts [5] = CPoint(rect.right, rect.top);
	}
	else
	{
		pts [0] = CPoint(rect.left, rect.top);
		pts [1] = CPoint(rect.left + 3, rect.top + 2);
		pts [2] = CPoint(rect.right - 3, rect.top + 3);
		pts [3] = CPoint(rect.right, rect.top);
		pts [4] = CPoint(rect.right, rect.bottom);
		pts [5] = CPoint(rect.left, rect.bottom);
	}

	CRgn rgnClip;
	rgnClip.CreatePolygonRgn(pts, AFX_PTS_NUM, WINDING);

	pDC->SelectClipRgn(&rgnClip);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clrDark, clrLight, bIsHorz);

	//---------------------
	// Draw button content:
	//---------------------
	const int nEllipse = 2;

	if (bIsHorz)
	{
		rect.DeflateRect(0, nEllipse);
		rect.left += nEllipse;
	}
	else
	{
		rect.DeflateRect(nEllipse, 0);
		rect.top += nEllipse;
	}

	const int nMargin = GetToolBarCustomizeButtonMargin();

	CSize sizeImage = CMenuImages::Size();
	if (CMFCToolBar::IsLargeIcons())
	{
		sizeImage.cx *= 2;
		sizeImage.cy *= 2;
	}

	if (bIsCustomize)
	{
		//-----------------
		// Draw menu image:
		//-----------------
		CRect rectMenu = rect;
		if (bIsHorz)
		{
			rectMenu.top = rectMenu.bottom - sizeImage.cy - 2 * nMargin;
		}
		else
		{
			rectMenu.top++;
			rectMenu.left = rectMenu.right - sizeImage.cx - 2 * nMargin;
		}

		rectMenu.DeflateRect((rectMenu.Width() - sizeImage.cx) / 2, (rectMenu.Height() - sizeImage.cy) / 2);
		rectMenu.OffsetRect(1, 1);

		CMenuImages::IMAGES_IDS id = bIsHorz ? CMenuImages::IdCustomizeArrowDown : CMenuImages::IdCustomizeArrowLeft;

		CMenuImages::Draw( pDC, id, rectMenu.TopLeft(), CMenuImages::ImageWhite, sizeImage);

		rectMenu.OffsetRect(-1, -1);

		CMenuImages::Draw( pDC, id, rectMenu.TopLeft(), CMenuImages::ImageBlack, sizeImage);
	}

	if (bIsMoreButtons)
	{
		//-------------------
		// Draw "more" image:
		//-------------------
		CRect rectMore = rect;
		if (bIsHorz)
		{
			rectMore.bottom = rectMore.top + sizeImage.cy + 2 * nMargin;
		}
		else
		{
			rectMore.right = rectMore.left + sizeImage.cx + 2 * nMargin;
			rectMore.top++;
		}

		rectMore.DeflateRect((rectMore.Width() - sizeImage.cx) / 2, (rectMore.Height() - sizeImage.cy) / 2);

		CMenuImages::IMAGES_IDS id = bIsHorz ? CMenuImages::IdCustomizeMoreButtonsHorz : CMenuImages::IdCustomizeMoreButtonsVert;

		rectMore.OffsetRect(1, 1);
		CMenuImages::Draw(pDC, id, rectMore.TopLeft(), CMenuImages::ImageWhite, sizeImage);

		rectMore.OffsetRect(-1, -1);
		CMenuImages::Draw(pDC, id, rectMore.TopLeft(), CMenuImages::ImageBlack, sizeImage);
	}

	pDC->SelectClipRgn(NULL);
}

BOOL CMFCVisualManagerOffice2003::IsToolbarRoundShape(CMFCToolBar* pToolBar)
{
	ASSERT_VALID(pToolBar);
	return !pToolBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));
}

void CMFCVisualManagerOffice2003::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea)
{
	ENSURE(pBar != NULL);
	ENSURE(pDC != NULL);

	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	if (DYNAMIC_DOWNCAST(CMFCReBar, pBar) != NULL || DYNAMIC_DOWNCAST(CMFCReBar, pBar->GetParent()))
	{
		FillReBarPane(pDC, pBar, rectClient);
		return;
	}

	CRuntimeClass* pBarClass = pBar->GetRuntimeClass();

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pBar->IsDialogControl() || pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCColorBar)))
	{
		CMFCVisualManagerOfficeXP::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCStatusBar)))
	{
		if (m_bStatusBarOfficeXPLook && m_hThemeStatusBar != NULL && m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
			return;
		}
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		if (m_hThemeStatusBar != NULL && m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
			return;
		}
	}

	if (rectClip.IsRectEmpty())
	{
		rectClip = rectClient;
	}

	CDrawingManager dm(*pDC);

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCCaptionBar)))
	{
		CMFCCaptionBar* pCaptionBar = (CMFCCaptionBar*) pBar;

		if (pCaptionBar->IsMessageBarMode())
		{
			dm.FillGradient(rectClient, m_clrBarGradientDark, m_clrBarGradientLight, FALSE);
		}
		else
		{
			dm.FillGradient(rectClient, m_clrCaptionBarGradientDark, m_clrCaptionBarGradientLight, TRUE);
		}
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		pDC->FillRect(rectClip, &m_brMenuLight);

		CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
		if (!pMenuBar->m_bDisableSideBarInXPMode)
		{
			CRect rectImages = rectClient;
			rectImages.right = rectImages.left + pMenuBar->GetGutterWidth();
			rectImages.DeflateRect(0, 1);

			dm.FillGradient(rectImages, m_clrToolBarGradientLight, m_clrToolBarGradientDark, FALSE, 35);
		}

		return;
	}

	BOOL bIsHorz = (pBar->GetPaneStyle() & CBRS_ORIENT_HORZ);
	BOOL bIsToolBar = pBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar)) && !pBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));

	COLORREF clr1 = bIsHorz ? m_clrToolBarGradientDark : m_clrToolBarGradientVertLight;
	COLORREF clr2 = bIsHorz ? m_clrToolBarGradientLight : m_clrToolBarGradientVertDark;

	if (!bIsToolBar)
	{
		bIsHorz = FALSE;

		clr1 = m_clrBarGradientDark;
		clr2 = m_clrBarGradientLight;

		rectClient.right = rectClient.left + afxGlobalData.m_rectVirtual.Width() + 10;
	}

	const int nStartFlatPercentage = bIsToolBar ? 25 : 0;

	BOOL bRoundedCorners = FALSE;

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCDropDownToolBar)))
	{
		bNCArea = FALSE;
	}

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pBar);
	if (bNCArea && pToolBar != NULL && pToolBar->IsDocked() && pToolBar->GetParentDockSite() != NULL && !pToolBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
	{
		bRoundedCorners = TRUE;

		CBasePane* pParentBar = DYNAMIC_DOWNCAST(CBasePane, pBar->GetParent());

		if (pParentBar != NULL)
		{
			CPoint pt(0, 0);
			pBar->MapWindowPoints(pParentBar, &pt, 1);
			pt = pDC->OffsetWindowOrg(pt.x, pt.y);

			CRect rectParent;
			pParentBar->GetClientRect(rectParent);

			OnFillBarBackground(pDC, pParentBar, rectParent, rectParent);

			pDC->SetWindowOrg(pt.x, pt.y);
		}

		CRect rectFill = rectClient;
		rectFill.DeflateRect(1, 0);

		dm.FillGradient(rectFill, clr1, clr2, bIsHorz, nStartFlatPercentage);

		CRect rectLeft = rectClient;
		rectLeft.top ++;
		rectLeft.right = rectLeft.left + 1;

		dm.FillGradient(rectLeft, clr1, clr2, bIsHorz);

		CRect rectRight = rectClient;
		rectLeft.top ++;
		rectRight.left = rectRight.right - 1;

		dm.FillGradient(rectRight, clr1, clr2, bIsHorz);
	}
	else
	{
		CRect rectFill = rectClient;

		if (bIsToolBar && pToolBar != NULL && pBar->IsDocked() && pToolBar->GetParentDockSite() != NULL)
		{
			ASSERT_VALID(pToolBar);

			rectFill.left -= pToolBar->m_cxLeftBorder;
			rectFill.right += pToolBar->m_cxRightBorder;
			rectFill.top -= pToolBar->m_cyTopBorder;
			rectFill.bottom += pToolBar->m_cyBottomBorder;
		}

		dm.FillGradient(rectFill, clr1, clr2, bIsHorz, nStartFlatPercentage);
	}

	if (bNCArea)
	{
		CMFCCustomizeButton* pCustomizeButton = NULL;

		CRect rectCustomizeBtn;
		rectCustomizeBtn.SetRectEmpty();

		if (pToolBar != NULL && pToolBar->GetCount() > 0)
		{
			pCustomizeButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton,
				pToolBar->GetButton(pToolBar->GetCount() - 1));

			if (pCustomizeButton != NULL)
			{
				rectCustomizeBtn = pCustomizeButton->Rect();
			}
		}

		if (bRoundedCorners)
		{
			//------------------------
			// Draw bottom/right edge:
			//------------------------
			CPen* pOldPen = pDC->SelectObject(&m_penBottomLine);
			ENSURE(pOldPen != NULL);

			if (bIsHorz)
			{
				pDC->MoveTo(rectClient.left + 2, rectClient.bottom - 1);
				pDC->LineTo(rectClient.right - rectCustomizeBtn.Width(), rectClient.bottom - 1);
			}
			else
			{
				pDC->MoveTo(rectClient.right - 1, rectClient.top + 2);
				pDC->LineTo(rectClient.right - 1, rectClient.bottom - 2 - rectCustomizeBtn.Height());
			}

			pDC->SelectObject(pOldPen);
		}

		if (pToolBar != NULL && pToolBar->GetCount() > 0)
		{
			if (pCustomizeButton != NULL && !rectCustomizeBtn.IsRectEmpty() && pCustomizeButton->IsPipeStyle())
			{
				BOOL bIsRTL = pBar->GetExStyle() & WS_EX_LAYOUTRTL;

				//----------------------------------------
				// Special drawing for "Customize" button:
				//----------------------------------------
				CRect rectWindow;
				pBar->GetWindowRect(rectWindow);

				pBar->ClientToScreen(&rectCustomizeBtn);

				CRect rectButton = rectClient;

				if (pToolBar->IsHorizontal())
				{
					if (bIsRTL)
					{
						int nButtonWidth = rectCustomizeBtn.Width();

						nButtonWidth -= rectWindow.left - rectCustomizeBtn.left;
						rectButton.left = rectButton.right - nButtonWidth;
					}
					else
					{
						rectButton.left = rectButton.right - rectCustomizeBtn.Width() - rectWindow.right + rectCustomizeBtn.right;
					}

					pCustomizeButton->SetExtraSize(0, rectWindow.bottom - rectCustomizeBtn.bottom);
				}
				else
				{
					rectButton.top = rectButton.bottom - rectCustomizeBtn.Height() - rectWindow.bottom + rectCustomizeBtn.bottom;
					pCustomizeButton->SetExtraSize(rectWindow.right - rectCustomizeBtn.right, 0);
				}

				AFX_BUTTON_STATE state = ButtonsIsRegular;

				if (pToolBar->IsButtonHighlighted(pToolBar->GetCount() - 1) || pCustomizeButton->IsDroppedDown())
				{
					state = ButtonsIsHighlighted;
				}
				else if (pCustomizeButton->m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
				{
					//-----------------------
					// Pressed in or checked:
					//-----------------------
					state = ButtonsIsPressed;
				}

				DrawCustomizeButton(pDC, rectButton, pToolBar->IsHorizontal(), state,
					(int) pCustomizeButton->GetCustomizeCmdId() > 0, !pCustomizeButton->GetInvisibleButtons().IsEmpty());
			}
		}
	}
}

void CMFCVisualManagerOffice2003::OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect)
{
	ASSERT_VALID(pBar);

	if (pBar->IsDialogControl() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawPaneBorder(pDC, pBar, rect);
	}
}

void CMFCVisualManagerOffice2003::OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar)
{
	ASSERT_VALID(pDC);

	if (pBar != NULL && pBar->IsDialogControl() || afxGlobalData.m_nBitsPerPixel <= 8)
	{
		CMFCVisualManagerOfficeXP::OnDrawBarGripper(pDC, rectGripper, bHorz, pBar);
		return;
	}

	const int nBoxSize = 4;

	if (bHorz)
	{
		rectGripper.left = rectGripper.right - nBoxSize;
	}
	else
	{
		rectGripper.top = rectGripper.bottom - nBoxSize;
	}

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pBar);
	if (pToolBar != NULL)
	{
		if (bHorz)
		{
			const int nHeight = CMFCToolBar::IsLargeIcons() ? pToolBar->GetRowHeight() : pToolBar->GetButtonSize().cy;
			const int nDelta = max(0, (nHeight - pToolBar->GetImageSize().cy) / 2);
			rectGripper.DeflateRect(0, nDelta);
		}
		else
		{
			const int nWidth = CMFCToolBar::IsLargeIcons() ? pToolBar->GetColumnWidth() : pToolBar->GetButtonSize().cx;
			const int nDelta = max(0, (nWidth - pToolBar->GetImageSize().cx) / 2);
			rectGripper.DeflateRect(nDelta, 0);
		}
	}

	const int nBoxesNumber = bHorz ? (rectGripper.Height() - nBoxSize) / nBoxSize : (rectGripper.Width() - nBoxSize) / nBoxSize;
	int nOffset = bHorz ? (rectGripper.Height() - nBoxesNumber * nBoxSize) / 2 : (rectGripper.Width() - nBoxesNumber * nBoxSize) / 2;

	for (int nBox = 0; nBox < nBoxesNumber; nBox++)
	{
		int x = bHorz ? rectGripper.left : rectGripper.left + nOffset;
		int y = bHorz ? rectGripper.top + nOffset : rectGripper.top;

		pDC->FillSolidRect(x + 1, y + 1, nBoxSize / 2, nBoxSize / 2, afxGlobalData.clrBtnHilite);
		pDC->FillSolidRect(x, y, nBoxSize / 2, nBoxSize / 2, m_clrGripper);

		nOffset += nBoxSize;
	}
}

void CMFCVisualManagerOffice2003::OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawComboBorder(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	if (bIsHighlighted || bIsDropped || bDisabled)
	{
		rect.DeflateRect(1, 1);

		COLORREF colorBorder = bDisabled ? afxGlobalData.clrBtnShadow : m_clrMenuItemBorder;
		pDC->Draw3dRect(&rect, colorBorder, colorBorder);
	}
}

void CMFCVisualManagerOffice2003::OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillOutlookPageButton(pDC, rect, bIsHighlighted, bIsPressed, clrText);
		return;
	}

	ASSERT_VALID(pDC);

	COLORREF clr1 = m_clrBarGradientDark;
	COLORREF clr2 = m_clrBarGradientLight;

	if (bIsPressed)
	{
		if (bIsHighlighted)
		{
			clr1 = m_clrHighlightDnGradientDark;
			clr2 = m_clrHighlightDnGradientLight;
		}
		else
		{
			clr1 = m_clrHighlightDnGradientLight;
			clr2 = m_clrHighlightDnGradientDark;
		}
	}
	else if (bIsHighlighted)
	{
		clr1 = m_clrHighlightGradientDark;
		clr2 = m_clrHighlightGradientLight;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clr1, clr2, TRUE);

	clrText = afxGlobalData.clrBtnText;
}

void CMFCVisualManagerOffice2003::OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawOutlookPageButtonBorder(pDC, rectBtn, bIsHighlighted, bIsPressed);
		return;
	}

	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rectBtn, afxGlobalData.clrBtnHilite, m_clrGripper);
}

void CMFCVisualManagerOffice2003::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CMFCCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);
	if (pCustButton == NULL || !pCustButton->IsPipeStyle() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	CMFCToolBar* pToolBar = pCustButton->GetParentToolbar();
	if (pToolBar != NULL)
	{
		ASSERT_VALID(pToolBar);

		CRect rectToolbar;
		pToolBar->GetWindowRect(rectToolbar);
		pToolBar->ScreenToClient(rectToolbar);

		if (pToolBar->IsHorizontal())
		{
			rect.right = rectToolbar.right;
		}
		else
		{
			rect.bottom = rectToolbar.bottom;
		}

		CSize sizeExtra = pCustButton->GetExtraSize();

		rect.InflateRect(sizeExtra);
		DrawCustomizeButton(pDC, rect, pToolBar->IsHorizontal(), state, (int) pCustButton->GetCustomizeCmdId() > 0, !pCustButton->GetInvisibleButtons().IsEmpty());
	}

	pCustButton->SetDefaultDraw(FALSE);
}

void CMFCVisualManagerOffice2003::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, AFX_BUTTON_STATE state)
{
	CMFCCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);
	if (pCustButton == NULL || !pCustButton->IsPipeStyle() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawButtonBorder(pDC, pButton, rect, state);
	}

	// Do nothing - the border is already painted in OnFillButtonInterior
}

void CMFCVisualManagerOffice2003::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	ASSERT_VALID(pBar);

	if (pBar->IsDialogControl() || pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)) || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		if (m_hThemeStatusBar == NULL)
		{
			CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
			return;
		}

		rect.InflateRect(1, 5);

		if (m_pfDrawThemeBackground)
		{
			(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), SP_PANE, 0, &rect, 0);
		}
		return;
	}

	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pBar);
	if (pToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
		return;
	}

	CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
	ENSURE(pOldPen != NULL);

	if (bHorz)
	{
		const int nDelta = max(0, (pToolBar->GetButtonSize().cy - pToolBar->GetImageSize().cy) / 2);
		rect.DeflateRect(0, nDelta);

		int x = rect.left += rect.Width() / 2 - 1;

		pDC->MoveTo(x, rect.top);
		pDC->LineTo(x, rect.bottom - 1);

		pDC->SelectObject(&m_penSeparatorLight);

		pDC->MoveTo(x + 1, rect.top + 1);
		pDC->LineTo(x + 1, rect.bottom);
	}
	else
	{
		const int nDelta = max(0, (pToolBar->GetButtonSize().cx - pToolBar->GetImageSize().cx) / 2);
		rect.DeflateRect(nDelta, 0);

		int y = rect.top += rect.Height() / 2 - 1;

		pDC->MoveTo(rect.left, y);
		pDC->LineTo(rect.right - 1, y);

		pDC->SelectObject(&m_penSeparatorLight);

		pDC->MoveTo(rect.left + 1, y + 1);
		pDC->LineTo(rect.right, y + 1);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOffice2003::OnUpdateSystemColors()
{
	CMFCBaseVisualManager::UpdateSystemColors();

	BOOL bIsAppThemed = m_bUseGlobalTheme ||(m_pfGetWindowTheme != NULL && (*m_pfGetWindowTheme)(AfxGetMainWnd()->GetSafeHwnd()) != NULL);

	m_WinXPTheme = bIsAppThemed ? GetStandardWindowsTheme() : WinXpTheme_None;

	if (!m_bDefaultWinXPColors && m_WinXPTheme != WinXpTheme_None)
	{
		m_WinXPTheme = WinXpTheme_NonStandard;
	}

	m_bIsStandardWinXPTheme = m_WinXPTheme == WinXpTheme_Blue || m_WinXPTheme == WinXpTheme_Olive || m_WinXPTheme == WinXpTheme_Silver;

	//----------------------
	// Modify global colors:
	//----------------------
	ModifyGlobalColors();

	CMFCVisualManagerOfficeXP::OnUpdateSystemColors();

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		m_clrTaskPaneGradientDark  = afxGlobalData.clrWindow;
		m_clrTaskPaneGradientLight  = afxGlobalData.clrWindow;
		m_clrTaskPaneGroupCaptionDark  = afxGlobalData.clrBarFace;
		m_clrTaskPaneGroupCaptionLight  = afxGlobalData.clrBarFace;
		m_clrTaskPaneGroupCaptionSpecDark  = afxGlobalData.clrBarFace;
		m_clrTaskPaneGroupCaptionSpecLight  = afxGlobalData.clrBarFace;
		m_clrTaskPaneGroupAreaLight  = afxGlobalData.clrWindow;
		m_clrTaskPaneGroupAreaDark  = afxGlobalData.clrWindow;
		m_clrTaskPaneGroupAreaSpecLight  = afxGlobalData.clrWindow;
		m_clrTaskPaneGroupAreaSpecDark  = afxGlobalData.clrWindow;
		m_clrTaskPaneGroupBorder  = afxGlobalData.clrBtnShadow;

		m_clrBarGradientLight = m_clrToolBarGradientLight = afxGlobalData.clrBarLight;

		m_penTaskPaneGroupBorder.DeleteObject();
		m_penTaskPaneGroupBorder.CreatePen(PS_SOLID, 1, m_clrTaskPaneGroupBorder);

		m_clrToolbarDisabled = afxGlobalData.clrBtnHilite;
		return;
	}

	//--------------------------------------------------
	// Calculate control bars bakground gradient colors:
	//--------------------------------------------------
	COLORREF clrBase = GetBaseThemeColor();

	if (m_WinXPTheme == WinXpTheme_Olive)
	{
		m_clrToolBarGradientDark = CDrawingManager::PixelAlpha(clrBase, 120);
		m_clrBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DFACE), .87, 1, 3);
		m_clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1., 2, 1);
		m_clrBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1.03);
	}
	else if (m_WinXPTheme == WinXpTheme_Silver)
	{
		m_clrToolBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DFACE), 0.75, 2);
		m_clrBarGradientDark = CDrawingManager::PixelAlpha(clrBase, 120);
		m_clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DHIGHLIGHT), .98);
		m_clrBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1.03);
	}
	else if (m_WinXPTheme == WinXpTheme_Blue)
	{
		m_clrToolBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DFACE), 0.93, 2);
		m_clrBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DLIGHT), .99, 2, 1);
		m_clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1.03);
		m_clrBarGradientLight = m_clrToolBarGradientLight;
	}
	else
	{
		m_clrToolBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DFACE), 0.93, 2);
		m_clrBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DLIGHT), .99, 2, 1);
		m_clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1., 1, 4);
		m_clrBarGradientLight = m_clrToolBarGradientLight;
	}

	m_clrToolBarGradientVertLight = m_clrToolBarGradientLight;
	m_clrToolBarGradientVertDark = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 98);

	COLORREF clrSeparatorDark;

	//-------------------------------------
	// Calculate highlight gradient colors:
	//-------------------------------------
	if (m_bIsStandardWinXPTheme && m_pfGetThemeColor != NULL)
	{
		COLORREF clr1, clr2, clr3;

		if (m_WinXPTheme == WinXpTheme_Blue && afxGlobalData.bIsWindowsVista)
		{
			clr1 = RGB (250, 196, 88);
			clr2 = RGB (250, 196, 88);
			clr3 = RGB (228, 93, 61);
		}
		else
		{
			(*m_pfGetThemeColor) (m_hThemeButton, BP_PUSHBUTTON, 0, TMT_ACCENTCOLORHINT, &clr1);
			(*m_pfGetThemeColor) (m_hThemeButton, BP_RADIOBUTTON, 0, TMT_ACCENTCOLORHINT, &clr2);
			(*m_pfGetThemeColor) (m_hThemeWindow, WP_CLOSEBUTTON, 0, TMT_FILLCOLORHINT, &clr3);
		}

		m_clrHighlightMenuItem = CDrawingManager::SmartMixColors(clr1, clr2, 1.3, 1, 1);
		m_clrHighlightGradientLight = CDrawingManager::SmartMixColors(clr1, clr3, 1.55, 2, 1);
		m_clrHighlightGradientDark = CDrawingManager::SmartMixColors(clr1, clr2, 1.03, 2, 1);
		m_clrHighlightDnGradientLight = CDrawingManager::SmartMixColors(clr1, clr3, 1.03, 1, 2);

		m_brFloatToolBarBorder.DeleteObject();

		COLORREF clrCustom;
		(*m_pfGetThemeColor)(m_hThemeButton, 2, 0, 3822, &clrCustom);

		COLORREF clrToolbarBorder = CDrawingManager::SmartMixColors(clrCustom, clrBase, 0.84, 1, 4);
		m_brFloatToolBarBorder.CreateSolidBrush(clrToolbarBorder);

		if (m_WinXPTheme == WinXpTheme_Blue || m_WinXPTheme == WinXpTheme_Silver)
		{
			m_clrCustomizeButtonGradientDark = afxGlobalData.bIsWindowsVista ? RGB (7, 57, 142) : 
												CDrawingManager::PixelAlpha (afxGlobalData.clrActiveCaption, 60);

			const double k = (m_WinXPTheme == WinXpTheme_Blue) ? 1.61 : 1;

			m_clrCustomizeButtonGradientLight = CDrawingManager::SmartMixColors(m_clrCustomizeButtonGradientDark, clrBase, k, 3, 1);

			(*m_pfGetThemeColor)(m_hThemeButton, 1, 5, 3823, &clrCustom);
		}
		else
		{
			m_clrCustomizeButtonGradientDark = CDrawingManager::SmartMixColors(clrCustom, clrBase, 0.63, 1, 3);

			(*m_pfGetThemeColor)(m_hThemeButton, 1, 5, 3823, &clrCustom);

			m_clrCustomizeButtonGradientLight = CDrawingManager::SmartMixColors(clrCustom, clrBase, 1.2, 1, 3);
		}

		afxGlobalData.clrBarDkShadow = m_clrCustomizeButtonGradientDark;

		if (m_WinXPTheme != WinXpTheme_Silver)
		{
			afxGlobalData.clrBarShadow = CDrawingManager::SmartMixColors(clrCustom, clrBase, 1.4, 1, 3);
		}

		m_clrToolBarBottomLine = m_WinXPTheme == WinXpTheme_Silver ? CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 80) :
		CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 50);

		m_colorToolBarCornerTop = CDrawingManager::PixelAlpha(m_clrToolBarGradientLight, 92);
		m_colorToolBarCornerBottom = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 97);

		m_clrGripper = CDrawingManager::PixelAlpha(m_clrToolBarGradientVertDark, 40);

		clrSeparatorDark = CDrawingManager::PixelAlpha(m_clrToolBarGradientVertDark, 81);

		m_clrMenuItemBorder = m_clrGripper;

		m_clrMenuBorder = CDrawingManager::PixelAlpha(clrBase, 80);

		m_clrCaptionBarGradientDark = m_clrCustomizeButtonGradientDark;
		m_clrCaptionBarGradientLight = m_clrCustomizeButtonGradientLight;

		m_clrMenuLight = CDrawingManager::PixelAlpha(afxGlobalData.clrWindow, .96, .96, .96);

		m_brMenuLight.DeleteObject();
		m_brMenuLight.CreateSolidBrush(m_clrMenuLight);
	}
	else
	{
		m_clrHighlightMenuItem = (COLORREF)-1;

		m_clrHighlightGradientLight = m_clrHighlight;
		m_clrHighlightGradientDark = m_clrHighlightDn;
		m_clrHighlightDnGradientLight = CDrawingManager::PixelAlpha(m_clrHighlightGradientLight, 120);

		m_clrCustomizeButtonGradientDark = afxGlobalData.clrBarShadow;
		m_clrCustomizeButtonGradientLight = CDrawingManager::SmartMixColors(m_clrCustomizeButtonGradientDark, afxGlobalData.clrBarFace, 1, 1, 1);

		m_clrToolBarBottomLine = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 75);
		m_colorToolBarCornerTop = afxGlobalData.clrBarLight;
		m_colorToolBarCornerBottom = m_clrToolBarGradientDark;

		m_clrGripper = afxGlobalData.clrBarShadow;
		clrSeparatorDark = afxGlobalData.clrBarShadow;

		m_clrCaptionBarGradientLight = afxGlobalData.clrBarShadow;
		m_clrCaptionBarGradientDark = afxGlobalData.clrBarDkShadow;
	}

	m_clrHighlightDnGradientDark = m_clrHighlightGradientDark;

	m_clrHighlightCheckedGradientLight = m_clrHighlightDnGradientDark;

	m_clrHighlightCheckedGradientDark = CDrawingManager::PixelAlpha(m_clrHighlightDnGradientLight, 120);

	m_brTabBack.DeleteObject();
	m_brTabBack.CreateSolidBrush(m_clrToolBarGradientLight);

	m_penSeparatorLight.DeleteObject();
	m_penSeparatorLight.CreatePen(PS_SOLID, 1, afxGlobalData.clrBarHilite);

	m_brTearOffCaption.DeleteObject();
	m_brTearOffCaption.CreateSolidBrush(afxGlobalData.clrBarFace);

	m_brFace.DeleteObject();
	m_brFace.CreateSolidBrush(m_clrToolBarGradientLight);

	m_penSeparator.DeleteObject();
	m_penSeparator.CreatePen(PS_SOLID, 1, clrSeparatorDark);

	m_clrMenuShadowBase = afxGlobalData.clrBarFace;

	m_clrToolbarDisabled = CDrawingManager::SmartMixColors(m_clrToolBarGradientDark, m_clrToolBarGradientLight, .92);

	m_penBottomLine.DeleteObject();
	m_penBottomLine.CreatePen(PS_SOLID, 1, m_clrToolBarBottomLine);

	// --------------------------
	// Calculate TaskPane colors:
	// --------------------------
	if (m_bIsStandardWinXPTheme && m_hThemeExplorerBar != NULL && m_pfGetThemeColor != NULL)
	{
		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 0, 0, 3810, &m_clrTaskPaneGradientLight);// GRADIENTCOLOR1
		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 0, 0, 3811, &m_clrTaskPaneGradientDark); // GRADIENTCOLOR2

		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 5, 0, 3802, &m_clrTaskPaneGroupCaptionDark); // FILLCOLOR
		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 12, 0, 3802, &m_clrTaskPaneGroupCaptionSpecDark);// FILLCOLOR
		m_clrTaskPaneGroupCaptionSpecLight = m_clrTaskPaneGroupCaptionDark;

		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 5, 0, 3802, &m_clrTaskPaneGroupAreaLight); // FILLCOLOR
		m_clrTaskPaneGroupAreaDark = m_clrTaskPaneGroupAreaLight;
		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 9, 0, 3821, &m_clrTaskPaneGroupAreaSpecLight); // FILLCOLORHINT
		m_clrTaskPaneGroupAreaSpecDark = m_clrTaskPaneGroupAreaSpecLight;
		(*m_pfGetThemeColor)(m_hThemeExplorerBar, 5, 0, 3801, &m_clrTaskPaneGroupBorder); // BORDERCOLOR
		m_clrTaskPaneGroupCaptionLight = m_clrTaskPaneGroupBorder;
	}
	else
	{
		m_clrTaskPaneGradientDark  = m_clrBarGradientDark;
		m_clrTaskPaneGradientLight  = m_clrToolBarGradientLight;
		m_clrTaskPaneGroupCaptionDark  = m_clrBarGradientDark;
		m_clrTaskPaneGroupCaptionLight  = m_clrToolBarGradientLight;

		COLORREF clrLight = CDrawingManager::PixelAlpha(afxGlobalData.clrBarShadow, 125);

		m_clrTaskPaneGroupCaptionSpecDark = CDrawingManager::SmartMixColors(m_clrCustomizeButtonGradientDark, clrLight);

		m_clrTaskPaneGroupCaptionSpecLight  = m_clrCustomizeButtonGradientLight;
		m_clrTaskPaneGroupAreaLight  = m_clrToolBarGradientLight;
		m_clrTaskPaneGroupAreaDark  = m_clrToolBarGradientLight;
		m_clrTaskPaneGroupAreaSpecLight  = m_clrToolBarGradientLight;
		m_clrTaskPaneGroupAreaSpecDark  = m_clrToolBarGradientLight;
		m_clrTaskPaneGroupBorder  = m_clrToolBarGradientLight;
	}

	m_penTaskPaneGroupBorder.DeleteObject();
	m_penTaskPaneGroupBorder.CreatePen(PS_SOLID, 1, m_clrTaskPaneGroupBorder);
}

void CMFCVisualManagerOffice2003::OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillHighlightedArea(pDC, rect, pBrush, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pBrush);

	BOOL bIsHorz = TRUE;
	BOOL bIsPopupMenu = FALSE;

	COLORREF clr1 = (COLORREF)-1;
	COLORREF clr2 = (COLORREF)-1;

	if (pButton != NULL)
	{
		ASSERT_VALID(pButton);

		bIsHorz = pButton->IsHorizontal();

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

		bIsPopupMenu = pMenuButton != NULL && pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

		if (bIsPopupMenu && pBrush == &m_brHighlight)
		{
			if (m_clrHighlightMenuItem != (COLORREF)-1)
			{
				CBrush br(m_clrHighlightMenuItem);
				pDC->FillRect(&rect, &br);
				return;
			}
		}

		if (pMenuButton != NULL && !bIsPopupMenu && pMenuButton->IsDroppedDown())
		{
			clr1 = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, m_bIsStandardWinXPTheme ? 101 : 120);
			clr2 = CDrawingManager::PixelAlpha(m_clrToolBarGradientLight, 110);
		}
	}

	if (pBrush == &m_brHighlight && m_bIsStandardWinXPTheme)
	{
		clr1 = m_clrHighlightGradientDark;
		clr2 = bIsPopupMenu ? clr1 : m_clrHighlightGradientLight;
	}
	else if (pBrush == &m_brHighlightDn && m_bIsStandardWinXPTheme)
	{
		clr1 = bIsPopupMenu ? m_clrHighlightDnGradientLight : m_clrHighlightDnGradientDark;
		clr2 = m_clrHighlightDnGradientLight;
	}
	else if (pBrush == &m_brHighlightChecked && m_bIsStandardWinXPTheme)
	{
		clr1 = bIsPopupMenu ? m_clrHighlightCheckedGradientLight : m_clrHighlightCheckedGradientDark;
		clr2 = m_clrHighlightCheckedGradientLight;
	}

	if (clr1 == (COLORREF)-1 || clr2 == (COLORREF)-1)
	{
		CMFCVisualManagerOfficeXP::OnFillHighlightedArea(pDC, rect, pBrush, pButton);
		return;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clr1, clr2, bIsHorz);
}

void CMFCVisualManagerOffice2003::OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		const int nRadius = 8;

		rect = CRect(rect.CenterPoint() - CSize(nRadius - 1, nRadius - 1), CSize(nRadius * 2, nRadius * 2));

		CDrawingManager dm(*pDC);
		dm.DrawGradientRing(rect, m_clrToolBarGradientDark, m_clrMenuLight, (COLORREF)-1, 45, nRadius);
	}

	CMFCVisualManager::OnDrawShowAllMenuItems(pDC, rect, state);
}

int CMFCVisualManagerOffice2003::GetShowAllMenuItemsHeight(CDC* pDC, const CSize& sizeDefault)
{
	int nHeight = CMFCVisualManager::GetShowAllMenuItemsHeight(pDC, sizeDefault);
	return nHeight + 4;
}

void CMFCVisualManagerOffice2003::OnDrawCaptionBarBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, COLORREF clrBarBorder, BOOL bFlatBorder)
{
	ASSERT_VALID(pDC);

	if (clrBarBorder == (COLORREF) -1)
	{
		pDC->FillRect(rect, (pBar != NULL && pBar->IsDialogControl()) ? &afxGlobalData.brBtnFace : &afxGlobalData.brBarFace);
	}
	else
	{
		CBrush brBorder(clrBarBorder);
		pDC->FillRect(rect, &brBorder);
	}

	if (!bFlatBorder)
	{
		pDC->Draw3dRect(rect, m_clrBarGradientLight, m_clrToolBarBottomLine);
	}
}

void CMFCVisualManagerOffice2003::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	if (!bDisabled)
	{
		if (bIsDropped || bIsHighlighted)
		{
			OnFillHighlightedArea(pDC, rect, bIsDropped ? &m_brHighlightDn : &m_brHighlight, NULL);

			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);
				dm.DrawLine(rect.left, rect.top, rect.left, rect.bottom, m_clrMenuItemBorder);
			}
			else
			{
				CPen pen(PS_SOLID, 1, m_clrMenuItemBorder);
				CPen* pOldPen = pDC->SelectObject(&pen);
				ENSURE(pOldPen != NULL);

				pDC->MoveTo(rect.left, rect.top);
				pDC->LineTo(rect.left, rect.bottom);

				pDC->SelectObject(pOldPen);
			}
		}
		else
		{
			CDrawingManager dm(*pDC);
			dm.FillGradient(rect, m_clrToolBarGradientDark, m_clrToolBarGradientLight, TRUE);

			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrWindow);
			}
			else
			{
				pDC->Draw3dRect(rect, afxGlobalData.clrWindow, afxGlobalData.clrWindow);
			}
		}
	}

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, bDisabled ? CMenuImages::ImageGray :(bIsDropped && bIsHighlighted) ? CMenuImages::ImageWhite : CMenuImages::ImageBlack);
}

void CMFCVisualManagerOffice2003::OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawTearOffCaption(pDC, rect, bIsActive);
		return;
	}

	const int nBorderSize = 1;
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brMenuLight);

	rect.DeflateRect(nBorderSize, 1);

	if (bIsActive)
	{
		OnFillHighlightedArea(pDC, rect, bIsActive ? &m_brHighlight : &m_brBarBkgnd, NULL);
	}
	else
	{
		pDC->FillRect(rect, &m_brTearOffCaption);
	}

	// Draw gripper:
	OnDrawBarGripper(pDC, rect, FALSE, NULL);

	if (bIsActive)
	{
		pDC->Draw3dRect(rect, m_clrMenuBorder, m_clrMenuBorder);
	}
}

void CMFCVisualManagerOffice2003::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect)
{
	BOOL bConnectMenuToParent = m_bConnectMenuToParent;

	if (DYNAMIC_DOWNCAST(CMFCCustomizeButton, pMenu->GetParentButton()) != NULL)
	{
		m_bConnectMenuToParent = FALSE;
	}

	CMFCVisualManagerOfficeXP::OnDrawMenuBorder(pDC, pMenu, rect);
	m_bConnectMenuToParent = bConnectMenuToParent;
}

COLORREF CMFCVisualManagerOffice2003::GetThemeColor(HTHEME hTheme, int nIndex) const
{
	if (hTheme != NULL && m_pfGetThemeSysColor != NULL)
	{
		return(*m_pfGetThemeSysColor)(hTheme, nIndex);
	}

	return ::GetSysColor(nIndex);
}

void CMFCVisualManagerOffice2003::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsDialogControl())
	{
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		return;
	}

	if (pTabWnd->IsFlatTab() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	CDrawingManager dm(*pDC);

	COLORREF clr1 = m_clrToolBarGradientDark;
	COLORREF clr2 = m_clrToolBarGradientLight;

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		dm.FillGradient(rect, clr1, clr2, TRUE);
	}
	else
	{
		dm.FillGradient(rect, clr2, clr1, TRUE);
	}
}

void CMFCVisualManagerOffice2003::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (!pTabWnd->IsOneNoteStyle() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManagerOfficeXP::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	CRect rectClip;
	pTabWnd->GetTabsRect(rectClip);

	const int nExtra = (iTab == 0 || bIsActive) ? 0 : rectTab.Height();

	if (rectTab.left + nExtra + 10 > rectClip.right || rectTab.right - 10 <= rectClip.left)
	{
		return;
	}

	const BOOL bIsHighlight = iTab == pTabWnd->GetHighlightedTab();

	COLORREF clrTab = pTabWnd->GetTabBkColor(iTab);
	if (clrTab == (COLORREF)-1 && bIsActive)
	{
		clrTab = afxGlobalData.clrWindow;
	}

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rectTab.OffsetRect(0, -1);
	}

	CRect rectFill = rectTab;

#define AFX_POINTS_NUM 5
	POINT pts [AFX_POINTS_NUM];

	const int nHeight = rectFill.Height();

	pts [0].x = rectFill.left;
	pts [0].y = rectFill.bottom;

	pts [1].x = rectFill.left + nHeight;
	pts [1].y = rectFill.top;

	pts [2].x = rectFill.right - 2;
	pts [2].y = rectFill.top;

	pts [3].x = rectFill.right;
	pts [3].y = rectFill.top + 2;

	pts [4].x = rectFill.right;
	pts [4].y = rectFill.bottom;

	BOOL bIsCutted = FALSE;

	for (int i = 0; i < AFX_POINTS_NUM; i++)
	{
		if (pts [i].x > rectClip.right)
		{
			pts [i].x = rectClip.right;
			bIsCutted = TRUE;
		}

		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
		{
			pts [i].y = rectFill.bottom - pts [i].y + rectFill.top;
		}
	}

	CRgn rgn;
	rgn.CreatePolygonRgn(pts, AFX_POINTS_NUM, WINDING);

	pDC->SelectClipRgn(&rgn);

	CRect rectLeft;
	pTabWnd->GetClientRect(rectLeft);
	rectLeft.right = rectClip.left - 1;

	pDC->ExcludeClipRect(rectLeft);

	CDrawingManager dm(*pDC);

	COLORREF clrFill = bIsHighlight ? m_clrHighlightMenuItem : clrTab;
	COLORREF clr2;

	if (clrFill != (COLORREF)-1)
	{
		clr2 = CDrawingManager::PixelAlpha(clrFill, 1.22, 1.22, 1.22);
	}
	else
	{
		clrFill = m_clrToolBarGradientDark;
		clr2 = m_clrToolBarGradientLight;
	}

	if (pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM)
	{
		rectFill.top++;
	}

	CRect rectTop = rectFill;
	rectTop.bottom = rectTop.CenterPoint().y - 1;

	CBrush brTop(clr2);
	pDC->FillRect(rectTop, &brTop);

	CRect rectMiddle = rectFill;
	rectMiddle.top = rectTop.bottom;
	rectMiddle.bottom = rectMiddle.top + 3;

	dm.FillGradient(rectMiddle, clrFill, clr2);

	CRect rectBottom = rectFill;
	rectBottom.top = rectMiddle.bottom;

	CBrush brBottom(clrFill);
	pDC->FillRect(rectBottom, &brBottom);

	pDC->SelectClipRgn(NULL);

	pDC->ExcludeClipRect(rectLeft);

	if (iTab > 0 && !bIsActive && iTab != pTabWnd->GetFirstVisibleTabNum())
	{
		CRect rectLeftTab = rectClip;
		rectLeftTab.right = rectFill.left + rectFill.Height() - 10;

		if (pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM)
		{
			rectLeftTab.top -= 2;
		}
		else
		{
			rectLeftTab.bottom++;
		}

		pDC->ExcludeClipRect(rectLeftTab);
	}

	CPen penGray(PS_SOLID, 1, afxGlobalData.clrBarDkShadow);
	CPen penShadow(PS_SOLID, 1, afxGlobalData.clrBarShadow);

	CPen* pOldPen = pDC->SelectObject(&penGray);
	CBrush* pOldBrush = (CBrush*) pDC->SelectStockObject(NULL_BRUSH);

	pDC->Polyline(pts, AFX_POINTS_NUM);

	if (bIsCutted)
	{
		pDC->MoveTo(rectClip.right, rectTab.top);
		pDC->LineTo(rectClip.right, rectTab.bottom);
	}

	CRect rectRight = rectClip;
	rectRight.left = rectFill.right;

	pDC->ExcludeClipRect(rectRight);

	CPen penLight(PS_SOLID, 1, afxGlobalData.clrBarHilite);

	pDC->SelectObject(&penLight);

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
	}
	else
	{
		pDC->MoveTo(rectFill.left + 1, rectFill.bottom);
		pDC->LineTo(rectFill.left + nHeight, rectFill.top + 1);
		pDC->LineTo(rectFill.right - 1, rectFill.top + 1);
	}

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldBrush);

	if (bIsActive)
	{
		const int iBarHeight = 1;
		const int y = (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM) ? (rectTab.top - iBarHeight) :(rectTab.bottom);

		CRect rectFillTab(CPoint(rectTab.left + 2, y), CSize(rectTab.Width() - 1, iBarHeight));

		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
		{
			rectFillTab.OffsetRect(-1, 1);
		}

		rectFillTab.right = min(rectFillTab.right, rectClip.right);

		CBrush br(clrTab);
		pDC->FillRect(rectFillTab, &br);
	}

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rectTab.left += rectTab.Height() + CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN;
	}
	else
	{
		rectTab.left += rectTab.Height();
		rectTab.right -= CMFCBaseTabCtrl::AFX_TAB_IMAGE_MARGIN;
	}

	COLORREF clrText = pTabWnd->GetTabTextColor(iTab);

	COLORREF cltTextOld = (COLORREF)-1;
	if (!bIsActive && clrText != (COLORREF)-1)
	{
		cltTextOld = pDC->SetTextColor(clrText);
	}

	rectTab.right = min(rectTab.right, rectClip.right - 2);

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd, (COLORREF)-1);

	if (cltTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(cltTextOld);
	}

	pDC->SelectClipRgn(NULL);
}

void CMFCVisualManagerOffice2003::OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsFlatTab() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pTabWnd->IsDialogControl())
	{
		CMFCVisualManagerOfficeXP::OnFillTab(pDC, rectFill, pbrFill, iTab, bIsActive, pTabWnd);
		return;
	}

	ASSERT_VALID(pDC);

	COLORREF clr1 = CDrawingManager::PixelAlpha(m_clrBarGradientDark, 105);

	if (pTabWnd->GetTabBkColor(iTab) != (COLORREF)-1)
	{
		clr1 = pTabWnd->GetTabBkColor(iTab);

		if (clr1 == afxGlobalData.clrWindow && bIsActive)
		{
			pDC->FillRect(rectFill, &afxGlobalData.brWindow);
			return;
		}
	}
	else
	{
		if (m_bAlwaysFillTab)
		{
			if (bIsActive)
			{
				pDC->FillRect(rectFill, &afxGlobalData.brWindow);
				return;
			}
		}
		else
		{
			if (pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
			{
				if (bIsActive)
				{
					pDC->FillRect(rectFill, &afxGlobalData.brWindow);
					return;
				}
			}
			else if (!bIsActive)
			{
				return;
			}
		}
	}

	COLORREF clr2 = CDrawingManager::PixelAlpha(clr1, 120);

	CDrawingManager dm(*pDC);

	if (pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_TOP)
	{
		dm.FillGradient(rectFill, clr1, clr2, TRUE);
	}
	else
	{
		dm.FillGradient(rectFill, clr2, clr1, TRUE);
	}
}

BOOL CMFCVisualManagerOffice2003::OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsFlatTab() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pTabWnd->IsDialogControl())
	{
		return CMFCVisualManagerOfficeXP::OnEraseTabsFrame(pDC, rect, pTabWnd);
	}

	COLORREF clrActiveTab = pTabWnd->GetTabBkColor(pTabWnd->GetActiveTab());
	if (clrActiveTab == (COLORREF)-1 && (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style()))
	{
		pDC->FillRect(rect, &afxGlobalData.brWindow);
		return TRUE;
	}

	CDrawingManager dm(*pDC);

	COLORREF clr1 = m_clrBarGradientDark;

	if (clrActiveTab != (COLORREF)-1)
	{
		clr1 = clrActiveTab;
	}

	COLORREF clr2 = CDrawingManager::PixelAlpha(clr1, 130);

	if (pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM)
	{
		COLORREF clr = clr1;
		clr1 = clr2;
		clr2 = clr;
	}

	dm.FillGradient2(rect, clr1, clr2, 45);
	return TRUE;
}

void CMFCVisualManagerOffice2003::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pBaseTab)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pBaseTab);

	CMFCTabCtrl* pWndTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, pBaseTab);

	if (pWndTab == NULL || pBaseTab->IsFlatTab() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pBaseTab->IsDialogControl())
	{
		CMFCVisualManagerOfficeXP::OnEraseTabsButton(pDC, rect, pButton, pBaseTab);
		return;
	}

	if ((pBaseTab->IsOneNoteStyle() || pBaseTab->IsVS2005Style()) && (pButton->IsPressed() || pButton->IsHighlighted()))
	{
		CDrawingManager dm(*pDC);

		if (pButton->IsPressed())
		{
			dm.FillGradient(rect, m_clrHighlightDnGradientDark, m_clrHighlightDnGradientLight);
		}
		else
		{
			dm.FillGradient(rect, m_clrHighlightGradientDark, m_clrHighlightGradientLight);
		}

		return;
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rect);

	pDC->SelectClipRgn(&rgn);

	CRect rectTabs;
	pWndTab->GetClientRect(&rectTabs);

	CRect rectTabArea;
	pWndTab->GetTabsRect(rectTabArea);

	if (pWndTab->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rectTabs.top = rectTabArea.top;
	}
	else
	{
		rectTabs.bottom = rectTabArea.bottom;
	}

	pWndTab->MapWindowPoints(pButton, rectTabs);
	OnEraseTabsArea(pDC, rectTabs, pWndTab);

	pDC->SelectClipRgn(NULL);
}

void CMFCVisualManagerOffice2003::OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT /*uiState*/, CMFCBaseTabCtrl* /*pWndTab*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsPushed() || pButton->IsHighlighted())
	{
		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOffice2003::ModifyGlobalColors()
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || !m_bIsStandardWinXPTheme || afxGlobalData.IsHighContrastMode())
	{
		//----------------------------------------------
		// Theme color may differ from the system color:
		//----------------------------------------------
		afxGlobalData.clrBarFace = GetThemeColor(m_hThemeButton, COLOR_3DFACE);
		afxGlobalData.clrBarShadow = GetThemeColor(m_hThemeButton, COLOR_3DSHADOW);
		afxGlobalData.clrBarHilite = GetThemeColor(m_hThemeButton, COLOR_3DHIGHLIGHT);
		afxGlobalData.clrBarDkShadow = GetThemeColor(m_hThemeButton, COLOR_3DDKSHADOW);
		afxGlobalData.clrBarLight = GetThemeColor(m_hThemeButton, COLOR_3DLIGHT);
	}
	else
	{
		COLORREF clrBase = GetBaseThemeColor();

		if (m_WinXPTheme == WinXpTheme_Olive)
		{
			COLORREF clrToolBarGradientDark = CDrawingManager::PixelAlpha(clrBase, 120);

			COLORREF clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1., 2, 1);

			afxGlobalData.clrBarFace = CDrawingManager::SmartMixColors(clrToolBarGradientDark, clrToolBarGradientLight, 1., 2, 1);
		}
		else if (m_WinXPTheme == WinXpTheme_Silver)
		{
			COLORREF clrToolBarGradientDark = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_3DFACE), 0.75, 2);
			COLORREF clrToolBarGradientLight = CDrawingManager::SmartMixColors(clrBase, GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1.03);

			afxGlobalData.clrBarFace = CDrawingManager::PixelAlpha(CDrawingManager::SmartMixColors(clrToolBarGradientDark, clrToolBarGradientLight), 95);
		}
		else
		{
			afxGlobalData.clrBarFace = CDrawingManager::SmartMixColors(GetThemeColor(m_hThemeWindow, /*COLOR_HIGHLIGHT*/29), GetThemeColor(m_hThemeWindow, COLOR_WINDOW));
		}

		afxGlobalData.clrBarShadow = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 70);
		afxGlobalData.clrBarHilite = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 130);
		afxGlobalData.clrBarDkShadow = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 50);
		afxGlobalData.clrBarLight = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 110);
	}

	afxGlobalData.brBarFace.DeleteObject();
	afxGlobalData.brBarFace.CreateSolidBrush(afxGlobalData.clrBarFace);
}

void __stdcall CMFCVisualManagerOffice2003::SetUseGlobalTheme(BOOL bUseGlobalTheme/* = TRUE*/)
{
	m_bUseGlobalTheme = bUseGlobalTheme;

	CMFCVisualManager::GetInstance()->OnUpdateSystemColors();
	CMFCVisualManager::GetInstance()->RedrawAll();
}

void __stdcall CMFCVisualManagerOffice2003::SetStatusBarOfficeXPLook(BOOL bStatusBarOfficeXPLook/* = TRUE*/)
{
	m_bStatusBarOfficeXPLook = bStatusBarOfficeXPLook;

	CMFCVisualManager::GetInstance()->RedrawAll();
}

void __stdcall CMFCVisualManagerOffice2003::SetDefaultWinXPColors(BOOL bDefaultWinXPColors/* = TRUE*/)
{
	m_bDefaultWinXPColors = bDefaultWinXPColors;

	CMFCVisualManager::GetInstance()->OnUpdateSystemColors();
	CMFCVisualManager::GetInstance()->RedrawAll();
}

void CMFCVisualManagerOffice2003::GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack,
	COLORREF& clrHighlight, COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack)
{
	ASSERT_VALID(pTabWnd);

	CMFCVisualManagerOfficeXP::GetTabFrameColors(pTabWnd, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);

	if (pTabWnd->IsOneNoteStyle() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pTabWnd->IsDialogControl() || !m_bIsStandardWinXPTheme)
	{
		return;
	}

	COLORREF clrActiveTab = pTabWnd->GetTabBkColor(pTabWnd->GetActiveTab());

	if (clrActiveTab == (COLORREF)-1)
	{
		clrFace = afxGlobalData.clrWindow;
	}

	clrDark = afxGlobalData.clrBarShadow;
	clrBlack = afxGlobalData.clrBarDkShadow;
	clrHighlight = pTabWnd->IsVS2005Style() ? afxGlobalData.clrBarShadow : afxGlobalData.clrBarLight;
	clrDarkShadow = afxGlobalData.clrBarShadow;
	clrLight = afxGlobalData.clrBarFace;
}

void CMFCVisualManagerOffice2003::OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillTasksPaneBackground(pDC, rectWorkArea);
		return;
	}

	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rectWorkArea, m_clrTaskPaneGradientDark, m_clrTaskPaneGradientLight, TRUE);
}

void CMFCVisualManagerOffice2003::OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted /*= FALSE*/, BOOL bIsSelected /*= FALSE*/, BOOL bCanCollapse /*= FALSE*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);
	ASSERT_VALID(pGroup->m_pPage);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawTasksGroupCaption(pDC, pGroup, bIsHighlighted, bIsSelected, bCanCollapse);
		return;
	}

	CRect rectGroup = pGroup->m_rect;

	// -----------------------
	// Draw caption background
	// -----------------------
	POINT pts [7];

	const int nLeft = pGroup->m_rect.left;
	const int nTop = pGroup->m_rect.top;

	pts [0].x = nLeft;
	pts [0].y = pGroup->m_rect.bottom;

	pts [1].x = nLeft;
	pts [1].y = nTop + 4;

	pts [2].x = nLeft + 1;
	pts [2].y = nTop + 2;

	pts [3].x = nLeft + 2;
	pts [3].y = nTop + 1;

	pts [4].x = nLeft + 4;
	pts [4].y = nTop;

	pts [5].x = pGroup->m_rect.right;
	pts [5].y = nTop;

	pts [6].x = pGroup->m_rect.right;
	pts [6].y = pGroup->m_rect.bottom;

	CRgn rgn;
	rgn.CreatePolygonRgn(pts, 7, WINDING);

	pDC->SelectClipRgn(&rgn);

	CDrawingManager dm(*pDC);

	if (pGroup->m_bIsSpecial)
	{
		dm.FillGradient(pGroup->m_rect, m_clrTaskPaneGroupCaptionSpecDark, m_clrTaskPaneGroupCaptionSpecLight, FALSE);
	}
	else
	{
		dm.FillGradient(pGroup->m_rect, m_clrTaskPaneGroupCaptionLight, m_clrTaskPaneGroupCaptionDark, FALSE);
	}

	pDC->SelectClipRgn(NULL);

	// ---------------------------
	// Draw an icon if it presents
	// ---------------------------
	BOOL bShowIcon = (pGroup->m_hIcon != NULL && pGroup->m_sizeIcon.cx < rectGroup.Width() - rectGroup.Height());
	if (bShowIcon)
	{
		OnDrawTasksGroupIcon(pDC, pGroup, 5, bIsHighlighted, bIsSelected, bCanCollapse);
	}

	// -----------------------
	// Draw group caption text
	// -----------------------
	CFont* pFontOld = pDC->SelectObject(&afxGlobalData.fontBold);
	COLORREF clrTextOld = pDC->GetTextColor();

	if (bCanCollapse && bIsHighlighted)
	{
		pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ? (pGroup->m_bIsSpecial ? m_clrTaskPaneGroupBorder : afxGlobalData.clrHilite) : pGroup->m_clrTextHot);
	}
	else
	{
		pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ? (pGroup->m_bIsSpecial ? m_clrTaskPaneGroupBorder : afxGlobalData.clrHilite) : pGroup->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	int nTaskPaneHOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionHorzOffset();
	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();
	int nCaptionHOffset = (nTaskPaneHOffset != -1 ? nTaskPaneHOffset : m_nGroupCaptionHorzOffset);

	CRect rectText = rectGroup;
	rectText.left += (bShowIcon ? pGroup->m_sizeIcon.cx + 5: nCaptionHOffset);
	rectText.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectText.right = max(rectText.left, rectText.right -(bCanCollapse ? rectGroup.Height() : nCaptionHOffset));

	pDC->DrawText(pGroup->m_strName, rectText, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);

	// -------------------------
	// Draw group caption button
	// -------------------------
	if (bCanCollapse && !pGroup->m_strName.IsEmpty())
	{
		CSize sizeButton = CMenuImages::Size();
		CRect rectButton = rectGroup;
		rectButton.left = max(rectButton.left, rectButton.right -(rectButton.Height()+1)/2 -(sizeButton.cx+1)/2);
		rectButton.top = max(rectButton.top, rectButton.bottom -(rectButton.Height()+1)/2 -(sizeButton.cy+1)/2);
		rectButton.right = rectButton.left + sizeButton.cx;
		rectButton.bottom = rectButton.top + sizeButton.cy;

		if (rectButton.right <= rectGroup.right && rectButton.bottom <= rectGroup.bottom)
		{
			if (bIsHighlighted)
			{
				// Draw button frame
				CBrush* pBrushOld = (CBrush*) pDC->SelectObject(&afxGlobalData.brBarFace);
				COLORREF clrBckOld = pDC->GetBkColor();

				pDC->Draw3dRect(&rectButton, afxGlobalData.clrWindow, afxGlobalData.clrBarShadow);

				pDC->SetBkColor(clrBckOld);
				pDC->SelectObject(pBrushOld);
			}

			if (!pGroup->m_bIsCollapsed)
			{
				CMenuImages::Draw(pDC, CMenuImages::IdArrowUp, rectButton.TopLeft());
			}
			else
			{
				CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectButton.TopLeft());
			}
		}
	}
}

void CMFCVisualManagerOffice2003::OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial /*= FALSE*/)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillTasksGroupInterior(pDC, rect, bSpecial);
		return;
	}

	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);
	if (bSpecial)
	{
		dm.FillGradient(rect, m_clrTaskPaneGroupCaptionSpecDark, m_clrTaskPaneGroupCaptionSpecLight, TRUE);
	}
	else
	{
		dm.FillGradient(rect, m_clrTaskPaneGroupAreaDark, m_clrTaskPaneGroupAreaLight, TRUE);
	}
}

void CMFCVisualManagerOffice2003::OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL /*bSpecial = FALSE*/, BOOL /*bNoTitle = FALSE*/)
{
	ASSERT_VALID(pDC);

	// Draw underline
	CPen* pPenOld = (CPen*) pDC->SelectObject(&m_penTaskPaneGroupBorder);

	rect.right -= 1;
	rect.bottom -= 1;
	pDC->MoveTo(rect.left, rect.top);
	pDC->LineTo(rect.right, rect.top);
	pDC->LineTo(rect.right, rect.bottom);
	pDC->LineTo(rect.left, rect.bottom);
	pDC->LineTo(rect.left, rect.top);

	pDC->SelectObject(pPenOld);
}

void CMFCVisualManagerOffice2003::OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted /*= FALSE*/, BOOL bIsSelected /*= FALSE*/)
{
	ASSERT_VALID(pTask);
	ASSERT_VALID(pDC);

	if (pTask->m_bIsSeparator)
	{
		CRect rectText = pTask->m_rect;

		CPen* pPenOld = (CPen*) pDC->SelectObject(&m_penSeparator);

		pDC->MoveTo(rectText.left, rectText.CenterPoint().y);
		pDC->LineTo(rectText.right, rectText.CenterPoint().y);

		pDC->SelectObject(pPenOld);
		return;
	}

	COLORREF clrOld = afxGlobalData.clrHotLinkNormalText;
	afxGlobalData.clrHotLinkNormalText = afxGlobalData.clrHilite;

	CMFCVisualManagerOfficeXP::OnDrawTask(pDC, pTask, pIcons, bIsHighlighted, bIsSelected);

	afxGlobalData.clrHotLinkNormalText = clrOld;
}

void CMFCVisualManagerOffice2003::OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited)
{
	ASSERT_VALID(pDC);

	CRect rectImage(CPoint(0, 0), CMenuImages::Size());

	CRect rectFill = rect;
	rectFill.top -= nBorderSize;

	pDC->FillRect(rectFill, &afxGlobalData.brBarFace);

	if (bHilited)
	{
		CBrush br(afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() ?
			afxGlobalData.clrWindow : m_clrHighlightMenuItem == (COLORREF)-1 ? m_clrHighlight : m_clrHighlightMenuItem);

		pDC->FillRect(rect, &br);
		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
	else
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
	}

	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rect);
}

COLORREF CMFCVisualManagerOffice2003::OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnFillCommandsListBackground(pDC, rect, bIsSelected);
	}

	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	COLORREF clrText = afxGlobalData.clrBarText;

	int nImageWidth = CMFCToolBar::GetMenuImageSize().cx + GetMenuImageMargin();

	if (bIsSelected)
	{
		rect.left = 0;

		COLORREF color = m_clrHighlightMenuItem == (COLORREF)-1 ? m_clrHighlight : m_clrHighlightMenuItem;

		CBrush br(color);
		pDC->FillRect(&rect, &br);

		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);

		// Now, we should define a menu text color...
		if (GetRValue(color) > 128 && GetGValue(color) > 128 && GetBValue(color) > 128)
		{
			clrText = RGB(0, 0, 0);
		}
		else
		{
			clrText = RGB(255, 255, 255);
		}
	}
	else
	{
		pDC->FillRect(rect, &m_brMenuLight);

		CRect rectImages = rect;
		rectImages.right = rectImages.left + nImageWidth + AFX_MENU_IMAGE_MARGIN;

		CDrawingManager dm(*pDC);
		dm.FillGradient(rectImages, m_clrToolBarGradientLight, m_clrToolBarGradientDark, FALSE);

		clrText = afxGlobalData.clrBarText;
	}

	return clrText;
}

void CMFCVisualManagerOffice2003::OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* pStatusBar, CRect rectProgress,
	int nProgressTotal, int nProgressCurr, COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText)
{
	if (!DrawStatusBarProgress(pDC, pStatusBar, rectProgress, nProgressTotal, nProgressCurr, clrBar, clrProgressBarDest, clrProgressText, bProgressText))
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarProgress(pDC, pStatusBar, rectProgress, nProgressTotal, nProgressCurr, clrBar, clrProgressBarDest, clrProgressText, bProgressText);
	}
}

void CMFCVisualManagerOffice2003::OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle)
{
	if (!m_bStatusBarOfficeXPLook || m_hThemeStatusBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarPaneBorder(pDC, pBar, rectPane, uiID, nStyle);
	}

	if (m_hThemeStatusBar != NULL && m_pfDrawThemeBackground != NULL && !(nStyle & SBPS_NOBORDERS))
	{
		(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), SP_PANE, 0, &rectPane, 0);
	}
}

void CMFCVisualManagerOffice2003::OnFillHeaderCtrlBackground(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);
	CMFCVisualManagerOfficeXP::OnFillHeaderCtrlBackground(pCtrl, pDC, rect);
}

COLORREF CMFCVisualManagerOffice2003::OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnDrawPaneCaption(pDC, pBar, bActive, rectCaption, rectButtons);
	}

	CDrawingManager dm(*pDC);

	if (!bActive)
	{
		dm.FillGradient(rectCaption, m_clrToolBarGradientDark, m_clrToolBarGradientLight, TRUE);
	}
	else
	{
		dm.FillGradient(rectCaption,  m_clrHighlightGradientDark, m_clrHighlightGradientLight, TRUE);
	}

	return afxGlobalData.clrBarText;
}

void CMFCVisualManagerOffice2003::OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillAutoHideButtonBackground(pDC, rect, pButton);
		return;
	}

	CDrawingManager dm(*pDC);

	if (pButton->IsActive())
	{
		dm.FillGradient(rect, m_clrHighlightGradientLight, m_clrHighlightGradientDark, pButton->IsHorizontal());
	}
	else
	{
		dm.FillGradient(rect, m_clrBarGradientLight, m_clrBarGradientDark, pButton->IsHorizontal());
	}
}

void CMFCVisualManagerOffice2003::OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* pButton)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawAutoHideButtonBorder(pDC, rectBounds, rectBorderSize, pButton);
		return;
	}

	COLORREF clr = afxGlobalData.clrBarShadow;
	COLORREF clrText = pDC->GetTextColor();

	if (rectBorderSize.left > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.top, rectBounds.left + rectBorderSize.left, rectBounds.bottom, clr);
	}
	if (rectBorderSize.top > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.top, rectBounds.right, rectBounds.top + rectBorderSize.top, clr);
	}
	if (rectBorderSize.right > 0)
	{
		pDC->FillSolidRect(rectBounds.right - rectBorderSize.right, rectBounds.top, rectBounds.right, rectBounds.bottom, clr);
	}
	if (rectBorderSize.bottom > 0)
	{
		pDC->FillSolidRect(rectBounds.left, rectBounds.bottom - rectBorderSize.bottom, rectBounds.right, rectBounds.bottom, clr);
	}

	pDC->SetTextColor(clrText);
}

void CMFCVisualManagerOffice2003::OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawOutlookBarSplitter(pDC, rectSplitter);
		return;
	}

	CDrawingManager dm(*pDC);

	dm.FillGradient(rectSplitter, m_clrCaptionBarGradientDark, m_clrCaptionBarGradientLight, TRUE);

	const int nBoxesNumber = 10;
	const int nBoxSize = rectSplitter.Height() - 3;

	int x = rectSplitter.CenterPoint().x - nBoxSize * nBoxesNumber / 2;
	int y = rectSplitter.top + 2;

	for (int nBox = 0; nBox < nBoxesNumber; nBox++)
	{
		pDC->FillSolidRect(x + 1, y + 1, nBoxSize / 2, nBoxSize / 2, afxGlobalData.clrBtnHilite); pDC->FillSolidRect(x, y, nBoxSize / 2, nBoxSize / 2, m_clrGripper);

		x += nBoxSize;
	}
}

void CMFCVisualManagerOffice2003::OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillOutlookBarCaption(pDC, rectCaption, clrText);
		return;
	}

	CDrawingManager dm(*pDC);

	dm.FillGradient(rectCaption, m_clrCaptionBarGradientDark, m_clrCaptionBarGradientLight, TRUE);
	clrText = afxGlobalData.clrBarHilite;
}

BOOL CMFCVisualManagerOffice2003::OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* /*pEdit*/, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& /*clrText*/)
{
	ASSERT_VALID(pDC);

	CRect rectFrame = rect;
	rectFrame.InflateRect(0, 1, 1, 1);

	switch(state)
	{
	case ButtonsIsPressed:
		OnFillHighlightedArea(pDC, rect, &m_brHighlightDn, NULL);
		pDC->Draw3dRect(&rectFrame, m_clrToolBarGradientDark, m_clrToolBarGradientDark);
		break;

	case ButtonsIsHighlighted:
		OnFillHighlightedArea(pDC, rect, &m_brHighlight, NULL);
		pDC->Draw3dRect(&rectFrame, m_clrToolBarGradientDark, m_clrToolBarGradientDark);
		break;

	default:
		{
			CDrawingManager dm(*pDC);

			dm.FillGradient(rect, afxGlobalData.clrBtnFace, afxGlobalData.clrBtnHilite);
			pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
		}
		break;
	}

	return TRUE;
}

COLORREF CMFCVisualManagerOffice2003::GetWindowColor() const
{
	return GetThemeColor(m_hThemeWindow, COLOR_WINDOW);
}

void CMFCVisualManagerOffice2003::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	ASSERT_VALID(pDC);

	rectRarelyUsed.left --;
	rectRarelyUsed.right = rectRarelyUsed.left + CMFCToolBar::GetMenuImageSize().cx + 2 * GetMenuImageMargin() + 2;

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnHighlightRarelyUsedMenuItems(pDC, rectRarelyUsed);
		return;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rectRarelyUsed, m_clrMenuRarelyUsed, m_clrToolBarGradientDark, FALSE);
}

void CMFCVisualManagerOffice2003::OnDrawControlBorder(CWnd* pWndCtrl)
{
	if (m_hThemeComboBox == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawControlBorder(pWndCtrl);
		return;
	}

	ASSERT_VALID(pWndCtrl);

	CWindowDC dc(pWndCtrl);

	CRect rect;
	pWndCtrl->GetWindowRect(rect);

	rect.bottom -= rect.top;
	rect.right -= rect.left;
	rect.left = rect.top = 0;

	COLORREF clrBorder = (COLORREF)-1;

	if ((m_pfGetThemeColor == NULL) || ((*m_pfGetThemeColor)(m_hThemeComboBox, 5, 0, 3801, &clrBorder) != S_OK))
	{
		CMFCVisualManagerOfficeXP::OnDrawControlBorder(pWndCtrl);
		return;
	}

	dc.Draw3dRect(&rect, clrBorder, clrBorder);

	rect.DeflateRect(1, 1);
	dc.Draw3dRect(rect, afxGlobalData.clrWindow, afxGlobalData.clrWindow);
}

void CMFCVisualManagerOffice2003::OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox)
{
	ASSERT_VALID(pDC);

	if (m_hThemeTree == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawExpandingBox(pDC, rect, bIsOpened, colorBox);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeTree, pDC->GetSafeHdc(), TVP_GLYPH, bIsOpened ? GLPS_OPENED : GLPS_CLOSED, &rect, 0);
	}
}

void CMFCVisualManagerOffice2003::GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder)
{
	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		clrBaseGroupBackground = RGB(228, 228, 228);
		clrBaseGroupBorder = RGB(181, 181, 181);
	}
	else
	{
		clrBaseGroupBackground = afxGlobalData.clrBarFace;
		clrBaseGroupBorder = afxGlobalData.clrBarShadow;
	}
}

COLORREF CMFCVisualManagerOffice2003::GetSmartDockingHighlightToneColor()
{
	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		WinXpTheme theme = GetStandardWindowsTheme();

		switch(theme)
		{
		case WinXpTheme_Blue:
			return RGB(61, 123, 241);

		case WinXpTheme_Olive:
			return RGB(190, 146, 109);

		case WinXpTheme_Silver:
			return RGB(134, 130, 169);
		}
	}

	return CMFCVisualManagerOfficeXP::GetSmartDockingHighlightToneColor();
}

void CMFCVisualManagerOffice2003::OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox)
{
	if (m_hThemeScrollBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarSizeBox(pDC, pStatBar, rectSizeBox);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeScrollBar, pDC->GetSafeHdc(), SBP_SIZEBOX, SZB_RIGHTALIGN, &rectSizeBox, 0);
	}
}

COLORREF CMFCVisualManagerOffice2003::GetBaseThemeColor()
{
	return m_bIsStandardWinXPTheme && m_hThemeWindow != NULL ? GetThemeColor(m_hThemeWindow, 29) : afxGlobalData.clrBarFace;
}

void CMFCVisualManagerOffice2003::OnHighlightQuickCustomizeMenuButton(CDC* pDC, CMFCToolBarMenuButton* /*pButton*/, CRect rect)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.IsHighContrastMode())
	{
		pDC->FillRect(rect, &m_brBarBkgnd);
	}
	else
	{
		CBrush br(m_clrToolBarGradientLight);
		pDC->FillRect(rect, &br);
	}

	pDC->Draw3dRect(rect, m_clrMenuBorder, m_clrMenuBorder);
}

void CMFCVisualManagerOffice2003::OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted)
{
	if (m_hThemeHeader == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawHeaderCtrlBorder(pCtrl, pDC, rect, bIsPressed, bIsHighlighted);
		return;
	}

	int nState = HIS_NORMAL;

	if (bIsPressed)
	{
		nState = HIS_PRESSED;
	}
	else if (bIsHighlighted)
	{
		nState = HIS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeHeader, pDC->GetSafeHdc(), HP_HEADERITEM, nState, &rect, 0);
	}
}

void CMFCVisualManagerOffice2003::OnFillPopupWindowBackground(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnFillPopupWindowBackground(pDC, rect);
		return;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight);
}

void CMFCVisualManagerOffice2003::OnDrawPopupWindowBorder(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
}

COLORREF  CMFCVisualManagerOffice2003::OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnDrawPopupWindowCaption(pDC, rectCaption, pPopupWnd);
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rectCaption, m_clrCaptionBarGradientDark, m_clrCaptionBarGradientLight, TRUE);

	if (pPopupWnd->HasSmallCaption())
	{
		CRect rectGripper = rectCaption;

		int xCenter = rectGripper.CenterPoint().x;
		int yCenter = rectGripper.CenterPoint().y;

		rectGripper.left = xCenter - 20;
		rectGripper.right = xCenter + 20;

		rectGripper.top = yCenter - 4;
		rectGripper.bottom = yCenter + 2;

		OnDrawBarGripper(pDC, rectGripper, FALSE, NULL);
	}

	// get the text color
	return afxGlobalData.clrBarHilite;
}

void CMFCVisualManagerOffice2003::OnErasePopupWindowButton(CDC* pDC, CRect rc, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnErasePopupWindowButton(pDC, rc, pButton);
		return;
	}

	if (pButton->IsPressed())
	{
		COLORREF color = m_clrHighlightDnGradientLight == (COLORREF)-1 ? m_clrHighlightDn : m_clrHighlightDnGradientLight;
		CBrush br(color);
		pDC->FillRect(&rc, &br);
		return;
	}
	else if (pButton->IsHighlighted() || pButton->IsPushed())
	{
		COLORREF color = m_clrHighlightMenuItem == (COLORREF)-1 ? m_clrHighlight : m_clrHighlightMenuItem;
		CBrush br(color);
		pDC->FillRect(&rc, &br);
		return;
	}

	CRect rectParent;
	pButton->GetParent()->GetClientRect(rectParent);

	pButton->GetParent()->MapWindowPoints(pButton, rectParent);
	OnFillPopupWindowBackground(pDC, rectParent);
}

void CMFCVisualManagerOffice2003::OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rc, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsHighlighted() || pButton->IsPushed() || pButton->IsCaptionButton())
	{
		pDC->Draw3dRect(rc, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOffice2003::OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled)
{
	if (!DrawCheckBox(pDC, rect, bHighlighted, nState, bEnabled, bPressed))
	{
		CMFCVisualManagerOfficeXP::OnDrawCheckBoxEx(pDC, rect, nState, bHighlighted, bPressed, bEnabled);
	}
}

COLORREF CMFCVisualManagerOffice2003::GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList)
{
	return CMFCVisualManager::GetPropertyGridGroupColor(pPropList);
}

COLORREF CMFCVisualManagerOffice2003::GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList)
{
	return CMFCVisualManager::GetPropertyGridGroupTextColor(pPropList);
}

COLORREF CMFCVisualManagerOffice2003::OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnDrawRibbonCategoryTab(pDC, pTab, bIsActive);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pTab);

	CMFCRibbonCategory* pCategory = pTab->GetParentCategory();
	ASSERT_VALID(pCategory);
	CMFCRibbonBar* pBar = pCategory->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	bIsActive = bIsActive && ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0 || pTab->GetDroppedDown() != NULL);

	const BOOL bIsFocused	= pTab->IsFocused() && (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS);
	const BOOL bIsHighlighted = (pTab->IsHighlighted() || bIsFocused) && !pTab->IsDroppedDown();

	CRect rectTab = pTab->GetRect();
	rectTab.top += 3;

	const int nTruncateRatio = pBar->GetTabTruncateRatio();

	if (nTruncateRatio > 0)
	{
		CRect rectRight = rectTab;
		rectRight.left = rectRight.right - 1;

		const int nPercent = max(10, 100 - nTruncateRatio / 2);

		COLORREF color1 = CDrawingManager::PixelAlpha(afxGlobalData.clrBarShadow, nPercent);
		COLORREF color2 = CDrawingManager::PixelAlpha(color1, 120);

		CDrawingManager dm(*pDC);
		dm.FillGradient(rectRight, color1, color2, TRUE);
	}

	if (!bIsActive && !bIsHighlighted)
	{
		return afxGlobalData.clrBarText;
	}

	rectTab.right -= 2;

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

#define AFX_RIBBONTAB_POINTS_NUM 8
	POINT pts [AFX_RIBBONTAB_POINTS_NUM];

	pts [0] = CPoint(rectTab.left, rectTab.bottom);
	pts [1] = CPoint(rectTab.left + 1, rectTab.bottom - 1);
	pts [2] = CPoint(rectTab.left + 1, rectTab.top + 2);
	pts [3] = CPoint(rectTab.left + 3, rectTab.top);
	pts [4] = CPoint(rectTab.right - 3, rectTab.top);
	pts [5] = CPoint(rectTab.right - 1, rectTab.top + 2);
	pts [6] = CPoint(rectTab.right - 1, rectTab.bottom - 1);
	pts [7] = CPoint(rectTab.right, rectTab.bottom);

	CRgn rgnClip;
	rgnClip.CreatePolygonRgn(pts, AFX_RIBBONTAB_POINTS_NUM, WINDING);

	pDC->SelectClipRgn(&rgnClip);

	CDrawingManager dm(*pDC);

	const BOOL bIsSelected = pTab->IsSelected();

	COLORREF clrFill = bIsSelected ? m_clrHighlightGradientDark : RibbonCategoryColorToRGB(pCategory->GetTabColor());

	COLORREF clr1 = afxGlobalData.clrBarFace;
	COLORREF clr2 = (clrFill == (COLORREF)-1) ? CDrawingManager::PixelAlpha(clr1, 120) : clrFill;

	if (bIsHighlighted)
	{
		if (bIsActive)
		{
			clr2 = m_clrHighlightGradientLight;
		}
		else
		{
			if (clrFill == (COLORREF)-1)
			{
				clr1 = m_clrHighlightGradientDark;
				clr2 = m_clrHighlightGradientLight;
			}
			else
			{
				clr1 = clrFill;
				clr2 = CDrawingManager::PixelAlpha(clr1, 120);
			}
		}
	}

	dm.FillGradient(rectTab, clr1, clr2, TRUE);

	pDC->SelectClipRgn(NULL);

	pDC->Polyline(pts, AFX_RIBBONTAB_POINTS_NUM);

	if (bIsHighlighted && bIsActive && !bIsSelected)
	{
		//---------------------
		// Draw internal frame:
		//---------------------
		const CPoint ptCenter = rectTab.CenterPoint();

		for (int i = 0; i < AFX_RIBBONTAB_POINTS_NUM; i++)
		{
			if (pts [i].x < ptCenter.x)
			{
				pts [i].x++;
			}
			else
			{
				pts [i].x--;
			}

			if (pts [i].y < ptCenter.y)
			{
				pts [i].y++;
			}
			else
			{
				pts [i].y--;
			}
		}

		CPen penInternal(PS_SOLID, 1, m_clrHighlightGradientDark);
		pDC->SelectObject(&penInternal);

		pDC->Polyline(pts, AFX_RIBBONTAB_POINTS_NUM);
		pDC->SelectObject(pOldPen);
	}

	pDC->SelectObject(pOldPen);

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManagerOffice2003::OnDrawRibbonButtonsGroup(CDC* pDC, CMFCRibbonButtonsGroup* pGroup, CRect rect)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);

	if (DYNAMIC_DOWNCAST(CMFCRibbonQuickAccessToolBar, pGroup) != NULL || pGroup->GetCount() == 0)
	{
		return(COLORREF)-1;
	}

	CMFCRibbonBaseElement* pButton = pGroup->GetButton(0);
	ASSERT_VALID(pButton);

	if (!pButton->IsShowGroupBorder())
	{
		return(COLORREF)-1;
	}

	const int dx = 2;
	const int dy = 2;

	CPen pen(PS_SOLID, 1, m_clrToolBarGradientDark);
	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

	CBrush* pOldBrush = (CBrush*) pDC->SelectStockObject(NULL_BRUSH);
	ENSURE(pOldBrush != NULL);

	rect.DeflateRect(1, 1);
	pDC->RoundRect(rect, CPoint(dx, dy));

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldBrush);

	return(COLORREF)-1;
}

COLORREF CMFCVisualManagerOffice2003::OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pContextCaption);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnDrawRibbonCategoryCaption(pDC, pContextCaption);
	}

	COLORREF clrFill = RibbonCategoryColorToRGB(pContextCaption->GetColor());
	CRect rect = pContextCaption->GetRect();

	if (clrFill != (COLORREF)-1)
	{
		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, clrFill, afxGlobalData.clrBarFace, TRUE);
	}

	return afxGlobalData.clrBarText;
}

void CMFCVisualManagerOffice2003::OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawRibbonSliderZoomButton(pDC, pSlider, rect, bIsZoomOut, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	COLORREF clrLine = (bIsPressed || bIsHighlighted) ? afxGlobalData.clrBarDkShadow : afxGlobalData.clrBtnDkShadow;

	CPoint ptCenter = rect.CenterPoint();
	CRect rectCircle(CPoint(ptCenter.x - 7, ptCenter.y - 7), CSize(15, 15));
	CDrawingManager dm(*pDC);

	COLORREF clrFill = (COLORREF)-1;

	if (bIsPressed || bIsHighlighted)
	{
		clrFill = bIsPressed ? m_clrHighlightDnGradientLight : m_clrHighlightDnGradientDark;
	}

	dm.DrawEllipse(rectCircle, clrFill, clrLine);

	// Draw +/- sign:
	CRect rectSign(CPoint(ptCenter.x - 3, ptCenter.y - 3), CSize(7, 7));

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		dm.DrawLine(rectSign.left, ptCenter.y, rectSign.right, ptCenter.y, clrLine);

		if (!bIsZoomOut)
		{
			dm.DrawLine(ptCenter.x, rectSign.top, ptCenter.x, rectSign.bottom, clrLine);
		}
	}
	else
	{
		CPen penLine(PS_SOLID, 1, clrLine);
		CPen* pOldPen = pDC->SelectObject(&penLine);

		pDC->MoveTo(rectSign.left, ptCenter.y);
		pDC->LineTo(rectSign.right, ptCenter.y);

		if (!bIsZoomOut)
		{
			pDC->MoveTo(ptCenter.x, rectSign.top);
			pDC->LineTo(ptCenter.x, rectSign.bottom);
		}

		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManagerOffice2003::OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect)
{
	ASSERT_VALID(pDC);

	if (m_hThemeTrack == NULL || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawRibbonSliderChannel(pDC, pSlider, rect);
		return;
	}

	rect.InflateRect(0, 1);

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeTrack, pDC->GetSafeHdc(), TKP_TRACK, 1, &rect, 0);
	}
}

void CMFCVisualManagerOffice2003::OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	ASSERT_VALID(pDC);

	if (m_hThemeTrack == NULL || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnDrawRibbonSliderThumb(pDC, pSlider, rect, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeTrack, pDC->GetSafeHdc(), TKP_THUMBBOTTOM, bIsPressed ? 3 : bIsHighlighted ? 2 : 1, &rect, 0);
	}
}

COLORREF CMFCVisualManagerOffice2003::OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pPane);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || m_hThemeStatusBar == NULL)
	{
		return CMFCVisualManagerOfficeXP::OnDrawRibbonStatusBarPane(pDC, pBar, pPane);
	}

	CRect rect = pPane->GetRect();

	if (pPane->IsHighlighted())
	{
		CRect rectButton = rect;
		rectButton.DeflateRect(1, 1);

		OnFillHighlightedArea(pDC, rectButton, pPane->IsPressed() ? &m_brHighlightDn : &m_brHighlight, NULL);

		pDC->Draw3dRect(rectButton, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}

	return(COLORREF)-1;
}

void CMFCVisualManagerOffice2003::OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode)
{
	ASSERT_VALID(pDC);

#define PP_BAR 1
#define PP_CHUNK 3

	if (m_hThemeProgress != NULL && m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_BAR, 0, &rectProgress, 0);

		if (!rectChunk.IsRectEmpty())
		{
			rectChunk.DeflateRect(2, 2);
			(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_CHUNK, 0, &rectChunk, 0);
		}
	}
	else
	{
		CMFCVisualManagerOfficeXP::OnDrawRibbonProgressBar(pDC, pProgress, rectProgress, rectChunk, bInfiniteMode);
	}
}

void CMFCVisualManagerOffice2003::OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* /*pSeparator*/, CRect rect)
{
	ASSERT_VALID(pDC);

	int x = rect.CenterPoint().x;

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawLine(x, rect.top, x, rect.bottom - 1, afxGlobalData.clrBarDkShadow);
		dm.DrawLine(x + 1, rect.top + 1, x + 1, rect.bottom, afxGlobalData.clrBarLight);
	}
	else
	{
		CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
		ENSURE(pOldPen != NULL);

		pDC->MoveTo(x, rect.top);
		pDC->LineTo(x, rect.bottom - 1);

		pDC->SelectObject(&m_penSeparatorLight);

		pDC->MoveTo(x + 1, rect.top + 1);
		pDC->LineTo(x + 1, rect.bottom);

		pDC->SelectObject(pOldPen);
	}
}

BOOL CMFCVisualManagerOffice2003::GetToolTipInfo(CMFCToolTipInfo& params, UINT /*nType*/ /*= (UINT)(-1)*/)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::GetToolTipInfo(params);
	}

	params.m_bBoldLabel = TRUE;
	params.m_bDrawDescription = TRUE;
	params.m_bDrawIcon = TRUE;
	params.m_bRoundedCorners = TRUE;
	params.m_bDrawSeparator = FALSE;

	params.m_clrFill = afxGlobalData.clrBarHilite;
	params.m_clrFillGradient = afxGlobalData.clrBarFace;
	params.m_clrText = afxGlobalData.clrBarText;
	params.m_clrBorder = afxGlobalData.clrBarShadow;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxtooltipmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtooltipmanager.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifndef TTM_SETTITLE
#define TTM_SETTITLE(WM_USER + 32)
#endif

UINT AFX_WM_UPDATETOOLTIPS = ::RegisterWindowMessage(_T("AFX_WM_UPDATETOOLTIPS"));
CTooltipManager* afxTooltipManager = NULL;

BOOL __stdcall CTooltipManager::CreateToolTip(CToolTipCtrl*& pToolTip, CWnd* pWndParent, UINT nType)
{
	UINT nCurrType = AFX_TOOLTIP_TYPE_DEFAULT;
	int nIndex = -1;

	for (int i = 0; i < AFX_TOOLTIP_TYPES; i++)
	{
		if (nCurrType == nType)
		{
			nIndex = i;
			break;
		}

		nCurrType <<= 1;
	}

	if (nIndex == -1)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (pToolTip != NULL)
	{
		ASSERT_VALID(pToolTip);

		if (pToolTip->GetSafeHwnd() != NULL)
		{
			pToolTip->DestroyWindow();
		}

		delete pToolTip;
		pToolTip = NULL;
	}

	if (afxTooltipManager != NULL)
	{
		if (!afxTooltipManager->CreateToolTipObject(pToolTip, nIndex))
		{
			return FALSE;
		}
	}
	else
	{
		pToolTip = new CToolTipCtrl;
		ASSERT_VALID(pToolTip);
	}

	if (!pToolTip->Create(pWndParent, TTS_ALWAYSTIP | TTS_NOPREFIX))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pToolTip->Activate(TRUE);

	if (afxGlobalData.m_nMaxToolTipWidth != -1)
	{
		pToolTip->SetMaxTipWidth(afxGlobalData.m_nMaxToolTipWidth);
	}

	if (pWndParent->GetSafeHwnd() != NULL && afxTooltipManager != NULL && afxTooltipManager->m_lstOwners.Find(pWndParent->GetSafeHwnd()) == NULL)
	{
		afxTooltipManager->m_lstOwners.AddTail(pWndParent->GetSafeHwnd());
	}

	return TRUE;
}

void __stdcall CTooltipManager::DeleteToolTip(CToolTipCtrl*& pToolTip)
{
	if (pToolTip != NULL)
	{
		ASSERT_VALID(pToolTip);

		if (pToolTip->GetSafeHwnd() != NULL)
		{
			HWND hwndParent = pToolTip->GetParent()->GetSafeHwnd();

			if (afxTooltipManager != NULL && hwndParent != NULL)
			{
				POSITION pos = afxTooltipManager->m_lstOwners.Find(hwndParent);
				if (pos != NULL)
				{
					afxTooltipManager->m_lstOwners.RemoveAt(pos);
				}
			}

			pToolTip->DestroyWindow();
		}

		delete pToolTip;
		pToolTip = NULL;
	}
}

void __stdcall CTooltipManager::SetTooltipText(TOOLINFO* pTI, CToolTipCtrl* pToolTip, UINT nType, const CString strText, LPCTSTR lpszDescr)
{
	if (pToolTip == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	if (pTI == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pToolTip);

	int nIndex = -1;
	UINT nCurrType = AFX_TOOLTIP_TYPE_DEFAULT;

	for (int i = 0; i < AFX_TOOLTIP_TYPES; i++)
	{
		if (nCurrType == nType)
		{
			nIndex = i;
			break;
		}

		nCurrType <<= 1;
	}

	if (nIndex == -1)
	{
		ASSERT(FALSE);
		return;
	}

	CString strTipText = strText;
	CString strDescr = lpszDescr != NULL ? lpszDescr : _T("");

	if (afxTooltipManager != NULL && afxTooltipManager->m_Params [nIndex].m_bBalloonTooltip)
	{
		if (strDescr.IsEmpty())
		{
			pToolTip->SendMessage(TTM_SETTITLE, 1, (LPARAM)(LPCTSTR) strDescr);
		}
		else
		{
			pToolTip->SendMessage(TTM_SETTITLE, 1, (LPARAM)(LPCTSTR) strText);
			strTipText = strDescr;
		}
	}

	pTI->lpszText = (LPTSTR) ::calloc((strTipText.GetLength() + 1), sizeof(TCHAR));
	if (pTI->lpszText == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	lstrcpy(pTI->lpszText, strTipText);

	CMFCToolTipCtrl* pToolTipEx = DYNAMIC_DOWNCAST(CMFCToolTipCtrl, pToolTip);

	if (pToolTipEx != NULL)
	{
		pToolTipEx->SetDescription(strDescr);
	}
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTooltipManager::CTooltipManager()
{
	ENSURE(afxTooltipManager == NULL);
	afxTooltipManager = this;

	for (int i = 0; i < AFX_TOOLTIP_TYPES; i++)
	{
		m_pRTC [i] = NULL;
	}
}

CTooltipManager::~CTooltipManager()
{
	afxTooltipManager = NULL;
}

BOOL CTooltipManager::CreateToolTipObject(CToolTipCtrl*& pToolTip, UINT nType)
{
	if (nType < 0 || nType >= AFX_TOOLTIP_TYPES)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCToolTipInfo& params = m_Params [nType];
	CRuntimeClass* pRTC = m_pRTC [nType];

	if (pRTC == NULL)
	{
		pToolTip = new CToolTipCtrl;
	}
	else
	{
		pToolTip = DYNAMIC_DOWNCAST(CToolTipCtrl, pRTC->CreateObject());
	}

	if (pToolTip == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(pToolTip);

	CMFCToolTipCtrl* pToolTipEx = DYNAMIC_DOWNCAST(CMFCToolTipCtrl, pToolTip);

	if (pToolTipEx != NULL)
	{
		pToolTipEx->SetParams(&params);
	}

	return TRUE;
}

void CTooltipManager::SetTooltipParams(UINT nTypes, CRuntimeClass* pRTC, CMFCToolTipInfo* pParams)
{
	if (pRTC == NULL || !pRTC->IsDerivedFrom(RUNTIME_CLASS(CMFCToolTipCtrl)))
	{
		if (pParams != NULL)
		{
			// Parameters can be used with CMFCToolTipCtrl class only!
			ASSERT(FALSE);
			pParams = NULL;
		}
	}

	CMFCToolTipInfo defaultParams;

	UINT nType = AFX_TOOLTIP_TYPE_DEFAULT;

	for (int i = 0; i < AFX_TOOLTIP_TYPES; i++)
	{
		if ((nType & nTypes) != 0)
		{
			if (pParams == NULL)
			{
				m_Params [i] = defaultParams;
			}
			else
			{
				m_Params [i] = *pParams;
			}

			m_pRTC [i] = pRTC;
		}

		nType <<= 1;
	}

	for (POSITION pos = m_lstOwners.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndOwner = m_lstOwners.GetNext(pos);

		if (::IsWindow(hwndOwner))
		{
			::SendMessage(hwndOwner, AFX_WM_UPDATETOOLTIPS, (WPARAM) nTypes, 0);
		}
	}
}

void CTooltipManager::UpdateTooltips()
{
	for (POSITION pos = m_lstOwners.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndOwner = m_lstOwners.GetNext(pos);

		if (::IsWindow(hwndOwner))
		{
			::SendMessage(hwndOwner, AFX_WM_UPDATETOOLTIPS, (WPARAM) AFX_TOOLTIP_TYPE_ALL, 0);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanageroffice2007.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.


#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobalutils.h"
#include "afxvisualmanageroffice2007.h"
#include "afxtoolbar.h"
#include "afxdrawmanager.h"
#include "afxpopupmenubar.h"
#include "afxmenubar.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxcustomizebutton.h"
#include "afxmenuimages.h"
#include "afxcaptionbar.h"
#include "afxbasetabctrl.h"
#include "afxcolorbar.h"
#include "afxtabctrl.h"
#include "afxtaskspane.h"
#include "afxstatusbar.h"
#include "afxautohidebutton.h"
#include "afxheaderctrl.h"
#include "afxrebar.h"
#include "afxdesktopalertwnd.h"
#include "afxdropdowntoolbar.h"
#include "afxtagmanager.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxdockablepane.h"
#include "afxoutlookbartabctrl.h"
#include "afxtoolbarcomboboxbutton.h"

#include "afxribbonbar.h"
#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonquickaccesstoolbar.h"
#include "afxribboncombobox.h"
#include "afxribbonmainpanel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonlabel.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonprogressbar.h"
#include "afxribbonlinkctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_RT_STYLE_XML _T("STYLE_XML")

const CMFCVisualManagerOffice2007::Style c_StyleDefault = CMFCVisualManagerOffice2007::Office2007_LunaBlue;
CMFCVisualManagerOffice2007::Style CMFCVisualManagerOffice2007::m_Style = c_StyleDefault;
CString CMFCVisualManagerOffice2007::m_strStylePrefix;
HINSTANCE CMFCVisualManagerOffice2007::m_hinstRes = NULL;
BOOL CMFCVisualManagerOffice2007::m_bAutoFreeRes = FALSE;

CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::CMFCVisualManagerBitmapCacheItem()
{
	m_bMirror = FALSE;
}

CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::~CMFCVisualManagerBitmapCacheItem()
{
}

void CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::AddImage(HBITMAP hBmp)
{
	m_Images.AddImage(hBmp, TRUE);
}

void CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::Cache(const CSize& size, CMFCControlRenderer& renderer)
{
	m_Images.Clear();

	const int nCount = renderer.GetImageCount();

	if (nCount > 0)
	{
		m_Images.SetImageSize(size);
		m_Images.SetTransparentColor((COLORREF)-1);

		for (int i = 0; i < nCount; i++)
		{
			BITMAPINFO bi;
			memset(&bi, 0, sizeof(BITMAPINFO));

			// Fill in the BITMAPINFOHEADER
			bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
			bi.bmiHeader.biWidth       = size.cx;
			bi.bmiHeader.biHeight      = size.cy;
			bi.bmiHeader.biPlanes      = 1;
			bi.bmiHeader.biBitCount    = 32;
			bi.bmiHeader.biCompression = BI_RGB;
			bi.bmiHeader.biSizeImage   = size.cy * size.cx * 4;

			LPBYTE pBits = NULL;
			HBITMAP hDib = ::CreateDIBSection(NULL, &bi, DIB_RGB_COLORS, (void **)&pBits, NULL, NULL);

			if (hDib == NULL || pBits == NULL)
			{
				ASSERT(FALSE);
				break;
			}

			CDC dc;
			dc.CreateCompatibleDC(NULL);

			HBITMAP hOldDib = (HBITMAP)::SelectObject(dc.GetSafeHdc(), hDib);

			m_bMirror = renderer.IsMirror();
			if (m_bMirror)
			{
				renderer.Mirror();
			}

			renderer.Draw(&dc, CRect(0, 0, size.cx, size.cy), i);

			if (m_bMirror)
			{
				renderer.Mirror();
			}

			::SelectObject(dc.GetSafeHdc(), hOldDib);

			AddImage(hDib);

			::DeleteObject(hDib);
		}
	}
}

void CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::Draw(CDC* pDC, CRect rect, int iImageIndex/* = 0*/, BYTE alphaSrc/* = 255*/)
{
	m_Images.DrawEx(pDC, CRect(rect.TopLeft(), m_Images.GetImageSize()), iImageIndex, CMFCToolBarImages::ImageAlignHorzLeft,
		CMFCToolBarImages::ImageAlignVertTop, CRect(0, 0, 0, 0), alphaSrc);
}

void CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem::DrawY(CDC* pDC, CRect rect, CSize sides, int iImageIndex/* = 0*/, BYTE alphaSrc/* = 255*/)
{
	CRect rectImage(CPoint(0, 0), m_Images.GetImageSize());

	ASSERT(rect.Height() == rectImage.Height());

	if (sides.cx > 0)
	{
		CRect rt(rectImage);
		if (m_bMirror)
		{
			rt.left = rectImage.right - sides.cx;
			rectImage.right = rt.left;
		}
		else
		{
			rt.right = rt.left + sides.cx;
			rectImage.left = rt.right;
		}

		m_Images.DrawEx(pDC, rect, iImageIndex, CMFCToolBarImages::ImageAlignHorzLeft, CMFCToolBarImages::ImageAlignVertTop, rt, alphaSrc);
	}

	if (sides.cy > 0)
	{
		CRect rt(rectImage);
		if (m_bMirror)
		{
			rt.right = rectImage.left + sides.cy;
			rectImage.left = rt.right;
		}
		else
		{
			rt.left = rectImage.right - sides.cy;
			rectImage.right = rt.left;
		}

		m_Images.DrawEx(pDC, rect, iImageIndex, CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertTop, rt, alphaSrc);
	}

	if (rectImage.Width() > 0)
	{
		rect.DeflateRect(sides.cx, 0, sides.cy, 0);
		m_Images.DrawEx(pDC, rect, iImageIndex, CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertTop, rectImage, alphaSrc);
	}
}

CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCache()
{
}

CMFCVisualManagerBitmapCache::~CMFCVisualManagerBitmapCache()
{
	Clear();
}

void CMFCVisualManagerBitmapCache::Clear()
{
	for (int i = 0; i < m_Cache.GetSize(); i++)
	{
		if (m_Cache[i] != NULL)
		{
			delete m_Cache[i];
		}
	}

	m_Cache.RemoveAll();
	m_Sizes.RemoveAll();
}

int CMFCVisualManagerBitmapCache::Cache(const CSize& size, CMFCControlRenderer& renderer)
{
	if (FindIndex(size) != -1)
	{
		ASSERT(FALSE);
		return -1;
	}

	CMFCVisualManagerBitmapCacheItem* pItem = new CMFCVisualManagerBitmapCacheItem;
	pItem->Cache(size, renderer);

	int nCache = (int) m_Cache.Add(pItem);
	int nSize  = (int) m_Sizes.Add(size);

	ASSERT(nCache == nSize);

	return nCache;
}

int CMFCVisualManagerBitmapCache::CacheY(int height, CMFCControlRenderer& renderer)
{
	CSize size(renderer.GetParams().m_rectImage.Width(), height);

	return Cache(size, renderer);
}

BOOL CMFCVisualManagerBitmapCache::IsCached(const CSize& size) const
{
	return FindIndex(size) != -1;
}

int CMFCVisualManagerBitmapCache::FindIndex(const CSize& size) const
{
	int nRes = -1;
	for (int i = 0; i < m_Sizes.GetSize(); i++)
	{
		if (size == m_Sizes[i])
		{
			nRes = i;
			break;
		}
	}

	return nRes;
}

CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem* CMFCVisualManagerBitmapCache::Get(const CSize& size)
{
	int nIndex = FindIndex(size);

	if (nIndex != -1)
	{
		return m_Cache[nIndex];
	}

	return NULL;
}

CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem* CMFCVisualManagerBitmapCache::Get(int nIndex)
{
	if (0 <= nIndex && nIndex < m_Cache.GetSize())
	{
		return m_Cache[nIndex];
	}

	return NULL;
}


IMPLEMENT_DYNCREATE(CMFCVisualManagerOffice2007, CMFCVisualManagerOffice2003)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCVisualManagerOffice2007::CMFCVisualManagerOffice2007() : m_bNcTextCenter(FALSE), m_bLoaded(FALSE)
{
	m_szNcBtnSize[0] = CSize(0, 0);
	m_szNcBtnSize[1] = CSize(0, 0);
	m_ptRibbonMainImageOffset = CPoint(0, -1);
}

CMFCVisualManagerOffice2007::~CMFCVisualManagerOffice2007()
{
	CMenuImages::SetColor(CMenuImages::ImageBlack, (COLORREF)-1);
}

CString __stdcall CMFCVisualManagerOffice2007::MakeResourceID(LPCTSTR lpszID)
{
	CString strResID(lpszID);
	ASSERT(!strResID.IsEmpty());

	if (!m_strStylePrefix.IsEmpty())
	{
		strResID = m_strStylePrefix + strResID;
	}

	return strResID;
}

CString __stdcall CMFCVisualManagerOffice2007::GetStyleResourceID(Style style)
{
	CString strResID(_T("IDX_OFFICE2007_STYLE"));
	CString strStylePrefix;

	switch(style)
	{
	case Office2007_LunaBlue:
		strStylePrefix = _T("BLUE_");
		break;

	case Office2007_ObsidianBlack:
		strStylePrefix = _T("BLACK_");
		break;

	case Office2007_Aqua:
		strStylePrefix = _T("AQUA_");
		break;

	case Office2007_Silver:
		strStylePrefix = _T("SILVER_");
		break;

	default:
		ASSERT(FALSE);
	}

	strResID = strStylePrefix + strResID;
	return strResID;
};

BOOL __stdcall CMFCVisualManagerOffice2007::SetStyle(Style style, LPCTSTR lpszPath)
{
	if (m_Style == style && m_hinstRes >(HINSTANCE) 32)
	{
		return TRUE;
	}

	UNREFERENCED_PARAMETER(lpszPath);
	CString strStyle(GetStyleResourceID(style));
	HINSTANCE hinstRes = AfxFindResourceHandle(strStyle, AFX_RT_STYLE_XML);

	if (::FindResource(hinstRes, strStyle, AFX_RT_STYLE_XML) == NULL)
	{
		TRACE(_T("Cannot load Style: %s\r\n"), strStyle);
		ASSERT(FALSE);
		return FALSE;
	}

	CleanStyle();
	m_Style = style;
	SetResourceHandle(hinstRes);

	return TRUE;
}

CMFCVisualManagerOffice2007::Style __stdcall CMFCVisualManagerOffice2007::GetStyle()
{
	return m_Style;
}

void __stdcall CMFCVisualManagerOffice2007::SetResourceHandle(HINSTANCE hinstRes)
{
	m_bAutoFreeRes = FALSE;

	if (m_hinstRes != hinstRes)
	{
		m_hinstRes = hinstRes;

		if (CMFCVisualManager::GetInstance()->IsKindOf(RUNTIME_CLASS(CMFCVisualManagerOffice2007)))
		{
			CMFCVisualManager::GetInstance()->OnUpdateSystemColors();
		}
	}
}

void __stdcall CMFCVisualManagerOffice2007::CleanStyle()
{
	if (m_bAutoFreeRes && m_hinstRes >(HINSTANCE) 32)
	{
		::FreeLibrary(m_hinstRes);
	}

	m_hinstRes = NULL;
	m_Style = c_StyleDefault;
	m_strStylePrefix.Empty();
}

void CMFCVisualManagerOffice2007::CleanUp()
{
	m_clrEditBorder                = (COLORREF)(-1);
	m_clrEditBorderDisabled        = (COLORREF)(-1);
	m_clrEditBorderHighlighted     = (COLORREF)(-1);
	m_clrEditSelection             = (COLORREF)(-1);
	m_clrComboBorder               = (COLORREF)(-1);
	m_clrComboBorderDisabled       = (COLORREF)(-1);
	m_clrComboBorderPressed        = (COLORREF)(-1);
	m_clrComboBorderHighlighted    = (COLORREF)(-1);
	m_clrComboBtnStart             = (COLORREF)(-1);
	m_clrComboBtnFinish            = (COLORREF)(-1);
	m_clrComboBtnBorder            = (COLORREF)(-1);
	m_clrComboBtnDisabledStart     = (COLORREF)(-1);
	m_clrComboBtnDisabledFinish    = (COLORREF)(-1);
	m_clrComboBtnBorderDisabled    = (COLORREF)(-1);
	m_clrComboBtnPressedStart      = (COLORREF)(-1);
	m_clrComboBtnPressedFinish     = (COLORREF)(-1);
	m_clrComboBtnBorderPressed     = (COLORREF)(-1);
	m_clrComboBtnHighlightedStart  = (COLORREF)(-1);
	m_clrComboBtnHighlightedFinish = (COLORREF)(-1);
	m_clrComboBtnBorderHighlighted = (COLORREF)(-1);
	m_clrComboSelection            = (COLORREF)(-1);
	m_ctrlComboBoxBtn.CleanUp();

	m_ToolBarGripper.Clear();
	m_ToolBarTear.Clear();
	m_ctrlToolBarBorder.CleanUp();

	m_ctrlStatusBarBack.CleanUp();
	m_ctrlStatusBarBack_Ext.CleanUp();
	m_StatusBarPaneBorder.Clear();
	m_StatusBarSizeBox.Clear();

	m_SysBtnBack[0].CleanUp();
	m_SysBtnBack[1].CleanUp();
	m_SysBtnClose[0].Clear();
	m_SysBtnClose[1].Clear();
	m_SysBtnRestore[0].Clear();
	m_SysBtnRestore[1].Clear();
	m_SysBtnMaximize[0].Clear();
	m_SysBtnMaximize[1].Clear();
	m_SysBtnMinimize[0].Clear();
	m_SysBtnMinimize[1].Clear();

	m_brMainClientArea.DeleteObject();

	m_AppCaptionFont.DeleteObject();
	m_penSeparator2.DeleteObject();

	m_brGroupBackground.DeleteObject();
	m_clrGroupText = (COLORREF)-1;

	m_penSeparatorDark.DeleteObject();

	m_ctrlMainBorder.CleanUp();
	m_ctrlMDIChildBorder.CleanUp();
	m_ctrlMainBorderCaption.CleanUp();
	m_ctrlPopupBorder.CleanUp();
	m_ctrlPopupResizeBar.CleanUp();
	m_PopupResizeBar_HV.Clear();
	m_PopupResizeBar_HVT.Clear();
	m_PopupResizeBar_V.Clear();

	m_ctrlMenuBarBtn.CleanUp();

	m_ctrlMenuItemBack.CleanUp();
	m_MenuItemMarkerC.Clear();
	m_MenuItemMarkerR.Clear();
	m_ctrlMenuItemShowAll.CleanUp();
	m_ctrlMenuHighlighted[0].CleanUp();
	m_ctrlMenuHighlighted[1].CleanUp();
	m_ctrlMenuButtonBorder.CleanUp();
	m_ctrlMenuScrollBtn[0].CleanUp();
	m_ctrlMenuScrollBtn[1].CleanUp();

	m_ctrlToolBarBtn.CleanUp();

	m_ctrlTaskScrollBtn.CleanUp();

	m_ctrlTab3D[0].CleanUp();
	m_ctrlTab3D[1].CleanUp();
	m_ctrlTabFlat[0].CleanUp();
	m_ctrlTabFlat[1].CleanUp();
	m_clrTabFlatBlack = CLR_DEFAULT;
	m_clrTabTextActive = CLR_DEFAULT;
	m_clrTabTextInactive = CLR_DEFAULT;
	m_clrTabFlatHighlight = CLR_DEFAULT;
	m_penTabFlatInner[0].DeleteObject();
	m_penTabFlatInner[1].DeleteObject();
	m_penTabFlatOuter[0].DeleteObject();
	m_penTabFlatOuter[1].DeleteObject();

	m_ctrlOutlookWndBar.CleanUp();
	m_ctrlOutlookWndPageBtn.CleanUp();

	m_ctrlRibbonCaptionQA.CleanUp();
	m_ctrlRibbonCaptionQA_Glass.CleanUp();
	m_ctrlRibbonCategoryBack.CleanUp();
	m_ctrlRibbonCategoryTab.CleanUp();
	m_ctrlRibbonCategoryTabSep.CleanUp();
	m_ctrlRibbonCategoryBtnPage[0].CleanUp();
	m_ctrlRibbonCategoryBtnPage[1].CleanUp();
	m_ctrlRibbonPanelBack_T.CleanUp();
	m_ctrlRibbonPanelBack_B.CleanUp();
	m_RibbonPanelSeparator.Clear();
	m_ctrlRibbonPanelQAT.CleanUp();
	m_ctrlRibbonMainPanel.CleanUp();
	m_ctrlRibbonMainPanelBorder.CleanUp();
	m_ctrlRibbonBtnMainPanel.CleanUp();

	m_ctrlRibbonBtnGroup_S.CleanUp();
	m_ctrlRibbonBtnGroup_F.CleanUp();
	m_ctrlRibbonBtnGroup_M.CleanUp();
	m_ctrlRibbonBtnGroup_L.CleanUp();
	m_ctrlRibbonBtnGroupMenu_F[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_F[1].CleanUp();
	m_ctrlRibbonBtnGroupMenu_M[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_M[1].CleanUp();
	m_ctrlRibbonBtnGroupMenu_L[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_L[1].CleanUp();
	m_ctrlRibbonBtn[0].CleanUp();
	m_ctrlRibbonBtn[1].CleanUp();
	m_ctrlRibbonBtnMenuH[0].CleanUp();
	m_ctrlRibbonBtnMenuH[1].CleanUp();
	m_ctrlRibbonBtnMenuV[0].CleanUp();
	m_ctrlRibbonBtnMenuV[1].CleanUp();
	m_ctrlRibbonBtnLaunch.CleanUp();
	m_RibbonBtnLaunchIcon.Clear();
	m_RibbonBtnMain.CleanUp();
	m_ctrlRibbonBtnDefault.CleanUp();
	m_ctrlRibbonBtnDefaultIcon.CleanUp();
	m_RibbonBtnDefaultImage.Clear();
	m_ctrlRibbonBtnDefaultQATIcon.CleanUp();
	m_ctrlRibbonBtnDefaultQAT.CleanUp();
	m_ctrlRibbonBtnCheck.CleanUp();
	m_ctrlRibbonBtnPalette[0].CleanUp();
	m_ctrlRibbonBtnPalette[1].CleanUp();
	m_ctrlRibbonBtnPalette[2].CleanUp();
	m_ctrlRibbonBtnStatusPane.CleanUp();
	m_ctrlRibbonSliderThumb.CleanUp();
	m_ctrlRibbonSliderBtnPlus.CleanUp();
	m_ctrlRibbonSliderBtnMinus.CleanUp();
	m_ctrlRibbonProgressBack.CleanUp();
	m_ctrlRibbonProgressNormal.CleanUp();
	m_ctrlRibbonProgressNormalExt.CleanUp();
	m_ctrlRibbonProgressInfinity.CleanUp();
	m_ctrlRibbonBorder_QAT.CleanUp();
	m_ctrlRibbonBorder_Floaty.CleanUp();

	m_ctrlRibbonKeyTip.CleanUp();
	m_clrRibbonKeyTipTextNormal   = (COLORREF)(-1);
	m_clrRibbonKeyTipTextDisabled = (COLORREF)(-1);

	m_ctrlRibbonComboBoxBtn.CleanUp();

	m_cacheRibbonCategoryBack.Clear();
	m_cacheRibbonPanelBack_T.Clear();
	m_cacheRibbonPanelBack_B.Clear();
	m_cacheRibbonBtnDefault.Clear();

	m_cacheRibbonBtnGroup_S.Clear();
	m_cacheRibbonBtnGroup_F.Clear();
	m_cacheRibbonBtnGroup_M.Clear();
	m_cacheRibbonBtnGroup_L.Clear();
	m_cacheRibbonBtnGroupMenu_F[0].Clear();
	m_cacheRibbonBtnGroupMenu_M[0].Clear();
	m_cacheRibbonBtnGroupMenu_L[0].Clear();
	m_cacheRibbonBtnGroupMenu_F[1].Clear();
	m_cacheRibbonBtnGroupMenu_M[1].Clear();
	m_cacheRibbonBtnGroupMenu_L[1].Clear();

	m_ctrlRibbonContextPanelBack_T.CleanUp();
	m_ctrlRibbonContextPanelBack_B.CleanUp();
	m_cacheRibbonContextPanelBack_T.Clear();
	m_cacheRibbonContextPanelBack_B.Clear();
	m_ctrlRibbonContextSeparator.CleanUp();

	for (int i = 0; i < AFX_RIBBON_CATEGORY_COLOR_COUNT; i++)
	{
		m_ctrlRibbonContextCategory[i].CleanUp();
	}

	m_clrCaptionBarText = afxGlobalData.clrWindow;

	m_bToolTipParams = FALSE;
	CMFCToolTipInfo dummy;
	m_ToolTipParams = dummy;

	m_ActivateFlag.RemoveAll();

	m_clrRibbonHyperlinkInactive = (COLORREF)-1;
	m_clrRibbonHyperlinkActive = (COLORREF)-1;
	m_clrRibbonStatusbarHyperlinkInactive = (COLORREF)-1;
	m_clrRibbonStatusbarHyperlinkActive = (COLORREF)-1;

	m_bLoaded = FALSE;
}

void CMFCVisualManagerOffice2007::OnUpdateSystemColors()
{
	CleanUp();

	CMFCVisualManagerOffice2003::OnUpdateSystemColors();

	if (afxGlobalData.IsHighContrastMode() || afxGlobalData.m_nBitsPerPixel <= 8)
	{
		return;
	}

	m_nMenuBorderSize = 1;

	HINSTANCE hinstResOld = NULL;

	if (m_hinstRes == NULL)
	{
		SetStyle(c_StyleDefault);
	}

	if (m_hinstRes != NULL)
	{
		hinstResOld = AfxGetResourceHandle();
		AfxSetResourceHandle(m_hinstRes);
	}

	CTagManager tm;

	if (!tm.LoadFromResource(GetStyleResourceID(m_Style), AFX_RT_STYLE_XML))
	{
#if !defined _AFXDLL
		TRACE(_T("\r\nImportant: to enable the Office 2007 look in static link,\r\n"));
		TRACE(_T("include afxribbon.rc from the RC file in your project.\r\n\r\n"));
		ASSERT(FALSE);
#endif
		if (hinstResOld != NULL)
		{
			AfxSetResourceHandle(hinstResOld);
		}

		return;
	}

	{
		CString strStyle;
		tm.ExcludeTag(_T("STYLE"), strStyle);
		tm.SetBuffer(strStyle);
	}

	CString strItem;

	m_nType = 20;

	if (!tm.IsEmpty())
	{
		int nVersion = 0;

		if (tm.ExcludeTag(_T("VERSION"), strItem))
		{
			CTagManager tmItem(strItem);

			tmItem.ReadInt(_T("NUMBER"), nVersion);

			if (nVersion == 2007)
			{
				tmItem.ReadInt(_T("TYPE"), m_nType);

				if (m_nType < 10)
				{
					m_nType *= 10;
				}

				m_bLoaded = TRUE;
			}

			if (m_bLoaded)
			{
				if (tmItem.ExcludeTag(_T("ID_PREFIX"), strItem))
				{
					strItem.Trim();
					m_strStylePrefix = strItem;
				}
			}
		}
	}

	if (!m_bLoaded)
	{
		if (hinstResOld != NULL)
		{
			::AfxSetResourceHandle(hinstResOld);
		}

		return;
	}

	// globals
	if (tm.ExcludeTag(_T("GLOBALS"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("BarText"), afxGlobalData.clrBarText);

		if (tmItem.ReadColor(_T("BarFace"), afxGlobalData.clrBarFace))
		{
			afxGlobalData.brBarFace.DeleteObject();
			afxGlobalData.brBarFace.CreateSolidBrush(afxGlobalData.clrBarFace);
			m_clrMenuShadowBase = afxGlobalData.clrBarFace;
		}
		if (tmItem.ReadColor(_T("ActiveCaption"), afxGlobalData.clrActiveCaption))
		{
			afxGlobalData.clrInactiveCaption     = afxGlobalData.clrActiveCaption;
			afxGlobalData.brActiveCaption.DeleteObject();
			afxGlobalData.brActiveCaption.CreateSolidBrush(afxGlobalData.clrActiveCaption);
		}
		if (tmItem.ReadColor(_T("CaptionText"), afxGlobalData.clrCaptionText))
		{
			afxGlobalData.clrInactiveCaptionText = afxGlobalData.clrCaptionText;
		}

		tmItem.ReadColor(_T("InactiveCaption"), afxGlobalData.clrInactiveCaption);
		afxGlobalData.brInactiveCaption.DeleteObject();
		afxGlobalData.brInactiveCaption.CreateSolidBrush(afxGlobalData.clrInactiveCaption);
		tmItem.ReadColor(_T("InactiveCaptionText"), afxGlobalData.clrInactiveCaptionText);

		tmItem.ReadColor(_T("BarShadow"), afxGlobalData.clrBarShadow);
		tmItem.ReadColor(_T("BarDkShadow"), afxGlobalData.clrBarDkShadow);
		tmItem.ReadColor(_T("BarLight"), afxGlobalData.clrBarLight);

		COLORREF clrFloatToolBarBorder;
		tmItem.ReadColor(_T("FloatToolBarBorder"), clrFloatToolBarBorder);
		m_brFloatToolBarBorder.DeleteObject();
		m_brFloatToolBarBorder.CreateSolidBrush(clrFloatToolBarBorder);

		tmItem.ReadColor(_T("HighlightGradientDark"), m_clrHighlightGradientDark);
		tmItem.ReadColor(_T("HighlightGradientLight"), m_clrHighlightGradientLight);

		m_clrHighlightDnGradientDark = m_clrHighlightGradientLight;
		m_clrHighlightDnGradientLight = m_clrHighlightGradientDark;
		tmItem.ReadColor(_T("HighlightDnGradientDark"), m_clrHighlightDnGradientDark);
		tmItem.ReadColor(_T("HighlightDnGradientLight"), m_clrHighlightDnGradientLight);

		m_clrHighlightCheckedGradientDark = m_clrHighlightDnGradientLight;
		m_clrHighlightCheckedGradientLight = m_clrHighlightDnGradientDark;
		tmItem.ReadColor(_T("HighlightCheckedGradientDark"), m_clrHighlightCheckedGradientDark);
		tmItem.ReadColor(_T("HighlightCheckedGradientLight"), m_clrHighlightCheckedGradientLight);

		tmItem.ReadColor(_T("PressedButtonBorder"), m_clrPressedButtonBorder);

		COLORREF clrHB = afxGlobalData.clrHilite;
		COLORREF clrHT = afxGlobalData.clrTextHilite;
		if (tmItem.ReadColor(_T("Highlight"), clrHB) && tmItem.ReadColor(_T("HighlightText"), clrHT))
		{
			afxGlobalData.clrHilite = clrHB;

			afxGlobalData.brHilite.DeleteObject();
			afxGlobalData.brHilite.CreateSolidBrush(clrHB);

			afxGlobalData.clrTextHilite = clrHT;
		}

		tmItem.ReadColor(_T("MenuShadowColor"), m_clrMenuShadowBase);

		// ToolTipParams
		m_bToolTipParams = tmItem.ReadToolTipInfo(_T("TOOLTIP"), m_ToolTipParams);
	}

	// mainwnd
	if (tm.ExcludeTag(_T("MAINWND"), strItem))
	{
		CTagManager tmItem(strItem);

		// caption
		CString strCaption;
		if (tmItem.ExcludeTag(_T("CAPTION"), strCaption))
		{
			CTagManager tmCaption(strCaption);

			NONCLIENTMETRICS ncm;
			if (afxGlobalData.GetNonClientMetrics (ncm))
			{
				tmCaption.ReadFont(_T("FONT"), ncm.lfCaptionFont);
				m_AppCaptionFont.DeleteObject();
				m_AppCaptionFont.CreateFontIndirect(&ncm.lfCaptionFont);
			}

			tmCaption.ReadColor(_T("ActiveStart"), m_clrAppCaptionActiveStart);
			tmCaption.ReadColor(_T("ActiveFinish"), m_clrAppCaptionActiveFinish);
			tmCaption.ReadColor(_T("InactiveStart"), m_clrAppCaptionInactiveStart);
			tmCaption.ReadColor(_T("InactiveFinish"), m_clrAppCaptionInactiveFinish);
			tmCaption.ReadColor(_T("ActiveText"), m_clrAppCaptionActiveText);
			tmCaption.ReadColor(_T("InactiveText"), m_clrAppCaptionInactiveText);
			tmCaption.ReadColor(_T("ActiveTitleText"), m_clrAppCaptionActiveTitleText);
			tmCaption.ReadColor(_T("InactiveTitleText"), m_clrAppCaptionInactiveTitleText);

			tmCaption.ReadBool(_T("TextCenter"), m_bNcTextCenter);

			tmCaption.ReadControlRenderer(_T("BORDER"), m_ctrlMainBorderCaption, MakeResourceID(_T("IDB_OFFICE2007_MAINBORDER_CAPTION")));

			m_szNcBtnSize[0] = CSize(::GetSystemMetrics(SM_CXSIZE), ::GetSystemMetrics(SM_CYSIZE));
			m_szNcBtnSize[1] = CSize(::GetSystemMetrics(SM_CXSMSIZE), ::GetSystemMetrics(SM_CYSMSIZE));

			// buttons
			CString strButtons;
			if (tmCaption.ExcludeTag(_T("BUTTONS"), strButtons))
			{
				CTagManager tmButtons(strButtons);

				for (int i = 0; i < 2; i++)
				{
					CString str;
					CString suffix;
					if (i == 1)
					{
						suffix = _T("_S");
					}
					if (tmButtons.ExcludeTag(i == 0 ? _T("NORMAL") : _T("SMALL"), str))
					{
						CTagManager tmBtn(str);

						tmBtn.ReadSize(_T("ConstSize"), m_szNcBtnSize[i]);

						CSize sizeIcon(0, 0);
						if (tmBtn.ReadSize(_T("IconSize"), sizeIcon))
						{
							m_SysBtnClose[i].Clear();
							m_SysBtnClose[i].SetPreMultiplyAutoCheck(TRUE);
							m_SysBtnClose[i].SetImageSize(sizeIcon);
							m_SysBtnClose[i].LoadStr(MakeResourceID(_T("IDB_OFFICE2007_SYS_BTN_CLOSE") + suffix));

							m_SysBtnRestore[i].Clear();
							m_SysBtnRestore[i].SetPreMultiplyAutoCheck(TRUE);
							m_SysBtnRestore[i].SetImageSize(sizeIcon);
							m_SysBtnRestore[i].LoadStr(MakeResourceID(_T("IDB_OFFICE2007_SYS_BTN_RESTORE") + suffix));

							m_SysBtnMaximize[i].Clear();
							m_SysBtnMaximize[i].SetPreMultiplyAutoCheck(TRUE);
							m_SysBtnMaximize[i].SetImageSize(sizeIcon);
							m_SysBtnMaximize[i].LoadStr(MakeResourceID(_T("IDB_OFFICE2007_SYS_BTN_MAXIMIZE") + suffix));

							m_SysBtnMinimize[i].Clear();
							m_SysBtnMinimize[i].SetPreMultiplyAutoCheck(TRUE);
							m_SysBtnMinimize[i].SetImageSize(sizeIcon);
							m_SysBtnMinimize[i].LoadStr(MakeResourceID(_T("IDB_OFFICE2007_SYS_BTN_MINIMIZE") + suffix));
						}

						CTagManager::ParseControlRenderer(tmBtn.GetBuffer(), m_SysBtnBack[i], MakeResourceID(_T("IDB_OFFICE2007_SYS_BTN_BACK")));
					}
				}
			}
		}

		// border
		tmItem.ReadControlRenderer(_T("BORDER"), m_ctrlMainBorder, MakeResourceID(_T("IDB_OFFICE2007_MAINBORDER")));
		tmItem.ReadControlRenderer(_T("BORDER_MDICHILD"), m_ctrlMDIChildBorder, MakeResourceID(_T("IDB_OFFICE2007_MDICHILDBORDER")));

		if (tmItem.ReadColor(_T("MainClientArea"), m_clrMainClientArea))
		{
			m_brMainClientArea.DeleteObject();
			m_brMainClientArea.CreateSolidBrush(m_clrMainClientArea);
		}
	}

	// menu
	if (tm.ExcludeTag(_T("MENU"), strItem))
	{
		CTagManager tmItem(strItem);

		if (tmItem.ReadColor(_T("Light"), m_clrMenuLight))
		{
			m_brMenuLight.DeleteObject();
			m_brMenuLight.CreateSolidBrush(m_clrMenuLight);
		}

		m_clrMenuRarelyUsed = CLR_DEFAULT;
		tmItem.ReadColor(_T("Rarely"), m_clrMenuRarelyUsed);

		tmItem.ReadColor(_T("Border"), m_clrMenuBorder);

		if (tmItem.ReadColor(_T("Separator1"), m_clrSeparator1))
		{
			m_penSeparator.DeleteObject();
			m_penSeparator.CreatePen(PS_SOLID, 1, m_clrSeparator1);
		}

		if (tmItem.ReadColor(_T("Separator2"), m_clrSeparator2))
		{
			m_penSeparator2.DeleteObject();
			m_penSeparator2.CreatePen(PS_SOLID, 1, m_clrSeparator2);
		}

		COLORREF clrGroupBack = (COLORREF)-1;
		if (tmItem.ReadColor(_T("GroupBackground"), clrGroupBack))
		{
			m_brGroupBackground.DeleteObject();
			m_brGroupBackground.CreateSolidBrush(clrGroupBack);
		}

		tmItem.ReadColor(_T("GroupText"), m_clrGroupText);

		if (tmItem.ReadColor(_T("ItemBorder"), m_clrMenuItemBorder))
		{
			m_penMenuItemBorder.DeleteObject();
			m_penMenuItemBorder.CreatePen(PS_SOLID, 1, m_clrMenuItemBorder);
		}

		tmItem.ReadInt(_T("BorderSize"), m_nMenuBorderSize);

		tmItem.ReadControlRenderer(_T("ItemBack"), m_ctrlMenuItemBack, MakeResourceID(_T("IDB_OFFICE2007_MENU_ITEM_BACK")));
		tmItem.ReadToolBarImages(_T("ItemCheck"), m_MenuItemMarkerC, MakeResourceID(_T("IDB_OFFICE2007_MENU_ITEM_MARKER_C")));
		tmItem.ReadToolBarImages(_T("ItemRadio"), m_MenuItemMarkerR, MakeResourceID(_T("IDB_OFFICE2007_MENU_ITEM_MARKER_R")));
		tmItem.ReadControlRenderer(_T("ItemShowAll"), m_ctrlMenuItemShowAll, MakeResourceID(_T("IDB_OFFICE2007_MENU_ITEM_SHOWALL")));
		tmItem.ReadControlRenderer(_T("Highlighted"), m_ctrlMenuHighlighted[0], MakeResourceID(_T("IDB_OFFICE2007_MENU_BTN")));
		tmItem.ReadControlRenderer(_T("HighlightedDisabled"), m_ctrlMenuHighlighted[1], MakeResourceID(_T("IDB_OFFICE2007_MENU_BTN_DISABLED")));
		tmItem.ReadControlRenderer(_T("ButtonBorder"), m_ctrlMenuButtonBorder, MakeResourceID(_T("IDB_OFFICE2007_MENU_BTN_VERT_SEPARATOR")));
		tmItem.ReadControlRenderer(_T("ScrollBtn_T"), m_ctrlMenuScrollBtn[0], MakeResourceID(_T("IDB_OFFICE2007_MENU_BTN_SCROLL_T")));
		tmItem.ReadControlRenderer(_T("ScrollBtn_B"), m_ctrlMenuScrollBtn[1], MakeResourceID(_T("IDB_OFFICE2007_MENU_BTN_SCROLL_B")));

		tmItem.ReadColor(_T("TextNormal"), m_clrMenuText);
		tmItem.ReadColor(_T("TextHighlighted"), m_clrMenuTextHighlighted);
		tmItem.ReadColor(_T("TextDisabled"), m_clrMenuTextDisabled);

		COLORREF clrImages = m_clrMenuText;

		CString strColors;
		if (tmItem.ExcludeTag(_T("COLORS"), strColors))
		{
			CTagManager tmColors(strColors);

			tmColors.ReadColor(_T("Black"), clrImages);
			CMenuImages::SetColor(CMenuImages::ImageBlack, clrImages);

			tmColors.ReadColor(_T("Black2"), clrImages);
			CMenuImages::SetColor(CMenuImages::ImageBlack2, clrImages);

			struct XColors
			{
				CMenuImages::IMAGE_STATE state;
				LPCTSTR name;
			};
			XColors colors[4] =
			{
				{CMenuImages::ImageGray, _T("Gray")},
				{CMenuImages::ImageLtGray, _T("LtGray")},
				{CMenuImages::ImageWhite, _T("White")},
				{CMenuImages::ImageDkGray, _T("DkGray")}
			};

			for (int ic = 0; ic < 4; ic++)
			{
				if (tmColors.ReadColor(colors[ic].name, clrImages))
				{
					CMenuImages::SetColor(colors[ic].state, clrImages);
				}
			}
		}
		else
		{
			tmItem.ReadColor(_T("ImagesColor"), clrImages);
			CMenuImages::SetColor(CMenuImages::ImageBlack, clrImages);
			CMenuImages::SetColor(CMenuImages::ImageBlack2, clrImages);
		}
	}

	// bars
	if (tm.ExcludeTag(_T("BARS"), strItem))
	{
		CTagManager tmItem(strItem);

		CString strBar;
		if (tmItem.ExcludeTag(_T("DEFAULT"), strBar))
		{
			CTagManager tmBar(strBar);

			if (tmBar.ReadColor(_T("Bkgnd"), m_clrBarBkgnd))
			{
				m_brBarBkgnd.DeleteObject();
				m_brBarBkgnd.CreateSolidBrush(m_clrBarBkgnd);
			}

			tmBar.ReadColor(_T("GradientLight"), m_clrBarGradientLight);
			m_clrBarGradientDark = m_clrBarGradientLight;
			tmBar.ReadColor(_T("GradientDark"), m_clrBarGradientDark);
		}

		if (tmItem.ExcludeTag(_T("TOOLBAR"), strBar))
		{
			CTagManager tmBar(strBar);

			m_clrToolBarGradientLight = m_clrBarGradientLight;
			m_clrToolBarGradientDark  = m_clrBarGradientDark;

			m_clrToolbarDisabled = CDrawingManager::SmartMixColors(m_clrToolBarGradientDark, m_clrToolBarGradientLight);

			tmBar.ReadColor(_T("GradientLight"), m_clrToolBarGradientLight);
			tmBar.ReadColor(_T("GradientDark"), m_clrToolBarGradientDark);

			m_clrToolBarGradientVertLight = m_clrToolBarGradientLight;
			m_clrToolBarGradientVertDark  = m_clrToolBarGradientDark;

			tmBar.ReadColor(_T("GradientVertLight"), m_clrToolBarGradientVertLight);
			tmBar.ReadColor(_T("GradientVertDark"), m_clrToolBarGradientVertDark);

			tmBar.ReadColor(_T("CustomizeButtonGradientLight"), m_clrCustomizeButtonGradientLight);
			tmBar.ReadColor(_T("CustomizeButtonGradientDark"), m_clrCustomizeButtonGradientDark);

			tmBar.ReadToolBarImages(_T("GRIPPER"), m_ToolBarGripper, MakeResourceID(_T("IDB_OFFICE2007_GRIPPER")));
			tmBar.ReadToolBarImages(_T("TEAR"), m_ToolBarTear, MakeResourceID(_T("IDB_OFFICE2007_TEAR")));

			tmBar.ReadControlRenderer(_T("BUTTON"), m_ctrlToolBarBtn, MakeResourceID(_T("IDB_OFFICE2007_TOOLBAR_BTN")));
			tmBar.ReadControlRenderer(_T("BORDER"), m_ctrlToolBarBorder, MakeResourceID(_T("IDB_OFFICE2007_TOOLBAR_BORDER")));

			m_clrToolBarBtnText = afxGlobalData.clrBarText;
			m_clrToolBarBtnTextHighlighted = m_clrToolBarBtnText;
			tmBar.ReadColor(_T("TextNormal"), m_clrToolBarBtnText);
			tmBar.ReadColor(_T("TextHighlighted"), m_clrToolBarBtnTextHighlighted);
			tmBar.ReadColor(_T("TextDisabled"), m_clrToolBarBtnTextDisabled);

			if (tmBar.ReadColor(_T("BottomLineColor"), m_clrToolBarBottomLine))
			{
				m_penBottomLine.DeleteObject();
				m_penBottomLine.CreatePen(PS_SOLID, 1, m_clrToolBarBottomLine);
			}

			m_penSeparatorDark.DeleteObject();
			m_penSeparatorDark.CreatePen(PS_SOLID, 1, CDrawingManager::PixelAlpha(m_clrToolBarBottomLine, RGB(255, 255, 255), 95));

			m_penSeparatorLight.DeleteObject();
			m_penSeparatorLight.CreatePen(PS_SOLID, 1, RGB(255, 255, 255));
		}

		if (tmItem.ExcludeTag(_T("MENUBAR"), strBar))
		{
			CTagManager tmBar(strBar);

			m_clrMenuBarGradientLight = m_clrToolBarGradientLight;
			m_clrMenuBarGradientDark  = m_clrToolBarGradientDark;

			tmBar.ReadColor(_T("GradientLight"), m_clrMenuBarGradientLight);
			tmBar.ReadColor(_T("GradientDark"), m_clrMenuBarGradientDark);

			m_clrMenuBarGradientVertLight = m_clrMenuBarGradientLight;
			m_clrMenuBarGradientVertDark  = m_clrMenuBarGradientDark;

			tmBar.ReadColor(_T("GradientVertLight"), m_clrMenuBarGradientVertLight);
			tmBar.ReadColor(_T("GradientVertDark"), m_clrMenuBarGradientVertDark);

			m_clrMenuBarBtnText            = m_clrToolBarBtnText;
			m_clrMenuBarBtnTextHighlighted = m_clrToolBarBtnTextHighlighted;
			m_clrMenuBarBtnTextDisabled    = m_clrToolBarBtnTextDisabled;
			tmBar.ReadColor(_T("TextNormal"), m_clrMenuBarBtnText);
			tmBar.ReadColor(_T("TextHighlighted"), m_clrMenuBarBtnTextHighlighted);
			tmBar.ReadColor(_T("TextDisabled"), m_clrMenuBarBtnTextDisabled);

			tmBar.ReadControlRenderer(_T("BUTTON"), m_ctrlMenuBarBtn, MakeResourceID(_T("IDB_OFFICE2007_MENUBAR_BTN")));
		}

		if (tmItem.ExcludeTag(_T("POPUPBAR"), strBar))
		{
			CTagManager tmBar(strBar);
			tmBar.ReadControlRenderer(_T("BORDER"), m_ctrlPopupBorder, MakeResourceID(_T("IDB_OFFICE2007_POPUPMENU_BORDER")));

			CString strResize;
			if (tmBar.ExcludeTag(_T("RESIZEBAR"), strResize))
			{
				CTagManager tmResize(strResize);
				tmResize.ReadControlRenderer(_T("BACK"), m_ctrlPopupResizeBar, MakeResourceID(_T("IDB_OFFICE2007_POPUPMENU_RESIZEBAR")));
				tmResize.ReadToolBarImages(_T("ICON_HV"), m_PopupResizeBar_HV, MakeResourceID(_T("IDB_OFFICE2007_POPUPMENU_RESIZEBAR_ICON_HV")));
				tmResize.ReadToolBarImages(_T("ICON_HVT"), m_PopupResizeBar_HVT, MakeResourceID(_T("IDB_OFFICE2007_POPUPMENU_RESIZEBAR_ICON_HVT")));
				tmResize.ReadToolBarImages(_T("ICON_V"), m_PopupResizeBar_V, MakeResourceID(_T("IDB_OFFICE2007_POPUPMENU_RESIZEBAR_ICON_V")));
			}
		}

		if (tmItem.ExcludeTag(_T("STATUSBAR"), strBar))
		{
			CTagManager tmBar(strBar);

			tmBar.ReadControlRenderer(_T("BACK"), m_ctrlStatusBarBack, MakeResourceID(_T("IDB_OFFICE2007_STATUSBAR_BACK")));
			tmBar.ReadControlRenderer(_T("BACK_EXT"), m_ctrlStatusBarBack_Ext, MakeResourceID(_T("IDB_OFFICE2007_STATUSBAR_BACK_EXT")));

			tmBar.ReadToolBarImages(_T("PANEBORDER"), m_StatusBarPaneBorder, MakeResourceID(_T("IDB_OFFICE2007_STATUSBAR_PANEBORDER")));
			tmBar.ReadToolBarImages(_T("SIZEBOX"), m_StatusBarSizeBox, MakeResourceID(_T("IDB_OFFICE2007_STATUSBAR_SIZEBOX")));

			m_clrStatusBarText = m_clrMenuBarBtnText;
			m_clrStatusBarTextDisabled = m_clrMenuBarBtnTextDisabled;
			m_clrExtenedStatusBarTextDisabled = m_clrMenuBarBtnTextDisabled;

			tmBar.ReadColor(_T("TextNormal"), m_clrStatusBarText);
			tmBar.ReadColor(_T("TextDisabled"), m_clrStatusBarTextDisabled);
			tmBar.ReadColor(_T("TextExtendedDisabled"), m_clrExtenedStatusBarTextDisabled);
		}

		if (tmItem.ExcludeTag(_T("CAPTIONBAR"), strBar))
		{
			CTagManager tmBar(strBar);

			tmBar.ReadColor(_T("GradientLight"), m_clrCaptionBarGradientLight);
			tmBar.ReadColor(_T("GradientDark"), m_clrCaptionBarGradientDark);
			tmBar.ReadColor(_T("TextNormal"), m_clrCaptionBarText);
		}
	}

	if (m_clrMenuRarelyUsed == CLR_DEFAULT)
	{
		m_clrMenuRarelyUsed = m_clrBarBkgnd;
	}

	m_brMenuRarelyUsed.DeleteObject();
	m_brMenuRarelyUsed.CreateSolidBrush(m_clrMenuRarelyUsed);

	m_clrEditBorder            = afxGlobalData.clrWindow;
	m_clrEditBorderDisabled    = afxGlobalData.clrBtnShadow;
	m_clrEditBorderHighlighted = m_clrMenuItemBorder;
	m_clrEditSelection         = afxGlobalData.clrHilite;

	// edit
	if (tm.ExcludeTag(_T("EDIT"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("BorderNormal"), m_clrEditBorder);
		tmItem.ReadColor(_T("BorderHighlighted"), m_clrEditBorderHighlighted);
		tmItem.ReadColor(_T("BorderDisabled"), m_clrEditBorderDisabled);
		tmItem.ReadColor(_T("Selection"), m_clrEditSelection);
	}

	m_clrComboBorder               = afxGlobalData.clrWindow;
	m_clrComboBorderDisabled       = afxGlobalData.clrBtnShadow;
	m_clrComboBorderHighlighted    = m_clrMenuItemBorder;
	m_clrComboBorderPressed        = m_clrComboBorderHighlighted;
	m_clrComboBtnBorder            = m_clrComboBorder;
	m_clrComboBtnBorderHighlighted = m_clrComboBorderHighlighted;
	m_clrComboBtnBorderPressed     = m_clrComboBorderHighlighted;
	m_clrComboSelection            = afxGlobalData.clrHilite;
	m_clrComboBtnStart             = m_clrToolBarGradientDark;
	m_clrComboBtnFinish            = m_clrToolBarGradientLight;
	m_clrComboBtnDisabledStart     = afxGlobalData.clrBtnFace;
	m_clrComboBtnDisabledFinish    = m_clrComboBtnDisabledStart;
	m_clrComboBtnHighlightedStart  = m_clrHighlightGradientDark;
	m_clrComboBtnHighlightedFinish = m_clrHighlightGradientLight;
	m_clrComboBtnPressedStart      = m_clrHighlightDnGradientDark;
	m_clrComboBtnPressedFinish     = m_clrHighlightDnGradientLight;

	// combobox
	if (tm.ExcludeTag(_T("COMBO"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("BorderNormal"), m_clrComboBorder);
		tmItem.ReadColor(_T("BorderHighlighted"), m_clrComboBorderHighlighted);
		tmItem.ReadColor(_T("BorderDisabled"), m_clrComboBorderDisabled);

		m_clrComboBorderPressed = m_clrComboBorderHighlighted;
		tmItem.ReadColor(_T("BorderPressed"), m_clrComboBorderPressed);

		tmItem.ReadColor(_T("Selection"), m_clrComboSelection);

		CString strButton;
		if (tmItem.ExcludeTag(_T("BUTTON"), strButton))
		{
			CTagManager tmButton(strButton);

			tmButton.ReadColor(_T("GradientStartNormal"), m_clrComboBtnStart);
			tmButton.ReadColor(_T("GradientFinishNormal"), m_clrComboBtnFinish);
			tmButton.ReadColor(_T("BtnBorderNormal"), m_clrComboBtnBorder);

			if (!tmButton.ReadControlRenderer(_T("IMAGE"), m_ctrlComboBoxBtn, MakeResourceID(_T("IDB_OFFICE2007_COMBOBOX_BTN"))))
			{
				tmButton.ReadColor(_T("GradientStartHighlighted"), m_clrComboBtnHighlightedStart);
				tmButton.ReadColor(_T("GradientFinishHighlighted"), m_clrComboBtnHighlightedFinish);
				tmButton.ReadColor(_T("GradientStartDisabled"), m_clrComboBtnDisabledStart);
				tmButton.ReadColor(_T("GradientFinishDisabled"), m_clrComboBtnDisabledFinish);
				tmButton.ReadColor(_T("GradientStartPressed"), m_clrComboBtnPressedStart);
				tmButton.ReadColor(_T("GradientFinishPressed"), m_clrComboBtnPressedFinish);

				tmButton.ReadColor(_T("BtnBorderHighlighted"), m_clrComboBtnBorderHighlighted);
				tmButton.ReadColor(_T("BtnBorderDisabled"), m_clrComboBtnBorderDisabled);

				m_clrComboBtnBorderPressed = m_clrComboBtnBorderHighlighted;
				tmButton.ReadColor(_T("BtnBorderPressed"), m_clrComboBtnBorderPressed);
			}
		}
	}

	m_clrRibbonEditBorder            = m_clrEditBorder;
	m_clrRibbonEditBorderDisabled    = m_clrEditBorderDisabled;
	m_clrRibbonEditBorderHighlighted = m_clrEditBorderHighlighted;
	m_clrRibbonEditBorderPressed     = m_clrRibbonEditBorderHighlighted;
	m_clrRibbonEditSelection         = m_clrEditSelection;

	m_clrRibbonComboBtnBorder            = m_clrComboBtnBorder;
	m_clrRibbonComboBtnBorderHighlighted = m_clrComboBtnBorderHighlighted;
	m_clrRibbonComboBtnBorderPressed     = m_clrComboBtnBorderPressed;
	m_clrRibbonComboBtnStart             = m_clrComboBtnStart;
	m_clrRibbonComboBtnFinish            = m_clrComboBtnFinish;
	m_clrRibbonComboBtnDisabledStart     = m_clrComboBtnDisabledStart;
	m_clrRibbonComboBtnDisabledFinish    = m_clrComboBtnDisabledFinish;
	m_clrRibbonComboBtnHighlightedStart  = m_clrComboBtnHighlightedStart;
	m_clrRibbonComboBtnHighlightedFinish = m_clrComboBtnHighlightedFinish;
	m_clrRibbonComboBtnPressedStart      = m_clrComboBtnPressedStart;
	m_clrRibbonComboBtnPressedFinish     = m_clrComboBtnPressedFinish;

	// task pane
	m_clrTaskPaneGradientDark       = m_clrBarGradientLight;
	m_clrTaskPaneGradientLight      = m_clrTaskPaneGradientDark;

	if (tm.ExcludeTag(_T("TASK"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("GradientDark"), m_clrTaskPaneGradientDark);
		tmItem.ReadColor(_T("GradientLight"), m_clrTaskPaneGradientLight);

		CString strGroup;
		if (tmItem.ExcludeTag(_T("GROUP"), strGroup))
		{
			CTagManager tmGroup(strGroup);

			CString strState;
			if (tmGroup.ExcludeTag(_T("NORMAL"), strState))
			{
				CTagManager tmState(strState);

				CString str;

				if (tmState.ExcludeTag(_T("CAPTION"), str))
				{
					CTagManager tmCaption(str);

					tmCaption.ReadColor(_T("DarkNormal"), m_clrTaskPaneGroupCaptionDark);
					tmCaption.ReadColor(_T("LightNormal"), m_clrTaskPaneGroupCaptionLight);
					tmCaption.ReadColor(_T("DarkHighlighted"), m_clrTaskPaneGroupCaptionHighDark);
					tmCaption.ReadColor(_T("LightHighlighted"), m_clrTaskPaneGroupCaptionHighLight);
					tmCaption.ReadColor(_T("TextNormal"), m_clrTaskPaneGroupCaptionText);
					tmCaption.ReadColor(_T("TextHighlighted"), m_clrTaskPaneGroupCaptionTextHigh);
				}

				if (tmState.ExcludeTag(_T("AREA"), str))
				{
					CTagManager tmArea(str);

					tmArea.ReadColor(_T("DarkNormal"), m_clrTaskPaneGroupAreaDark);
					tmArea.ReadColor(_T("LightNormal"), m_clrTaskPaneGroupAreaLight);
				}
			}

			if (tmGroup.ExcludeTag(_T("SPECIAL"), strState))
			{
				CTagManager tmState(strState);

				CString str;
				if (tmState.ExcludeTag(_T("CAPTION"), str))
				{
					CTagManager tmCaption(str);

					tmCaption.ReadColor(_T("DarkNormal"), m_clrTaskPaneGroupCaptionSpecDark);
					tmCaption.ReadColor(_T("LightNormal"), m_clrTaskPaneGroupCaptionSpecLight);
					tmCaption.ReadColor(_T("DarkHighlighted"), m_clrTaskPaneGroupCaptionHighSpecDark);
					tmCaption.ReadColor(_T("LightHighlighted"), m_clrTaskPaneGroupCaptionHighSpecLight);
					tmCaption.ReadColor(_T("TextNormal"), m_clrTaskPaneGroupCaptionTextSpec);
					tmCaption.ReadColor(_T("TextHighlighted"), m_clrTaskPaneGroupCaptionTextHighSpec);
				}

				if (tmState.ExcludeTag(_T("AREA"), str))
				{
					CTagManager tmArea(str);

					tmArea.ReadColor(_T("DarkNormal"), m_clrTaskPaneGroupAreaSpecDark);
					tmArea.ReadColor(_T("LightNormal"), m_clrTaskPaneGroupAreaSpecLight);
				}
			}

			if (tmGroup.ReadColor(_T("BORDER"), m_clrTaskPaneGroupBorder))
			{
				m_penTaskPaneGroupBorder.DeleteObject();
				m_penTaskPaneGroupBorder.CreatePen(PS_SOLID, 1, m_clrTaskPaneGroupBorder);
			}
		}

		tmItem.ReadControlRenderer(_T("SCROLL_BUTTON"), m_ctrlTaskScrollBtn, MakeResourceID(_T("IDB_OFFICE2007_TASKPANE_SCROLL_BTN")));
	}

	if (tm.ExcludeTag(_T("TABS"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("TextColorActive"), m_clrTabTextActive);
		tmItem.ReadColor(_T("TextColorInactive"), m_clrTabTextInactive);

		CString strTab;
		if (tmItem.ExcludeTag(_T("3D"), strTab))
		{
			CTagManager tmTab(strTab);

			CString strBtn;
			if (tmTab.ExcludeTag(_T("BUTTON"), strBtn))
			{
				CMFCControlRendererInfo params(MakeResourceID(_T("IDB_OFFICE2007_TAB_3D")), CRect(0, 0, 0, 0), CRect(0, 0, 0, 0));
				if (CTagManager::ParseControlRendererInfo(strBtn, params))
				{
					m_ctrlTab3D[0].Create(params);
					m_ctrlTab3D[1].Create(params, TRUE);
				}
			}
		}

		if (tmItem.ExcludeTag(_T("FLAT"), strTab))
		{
			CTagManager tmTab(strTab);

			CString strBtn;
			if (tmTab.ExcludeTag(_T("BUTTON"), strBtn))
			{
				CMFCControlRendererInfo params(MakeResourceID(_T("IDB_OFFICE2007_TAB_FLAT")), CRect(0, 0, 0, 0), CRect(0, 0, 0, 0));
				if (CTagManager::ParseControlRendererInfo(strBtn, params))
				{
					m_ctrlTabFlat[0].Create(params);
					m_ctrlTabFlat[1].Create(params, TRUE);
				}
			}

			tmTab.ReadColor(_T("Black"), m_clrTabFlatBlack);
			tmTab.ReadColor(_T("Highlight"), m_clrTabFlatHighlight);

			COLORREF clr;
			if (tmTab.ReadColor(_T("BorderInnerNormal"), clr))
			{
				m_penTabFlatInner[0].DeleteObject();
				m_penTabFlatInner[0].CreatePen(PS_SOLID, 1, clr);
			}
			if (tmTab.ReadColor(_T("BorderInnerActive"), clr))
			{
				m_penTabFlatInner[1].DeleteObject();
				m_penTabFlatInner[1].CreatePen(PS_SOLID, 1, clr);
			}
			if (tmTab.ReadColor(_T("BorderOuterNormal"), clr))
			{
				m_penTabFlatOuter[0].DeleteObject();
				m_penTabFlatOuter[0].CreatePen(PS_SOLID, 1, clr);
			}
			if (tmTab.ReadColor(_T("BorderOuterActive"), clr))
			{
				m_penTabFlatOuter[1].DeleteObject();
				m_penTabFlatOuter[1].CreatePen(PS_SOLID, 1, clr);
			}
		}
	}

	if (tm.ExcludeTag(_T("HEADER"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("NormalStart"), m_clrHeaderNormalStart);
		tmItem.ReadColor(_T("NormalFinish"), m_clrHeaderNormalFinish);
		tmItem.ReadColor(_T("NormalBorder"), m_clrHeaderNormalBorder);
		tmItem.ReadColor(_T("HighlightedStart"), m_clrHeaderHighlightedStart);
		tmItem.ReadColor(_T("HighlightedFinish"), m_clrHeaderHighlightedFinish);
		tmItem.ReadColor(_T("HighlightedBorder"), m_clrHeaderHighlightedBorder);
		tmItem.ReadColor(_T("PressedStart"), m_clrHeaderPressedStart);
		tmItem.ReadColor(_T("PressedFinish"), m_clrHeaderPressedFinish);
		tmItem.ReadColor(_T("PressedBorder"), m_clrHeaderPressedBorder);
	}

	m_clrRibbonCategoryText                = m_clrMenuBarBtnText;
	m_clrRibbonCategoryTextHighlighted     = m_clrMenuBarBtnTextHighlighted;
	m_clrRibbonCategoryTextDisabled		   = m_clrMenuBarBtnTextDisabled;
	m_clrRibbonPanelText                   = m_clrToolBarBtnText;
	m_clrRibbonPanelTextHighlighted        = m_clrToolBarBtnTextHighlighted;
	m_clrRibbonPanelCaptionText            = m_clrRibbonPanelText;
	m_clrRibbonPanelCaptionTextHighlighted = m_clrRibbonPanelTextHighlighted;

	m_clrRibbonEdit                        = afxGlobalData.clrBarLight;
	m_clrRibbonEditHighlighted             = afxGlobalData.clrWindow;
	m_clrRibbonEditPressed                 = m_clrRibbonEditHighlighted;
	m_clrRibbonEditDisabled                = afxGlobalData.clrBtnFace;

	if (tm.ExcludeTag(_T("RIBBON"), strItem))
	{
		CTagManager tmItem(strItem);

		CString str;

		if (tmItem.ExcludeTag(_T("CATEGORY"), str))
		{
			CTagManager tmCategory(str);
			tmCategory.ReadControlRenderer(_T("BACK"), m_ctrlRibbonCategoryBack, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CATEGORY_BACK")));

			CString strTab;
			if (tmCategory.ExcludeTag(_T("TAB"), strTab))
			{
				CTagManager tmTab(strTab);
				tmTab.ReadControlRenderer(_T("BUTTON"), m_ctrlRibbonCategoryTab, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CATEGORY_TAB")));

				tmTab.ReadColor(_T("TextNormal"), m_clrRibbonCategoryText);
				tmTab.ReadColor(_T("TextHighlighted"), m_clrRibbonCategoryTextHighlighted);
				tmTab.ReadColor(_T("TextDisabled"), m_clrRibbonCategoryTextDisabled);
			}

			tmCategory.ReadControlRenderer(_T("TAB_SEPARATOR"), m_ctrlRibbonCategoryTabSep, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CATEGORY_TAB_SEP")));

			tmCategory.ReadControlRenderer(_T("BUTTON_PAGE_L"), m_ctrlRibbonCategoryBtnPage[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PAGE_L")));
			tmCategory.ReadControlRenderer(_T("BUTTON_PAGE_R"), m_ctrlRibbonCategoryBtnPage[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PAGE_R")));
		}

		if (tmItem.ExcludeTag(_T("PANEL"), str))
		{
			CTagManager tmPanel(str);

			{
				CString strBack;
				if (tmPanel.ExcludeTag(_T("BACK"), strBack))
				{
					CTagManager tmBack(strBack);

					tmBack.ReadControlRenderer(_T("TOP"), m_ctrlRibbonPanelBack_T, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_BACK_T")));
					tmBack.ReadControlRenderer(_T("BOTTOM"), m_ctrlRibbonPanelBack_B, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_BACK_B")));
				}
			}

			{
				CString strCaption;
				if (tmPanel.ExcludeTag(_T("CAPTION"), strCaption))
				{
					CTagManager tmCaption(strCaption);

					tmCaption.ReadControlRenderer(_T("LAUNCH_BTN"), m_ctrlRibbonBtnLaunch, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_LAUNCH")));
					tmCaption.ReadToolBarImages(_T("LAUNCH_ICON"), m_RibbonBtnLaunchIcon, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_LAUNCH_ICON")));
					tmCaption.ReadColor(_T("TextNormal"), m_clrRibbonPanelCaptionText);
					tmCaption.ReadColor(_T("TextHighlighted"), m_clrRibbonPanelCaptionTextHighlighted);

					m_RibbonBtnLaunchIcon.SmoothResize(afxGlobalData.GetRibbonImageScale());
				}
			}

			tmPanel.ReadToolBarImages(_T("SEPARATOR"), m_RibbonPanelSeparator, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_SEPARATOR")));
			tmPanel.ReadControlRenderer(_T("QAT"), m_ctrlRibbonPanelQAT, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_QAT")));

			{
				CString strButtons;
				if (tmPanel.ExcludeTag(_T("BUTTONS"), strButtons))
				{
					CTagManager tmButtons(strButtons);

					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_F"), m_ctrlRibbonBtnGroup_F, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUP_F")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_M"), m_ctrlRibbonBtnGroup_M, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUP_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_L"), m_ctrlRibbonBtnGroup_L, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUP_L")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_S"), m_ctrlRibbonBtnGroup_S, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUP_S")));

					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_F_C"), m_ctrlRibbonBtnGroupMenu_F[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_F_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_F_M"), m_ctrlRibbonBtnGroupMenu_F[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_F_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_M_C"), m_ctrlRibbonBtnGroupMenu_M[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_M_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_M_M"), m_ctrlRibbonBtnGroupMenu_M[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_M_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_L_C"), m_ctrlRibbonBtnGroupMenu_L[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_L_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_L_M"), m_ctrlRibbonBtnGroupMenu_L[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_GROUPMENU_L_M")));

					tmButtons.ReadControlRenderer(_T("BUTTON_NORMAL_S"), m_ctrlRibbonBtn[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_NORMAL_S")));
					tmButtons.ReadControlRenderer(_T("BUTTON_NORMAL_B"), m_ctrlRibbonBtn[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_NORMAL_B")));

					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT"), m_ctrlRibbonBtnDefault, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_DEFAULT")));
					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT_ICON"), m_ctrlRibbonBtnDefaultIcon, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_DEFAULT_ICON")));
					tmButtons.ReadToolBarImages(_T("BUTTON_DEFAULT_IMAGE"), m_RibbonBtnDefaultImage, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_DEFAULT_IMAGE")));
					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT_QAT"), m_ctrlRibbonBtnDefaultQAT, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_DEFAULT_QAT")));

					if (!m_ctrlRibbonBtnDefaultQAT.IsValid())
					{
						tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT_QAT_ICON"), m_ctrlRibbonBtnDefaultQATIcon, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_DEFAULT_QAT_ICON")));
					}

					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_H_C"), m_ctrlRibbonBtnMenuH[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_MENU_H_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_H_M"), m_ctrlRibbonBtnMenuH[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_MENU_H_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_V_C"), m_ctrlRibbonBtnMenuV[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_MENU_V_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_V_M"), m_ctrlRibbonBtnMenuV[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_MENU_V_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_CHECK"), m_ctrlRibbonBtnCheck, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_CHECK")));

					m_ctrlRibbonBtnCheck.SmoothResize(afxGlobalData.GetRibbonImageScale());

					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_T"), m_ctrlRibbonBtnPalette[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PALETTE_T")));
					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_M"), m_ctrlRibbonBtnPalette[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PALETTE_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_B"), m_ctrlRibbonBtnPalette[2], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PALETTE_B")));
				}
			}

			{
				CString strEdit;
				if (tmPanel.ExcludeTag(_T("EDIT"), strEdit))
				{
					CTagManager tmEdit(strEdit);

					tmEdit.ReadColor(_T("Normal"), m_clrRibbonEdit);
					tmEdit.ReadColor(_T("Highlighted"), m_clrRibbonEditHighlighted);
					tmEdit.ReadColor(_T("Disabled"), m_clrRibbonEditDisabled);
					tmEdit.ReadColor(_T("Pressed"), m_clrRibbonEditPressed);

					tmEdit.ReadColor(_T("BorderNormal"), m_clrRibbonEditBorder);
					tmEdit.ReadColor(_T("BorderHighlighted"), m_clrRibbonEditBorderHighlighted);
					tmEdit.ReadColor(_T("BorderDisabled"), m_clrRibbonEditBorderDisabled);
					tmEdit.ReadColor(_T("BorderPressed"), m_clrRibbonEditBorderPressed);
					tmEdit.ReadColor(_T("Selection"), m_clrRibbonEditSelection);

					CString strButton;
					if (tmEdit.ExcludeTag(_T("BUTTON"), strButton))
					{
						CTagManager tmButton(strButton);

						tmButton.ReadColor(_T("GradientStartNormal"), m_clrRibbonComboBtnStart);
						tmButton.ReadColor(_T("GradientFinishNormal"), m_clrRibbonComboBtnFinish);
						tmButton.ReadColor(_T("BtnBorderNormal"), m_clrRibbonComboBtnBorder);

						if (!tmButton.ReadControlRenderer(_T("IMAGE"), m_ctrlRibbonComboBoxBtn, MakeResourceID(_T("IDB_OFFICE2007_COMBOBOX_BTN"))))
						{
							tmButton.ReadColor(_T("GradientStartHighlighted"), m_clrRibbonComboBtnHighlightedStart);
							tmButton.ReadColor(_T("GradientFinishHighlighted"), m_clrRibbonComboBtnHighlightedFinish);
							tmButton.ReadColor(_T("GradientStartDisabled"), m_clrRibbonComboBtnDisabledStart);
							tmButton.ReadColor(_T("GradientFinishDisabled"), m_clrRibbonComboBtnDisabledFinish);
							tmButton.ReadColor(_T("GradientStartPressed"), m_clrRibbonComboBtnPressedStart);
							tmButton.ReadColor(_T("GradientFinishPressed"), m_clrRibbonComboBtnPressedFinish);

							tmButton.ReadColor(_T("BtnBorderHighlighted"), m_clrRibbonComboBtnBorderHighlighted);
							tmButton.ReadColor(_T("BtnBorderDisabled"), m_clrRibbonComboBtnBorderDisabled);

							m_clrRibbonComboBtnBorderPressed = m_clrRibbonComboBtnBorderHighlighted;
							tmButton.ReadColor(_T("BtnBorderPressed"), m_clrRibbonComboBtnBorderPressed);
						}
					}
				}
			}

			tmPanel.ReadColor(_T("TextNormal"), m_clrRibbonPanelText);
			tmPanel.ReadColor(_T("TextHighlighted"), m_clrRibbonPanelTextHighlighted);
		}

		if (tmItem.ExcludeTag(_T("CONTEXT"), str))
		{
			CTagManager tmContext(str);

			CString strCategory;
			if (tmContext.ExcludeTag(_T("CATEGORY"), strCategory))
			{
				CTagManager tmCategory(strCategory);

				CMFCControlRendererInfo prBack;
				CMFCControlRendererInfo prCaption;
				CMFCControlRendererInfo prTab;
				CMFCControlRendererInfo prDefault;
				COLORREF clrText = m_clrRibbonCategoryText;
				COLORREF clrTextHighlighted = m_clrRibbonCategoryTextHighlighted;
				COLORREF clrCaptionText = clrText;

				tmCategory.ReadControlRendererInfo(_T("BACK"), prBack);

				CString strTab;
				if (tmCategory.ExcludeTag(_T("TAB"), strTab))
				{
					CTagManager tmTab(strTab);

					tmTab.ReadControlRendererInfo(_T("BUTTON"), prTab);
					tmTab.ReadColor(_T("TextNormal"), clrText);
					tmTab.ReadColor(_T("TextHighlighted"), clrTextHighlighted);
				}

				CString strCaption;
				if (tmCategory.ExcludeTag(_T("CAPTION"), strCaption))
				{
					CTagManager tmCaption(strCaption);

					tmCaption.ReadControlRendererInfo(_T("BACK"), prCaption);
					tmCaption.ReadColor(_T("TextNormal"), clrCaptionText);
				}

				tmCategory.ReadControlRendererInfo(_T("BUTTON_DEFAULT"), prDefault);

				CString strID[AFX_RIBBON_CATEGORY_COLOR_COUNT] =
				{
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_R_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_O_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_Y_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_G_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_B_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_I_")),
					MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_V_"))
				};

				for (int i = 0; i < AFX_RIBBON_CATEGORY_COLOR_COUNT; i++)
				{
					CMFCRibbonContextCategory& cat = m_ctrlRibbonContextCategory[i];

					prDefault.m_strBmpResID = strID[i] + _T("BTN_DEFAULT");
					prTab.m_strBmpResID     = strID[i] + _T("CATEGORY_TAB");
					prCaption.m_strBmpResID = strID[i] + _T("CATEGORY_CAPTION");
					prBack.m_strBmpResID    = strID[i] + _T("CATEGORY_BACK");

					cat.m_ctrlBtnDefault.Create(prDefault);
					cat.m_ctrlCaption.Create(prCaption);
					cat.m_ctrlTab.Create(prTab);
					cat.m_ctrlBack.Create(prBack);
					cat.m_clrText            = clrText;
					cat.m_clrTextHighlighted = clrTextHighlighted;
					cat.m_clrCaptionText     = clrCaptionText;
				}
			}

			CString strPanel;
			if (tmContext.ExcludeTag(_T("PANEL"), strPanel))
			{
				CTagManager tmPanel(strPanel);

				CString strBack;
				if (tmPanel.ExcludeTag(_T("BACK"), strBack))
				{
					CTagManager tmBack(strBack);

					tmBack.ReadControlRenderer(_T("TOP"), m_ctrlRibbonContextPanelBack_T, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_PANEL_BACK_T")));
					tmBack.ReadControlRenderer(_T("BOTTOM"), m_ctrlRibbonContextPanelBack_B, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_PANEL_BACK_B")));
				}

				CString strCaption;
				if (tmPanel.ExcludeTag(_T("CAPTION"), strCaption))
				{
					CTagManager tmCaption(strCaption);

					tmCaption.ReadColor(_T("TextNormal"), m_clrRibbonContextPanelCaptionText);
					tmCaption.ReadColor(_T("TextHighlighted"), m_clrRibbonContextPanelCaptionTextHighlighted);
				}

				tmPanel.ReadColor(_T("TextNormal"), m_clrRibbonContextPanelText);
				tmPanel.ReadColor(_T("TextHighlighted"), m_clrRibbonContextPanelTextHighlighted);
			}

			tmContext.ReadControlRenderer(_T("SEPARATOR"), m_ctrlRibbonContextSeparator, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CONTEXT_SEPARATOR")));
		}

		tmItem.ReadControlRenderer(_T("MAIN_BUTTON"), m_RibbonBtnMain, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_MAIN")));

		if (m_RibbonBtnMain.IsValid())
		{
			m_RibbonBtnMain.SmoothResize (afxGlobalData.GetRibbonImageScale());
		}

		if (tmItem.ExcludeTag(_T("MAIN"), str))
		{
			CTagManager tmMain(str);
			tmMain.ReadControlRenderer(_T("BACK"), m_ctrlRibbonMainPanel, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_MAIN")));
			tmMain.ReadControlRenderer(_T("BORDER"), m_ctrlRibbonMainPanelBorder, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PANEL_MAIN_BORDER")));
			tmMain.ReadControlRenderer(_T("BUTTON"), m_ctrlRibbonBtnMainPanel, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PANEL_MAIN")));
		}

		if (tmItem.ExcludeTag(_T("CAPTION"), str))
		{
			CTagManager tmCaption(str);
			tmCaption.ReadControlRenderer(_T("QA"), m_ctrlRibbonCaptionQA, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CAPTION_QA")));
			tmCaption.ReadControlRenderer(_T("QA_GLASS"), m_ctrlRibbonCaptionQA_Glass, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_CAPTION_QA_GLASS")));
		}

		if (tmItem.ExcludeTag(_T("STATUS"), str))
		{
			CTagManager tmStatus(str);
			tmStatus.ReadControlRenderer(_T("PANE_BUTTON"), m_ctrlRibbonBtnStatusPane, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_STATUS_PANE")));

			CString strSlider;
			if (tmStatus.ExcludeTag(_T("SLIDER"), strSlider))
			{
				CTagManager tmSlider(strSlider);

				tmSlider.ReadControlRenderer(_T("THUMB"), m_ctrlRibbonSliderThumb, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_SLIDER_THUMB")));
				tmSlider.ReadControlRenderer(_T("PLUS"), m_ctrlRibbonSliderBtnPlus, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_SLIDER_BTN_PLUS")));
				tmSlider.ReadControlRenderer(_T("MINUS"), m_ctrlRibbonSliderBtnMinus, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_SLIDER_BTN_MINUS")));

				m_ctrlRibbonSliderThumb.SmoothResize(afxGlobalData.GetRibbonImageScale());
				m_ctrlRibbonSliderBtnMinus.SmoothResize(afxGlobalData.GetRibbonImageScale());
				m_ctrlRibbonSliderBtnPlus.SmoothResize(afxGlobalData.GetRibbonImageScale());
			}

			CString strProgress;
			if (tmStatus.ExcludeTag(_T("PROGRESS"), strProgress))
			{
				CTagManager tmProgress(strProgress);

				tmProgress.ReadControlRenderer(_T("BACK"), m_ctrlRibbonProgressBack, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PROGRESS_BACK")));
				tmProgress.ReadControlRenderer(_T("NORMAL"), m_ctrlRibbonProgressNormal, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PROGRESS_NORMAL")));
				tmProgress.ReadControlRenderer(_T("NORMAL_EXT"), m_ctrlRibbonProgressNormalExt, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PROGRESS_NORMAL_EXT")));
				tmProgress.ReadControlRenderer(_T("INFINITY"), m_ctrlRibbonProgressInfinity, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_PROGRESS_INFINITY")));
			}
		}

		if (tmItem.ExcludeTag(_T("BORDERS"), str))
		{
			CTagManager tmBorders(str);

			tmBorders.ReadControlRenderer(_T("QAT"), m_ctrlRibbonBorder_QAT, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BORDER_QAT")));
			tmBorders.ReadControlRenderer(_T("FLOATY"), m_ctrlRibbonBorder_Floaty, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BORDER_FLOATY")));
		}

		if (tmItem.ExcludeTag(_T("KEYTIP"), str))
		{
			CTagManager tmKeyTip(str);

			tmKeyTip.ReadControlRenderer(_T("BACK"), m_ctrlRibbonKeyTip, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_KEYTIP_BACK")));
			tmKeyTip.ReadColor(_T("TextNormal"), m_clrRibbonKeyTipTextNormal);

			BOOL bSystem = FALSE;
			if (m_clrRibbonKeyTipTextNormal == (COLORREF)(-1))
			{
				if (m_bToolTipParams && m_ToolTipParams.m_clrText != (COLORREF)(-1))
				{
					m_clrRibbonKeyTipTextNormal = m_ToolTipParams.m_clrText;
				}
				else
				{
					bSystem = TRUE;
					m_clrRibbonKeyTipTextNormal = ::GetSysColor(COLOR_INFOTEXT);
				}
			}

			tmKeyTip.ReadColor(_T("TextDisabled"), m_clrRibbonKeyTipTextDisabled);

			if (m_clrRibbonKeyTipTextDisabled == (COLORREF)(-1))
			{
				if (bSystem)
				{
					m_clrRibbonKeyTipTextDisabled = afxGlobalData.clrGrayedText;
				}
				else
				{
					m_clrRibbonKeyTipTextDisabled = CDrawingManager::PixelAlpha(
						m_clrRibbonKeyTipTextNormal, afxGlobalData.clrWindow, 50);
				}
			}
		}

		if (tmItem.ExcludeTag(_T("HYPERLINK"), str))
		{
			CTagManager tmHyperlink(str);

			tmHyperlink.ReadColor(_T("Inactive"), m_clrRibbonHyperlinkInactive);
			tmHyperlink.ReadColor(_T("Active"), m_clrRibbonHyperlinkActive);
			tmHyperlink.ReadColor(_T("StatusbarInactive"), m_clrRibbonStatusbarHyperlinkInactive);
			tmHyperlink.ReadColor(_T("StatusbarActive"), m_clrRibbonStatusbarHyperlinkActive);
		}
	}

	m_clrOutlookCaptionTextNormal   = m_clrCaptionBarText;
	m_clrOutlookPageTextNormal      = m_clrOutlookCaptionTextNormal;
	m_clrOutlookPageTextHighlighted = m_clrOutlookPageTextNormal;
	m_clrOutlookPageTextPressed     = m_clrOutlookPageTextNormal;

	if (tm.ExcludeTag(_T("OUTLOOK"), strItem))
	{
		CTagManager tmItem(strItem);

		CString str;
		if (tmItem.ExcludeTag(_T("CAPTION"), str))
		{
			CTagManager tmCaption(str);

			tmCaption.ReadColor(_T("TextNormal"), m_clrOutlookCaptionTextNormal);
		}

		if (tmItem.ExcludeTag(_T("PAGEBUTTON"), str))
		{
			CTagManager tmPage(str);

			tmPage.ReadControlRenderer(_T("BACK"), m_ctrlOutlookWndPageBtn, MakeResourceID(_T("IDB_OFFICE2007_OUTLOOK_BTN_PAGE")));

			tmPage.ReadColor(_T("TextNormal"), m_clrOutlookPageTextNormal);
			tmPage.ReadColor(_T("TextHighlighted"), m_clrOutlookPageTextHighlighted);
			tmPage.ReadColor(_T("TextPressed"), m_clrOutlookPageTextPressed);
		}

		if (tmItem.ExcludeTag(_T("BAR"), str))
		{
			CTagManager tmBar(str);

			tmBar.ReadControlRenderer(_T("BACK"), m_ctrlOutlookWndBar, MakeResourceID(_T("IDB_OFFICE2007_OUTLOOK_BAR_BACK")));
		}
	}

	// Popup Window:
	m_clrPopupGradientLight = m_clrBarGradientLight;
	m_clrPopupGradientDark = m_clrBarGradientDark;

	if (tm.ExcludeTag(_T("POPUP"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadColor(_T("GradientFillLight"), m_clrPopupGradientLight);
		tmItem.ReadColor(_T("GradientFillDark"), m_clrPopupGradientDark);
	}

	if (hinstResOld != NULL)
	{
		AfxSetResourceHandle(hinstResOld);
	}
}

BOOL CMFCVisualManagerOffice2007::IsWindowActive(CWnd* pWnd) const
{
	BOOL bActive = FALSE;

	HWND hWnd = pWnd->GetSafeHwnd();

	if (hWnd != NULL)
	{
		if (!m_ActivateFlag.Lookup(pWnd->GetSafeHwnd(), bActive))
		{
			//ASSERT(FALSE);
			bActive = TRUE;
		}
	}

	return bActive;
}

BOOL CMFCVisualManagerOffice2007::OnNcActivate(CWnd* pWnd, BOOL bActive)
{
	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		return FALSE;
	}

	// stay active if WF_STAYACTIVE bit is on
	if (pWnd->m_nFlags & WF_STAYACTIVE)
	{
		bActive = TRUE;
	}

	// but do not stay active if the window is disabled
	if (!pWnd->IsWindowEnabled())
	{
		bActive = FALSE;
	}

	BOOL bIsMDIFrame = FALSE;
	BOOL bWasActive = FALSE;

	// If the active state of an owner-draw MDI frame window changes, we need to
	// invalidate the MDI client area so the MDI child window captions are redrawn.
	if (IsOwnerDrawCaption())
	{
		bIsMDIFrame = pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd));
		bWasActive = IsWindowActive(pWnd);
	}

	m_ActivateFlag[pWnd->GetSafeHwnd()] = bActive;
	pWnd->SendMessage(WM_NCPAINT, 0, 0);

	if (IsOwnerDrawCaption())
	{
		if (bIsMDIFrame && (bWasActive != bActive))
		{
			::RedrawWindow(((CMDIFrameWnd *)pWnd)->m_hWndMDIClient, NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN);
		}
	}

	return TRUE;
}

void CMFCVisualManagerOffice2007::DrawNcBtn(CDC* pDC, const CRect& rect, UINT nButton, AFX_BUTTON_STATE state, BOOL bSmall, BOOL bActive, BOOL bMDI/* = FALSE*/)
{
	ASSERT_VALID(pDC);

	CMFCToolBarImages* pImage = NULL;

	int nIndex = bSmall ? 1 : 0;

	if (nButton == SC_CLOSE)
	{
		pImage = &m_SysBtnClose[nIndex];
	}
	else if (nButton == SC_MINIMIZE)
	{
		pImage = &m_SysBtnMinimize[nIndex];
	}
	else if (nButton == SC_MAXIMIZE)
	{
		pImage = &m_SysBtnMaximize[nIndex];
	}
	else if (nButton == SC_RESTORE)
	{
		pImage = &m_SysBtnRestore[nIndex];
	}
	else
	{
		return;
	}

	CMFCToolBarImages::ImageAlignHorz horz = afxGlobalData.GetRibbonImageScale() != 1. ? CMFCToolBarImages::ImageAlignHorzStretch : CMFCToolBarImages::ImageAlignHorzCenter;
	CMFCToolBarImages::ImageAlignVert vert = afxGlobalData.GetRibbonImageScale() != 1. ? CMFCToolBarImages::ImageAlignVertStretch : CMFCToolBarImages::ImageAlignVertCenter;

	CRect rtBtnImage(CPoint(0, 0), pImage->GetImageSize());

	if (!bActive)
	{
		rtBtnImage.OffsetRect(0, pImage->GetImageSize().cy * 3);
	}
	else
	{
		if (state != ButtonsIsRegular)
		{
			if (!IsBeta() && bMDI)
			{
				m_ctrlRibbonBtn[0].Draw(pDC, rect, state == ButtonsIsHighlighted ? 0 : 1);
			}
			else
			{
				m_SysBtnBack[nIndex].Draw(pDC, rect, state == ButtonsIsHighlighted ? 0 : 1);
			}

			rtBtnImage.OffsetRect(0, pImage->GetImageSize().cy * (state == ButtonsIsHighlighted ? 1 : 2));
		}
	}

	pImage->DrawEx(pDC, rect, 0, horz, vert, rtBtnImage);
}

void CMFCVisualManagerOffice2007::DrawNcText(CDC* pDC, CRect& rect, const CString& strTitle, const CString& strDocument, BOOL bPrefix, BOOL bActive,
	BOOL bIsRTL, BOOL bTextCenter, BOOL bGlass/* = FALSE*/, int nGlassGlowSize/* = 0*/, COLORREF clrGlassText/* = (COLORREF)-1*/)
{
	if ((strTitle.IsEmpty() && strDocument.IsEmpty()) || rect.right <= rect.left)
	{
		return;
	}

	ASSERT_VALID(pDC);

	int nOldMode = pDC->SetBkMode(TRANSPARENT);
	COLORREF clrOldText = pDC->GetTextColor();

	DWORD dwTextStyle = DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER | (bIsRTL ? DT_RTLREADING : 0);

	if (strDocument.IsEmpty())
	{
		COLORREF clrText = bActive ? m_clrAppCaptionActiveTitleText : m_clrAppCaptionInactiveTitleText;

		int widthFull = rect.Width();
		int width = pDC->GetTextExtent(strTitle).cx;

		if (bTextCenter && width < widthFull)
		{
			rect.left += (widthFull - width) / 2;
		}

		rect.right = min(rect.left + width, rect.right);

		if (rect.right > rect.left)
		{
			if (bGlass)
			{
				DrawTextOnGlass(pDC, strTitle, rect, dwTextStyle, nGlassGlowSize, clrGlassText);
			}
			else
			{
				pDC->SetTextColor(clrText);
				pDC->DrawText(strTitle, rect, dwTextStyle);
			}
		}
	}
	else
	{
		const CString& str1 = bPrefix ? strDocument : strTitle;
		const CString& str2 = bPrefix ? strTitle : strDocument;

		COLORREF clrText1 = bActive ? m_clrAppCaptionActiveText : m_clrAppCaptionInactiveText;
		COLORREF clrText2 = bActive ? m_clrAppCaptionActiveTitleText : m_clrAppCaptionInactiveTitleText;

		if (!bPrefix)
		{
			COLORREF clr = clrText1;
			clrText1 = clrText2;
			clrText2 = clr;
		}

		int widthFull = rect.Width();
		CSize sz1 = pDC->GetTextExtent(str1);
		CSize sz2 = pDC->GetTextExtent(str2);
		int width = sz1.cx + sz2.cx;
		int left = rect.left;

		if (bTextCenter && width < widthFull)
		{
			rect.left += (widthFull - width) / 2;
		}

		rect.right = min(rect.left + width, rect.right);

		if (bIsRTL)
		{
			if (width <= rect.Width())
			{
				rect.left += sz2.cx;
			}
			else
			{
				if (sz1.cx < rect.Width())
				{
					rect.left += max(0, sz2.cx +(rect.Width() - width));
				}
			}
		}

		if (bGlass)
		{
			DrawTextOnGlass(pDC, str1, rect, dwTextStyle, nGlassGlowSize, clrGlassText);
		}
		else
		{
			pDC->SetTextColor(clrText1);
			pDC->DrawText(str1, rect, dwTextStyle);
		}

		if (bIsRTL)
		{
			if (width <= (rect.right - left))
			{
				rect.right = rect.left;
				rect.left  = rect.right - sz2.cx;
			}
			else
			{
				rect.left = left;
				rect.right -= sz1.cx;
			}
		}
		else
		{
			rect.left += sz1.cx;
		}

		if (rect.right > rect.left)
		{
			if (bGlass)
			{
				DrawTextOnGlass(pDC, str2, rect, dwTextStyle, nGlassGlowSize, clrGlassText);
			}
			else
			{
				pDC->SetTextColor(clrText2);
				pDC->DrawText(str2, rect, dwTextStyle);
			}
		}
	}

	pDC->SetBkMode(nOldMode);
	pDC->SetTextColor(clrOldText);
}

void CMFCVisualManagerOffice2007::DrawNcCaption(CDC* pDC, CRect rectCaption, DWORD dwStyle, DWORD dwStyleEx, const CString& strTitle,
	const CString& strDocument, HICON hIcon, BOOL bPrefix, BOOL bActive, BOOL bTextCenter, const CObList& lstSysButtons)
{
	const BOOL bIsRTL = (dwStyleEx & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
	const int nSysCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
	CSize szSysBorder(GetSystemBorders(FALSE));

	CDC memDC;
	memDC.CreateCompatibleDC(pDC);
	CBitmap memBmp;
	memBmp.CreateCompatibleBitmap(pDC, rectCaption.Width(), rectCaption.Height());
	CBitmap* pBmpOld = memDC.SelectObject(&memBmp);
	memDC.BitBlt(0, 0, rectCaption.Width(), rectCaption.Height(), pDC, 0, 0, SRCCOPY);

	BOOL bMaximized = (dwStyle & WS_MAXIMIZE) == WS_MAXIMIZE;

	{
		if (IsBeta())
		{
			COLORREF clr1  = bActive ? m_clrAppCaptionActiveStart : m_clrAppCaptionInactiveStart;
			COLORREF clr2  = bActive ? m_clrAppCaptionActiveFinish : m_clrAppCaptionInactiveFinish;

			CRect rectCaption1(rectCaption);
			CRect rectBorder(m_ctrlMainBorderCaption.GetParams().m_rectSides);

			rectCaption1.DeflateRect(rectBorder.left, rectBorder.top, rectBorder.right, rectBorder.bottom);

			{
				CDrawingManager dm(memDC);
				dm.Fill4ColorsGradient(rectCaption1, clr1, clr2, clr2, clr1, FALSE);
			}

			m_ctrlMainBorderCaption.DrawFrame(&memDC, rectCaption, bActive ? 0 : 1);
		}
		else
		{
			m_ctrlMainBorderCaption.Draw(&memDC, rectCaption, bActive ? 0 : 1);
		}
	}

	CRect rect(rectCaption);
	rect.DeflateRect(szSysBorder.cx, bMaximized ? szSysBorder.cy : 0, szSysBorder.cx, 0);

	// Draw icon:
	if (hIcon != NULL)
	{
		CSize szIcon(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));
		CRect rectIcon(rect.TopLeft(), CSize(nSysCaptionHeight, rect.Height()));

		long x = rect.left + max(0, (rectIcon.Width()  - szIcon.cx) / 2);
		long y = rect.top  + max(0, (rectIcon.Height() - szIcon.cy) / 2);

		::DrawIconEx(memDC.GetSafeHdc(), x, y, hIcon, szIcon.cx, szIcon.cy, 0, NULL, DI_NORMAL);

		rect.left += rectIcon.Width();
	}

	// Draw system buttons:
	int xButtonsRight = rect.right;

	for (POSITION pos = lstSysButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButtonEx* pButton = (CMFCCaptionButtonEx*)lstSysButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		AFX_BUTTON_STATE state = ButtonsIsRegular;

		if (pButton->m_bPushed && pButton->m_bFocused)
		{
			state = ButtonsIsPressed;
		}
		else if (pButton->m_bFocused)
		{
			state = ButtonsIsHighlighted;
		}

		UINT uiHit = pButton->GetHit();
		UINT nButton = 0;

		switch(uiHit)
		{
		case AFX_HTCLOSE:
			nButton = SC_CLOSE;
			break;

		case AFX_HTMAXBUTTON:
			nButton = (dwStyle & WS_MAXIMIZE) == WS_MAXIMIZE ? SC_RESTORE : SC_MAXIMIZE;
			break;

		case AFX_HTMINBUTTON:
			nButton = (dwStyle & WS_MINIMIZE) == WS_MINIMIZE ? SC_RESTORE : SC_MINIMIZE;
			break;
		}

		CRect rectBtn(pButton->GetRect());
		if (bMaximized)
		{
			rectBtn.OffsetRect(szSysBorder.cx, szSysBorder.cy);
		}

		DrawNcBtn(&memDC, rectBtn, nButton, state, FALSE, bActive, FALSE);

		xButtonsRight = min(xButtonsRight, pButton->GetRect().left);
	}

	// Draw text:
	if ((!strTitle.IsEmpty() || !strDocument.IsEmpty()) && rect.left < rect.right)
	{
		CFont* pOldFont = (CFont*)memDC.SelectObject(&m_AppCaptionFont);

		CRect rectText = rect;
		rectText.right = xButtonsRight - 1;

		DrawNcText(&memDC, rectText, strTitle, strDocument, bPrefix, bActive, bIsRTL, bTextCenter);

		memDC.SelectObject(pOldFont);
	}

	pDC->BitBlt(rectCaption.left, rectCaption.top, rectCaption.Width(), rectCaption.Height(), &memDC, 0, 0, SRCCOPY);
	memDC.SelectObject(pBmpOld);
}

CMFCRibbonBar* CMFCVisualManagerOffice2007::GetRibbonBar(CWnd* pWnd) const
{
	CMFCRibbonBar* pBar = NULL;

	if (pWnd == NULL)
	{
		pWnd = AfxGetMainWnd();
	}

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	if (pWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		pBar = ((CFrameWndEx*) pWnd)->GetRibbonBar();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		pBar = ((CMDIFrameWndEx*) pWnd)->GetRibbonBar();
	}

	return pBar;
}

BOOL CMFCVisualManagerOffice2007::IsRibbonPresent(CWnd* pWnd) const
{
	CMFCRibbonBar* pBar = GetRibbonBar(pWnd);

	return pBar != NULL && pBar->IsWindowVisible();
}

BOOL CMFCVisualManagerOffice2007::OnNcPaint(CWnd* pWnd, const CObList& lstSysButtons, CRect rectRedraw)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnNcPaint(pWnd, lstSysButtons, rectRedraw);
	}

	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	CWindowDC dc(pWnd);

	if (dc.GetSafeHdc() != NULL)
	{
		CRgn rgn;
		if (!rectRedraw.IsRectEmpty())
		{
			rgn.CreateRectRgnIndirect(rectRedraw);
			dc.SelectClipRgn(&rgn);
		}


		CMFCRibbonBar* pBar = GetRibbonBar(pWnd);
		BOOL bRibbonCaption  = pBar != NULL && pBar->IsWindowVisible() && pBar->IsReplaceFrameCaption();

		CRect rtWindow;
		pWnd->GetWindowRect(rtWindow);
		pWnd->ScreenToClient(rtWindow);

		CRect rtClient;
		pWnd->GetClientRect(rtClient);

		rtClient.OffsetRect(-rtWindow.TopLeft());
		dc.ExcludeClipRect(rtClient);

		rtWindow.OffsetRect(-rtWindow.TopLeft());

		BOOL bActive = IsWindowActive(pWnd);

		// Modify bActive (if currently TRUE) for owner-drawn MDI child windows: draw child
		// frame active only if window is active MDI child and the MDI frame window is active.
		if (bActive && IsOwnerDrawCaption() && pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)))
		{
			CMDIFrameWnd *pParent = ((CMDIChildWnd *)pWnd)->GetMDIFrame();
			if (pParent)
			{
				CMDIChildWnd *pActiveChild = pParent->MDIGetActive(NULL);
				if (pActiveChild)
				{
					bActive = ((pActiveChild->GetSafeHwnd() == pWnd->GetSafeHwnd()) && IsWindowActive(pParent));
				}
			}
		}

		CRect rectCaption(rtWindow);
		CSize szSysBorder(GetSystemBorders(bRibbonCaption));

		rectCaption.bottom = rectCaption.top + szSysBorder.cy;

		const DWORD dwStyle = pWnd->GetStyle();
		BOOL bMaximized = (dwStyle & WS_MAXIMIZE) == WS_MAXIMIZE;

		if (!bRibbonCaption)
		{
			const int nSysCaptionHeight = ::GetSystemMetrics(SM_CYCAPTION);
			rectCaption.bottom += nSysCaptionHeight;

			const DWORD dwStyleEx = pWnd->GetExStyle();

			HICON hIcon = afxGlobalUtils.GetWndIcon(pWnd);

			CString strText;
			pWnd->GetWindowText(strText);

			CString strTitle(strText);
			CString strDocument;

			BOOL bPrefix = FALSE;
			if ((dwStyle & FWS_ADDTOTITLE) == FWS_ADDTOTITLE)
			{
				bPrefix = (dwStyle & FWS_PREFIXTITLE) == FWS_PREFIXTITLE;
				CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, pWnd);

				if (pFrameWnd != NULL)
				{
					strTitle = pFrameWnd->GetTitle();

					if (!strTitle.IsEmpty())
					{
						int pos = strText.Find(strTitle);

						if (pos != -1)
						{
							if (strText.GetLength() > strTitle.GetLength())
							{
								if (pos == 0)
								{
									bPrefix = FALSE; // avoid exception
									strTitle = strText.Left(strTitle.GetLength() + 3);
									strDocument = strText.Right(strText.GetLength() - strTitle.GetLength());
								}
								else
								{
									strTitle = strText.Right(strTitle.GetLength() + 3);
									strDocument = strText.Left(strText.GetLength() - strTitle.GetLength());
								}
							}
						}
					}
					else
					{
						strDocument = strText;
					}
				}
			}

			if (bMaximized)
			{
				rectCaption.InflateRect(szSysBorder.cx, szSysBorder.cy, szSysBorder.cx, 0);
			}

			DrawNcCaption(&dc, rectCaption, dwStyle, dwStyleEx, strTitle, strDocument, hIcon, bPrefix, bActive, m_bNcTextCenter, lstSysButtons);

			if (bMaximized)
			{
				return TRUE;
			}
		}

		else
		{
			if (bMaximized)
			{
				return TRUE;
			}

			rectCaption.bottom += pBar->GetCaptionHeight();

			CRect rectBorder(m_ctrlMainBorderCaption.GetParams().m_rectSides);

			if (IsBeta())
			{
				COLORREF clr1  = bActive ? m_clrAppCaptionActiveStart : m_clrAppCaptionInactiveStart;
				COLORREF clr2  = bActive ? m_clrAppCaptionActiveFinish : m_clrAppCaptionInactiveFinish;

				CRect rectCaption2(rectCaption);
				rectCaption2.DeflateRect(rectBorder.left, rectBorder.top, rectBorder.right, rectBorder.bottom);

				{
					CDrawingManager dm(dc);
					dm.Fill4ColorsGradient(rectCaption2, clr1, clr2, clr2, clr1, FALSE);
				}

				m_ctrlMainBorderCaption.DrawFrame(&dc, rectCaption, bActive ? 0 : 1);
			}
			else
			{
				m_ctrlMainBorderCaption.Draw(&dc, rectCaption, bActive ? 0 : 1);
			}
		}

		rtWindow.top = rectCaption.bottom;
		dc.ExcludeClipRect(rectCaption);

		if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)))
		{
			m_ctrlMDIChildBorder.DrawFrame(&dc, rtWindow, bActive ? 0 : 1);
		}
		else
		{
			m_ctrlMainBorder.DrawFrame(&dc, rtWindow, bActive ? 0 : 1);
		}

		//-------------------------------
		// Find status bar extended area:
		//-------------------------------
		CRect rectExt(0, 0, 0, 0);
		BOOL bExtended    = FALSE;
		BOOL bBottomFrame = FALSE;
		BOOL bIsStatusBar = FALSE;

		CWnd* pStatusBar = pWnd->GetDescendantWindow(AFX_IDW_STATUS_BAR, TRUE);

		if (pStatusBar->GetSafeHwnd() != NULL && pStatusBar->IsWindowVisible())
		{
			CMFCStatusBar* pClassicStatusBar = DYNAMIC_DOWNCAST(CMFCStatusBar, pStatusBar);
			if (pClassicStatusBar != NULL)
			{
				bExtended = pClassicStatusBar->GetExtendedArea(rectExt);
				bIsStatusBar = TRUE;
			}

			else
			{
				CMFCRibbonStatusBar* pRibbonStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pStatusBar);
				if (pRibbonStatusBar != NULL)
				{
					bExtended    = pRibbonStatusBar->GetExtendedArea(rectExt);
					bBottomFrame = pRibbonStatusBar->IsBottomFrame();
					bIsStatusBar = TRUE;
				}
			}

		}

		if (bIsStatusBar)
		{
			CRect rectStatus;
			pStatusBar->GetClientRect(rectStatus);

			int nHeight = rectStatus.Height();
			rectStatus.bottom = rtWindow.bottom;
			rectStatus.top    = rectStatus.bottom - nHeight -(bBottomFrame ? -1 : szSysBorder.cy);
			rectStatus.left   = rtWindow.left;
			rectStatus.right  = rtWindow.right;

			if (bExtended)
			{
				rectExt.left   = rectStatus.right - rectExt.Width() - szSysBorder.cx;
				rectExt.top    = rectStatus.top;
				rectExt.bottom = rectStatus.bottom;
				rectExt.right  = rtWindow.right;
			}

			m_ctrlStatusBarBack.Draw(&dc, rectStatus, bActive ? 0 : 1);

			if (bExtended)
			{
				rectExt.left -= m_ctrlStatusBarBack_Ext.GetParams().m_rectCorners.left;
				m_ctrlStatusBarBack_Ext.Draw(&dc, rectExt, bActive ? 0 : 1);
			}
		}

		dc.SelectClipRgn(NULL);

		return TRUE;
	}

	return CMFCVisualManagerOffice2003::OnNcPaint(pWnd, lstSysButtons, rectRedraw);
}

BOOL CMFCVisualManagerOffice2007::OnSetWindowRegion(CWnd* pWnd, CSize sizeWindow)
{
	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (!CanDrawImage())
	{
		return FALSE;
	}

	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		return FALSE;
	}

	CSize sz(0, 0);

	BOOL bMainWnd = FALSE;

	if (DYNAMIC_DOWNCAST(CMFCPopupMenu, pWnd) != NULL)
	{
		sz  = CSize(3, 3);
	}
	else if (DYNAMIC_DOWNCAST(CMFCRibbonBar, pWnd) != NULL)
	{
		return FALSE;
	}
	else
	{
		if ((pWnd->GetStyle() & WS_MAXIMIZE) == WS_MAXIMIZE)
		{
			pWnd->SetWindowRgn(NULL, TRUE);
			return TRUE;
		}

		sz  = CSize(9, 9);
		bMainWnd = TRUE;
	}

	if (sz != CSize(0, 0))
	{
		CRgn rgn;
		BOOL bCreated = FALSE;

		bCreated = rgn.CreateRoundRectRgn(0, 0, sizeWindow.cx + 1, sizeWindow.cy + 1, sz.cx, sz.cy);

		if (bCreated)
		{
			if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)))
			{
				CRgn rgnWinodw;
				rgnWinodw.CreateRectRgn(0, sz.cy, sizeWindow.cx, sizeWindow.cy);

				rgn.CombineRgn(&rgn, &rgnWinodw, RGN_OR);
			}

			pWnd->SetWindowRgn((HRGN)rgn.Detach(), TRUE);
			return TRUE;
		}
	}

	return FALSE;
}

CSize CMFCVisualManagerOffice2007::GetNcBtnSize(BOOL bSmall) const
{
	return m_szNcBtnSize[bSmall ? 1 : 0];
}

void CMFCVisualManagerOffice2007::DrawSeparator(CDC* pDC, const CRect& rect, BOOL bHorz)
{
	DrawSeparator(pDC, rect, m_penSeparator, m_penSeparator2, bHorz);
}

void CMFCVisualManagerOffice2007::DrawSeparator(CDC* pDC, const CRect& rect, CPen& pen1, CPen& pen2, BOOL bHorz)
{
	CRect rect1(rect);
	CRect rect2;

	if (bHorz)
	{
		rect1.top += rect.Height() / 2 - 1;
		rect1.bottom = rect1.top;
		rect2 = rect1;
		rect2.OffsetRect(0, 1);
	}
	else
	{
		rect1.left += rect.Width() / 2 - 1;
		rect1.right = rect1.left;
		rect2 = rect1;
		rect2.OffsetRect(1, 0);
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);

		LOGPEN logpen;

		pen1.GetLogPen(&logpen);
		dm.DrawLine(rect1.left, rect1.top, rect1.right, rect1.bottom, logpen.lopnColor);

		pen2.GetLogPen(&logpen);
		dm.DrawLine(rect2.left, rect2.top, rect2.right, rect2.bottom, logpen.lopnColor);
	}
	else
	{
		CPen* pOldPen = pDC->SelectObject(&pen1);
		pDC->MoveTo(rect1.TopLeft());
		pDC->LineTo(rect1.BottomRight());

		pDC->SelectObject(&pen2);
		pDC->MoveTo(rect2.TopLeft());
		pDC->LineTo(rect2.BottomRight());

		pDC->SelectObject(pOldPen);
	}
}

COLORREF CMFCVisualManagerOffice2007::GetCaptionBarTextColor(CMFCCaptionBar* pBar)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetCaptionBarTextColor(pBar);
	}

	return m_clrCaptionBarText;
}

void CMFCVisualManagerOffice2007::OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* pBar, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawCaptionBarInfoArea(pDC, pBar, rect);
		return;
	}

	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, afxGlobalData.clrBarFace, RGB(255, 255, 255));

	pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
}

void CMFCVisualManagerOffice2007::OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillOutlookPageButton(pDC, rect, bIsHighlighted, bIsPressed, clrText);
		return;
	}

	ASSERT_VALID(pDC);

	CRect rt(rect);

	if (m_ctrlOutlookWndPageBtn.IsValid())
	{
		int index = 0;

		if (bIsPressed)
		{
			index = 2;

			if (bIsHighlighted)
			{
				index = 3;
			}

			clrText = m_clrOutlookPageTextPressed;
		}
		else if (bIsHighlighted)
		{
			index = 1;

			clrText = m_clrOutlookPageTextHighlighted;
		}

		m_ctrlOutlookWndPageBtn.Draw(pDC, rt, index);
	}
	else
	{
		COLORREF clr1 = m_clrBarGradientDark;
		COLORREF clr2 = m_clrBarGradientLight;

		if (bIsPressed)
		{
			if (bIsHighlighted)
			{
				clr1 = m_clrHighlightDnGradientDark;
				clr2 = m_clrHighlightDnGradientLight;
			}
			else
			{
				clr1 = m_clrHighlightDnGradientLight;
				clr2 = m_clrHighlightDnGradientDark;
			}
		}
		else if (bIsHighlighted)
		{
			clr1 = m_clrHighlightGradientDark;
			clr2 = m_clrHighlightGradientLight;
		}

		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, clr1, clr2, TRUE);
	}

	clrText = m_clrOutlookPageTextNormal;

	if (bIsPressed)
	{
		clrText = m_clrOutlookPageTextPressed;
	}
	else if (bIsHighlighted)
	{
		clrText = m_clrOutlookPageTextHighlighted;
	}
}

void CMFCVisualManagerOffice2007::OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawOutlookPageButtonBorder(pDC, rectBtn, bIsHighlighted, bIsPressed);
		return;
	}

	pDC->Draw3dRect(rectBtn, afxGlobalData.clrBtnHilite, m_clrToolBarBottomLine);
}

void CMFCVisualManagerOffice2007::OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter)
{
	ASSERT_VALID(pDC);

	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawOutlookBarSplitter(pDC, rectSplitter);
		return;
	}

	CDrawingManager dm(*pDC);

	dm.FillGradient(rectSplitter, m_clrCaptionBarGradientDark, m_clrCaptionBarGradientLight, TRUE);

	rectSplitter.OffsetRect(0, 1);
	m_ToolBarTear.DrawEx(pDC, rectSplitter, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
	rectSplitter.OffsetRect(0, -1);

	CPen* pOldPen = pDC->SelectObject(&m_penBottomLine);

	pDC->MoveTo(rectSplitter.left, rectSplitter.top);
	pDC->LineTo(rectSplitter.right, rectSplitter.top);

	pDC->MoveTo(rectSplitter.left, rectSplitter.bottom - 1);
	pDC->LineTo(rectSplitter.right, rectSplitter.bottom - 1);

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOffice2007::OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText)
{
	CMFCVisualManagerOffice2003::OnFillOutlookBarCaption(pDC, rectCaption, clrText);

	if (CanDrawImage())
	{
		clrText = m_clrOutlookCaptionTextNormal;
	}
}

void CMFCVisualManagerOffice2007::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea/* = FALSE*/)
{
	CRuntimeClass* pBarClass = pBar->GetRuntimeClass();

	if (!CanDrawImage() || pBar->IsDialogControl() || pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCColorBar)))
	{
		CMFCVisualManagerOffice2003::OnFillBarBackground(pDC, pBar, rectClient, rectClip, bNCArea);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
	{
		BOOL bIsHorz = (pBar->GetPaneStyle() & CBRS_ORIENT_HORZ);
		COLORREF clr1 = bIsHorz ? m_clrMenuBarGradientDark : m_clrMenuBarGradientVertLight;
		COLORREF clr2 = bIsHorz ? m_clrMenuBarGradientLight : m_clrMenuBarGradientVertDark;

		CDrawingManager dm(*pDC);
		dm.Fill4ColorsGradient(rectClient, clr1, clr2, clr2, clr1, !bIsHorz);
		return;
	}
	else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		pDC->FillRect(rectClip, &m_brMenuLight);

		CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
		if (!pMenuBar->m_bDisableSideBarInXPMode)
		{
			CRect rectImages = rectClient;
			rectImages.right = rectImages.left + pMenuBar->GetGutterWidth();
			rectImages.DeflateRect (0, 1);

			pDC->FillRect(rectImages, &m_brBarBkgnd);

			rectImages.left = rectImages.right;
			rectImages.right += 2;
			DrawSeparator(pDC, rectImages, FALSE);
		}

		return;
	}
	else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCStatusBar)))
	{
		CSize szSysBorder(GetSystemBorders(TRUE));

		CRect rect(rectClient);
		CRect rectExt(0, 0, 0, 0);
		BOOL bExtended = ((CMFCStatusBar*)pBar)->GetExtendedArea(rectExt);

		if (bExtended)
		{
			rect.right = rectExt.left;
		}

		CWnd* pWnd = ((CMFCStatusBar*)pBar)->GetParent();
		ASSERT_VALID(pWnd);

		BOOL bActive = IsWindowActive(pWnd);

		rect.InflateRect(szSysBorder.cx, 0, szSysBorder.cx, szSysBorder.cy);
		m_ctrlStatusBarBack.Draw(pDC, rect, bActive ? 0 : 1);

		if (bExtended)
		{
			rectExt.InflateRect(0, 0, szSysBorder.cx, szSysBorder.cy);
			rectExt.left -= m_ctrlStatusBarBack_Ext.GetParams().m_rectCorners.left;
			m_ctrlStatusBarBack_Ext.Draw(pDC, rectExt, bActive ? 0 : 1);
		}

		return;
	}
	else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		CMFCRibbonStatusBar* pRibbonStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pBar);

		CSize szSysBorder(GetSystemBorders(TRUE));

		CRect rect(rectClient);
		CRect rectExt(0, 0, 0, 0);

		BOOL bExtended    = pRibbonStatusBar->GetExtendedArea(rectExt);
		BOOL bBottomFrame = pRibbonStatusBar->IsBottomFrame();

		if (bExtended)
		{
			rect.right = rectExt.left;
		}

		CWnd* pWnd = pBar->GetParent();
		ASSERT_VALID(pWnd);

		BOOL bActive = IsWindowActive(pWnd);

		rect.InflateRect(szSysBorder.cx, 0, szSysBorder.cx, bBottomFrame ? -1 : szSysBorder.cy);
		m_ctrlStatusBarBack.Draw(pDC, rect, bActive ? 0 : 1);

		if (bExtended)
		{
			rectExt.InflateRect(0, 0, szSysBorder.cx, bBottomFrame ? -1 : szSysBorder.cy);
			rectExt.left -= m_ctrlStatusBarBack_Ext.GetParams().m_rectCorners.left;
			m_ctrlStatusBarBack_Ext.Draw(pDC, rectExt, bActive ? 0 : 1);
		}

		return;
	}
	else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarToolBar)))
	{
		if (m_ctrlOutlookWndBar.IsValid())
		{
			m_ctrlOutlookWndBar.Draw(pDC, rectClient);
		}
		else
		{
			CDrawingManager dm(*pDC);
			dm.FillGradient(rectClient, m_clrToolBarGradientDark, m_clrToolBarGradientLight, TRUE);
		}

		return;
	}

	CMFCVisualManagerOffice2003::OnFillBarBackground(pDC, pBar, rectClient, rectClip, bNCArea);
}

void CMFCVisualManagerOffice2007::OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillHighlightedArea(pDC, rect, pBrush, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pBrush);

	BOOL bIsHorz = TRUE;

	COLORREF clr1 = (COLORREF)-1;
	COLORREF clr2 = (COLORREF)-1;

	if (pButton != NULL)
	{
		ASSERT_VALID(pButton);

		bIsHorz = pButton->IsHorizontal();

		CMFCToolBarMenuButton* pCustButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);

		if (pCustButton != NULL)
		{
			if (pButton->IsDroppedDown())
			{
				clr1 = m_clrHighlightDnGradientDark;
				clr2 = m_clrHighlightDnGradientLight;
			}
		}
	}

	if (pBrush == &m_brHighlight)
	{
		clr1 = m_clrHighlightGradientDark;
		clr2 = m_clrHighlightGradientLight;//bIsPopupMenu ? clr1 : m_clrHighlightGradientLight;
	}
	else if (pBrush == &m_brHighlightDn)
	{
		clr1 = m_clrHighlightDnGradientDark;//bIsPopupMenu ? m_clrHighlightDnGradientLight : m_clrHighlightDnGradientDark;
		clr2 = m_clrHighlightDnGradientLight;
	}
	else if (pBrush == &m_brHighlightChecked)
	{
		clr1 = m_clrHighlightCheckedGradientDark;//bIsPopupMenu ? m_clrHighlightCheckedGradientLight : m_clrHighlightCheckedGradientDark;
		clr2 = m_clrHighlightCheckedGradientLight;
	}

	if (clr1 == (COLORREF)-1 || clr2 == (COLORREF)-1)
	{
		CMFCVisualManagerOffice2003::OnFillHighlightedArea(pDC, rect, pBrush, pButton);
		return;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clr1, clr2, bIsHorz);
}

void CMFCVisualManagerOffice2007::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawMenuBorder(pDC, pMenu, rect);
		return;
	}

	if (pMenu != NULL)
	{
		CMFCRibbonPanelMenuBar* pRibbonMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, pMenu->GetMenuBar());

		if (pRibbonMenuBar != NULL)
		{
			ASSERT_VALID(pRibbonMenuBar);

			if (pRibbonMenuBar->IsMainPanel())
			{
				if (m_ctrlRibbonMainPanel.IsValid())
				{
					m_ctrlRibbonMainPanel.DrawFrame(pDC, rect);
				}
				else
				{
					m_ctrlPopupBorder.DrawFrame(pDC, rect);
				}

				return;
			}

			if (!pRibbonMenuBar->IsMenuMode())
			{
				if (pRibbonMenuBar->IsQATPopup() && m_ctrlRibbonBorder_QAT.IsValid())
				{
					m_ctrlRibbonBorder_QAT.DrawFrame(pDC, rect);
					return;
				}
				else if (pRibbonMenuBar->IsCategoryPopup())
				{
					if (IsBeta1())
					{
						m_ctrlRibbonCategoryBack.DrawFrame(pDC, rect);
					}

					return;
				}
				else if (pRibbonMenuBar->IsRibbonMiniToolBar() && m_ctrlRibbonBorder_Floaty.IsValid())
				{
					m_ctrlRibbonBorder_Floaty.DrawFrame(pDC, rect);
					return;
				}
				else
				{
					if (pRibbonMenuBar->GetPanel() != NULL)
					{
						if (IsBeta1())
						{
							m_ctrlRibbonCategoryBack.DrawFrame(pDC, rect);
						}

						return;
					}

					// draw standard
				}
			}
		}
	}

	CBasePane* pTopLevelBar = NULL;

	for (CMFCPopupMenu* pParentMenu = pMenu; pParentMenu != NULL; pParentMenu = pParentMenu->GetParentPopupMenu())
	{
		CMFCToolBarMenuButton* pParentButton = pParentMenu->GetParentButton();
		if (pParentButton == NULL)
		{
			break;
		}

		pTopLevelBar = DYNAMIC_DOWNCAST(CBasePane, pParentButton->GetParentWnd());
	}

	if (pTopLevelBar == NULL || pTopLevelBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		m_ctrlPopupBorder.DrawFrame(pDC, rect);
	}
	else
	{
		CMFCVisualManagerOffice2003::OnDrawMenuBorder(pDC, pMenu, rect);
	}
}

void CMFCVisualManagerOffice2007::OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar)
{
	if (!CanDrawImage() || (pBar != NULL && pBar->IsDialogControl()) || m_ToolBarGripper.GetCount() == 0)
	{
		CMFCVisualManagerOffice2003::OnDrawBarGripper(pDC, rectGripper, bHorz, pBar);
		return;
	}

	CSize szBox(m_ToolBarGripper.GetImageSize());

	if (szBox != CSize(0, 0))
	{
		if (bHorz)
		{
			rectGripper.left = rectGripper.right - szBox.cx;
		}
		else
		{
			rectGripper.top = rectGripper.bottom - szBox.cy;
		}

		CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pBar);
		if (pToolBar != NULL)
		{
			if (bHorz)
			{
				const int nHeight = CMFCToolBar::IsLargeIcons() ? pToolBar->GetRowHeight() : pToolBar->GetButtonSize().cy;
				const int nDelta = max(0, (nHeight - pToolBar->GetImageSize().cy) / 2);
				rectGripper.DeflateRect(0, nDelta);
			}
			else
			{
				const int nWidth = CMFCToolBar::IsLargeIcons() ? pToolBar->GetColumnWidth() : pToolBar->GetButtonSize().cx;
				const int nDelta = max(0, (nWidth - pToolBar->GetImageSize().cx) / 2);
				rectGripper.DeflateRect(nDelta, 0);
			}
		}

		const int nBoxesNumber = bHorz ? (rectGripper.Height() - szBox.cy) / szBox.cy : (rectGripper.Width() - szBox.cx) / szBox.cx;
		int nOffset = bHorz ? (rectGripper.Height() - nBoxesNumber * szBox.cy) / 2 : (rectGripper.Width() - nBoxesNumber * szBox.cx) / 2;

		for (int nBox = 0; nBox < nBoxesNumber; nBox++)
		{
			int x = bHorz ? rectGripper.left :
			rectGripper.left + nOffset;

			int y = bHorz ? rectGripper.top + nOffset :
			rectGripper.top;

			m_ToolBarGripper.DrawEx(pDC, CRect(CPoint(x, y), szBox), 0);
			nOffset += bHorz ? szBox.cy : szBox.cx;
		}
	}
}

void CMFCVisualManagerOffice2007::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	ASSERT_VALID(pDC);

	if (!CanDrawImage() || pBar == NULL || pBar->IsDialogControl())
	{
		CMFCVisualManagerOffice2003::OnDrawSeparator(pDC, pBar, rect, bHorz);
		return;
	}

	ASSERT_VALID(pBar);

	CRect rectSeparator(rect);


	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		CMFCRibbonStatusBar* pRibbonStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pBar);

		rect.InflateRect(1, 5, 1, pRibbonStatusBar->IsBottomFrame() ? 2 : 5);

		m_StatusBarPaneBorder.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertStretch);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonBar)) || (bHorz && pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonPanelMenuBar))))
	{
		if (rect.Width() < m_RibbonPanelSeparator.GetImageSize().cx)
		{
			rect.left = rect.right - m_RibbonPanelSeparator.GetImageSize().cx;
		}

		m_RibbonPanelSeparator.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
		return;
	}

	BOOL bPopupMenu = FALSE;

	if (!bHorz)
	{
		BOOL bIsRibbon = FALSE;
		bIsRibbon = pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonPanelMenuBar));

		if (bIsRibbon &&((CMFCRibbonPanelMenuBar*) pBar)->IsDefaultMenuLook())
		{
			bIsRibbon = FALSE;
		}

		bPopupMenu = pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

		if (bPopupMenu && !bIsRibbon && !pBar->IsKindOf(RUNTIME_CLASS(CMFCColorBar)))
		{
			rectSeparator.left = rect.left + CMFCToolBar::GetMenuImageSize().cx + GetMenuImageMargin() + 1;

			CRect rectBar;
			pBar->GetClientRect(rectBar);

			if (rectBar.right - rectSeparator.right < 50) // Last item in row
			{
				rectSeparator.right = rectBar.right;
			}

			if (((CMFCPopupMenuBar*) pBar)->m_bDisableSideBarInXPMode)
			{
				rectSeparator.left = 0;
			}

			//---------------------------------
			// Maybe Quick Customize separator
			//---------------------------------
			if (bPopupMenu)
			{
				CWnd* pWnd = pBar->GetParent();
				if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CMFCPopupMenu)))
				{
					CMFCPopupMenu* pMenu = (CMFCPopupMenu*)pWnd;
					if (pMenu->IsCustomizePane())
					{
						rectSeparator.left = rect.left + 2 * CMFCToolBar::GetMenuImageSize().cx + 3 * GetMenuImageMargin() + 2;
					}
				}
			}
		}
	}

	if (bPopupMenu)
	{
		DrawSeparator(pDC, rectSeparator, !bHorz);
	}
	else
	{
		if (bHorz)
		{
			int nHeight = rectSeparator.Height() / 5;
			rectSeparator.top    += nHeight;
			rectSeparator.bottom -= nHeight;
		}
		else
		{
			int nWidth = rectSeparator.Width() / 5;
			rectSeparator.left  += nWidth;
			rectSeparator.right -= nWidth;
		}

		DrawSeparator(pDC, rectSeparator, m_penSeparatorDark, m_penSeparatorLight, !bHorz);
	}
}

COLORREF CMFCVisualManagerOffice2007::OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons)
{
	if (!CanDrawImage() || pBar == NULL || pBar->IsDialogControl())
	{
		return CMFCVisualManagerOffice2003::OnDrawPaneCaption(pDC, pBar, bActive, rectCaption, rectButtons);
	}

	ASSERT_VALID(pDC);

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarFace);
	CPen* pOldPen = pDC->SelectObject(&pen);

	rectCaption.bottom += 2;

	pDC->MoveTo(rectCaption.left, rectCaption.bottom);
	pDC->LineTo(rectCaption.left, rectCaption.top);

	pDC->MoveTo(rectCaption.left  + 1, rectCaption.top);
	pDC->LineTo(rectCaption.right - 1, rectCaption.top);

	pDC->MoveTo(rectCaption.right - 1, rectCaption.top + 1);
	pDC->LineTo(rectCaption.right - 1, rectCaption.bottom);

	pDC->SelectObject(pOldPen);

	rectCaption.DeflateRect(1, 1, 1, 0);
	pDC->FillRect(rectCaption, bActive ? &afxGlobalData.brActiveCaption : &afxGlobalData.brInactiveCaption);

	return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
}

void CMFCVisualManagerOffice2007::OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawStatusBarPaneBorder(pDC, pBar, rectPane, uiID, nStyle);
		return;
	}

	BOOL bExtended = pBar->GetDrawExtendedArea();
	if (!bExtended ||((nStyle & SBPS_STRETCH) == 0 && bExtended))
	{
		rectPane.OffsetRect(1, 0);
		m_StatusBarPaneBorder.DrawEx(pDC, rectPane, 0, CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertStretch);
	}
}

void CMFCVisualManagerOffice2007::OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox)
{
	if (!CanDrawImage() ||
		m_StatusBarSizeBox.GetCount() == 0)
	{
		CMFCVisualManagerOffice2003::OnDrawStatusBarSizeBox(pDC, pStatBar, rectSizeBox);
		return;
	}

	m_StatusBarSizeBox.DrawEx(pDC, rectSizeBox, 0, CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertBottom);
}

void CMFCVisualManagerOffice2007::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	BOOL bRibbon = pButton != NULL && pButton->IsRibbonButton();

	BOOL bActive = bIsHighlighted || bIsDropped;

	CMFCControlRenderer* pRenderer = bRibbon ? &m_ctrlRibbonComboBoxBtn : &m_ctrlComboBoxBtn;

	if (!pRenderer->IsValid())
	{
		COLORREF color1 = bRibbon ? m_clrRibbonComboBtnStart : m_clrComboBtnStart;
		COLORREF color2 = bRibbon ? m_clrRibbonComboBtnFinish : m_clrComboBtnFinish;
		COLORREF colorBorder = bRibbon ? m_clrRibbonComboBtnBorder : m_clrComboBtnBorder;
		if (bDisabled)
		{
			color1 = bRibbon ? m_clrRibbonComboBtnDisabledStart : m_clrComboBtnDisabledStart;
			color2 = bRibbon ? m_clrRibbonComboBtnDisabledFinish : m_clrComboBtnDisabledFinish;
			colorBorder = bRibbon ? m_clrRibbonComboBtnBorderDisabled : m_clrComboBtnBorderDisabled;
		}
		else if (bActive)
		{
			if (bIsDropped)
			{
				color1 = bRibbon ? m_clrRibbonComboBtnPressedStart : m_clrComboBtnPressedStart;
				color2 = bRibbon ? m_clrRibbonComboBtnPressedFinish : m_clrComboBtnPressedFinish;
				colorBorder = bRibbon ? m_clrRibbonComboBtnBorderPressed : m_clrComboBtnBorderPressed;
			}
			else
			{
				color1 = bRibbon ? m_clrRibbonComboBtnHighlightedStart : m_clrComboBtnHighlightedStart;
				color2 = bRibbon ? m_clrRibbonComboBtnHighlightedFinish : m_clrComboBtnHighlightedFinish;
				colorBorder = bRibbon ? m_clrRibbonComboBtnBorderHighlighted : m_clrComboBtnBorderHighlighted;
			}
		}

		if (bRibbon || !bDisabled || (bDisabled && colorBorder != (COLORREF)(-1)))
		{
			if (!bDisabled)
			{
				rect.InflateRect(0, 1, 1, 1);
			}

			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);
				dm.DrawRect(rect, (COLORREF)-1, colorBorder);
			}
			else
			{
				pDC->Draw3dRect(rect, colorBorder, colorBorder);
			}

			if (!bDisabled)
			{
				rect.DeflateRect(0, 1, 1, 1);
			}
		}

		if (bDisabled)
		{
			rect.DeflateRect(0, 1, 1, 1);
		}
		else if (bActive)
		{
			rect.DeflateRect(1, 0, 0, 0);
		}

		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, color1, color2, TRUE);

		if (bDisabled)
		{
			rect.InflateRect(0, 1, 1, 1);
		}
		else if (bActive)
		{
			rect.InflateRect(1, 0, 0, 0);
		}
	}
	else
	{
		rect.InflateRect(0, 1, 1, 1);

		int nIndex = 0;
		if (bDisabled)
		{
			nIndex = 3;
		}
		else
		{
			if (bIsDropped)
			{
				nIndex = 2;
			}
			else if (bIsHighlighted)
			{
				nIndex = 1;
			}
		}

		pRenderer->Draw(pDC, rect, nIndex);

		rect.DeflateRect(0, 1, 1, 1);
	}

	rect.bottom -= 2;

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
}

void CMFCVisualManagerOffice2007::OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawComboBorder(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	rect.DeflateRect(1, 1);

	COLORREF colorBorder = m_clrComboBorder;

	if (bDisabled)
	{
		colorBorder = m_clrComboBorderDisabled;
	}
	else if (bIsHighlighted || bIsDropped)
	{
		colorBorder = bIsDropped ? m_clrComboBorderPressed : m_clrComboBorderHighlighted;
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, (COLORREF)-1, colorBorder);
	}
	else
	{
		pDC->Draw3dRect(&rect, colorBorder, colorBorder);
	}
}

void CMFCVisualManagerOffice2007::OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawEditBorder(pDC, rect, bDisabled, bIsHighlighted, pButton);
		return;
	}

	rect.DeflateRect(1, 1);

	COLORREF colorBorder = m_clrEditBorder;

	if (bDisabled)
	{
		colorBorder = m_clrEditBorderDisabled;
	}
	else if (bIsHighlighted)
	{
		colorBorder = m_clrEditBorderHighlighted;
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, (COLORREF)-1, colorBorder);
	}
	else
	{
		pDC->Draw3dRect(&rect, colorBorder, colorBorder);
	}
}

void CMFCVisualManagerOffice2007::OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive)
{
	if (!CanDrawImage() || m_ToolBarTear.GetCount() == 0)
	{
		CMFCVisualManagerOffice2003::OnDrawTearOffCaption(pDC, rect, bIsActive);
		return;
	}

	pDC->FillRect(rect, &m_brBarBkgnd);
	if (bIsActive)
	{
		m_ctrlMenuHighlighted[0].Draw(pDC, rect);
	}

	m_ToolBarTear.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
}

void CMFCVisualManagerOffice2007::OnDrawMenuResizeBar(CDC* pDC, CRect rect, int nResizeFlags)
{
	CMFCToolBarImages& images = (nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_BOTTOM_RIGHT) ? m_PopupResizeBar_HV :
	(nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_TOP_RIGHT) ? m_PopupResizeBar_HVT : m_PopupResizeBar_V;

	if (!CanDrawImage() || !m_ctrlPopupResizeBar.IsValid() || !images.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawMenuResizeBar(pDC, rect, nResizeFlags);
		return;
	}

	ASSERT_VALID(pDC);

	m_ctrlPopupResizeBar.Draw(pDC, rect);

	if (nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_BOTTOM_RIGHT || nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_TOP_RIGHT)
	{
		images.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzRight,
			nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_TOP_RIGHT ? CMFCToolBarImages::ImageAlignVertTop : CMFCToolBarImages::ImageAlignVertBottom);
	}
	else
	{
		images.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
	}
}

void CMFCVisualManagerOffice2007::OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL bIsPressed, BOOL bIsDisabled)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawMenuScrollButton(pDC, rect, bIsScrollDown, bIsHighlited, bIsPressed, bIsDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	CMFCControlRenderer* pRenderer = &m_ctrlMenuScrollBtn[0];

	if (bIsScrollDown && m_ctrlMenuScrollBtn[1].IsValid())
	{
		pRenderer = &m_ctrlMenuScrollBtn[1];
	}

	rect.top --;

	pRenderer->Draw(pDC, rect, bIsHighlited ? 1 : 0);

	CMenuImages::Draw(pDC, bIsScrollDown ? CMenuImages::IdArrowDown : CMenuImages::IdArrowUp, rect);
}

void CMFCVisualManagerOffice2007::OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawMenuSystemButton(pDC, rect, uiSystemCommand, nStyle, bHighlight);
		return;
	}

	ASSERT_VALID(pDC);

	CMFCToolBarImages* pImage = NULL;

	switch(uiSystemCommand)
	{
	case SC_CLOSE:
		pImage = &m_SysBtnClose[0];
		break;

	case SC_MINIMIZE:
		pImage = &m_SysBtnMinimize[0];
		break;

	case SC_RESTORE:
		pImage = &m_SysBtnRestore[0];
		break;

	default:
		return;
	}

	BOOL bDisabled = (nStyle & TBBS_DISABLED);
	BOOL bPressed = (nStyle & TBBS_PRESSED);

	CRect rtBtnImage(CPoint(0, 0), pImage->GetImageSize());

	int nImage = 0;
	if (bDisabled)
	{
		nImage = 3;
	}
	else if (bPressed || bHighlight)
	{
		int index = -1;
		if (bPressed)
		{
			if (bHighlight)
			{
				index = 1;
			}
		}
		else if (bHighlight)
		{
			index = 0;
		}

		if (index != -1)
		{
			m_ctrlRibbonBtn[0].Draw(pDC, rect, index);
		}
	}

	rtBtnImage.OffsetRect(0, pImage->GetImageSize().cy * nImage);
	pImage->DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, rtBtnImage);
}

void CMFCVisualManagerOffice2007::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	CMFCCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);

	if (pCustButton == NULL)
	{
		if (CMFCToolBar::IsCustomizeMode() && !CMFCToolBar::IsAltCustomizeMode() && !pButton->IsLocked())
		{
			return;
		}

		CMFCControlRenderer* pRenderer = NULL;
		int index = 0;

		BOOL bDisabled = (pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED;
		BOOL bPressed  = (pButton->m_nStyle & TBBS_PRESSED ) == TBBS_PRESSED;
		BOOL bChecked  = (pButton->m_nStyle & TBBS_CHECKED ) == TBBS_CHECKED;
		BOOL bHandled  = FALSE;

		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, pButton->GetParentWnd());

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
		if (pMenuButton != NULL && pBar != NULL)
		{
			if (pBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
			{
				if (state == ButtonsIsPressed || state == ButtonsIsHighlighted)
				{
					if (pMenuButton->IsDroppedDown())
					{
						ExtendMenuButton(pMenuButton, rect);
						index = 1;
					}

					pRenderer = &m_ctrlMenuBarBtn;

					bHandled = TRUE;
				}
				else
				{
					return;
				}

				bHandled = TRUE;
			}
			else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
			{
				if (bChecked)
				{
					pRenderer = &m_ctrlMenuItemBack;

					if (bDisabled)
					{
						index = 1;
					}

					rect.InflateRect(0, 0, 0, 1);
					bHandled = TRUE;
				}
				else if (state == ButtonsIsPressed || state == ButtonsIsHighlighted)
				{
					pRenderer = &m_ctrlMenuHighlighted[bDisabled ? 1 : 0];
					bHandled = TRUE;
				}
				else
				{
					return;
				}
			}
			else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
			{
				if (pMenuButton->IsDroppedDown())
				{
					ExtendMenuButton(pMenuButton, rect);
				}
			}
		}
		else if (pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CMFCColorBar)))
		{
			if (bChecked)
			{
				pRenderer = &m_ctrlMenuItemBack;

				if (bDisabled)
				{
					index = 1;
				}
			}


			if (!bDisabled)
			{
				if (state == ButtonsIsHighlighted)
				{
					pRenderer = &m_ctrlMenuHighlighted[0];
					index = 0;
				}
			}

			bHandled = TRUE;
		}
		else if (pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarToolBar)))
		{
			bHandled = TRUE;
		}

		if (!bHandled)
		{
			index = -1;

			if (bChecked)
			{
				if (bDisabled)
				{
					index = 0;
				}
				else if (state == ButtonsIsPressed || state == ButtonsIsHighlighted)
				{
					index = 3;
				}
			}

			if (!bDisabled)
			{
				if (bPressed)
				{
					index = 2;
				}
				else if (state == ButtonsIsHighlighted)
				{
					if (index == -1)
					{
						index = 0;
					}

					index++;
				}
			}

			if (index == -1)
			{
				return;
			}

			pRenderer = &m_ctrlToolBarBtn;
		}

		if (pRenderer != NULL)
		{
			pRenderer->Draw(pDC, rect, index);
			return;
		}
	}

	CMFCVisualManagerOffice2003::OnFillButtonInterior(pDC, pButton, rect, state);
}

void CMFCVisualManagerOffice2007::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawButtonBorder(pDC, pButton, rect, state);
		return;
	}

	//------------------------------------------------
	// Draw shadow under the dropped-down menu button:
	//------------------------------------------------
	if (state != ButtonsIsPressed && state != ButtonsIsHighlighted)
	{
		return;
	}

	if (!m_bShdowDroppedDownMenuButton || !CMFCMenuBar::IsMenuShadows() || CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	if (pMenuButton == NULL || !pMenuButton->IsDroppedDown())
	{
		return;
	}

	BOOL bIsPopupMenu = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

	if (bIsPopupMenu)
	{
		return;
	}

	CMFCPopupMenu* pPopupMenu= pMenuButton->GetPopupMenu();
	if (pPopupMenu != NULL && (pPopupMenu->IsWindowVisible() || pPopupMenu->IsShown()) && !pPopupMenu->IsRightAlign() && !(pPopupMenu->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ExtendMenuButton(pMenuButton, rect);

		CDrawingManager dm(*pDC);

		dm.DrawShadow(rect, m_nMenuShadowDepth, 100, 75, NULL, NULL, m_clrMenuShadowBase);
	}
}

void CMFCVisualManagerOffice2007::OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawButtonSeparator(pDC, pButton, rect, state, bHorz);
		return;
	}

	CPen* pPen = &m_penMenuItemBorder;

	CPen* pOldPen = pDC->SelectObject(pPen);
	ENSURE(pOldPen != NULL);

	if (bHorz)
	{
		pDC->MoveTo(rect.left, rect.top + 2);
		pDC->LineTo(rect.left, rect.bottom - 2);
	}
	else
	{
		pDC->MoveTo(rect.left  + 2, rect.top);
		pDC->LineTo(rect.right - 2, rect.top);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOffice2007::OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnHighlightMenuItem(pDC, pButton, rect, clrText);
		return;
	}

	m_ctrlMenuHighlighted[(pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED ? 1 : 0].Draw(pDC, rect);
}

void CMFCVisualManagerOffice2007::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnHighlightRarelyUsedMenuItems(pDC, rectRarelyUsed);
	}

	rectRarelyUsed.left --;
	rectRarelyUsed.right = rectRarelyUsed.left + CMFCToolBar::GetMenuImageSize().cx + 2 * GetMenuImageMargin() + 2;

	pDC->FillRect(rectRarelyUsed, &m_brMenuRarelyUsed);
}

void CMFCVisualManagerOffice2007::OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, BOOL bHighlight, BOOL bIsRadio)
{
	ASSERT_VALID(pButton);

	CMFCToolBarImages& img = bIsRadio ? m_MenuItemMarkerR : m_MenuItemMarkerC;

	if (!CanDrawImage() || img.GetCount() == 0)
	{
		CMFCVisualManagerOffice2003::OnDrawMenuCheck(pDC, pButton, rect, bHighlight, bIsRadio);
		return;
	}

	CSize size(img.GetImageSize());
	CRect rectImage(0, 0, size.cx, size.cy);

	if ((pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED)
	{
		rectImage.OffsetRect(0, size.cy);
	}

	if (afxGlobalData.m_bIsRTL)
	{
		img.Mirror();
	}

	img.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, rectImage);

	if (afxGlobalData.m_bIsRTL)
	{
		img.Mirror();
	}
}

void CMFCVisualManagerOffice2007::OnDrawMenuItemButton(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rectButton, BOOL bHighlight, BOOL bDisabled)
{
	if (!CanDrawImage() || !m_ctrlMenuButtonBorder.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawMenuItemButton(pDC, pButton, rectButton, bHighlight, bDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	CRect rect = rectButton;
	rect.right = rect.left + 1;
	rect.left--;
	rect.DeflateRect(0, 1);

	if (bHighlight)
	{
		m_ctrlMenuButtonBorder.Draw(pDC, rect);
	}
	else
	{
		CBrush br(afxGlobalData.clrBtnShadow);

		rect.DeflateRect(0, 3);
		rect.right--;
		pDC->FillRect(rect, &br);
	}
}

void CMFCVisualManagerOffice2007::OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage() || !m_ctrlMenuItemShowAll.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawShowAllMenuItems(pDC, rect, state);
		return;
	}

	m_ctrlMenuItemShowAll.FillInterior(pDC, rect, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, state == ButtonsIsHighlighted ? 1 : 0);
}

int CMFCVisualManagerOffice2007::GetShowAllMenuItemsHeight(CDC* pDC, const CSize& sizeDefault)
{
	return(CanDrawImage() && m_ctrlMenuItemShowAll.IsValid()) ?
		m_ctrlMenuItemShowAll.GetParams().m_rectImage.Size().cy + 2 * AFX_TEXT_MARGIN : CMFCVisualManagerOffice2003::GetShowAllMenuItemsHeight(pDC, sizeDefault);
}

COLORREF CMFCVisualManagerOffice2007::OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnFillMiniFrameCaption(pDC, rectCaption, pFrameWnd, bActive);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	BOOL bIsToolBar = FALSE;

	if (DYNAMIC_DOWNCAST(CMFCBaseToolBar, pFrameWnd->GetPane()) != NULL)
	{
		bActive = FALSE;
		bIsToolBar = TRUE;
	}

	pDC->FillRect(rectCaption, bActive ? &afxGlobalData.brActiveCaption : &afxGlobalData.brInactiveCaption);

	// get the text color
	return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
}

void CMFCVisualManagerOffice2007::OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawMiniFrameBorder(pDC, pFrameWnd, rectBorder, rectBorderSize);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	BOOL bIsTasksPane = pFrameWnd->IsKindOf( RUNTIME_CLASS( CMFCTasksPaneFrameWnd ) );

	if (bIsTasksPane)
	{
		CBrush* pOldBrush = pDC->SelectObject(&m_brFloatToolBarBorder);
		ENSURE(pOldBrush != NULL);

		pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorderSize.left, rectBorder.Height(), PATCOPY);
		pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorder.Width(), rectBorderSize.top, PATCOPY);
		pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top, rectBorderSize.right, rectBorder.Height(), PATCOPY);
		pDC->PatBlt(rectBorder.left, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width(), rectBorderSize.bottom, PATCOPY);

		rectBorderSize.DeflateRect(2, 2);
		rectBorder.DeflateRect(2, 2);

		pDC->SelectObject(&afxGlobalData.brBarFace);

		pDC->PatBlt(rectBorder.left, rectBorder.top + 1, rectBorderSize.left, rectBorder.Height() - 1, PATCOPY);
		pDC->PatBlt(rectBorder.left + 1, rectBorder.top, rectBorder.Width() - 2, rectBorderSize.top, PATCOPY);
		pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top + 1, rectBorderSize.right, rectBorder.Height() - 1, PATCOPY);
		pDC->PatBlt(rectBorder.left + 1, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width() - 2, rectBorderSize.bottom, PATCOPY);

		pDC->SelectObject(pOldBrush);
	}
	else
	{
		CMFCVisualManagerOffice2003::OnDrawMiniFrameBorder(pDC, pFrameWnd, rectBorder, rectBorderSize);
	}
}

void CMFCVisualManagerOffice2007::OnDrawFloatingToolbarBorder(CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawFloatingToolbarBorder(pDC, pToolBar, rectBorder, rectBorderSize);
		return;
	}

	ASSERT_VALID(pDC);

	CBrush* pOldBrush = pDC->SelectObject(&m_brFloatToolBarBorder);
	ENSURE(pOldBrush != NULL);

	pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorderSize.left, rectBorder.Height(), PATCOPY);
	pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorder.Width(), rectBorderSize.top, PATCOPY);
	pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top, rectBorderSize.right, rectBorder.Height(), PATCOPY);
	pDC->PatBlt(rectBorder.left, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width(), rectBorderSize.bottom, PATCOPY);

	rectBorderSize.DeflateRect(2, 2);
	rectBorder.DeflateRect(2, 2);

	pDC->SelectObject(&afxGlobalData.brBarFace);

	pDC->PatBlt(rectBorder.left, rectBorder.top + 1, rectBorderSize.left, rectBorder.Height() - 1, PATCOPY);
	pDC->PatBlt(rectBorder.left + 1, rectBorder.top, rectBorder.Width() - 2, rectBorderSize.top, PATCOPY);
	pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top + 1, rectBorderSize.right, rectBorder.Height() - 1, PATCOPY);
	pDC->PatBlt(rectBorder.left + 1, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width() - 2, rectBorderSize.bottom, PATCOPY);

	pDC->SelectObject(pOldBrush);
}

BOOL CMFCVisualManagerOffice2007::IsOwnerDrawMenuCheck()
{
	return CanDrawImage() ? FALSE : CMFCVisualManagerOffice2003::IsOwnerDrawMenuCheck();
}

BOOL CMFCVisualManagerOffice2007::IsHighlightWholeMenuItem()
{
	return CanDrawImage() ? TRUE : CMFCVisualManagerOffice2003::IsHighlightWholeMenuItem();
}

COLORREF CMFCVisualManagerOffice2007::GetStatusBarPaneTextColor(CMFCStatusBar* pStatusBar, CMFCStatusBarPaneInfo* pPane)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetStatusBarPaneTextColor(pStatusBar, pPane);
	}

	ENSURE(pPane != NULL);

	return(pPane->nStyle & SBPS_DISABLED) ? m_clrStatusBarTextDisabled : pPane->clrText == (COLORREF)-1 ? m_clrStatusBarText : pPane->clrText;
}

COLORREF CMFCVisualManagerOffice2007::GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetToolbarButtonTextColor(pButton, state);
	}

	ASSERT_VALID(pButton);

	BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() && !pButton->IsEditable()) || (!CMFCToolBar::IsCustomizeMode() &&(pButton->m_nStyle & TBBS_DISABLED));

	if (pButton->GetParentWnd() != NULL && pButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
	{
		if (CMFCToolBar::IsCustomizeMode())
		{
			return m_clrMenuBarBtnText;
		}

		return bDisabled ? m_clrMenuBarBtnTextDisabled :
			((state == ButtonsIsHighlighted || state == ButtonsIsPressed || pButton->IsDroppedDown()) ? m_clrMenuBarBtnTextHighlighted : m_clrMenuBarBtnText);
	}

	return bDisabled ? m_clrToolBarBtnTextDisabled :
		((state == ButtonsIsHighlighted || state == ButtonsIsPressed) ? m_clrToolBarBtnTextHighlighted : m_clrToolBarBtnText);
}

COLORREF CMFCVisualManagerOffice2007::GetMenuItemTextColor(CMFCToolBarMenuButton* pButton, BOOL bHighlighted, BOOL bDisabled)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetMenuItemTextColor(pButton, bHighlighted, bDisabled);
	}

	return bDisabled ? m_clrMenuTextDisabled : m_clrMenuText;
}

COLORREF CMFCVisualManagerOffice2007::GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetHighlightedMenuItemTextColor(pButton);
	}

	return m_clrMenuTextHighlighted;
}

void CMFCVisualManagerOffice2007::GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
	COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::GetTabFrameColors(pTabWnd, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);
		return;
	}

	ASSERT_VALID(pTabWnd);

	CMFCVisualManagerOffice2003::GetTabFrameColors(pTabWnd, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);

	if (pTabWnd->IsFlatTab() && !pTabWnd->IsDialogControl())
	{
		if (m_clrTabFlatBlack != CLR_DEFAULT)
		{
			clrBlack = m_clrTabFlatBlack;
		}

		if (m_clrTabFlatHighlight != CLR_DEFAULT)
		{
			clrHighlight = m_clrTabFlatHighlight;
		}
	}
}

void CMFCVisualManagerOffice2007::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (!CanDrawImage() || pTabWnd->IsDialogControl())
	{
		CMFCVisualManagerOffice2003::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManagerOffice2003::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	const BOOL bBottom = pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM;

	if (pTabWnd->IsFlatTab())
	{
		m_ctrlTabFlat[bBottom ? 1 : 0].Draw(pDC, rect);
	}
	else
	{
		CDrawingManager dm(*pDC);

		COLORREF clr1 = m_clrBarGradientDark;
		COLORREF clr2 = m_clrBarGradientLight;

		if (bBottom)
		{
			dm.FillGradient(rect, clr1, clr2, TRUE);
		}
		else
		{
			dm.FillGradient(rect, clr2, clr1, TRUE);
		}
	}
}

void CMFCVisualManagerOffice2007::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManagerOffice2003::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	const BOOL bBottom = pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM;
	const BOOL bIsHighlight = iTab == pTabWnd->GetHighlightedTab();

	COLORREF clrText = pTabWnd->GetTabTextColor(iTab);

	if (pTabWnd->IsFlatTab())
	{
		int nImage = (bIsActive || bIsHighlight) ? 2 : 1;

		CRgn rgn;

		POINT pts[4];

		if (bBottom)
		{
			rectTab.bottom++;

			pts[0].x = rectTab.left;
			pts[0].y = rectTab.bottom + 1;
			pts[1].x = rectTab.left;
			pts[1].y = rectTab.top;
			pts[2].x = rectTab.right + 1;
			pts[2].y = rectTab.top;
			pts[3].x = rectTab.right - rectTab.Height() + 1;
			pts[3].y = rectTab.bottom + 1;

			rectTab.top++;
		}
		else
		{
			pts[0].x = rectTab.left;
			pts[0].y = rectTab.bottom + 1;
			pts[1].x = rectTab.left;
			pts[1].y = rectTab.top;
			pts[2].x = rectTab.right - rectTab.Height() + 1;
			pts[2].y = rectTab.top;
			pts[3].x = rectTab.right + 1;
			pts[3].y = rectTab.bottom + 1;
		}

		rgn.CreatePolygonRgn(pts, 4, WINDING);

		int isave = pDC->SaveDC();

		pDC->SelectClipRgn(&rgn, RGN_AND);

		m_ctrlTabFlat[bBottom ? 1 : 0].Draw(pDC, rectTab, nImage);

		CPen* pOldPen = pDC->SelectObject(&m_penTabFlatOuter[bIsActive ? 1 : 0]);

		if (bBottom)
		{
			pDC->MoveTo(pts[2].x, pts[2].y);
			pDC->LineTo(pts[3].x, pts[3].y - 1);
		}
		else
		{
			pDC->MoveTo(pts[2].x - 1, pts[2].y);
			pDC->LineTo(pts[3].x - 1, pts[3].y - 1);
		}

		pDC->SelectObject(&m_penTabFlatInner[bIsActive ? 1 : 0]);

		if (bBottom)
		{
			pDC->MoveTo(pts[2].x - 2, pts[2].y + 1);
			pDC->LineTo(pts[3].x, pts[3].y - 2);
		}
		else
		{
			pDC->MoveTo(pts[2].x - 1, pts[2].y + 1);
			pDC->LineTo(pts[3].x - 2, pts[3].y - 1);
		}

		pDC->SelectObject(pOldPen);

		pDC->SelectClipRgn(NULL);

		clrText = afxGlobalData.clrBarText;
		pDC->RestoreDC(isave);
	}
	else
	{
		if (clrText == (COLORREF)-1)
		{
			clrText = bIsActive ? m_clrMenuBarBtnTextHighlighted : m_clrMenuBarBtnText;
		}

		int nImage = bIsActive ? 3 : 0;
		if (bIsHighlight)
		{
			nImage += 1;
		}

		m_ctrlTab3D[bBottom ? 1 : 0].Draw(pDC, rectTab, nImage);

		if (pTabWnd->IsDialogControl())
		{
			clrText = afxGlobalData.clrBtnText;
		}
	}

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd, clrText);
}

void CMFCVisualManagerOffice2007::OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);

	if (!CanDrawImage() || pTabWnd->IsDialogControl())
	{
		CMFCVisualManagerOffice2003::OnFillTab(pDC, rectFill, pbrFill, iTab, bIsActive, pTabWnd);
		return;
	}

	if (pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManagerOffice2003::OnFillTab(pDC, rectFill, pbrFill, iTab, bIsActive, pTabWnd);
		return;
	}

	ASSERT_VALID(pDC);

	const BOOL bBottom = pTabWnd->GetLocation() == CMFCTabCtrl::LOCATION_BOTTOM;
	const BOOL bIsHighlight = iTab == pTabWnd->GetHighlightedTab();

	BOOL bIsBeta = IsBeta();
	if (!bIsBeta ||(bIsActive || bIsHighlight))
	{
		int nImage = bIsActive ?(bIsBeta ? 2 : 3) :(bIsBeta ? -1 : 0);
		if (bIsHighlight)
		{
			nImage += 1;
		}

		m_ctrlTab3D[bBottom ? 1 : 0].Draw(pDC, rectFill, nImage);
	}
}

COLORREF CMFCVisualManagerOffice2007::GetTabTextColor(const CMFCBaseTabCtrl* pTabWnd, int iTab, BOOL bIsActive)
{
	if (!CanDrawImage() || pTabWnd->IsDialogControl())
	{
		return CMFCVisualManagerOffice2003::GetTabTextColor(pTabWnd, iTab, bIsActive);
	}

	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->GetTabBkColor(iTab) != (COLORREF)-1)
	{
		return CMFCVisualManagerOffice2003::GetTabTextColor(pTabWnd, iTab, bIsActive);
	}

	return bIsActive ? m_clrTabTextActive : m_clrTabTextInactive;
}

int CMFCVisualManagerOffice2007::GetTabHorzMargin(const CMFCBaseTabCtrl* pTabWnd)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetTabHorzMargin(pTabWnd);
	}

	CMFCControlRenderer* pRenderer = pTabWnd->IsFlatTab() ? &m_ctrlTabFlat[0] : &m_ctrlTab3D[0];

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded() || !pRenderer->IsValid())
	{
		return CMFCVisualManagerOffice2003::GetTabHorzMargin(pTabWnd);
	}

	return pRenderer->GetParams().m_rectSides.right / 2;
}

BOOL CMFCVisualManagerOffice2007::OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (!CanDrawImage() || pTabWnd->IsDialogControl())
	{
		return CMFCVisualManagerOffice2003::OnEraseTabsFrame(pDC, rect, pTabWnd);
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		return CMFCVisualManagerOffice2003::OnEraseTabsFrame(pDC, rect, pTabWnd);
	}

	if (pTabWnd->IsFlatTab())
	{
		pDC->FillRect(rect, &afxGlobalData.brWindow);

		if (pTabWnd->GetLocation() != CMFCTabCtrl::LOCATION_BOTTOM)
		{
			CPen pen(PS_SOLID, 1, m_clrTabFlatBlack);
			CPen* pOldPen = pDC->SelectObject(&pen);

			pDC->MoveTo(rect.left, rect.top + pTabWnd->GetTabsHeight() + 1);
			pDC->LineTo(rect.right, rect.top + pTabWnd->GetTabsHeight() + 1);

			pDC->SelectObject(pOldPen);
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCVisualManagerOffice2007::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pBaseTab)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pBaseTab);

	CMFCTabCtrl* pWndTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, pBaseTab);

	if (!CanDrawImage() || pWndTab == NULL || pBaseTab->IsDialogControl())
	{
		CMFCVisualManagerOffice2003::OnEraseTabsButton(pDC, rect, pButton, pBaseTab);
		return;
	}

	if (pBaseTab->IsFlatTab() || pBaseTab->IsOneNoteStyle() || pBaseTab->IsColored() ||
		pBaseTab->IsVS2005Style() || pBaseTab->IsLeftRightRounded() || (!pButton->IsPressed() && !pButton->IsHighlighted()))
	{
		CMFCVisualManagerOffice2003::OnEraseTabsButton(pDC, rect, pButton, pBaseTab);
		return;
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rect);

	pDC->SelectClipRgn(&rgn);

	CRect rectTabs;
	pWndTab->GetClientRect(&rectTabs);

	CRect rectTabArea;
	pWndTab->GetTabsRect(rectTabArea);

	if (pWndTab->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rectTabs.top = rectTabArea.top;
	}
	else
	{
		rectTabs.bottom = rectTabArea.bottom;
	}

	pWndTab->MapWindowPoints(pButton, rectTabs);
	OnEraseTabsArea(pDC, rectTabs, pWndTab);

	pDC->SelectClipRgn(NULL);

	int index = pButton->IsPressed() ? 2 : 1;
	m_ctrlToolBarBtn.Draw(pDC, rect, index);
}

void CMFCVisualManagerOffice2007::OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawTabsButtonBorder(pDC, rect, pButton, uiState, pWndTab);
	}
}

void CMFCVisualManagerOffice2007::OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted /*= FALSE*/, BOOL bIsSelected /*= FALSE*/, BOOL bCanCollapse /*= FALSE*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);
	ASSERT_VALID(pGroup->m_pPage);

	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawTasksGroupCaption(pDC, pGroup, bIsHighlighted, bIsSelected, bCanCollapse);
		return;
	}

	CRect rectGroup = pGroup->m_rect;

	// -----------------------
	// Draw caption background
	// -----------------------
	CDrawingManager dm(*pDC);

	if (pGroup->m_bIsSpecial)
	{
		if (IsBeta())
		{
			dm.FillGradient(pGroup->m_rect, bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecLight : m_clrTaskPaneGroupCaptionSpecLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecDark : m_clrTaskPaneGroupCaptionSpecDark, TRUE);
		}
		else
		{
			dm.Fill4ColorsGradient(pGroup->m_rect, bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecDark  : m_clrTaskPaneGroupCaptionSpecDark,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecLight : m_clrTaskPaneGroupCaptionSpecLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecLight : m_clrTaskPaneGroupCaptionSpecLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighSpecDark  : m_clrTaskPaneGroupCaptionSpecDark, FALSE);
		}
	}
	else
	{
		if (IsBeta())
		{
			dm.FillGradient(pGroup->m_rect, bIsHighlighted ? m_clrTaskPaneGroupCaptionHighLight : m_clrTaskPaneGroupCaptionLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighDark : m_clrTaskPaneGroupCaptionDark, TRUE);
		}
		else
		{
			dm.Fill4ColorsGradient(pGroup->m_rect, bIsHighlighted ? m_clrTaskPaneGroupCaptionHighDark  : m_clrTaskPaneGroupCaptionDark,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighLight : m_clrTaskPaneGroupCaptionLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighLight : m_clrTaskPaneGroupCaptionLight,
				bIsHighlighted ? m_clrTaskPaneGroupCaptionHighDark  : m_clrTaskPaneGroupCaptionDark, FALSE);
		}
	}

	// ---------------------------
	// Draw an icon if it presents
	// ---------------------------
	BOOL bShowIcon = (pGroup->m_hIcon != NULL && pGroup->m_sizeIcon.cx < rectGroup.Width() - rectGroup.Height());
	if (bShowIcon)
	{
		OnDrawTasksGroupIcon(pDC, pGroup, 5, bIsHighlighted, bIsSelected, bCanCollapse);
	}

	// -----------------------
	// Draw group caption text
	// -----------------------
	CFont* pFontOld = pDC->SelectObject(&afxGlobalData.fontBold);
	COLORREF clrTextOld = pDC->GetTextColor();

	if (bCanCollapse && bIsHighlighted)
	{
		pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ?
			(pGroup->m_bIsSpecial ? m_clrTaskPaneGroupCaptionTextHighSpec : m_clrTaskPaneGroupCaptionTextHigh) : pGroup->m_clrTextHot);
	}
	else
	{
		pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ?
			(pGroup->m_bIsSpecial ? m_clrTaskPaneGroupCaptionTextSpec : m_clrTaskPaneGroupCaptionText) : pGroup->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	int nTaskPaneHOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionHorzOffset();
	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();
	int nCaptionHOffset = (nTaskPaneHOffset != -1 ? nTaskPaneHOffset : m_nGroupCaptionHorzOffset);

	CRect rectText = rectGroup;
	rectText.left += (bShowIcon ? pGroup->m_sizeIcon.cx + 5: nCaptionHOffset);
	rectText.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectText.right = max(rectText.left, rectText.right -(bCanCollapse ? rectGroup.Height() : nCaptionHOffset));

	pDC->DrawText(pGroup->m_strName, rectText, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);

	// -------------------------
	// Draw group caption button
	// -------------------------
	if (bCanCollapse && !pGroup->m_strName.IsEmpty())
	{
		CSize sizeButton = CMenuImages::Size();
		CRect rectButton = rectGroup;
		rectButton.left = max(rectButton.left, rectButton.right -(rectButton.Height() + 1) / 2 -(sizeButton.cx + 1) / 2);
		rectButton.top = max(rectButton.top, rectButton.bottom -(rectButton.Height() + 1) / 2 -(sizeButton.cy + 1) / 2);
		rectButton.right = rectButton.left + sizeButton.cx;
		rectButton.bottom = rectButton.top + sizeButton.cy;

		if (rectButton.right <= rectGroup.right && rectButton.bottom <= rectGroup.bottom)
		{
			if (bIsHighlighted)
			{
				// Draw button frame
				CBrush* pBrushOld = (CBrush*) pDC->SelectObject(&afxGlobalData.brBarFace);
				COLORREF clrBckOld = pDC->GetBkColor();

				pDC->Draw3dRect(&rectButton, afxGlobalData.clrWindow, afxGlobalData.clrBarShadow);

				pDC->SetBkColor(clrBckOld);
				pDC->SelectObject(pBrushOld);
			}

			CMenuImages::Draw(pDC, pGroup->m_bIsCollapsed ? CMenuImages::IdArrowDown : CMenuImages::IdArrowUp, rectButton.TopLeft(), CMenuImages::ImageBlack);
		}
	}
}

void CMFCVisualManagerOffice2007::OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted /*= FALSE*/, BOOL bIsSelected /*= FALSE*/)
{
	ASSERT_VALID(pTask);

	if (CanDrawImage() && pTask->m_bIsSeparator)
	{
		DrawSeparator(pDC, pTask->m_rect, TRUE);
		return;
	}

	CMFCVisualManagerOffice2003::OnDrawTask(pDC, pTask, pIcons, bIsHighlighted, bIsSelected);
}

void CMFCVisualManagerOffice2007::OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawScrollButtons(pDC, rect, nBorderSize, iImage, bHilited);
		return;
	}

	CRect rt(rect);
	rt.top--;
	m_ctrlTaskScrollBtn.Draw(pDC, rt, bHilited ? 1 : 0);

	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rect);
}

void CMFCVisualManagerOffice2007::OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawHeaderCtrlBorder(pCtrl, pDC, rect, bIsPressed, bIsHighlighted);
		return;
	}

	COLORREF clrStart  = m_clrHeaderNormalStart;
	COLORREF clrFinish = m_clrHeaderNormalFinish;
	COLORREF clrBorder = m_clrHeaderNormalBorder;

	if (bIsPressed)
	{
		clrStart  = m_clrHeaderPressedStart;
		clrFinish = m_clrHeaderPressedFinish;
		clrBorder = m_clrHeaderPressedBorder;
	}
	else if (bIsHighlighted)
	{
		clrStart  = m_clrHeaderHighlightedStart;
		clrFinish = m_clrHeaderHighlightedFinish;
		clrBorder = m_clrHeaderHighlightedBorder;
	}

	{
		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, clrFinish, clrStart);
	}

	CPen pen(PS_SOLID, 0, clrBorder);
	CPen* pOldPen = pDC->SelectObject(&pen);

	if (bIsPressed || bIsHighlighted)
	{
		pDC->MoveTo(rect.right - 1, rect.top);
		pDC->LineTo(rect.right - 1, rect.bottom - 1);
		pDC->LineTo(rect.left, rect.bottom - 1);
		pDC->LineTo(rect.left, rect.top - 1);
	}
	else
	{
		pDC->MoveTo(rect.right - 1, rect.top);
		pDC->LineTo(rect.right - 1, rect.bottom - 1);
		pDC->LineTo(rect.left - 1, rect.bottom - 1);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOffice2007::OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawCheckBoxEx(pDC, rect, nState, bHighlighted, bPressed, bEnabled);
		return;
	}

	int index = nState * 4;

	if (!bEnabled)
	{
		index += 3;
	}
	else if (bPressed)
	{
		if (bHighlighted)
		{
			index += 2;
		}
	}
	else if (bHighlighted)
	{
		index += 1;
	}

	if (afxGlobalData.m_bIsRTL)
	{
		m_ctrlRibbonBtnCheck.Mirror();
	}

	m_ctrlRibbonBtnCheck.FillInterior(pDC, rect, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, index);

	if (afxGlobalData.m_bIsRTL)
	{
		m_ctrlRibbonBtnCheck.Mirror();
	}
}

void CMFCVisualManagerOffice2007::OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rectCaption, CRect rectText)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonCaption(pDC, pBar, rectCaption, rectText);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	CWnd* pWnd = pBar->GetParent();
	ASSERT_VALID(pWnd);

	const DWORD dwStyle   = pWnd->GetStyle();
	const DWORD dwStyleEx = pWnd->GetExStyle();

	const BOOL bIsRTL     = (dwStyleEx & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
	const BOOL bActive    = IsWindowActive(pWnd);
	const BOOL bGlass	  = pBar->IsTransparentCaption();

	//int nExtraWidth = 0;

	{
		CSize szSysBorder(GetSystemBorders(TRUE));
		CRect rectCaption1(rectCaption);
		CRect rectBorder(m_ctrlMainBorderCaption.GetParams().m_rectSides);
		CRect rectQAT = pBar->GetQuickAccessToolbarLocation();

		if (rectQAT.left > rectQAT.right)
		{
			rectText.left = rectQAT.left + 1;
		}

		rectCaption1.InflateRect(szSysBorder.cx, szSysBorder.cy, szSysBorder.cx, 0);

		BOOL bHide  = (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ALL) != 0;
		BOOL bExtra = !bHide && pBar->IsQuickAccessToolbarOnTop() && rectQAT.left < rectQAT.right && (!pBar->IsQATEmpty() || IsBeta1());

		if (!bGlass)
		{
			if (IsBeta())
			{
				COLORREF clr1  = bActive ? m_clrAppCaptionActiveStart : m_clrAppCaptionInactiveStart;
				COLORREF clr2  = bActive ? m_clrAppCaptionActiveFinish : m_clrAppCaptionInactiveFinish;

				CRect rectCaption2(rectCaption1);
				rectCaption2.DeflateRect(rectBorder.left, rectBorder.top, rectBorder.right, rectBorder.bottom);

				CDrawingManager dm(*pDC);
				dm.Fill4ColorsGradient(rectCaption2, clr1, clr2, clr2, clr1, FALSE);

				m_ctrlMainBorderCaption.DrawFrame(pDC, rectCaption1, bActive ? 0 : 1);
			}
			else
			{
				m_ctrlMainBorderCaption.Draw(pDC, rectCaption1, bActive ? 0 : 1);
			}
		}

		if (bExtra)
		{
			CMFCControlRenderer* pCaptionQA = bGlass ? &m_ctrlRibbonCaptionQA_Glass : &m_ctrlRibbonCaptionQA;

			if (pCaptionQA->IsValid())
			{
				const CMFCControlRendererInfo& params = pCaptionQA->GetParams();

				CRect rectQAFrame(rectQAT);
				rectQAFrame.InflateRect(params.m_rectCorners.left - 2, 1, 0, 1);
				rectQAFrame.right   = pBar->GetQATCommandsLocation().right + GetRibbonQuickAccessToolBarRightMargin() + 1;

				if (rectQAFrame.Height() < params.m_rectImage.Height())
				{
					rectQAFrame.top = rectQAFrame.bottom - params.m_rectImage.Height();
				}

				if (bGlass)
				{
					const int dxFrame = GetSystemMetrics(SM_CXSIZEFRAME) / 2;

					const int nTop = afxGlobalData.GetRibbonImageScale () != 1. ? -2 : 1;
					rectQAFrame.DeflateRect (1, nTop, dxFrame, 0);
				}

				pCaptionQA->Draw(pDC, rectQAFrame, bActive ? 0 : 1);
			}
		}
		else if (bHide)
		{
			HICON hIcon = afxGlobalUtils.GetWndIcon(pWnd);

			if (hIcon != NULL)
			{
				CSize szIcon(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));

				CRect rectIcon(rectCaption.TopLeft(), CSize(min(::GetSystemMetrics(SM_CYCAPTION), rectCaption.Height()), rectCaption.Height()));

				long x = rectCaption.left + max(0, (rectIcon.Width()  - szIcon.cx) / 2);
				long y = rectCaption.top  + max(0, (rectIcon.Height() - szIcon.cy) / 2);

				pDC->DrawState(CPoint(x, y), szIcon, hIcon, DSS_NORMAL, (CBrush*)NULL);

				if (rectText.left < rectIcon.right)
				{
					rectText.left = rectIcon.right;
				}
			}
		}
	}

	CString strText;
	pWnd->GetWindowText(strText);

	CFont* pOldFont = (CFont*)pDC->SelectObject(&m_AppCaptionFont);
	ENSURE(pOldFont != NULL);

	CString strTitle(strText);
	CString strDocument;

	BOOL bPrefix = FALSE;
	if ((dwStyle & FWS_ADDTOTITLE) == FWS_ADDTOTITLE)
	{
		bPrefix = (dwStyle & FWS_PREFIXTITLE) == FWS_PREFIXTITLE;
		CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, pWnd);

		if (pFrameWnd != NULL)
		{
			strTitle = pFrameWnd->GetTitle();

			if (!strTitle.IsEmpty())
			{
				int pos = strText.Find(strTitle);

				if (pos != -1)
				{
					if (strText.GetLength() > strTitle.GetLength())
					{
						if (pos == 0)
						{
							bPrefix = FALSE; // avoid exception
							strTitle = strText.Left(strTitle.GetLength() + 3);
							strDocument = strText.Right(strText.GetLength() - strTitle.GetLength());
						}
						else
						{
							strTitle = strText.Right(strTitle.GetLength() + 3);
							strDocument = strText.Left(strText.GetLength() - strTitle.GetLength());
						}
					}
				}
			}
			else
			{
				strDocument = strText;
			}
		}
	}

	DrawNcText(pDC, rectText, strTitle, strDocument, bPrefix, bActive, bIsRTL, m_bNcTextCenter, bGlass,
		pWnd->IsZoomed() ? 0 : 10, pWnd->IsZoomed() ? RGB(255, 255, 255) :(COLORREF)-1);

	pDC->SelectObject(pOldFont);
}

int CMFCVisualManagerOffice2007::GetRibbonQuickAccessToolBarRightMargin()
{
	if (!CanDrawImage() || !m_ctrlRibbonCaptionQA.IsValid())
	{
		return CMFCVisualManagerOffice2003::GetRibbonQuickAccessToolBarRightMargin();
	}

	return m_ctrlRibbonCaptionQA.GetParams().m_rectSides.right;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonCaptionButton(pDC, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	const BOOL bHighlighted = pButton->IsHighlighted() || pButton->IsFocused();
	const BOOL bPressed = pButton->IsPressed();

	AFX_BUTTON_STATE state = ButtonsIsRegular;
	if (bPressed)
	{
		if (bHighlighted)
		{
			state = ButtonsIsPressed;
		}
	}
	else if (bHighlighted)
	{
		state = ButtonsIsHighlighted;
	}

	const BOOL bMDI = pButton->IsMDIChildButton();
	BOOL bActive = TRUE;

	if (!bMDI)
	{
		CMFCRibbonBar* pBar = pButton->GetParentRibbonBar();
		if (pBar->GetSafeHwnd() != NULL)
		{
			CWnd* pWnd = pBar->GetParent();
			ASSERT_VALID(pWnd);

			bActive = IsWindowActive(pWnd);
		}
	}

	DrawNcBtn(pDC, pButton->GetRect(), pButton->GetID(), state, FALSE, bActive, pButton->IsMDIChildButton());
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonButtonsGroup(CDC* pDC, CMFCRibbonButtonsGroup* pGroup, CRect rectGroup)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonButtonsGroup(pDC, pGroup, rectGroup);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);

	if (pGroup->IsKindOf(RUNTIME_CLASS(CMFCRibbonQuickAccessToolBar)) && m_ctrlRibbonPanelQAT.IsValid())
	{
		CMFCRibbonBar* pBar = pGroup->GetParentRibbonBar();

		if (pBar != NULL && (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ALL) == 0 && !pBar->IsQuickAccessToolbarOnTop())
		{
			m_ctrlRibbonPanelQAT.Draw(pDC, rectGroup);
		}
	}

	return(COLORREF)-1;
}

void CMFCVisualManagerOffice2007::OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled/* = FALSE*/, BOOL bIsPressed/* = FALSE*/, BOOL bIsHighlighted/* = FALSE*/)
{
	if (!CanDrawImage() || !m_RibbonBtnDefaultImage.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawDefaultRibbonImage(pDC, rectImage, bIsDisabled, bIsPressed, bIsHighlighted);
		return;
	}

	m_RibbonBtnDefaultImage.DrawEx(pDC, rectImage, bIsDisabled ? 1 : 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonApplicationButton(pDC, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	BOOL bHighlighted = pButton->IsHighlighted() || pButton->IsFocused();
	BOOL bPressed = pButton->IsPressed();

	if (pButton->IsDroppedDown())
	{
		bPressed = TRUE;
		bHighlighted = TRUE;
	}

	CRect rect = pButton->GetRect();
	rect.OffsetRect(1, -1);

	int index = 0;
	if (bPressed)
	{
		if (bHighlighted)
		{
			index = 2;
		}
	}
	else if (bHighlighted)
	{
		index = 1;
	}

	CRect rectImage(m_RibbonBtnMain.GetParams().m_rectImage);

	CMFCToolBarImages::ImageAlignHorz horz = CMFCToolBarImages::ImageAlignHorzStretch;
	CMFCToolBarImages::ImageAlignVert vert = CMFCToolBarImages::ImageAlignVertStretch;

	if (rect.Width() >= rectImage.Width() && rect.Height() >= rectImage.Height())
	{
		horz = CMFCToolBarImages::ImageAlignHorzCenter;
		vert = CMFCToolBarImages::ImageAlignVertCenter;
	}

	m_RibbonBtnMain.FillInterior(pDC, rect, horz, vert, index);
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* pWndRibbonBar, CRect rectTab)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonTabsFrame(pDC, pWndRibbonBar, rectTab);
	}
	/*
	if (IsBeta())
	{
	CDrawingManager dm(*pDC);
	dm.Fill4ColorsGradient(rectTab, m_clrAppCaptionActiveStart, m_clrAppCaptionActiveFinish,
	m_clrAppCaptionActiveFinish, m_clrAppCaptionActiveStart, FALSE);
	}
	*/
	return m_clrRibbonCategoryText;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonCategory(pDC, pCategory, rectCategory);
		return;
	}

	CMFCControlRenderer* pRenderer = &m_ctrlRibbonCategoryBack;
	CMFCVisualManagerBitmapCache* pCache = &m_cacheRibbonCategoryBack;

	CMFCRibbonBaseElement* pParentButton = pCategory->GetParentButton();

	if (pCategory->GetTabColor() != AFX_CategoryColor_None && (pParentButton == NULL || !pParentButton->IsQATMode()))
	{
		CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[pCategory->GetTabColor() - 1];

		pRenderer = &context.m_ctrlBack;
		pCache    = &context.m_cacheBack;
	}

	const CMFCControlRendererInfo& params = pRenderer->GetParams();

	CMFCRibbonPanelMenuBar* pMenuBar = pCategory->GetParentMenuBar();
	if (pMenuBar != NULL)
	{
		if (pMenuBar->GetCategory() != NULL)
		{
			if (rectCategory.left < 0 || rectCategory.top < 0)
			{
				CDrawingManager dm(*pDC);
				dm.FillGradient(rectCategory, m_clrBarGradientDark, m_clrBarGradientLight, TRUE);

				return;
			}
		}
		else if (pMenuBar->GetPanel() != NULL)
		{
			if (IsBeta())
			{
				pRenderer->FillInterior(pDC, rectCategory);
				return;
			}
		}
	}

	int nCacheIndex = -1;
	if (pCache != NULL)
	{
		CSize size(params.m_rectImage.Width(), rectCategory.Height());
		nCacheIndex = pCache->FindIndex(size);
		if (nCacheIndex == -1)
		{
			nCacheIndex = pCache->CacheY(size.cy, *pRenderer);
		}
	}

	if (nCacheIndex != -1)
	{
		pCache->Get(nCacheIndex)->DrawY(pDC, rectCategory, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right));
	}
	else
	{
		pRenderer->Draw(pDC, rectCategory);
	}
}

void CMFCVisualManagerOffice2007::OnDrawRibbonCategoryScroll (
					CDC* pDC, 
					CRibbonCategoryScroll* pScroll)
{
	if (!CanDrawImage ())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonCategoryScroll (pDC, pScroll);
		return;
	}

	ASSERT_VALID (pDC);
	ASSERT_VALID (pScroll);

	CRect rect = pScroll->GetRect ();

	CMFCControlRenderer* pRenderer = 
		&m_ctrlRibbonCategoryBtnPage[pScroll->IsLeftScroll () ? 0 : 1];
	int index = 0;

	if (pScroll->IsPressed ())
	{
		index = 1;
		if (pScroll->IsHighlighted())
		{
			index = 2;
		}
	}
	else if (pScroll->IsHighlighted())
	{
		index = 1;
	}

	pRenderer->Draw (pDC, rect, index);
	
	BOOL bIsLeft = pScroll->IsLeftScroll ();
	if (afxGlobalData.m_bIsRTL)
	{
		bIsLeft = !bIsLeft;
	}

	CMenuImages::Draw (pDC,
		bIsLeft ? CMenuImages::IdArrowLeftLarge : CMenuImages::IdArrowRightLarge, 
		rect);
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab,
	BOOL bIsActive)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonCategoryTab(pDC, pTab, bIsActive);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pTab);

	CMFCRibbonCategory* pCategory = pTab->GetParentCategory();
	ASSERT_VALID(pCategory);
	CMFCRibbonBar* pBar = pCategory->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	bIsActive = bIsActive && ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0 || pTab->GetDroppedDown() != NULL);

	const BOOL bPressed     = pTab->IsPressed();
	const BOOL bIsFocused	= pTab->IsFocused() && (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS);
	const BOOL bIsHighlight = (pTab->IsHighlighted() || bIsFocused) && !pTab->IsDroppedDown();

	CRect rectTab(pTab->GetRect());
	rectTab.bottom++;

	int ratio = 0;
	if (!IsBeta() && m_ctrlRibbonCategoryTabSep.IsValid())
	{
		ratio = pBar->GetTabTruncateRatio();
	}

	if (ratio > 0)
	{
		rectTab.left++;
	}

	int nImage = bIsActive ? 3 : 0;

	if (bPressed)
	{
		if (bIsHighlight)
		{
			nImage = bIsActive ? 2 : 1;
		}
	}

	if (bIsHighlight)
	{
		nImage += 1;
	}

	CMFCControlRenderer* pRenderer = &m_ctrlRibbonCategoryTab;
	COLORREF clrText = m_clrRibbonCategoryText;
	COLORREF clrTextHighlighted = m_clrRibbonCategoryTextHighlighted;

	if (pCategory->GetTabColor() != AFX_CategoryColor_None || pTab->IsSelected())
	{
		CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[(pTab->IsSelected() || nImage == 4) ? AFX_CategoryColor_Orange - 1 : pCategory->GetTabColor() - 1];
		pRenderer = &context.m_ctrlTab;
		clrText  = context.m_clrText;
		clrTextHighlighted = context.m_clrTextHighlighted;
	}

	pRenderer->Draw(pDC, rectTab, nImage);

	if (ratio > 0)
	{
		CRect rectSep(rectTab);
		rectSep.left = rectSep.right;
		rectSep.right++;
		rectSep.bottom--;

		m_ctrlRibbonCategoryTabSep.Draw(pDC, rectSep, 0, (BYTE)min(ratio * 255 / 100, 255));
	}

	return bIsActive ? clrTextHighlighted : clrText;
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonPanel(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectPanel, CRect rectCaption)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonPanel(pDC, pPanel, rectPanel, rectCaption);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pPanel);

	COLORREF clrText = m_clrRibbonPanelText;

	if (pPanel->IsKindOf(RUNTIME_CLASS(CMFCRibbonMainPanel)))
	{
		const int nBorderSize = GetPopupMenuBorderSize();
		rectPanel.InflateRect(nBorderSize, nBorderSize);

		m_ctrlRibbonMainPanel.Draw(pDC, rectPanel);
	}
	else
	{
		BOOL bHighlighted = pPanel->IsHighlighted();

		if (bHighlighted)
		{
			clrText = m_clrRibbonPanelTextHighlighted;
		}

		CMFCControlRenderer* pRendererB = &m_ctrlRibbonPanelBack_B;
		CMFCControlRenderer* pRendererT = &m_ctrlRibbonPanelBack_T;
		CMFCVisualManagerBitmapCache* pCacheB = &m_cacheRibbonPanelBack_B;
		CMFCVisualManagerBitmapCache* pCacheT = &m_cacheRibbonPanelBack_T;

		CMFCRibbonCategory* pCategory = pPanel->GetParentCategory();
		ASSERT_VALID(pCategory);

		CMFCRibbonBaseElement* pParentButton = pPanel->GetParentButton();

		if (pCategory->GetTabColor() != AFX_CategoryColor_None && (pParentButton == NULL || !pParentButton->IsQATMode()))
		{
			pRendererB = &m_ctrlRibbonContextPanelBack_B;
			pRendererT = &m_ctrlRibbonContextPanelBack_T;
			pCacheB = &m_cacheRibbonContextPanelBack_B;
			pCacheT = &m_cacheRibbonContextPanelBack_T;

			clrText = bHighlighted ? m_clrRibbonContextPanelTextHighlighted : m_clrRibbonContextPanelText;
		}

		if (!pPanel->IsCollapsed())
		{
			CRect rect(rectPanel);

			BOOL bDrawCaption = rectCaption.Height() > 0 && pRendererT->IsValid();

			if (bDrawCaption)
			{
				BOOL bBottomEnabled = pRendererB->IsValid();

				if (bBottomEnabled)
				{
					rect.bottom -= rectCaption.Height() == 0 ? pRendererB->GetParams().m_rectImage.Height() : rectCaption.Height();
				}

				{
					const CMFCControlRendererInfo& params = pRendererT->GetParams();

					int nCacheIndex = -1;
					if (pCacheT != NULL)
					{
						CSize size(params.m_rectImage.Width(), rect.Height());
						nCacheIndex = pCacheT->FindIndex(size);
						if (nCacheIndex == -1)
						{
							nCacheIndex = pCacheT->CacheY(size.cy, *pRendererT);
						}
					}

					if (nCacheIndex != -1)
					{
						pCacheT->Get(nCacheIndex)->DrawY(pDC, rect, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right), bHighlighted ? 1 : 0);
					}
					else
					{
						pRendererT->Draw(pDC, rect, bHighlighted ? 1 : 0);
					}
				}

				if (bBottomEnabled)
				{
					rect.top = rect.bottom;
					rect.bottom = rectPanel.bottom;

					const CMFCControlRendererInfo& params = pRendererB->GetParams();

					int nCacheIndex = -1;
					if (pCacheB != NULL)
					{
						CSize size(params.m_rectImage.Width(), rect.Height());
						nCacheIndex = pCacheB->FindIndex(size);
						if (nCacheIndex == -1)
						{
							nCacheIndex = pCacheB->CacheY(size.cy, *pRendererB);
						}
					}

					if (nCacheIndex != -1)
					{
						pCacheB->Get(nCacheIndex)->DrawY(pDC, rect, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right), bHighlighted ? 1 : 0);
					}
					else
					{
						pRendererB->Draw(pDC, rect, bHighlighted ? 1 : 0);
					}
				}
			}
		}
	}

	return clrText;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonPanelCaption(pDC, pPanel, rectCaption);
		return;
	}

	if (pPanel->IsKindOf(RUNTIME_CLASS(CMFCRibbonMainPanel)))
	{
		return;
	}

	CString str = pPanel->GetName();

	if (!str.IsEmpty())
	{
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
		if (pPanel->GetLaunchButton().GetID() > 0)
		{
			rectCaption.right = pPanel->GetLaunchButton().GetRect().left;

			rectCaption.DeflateRect(1, 1);
			rectCaption.OffsetRect(-1, -1);
		}
		else
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
		{
			rectCaption.DeflateRect(1, 1);

			if ((rectCaption.Width() % 2) == 0)
			{
				rectCaption.right--;
			}

			rectCaption.OffsetRect(0, -1);
		}

		COLORREF clrTextOld = pDC->SetTextColor(pPanel->IsHighlighted() ? m_clrRibbonPanelCaptionTextHighlighted : m_clrRibbonPanelCaptionText);

		pDC->DrawText( str, rectCaption, DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX);
		pDC->SetTextColor(clrTextOld);
	}
}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
void CMFCVisualManagerOffice2007::OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonLaunchButton(pDC, pButton, pPanel);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pPanel);

	CRect rect(pButton->GetRect());

	if (!IsBeta())
	{
		rect.right--;
		rect.bottom--;
	}

	BOOL bHighlighted = pButton->IsHighlighted() || pButton->IsFocused();

	int index = 0;

	if (m_RibbonBtnLaunchIcon.GetCount() > 3)
	{
		if (pButton->IsDisabled())
		{
			index = 3;
		}
		else if (pButton->IsPressed())
		{
			if (bHighlighted)
			{
				index = 2;
			}
		}
		else if (bHighlighted)
		{
			index = 1;
		}
	}
	else
	{
		if (!pButton->IsDisabled())
		{
			if (pButton->IsPressed())
			{
				if (bHighlighted)
				{
					index = 2;
				}
			}
			else if (bHighlighted)
			{
				index = 1;
			}
		}
	}

	if (m_ctrlRibbonBtnLaunch.IsValid())
	{
		m_ctrlRibbonBtnLaunch.Draw(pDC, rect, index);
	}

	if (m_RibbonBtnLaunchIcon.IsValid())
	{
		m_RibbonBtnLaunchIcon.DrawEx(pDC, rect, index, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
	}
}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

COLORREF CMFCVisualManagerOffice2007::OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnFillRibbonButton(pDC, pButton);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	const BOOL bIsMenuMode = pButton->IsMenuMode();

	CRect rect(pButton->GetRect());

	CMFCControlRenderer* pRenderer = NULL;
	CMFCVisualManagerBitmapCache* pCache = NULL;
	int index = 0;

	BOOL bDisabled    = pButton->IsDisabled();
	BOOL bFocused     = pButton->IsFocused();
	BOOL bDroppedDown = pButton->IsDroppedDown();
	BOOL bPressed     = pButton->IsPressed() && !bIsMenuMode;
	BOOL bChecked     = pButton->IsChecked();
	BOOL bHighlighted = pButton->IsHighlighted() || bFocused;

	BOOL bDefaultPanelButton = pButton->IsDefaultPanelButton() && !pButton->IsQATMode();
	if (bFocused)
	{
		bDisabled = FALSE;
	}

	if (pButton->IsDroppedDown() && !bIsMenuMode)
	{
		bChecked     = TRUE;
		bPressed     = FALSE;
		bHighlighted = FALSE;
	}

	CMFCRibbonBaseElement::RibbonElementLocation location = pButton->GetLocationInGroup();

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		rect.left = pButton->GetCommandRect().left;

		COLORREF color1 = m_clrRibbonEdit;
		if (bDisabled)
		{
			color1 = m_clrRibbonEditDisabled;
		}
		else if (bChecked || bHighlighted)
		{
			color1 = m_clrRibbonEditHighlighted;
		}

		COLORREF color2 = color1;

		{
			CDrawingManager dm(*pDC);
			dm.FillGradient(rect, color1, color2, TRUE);
		}

		return(COLORREF)-1;
	}

	if (bChecked && bIsMenuMode && !pButton->IsGalleryIcon())
	{
		bChecked = FALSE;
	}

	if (location != CMFCRibbonBaseElement::RibbonElementNotInGroup && pButton->IsShowGroupBorder())
	{
		if (!pButton->GetMenuRect().IsRectEmpty())
		{
			CRect rectC = pButton->GetCommandRect();
			CRect rectM = pButton->GetMenuRect();

			CMFCControlRenderer* pRendererC = NULL;
			CMFCControlRenderer* pRendererM = NULL;

			CMFCVisualManagerBitmapCache* pCacheC = NULL;
			CMFCVisualManagerBitmapCache* pCacheM = NULL;

			if (location == CMFCRibbonBaseElement::RibbonElementSingleInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_F[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_L[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_F[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_L[1];
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementFirstInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_F[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_F[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_F[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_F[1];
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementLastInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_L[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_L[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_L[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_L[1];
			}
			else
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_M[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_M[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_M[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_M[1];
			}

			int indexC = 0;
			int indexM = 0;

			BOOL bHighlightedC = pButton->IsCommandAreaHighlighted();
			BOOL bHighlightedM = pButton->IsMenuAreaHighlighted();

			if (IsBeta())
			{
				if (bChecked)
				{
					indexC = 3;
				}

				if (bDisabled)
				{
					indexC = 0;
				}
				else
				{
					if (pButton->IsDroppedDown() && !bIsMenuMode)
					{
						indexC = pButton->IsChecked() ? 3 : 0;
						indexM = 3;
					}
					else
					{
						if (bPressed)
						{
							if (bHighlightedC)
							{
								indexM = 1;
								indexC = 2;
							}
						}
						else if (bHighlighted)
						{
							indexC++;
							indexM = 1;
						}
					}
				}
			}
			else
			{
				if (bChecked)
				{
					indexC = 3;

					if (bHighlighted)
					{
						indexM = 5;
					}
				}

				if (bDisabled)
				{
					if (bChecked)
					{
						indexC = 5;
						indexM = 4;
					}
				}
				else
				{
					if (pButton->IsDroppedDown() && !bIsMenuMode)
					{
						indexC = pButton->IsChecked() ? 3 : 6;
						indexM = 3;
					}
					else
					{
						if (bFocused)
						{
							indexC = 6;
							indexM = 5;
						}

						if (bHighlightedC || bHighlightedM)
						{
							if (bChecked)
							{
								indexC = bHighlightedC ? 4 : 3;
							}
							else
							{
								indexC = bHighlightedC ? 1 : 6;
							}

							indexM = bHighlightedM ? 1 : 5;
						}

						if (bPressed)
						{
							if (bHighlightedC)
							{
								indexC = 2;
							}
						}
					}
				}
			}

			if (indexC != -1 && indexM != -1)
			{
				int nCacheIndex = -1;
				if (pCacheC != NULL)
				{
					CSize size(rectC.Size());
					nCacheIndex = pCacheC->FindIndex(size);
					if (nCacheIndex == -1)
					{
						nCacheIndex = pCacheC->Cache(size, *pRendererC);
					}
				}

				if (nCacheIndex != -1)
				{
					pCacheC->Get(nCacheIndex)->Draw(pDC, rectC, indexC);
				}
				else
				{
					pRendererC->Draw(pDC, rectC, indexC);
				}

				nCacheIndex = -1;
				if (pCacheM != NULL)
				{
					CSize size(rectM.Size());
					nCacheIndex = pCacheM->FindIndex(size);
					if (nCacheIndex == -1)
					{
						nCacheIndex = pCacheM->Cache(size, *pRendererM);
					}
				}

				if (nCacheIndex != -1)
				{
					pCacheM->Get(nCacheIndex)->Draw(pDC, rectM, indexM);
				}
				else
				{
					pRendererM->Draw(pDC, rectM, indexM);
				}
			}

			return(COLORREF)-1;
		}
		else
		{
			if (location == CMFCRibbonBaseElement::RibbonElementSingleInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_S;
				pCache    = &m_cacheRibbonBtnGroup_S;
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementFirstInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_F;
				pCache    = &m_cacheRibbonBtnGroup_F;
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementLastInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_L;
				pCache    = &m_cacheRibbonBtnGroup_L;
			}
			else
			{
				pRenderer = &m_ctrlRibbonBtnGroup_M;
				pCache    = &m_cacheRibbonBtnGroup_M;
			}

			if (bChecked)
			{
				index = 3;
			}

			if (bDisabled && !bFocused)
			{
				index = 0;
			}
			else
			{
				if (bPressed)
				{
					if (bHighlighted)
					{
						index = 2;
					}
				}
				else if (bHighlighted)
				{
					index++;
				}
			}
		}
	}
	else if (bDefaultPanelButton)
	{
		if (bPressed)
		{
			if (bHighlighted)
			{
				index = 2;
			}
		}
		else if (bHighlighted)
		{
			index = 1;
		}
		else if (bChecked)
		{
			index = 2;
		}

		if (bFocused && !bDroppedDown && m_ctrlRibbonBtnDefault.GetImageCount() > 3)
		{
			index = 3;
		}

		if (index != -1)
		{
			pRenderer = &m_ctrlRibbonBtnDefault;
			CMFCVisualManagerBitmapCache* pCacheDefault = &m_cacheRibbonBtnDefault;

			CMFCRibbonCategory* pCategory = pButton->GetParentCategory();
			ASSERT_VALID(pCategory);

			if (pCategory->GetTabColor() != AFX_CategoryColor_None)
			{
				CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[pCategory->GetTabColor() - 1];

				pRenderer = &context.m_ctrlBtnDefault;
				pCacheDefault = &context.m_cacheBtnDefault;
			}

			const CMFCControlRendererInfo& params = pRenderer->GetParams();

			int nCacheIndex = -1;
			if (pCacheDefault != NULL)
			{
				CSize size(params.m_rectImage.Width(), rect.Height());
				nCacheIndex = pCacheDefault->FindIndex(size);
				if (nCacheIndex == -1)
				{
					nCacheIndex = pCacheDefault->CacheY(size.cy, *pRenderer);
				}
			}

			if (nCacheIndex != -1)
			{
				pCacheDefault->Get(nCacheIndex)->DrawY(pDC, rect, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right), index);

				return m_clrToolBarBtnTextHighlighted;
			}
		}
	}
	else if ((!bDisabled &&(bPressed || bChecked || bHighlighted)) || (bDisabled && bFocused))
	{
		if (!pButton->GetMenuRect().IsRectEmpty()/* && (pButton->IsHighlighted() || bChecked)*/)
		{
			CRect rectC = pButton->GetCommandRect();
			CRect rectM = pButton->GetMenuRect();

			CMFCControlRenderer* pRendererC = pButton->IsMenuOnBottom() ? &m_ctrlRibbonBtnMenuV[0] : &m_ctrlRibbonBtnMenuH[0];
			CMFCControlRenderer* pRendererM = pButton->IsMenuOnBottom() ? &m_ctrlRibbonBtnMenuV[1] : &m_ctrlRibbonBtnMenuH[1];

			int indexC = -1;
			int indexM = -1;

			BOOL bDropped      = pButton->IsDroppedDown();
			BOOL bHighlightedC = pButton->IsCommandAreaHighlighted();
			BOOL bHighlightedM = pButton->IsMenuAreaHighlighted();

			if (IsBeta())
			{
				if (bChecked)
				{
					indexC = 2;
					indexM = 2;
				}

				if (bDisabled)
				{
					if (bChecked)
					{
					}
				}
				else
				{
					if (bDropped && !bIsMenuMode)
					{
						indexC = bChecked ? 2 : 4;
						indexM = 2;
					}
					else
					{
						if (bPressed)
						{
							if (bHighlighted)
							{
								if (bHighlightedC)
								{
									indexC = 1;
								}
								else
								{
									indexC = bChecked ? indexC : 0;
								}

								indexM = bChecked ? indexM : 0;
							}
						}
						else if (bHighlighted)
						{
							indexC++;
							indexM++;
						}
					}
				}
			}
			else
			{
				if (bDisabled)
				{
					if (bHighlightedC || bHighlightedM)
					{
						indexC = 4;
						indexM = 4;

						if (bHighlightedM)
						{
							indexM = 0;

							if (bDropped && !bIsMenuMode)
							{
								indexC = 5;
								indexM = 2;
							}
							else if (bPressed)
							{
								indexM = 1;
							}
						}
					}
				}
				else
				{
					if (bDropped && !bIsMenuMode)
					{
						indexC = 5;
						indexM = 2;
					}
					else
					{
						if (bFocused)
						{
							indexC = 5;
							indexM = 4;
						}

						if (bChecked)
						{
							indexC = 2;
							indexM = 2;
						}

						if (bHighlightedC || bHighlightedM)
						{
							indexM = 4;

							if (bPressed)
							{
								if (bHighlightedC)
								{
									indexC = 1;
								}
								else if (bHighlightedM)
								{
									indexC = bChecked ? 3 : 5;
								}
							}
							else
							{
								indexC = bChecked ? 3 : 0;

								if (bHighlightedM)
								{
									indexC = bChecked ? 3 : 5;
									indexM = 0;
								}
							}
						}
					}
				}
			}

			if (indexC != -1)
			{
				pRendererC->Draw(pDC, rectC, indexC);
			}

			if (indexM != -1)
			{
				pRendererM->Draw(pDC, rectM, indexM);
			}

			return(COLORREF)-1;
		}
		else
		{
			index = -1;

			pRenderer = &m_ctrlRibbonBtn[0];
			if (rect.Height() > pRenderer->GetParams().m_rectImage.Height() * 1.5 && m_ctrlRibbonBtn[1].IsValid())
			{
				pRenderer = &m_ctrlRibbonBtn[1];
			}

			if (bDisabled && bFocused)
			{
				if (pRenderer->GetImageCount() > 4)
				{
					index = 4;
				}
				else
				{
					index = 0;
				}
			}

			if (!bDisabled)
			{
				if (bChecked)
				{
					index = 2;
				}

				if (bPressed)
				{
					if (bHighlighted)
					{
						index = 1;
					}
				}
				else if (bHighlighted)
				{
					index++;
				}
			}
		}
	}

	COLORREF clrText = bDisabled ? m_clrToolBarBtnTextDisabled : COLORREF(-1);

	if (pRenderer != NULL)
	{
		if (index != -1)
		{
			int nCacheIndex = -1;
			if (pCache != NULL)
			{
				CSize size(rect.Size());
				nCacheIndex = pCache->FindIndex(size);
				if (nCacheIndex == -1)
				{
					nCacheIndex = pCache->Cache(size, *pRenderer);
				}
			}

			if (nCacheIndex != -1)
			{
				pCache->Get(nCacheIndex)->Draw(pDC, rect, index);
			}
			else
			{
				pRenderer->Draw(pDC, rect, index);
			}

			if (!bDisabled)
			{
				clrText = m_clrToolBarBtnTextHighlighted;
			}
		}
	}

	return clrText;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonButtonBorder(pDC, pButton);
	}

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		CRect rect(pButton->GetRect());

		COLORREF colorBorder = m_clrRibbonEditBorder;

		if (pButton->IsDisabled())
		{
			colorBorder = m_clrRibbonEditBorderDisabled;
		}
		else if (pButton->IsHighlighted() || pButton->IsDroppedDown() || pButton->IsFocused())
		{
			colorBorder = pButton->IsDroppedDown() ? m_clrRibbonEditBorderPressed : m_clrRibbonEditBorderHighlighted;
		}

		rect.left = pButton->GetCommandRect().left;

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, (COLORREF)-1, colorBorder);
		}
		else
		{
			pDC->Draw3dRect(rect, colorBorder, colorBorder);
		}
	}
}

void CMFCVisualManagerOffice2007::OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonMenuCheckFrame(pDC, pButton, rect);
		return;
	}

	ASSERT_VALID(pDC);

	m_ctrlMenuItemBack.Draw(pDC, rect);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonDefaultPaneButton(pDC, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	OnFillRibbonButton(pDC, pButton);

	BOOL bIsQATMode = pButton->IsQATMode();

	CRect rectFrame(pButton->GetRect());

	if (!bIsQATMode)
	{
		if (m_ctrlRibbonBtnDefaultIcon.IsValid())
		{
			const CSize sizeImage = pButton->GetImageSize(CMFCRibbonButton::RibbonImageSmall);
			const int nMarginX = 11;
			const int nMarginY = 10;

			rectFrame.top += nMarginY / 2;
			rectFrame.bottom = rectFrame.top + sizeImage.cy + 2 * nMarginY;
			rectFrame.top -= 2;
			rectFrame.left = rectFrame.CenterPoint().x - sizeImage.cx / 2 - nMarginX;
			rectFrame.right = rectFrame.left + sizeImage.cx + 2 * nMarginX;

			m_ctrlRibbonBtnDefaultIcon.Draw(pDC, rectFrame);
		}
	}
	else
	{
		if (m_ctrlRibbonBtnDefaultQAT.IsValid())
		{
			int index = 0;
			if (pButton->IsDroppedDown())
			{
				index = 2;
			}
			else if (pButton->IsPressed())
			{
				if (pButton->IsHighlighted())
				{
					index = 2;
				}
			}
			else if (pButton->IsHighlighted() || pButton->IsFocused())
			{
				index = 1;
			}

			m_ctrlRibbonBtnDefaultQAT.Draw(pDC, rectFrame, index);
		}
		else if (m_ctrlRibbonBtnDefaultQATIcon.IsValid())
		{
			int nHeight = m_ctrlRibbonBtnDefaultQATIcon.GetParams().m_rectImage.Height();

			if (rectFrame.Height() < nHeight)
			{
				nHeight = rectFrame.Height() / 2;
			}

			rectFrame.DeflateRect(1, 0);
			rectFrame.top = rectFrame.bottom - nHeight;

			m_ctrlRibbonBtnDefaultQATIcon.Draw(pDC, rectFrame);
		}
	}

	OnDrawRibbonDefaultPaneButtonContext(pDC, pButton);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonDefaultPaneButtonIndicator(CDC* pDC, CMFCRibbonButton* pButton, CRect rect, BOOL bIsSelected, BOOL bHighlighted)
{
	if (!CanDrawImage() || !m_ctrlRibbonBtnDefaultIcon.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonDefaultPaneButtonIndicator(pDC, pButton, rect, bIsSelected, bHighlighted);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	rect.left = rect.right - m_ctrlRibbonBtnDefaultIcon.GetParams().m_rectImage.Width();
	m_ctrlRibbonBtnDefaultIcon.Draw(pDC, rect);

	CRect rectWhite = rect;
	rectWhite.OffsetRect(0, 1);

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectWhite, CMenuImages::ImageWhite);
	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, CMenuImages::ImageBlack);
}

void CMFCVisualManagerOffice2007::OnFillRibbonEdit(CDC* pDC, CMFCRibbonRichEditCtrl* pEdit, CRect rect, BOOL bIsHighlighted, BOOL bIsPaneHighlighted,
	BOOL bIsDisabled, COLORREF& clrText, COLORREF& clrSelBackground, COLORREF& clrSelText)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillRibbonEdit(pDC, pEdit, rect, bIsHighlighted, bIsPaneHighlighted, bIsDisabled, clrText, clrSelBackground, clrSelText);
		return;
	}

	ASSERT_VALID(pDC);

	COLORREF color1 = m_clrRibbonEdit;

	if (bIsDisabled)
	{
		color1 = m_clrRibbonEditDisabled;
	}
	else
	{
		if (bIsHighlighted)
		{
			color1 = m_clrRibbonEditHighlighted;
		}
	}

	COLORREF color2 = color1;

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, color1, color2, TRUE);

	if (bIsDisabled)
	{
		clrText = afxGlobalData.clrGrayedText;
	}
	else
	{
		clrText = m_clrMenuText;
		clrSelText = m_clrMenuText;
		clrSelBackground = m_clrRibbonEditSelection;
	}
}

void CMFCVisualManagerOffice2007::OnDrawRibbonMainPanelFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonMainPanelFrame(pDC, pPanel, rect);
		return;
	}

	if (!IsBeta())
	{
		ASSERT_VALID(pDC);

		rect.right += 2;
		m_ctrlRibbonMainPanelBorder.DrawFrame(pDC, rect);
	}
}

void CMFCVisualManagerOffice2007::OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillRibbonMenuFrame(pDC, pPanel, rect);
		return;
	}

	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brMenuLight);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonRecentFilesFrame(pDC, pPanel, rect);
		return;
	}

	ASSERT_VALID(pDC);

	rect.right += 2;
	pDC->FillRect(rect, &m_brBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.right = rectSeparator.left + 2;

	DrawSeparator(pDC, rectSeparator, FALSE);
}

COLORREF CMFCVisualManagerOffice2007::OnFillRibbonMainPanelButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnFillRibbonMainPanelButton(pDC, pButton);
	}

	BOOL bHighlighted = pButton->IsHighlighted();

	COLORREF clrText = bHighlighted ? m_clrMenuTextHighlighted : pButton->IsDisabled() ? m_clrMenuTextDisabled : m_clrMenuText;

	const int index = bHighlighted ? 1 : 0;
	m_ctrlRibbonBtnMainPanel.Draw(pDC, pButton->GetRect(), index);

	return clrText;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonMainPanelButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonMainPanelButtonBorder(pDC, pButton);
		return;
	}
}

void CMFCVisualManagerOffice2007::OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonGalleryButton(pDC, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	int index = 0;
	if (pButton->IsDisabled())
	{
		index = 3;
	}
	else
	{
		if (pButton->IsPressed())
		{
			if (pButton->IsHighlighted())
			{
				index = 2;
			}
		}
		else if (pButton->IsHighlighted() || pButton->IsFocused())
		{
			index = 1;
		}
	}

	int nBtn = 1;
	if (pButton->IsLast())
	{
		nBtn = 2;
	}
	else if (pButton->IsFirst())
	{
		nBtn = 0;
	}

	m_ctrlRibbonBtnPalette[nBtn].Draw(pDC, pButton->GetRect(), index);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonGalleryBorder(CDC* pDC, CMFCRibbonGallery* pButton, CRect rectBorder)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonGalleryBorder(pDC, pButton, rectBorder);
		return;
	}

	rectBorder.right -= 5;

	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption)
{
	if (!CanDrawImage() || pContextCaption->GetColor() == AFX_CategoryColor_None)
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonCategoryCaption(pDC, pContextCaption);
	}

	CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[pContextCaption->GetColor() - 1];

	CRect rect(pContextCaption->GetRect());
	context.m_ctrlCaption.Draw(pDC, rect);

	int xTabRight = pContextCaption->GetRightTabX();

	if (xTabRight > 0)
	{
		CRect rectTab(pContextCaption->GetParentRibbonBar()->GetActiveCategory()->GetTabRect());
		rect.top = rectTab.top;
		rect.bottom = rectTab.bottom;
		rect.right = xTabRight;

		m_ctrlRibbonContextSeparator.DrawFrame(pDC, rect);
	}

	return context.m_clrCaptionText;
}

COLORREF CMFCVisualManagerOffice2007::OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::OnDrawRibbonStatusBarPane(pDC, pBar, pPane);
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);
	ASSERT_VALID(pPane);

	CRect rectPane = pPane->GetRect();

	const BOOL bHighlighted = pPane->IsHighlighted();
	const BOOL bChecked     = pPane->IsChecked();
	const BOOL bExtended = pPane->IsExtended();

	if (bHighlighted || bChecked)
	{
		CRect rectButton = rectPane;
		rectButton.DeflateRect(1, 1);

		int index = 0;
		if (pPane->IsPressed())
		{
			if (bHighlighted)
			{
				index = 1;
			}
		}
		else if (bChecked)
		{
			if (bHighlighted)
			{
				index = 0;
			}
			else
			{
				index = 1;
			}
		}

		m_ctrlRibbonBtnStatusPane.Draw(pDC, rectButton, index);
	}

	if (pPane->IsDisabled())
	{
		return bExtended ? m_clrExtenedStatusBarTextDisabled : m_clrStatusBarTextDisabled;
	}

	return bHighlighted ? m_clrToolBarBtnTextHighlighted : m_clrStatusBarText;
}

void CMFCVisualManagerOffice2007::OnDrawRibbonSliderZoomButton( CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonSliderZoomButton( pDC, pSlider, rect, bIsZoomOut, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	CMFCControlRenderer* pRenderer = bIsZoomOut ? &m_ctrlRibbonSliderBtnMinus : &m_ctrlRibbonSliderBtnPlus;

	int index = 0;
	if (bIsPressed)
	{
		if (bIsHighlighted)
		{
			index = 2;
		}
	}
	else if (bIsHighlighted)
	{
		index = 1;
	}

	pRenderer->FillInterior(pDC, rect, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, index);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonSliderChannel( pDC, pSlider, rect);
		return;
	}

	ASSERT_VALID(pDC);

	DrawSeparator(pDC, rect, m_penSeparatorDark, m_penSeparator2, TRUE);

	rect.left += rect.Width() / 2 - 1;
	rect.right = rect.left + 2;
	rect.top -= 2;
	rect.bottom += 2;
	DrawSeparator(pDC, rect, m_penSeparatorDark, m_penSeparator2, FALSE);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonSliderThumb(pDC, pSlider, rect, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	int index = 0;
	if (bIsPressed)
	{
		index = 2;
	}
	else if (bIsHighlighted)
	{
		index = 1;
	}

	m_ctrlRibbonSliderThumb.FillInterior(pDC, rect, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, index);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonProgressBar(pDC, pProgress, rectProgress, rectChunk, bInfiniteMode);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pProgress);

	m_ctrlRibbonProgressBack.Draw(pDC, rectProgress);

	CRect rectInternal(rectProgress);
	CRect rectBorders(m_ctrlRibbonProgressBack.GetParams().m_rectCorners);

	rectInternal.DeflateRect(rectBorders.left, rectBorders.top, rectBorders.right, rectBorders.bottom);

	if (!bInfiniteMode)
	{
		// normal
		rectChunk.IntersectRect(rectChunk, rectInternal);

		if (!rectChunk.IsRectEmpty() || pProgress->GetPos() != pProgress->GetRangeMin())
		{
			CRgn rgn;
			rgn.CreateRectRgnIndirect(rectInternal);
			pDC->SelectClipRgn(&rgn);

			if (!rectChunk.IsRectEmpty())
			{
				rectChunk.left = rectChunk.right - rectInternal.Width();
				m_ctrlRibbonProgressNormal.Draw(pDC, rectChunk);
			}
			else
			{
				rectChunk = rectInternal;
				rectChunk.right  = rectInternal.left;
			}

			if (rectChunk.right != rectInternal.right)
			{
				rectChunk.left = rectChunk.right;
				rectChunk.right += m_ctrlRibbonProgressNormalExt.GetParams().m_rectImage.Width();

				m_ctrlRibbonProgressNormalExt.Draw(pDC, rectChunk);
			}

			pDC->SelectClipRgn(NULL);
		}
	}
	else if (pProgress->GetPos() != pProgress->GetRangeMin())
	{
		int index = (pProgress->GetPos() - pProgress->GetRangeMin()) % m_ctrlRibbonProgressInfinity.GetImageCount();

		m_ctrlRibbonProgressInfinity.Draw(pDC, rectInternal, index);
	}
}

void CMFCVisualManagerOffice2007::OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillRibbonQuickAccessToolBarPopup(pDC, pMenuBar, rect);
		return;
	}

	ASSERT_VALID(pDC);

	if (m_ctrlRibbonBorder_QAT.IsValid())
	{
		m_ctrlRibbonBorder_QAT.FillInterior(pDC, rect);
	}
	else
	{
		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight, TRUE);
	}
}

int CMFCVisualManagerOffice2007::GetRibbonPopupBorderSize(const CMFCRibbonPanelMenu* pPopup) const
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetRibbonPopupBorderSize(pPopup);
	}

	if (pPopup != NULL)
	{
		ASSERT_VALID(pPopup);

		CMFCRibbonPanelMenuBar* pRibbonMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, (const_cast<CMFCRibbonPanelMenu*>(pPopup))->GetMenuBar());

		if (pRibbonMenuBar != NULL)
		{
			if (pRibbonMenuBar->IsMainPanel())
			{
				return(int)GetPopupMenuBorderSize();
			}

			if (!pRibbonMenuBar->IsMenuMode())
			{
				if (pRibbonMenuBar->IsQATPopup())
				{
					if (m_ctrlRibbonBorder_QAT.IsValid())
					{
						return m_ctrlRibbonBorder_QAT.GetParams().m_rectSides.left;
					}
				}
				else if (pRibbonMenuBar->IsCategoryPopup())
				{
					return 0;
				}
				else if (pRibbonMenuBar->IsRibbonMiniToolBar())
				{
					if (m_ctrlRibbonBorder_Floaty.IsValid())
					{
						return m_ctrlRibbonBorder_Floaty.GetParams().m_rectSides.left;
					}
				}
				else
				{
					if (pRibbonMenuBar->GetPanel() != NULL)
					{
						if (!IsBeta1())
						{
							return 0;
						}
					}

					// standard size
				}
			}
		}
	}

	return(int)GetPopupMenuBorderSize();
}

void CMFCVisualManagerOffice2007::OnDrawRibbonKeyTip(CDC* pDC, CMFCRibbonBaseElement* pElement, CRect rect, CString str)
{
	if (!CanDrawImage() ||
		!m_ctrlRibbonKeyTip.IsValid())
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonKeyTip(pDC, pElement, rect, str);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pElement);

	BOOL bDisabled = pElement->IsDisabled();

	m_ctrlRibbonKeyTip.Draw(pDC, rect, 0);

	str.MakeUpper();

	COLORREF clrTextOld = pDC->SetTextColor(bDisabled ? m_clrRibbonKeyTipTextDisabled : m_clrRibbonKeyTipTextNormal);

	pDC->DrawText(str, rect, DT_SINGLELINE | DT_VCENTER | DT_CENTER);
	pDC->SetTextColor(clrTextOld);
}

void CMFCVisualManagerOffice2007::OnDrawRibbonCheckBoxOnList(CDC* pDC, CMFCRibbonCheckBox* pCheckBox, CRect rect, BOOL bIsSelected, BOOL bHighlighted)
{
	ASSERT_VALID(pDC);

	CMFCToolBarImages& img = m_MenuItemMarkerC;

	if (!CanDrawImage() || img.GetCount() == 0)
	{
		CMFCVisualManagerOffice2003::OnDrawRibbonCheckBoxOnList(pDC, pCheckBox, rect, bIsSelected, bHighlighted);
		return;
	}

	if (afxGlobalData.GetRibbonImageScale() != 1)
	{
		rect.DeflateRect(5, 5);
		img.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertStretch);
	}
	else
	{
		img.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
	}
}

COLORREF CMFCVisualManagerOffice2007::GetRibbonHyperlinkTextColor(CMFCRibbonLinkCtrl* pHyperLink)
{
	ASSERT_VALID(pHyperLink);

	if (!CanDrawImage() || pHyperLink->IsDisabled())
	{
		return CMFCVisualManagerOffice2003::GetRibbonHyperlinkTextColor(pHyperLink);
	}

	COLORREF clrText = pHyperLink->IsHighlighted() ? m_clrRibbonHyperlinkActive : m_clrRibbonHyperlinkInactive;

	if (m_clrRibbonStatusbarHyperlinkActive != (COLORREF)-1 && m_clrRibbonStatusbarHyperlinkInactive != (COLORREF)-1)
	{
		CMFCRibbonStatusBar* pParentStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pHyperLink->GetParentRibbonBar());

		if (pParentStatusBar != NULL)
		{
			ASSERT_VALID(pParentStatusBar);

			if (!pParentStatusBar->IsExtendedElement(pHyperLink))
			{
				clrText = pHyperLink->IsHighlighted() ? m_clrRibbonStatusbarHyperlinkActive : m_clrRibbonStatusbarHyperlinkInactive;
			}
		}
	}

	if (clrText == (COLORREF)-1)
	{
		return CMFCVisualManagerOffice2003::GetRibbonHyperlinkTextColor(pHyperLink);
	}

	return clrText;
}

COLORREF CMFCVisualManagerOffice2007::GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* pEdit, BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetRibbonEditBackgroundColor(pEdit, bIsHighlighted, bIsPaneHighlighted, bIsDisabled);
	}

	COLORREF color = m_clrRibbonEdit;

	if (bIsDisabled)
	{
		color = m_clrRibbonEditDisabled;
	}
	else
	{
		if (bIsHighlighted)
		{
			color = m_clrRibbonEditHighlighted;
		}
	}

	return color;
}

COLORREF CMFCVisualManagerOffice2007::GetRibbonStatusBarTextColor(CMFCRibbonStatusBar* pStatusBar)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerOffice2003::GetRibbonStatusBarTextColor(pStatusBar);
	}

	return m_clrStatusBarText;
}

CSize CMFCVisualManagerOffice2007::GetSystemBorders(BOOL bRibbonPresent) const
{
	CSize size(::GetSystemMetrics(SM_CYSIZEFRAME), ::GetSystemMetrics(SM_CXSIZEFRAME));

	if (bRibbonPresent)
	{
		size.cx--;
		size.cy--;
	}

	return size;
}

BOOL CMFCVisualManagerOffice2007::OnEraseMDIClientArea(CDC* pDC, CRect rectClient)
{
	if (!CanDrawImage() || m_brMainClientArea.GetSafeHandle() == NULL)
	{
		return CMFCVisualManagerOffice2003::OnEraseMDIClientArea(pDC, rectClient);
	}

	pDC->FillRect(rectClient, &m_brMainClientArea);
	return TRUE;
}

BOOL CMFCVisualManagerOffice2007::GetToolTipInfo(CMFCToolTipInfo& params, UINT /*nType*/ /*= (UINT)(-1)*/)
{
	if (!CanDrawImage() || !m_bToolTipParams)
	{
		return CMFCVisualManagerOffice2003::GetToolTipInfo(params);
	}

	params = m_ToolTipParams;
	return TRUE;
}

void CMFCVisualManagerOffice2007::OnFillPopupWindowBackground(CDC* pDC, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerOffice2003::OnFillPopupWindowBackground(pDC, rect);
		return;
	}

	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, m_clrPopupGradientDark, m_clrPopupGradientLight);
}

COLORREF CMFCVisualManagerOffice2007::OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd)
{
	COLORREF clrText = CMFCVisualManagerOffice2003::OnDrawPopupWindowCaption(pDC, rectCaption, pPopupWnd);

	if (CanDrawImage())
	{
		clrText = m_clrOutlookCaptionTextNormal;
	}

	return clrText;
}

COLORREF CMFCVisualManagerOffice2007::OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* pParent, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected)
{
	if (!CanDrawImage() || !m_ctrlRibbonBtn[0].IsValid())
	{
		return CMFCVisualManagerOffice2003::OnDrawPropertySheetListItem(pDC, pParent, rect, bIsHighlihted, bIsSelected);
	}

	rect.DeflateRect(2, 1);

	int nIndex = 0;

	if (bIsSelected)
	{
		nIndex = bIsHighlihted ? 1 : 2;
	}

	m_ctrlRibbonBtn [0].Draw(pDC, rect, nIndex);
	return m_clrToolBarBtnTextHighlighted;
}

COLORREF CMFCVisualManagerOffice2007::OnDrawMenuLabel(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, m_brGroupBackground.GetSafeHandle() != NULL ? &m_brGroupBackground : &m_brBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.top = rectSeparator.bottom - 2;

	DrawSeparator(pDC, rectSeparator, TRUE);

	return m_clrGroupText != (COLORREF)-1 ? m_clrGroupText : m_clrMenuText;
}

COLORREF CMFCVisualManagerOffice2007::OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
	BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton)
{
	COLORREF clrText = CMFCVisualManagerOffice2003::OnFillCaptionBarButton(pDC, pBar, rect, bIsPressed, bIsHighlighted, bIsDisabled, bHasDropDownArrow, bIsSysButton);

	ASSERT_VALID(pBar);

	if (CanDrawImage() && pBar->IsMessageBarMode() && bIsSysButton && !bIsHighlighted)
	{
		clrText = m_clrMenuBarBtnText;
	}

	return clrText;
}

AFX_SMARTDOCK_THEME CMFCVisualManagerOffice2007::GetSmartDockingTheme()
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || !afxGlobalData.IsWindowsLayerSupportAvailable() || !afxGlobalData.bIsWindowsVista)
	{
		return CMFCVisualManagerOffice2003::GetSmartDockingTheme();
	}

	return AFX_SDT_VS2008;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanagervs2005.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxdrawmanager.h"
#include "afxcaptionbutton.h"
#include "afxtabctrl.h"
#include "afxvisualmanagervs2005.h"
#include "afxautohidebutton.h"
#include "afxtoolbar.h"
#include "afxtoolbarmenubutton.h"
#include "afxstatusbar.h"
#include "afxdockingmanager.h"
#include "afxtabbedpane.h"
#include "afxpropertygridctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CMFCVisualManagerVS2005::m_bRoundedAutohideButtons = FALSE;

IMPLEMENT_DYNCREATE(CMFCVisualManagerVS2005, CMFCVisualManagerOffice2003)

// Construction/Destruction
CMFCVisualManagerVS2005::CMFCVisualManagerVS2005()
{
	m_bAlwaysFillTab = TRUE;
	m_b3DTabWideBorder = FALSE;
	m_bShdowDroppedDownMenuButton = TRUE;
	m_bDrawLastTabLine = FALSE;
	m_colorActiveTabBorder = (COLORREF)-1;
	m_bFrameMenuCheckedItems = TRUE;

	CDockingManager::EnableDockSiteMenu();
	CDockingManager::SetDockingMode(DT_SMART);
	CMFCAutoHideButton::m_bOverlappingTabs = FALSE;
}

CMFCVisualManagerVS2005::~CMFCVisualManagerVS2005()
{
}

void CMFCVisualManagerVS2005::OnUpdateSystemColors()
{
	BOOL bDefaultWinXPColors = m_bDefaultWinXPColors;
	m_clrPressedButtonBorder = (COLORREF)-1;
	m_CurrAppTheme = GetStandardWindowsTheme();

	if (m_CurrAppTheme != WinXpTheme_Silver)
	{
		m_bDefaultWinXPColors = FALSE;
	}

	CMFCVisualManagerOffice2003::OnUpdateSystemColors();

	if (!bDefaultWinXPColors)
	{
		return;
	}

	COLORREF clrMenuButtonDroppedDown = m_clrBarBkgnd;
	COLORREF clrMenuItemCheckedHighlight = m_clrHighlightDn;

	if (m_hThemeComboBox == NULL || m_pfGetThemeColor == NULL || (*m_pfGetThemeColor)(m_hThemeComboBox, 5, 0, 3801, &m_colorActiveTabBorder) != S_OK)
	{
		m_colorActiveTabBorder = (COLORREF)-1;
	}

	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		m_clrCustomizeButtonGradientLight = CDrawingManager::SmartMixColors(m_clrCustomizeButtonGradientDark, afxGlobalData.clrBarFace, 1.5, 1, 1);

		if (m_CurrAppTheme == WinXpTheme_Blue || m_CurrAppTheme == WinXpTheme_Olive)
		{
			m_clrToolBarGradientDark = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 83);

			m_clrToolBarGradientLight = CDrawingManager::SmartMixColors(GetBaseThemeColor(), GetThemeColor(m_hThemeWindow, COLOR_WINDOW), 1., 3, 2);
		}

		if (m_CurrAppTheme == WinXpTheme_Blue)
		{
			m_clrCustomizeButtonGradientDark = CDrawingManager::PixelAlpha(m_clrCustomizeButtonGradientDark, 90);
			m_clrCustomizeButtonGradientLight = CDrawingManager::PixelAlpha(m_clrCustomizeButtonGradientLight, 115);

			m_clrToolBarBottomLine = CDrawingManager::PixelAlpha(m_clrToolBarBottomLine, 85);
		}
		else if (m_CurrAppTheme == WinXpTheme_Olive)
		{
			m_clrToolBarBottomLine = CDrawingManager::PixelAlpha(m_clrToolBarBottomLine, 110);

			m_clrCustomizeButtonGradientDark = m_clrToolBarBottomLine;

			m_clrCustomizeButtonGradientLight = CDrawingManager::PixelAlpha(m_clrCustomizeButtonGradientLight, 120);

			m_clrHighlightDn = afxGlobalData.clrHilite;

			m_clrHighlight = CDrawingManager::PixelAlpha(m_clrHighlightDn, 124);
			m_clrHighlightChecked = CDrawingManager::PixelAlpha(GetThemeColor(m_hThemeWindow, 27 /*COLOR_GRADIENTACTIVECAPTION*/), 98);

			m_brHighlight.DeleteObject();
			m_brHighlightDn.DeleteObject();

			m_brHighlight.CreateSolidBrush(m_clrHighlight);
			m_brHighlightDn.CreateSolidBrush(m_clrHighlightDn);

			m_brHighlightChecked.DeleteObject();
			m_brHighlightChecked.CreateSolidBrush(m_clrHighlightChecked);
		}
		else if (m_CurrAppTheme != WinXpTheme_Silver)
		{
			m_clrToolBarBottomLine = m_clrToolBarGradientDark;
		}

		clrMenuButtonDroppedDown = CDrawingManager::PixelAlpha(m_clrBarBkgnd, 107);

		clrMenuItemCheckedHighlight = GetThemeColor(m_hThemeWindow, COLOR_HIGHLIGHT);

		if (m_CurrAppTheme == WinXpTheme_Blue || m_CurrAppTheme == WinXpTheme_Olive)
		{
			m_clrBarGradientLight = CDrawingManager::PixelAlpha(m_clrToolBarGradientLight, 95);
			m_clrBarGradientDark = CDrawingManager::PixelAlpha(m_clrBarGradientDark, 97);
		}

		m_clrToolbarDisabled = CDrawingManager::SmartMixColors(m_clrToolBarGradientDark, m_clrToolBarGradientLight, .92, 1, 2);
		m_clrPressedButtonBorder = CDrawingManager::SmartMixColors(m_clrMenuItemBorder, afxGlobalData.clrBarDkShadow, .8, 1, 2);
	}

	m_brMenuButtonDroppedDown.DeleteObject();
	m_brMenuButtonDroppedDown.CreateSolidBrush(clrMenuButtonDroppedDown);

	m_brMenuItemCheckedHighlight.DeleteObject();
	m_brMenuItemCheckedHighlight.CreateSolidBrush(clrMenuItemCheckedHighlight);

	m_penActiveTabBorder.DeleteObject();

	if (m_colorActiveTabBorder != (COLORREF)-1)
	{
		m_penActiveTabBorder.CreatePen(PS_SOLID, 1, m_colorActiveTabBorder);
	}

	m_bDefaultWinXPColors = bDefaultWinXPColors;

	m_clrInactiveTabText = afxGlobalData.clrBtnDkShadow;

	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		m_penSeparator.DeleteObject();

		COLORREF clrSeparator = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, 84);

		m_penSeparator.CreatePen(PS_SOLID, 1, clrSeparator);
	}
}

COLORREF CMFCVisualManagerVS2005::OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerOfficeXP::OnDrawPaneCaption(pDC, pBar, bActive, rectCaption, rectButtons);
	}

	rectCaption.bottom++;

	COLORREF clrFill;

	if (!bActive)
	{
		clrFill = CDrawingManager::PixelAlpha(m_clrBarGradientDark, 87);

		CBrush brFill(clrFill);
		pDC->FillRect(rectCaption, &brFill);

		pDC->Draw3dRect(rectCaption, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
	}
	else
	{
		if (m_CurrAppTheme == WinXpTheme_Blue || m_CurrAppTheme == WinXpTheme_Olive || m_CurrAppTheme == WinXpTheme_Silver)
		{
			COLORREF clrLight = CDrawingManager::PixelAlpha(afxGlobalData.clrHilite, 130);

			CDrawingManager dm(*pDC);
			dm.FillGradient(rectCaption, afxGlobalData.clrHilite, clrLight, TRUE);

			return afxGlobalData.clrTextHilite;
		}
		else
		{
			pDC->FillRect(rectCaption, &afxGlobalData.brActiveCaption);
			return afxGlobalData.clrCaptionText;
		}
	}

	if (GetRValue(clrFill) <= 192 && GetGValue(clrFill) <= 192 && GetBValue(clrFill) <= 192)
	{
		return RGB(255, 255, 255);
	}
	else
	{
		return RGB(0, 0, 0);
	}
}

void CMFCVisualManagerVS2005::OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID /*= -1*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (bActive || pButton->IsMiniFrameButton())
	{
		CMFCVisualManagerOfficeXP::OnDrawCaptionButton(pDC, pButton, bActive, bHorz, bMaximized, bDisabled, nImageID);
		return;
	}

	CRect rc = pButton->GetRect();

	const BOOL bHighlight = (pButton->m_bPushed || pButton->m_bFocused || pButton->m_bDroppedDown) && !bDisabled;

	if (bHighlight)
	{
		pDC->FillRect(rc, &afxGlobalData.brBarFace);
	}

	CMenuImages::IMAGES_IDS id = (CMenuImages::IMAGES_IDS)-1;

	if (nImageID != -1)
	{
		id = (CMenuImages::IMAGES_IDS)nImageID;
	}
	else
	{
		id = pButton->GetIconID(bHorz, bMaximized);
	}

	if (id != (CMenuImages::IMAGES_IDS)-1)
	{
		CSize sizeImage = CMenuImages::Size();
		CPoint ptImage(rc.left +(rc.Width() - sizeImage.cx) / 2, rc.top +(rc.Height() - sizeImage.cy) / 2);

		OnDrawCaptionButtonIcon(pDC, pButton, id, bActive, bDisabled, ptImage);
	}

	if (bHighlight)
	{
		pDC->Draw3dRect(rc, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
	}
}

void CMFCVisualManagerVS2005::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsFlatTab() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOfficeXP::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style())
	{
		if (pTabWnd->IsDialogControl())
		{
			pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		}
		else
		{
			pDC->FillRect(rect, &afxGlobalData.brBarFace);
		}
	}
	else
	{
		CBasePane* pParentBar = DYNAMIC_DOWNCAST(CBasePane, pTabWnd->GetParent());
		if (pParentBar == NULL)
		{
			pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		}
		else
		{
			CRect rectScreen = afxGlobalData.m_rectVirtual;
			pTabWnd->ScreenToClient(&rectScreen);

			CRect rectFill = rect;
			rectFill.left = min(rectFill.left, rectScreen.left);

			OnFillBarBackground(pDC, pParentBar, rectFill, rect);
		}
	}
}

void CMFCVisualManagerVS2005::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style())
	{
		CPen* pOldPen = NULL;

		if (bIsActive && pTabWnd->IsVS2005Style() && m_penActiveTabBorder.GetSafeHandle() != NULL)
		{
			pOldPen = pDC->SelectObject(&m_penActiveTabBorder);
		}

		CMFCVisualManagerOffice2003::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);

		if (pOldPen != NULL)
		{
			pDC->SelectObject(pOldPen);
		}

		return;
	}

	COLORREF clrTab = pTabWnd->GetTabBkColor(iTab);
	COLORREF clrTextOld = (COLORREF)-1;

	if (bIsActive && clrTab == (COLORREF)-1)
	{
		clrTextOld = pDC->SetTextColor(afxGlobalData.clrWindowText);
		((CMFCBaseTabCtrl*)pTabWnd)->SetTabBkColor(iTab, afxGlobalData.clrWindow);
	}

	CMFCVisualManagerOfficeXP::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);

	((CMFCBaseTabCtrl*)pTabWnd)->SetTabBkColor(iTab, clrTab);

	if (clrTextOld != (COLORREF)-1)
	{
		pDC->SetTextColor(clrTextOld);
	}
}

int CMFCVisualManagerVS2005::CreateAutoHideButtonRegion(CRect rect, DWORD dwAlignment, LPPOINT& points)
{
	switch(dwAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_LEFT:
		rect.right--;
		break;

	case CBRS_ALIGN_TOP:
		rect.bottom--;
		break;
	}

	CRect rectOrign = rect;
	DWORD dwAlignmentOrign = dwAlignment;

	if ((dwAlignment & CBRS_ALIGN_ANY) == CBRS_ALIGN_LEFT || (dwAlignment & CBRS_ALIGN_ANY) == CBRS_ALIGN_RIGHT)
	{
		rect = CRect(0, 0, rectOrign.Height(), rectOrign.Width());
		dwAlignment = (dwAlignment == CBRS_ALIGN_LEFT) ? CBRS_ALIGN_TOP : CBRS_ALIGN_BOTTOM;
	}

	CList<POINT, POINT> pts;

	if (!m_bRoundedAutohideButtons)
	{
		rect.right--;

		pts.AddHead(CPoint(rect.left, rect.top));
		pts.AddHead(CPoint(rect.left, rect.bottom - 2));
		pts.AddHead(CPoint(rect.left + 2, rect.bottom));
		pts.AddHead(CPoint(rect.right - 2, rect.bottom));
		pts.AddHead(CPoint(rect.right, rect.bottom - 2));
		pts.AddHead(CPoint(rect.right, rect.top));
	}
	else
	{
		POSITION posLeft = pts.AddHead(CPoint(rect.left, rect.top));
		posLeft = pts.InsertAfter(posLeft, CPoint(rect.left, rect.top + 2));

		POSITION posRight = pts.AddTail(CPoint(rect.right, rect.top));
		posRight = pts.InsertBefore(posRight, CPoint(rect.right, rect.top + 2));

		int xLeft = rect.left + 1;
		int xRight = rect.right - 1;

		int y = 0;

		BOOL bIsHorz = (dwAlignmentOrign & CBRS_ALIGN_ANY) == CBRS_ALIGN_LEFT || (dwAlignmentOrign & CBRS_ALIGN_ANY) == CBRS_ALIGN_RIGHT;

		for (y = rect.top + 2; y < rect.bottom - 4; y += 2)
		{
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y));
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y + 2));

			posRight = pts.InsertBefore(posRight, CPoint(xRight, y));
			posRight = pts.InsertBefore(posRight, CPoint(xRight, y + 2));

			xLeft++;
			xRight--;
		}

		if ((dwAlignmentOrign & CBRS_ALIGN_ANY) == CBRS_ALIGN_BOTTOM && !bIsHorz)
		{
			xLeft--;
			xRight++;
		}

		if (bIsHorz)
		{
			xRight++;
		}

		for (;y < rect.bottom - 1; y++)
		{
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft, y));
			posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 1, y + 1));

			posRight = pts.InsertBefore(posRight, CPoint(xRight, y));
			posRight = pts.InsertBefore(posRight, CPoint(xRight - 1, y + 1));

			if (y == rect.bottom - 2)
			{
				posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 1, y + 1));
				posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 3, y + 1));

				posRight = pts.InsertBefore(posRight, CPoint(xRight, y + 1));
				posRight = pts.InsertBefore(posRight, CPoint(xRight - 2, y + 1));
			}

			xLeft++;
			xRight--;
		}

		posLeft = pts.InsertAfter(posLeft, CPoint(xLeft + 2, rect.bottom));
		posRight = pts.InsertBefore(posRight, CPoint(xRight - 2, rect.bottom));
	}

	points = new POINT [pts.GetCount()];

	int i = 0;

	for (POSITION pos = pts.GetHeadPosition(); pos != NULL; i++)
	{
		points [i] = pts.GetNext(pos);

		switch(dwAlignmentOrign & CBRS_ALIGN_ANY)
		{
		case CBRS_ALIGN_BOTTOM:
			points [i].y = rect.bottom -(points [i].y - rect.top);
			break;

		case CBRS_ALIGN_RIGHT:
			{
				int x = rectOrign.right - points [i].y;
				int y = rectOrign.top + points [i].x;

				points [i] = CPoint(x, y);
			}
			break;

		case CBRS_ALIGN_LEFT:
			{
				int x = rectOrign.left + points [i].y;
				int y = rectOrign.top + points [i].x;

				points [i] = CPoint(x, y);
			}
			break;
		}
	}

	return(int) pts.GetCount();
}

void CMFCVisualManagerVS2005::OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (!m_bRoundedAutohideButtons)
	{
		return;
	}

	LPPOINT points;
	int nPoints = CreateAutoHideButtonRegion(rect, pButton->GetAlignment(), points);

	CRgn rgnClip;
	rgnClip.CreatePolygonRgn(points, nPoints, WINDING);

	pDC->SelectClipRgn(&rgnClip);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerOffice2003::OnFillAutoHideButtonBackground(pDC, rect, pButton);
	}
	else
	{
		BOOL bIsHorz = ((pButton->GetAlignment() & CBRS_ALIGN_ANY) == CBRS_ALIGN_LEFT || (pButton->GetAlignment() & CBRS_ALIGN_ANY) == CBRS_ALIGN_RIGHT);

		CDrawingManager dm(*pDC);

		dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight, !bIsHorz);
	}

	pDC->SelectClipRgn(NULL);
	delete [] points;
}

void CMFCVisualManagerVS2005::OnDrawAutoHideButtonBorder(CDC* pDC, CRect rect, CRect /*rectBorderSize*/, CMFCAutoHideButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);

	CPen* pOldPen = pDC->SelectObject(&pen);
	ENSURE(pOldPen != NULL);

	LPPOINT points;
	int nPoints = CreateAutoHideButtonRegion(rect, pButton->GetAlignment(), points);

	if (!m_bRoundedAutohideButtons)
	{
		pDC->Polyline(points, nPoints);
	}
	else
	{
		BOOL bIsHorz ((pButton->GetAlignment() & CBRS_ALIGN_ANY) == CBRS_ALIGN_LEFT || (pButton->GetAlignment() & CBRS_ALIGN_ANY) == CBRS_ALIGN_RIGHT);

		for (int i = 0; i < nPoints; i++)
		{
			if ((i % 2) != 0)
			{
				int x1 = points [i - 1].x;
				int y1 = points [i - 1].y;

				int x2 = points [i].x;
				int y2 = points [i].y;

				if (bIsHorz)
				{
					if (y1 > rect.CenterPoint().y && y2 > rect.CenterPoint().y)
					{
						y1--;
						y2--;
					}
				}
				else
				{
					if (x1 > rect.CenterPoint().x && x2 > rect.CenterPoint().x)
					{
						x1--;
						x2--;
					}
				}

				if (y2 >= y1)
				{
					pDC->MoveTo(x1, y1);
					pDC->LineTo(x2, y2);
				}
				else
				{
					pDC->MoveTo(x2, y2);
					pDC->LineTo(x1, y1);
				}
			}
		}
	}

	pDC->SelectObject(pOldPen);
	delete [] points;
}

void CMFCVisualManagerVS2005::GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
	COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack)
{
	ASSERT_VALID(pTabWnd);

	CMFCVisualManagerOffice2003::GetTabFrameColors(pTabWnd, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);

	if (pTabWnd->IsVS2005Style() && m_colorActiveTabBorder != (COLORREF)-1)
	{
		clrHighlight = m_colorActiveTabBorder;
	}

	clrBlack = clrDarkShadow;
}

void CMFCVisualManagerVS2005::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, pBar);
	if (pToolBar != NULL)
	{
		ASSERT_VALID(pToolBar);

		if (bHorz)
		{
			const int nDelta = max(0, (pToolBar->GetButtonSize().cy - pToolBar->GetImageSize().cy) / 2);
			rect.top += nDelta;
		}
		else
		{
			const int nDelta = max(0, (pToolBar->GetButtonSize().cx - pToolBar->GetImageSize().cx) / 2);
			rect.left += nDelta;
		}
	}

	CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
}

void CMFCVisualManagerVS2005::OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton)
{
	if (pButton != NULL && (m_CurrAppTheme == WinXpTheme_Blue || m_CurrAppTheme == WinXpTheme_Olive))
	{
		ASSERT_VALID(pButton);

		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

		BOOL bIsPopupMenu = pMenuButton != NULL && pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

		if (bIsPopupMenu && (pButton->m_nStyle & TBBS_CHECKED) && pBrush == &m_brHighlightDn)
		{
			pDC->FillRect(rect, &m_brMenuItemCheckedHighlight);
			return;
		}

		if (pMenuButton != NULL && !bIsPopupMenu && pMenuButton->IsDroppedDown())
		{
			pDC->FillRect(rect, &m_brMenuButtonDroppedDown);
			return;
		}
	}

	CMFCVisualManagerOffice2003::OnFillHighlightedArea(pDC, rect, pBrush, pButton);
}

int CMFCVisualManagerVS2005::GetDockingTabsBordersSize()
{
	return CTabbedPane::m_StyleTabWnd == CMFCTabCtrl::STYLE_3D_ROUNDED ? 0 : 3;
}

COLORREF CMFCVisualManagerVS2005::GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList)
{
	ASSERT_VALID(pPropList);

	if (m_bDefaultWinXPColors)
	{
		return CMFCVisualManagerOffice2003::GetPropertyGridGroupColor(pPropList);
	}

	return pPropList->DrawControlBarColors() ? afxGlobalData.clrBarLight : afxGlobalData.clrBtnLight;
}

COLORREF CMFCVisualManagerVS2005::OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	if (DYNAMIC_DOWNCAST(CMFCBaseToolBar, pFrameWnd->GetPane()) == NULL)
	{
		return CMFCVisualManagerOffice2003::OnFillMiniFrameCaption(pDC, rectCaption, pFrameWnd, bActive);
	}

	::FillRect(pDC->GetSafeHdc(), rectCaption, ::GetSysColorBrush(COLOR_3DSHADOW));
	return afxGlobalData.clrCaptionText;
}

void CMFCVisualManagerVS2005::OnDrawToolBoxFrame(CDC* pDC, const CRect& rect)
{
	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanagervs2008.cpp ===
,// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright(C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxvisualmanagervs2008.h"
#include "afxtoolbarmenubutton.h"
#include "afxdrawmanager.h"
#include "afxtabctrl.h"
#include "afxautohidebutton.h"
#include "afxcolorbar.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define WINXPBLUE_GRADIENT_LIGHT	RGB(239, 243, 250)
#define WINXPBLUE_GRADIENT_DARK		RGB(193, 210, 238)
#define WINXPBLUE_MENUITEM_BORDER	RGB(152, 181, 226)
#define WINXPBLUE_MENU_GUTTER		RGB(241, 241, 241)
#define WINXPBLUE_MENU_GUTTER_DARK	RGB(225, 225, 225)

IMPLEMENT_DYNCREATE(CMFCVisualManagerVS2008, CMFCVisualManagerVS2005)

// Construction/Destruction
CMFCVisualManagerVS2008::CMFCVisualManagerVS2008()
{
	m_bConnectMenuToParent = FALSE;
	m_bShdowDroppedDownMenuButton = FALSE;
	m_bOSColors = FALSE;

	OnUpdateSystemColors();
}

CMFCVisualManagerVS2008::~CMFCVisualManagerVS2008()
{
}

void CMFCVisualManagerVS2008::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea)
{
	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 ||
		afxGlobalData.IsHighContrastMode() ||
		!pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)) ||
		pBar->IsKindOf(RUNTIME_CLASS(CMFCColorBar)) ||
		GetStandardWindowsTheme() != WinXpTheme_Blue)
	{
		CMFCVisualManagerVS2005::OnFillBarBackground(pDC, pBar, rectClient, rectClip, bNCArea);
		return;
	}

	if (rectClip.IsRectEmpty())
	{
		rectClip = rectClient;
	}

	pDC->FillRect(rectClip, &m_brMenuLight);

	CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
	ASSERT_VALID(pMenuBar);

	if (!pMenuBar->m_bDisableSideBarInXPMode)
	{
		CRect rectImages = rectClient;

		rectImages.right = rectImages.left + pMenuBar->GetGutterWidth();
		rectImages.DeflateRect(0, 1);

		CBrush br(WINXPBLUE_MENU_GUTTER);
		pDC->FillRect(rectImages, &br);

		CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
		ASSERT(pOldPen != NULL);

		pDC->MoveTo(rectImages.right, rectImages.top);
		pDC->LineTo(rectImages.right, rectImages.bottom);

		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManagerVS2008::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() ||
		GetStandardWindowsTheme() != WinXpTheme_Blue)
	{
		CMFCVisualManagerVS2005::OnHighlightRarelyUsedMenuItems(pDC, rectRarelyUsed);
		return;
	}

	rectRarelyUsed.left--;
	rectRarelyUsed.right = rectRarelyUsed.left + CMFCToolBar::GetMenuImageSize().cx + 2 * GetMenuImageMargin() + 2;

	CBrush br(WINXPBLUE_MENU_GUTTER_DARK);
	pDC->FillRect(rectRarelyUsed, &br);
}

void CMFCVisualManagerVS2008::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

	BOOL bIsMenuBarButton = pMenuButton != NULL && pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));
	if (bIsMenuBarButton)
	{
		rect.bottom -= 2;
	}

	if (!bIsMenuBarButton || !pMenuButton->IsDroppedDown())
	{
		CMFCVisualManagerVS2005::OnDrawButtonBorder(pDC, pButton, rect, state);
		return;
	}

	pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
}

void CMFCVisualManagerVS2008::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CMFCToolBarMenuButton* pMenuButton = 
		DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);

	BOOL bIsMenuBarButton = pMenuButton != NULL &&
		pMenuButton->GetParentWnd() != NULL &&
		pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));

	if (bIsMenuBarButton)
	{
		rect.bottom -= 2;
	}

	if (!bIsMenuBarButton || !pMenuButton->IsDroppedDown())
	{
		CMFCVisualManagerVS2005::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	if (!m_bOSColors)
	{
		OnFillHighlightedArea(pDC, rect, &m_brBarBkgnd, pButton);
		return;
	}

	COLORREF clr1 = CDrawingManager::PixelAlpha(m_clrHighlight, 85);
	COLORREF clr2 = RGB(255, 255, 255);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clr1, clr2, TRUE);
}

void CMFCVisualManagerVS2008::OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		CMFCVisualManagerVS2005::OnHighlightMenuItem(pDC, pButton, rect, clrText);
		return;
	}

	const int nRoundSize = 3;
	const BOOL bIsWinXPBlue = (GetStandardWindowsTheme() == WinXpTheme_Blue);

	COLORREF clr1 = bIsWinXPBlue ? WINXPBLUE_GRADIENT_DARK : m_clrHighlightGradientDark;
	COLORREF clr2 = bIsWinXPBlue ? WINXPBLUE_GRADIENT_LIGHT : m_clrHighlightGradientLight;
	COLORREF clrBorder = bIsWinXPBlue ? WINXPBLUE_MENUITEM_BORDER : m_clrHighlightGradientDark;

	if (m_bOSColors)
	{
		clr1 = m_clrHighlight;
		clr2 = RGB(255, 255, 255);
		clrBorder = m_clrHighlightDn;
	}

	rect.DeflateRect(2, 0);

	CRgn rgn;
	rgn.CreateRoundRectRgn(rect.left, rect.top, rect.right, rect.bottom, nRoundSize, nRoundSize);

	pDC->SelectClipRgn(&rgn);

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, clr1, clr2, TRUE);

	pDC->SelectClipRgn(NULL);

	CPen pen(PS_SOLID, 1, clrBorder);
	CPen* pOldPen = pDC->SelectObject(&pen);
	CBrush* pOldBrush = (CBrush*) pDC->SelectStockObject(NULL_BRUSH);

	pDC->RoundRect(rect.left, rect.top, rect.right, rect.bottom, nRoundSize + 2, nRoundSize + 2);

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldBrush);

	clrText = GetHighlightedMenuItemTextColor(pButton);
}

void CMFCVisualManagerVS2008::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() ||
		!pTabWnd->IsVS2005Style() ||
		pTabWnd->IsDialogControl())
	{
		CMFCVisualManagerVS2005::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	CFrameWnd* pMainFrame = AFXGetTopLevelFrame(pTabWnd);
	if (pMainFrame->GetSafeHwnd() != NULL)
	{
		CRect rectMain;
		pMainFrame->GetClientRect(rectMain);
		pMainFrame->MapWindowPoints((CMFCTabCtrl*)pTabWnd, &rectMain);

		rect.top = rectMain.top;
		rect.left = rectMain.left;
		rect.right = rect.left + afxGlobalData.m_rectVirtual.Width() + 10;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight, FALSE, 0);
}

void CMFCVisualManagerVS2008::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pWndTab);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() ||
		!pWndTab->IsVS2005Style() ||
		pWndTab->IsDialogControl() ||
		pButton->IsPressed() || pButton->IsHighlighted())
	{
		CMFCVisualManagerVS2005::OnEraseTabsButton(pDC, rect, pButton, pWndTab);
		return;
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rect);

	pDC->SelectClipRgn(&rgn);

	CFrameWnd* pMainFrame = AFXGetTopLevelFrame(pButton);
	if (pMainFrame->GetSafeHwnd() != NULL)
	{
		CRect rectMain;
		pMainFrame->GetClientRect(rectMain);
		pMainFrame->MapWindowPoints(pButton, &rectMain);

		rect.top = rectMain.top;
		rect.left = rectMain.left;
		rect.right = rect.left + afxGlobalData.m_rectVirtual.Width() + 10;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight, FALSE, 0);

	pDC->SelectClipRgn(NULL);
}

BOOL CMFCVisualManagerVS2008::OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (!pTabWnd->IsVS2005Style() || afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerVS2005::OnEraseTabsFrame(pDC, rect, pTabWnd);
	}

	COLORREF clrActiveTab = pTabWnd->GetTabBkColor(pTabWnd->GetActiveTab());
	if (clrActiveTab == (COLORREF)-1)
	{
		clrActiveTab = m_clrHighlight;
	}

	CBrush brFill(clrActiveTab);
	pDC->FillRect(rect, &brFill);

	return TRUE;
}

void CMFCVisualManagerVS2008::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	const COLORREF clrTab = pTabWnd->GetTabBkColor(iTab);
	const BOOL bIsHighlight = (iTab == pTabWnd->GetHighlightedTab());

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() ||
		pTabWnd->IsDialogControl() ||
		pTabWnd->IsFlatTab() || 
		clrTab != (COLORREF)-1)
	{
		CMFCVisualManagerVS2005::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	if ((bIsActive || bIsHighlight || m_bOSColors) && pTabWnd->IsVS2005Style())
	{
		((CMFCBaseTabCtrl*)pTabWnd)->SetTabBkColor(iTab, 
			bIsActive ? m_clrHighlight : 
			bIsHighlight ? m_clrHighlightDnGradientDark : GetThemeColor(m_hThemeButton, 2));

		CMFCVisualManagerVS2005::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);

		((CMFCBaseTabCtrl*)pTabWnd)->SetTabBkColor(iTab, clrTab);
		return;
	}

	if (m_hThemeTab == NULL ||
		pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style() ||
		pTabWnd->IsLeftRightRounded())
	{
		CRect rectClip = rectTab;
		rectClip.bottom -= 2;

		CRgn rgn;
		rgn.CreateRectRgnIndirect(&rectClip);

		pDC->SelectClipRgn(&rgn);

		CMFCVisualManagerVS2005::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		
		pDC->SelectClipRgn(NULL);
		return;
	}

	int nState = TIS_NORMAL;
	if (bIsActive)
	{
		nState = TIS_SELECTED;
	}
	else if (iTab == pTabWnd->GetHighlightedTab())
	{
		nState = TIS_HOT;
	}

	rectTab.right += 2;

	if (!bIsActive)
	{
		rectTab.bottom--;
	}

	if (rectTab.Width() > 25)	// DrawThemeBackground will draw < 25 width tab bad
	{
		(*m_pfDrawThemeBackground)(m_hThemeTab, pDC->GetSafeHdc(), TABP_TABITEM, nState, &rectTab, 0);

		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
		{
			CDrawingManager dm(*pDC);
			dm.MirrorRect(rectTab, FALSE);
		}
	}

	COLORREF clrTabText = afxGlobalData.clrWindowText;

	if (!bIsActive)
	{
		clrTabText = afxGlobalData.clrBtnDkShadow;
	}
	else if (m_pfGetThemeColor != NULL)
	{
		(*m_pfGetThemeColor)(m_hThemeTab, TABP_TABITEM, nState, TMT_TEXTCOLOR, &clrTabText);
	}

	COLORREF cltTextOld = pDC->SetTextColor(clrTabText);

	rectTab.right -= 2;

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd,(COLORREF)-1);

	pDC->SetTextColor(cltTextOld);
}

void CMFCVisualManagerVS2008::OnDrawAutoHideButtonBorder(CDC* pDC, CRect rect, CRect rectBorderSize, CMFCAutoHideButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || m_hThemeTab == NULL)
	{
		CMFCVisualManagerVS2005::OnDrawAutoHideButtonBorder(pDC, rect, rectBorderSize, pButton);
		return;
	}

	const int nState = pButton->IsHighlighted() ? TIS_HOT : TIS_NORMAL;
	const DWORD dwAlign = (pButton->GetAlignment()) & CBRS_ALIGN_ANY;

	CDrawingManager dm(*pDC);

	switch(dwAlign)
	{
	case CBRS_ALIGN_LEFT:
	case CBRS_ALIGN_RIGHT:
		{
			CRect rectTab(0, 0, rect.Height(), rect.Width());

			CDC dcMem;
			dcMem.CreateCompatibleDC(pDC);

			CBitmap bmpMem;
			bmpMem.CreateCompatibleBitmap(pDC, rectTab.Width(), rectTab.Height());

			CBitmap* pBmpOld = (CBitmap*) dcMem.SelectObject(&bmpMem);

			(*m_pfDrawThemeBackground)(m_hThemeTab, dcMem.GetSafeHdc(), TABP_TABITEM, nState, &rectTab, 0);

			dm.DrawRotated(rect, dcMem, dwAlign == CBRS_ALIGN_LEFT);
			dcMem.SelectObject(pBmpOld);
		}
		break;

	case CBRS_ALIGN_TOP:
	case CBRS_ALIGN_BOTTOM:
		(*m_pfDrawThemeBackground)(m_hThemeTab, pDC->GetSafeHdc(), TABP_TABITEM, nState, &rect, 0);

		if (dwAlign == CBRS_ALIGN_TOP)
		{
			dm.MirrorRect(rect, FALSE);
			break;
		}
	}
}

COLORREF CMFCVisualManagerVS2008::OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons)
{
	ASSERT_VALID(pDC);

	if (!m_bOSColors)
	{
		return CMFCVisualManagerVS2005::OnDrawPaneCaption(pDC, pBar, bActive, rectCaption, rectButtons);
	}

	rectCaption.bottom++;

	CDrawingManager dm(*pDC);
	dm.FillGradient(rectCaption, 
		bActive ? afxGlobalData.clrActiveCaptionGradient : afxGlobalData.clrInactiveCaptionGradient, 
		bActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption, 
		TRUE);

	return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
}

void CMFCVisualManagerVS2008::OnUpdateSystemColors()
{
	m_bOSColors = afxGlobalData.bIsWindowsVista &&
		m_hThemeExplorerBar != NULL &&
		afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode();

	CMFCVisualManagerVS2005::OnUpdateSystemColors();

	if (!m_bOSColors || m_pfGetThemeColor == NULL)
	{
		return;
	}

	(*m_pfGetThemeColor)(m_hThemeExplorerBar, 0, 0, TMT_EDGEHIGHLIGHTCOLOR, &m_clrToolBarGradientLight);
	(*m_pfGetThemeColor)(m_hThemeExplorerBar, 0, 0, TMT_GRADIENTCOLOR2, &m_clrToolBarGradientDark);

	m_clrBarGradientDark = CDrawingManager::SmartMixColors(m_clrToolBarGradientDark, m_clrToolBarGradientLight,
		1., 2, 1);

	m_clrBarGradientLight = m_clrToolBarGradientLight;

	m_clrToolBarGradientVertLight = m_clrToolBarGradientLight;

	m_clrToolBarGradientVertDark = CDrawingManager::PixelAlpha(
			m_clrToolBarGradientDark, 98);

	// Calculate highlight gradient colors:
	m_clrCustomizeButtonGradientLight = m_clrToolBarGradientDark;
	m_clrCustomizeButtonGradientDark = m_clrBarGradientDark;

	m_clrToolBarBottomLine = CDrawingManager::PixelAlpha(m_clrToolBarGradientDark, 85);
	m_colorToolBarCornerBottom = m_clrToolBarGradientDark;

	m_brTabBack.DeleteObject();
	m_brTabBack.CreateSolidBrush(m_clrToolBarGradientLight);

	m_brFace.DeleteObject();
	m_brFace.CreateSolidBrush(m_clrToolBarGradientLight);

	m_clrToolbarDisabled = CDrawingManager::SmartMixColors(
		m_clrToolBarGradientDark, m_clrToolBarGradientLight, .92);

	m_penBottomLine.DeleteObject();
	m_penBottomLine.CreatePen(PS_SOLID, 1, m_clrToolBarBottomLine);
}

COLORREF CMFCVisualManagerVS2008::OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected)
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode())
	{
		return CMFCVisualManagerVS2005::OnFillCommandsListBackground(pDC, rect, bIsSelected);
	}

	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	rect.left = 0;

	const BOOL bIsWinXPBlue = (GetStandardWindowsTheme() == WinXpTheme_Blue) || m_bOSColors;

	if (bIsSelected)
	{
		COLORREF clr1 = bIsWinXPBlue ? WINXPBLUE_GRADIENT_DARK : m_clrHighlightGradientDark;
		COLORREF clr2 = bIsWinXPBlue ? WINXPBLUE_GRADIENT_LIGHT : m_clrHighlightGradientLight;
		COLORREF clrBorder = bIsWinXPBlue ? WINXPBLUE_MENUITEM_BORDER : m_clrHighlightGradientDark;

		if (m_bOSColors)
		{
			clr1 = m_clrHighlight;
			clr2 = RGB(255, 255, 255);
			clrBorder = m_clrHighlightDn;
		}

		CDrawingManager dm(*pDC);
		dm.FillGradient(rect, clr1, clr2, TRUE);

		pDC->Draw3dRect(rect, clrBorder, clrBorder);

		CMFCToolBarMenuButton dummy;
		return GetHighlightedMenuItemTextColor(&dummy);
	}
	else
	{
		pDC->FillRect(rect, &m_brMenuLight);

		int iImageWidth = CMFCToolBar::GetMenuImageSize().cx + GetMenuImageMargin();

		CRect rectImages = rect;
		rectImages.right = rectImages.left + iImageWidth + AFX_MENU_IMAGE_MARGIN;

		if (bIsWinXPBlue)
		{
			CBrush br(WINXPBLUE_MENU_GUTTER);
			pDC->FillRect(rectImages, &br);

			CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
			ASSERT(pOldPen != NULL);

			pDC->MoveTo(rectImages.right, rectImages.top);
			pDC->LineTo(rectImages.right, rectImages.bottom);

			pDC->SelectObject(pOldPen);
		}
		else
		{
			CDrawingManager dm(*pDC);
			dm.FillGradient(rectImages, m_clrToolBarGradientLight, m_clrToolBarGradientDark, FALSE);
		}

		return afxGlobalData.clrBarText;
	}
}

void CMFCVisualManagerVS2008::GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
		COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack)
{
	ASSERT_VALID(pTabWnd);
	
	CMFCVisualManagerVS2005::GetTabFrameColors(pTabWnd,
			   clrDark, clrBlack,
			   clrHighlight, clrFace,
			   clrDarkShadow, clrLight,
			   pbrFace, pbrBlack);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pTabWnd->IsFlatTab())
	{
		return;
	}

	clrBlack = afxGlobalData.clrBarShadow;
}

void CMFCVisualManagerVS2008::OnDrawTabResizeBar(CDC* pDC, CMFCBaseTabCtrl* pWndTab, BOOL bIsVert, CRect rect, CBrush* pbrFace, CPen* pPen)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pbrFace);
	ASSERT_VALID(pPen);
	ASSERT_VALID(pWndTab);

	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || pWndTab->IsFlatTab())
	{
		CMFCVisualManagerVS2005::OnDrawTabResizeBar(pDC, pWndTab, bIsVert, rect, pbrFace, pPen);
		return;
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rect);

	pDC->SelectClipRgn(&rgn);

	CFrameWnd* pMainFrame = AFXGetTopLevelFrame(pWndTab);
	if (pMainFrame->GetSafeHwnd() != NULL)
	{
		CRect rectMain;
		pMainFrame->GetClientRect(rectMain);
		pMainFrame->MapWindowPoints(pWndTab, &rectMain);

		rect.top = rectMain.top;
		rect.left = rectMain.left;
		rect.right = rect.left + afxGlobalData.m_rectVirtual.Width() + 10;
	}

	CDrawingManager dm(*pDC);
	dm.FillGradient(rect, m_clrBarGradientDark, m_clrBarGradientLight, FALSE, 0);

	pDC->SelectClipRgn(NULL);
}

AFX_SMARTDOCK_THEME CMFCVisualManagerVS2008::GetSmartDockingTheme()
{
	if (afxGlobalData.m_nBitsPerPixel <= 8 || afxGlobalData.IsHighContrastMode() || !afxGlobalData.IsWindowsLayerSupportAvailable() || !afxGlobalData.bIsWindowsVista)
	{
		return CMFCVisualManagerVS2005::GetSmartDockingTheme();
	}

	return AFX_SDT_VS2008;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanagerwindows.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.


#include "stdafx.h"
#include "afxvisualmanagerwindows.h"
#include "afxpopupmenubar.h"
#include "afxbutton.h"
#include "afxdrawmanager.h"
#include "afxbasetabctrl.h"
#include "afxdockablepane.h"
#include "afxtaskspane.h"
#include "afxtoolbarmenubutton.h"
#include "afxoutlookbarpanebutton.h"
#include "afxstatusbar.h"
#include "afxcaptionbar.h"
#include "afxcolorbar.h"
#include "afxdesktopalertwnd.h"
#include "afxdocksite.h"
#include "afxribbonstatusbar.h"
#include "afxribbonpanelmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCVisualManagerWindows, CMFCVisualManagerOfficeXP)

BOOL CMFCVisualManagerWindows::m_b3DTabsXPTheme = FALSE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCVisualManagerWindows::CMFCVisualManagerWindows(BOOL bIsTemporary) : CMFCVisualManagerOfficeXP(bIsTemporary)
{
	m_bShadowHighlightedImage = FALSE;

	m_bOfficeStyleMenus = FALSE;

	m_nVertMargin = 12;
	m_nHorzMargin = 12;
	m_nGroupVertOffset = 15;
	m_nGroupCaptionHeight = 25;
	m_nGroupCaptionHorzOffset = 13;
	m_nGroupCaptionVertOffset = 7;
	m_nTasksHorzOffset = 12;
	m_nTasksIconHorzOffset = 5;
	m_nTasksIconVertOffset = 4;
	m_bActiveCaptions = TRUE;

	afxGlobalData.UpdateSysColors();
	OnUpdateSystemColors();
}

CMFCVisualManagerWindows::~CMFCVisualManagerWindows()
{
}

BOOL __stdcall CMFCVisualManagerWindows::IsWinXPThemeAvailable()
{
	CMFCVisualManagerWindows* pWinXPManager = DYNAMIC_DOWNCAST(CMFCVisualManagerWindows, m_pVisManager);
	if (pWinXPManager != NULL)
	{
		return pWinXPManager->m_hThemeWindow != NULL;
	}

	// Create a temporary manager and check it:
	CMFCVisualManagerWindows winXPManager(TRUE /* Temporary */);
	return winXPManager.m_hThemeWindow != NULL;
}

void CMFCVisualManagerWindows::SetOfficeStyleMenus(BOOL bOn)
{
	m_bOfficeStyleMenus = bOn;
}

void CMFCVisualManagerWindows::OnUpdateSystemColors()
{
	CMFCVisualManagerOfficeXP::OnUpdateSystemColors();

	m_bShadowHighlightedImage = TRUE;

	CMFCBaseVisualManager::UpdateSystemColors();

	if (m_hThemeWindow != NULL)
	{
		m_bShadowHighlightedImage = FALSE;
	}

	if (m_pfGetThemeColor != NULL)
	{
		if (m_hThemeToolBar != NULL)
		{
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_TEXTCOLOR, &afxGlobalData.clrBarText);
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_FILLCOLOR, &afxGlobalData.clrBarFace);
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_EDGELIGHTCOLOR, &afxGlobalData.clrBarLight);
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_EDGEHIGHLIGHTCOLOR, &afxGlobalData.clrBarHilite);
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_EDGESHADOWCOLOR, &afxGlobalData.clrBarShadow);
			(*m_pfGetThemeColor)(m_hThemeToolBar, TP_BUTTON, 0, TMT_EDGEDKSHADOWCOLOR, &afxGlobalData.clrBarDkShadow);
		}

		if (m_hThemeButton != NULL)
		{
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_TEXTCOLOR, &afxGlobalData.clrBtnText);
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_FILLCOLOR, &afxGlobalData.clrBtnFace);
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_EDGELIGHTCOLOR, &afxGlobalData.clrBtnLight);
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_EDGEHIGHLIGHTCOLOR, &afxGlobalData.clrBtnHilite);
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_EDGESHADOWCOLOR, &afxGlobalData.clrBtnShadow);
			(*m_pfGetThemeColor)(m_hThemeButton, BP_PUSHBUTTON, 0, TMT_EDGEDKSHADOWCOLOR, &afxGlobalData.clrBtnDkShadow);
		}
	}
}

void CMFCVisualManagerWindows::OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar)
{
	ASSERT_VALID(pDC);

	if (m_hThemeRebar == NULL || pBar->GetSafeHwnd() == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawBarGripper(pDC, rectGripper, bHorz, pBar);
		return;
	}

	BOOL bSideBar = pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CDockablePane));

	CRect rectFill = rectGripper;

	if (bSideBar)
	{
		bHorz = !bHorz;
	}

	COLORREF clrTextOld = pDC->SetTextColor(afxGlobalData.clrBtnShadow);
	COLORREF clrBkOld = pDC->SetBkColor(afxGlobalData.clrBtnFace);

	CRect rectGripperTheme = rectGripper;
	const int nGripperOffset = 2;

	if (bHorz)
	{
		rectGripperTheme.DeflateRect(0, nGripperOffset);
		rectGripperTheme.OffsetRect(nGripperOffset, 0);
		rectGripperTheme.right = rectGripperTheme.left + 3 * nGripperOffset;
	}
	else
	{
		rectGripperTheme.DeflateRect(nGripperOffset, 0);
		rectGripperTheme.OffsetRect(0, nGripperOffset);
		rectGripperTheme.bottom = rectGripperTheme.top + 3 * nGripperOffset;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeRebar, pDC->GetSafeHdc(), bHorz ? RP_GRIPPER : RP_GRIPPERVERT, 0, &rectGripperTheme, 0);
	}

	if (bSideBar)
	{
		//------------------
		// Draw bar caption:
		//------------------
		int nOldBkMode = pDC->SetBkMode(OPAQUE);
		pDC->SetTextColor(afxGlobalData.clrBtnText);

		const CFont& font = CMFCMenuBar::GetMenuFont(bHorz);

		CFont* pOldFont = pDC->SelectObject((CFont*) &font);

		CString strCaption;
		pBar->GetWindowText(strCaption);
		strCaption = _T(" ") + strCaption + _T(" ");

		CRect rectText = rectGripper;
		UINT uiTextFormat = 0;

		TEXTMETRIC tm;
		pDC->GetTextMetrics(&tm);

		CPoint ptTextOffset(0, 0);
		if (bHorz)
		{
			ptTextOffset.y = (rectGripper.Height() - tm.tmHeight - 1) / 2;
		}
		else
		{
			ptTextOffset.x = (rectGripper.Width() - tm.tmHeight + 1) / 2;
		}

		if (bHorz)
		{
			rectText.top += ptTextOffset.y;
			pDC->DrawText(strCaption, &rectText, uiTextFormat);
		}
		else
		{
			rectText.left = rectText.right - ptTextOffset.x;
			rectText.top = rectGripper.top + ptTextOffset.y;
			rectText.bottom = rectGripper.top + 3 * ptTextOffset.y;

			uiTextFormat |= DT_NOCLIP;

			pDC->DrawText(strCaption, &rectText, uiTextFormat);
		}

		pDC->SelectObject(pOldFont);
		pDC->SetBkMode(nOldBkMode);
	}

	pDC->SetTextColor(clrTextOld);
	pDC->SetBkColor(clrBkOld);
}

void CMFCVisualManagerWindows::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea)
{
	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCStatusBar)) && m_hThemeStatusBar != NULL && m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		if (m_hThemeStatusBar != NULL && m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
			return;
		}
	}

	if (m_pfDrawThemeBackground == NULL || m_hThemeRebar == NULL || pBar->IsDialogControl() || pBar->IsKindOf(RUNTIME_CLASS(CMFCCaptionBar)) || pBar->IsKindOf(RUNTIME_CLASS(CMFCColorBar)))
	{
		CMFCVisualManagerOfficeXP::OnFillBarBackground(pDC, pBar,rectClient, rectClip, bNCArea);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		if (m_bOfficeStyleMenus)
		{
			CMFCVisualManagerOfficeXP::OnFillBarBackground(pDC, pBar,rectClient, rectClip, bNCArea);
		}
		else
		{
			::FillRect(pDC->GetSafeHdc(), rectClient, ::GetSysColorBrush(COLOR_MENU));

			CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
			if (m_hThemeMenu != NULL && !pMenuBar->m_bDisableSideBarInXPMode)
			{
				CRect rectGutter = rectClient;
				rectGutter.right = rectGutter.left + pMenuBar->GetGutterWidth() + 2;
				rectGutter.DeflateRect(0, 1);

				(*m_pfDrawThemeBackground)(m_hThemeMenu, pDC->GetSafeHdc(), MENU_POPUPGUTTER, 0, &rectGutter, 0);
			}
		}

		return;
	}

	FillReBarPane(pDC, pBar, rectClient);
}

void CMFCVisualManagerWindows::OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect)
{
	CMFCVisualManager::OnDrawPaneBorder(pDC, pBar, rect);
}

void CMFCVisualManagerWindows::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (m_hThemeToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	BOOL bIsMenuBar = FALSE;
	BOOL bIsPopupMenu = FALSE;

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	if (pMenuButton != NULL)
	{
		bIsMenuBar = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));
		bIsPopupMenu = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));
	}

	if (m_bOfficeStyleMenus &&(bIsPopupMenu || bIsMenuBar))
	{
		CMFCVisualManagerOfficeXP::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	if (bIsPopupMenu && state != ButtonsIsHighlighted && state != ButtonsIsPressed)
	{
		return;
	}

	int nState = TS_NORMAL;

	if (pButton->m_nStyle & TBBS_DISABLED)
	{
		nState = TS_DISABLED;
	}
	else if ((pButton->m_nStyle & TBBS_PRESSED) && state == ButtonsIsHighlighted)
	{
		nState = TS_PRESSED;
	}
	else if (pButton->m_nStyle & TBBS_CHECKED)
	{
		nState = (state == ButtonsIsHighlighted) ? TS_HOTCHECKED : TS_CHECKED;
	}
	else if (state == ButtonsIsHighlighted)
	{
		nState = TS_HOT;

		if (pMenuButton != NULL && pMenuButton->IsDroppedDown())
		{
			nState = TS_PRESSED;
			rect.bottom--;
		}
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), TP_BUTTON, nState, &rect, 0);
	}
}

COLORREF CMFCVisualManagerWindows::GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pButton);

	if (m_hThemeToolBar == NULL || pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton)))
	{
		return CMFCVisualManagerOfficeXP::GetToolbarButtonTextColor(pButton, state);
	}

	return CMFCVisualManager::GetToolbarButtonTextColor(pButton, state);
}

void CMFCVisualManagerWindows::OnHighlightMenuItem(CDC*pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText)
{
	if (m_hThemeWindow == NULL || m_bOfficeStyleMenus)
	{
		CMFCVisualManagerOfficeXP::OnHighlightMenuItem(pDC, pButton, rect, clrText);
		return;
	}

	if (m_hThemeMenu == NULL)
	{
		CMFCVisualManager::OnHighlightMenuItem(pDC, pButton, rect, clrText);
		return;
	}

	(*m_pfDrawThemeBackground)(m_hThemeMenu, pDC->GetSafeHdc(), MENU_POPUPITEM, MPI_HOT, &rect, 0);

	(*m_pfGetThemeColor)(m_hThemeMenu, MENU_POPUPITEM, MPI_HOT, TMT_TEXTCOLOR, &clrText);
}

COLORREF CMFCVisualManagerWindows::GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton)
{
	if (m_hThemeMenu != NULL && !m_bOfficeStyleMenus)
	{
		COLORREF clrText = 0;
		(*m_pfGetThemeColor)(m_hThemeMenu, MENU_POPUPITEM, 0, TMT_TEXTCOLOR, &clrText);
		return clrText;
	}

	if (m_hThemeWindow == NULL || m_bOfficeStyleMenus)
	{
		return CMFCVisualManagerOfficeXP::GetHighlightedMenuItemTextColor(pButton);
	}
	else
	{
		return CMFCVisualManager::GetHighlightedMenuItemTextColor(pButton);
	}
}

void CMFCVisualManagerWindows::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	if (m_hThemeWindow == NULL || m_bOfficeStyleMenus)
	{
		CMFCVisualManagerOfficeXP::OnHighlightRarelyUsedMenuItems(pDC, rectRarelyUsed);
		return;
	}

	ASSERT_VALID(pDC);

	CDrawingManager dm(*pDC);

	rectRarelyUsed.left --;
	rectRarelyUsed.right = rectRarelyUsed.left + CMFCToolBar::GetMenuImageSize().cx + 2 * GetMenuImageMargin() + 2;
	dm.HighlightRect(rectRarelyUsed, 94);
}

void CMFCVisualManagerWindows::OnFillMenuImageRect(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (m_hThemeMenu == NULL || m_bOfficeStyleMenus || m_pfDrawThemeBackground == NULL)
	{
		CMFCVisualManagerOfficeXP::OnFillMenuImageRect(pDC, pButton, rect, state);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->m_nStyle & TBBS_CHECKED)
	{
		(*m_pfDrawThemeBackground)(m_hThemeMenu, pDC->GetSafeHdc(), MENU_POPUPCHECKBACKGROUND, MCB_NORMAL, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, AFX_BUTTON_STATE state)
{
	if (m_hThemeToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawButtonBorder(pDC, pButton, rect, state);
		return;
	}

	if (m_bOfficeStyleMenus)
	{
		CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
		if (pMenuButton != NULL)
		{
			BOOL bIsMenuBar = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));
			BOOL bIsPopupMenu = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

			if (bIsPopupMenu || bIsMenuBar)
			{
				CMFCVisualManagerOfficeXP::OnDrawButtonBorder(pDC, pButton, rect, state);
				return;
			}
		}
	}
}

void CMFCVisualManagerWindows::OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz)
{
	if (m_hThemeToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawButtonSeparator(pDC, pButton, rect, state, bHorz);
		return;
	}

	rect.InflateRect(2, 2);

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), bHorz ? TP_SEPARATOR : TP_SEPARATORVERT, 0, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	ASSERT_VALID(pBar);

	if (m_hThemeToolBar == NULL || pBar->IsDialogControl())
	{
		CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
		return;
	}

	CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
	if (pMenuBar != NULL)
	{
		if (m_bOfficeStyleMenus)
		{
			CMFCVisualManagerOfficeXP::OnDrawSeparator(pDC, pBar, rect, bHorz);
			return;
		}

		if (m_hThemeMenu != NULL)
		{
			CMFCRibbonPanelMenuBar* pRibbonMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, pBar);
			BOOL bRibbonPanel = pRibbonMenuBar != NULL && !pRibbonMenuBar->IsMenuMode () && !pRibbonMenuBar->IsMainPanel ();
			if (bRibbonPanel)
			{
				if (bHorz && rect.Width () < 2)
				{
					rect.right++;
				}

				(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), bHorz ? TP_SEPARATOR : TP_SEPARATORVERT, 0, &rect, 0);
				return;
			}

			if (pRibbonMenuBar == NULL || !bRibbonPanel)
			{
				CRect rectClient;
				pBar->GetClientRect(rectClient);

				rect.left = rectClient.left + pMenuBar->GetGutterWidth();
				rect.right = rectClient.right;
				rect.top = rect.CenterPoint().y - 3;
				rect.bottom = rect.CenterPoint().y + 3;
			}

			(*m_pfDrawThemeBackground)(m_hThemeMenu, pDC->GetSafeHdc(), MENU_POPUPSEPARATOR, 0, &rect, 0);
			return;
		}
	}

	if (bHorz && rect.Width() < 2)
	{
		rect.right++;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), bHorz ? TP_SEPARATOR : TP_SEPARATORVERT, 0, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID /*= -1*/)
{
	if (m_hThemeToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawCaptionButton(pDC, pButton, bActive, bHorz, bMaximized, bDisabled, nImageID);
		return;
	}

	ENSURE(pButton != NULL);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pDC);

	BOOL bPushed = pButton->m_bPushed;
	BOOL bFocused = pButton->m_bFocused || pButton->m_bDroppedDown;

	int nState = TS_NORMAL;
	if (bDisabled)
	{
		nState = TS_DISABLED;
	}
	else if (bPushed && bFocused)
	{
		nState = TS_PRESSED;
	}
	else if (bFocused)
	{
		nState = TS_HOT;
	}

	CRect rect = pButton->GetRect();

	if (pButton->IsMiniFrameButton())
	{
		rect.bottom -= 3;
		rect.right -= 2;
	}

	int nPart = 0;
	HTHEME hTheme = NULL;

	if (nImageID == -1)
	{
		switch(pButton->m_nHit)
		{
		case HTCLOSE:
		case AFX_HTCLOSE:

			if (pButton->IsMiniFrameButton() || afxGlobalData.bIsWindowsVista)
			{
				nPart = WP_SMALLCLOSEBUTTON;
				hTheme = m_hThemeWindow;

				if (!pButton->IsMiniFrameButton())
				{
					rect.DeflateRect(1, 2);
				}
			}
			else
			{
				nPart = EBP_HEADERCLOSE;
				hTheme = m_hThemeExplorerBar;
			}

			break;

		case HTMAXBUTTON:
			if (!afxGlobalData.bIsWindowsVista)
			{
				nPart = EBP_HEADERPIN;
				hTheme = m_hThemeExplorerBar;

				if (!bMaximized)
				{
					nState += 3;
				}
			}
			break;
		}
	}

	if (nPart == 0 || hTheme == NULL)
	{
		if (!pButton->IsMiniFrameButton() && !afxGlobalData.bIsWindowsVista)
		{
			rect.DeflateRect(1, 2);
		}

		if (m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), TP_BUTTON, nState, &rect, 0);
		}

		CMenuImages::IMAGES_IDS id = (CMenuImages::IMAGES_IDS)-1;

		if (nImageID != -1)
		{
			id = (CMenuImages::IMAGES_IDS)nImageID;
		}
		else
		{
			id = pButton->GetIconID(bHorz, bMaximized);
		}

		if (id != (CMenuImages::IMAGES_IDS)-1)
		{
			CSize sizeImage = CMenuImages::Size();
			CPoint ptImage(rect.left +(rect.Width() - sizeImage.cx) / 2, rect.top +(rect.Height() - sizeImage.cy) / 2);

			OnDrawCaptionButtonIcon(pDC, pButton, id, bActive, bDisabled, ptImage);
		}
	}
	else if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(hTheme, pDC->GetSafeHdc(), nPart, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawCaptionButtonIcon(CDC* pDC, CMFCCaptionButton* pButton, CMenuImages::IMAGES_IDS id, BOOL bActive, BOOL bDisabled, CPoint ptImage)
{
	BOOL bFocused = pButton->m_bFocused || pButton->m_bDroppedDown;

	if (m_hThemeButton == NULL || !bFocused)
	{
		CMFCVisualManagerOfficeXP::OnDrawCaptionButtonIcon(pDC, pButton, id, bActive,
			bDisabled, ptImage);
		return;
	}

	ASSERT_VALID(pDC);
	CMenuImages::Draw(pDC, id, ptImage, CMenuImages::ImageBlack);
}

COLORREF CMFCVisualManagerWindows::OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected)
{
	if (m_hThemeWindow == NULL || m_bOfficeStyleMenus)
	{
		return CMFCVisualManagerOfficeXP::OnFillCommandsListBackground(pDC, rect, bIsSelected);
	}

	::FillRect(pDC->GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_MENU));

	if (bIsSelected)
	{
		pDC->FillRect(rect, &afxGlobalData.brHilite);
		pDC->Draw3dRect(rect, afxGlobalData.clrMenuText, afxGlobalData.clrMenuText);

		return afxGlobalData.clrTextHilite;
	}

	return afxGlobalData.clrMenuText;
}

void CMFCVisualManagerWindows::OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive)
{
	CMFCVisualManagerOfficeXP::OnDrawTearOffCaption(pDC, rect, bIsActive);
}

void CMFCVisualManagerWindows::OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawMenuSystemButton(pDC, rect, uiSystemCommand, nStyle, bHighlight);
		return;
	}

	int nPart;
	switch(uiSystemCommand)
	{
	case SC_CLOSE:
		nPart = WP_MDICLOSEBUTTON;
		break;

	case SC_RESTORE:
		nPart = WP_MDIRESTOREBUTTON;
		break;

	case SC_MINIMIZE:
		nPart = WP_MDIMINBUTTON;
		break;

	default:
		return;
	}

	BOOL bIsDisabled = (nStyle & TBBS_DISABLED);
	BOOL bIsPressed = (nStyle & TBBS_PRESSED);

	int nState = CBS_NORMAL;
	if (bIsDisabled)
	{
		nState = CBS_DISABLED;
	}
	else if (bIsPressed && bHighlight)
	{
		nState = CBS_PUSHED;
	}
	else if (bHighlight)
	{
		nState = CBS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), nPart, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle)
{
	if (m_hThemeStatusBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarPaneBorder(pDC, pBar, rectPane, uiID, nStyle);
		return;
	}

	if (!(nStyle & SBPS_NOBORDERS) && m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), SP_PANE, 0, &rectPane, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox)
{
	if (m_hThemeScrollBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarSizeBox(pDC, pStatBar, rectSizeBox);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeScrollBar, pDC->GetSafeHdc(), SBP_SIZEBOX, SZB_RIGHTALIGN, &rectSizeBox, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect)
{
	if (m_hThemeWindow == NULL || m_bOfficeStyleMenus)
	{
		ASSERT_VALID(pMenu);

		BOOL bConnectMenuToParent = m_bConnectMenuToParent;
		m_bConnectMenuToParent = FALSE;

		if (m_hThemeWindow == NULL)
		{
			m_bConnectMenuToParent = TRUE;
		}
		else if (!CMFCToolBar::IsCustomizeMode())
		{
			CMFCToolBarMenuButton* pMenuButton = pMenu->GetParentButton();

			if (pMenuButton != NULL)
			{
				BOOL bIsMenuBar = pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));
				if (bIsMenuBar)
				{
					m_bConnectMenuToParent = TRUE;
				}
			}
		}

		CMFCVisualManagerOfficeXP::OnDrawMenuBorder(pDC, pMenu, rect);

		m_bConnectMenuToParent = bConnectMenuToParent;
	}
	else
	{
		CMFCVisualManager::OnDrawMenuBorder(pDC, pMenu, rect);
	}
}

void CMFCVisualManagerWindows::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (m_hThemeComboBox == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	int nState = bDisabled ? CBXS_DISABLED : bIsDropped ? CBXS_PRESSED : bIsHighlighted ? CBXS_HOT : CBXS_NORMAL;

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeComboBox, pDC->GetSafeHdc(), CP_DROPDOWNBUTTON, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawComboBorder(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	if (bIsHighlighted || bIsDropped)
	{
		rect.DeflateRect(1, 1);
		pDC->Draw3dRect(&rect,  afxGlobalData.clrHilite, afxGlobalData.clrHilite);
	}
}

void CMFCVisualManagerWindows::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab)
{
	if (!m_b3DTabsXPTheme || m_hThemeTab == NULL || pWndTab->IsFlatTab() || pWndTab->IsOneNoteStyle() || pWndTab->IsVS2005Style())
	{
		CMFCVisualManagerOfficeXP::OnEraseTabsButton(pDC, rect, pButton, pWndTab);
		return;
	}

	CRgn rgn;
	rgn.CreateRectRgnIndirect(rect);

	pDC->SelectClipRgn(&rgn);

	CRect rectTabs;
	pWndTab->GetClientRect(&rectTabs);

	CRect rectTabArea;
	pWndTab->GetTabsRect(rectTabArea);

	if (pWndTab->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rectTabs.top = rectTabArea.top;
		rectTabs.bottom += 2;
	}
	else
	{
		rectTabs.bottom = rectTabArea.bottom;
	}

	pWndTab->MapWindowPoints(pButton, rectTabs);

	OnEraseTabsArea(pDC, rectTabs, pWndTab);

	pDC->SelectClipRgn(NULL);
}

void CMFCVisualManagerWindows::OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab)
{
	if (m_hThemeToolBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawTabsButtonBorder(pDC, rect, pButton, uiState, pWndTab);
		return;
	}

	int nState = TS_NORMAL;

	if (!pButton->IsWindowEnabled())
	{
		nState = TS_DISABLED;
	}
	else if (pButton->IsPressed() || pButton->GetCheck())
	{
		nState = TS_PRESSED;
	}
	else if (pButton->IsHighlighted())
	{
		nState = TS_HOT;
	}

	afxGlobalData.DrawParentBackground(pButton, pDC, rect);

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeToolBar, pDC->GetSafeHdc(), TP_BUTTON, nState, &rect, 0);
	}
}

COLORREF CMFCVisualManagerWindows::OnFillMiniFrameCaption( CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive)
{
	if (m_hThemeWindow == NULL)
	{
		return CMFCVisualManager::OnFillMiniFrameCaption(pDC, rectCaption, pFrameWnd, bActive);
	}

	return afxGlobalData.clrCaptionText;
}

void CMFCVisualManagerWindows::OnDrawMiniFrameBorder( CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManager::OnDrawMiniFrameBorder(pDC, pFrameWnd, rectBorder, rectBorderSize);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), WP_SMALLCAPTION, 0, &rectBorder, 0);
	}

	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarDkShadow);
	rectBorder.DeflateRect(1, 1);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

void CMFCVisualManagerWindows::OnDrawFloatingToolbarBorder( CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManager::OnDrawFloatingToolbarBorder(pDC, pToolBar, rectBorder, rectBorderSize);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), WP_SMALLCAPTION, 0, &rectBorder, 0);
	}

	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarFace, afxGlobalData.clrBarDkShadow);
	rectBorder.DeflateRect(1, 1);
	pDC->Draw3dRect(rectBorder, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

void CMFCVisualManagerWindows::OnFillOutlookPageButton(CDC* pDC, const CRect& rectClient, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText)
{
	if (m_hThemeButton == NULL)
	{
		CMFCVisualManagerOfficeXP::OnFillOutlookPageButton(pDC, rectClient, bIsHighlighted, bIsPressed, clrText);
		return;
	}

	int nState = PBS_NORMAL;
	if (bIsHighlighted)
	{
		nState = PBS_PRESSED;
	}
	else if (bIsPressed)
	{
		nState = PBS_HOT;
	}

	CRect rect = rectClient;
	rect.InflateRect(1, 1);

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_PUSHBUTTON, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed)
{
	if (m_hThemeButton == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawOutlookPageButtonBorder(pDC, rectBtn, bIsHighlighted, bIsPressed);
	}
}

void CMFCVisualManagerWindows::OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* pStatusBar, CRect rectProgress, int nProgressTotal, int nProgressCurr,
	COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText)
{
	if (!DrawStatusBarProgress(pDC, pStatusBar, rectProgress, nProgressTotal, nProgressCurr, clrBar, clrProgressBarDest, clrProgressText, bProgressText))
	{
		CMFCVisualManagerOfficeXP::OnDrawStatusBarProgress(pDC, pStatusBar, rectProgress, nProgressTotal, nProgressCurr, clrBar, clrProgressBarDest, clrProgressText, bProgressText);
	}
}

CSize CMFCVisualManagerWindows::GetButtonExtraBorder() const
{
	if (m_hThemeWindow == NULL)
	{
		return CMFCVisualManagerOfficeXP::GetButtonExtraBorder();
	}

	return CSize(2, 2);
}

CSize CMFCVisualManagerWindows::GetCaptionButtonExtraBorder() const
{
	if (m_hThemeWindow == NULL)
	{
		return CMFCVisualManagerOfficeXP::GetCaptionButtonExtraBorder();
	}

	return CSize(1, 1);
}

void CMFCVisualManagerWindows::OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted)
{
	if (m_hThemeHeader == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawHeaderCtrlBorder(pCtrl, pDC, rect, bIsPressed, bIsHighlighted);
		return;
	}

	int nState = HIS_NORMAL;

	if (bIsPressed)
	{
		nState = HIS_PRESSED;
	}
	else if (bIsHighlighted)
	{
		nState = HIS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeHeader, pDC->GetSafeHdc(), HP_HEADERITEM, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawHeaderCtrlSortArrow(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsUp)
{
	if (m_hThemeHeader == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawHeaderCtrlSortArrow(pCtrl, pDC, rect, bIsUp);
		return;
	}

#define AFX_POINTS_NUM 3
	POINT pts [AFX_POINTS_NUM];

	if (bIsUp)
	{
		pts [0].x = rect.left;
		pts [0].y = rect.bottom;

		pts [1].x = rect.CenterPoint().x;
		pts [1].y = rect.top;

		pts [2].x = rect.right;
		pts [2].y = rect.bottom;
	}
	else
	{
		pts [0].x = rect.left;
		pts [0].y = rect.top;

		pts [1].x = rect.CenterPoint().x;
		pts [1].y = rect.bottom;

		pts [2].x = rect.right;
		pts [2].y = rect.top;
	}

	CBrush br(afxGlobalData.clrBtnShadow);
	CBrush* pOldBrush = pDC->SelectObject(&br);

	CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);

	pDC->Polygon(pts, AFX_POINTS_NUM);

	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);
}


void CMFCVisualManagerWindows::OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawEditBorder(pDC, rect, bDisabled, bIsHighlighted, pButton);
		return;
	}

	if (bIsHighlighted)
	{
		pDC->Draw3dRect(&rect,  afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnHilite);
	}
}

void CMFCVisualManagerWindows::OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea)
{
	ASSERT_VALID(pDC);

	if (m_hThemeExplorerBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnFillTasksPaneBackground(pDC, rectWorkArea);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_HEADERBACKGROUND, 0, &rectWorkArea, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted, BOOL bIsSelected, BOOL bCanCollapse)
{
	ENSURE(pGroup != NULL);
	ENSURE(pGroup->m_pPage != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);
	ASSERT_VALID(pGroup->m_pPage);

	if (m_hThemeExplorerBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawTasksGroupCaption(pDC, pGroup, bIsHighlighted, bIsSelected, bCanCollapse);
		return;
	}

	if (pGroup->m_strName.IsEmpty())
	{
		return;
	}

	// -------------------------------
	// Draw group caption(Windows XP)
	// -------------------------------
	if (m_pfDrawThemeBackground != NULL)
	{
		if (pGroup->m_bIsSpecial)
		{
			(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPHEAD, 0, &pGroup->m_rect, 0);
		}
		else
		{
			(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPHEAD, 0, &pGroup->m_rect, 0);
		}
	}

	// ---------------------------
	// Draw an icon if it presents
	// ---------------------------
	BOOL bShowIcon = (pGroup->m_hIcon != NULL && pGroup->m_sizeIcon.cx < pGroup->m_rect.Width() - pGroup->m_rect.Height());
	if (bShowIcon)
	{
		OnDrawTasksGroupIcon(pDC, pGroup, 5, bIsHighlighted, bIsSelected, bCanCollapse);
	}

	// -----------------------
	// Draw group caption text
	// -----------------------
	CFont* pFontOld = pDC->SelectObject(&afxGlobalData.fontBold);
	COLORREF clrTextOld = pDC->GetTextColor();
	if (bCanCollapse && bIsHighlighted)
	{
		if (pGroup->m_bIsSpecial)
		{
			pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrWindow : pGroup->m_clrTextHot);
		}
		else
		{
			pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrHilite : pGroup->m_clrTextHot);
		}
	}
	else
	{
		if (pGroup->m_bIsSpecial)
		{
			pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindow : pGroup->m_clrText);
		}
		else
		{
			pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ? afxGlobalData.clrHilite : pGroup->m_clrText);
		}
	}
	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	int nTaskPaneHOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionHorzOffset();
	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();
	int nCaptionHOffset = (nTaskPaneHOffset != -1 ? nTaskPaneHOffset : m_nGroupCaptionHorzOffset);

	CRect rectText = pGroup->m_rect;
	rectText.left += (bShowIcon ? pGroup->m_sizeIcon.cx + 5: nCaptionHOffset);
	rectText.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectText.right = max(rectText.left, rectText.right -(bCanCollapse ? pGroup->m_rect.Height() : nCaptionHOffset));

	pDC->DrawText(pGroup->m_strName, rectText, DT_SINGLELINE | DT_END_ELLIPSIS);

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);

	// -------------------------
	// Draw group caption button
	// -------------------------
	if (bCanCollapse)
	{
		CRect rectButton = pGroup->m_rect;
		rectButton.left = max(rectButton.left, rectButton.right - rectButton.Height());

		if (m_pfDrawThemeBackground != NULL)
		{
			if (pGroup->m_bIsSpecial)
			{
				if (!pGroup->m_bIsCollapsed)
				{
					if (bIsHighlighted)
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPCOLLAPSE, EBSGC_HOT, &rectButton, 0);
					}
					else
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPCOLLAPSE, EBSGC_NORMAL, &rectButton, 0);
					}
				}
				else
				{
					if (bIsHighlighted)
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPEXPAND, EBSGE_HOT, &rectButton, 0);
					}
					else
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPEXPAND, EBSGE_NORMAL, &rectButton, 0);
					}
				}
			}
			else
			{
				if (!pGroup->m_bIsCollapsed)
				{
					if (bIsHighlighted)
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPCOLLAPSE, EBNGC_HOT, &rectButton, 0);
					}
					else
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPCOLLAPSE, EBNGC_NORMAL, &rectButton, 0);
					}
				}
				else
				{
					if (bIsHighlighted)
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPEXPAND, EBNGE_HOT, &rectButton, 0);
					}
					else
					{
						(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPEXPAND, EBNGE_NORMAL, &rectButton, 0);
					}
				}
			}
		}
	}
}

void CMFCVisualManagerWindows::OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial)
{
	ASSERT_VALID(pDC);

	if (m_hThemeExplorerBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnFillTasksGroupInterior(pDC, rect);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		if (!bSpecial)
		{
			(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPBACKGROUND, 0, &rect, 0);
		}
		else
		{
			(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPBACKGROUND, 0, &rect, 0);
		}
	}
}

void CMFCVisualManagerWindows::OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial, BOOL bNoTitle)
{
	if (m_hThemeExplorerBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawTasksGroupAreaBorder(pDC, rect, bSpecial, bNoTitle);
		return;
	}

	ASSERT_VALID(pDC);

	// Draw underline
	if (bNoTitle)
	{
		CRect rectDraw = rect;
		rectDraw.bottom = rectDraw.top + 1;

		if (m_pfDrawThemeBackground != NULL)
		{
			if (bSpecial)
			{
				(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_SPECIALGROUPHEAD, 0, &rectDraw, 0);
			}
			else
			{
				(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPHEAD, 0, &rectDraw, 0);
			}
		}
	}

	return;
}

void CMFCVisualManagerWindows::OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted, BOOL bIsSelected)
{
	ENSURE(pTask != NULL);
	ENSURE(pIcons != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pIcons);
	ASSERT_VALID(pTask);

	if (m_hThemeExplorerBar == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawTask(pDC, pTask, pIcons, bIsHighlighted, bIsSelected);
		return;
	}

	if (pTask->m_bIsSeparator)
	{
		// --------------
		// Draw separator
		// --------------
		CRect rectDraw = pTask->m_rect;
		rectDraw.top = pTask->m_rect.CenterPoint().y;
		rectDraw.bottom = rectDraw.top + 1;

		// draw same as group caption
		if (m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_NORMALGROUPHEAD, 0, &rectDraw, 0);
		}
		return;
	}

	// ---------
	// Draw icon
	// ---------
	CRect rectText = pTask->m_rect;
	CSize sizeIcon(0, 0);
	::ImageList_GetIconSize(pIcons->m_hImageList, (int*) &sizeIcon.cx, (int*) &sizeIcon.cy);
	if (pTask->m_nIcon >= 0 && sizeIcon.cx > 0)
	{
		pIcons->Draw(pDC, pTask->m_nIcon, rectText.TopLeft(), ILD_TRANSPARENT);
	}
	int nTaskPaneOffset = pTask->m_pGroup->m_pPage->m_pTaskPane->GetTasksIconHorzOffset();
	rectText.left += sizeIcon.cx +(nTaskPaneOffset != -1 ? nTaskPaneOffset : m_nTasksIconHorzOffset);

	// ---------
	// Draw text
	// ---------
	BOOL bIsLabel = (pTask->m_uiCommandID == 0);

	CFont* pFontOld = NULL;
	COLORREF clrTextOld = pDC->GetTextColor();
	if (bIsLabel)
	{
		pFontOld = pDC->SelectObject( pTask->m_bIsBold ? &afxGlobalData.fontBold : &afxGlobalData.fontRegular);
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrText);
	}
	else if (!pTask->m_bEnabled)
	{
		pDC->SetTextColor(afxGlobalData.clrGrayedText);
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
	}
	else if (bIsHighlighted)
	{
		pFontOld = pDC->SelectObject(&afxGlobalData.fontUnderline);
		pDC->SetTextColor(pTask->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrHilite : pTask->m_clrTextHot);
	}
	else
	{
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrHilite : pTask->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	CMFCTasksPane* pTaskPane = pTask->m_pGroup->m_pPage->m_pTaskPane;
	ASSERT_VALID(pTaskPane);

	BOOL bMultiline = bIsLabel ? pTaskPane->IsWrapLabelsEnabled() : pTaskPane->IsWrapTasksEnabled();

	if (bMultiline)
	{
		pDC->DrawText(pTask->m_strName, rectText, DT_WORDBREAK);
	}
	else
	{
		CString strText = pTask->m_strName;
		strText.Remove (_T('\n'));
		strText.Remove (_T('\r'));
		pDC->DrawText(strText, rectText, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	}

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);
}

void CMFCVisualManagerWindows::OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited)
{
	ASSERT_VALID(pDC);

	CRect rectImage(CPoint(0, 0), CMenuImages::Size());

	CRect rectFill = rect;
	rectFill.top -= nBorderSize;

	pDC->FillRect(rectFill, &afxGlobalData.brBarFace);

	if (bHilited)
	{
		CDrawingManager dm(*pDC);
		dm.HighlightRect(rect);

		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarDkShadow);
	}

	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rect);
}

void CMFCVisualManagerWindows::OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox)
{
	ASSERT_VALID(pDC);

	if (m_hThemeTree == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawExpandingBox(pDC, rect, bIsOpened, colorBox);
		return;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeTree, pDC->GetSafeHdc(), TVP_GLYPH, bIsOpened ? GLPS_OPENED : GLPS_CLOSED, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled)
{
	if (!DrawCheckBox(pDC, rect, bHighlighted, nState, bEnabled, bPressed))
	{
		CMFCVisualManagerOfficeXP::OnDrawCheckBoxEx(pDC, rect, nState, bHighlighted, bPressed, bEnabled);
	}
}

void CMFCVisualManagerWindows::OnDrawControlBorder(CWnd* pWndCtrl)
{
	if (m_hThemeComboBox == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawControlBorder(pWndCtrl);
		return;
	}

	ASSERT_VALID(pWndCtrl);

	CWindowDC dc(pWndCtrl);

	CRect rect;
	pWndCtrl->GetWindowRect(rect);

	rect.bottom -= rect.top;
	rect.right -= rect.left;
	rect.left = rect.top = 0;

	COLORREF clrBorder = (COLORREF)-1;

	if ((m_pfGetThemeColor == NULL) || ((*m_pfGetThemeColor)(m_hThemeComboBox, 5, 0, TMT_BORDERCOLOR, &clrBorder) != S_OK))
	{
		CMFCVisualManagerOfficeXP::OnDrawControlBorder(pWndCtrl);
		return;
	}

	dc.Draw3dRect(&rect, clrBorder, clrBorder);
	rect.DeflateRect(1, 1);
	dc.Draw3dRect(rect, afxGlobalData.clrWindow, afxGlobalData.clrWindow);
}


BOOL CMFCVisualManagerWindows::OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* pEdit, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& clrText)
{
	if (m_hThemeButton == NULL)
	{
		return CMFCVisualManagerOfficeXP::OnDrawBrowseButton(pDC, rect, pEdit, state, clrText);
	}

	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &afxGlobalData.brWindow);

	int nState = PBS_NORMAL;

	switch(state)
	{
	case ButtonsIsPressed:
		nState = PBS_PRESSED;
		break;

	case ButtonsIsHighlighted:
		nState = PBS_HOT;
		break;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_PUSHBUTTON, nState, &rect, 0);
	}

	return TRUE;
}

void CMFCVisualManagerWindows::OnDrawSpinButtons(CDC* pDC, CRect rect, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* pSpinCtrl)
{
	if (m_hThemeSpin == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawSpinButtons(pDC, rect, nState, bOrientation, pSpinCtrl);
		return;
	}

	// Draw up part:
	CRect rectUp = rect;
	rectUp.bottom = rect.CenterPoint().y - 1;

	int nDrawState = UPS_NORMAL;

	if (nState & AFX_SPIN_DISABLED)
	{
		nDrawState = UPS_DISABLED;
	}
	else if (nState & AFX_SPIN_PRESSEDUP)
	{
		nDrawState = UPS_PRESSED;
	}
	else if (nState & AFX_SPIN_HIGHLIGHTEDUP)
	{
		nDrawState = UPS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeSpin, pDC->GetSafeHdc(), bOrientation ? SPNP_UPHORZ : SPNP_UP, nDrawState, &rectUp, 0);
	}

	// Draw up part:
	CRect rectDown = rect;
	rectDown.top = rect.CenterPoint().y;

	nDrawState = UPS_NORMAL;

	if (nState & AFX_SPIN_DISABLED)
	{
		nDrawState = UPS_DISABLED;
	}
	else if (nState & AFX_SPIN_PRESSEDDOWN)
	{
		nDrawState = UPS_PRESSED;
	}
	else if (nState & AFX_SPIN_HIGHLIGHTEDDOWN)
	{
		nDrawState = UPS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeSpin, pDC->GetSafeHdc(), bOrientation ? SPNP_DOWNHORZ : SPNP_DOWN, nDrawState, &rectDown, 0);
	}
}

void CMFCVisualManagerWindows::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (!m_b3DTabsXPTheme || m_hThemeTab == NULL || pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManagerOfficeXP::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	int nState = TIS_NORMAL;
	if (bIsActive)
	{
		nState = TIS_SELECTED;
	}
	else if (iTab == pTabWnd->GetHighlightedTab())
	{
		nState = TIS_HOT;
	}

	rectTab.right++;

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_TOP && !bIsActive)
	{
		rectTab.bottom--;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeTab, pDC->GetSafeHdc(), TABP_TABITEM, nState, &rectTab, 0);
	}

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		CDrawingManager dm(*pDC);
		dm.MirrorRect(rectTab, FALSE);
	}

	COLORREF clrTabText = afxGlobalData.clrWindowText;
	if (m_pfGetThemeColor != NULL)
	{
		(*m_pfGetThemeColor)(m_hThemeTab, TABP_TABITEM, nState, TMT_TEXTCOLOR, &clrTabText);
	}

	COLORREF cltTextOld = pDC->SetTextColor(clrTabText);

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd, (COLORREF)-1);

	pDC->SetTextColor(cltTextOld);
}

void CMFCVisualManagerWindows::OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	if (m_hThemeWindow == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawTabCloseButton(pDC, rect, pTabWnd, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	int nState = TS_NORMAL;
	if (bIsDisabled)
	{
		nState = TS_DISABLED;
	}
	else if (bIsPressed && bIsHighlighted)
	{
		nState = TS_PRESSED;
	}
	else if (bIsHighlighted)
	{
		nState = TS_HOT;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), WP_SMALLCLOSEBUTTON, nState, &rect, 0);
	}
}

void CMFCVisualManagerWindows::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (!m_b3DTabsXPTheme || m_hThemeTab == NULL || pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style() || pTabWnd->IsDialogControl())
	{
		CMFCVisualManagerOfficeXP::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	rect.right += 10;

	if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
	{
		rect.top -= 3;
		CMemDC memDC(*pDC, (CWnd*) pTabWnd);

		if (m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeTab, memDC.GetDC().GetSafeHdc(), TABP_PANE, 0, &rect, NULL);
		}
		CDrawingManager dm(memDC.GetDC());
		dm.MirrorRect(rect, FALSE);
	}
	else
	{
		rect.bottom += 2;
		if (m_pfDrawThemeBackground != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeTab, pDC->GetSafeHdc(), TABP_PANE, 0, &rect, 0);
		}
	}
}

BOOL CMFCVisualManagerWindows::OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (!m_b3DTabsXPTheme || m_hThemeTab == NULL || pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style())
	{
		return CMFCVisualManagerOfficeXP::OnEraseTabsFrame(pDC, rect, pTabWnd);
	}

	return FALSE;
}

void CMFCVisualManagerWindows::OnErasePopupWindowButton(CDC* pDC, CRect rect, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (m_hThemeButton == NULL || pButton->IsCaptionButton())
	{
		CMFCVisualManagerOfficeXP::OnErasePopupWindowButton(pDC, rect, pButton);
		return;
	}

	CRect rectParent;
	pButton->GetParent()->GetClientRect(rectParent);

	pButton->GetParent()->MapWindowPoints(pButton, rectParent);
	OnFillPopupWindowBackground(pDC, rectParent);
}

void CMFCVisualManagerWindows::OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rect, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pButton);

	int nState = PBS_NORMAL;

	if (!pButton->IsWindowEnabled())
	{
		nState = PBS_DISABLED;
	}
	else if (pButton->IsPressed() || pButton->GetCheck())
	{
		nState = PBS_PRESSED;
	}
	else if (pButton->IsHighlighted())
	{
		nState = PBS_HOT;
	}
	else
	{
		nState = PBS_NORMAL;
	}

	if (m_hThemeWindow != NULL && m_pfDrawThemeBackground != NULL && pButton->IsCloseButton() && pButton->IsCaptionButton())
	{
		(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), WP_SMALLCLOSEBUTTON, nState, &rect, 0);
		return;
	}

	if (m_hThemeButton == NULL)
	{
		CMFCVisualManagerOfficeXP::OnDrawPopupWindowButtonBorder(pDC, rect, pButton);
		return;
	}

	afxGlobalData.DrawParentBackground(pButton, pDC, rect);
	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeButton, pDC->GetSafeHdc(), BP_PUSHBUTTON, nState, &rect, 0);
	}
}

BOOL CMFCVisualManagerWindows::IsDefaultWinXPPopupButton(CMFCDesktopAlertWndButton* pButton) const
{
	ASSERT_VALID(pButton);
	return m_hThemeWindow != NULL && pButton->IsCloseButton() && pButton->IsCaptionButton();
}

COLORREF CMFCVisualManagerWindows::OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons)
{
	if (m_hThemeExplorerBar == NULL || m_pfGetThemeColor == NULL)
	{
		return CMFCVisualManagerOfficeXP::OnDrawPaneCaption(pDC, pBar, bActive, rectCaption, rectButtons);
	}

	if (afxGlobalData.bIsWindowsVista)
	{
		CDrawingManager dm(*pDC);
		dm.FillGradient(rectCaption, 
			bActive ? afxGlobalData.clrActiveCaptionGradient : afxGlobalData.clrInactiveCaptionGradient, 
			bActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption, TRUE);

		return bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrInactiveCaptionText;
	}

	if (m_pfDrawThemeBackground != NULL)
	{
		(*m_pfDrawThemeBackground)(m_hThemeExplorerBar, pDC->GetSafeHdc(), EBP_HEADERBACKGROUND, 0, &rectCaption, 0);
	}

	COLORREF clrText;
	if ((m_pfGetThemeColor == NULL) || ((*m_pfGetThemeColor)(m_hThemeExplorerBar, EBP_HEADERBACKGROUND, 0, TMT_TEXTCOLOR, &clrText) != S_OK))
	{
		clrText = afxGlobalData.clrInactiveCaptionText;
	}

	if (bActive)
	{
		CDrawingManager dm(*pDC);
		int nPercentage = 110;

		if (GetRValue(clrText) > 128 &&
			GetGValue(clrText) > 128 &&
			GetBValue(clrText) > 128)
		{
			nPercentage = 80;
		}

		dm.HighlightRect(rectCaption, nPercentage);
	}

	return clrText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanagerwindows7.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobalutils.h"
#include "afxvisualmanagerwindows7.h"
#include "afxtoolbar.h"
#include "afxdrawmanager.h"
#include "afxpopupmenubar.h"
#include "afxmenubar.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxcustomizebutton.h"
#include "afxmenuimages.h"
#include "afxcaptionbar.h"
#include "afxbasetabctrl.h"
#include "afxcolorbar.h"
#include "afxtabctrl.h"
#include "afxtaskspane.h"
#include "afxstatusbar.h"
#include "afxautohidebutton.h"
#include "afxheaderctrl.h"
#include "afxrebar.h"
#include "afxdesktopalertwnd.h"
#include "afxdropdowntoolbar.h"
#include "afxtagmanager.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxdockablepane.h"
#include "afxoutlookbartabctrl.h"
#include "afxtoolbarcomboboxbutton.h"

#include "afxribbonbar.h"
#include "afxribbonpanel.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonquickaccesstoolbar.h"
#include "afxribboncombobox.h"
#include "afxribbonmainpanel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonlabel.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonprogressbar.h"
#include "afxribbonlinkctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_RT_STYLE_XML _T("STYLE_XML")

CString	CMFCVisualManagerWindows7::m_strStylePrefix;
HINSTANCE CMFCVisualManagerWindows7::m_hinstRes = NULL;
BOOL CMFCVisualManagerWindows7::m_bAutoFreeRes = FALSE;

IMPLEMENT_DYNCREATE(CMFCVisualManagerWindows7, CMFCVisualManagerWindows)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCVisualManagerWindows7::CMFCVisualManagerWindows7()
: m_bLoaded(FALSE)
{
}

CMFCVisualManagerWindows7::~CMFCVisualManagerWindows7()
{
}


CString __stdcall CMFCVisualManagerWindows7::MakeResourceID(LPCTSTR lpszID)
{
	CString strResID(lpszID);
	ASSERT(!strResID.IsEmpty());

	if (!m_strStylePrefix.IsEmpty())
	{
		strResID = m_strStylePrefix + strResID;
	}

	return strResID;
}

CString __stdcall CMFCVisualManagerWindows7::GetStyleResourceID()
{
	return _T("WINDOWS7_IDX_STYLE");
}

void __stdcall CMFCVisualManagerWindows7::SetResourceHandle(HINSTANCE hinstRes)
{
	m_bAutoFreeRes = FALSE;

	if (m_hinstRes != hinstRes)
	{
		m_hinstRes = hinstRes;

		if (CMFCVisualManager::GetInstance()->IsKindOf(RUNTIME_CLASS(CMFCVisualManagerWindows7)))
		{
			CMFCVisualManager::GetInstance()->OnUpdateSystemColors();
		}
	}
}

BOOL __stdcall CMFCVisualManagerWindows7::SetStyle(LPCTSTR lpszPath)
{
	if (m_hinstRes >(HINSTANCE) 32)
	{
		return TRUE;
	}

	UNREFERENCED_PARAMETER(lpszPath);
	CString strStyle(GetStyleResourceID());
	HINSTANCE hinstRes = AfxFindResourceHandle(strStyle, AFX_RT_STYLE_XML);

	if (::FindResource(hinstRes, strStyle, AFX_RT_STYLE_XML) == NULL)
	{
		TRACE(_T("Cannot load Style: %s\r\n"), strStyle);
		ASSERT(FALSE);
		return FALSE;
	}

	CleanStyle();
	SetResourceHandle(hinstRes);

	return TRUE;
}

void __stdcall CMFCVisualManagerWindows7::CleanStyle()
{
	if (m_bAutoFreeRes && m_hinstRes > (HINSTANCE)32)
	{
		::FreeLibrary(m_hinstRes);
	}

	m_hinstRes = NULL;
	m_strStylePrefix.Empty();
}

BOOL CMFCVisualManagerWindows7::IsOwnerDrawMenuCheck()
{
	return CanDrawImage() ? FALSE : CMFCVisualManagerWindows::IsOwnerDrawMenuCheck();
}

BOOL CMFCVisualManagerWindows7::IsHighlightWholeMenuItem()
{
	return CanDrawImage() ? TRUE : CMFCVisualManagerWindows::IsHighlightWholeMenuItem();
}

void CMFCVisualManagerWindows7::DrawSeparator(CDC* pDC, const CRect& rect, CPen& pen1, CPen& pen2, BOOL bHorz)
{
	CRect rect1(rect);
	CRect rect2;

	if (bHorz)
	{
		rect1.top += rect.Height() / 2 - 1;
		rect1.bottom = rect1.top;
		rect2 = rect1;
		rect2.OffsetRect(0, 1);
	}
	else
	{
		rect1.left += rect.Width() / 2 - 1;
		rect1.right = rect1.left;
		rect2 = rect1;
		rect2.OffsetRect(1, 0);
	}

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);

		LOGPEN logpen;

		pen1.GetLogPen(&logpen);
		dm.DrawLine(rect1.left, rect1.top, rect1.right, rect1.bottom, logpen.lopnColor);

		pen2.GetLogPen(&logpen);
		dm.DrawLine(rect2.left, rect2.top, rect2.right, rect2.bottom, logpen.lopnColor);
	}
	else
	{
		CPen* pOldPen = pDC->SelectObject(&pen1);
		pDC->MoveTo(rect1.TopLeft());
		pDC->LineTo(rect1.BottomRight());

		pDC->SelectObject(&pen2);
		pDC->MoveTo(rect2.TopLeft());
		pDC->LineTo(rect2.BottomRight());

		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManagerWindows7::DrawNcBtn(CDC* pDC, const CRect& rect, UINT nButton, AFX_BUTTON_STATE state, BOOL bSmall, BOOL bActive, BOOL bMDI/* = FALSE*/)
{
	ASSERT_VALID(pDC);

	if (m_hThemeWindow == NULL)
	{
		UINT nState = 0;

		switch (nButton)
		{
		case SC_CLOSE:
			nState = DFCS_CAPTIONCLOSE;
			break;

		case SC_MINIMIZE:
			nState = DFCS_CAPTIONMIN;
			break;

		case SC_MAXIMIZE:
			nState = DFCS_CAPTIONMAX;
			break;

		case SC_RESTORE:
			nState = DFCS_CAPTIONRESTORE;
			break;

		case SC_CONTEXTHELP:
			nState = DFCS_CAPTIONHELP;
			break;

		default:
			return;
		}

		if (!bActive)
		{
			nState |= DFCS_INACTIVE;
		}

		if (state != ButtonsIsRegular)
		{
			nState |= state == ButtonsIsHighlighted ? DFCS_HOT : DFCS_PUSHED;
		}

		CRect rt(rect);
		pDC->DrawFrameControl(rt, DFC_CAPTION, nState);
		return;
	}

	int nPart = 0;
	int nState = 0;
	if (nButton == SC_CLOSE)
	{
		if (bMDI)
		{
			nPart = WP_MDICLOSEBUTTON;
		}
		else
		{
			nPart = bSmall ? WP_SMALLCLOSEBUTTON : WP_CLOSEBUTTON;
		}

		nState = bActive ? CBS_NORMAL : CBS_DISABLED;
		if (state != ButtonsIsRegular)
		{
			nState = state == ButtonsIsHighlighted ? CBS_HOT : CBS_PUSHED;
		}
	}
	else if (nButton == SC_MINIMIZE)
	{
		if (bMDI)
		{
			nPart = WP_MDIMINBUTTON;
		}
		else if (!bSmall)
		{
			nPart = WP_MINBUTTON;
		}

		nState = bActive ? MINBS_NORMAL : MINBS_DISABLED;
		if (state != ButtonsIsRegular)
		{
			nState = state == ButtonsIsHighlighted ? MINBS_HOT : MINBS_PUSHED;
		}
	}
	else if (nButton == SC_MAXIMIZE)
	{
		if (!bMDI && !bSmall)
		{
			nPart = WP_MAXBUTTON;
		}

		nState = bActive ? MAXBS_NORMAL : MAXBS_DISABLED;
		if (state != ButtonsIsRegular)
		{
			nState = state == ButtonsIsHighlighted ? MAXBS_HOT : MAXBS_PUSHED;
		}
	}
	else if (nButton == SC_RESTORE)
	{
		if (bMDI)
		{
			nPart = WP_MDIRESTOREBUTTON;
		}
		else
		{
			nPart = WP_RESTOREBUTTON;
		}

		nState = bActive ? RBS_NORMAL : RBS_DISABLED;
		if (state != ButtonsIsRegular)
		{
			nState = state == ButtonsIsHighlighted ? RBS_HOT : RBS_PUSHED;
		}
	}
	else if (nButton == SC_CONTEXTHELP)
	{
		if (bMDI)
		{
			nPart = WP_MDIHELPBUTTON;
		}
		else if (!bSmall)
		{
			nPart = WP_HELPBUTTON;
		}

		nState = bActive ? HBS_NORMAL : HBS_DISABLED;
		if (state != ButtonsIsRegular)
		{
			nState = state == ButtonsIsHighlighted ? HBS_HOT : HBS_PUSHED;
		}
	}

	if (nPart == 0)
	{
		return;
	}

	(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), nPart, nState, &rect, 0);
}

void CMFCVisualManagerWindows7::DrawNcText(CDC* pDC, CRect& rect, const CString& strTitle, BOOL bActive, BOOL bIsRTL, BOOL bTextCenter, BOOL bGlass/* = FALSE*/, int nGlassGlowSize/* = 0*/, COLORREF clrGlassText/* = (COLORREF)-1*/)
{
	if (strTitle.IsEmpty() || rect.right <= rect.left)
	{
		return;
	}

	ASSERT_VALID(pDC);

	int nOldMode = pDC->SetBkMode(TRANSPARENT);
	COLORREF clrOldText = pDC->GetTextColor();

	DWORD dwTextStyle = DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER | (bIsRTL ? DT_RTLREADING : 0);

	COLORREF clrText = bActive 
		? afxGlobalData.clrCaptionText
		: afxGlobalData.clrInactiveCaptionText;

	int widthFull = rect.Width();
	int width = pDC->GetTextExtent(strTitle).cx;

	if (bTextCenter && width < widthFull)
	{
		rect.left += (widthFull - width) / 2;
	}

	rect.right = min(rect.left + width, rect.right);

	if (rect.right > rect.left)
	{
		if (bGlass)
		{
			DrawTextOnGlass(pDC, strTitle, rect, dwTextStyle, nGlassGlowSize, clrGlassText);
		}
		else
		{
			pDC->SetTextColor(clrText);
			pDC->DrawText(strTitle, rect, dwTextStyle);
		}
	}

	pDC->SetBkMode(nOldMode);
	pDC->SetTextColor(clrOldText);
}

void CMFCVisualManagerWindows7::CleanUp()
{
	m_AppCaptionFont.DeleteObject();
	m_penSeparatorDark.DeleteObject();
	m_penSeparatorLight.DeleteObject();

	m_brRibbonBarBkgnd.DeleteObject();

	m_ctrlMenuItemBack.CleanUp();
    m_MenuItemMarkerC.Clear();
    m_MenuItemMarkerR.Clear();
	m_ctrlMenuHighlighted[0].CleanUp();
	m_ctrlMenuHighlighted[1].CleanUp();

	m_ctrlRibbonComboBoxBtn.CleanUp();

	m_ctrlRibbonCaptionQA.CleanUp();
	m_ctrlRibbonCategoryBack.CleanUp();
	m_ctrlRibbonCategoryTab.CleanUp();
	m_ctrlRibbonCategoryTabSep.CleanUp();
	m_ctrlRibbonPanelBackSep.CleanUp();
	m_ctrlRibbonMainPanel.CleanUp();
	m_ctrlRibbonBtnMainPanel.CleanUp();
	m_ctrlRibbonBtnGroup_S.CleanUp();
	m_ctrlRibbonBtnGroup_F.CleanUp();
	m_ctrlRibbonBtnGroup_M.CleanUp();
	m_ctrlRibbonBtnGroup_L.CleanUp();
	m_ctrlRibbonBtnGroupMenu_F[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_F[1].CleanUp();
	m_ctrlRibbonBtnGroupMenu_M[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_M[1].CleanUp();
	m_ctrlRibbonBtnGroupMenu_L[0].CleanUp();
	m_ctrlRibbonBtnGroupMenu_L[1].CleanUp();
	m_ctrlRibbonBtn[0].CleanUp();
	m_ctrlRibbonBtn[1].CleanUp();
	m_ctrlRibbonBtnMenuH[0].CleanUp();
	m_ctrlRibbonBtnMenuH[1].CleanUp();
	m_ctrlRibbonBtnMenuV[0].CleanUp();
	m_ctrlRibbonBtnMenuV[1].CleanUp();
	m_ctrlRibbonBtnLaunch.CleanUp();
	m_RibbonBtnLaunchIcon.Clear();
	m_ctrlRibbonBtnMain.CleanUp();
	m_ctrlRibbonSliderBtnPlus.CleanUp();
	m_ctrlRibbonSliderBtnMinus.CleanUp();
	m_RibbonBtnDefaultImage.Clear ();
	m_ctrlRibbonBtnDefault.CleanUp();
	m_ctrlRibbonBtnDefaultIcon.CleanUp();
	m_ctrlRibbonBtnDefaultQAT.CleanUp();
	m_ctrlRibbonBtnStatusPane.CleanUp();
	m_ctrlRibbonBtnPalette[0].CleanUp();
	m_ctrlRibbonBtnPalette[1].CleanUp();
	m_ctrlRibbonBtnPalette[2].CleanUp();

	m_ctrlRibbonBorder_QAT.CleanUp();

	m_cacheRibbonCategoryBack.Clear();
	m_cacheRibbonBtnGroup_S.Clear();
	m_cacheRibbonBtnGroup_F.Clear();
	m_cacheRibbonBtnGroup_M.Clear();
	m_cacheRibbonBtnGroup_L.Clear();
	m_cacheRibbonBtnGroupMenu_F[0].Clear();
	m_cacheRibbonBtnGroupMenu_M[0].Clear();
	m_cacheRibbonBtnGroupMenu_L[0].Clear();
	m_cacheRibbonBtnGroupMenu_F[1].Clear();
	m_cacheRibbonBtnGroupMenu_M[1].Clear();
	m_cacheRibbonBtnGroupMenu_L[1].Clear();
	m_cacheRibbonBtnDefault.Clear();

	m_ActivateFlag.RemoveAll();

	m_bLoaded = FALSE;
}

void CMFCVisualManagerWindows7::OnUpdateSystemColors()
{
	HINSTANCE hinstResOld = NULL;

	if (m_hinstRes == NULL)
	{
		SetStyle();
		return;
	}

	if (m_hinstRes != NULL)
	{
		hinstResOld = AfxGetResourceHandle();
		AfxSetResourceHandle(m_hinstRes);
	}

	CleanUp();

	CMFCVisualManagerWindows::OnUpdateSystemColors();

	m_nMenuBorderSize = 1;

	CTagManager tm;

	if (!tm.LoadFromResource(GetStyleResourceID(), AFX_RT_STYLE_XML))
	{
#if !defined _AFXDLL
		TRACE(_T("\r\nImportant: to enable the Windows7 look in static link,\r\n"));
		TRACE(_T("include afxribbon.rc from the RC file in your project.\r\n\r\n"));
		ASSERT(FALSE);
#endif
		if (hinstResOld != NULL)
		{
			AfxSetResourceHandle(hinstResOld);
		}

		return;
	}

	{
		CString strStyle;
		tm.ExcludeTag(_T("STYLE"), strStyle);
		tm.SetBuffer(strStyle);
	}

	CString strItem;

	if (!tm.IsEmpty())
	{
		int nVersion = 0;

		if (tm.ExcludeTag(_T("VERSION"), strItem))
		{
			CTagManager tmItem(strItem);

			tmItem.ReadInt(_T("NUMBER"), nVersion);

			int nType = 20;
			if (nVersion == 2007)
			{
				tmItem.ReadInt(_T("TYPE"), nType);

				m_bLoaded = TRUE;
			}

			if (m_bLoaded)
			{
				if (tmItem.ExcludeTag(_T("ID_PREFIX"), strItem))
				{
					strItem.TrimLeft();
					strItem.TrimRight();
					m_strStylePrefix = strItem;
				}
			}
		}
	}

	if (!m_bLoaded)
	{
		if (hinstResOld != NULL)
		{
			::AfxSetResourceHandle(hinstResOld);
		}

		return;
	}

	// menu
	if (tm.ExcludeTag(_T("MENU"), strItem))
	{
		CTagManager tmItem(strItem);

		tmItem.ReadInt(_T("BorderSize"), m_nMenuBorderSize);

		tmItem.ReadControlRenderer(_T("ItemBack"), m_ctrlMenuItemBack, MakeResourceID(_T("IDB_MENU_ITEM_BACK")));
		tmItem.ReadToolBarImages (_T("ItemCheck"), m_MenuItemMarkerC, MakeResourceID(_T("IDB_MENU_ITEM_MARKER_C")));
		tmItem.ReadToolBarImages (_T("ItemRadio"), m_MenuItemMarkerR, MakeResourceID(_T("IDB_MENU_ITEM_MARKER_R")));
		tmItem.ReadControlRenderer(_T("Highlighted"), m_ctrlMenuHighlighted[0], MakeResourceID(_T("IDB_MENU_BTN")));
		tmItem.ReadControlRenderer(_T("HighlightedDisabled"), m_ctrlMenuHighlighted[1], MakeResourceID(_T("IDB_MENU_BTN_DISABLED")));
	}

	m_brMenuRarelyUsed.DeleteObject();
	m_brMenuRarelyUsed.CreateSolidBrush(m_clrMenuRarelyUsed);

	m_clrRibbonEdit            = afxGlobalData.clrWindow;
	m_clrRibbonEditHighlighted = afxGlobalData.clrWindow;
	m_clrRibbonEditPressed     = m_clrRibbonEditHighlighted;
	m_clrRibbonEditDisabled    = afxGlobalData.clrBtnFace;

	m_clrRibbonEditBorder            = afxGlobalData.clrWindow;
	m_clrRibbonEditBorderDisabled    = afxGlobalData.clrBtnShadow;
	m_clrRibbonEditBorderHighlighted = m_clrMenuItemBorder;
	m_clrRibbonEditBorderPressed     = m_clrRibbonEditBorderHighlighted;
	m_clrRibbonEditSelection         = afxGlobalData.clrHilite;

	m_clrRibbonBarBkgnd         = afxGlobalData.clrBarFace;
	m_clrRibbonBarGradientLight = afxGlobalData.clrBarLight;
	m_clrRibbonBarGradientDark  = m_clrRibbonBarGradientLight;

	// bars
	if (tm.ExcludeTag(_T("BARS"), strItem))
	{
		CTagManager tmItem(strItem);

		CString strBar;
		if (tmItem.ExcludeTag(_T("RIBBONBAR"), strBar))
		{
			CTagManager tmBar(strBar);

			tmBar.ReadColor(_T("Bkgnd"), m_clrRibbonBarBkgnd);
			tmBar.ReadColor(_T("GradientLight"), m_clrRibbonBarGradientLight);
			m_clrRibbonBarGradientDark = m_clrRibbonBarGradientLight;
			tmBar.ReadColor(_T("GradientDark"), m_clrRibbonBarGradientDark);
		}
	}

	m_brRibbonBarBkgnd.DeleteObject ();
	m_brRibbonBarBkgnd.CreateSolidBrush  (m_clrRibbonBarBkgnd);

	if (tm.ExcludeTag(_T("RIBBON"), strItem))
	{
		CTagManager tmItem(strItem);

		CString str;

		if (tmItem.ExcludeTag(_T("CATEGORY"), str))
		{
			CTagManager tmCategory(str);
			tmCategory.ReadControlRenderer(_T("BACK"), m_ctrlRibbonCategoryBack, MakeResourceID(_T("IDB_RIBBON_CATEGORY_BACK")));

			CString strTab;
			if (tmCategory.ExcludeTag(_T("TAB"), strTab))
			{
				CTagManager tmTab(strTab);
				tmTab.ReadControlRenderer(_T("BUTTON"), m_ctrlRibbonCategoryTab, MakeResourceID(_T("IDB_RIBBON_CATEGORY_TAB")));
			}

			tmCategory.ReadControlRenderer (_T("TAB_SEPARATOR"), m_ctrlRibbonCategoryTabSep, MakeResourceID(_T("IDB_RIBBON_CATEGORY_TAB_SEP")));

//			tmCategory.ReadControlRenderer (_T("BUTTON_PAGE_L"), m_ctrlRibbonCategoryBtnPage[0], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PAGE_L")));
//			tmCategory.ReadControlRenderer (_T("BUTTON_PAGE_R"), m_ctrlRibbonCategoryBtnPage[1], MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BTN_PAGE_R")));
		}

		if (tmItem.ExcludeTag(_T("PANEL"), str))
		{
			CTagManager tmPanel(str);

			{
				CString strBack;
				if (tmPanel.ExcludeTag(_T("BACK"), strBack))
				{
					CTagManager tmBack(strBack);
					tmBack.ReadControlRenderer(_T("SEPARATOR"), m_ctrlRibbonPanelBackSep, MakeResourceID(_T("IDB_RIBBON_PANEL_BACK_SEP")));
				}
			}

			{
				CString strCaption;
				if (tmPanel.ExcludeTag(_T("CAPTION"), strCaption))
				{
					CTagManager tmCaption(strCaption);

					tmCaption.ReadControlRenderer(_T("LAUNCH_BTN"), m_ctrlRibbonBtnLaunch, MakeResourceID(_T("IDB_RIBBON_BTN_LAUNCH")));
					tmCaption.ReadToolBarImages(_T("LAUNCH_ICON"), m_RibbonBtnLaunchIcon, MakeResourceID(_T("IDB_RIBBON_BTN_LAUNCH_ICON")));
					tmCaption.ReadColor(_T("TextNormal"), m_clrRibbonPanelCaptionText);
					tmCaption.ReadColor(_T("TextHighlighted"), m_clrRibbonPanelCaptionTextHighlighted);
				}
			}

			{
				CString strButtons;
				if (tmPanel.ExcludeTag(_T("BUTTONS"), strButtons))
				{
					CTagManager tmButtons(strButtons);

					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_F"), m_ctrlRibbonBtnGroup_F, MakeResourceID(_T("IDB_RIBBON_BTN_GROUP_F")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_M"), m_ctrlRibbonBtnGroup_M, MakeResourceID(_T("IDB_RIBBON_BTN_GROUP_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_L"), m_ctrlRibbonBtnGroup_L, MakeResourceID(_T("IDB_RIBBON_BTN_GROUP_L")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUP_S"), m_ctrlRibbonBtnGroup_S, MakeResourceID(_T("IDB_RIBBON_BTN_GROUP_S")));

					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_F_C"), m_ctrlRibbonBtnGroupMenu_F[0], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_F_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_F_M"), m_ctrlRibbonBtnGroupMenu_F[1], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_F_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_M_C"), m_ctrlRibbonBtnGroupMenu_M[0], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_M_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_M_M"), m_ctrlRibbonBtnGroupMenu_M[1], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_M_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_L_C"), m_ctrlRibbonBtnGroupMenu_L[0], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_L_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_GROUPMENU_L_M"), m_ctrlRibbonBtnGroupMenu_L[1], MakeResourceID(_T("IDB_RIBBON_BTN_GROUPMENU_L_M")));

					tmButtons.ReadControlRenderer(_T("BUTTON_NORMAL_S"), m_ctrlRibbonBtn[0], MakeResourceID(_T("IDB_RIBBON_BTN_NORMAL_S")));
					tmButtons.ReadControlRenderer(_T("BUTTON_NORMAL_B"), m_ctrlRibbonBtn[1], MakeResourceID(_T("IDB_RIBBON_BTN_NORMAL_B")));

					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT"), m_ctrlRibbonBtnDefault, MakeResourceID(_T("IDB_RIBBON_BTN_DEFAULT")));
					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT_ICON"), m_ctrlRibbonBtnDefaultIcon, MakeResourceID(_T("IDB_RIBBON_BTN_DEFAULT_ICON")));
					tmButtons.ReadToolBarImages(_T("BUTTON_DEFAULT_IMAGE"), m_RibbonBtnDefaultImage, MakeResourceID(_T("IDB_RIBBON_BTN_DEFAULT_IMAGE")));
					tmButtons.ReadControlRenderer(_T("BUTTON_DEFAULT_QAT"), m_ctrlRibbonBtnDefaultQAT, MakeResourceID(_T("IDB_RIBBON_BTN_DEFAULT_QAT")));

					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_H_C"), m_ctrlRibbonBtnMenuH[0], MakeResourceID(_T("IDB_RIBBON_BTN_MENU_H_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_H_M"), m_ctrlRibbonBtnMenuH[1], MakeResourceID(_T("IDB_RIBBON_BTN_MENU_H_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_V_C"), m_ctrlRibbonBtnMenuV[0], MakeResourceID(_T("IDB_RIBBON_BTN_MENU_V_C")));
					tmButtons.ReadControlRenderer(_T("BUTTON_MENU_V_M"), m_ctrlRibbonBtnMenuV[1], MakeResourceID(_T("IDB_RIBBON_BTN_MENU_V_M")));

					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_T"), m_ctrlRibbonBtnPalette[0], MakeResourceID(_T("IDB_RIBBON_BTN_PALETTE_T")));
					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_M"), m_ctrlRibbonBtnPalette[1], MakeResourceID(_T("IDB_RIBBON_BTN_PALETTE_M")));
					tmButtons.ReadControlRenderer(_T("BUTTON_PNL_B"), m_ctrlRibbonBtnPalette[2], MakeResourceID(_T("IDB_RIBBON_BTN_PALETTE_B")));
				}
			}

			{
				CString strEdit;
				if (tmPanel.ExcludeTag(_T("EDIT"), strEdit))
				{
					CTagManager tmEdit(strEdit);

					tmEdit.ReadColor(_T("Normal"), m_clrRibbonEdit);
					tmEdit.ReadColor(_T("Highlighted"), m_clrRibbonEditHighlighted);
					tmEdit.ReadColor(_T("Disabled"), m_clrRibbonEditDisabled);
					tmEdit.ReadColor(_T("Pressed"), m_clrRibbonEditPressed);

					tmEdit.ReadColor(_T("BorderNormal"), m_clrRibbonEditBorder);
					tmEdit.ReadColor(_T("BorderHighlighted"), m_clrRibbonEditBorderHighlighted);
					tmEdit.ReadColor(_T("BorderDisabled"), m_clrRibbonEditBorderDisabled);
					tmEdit.ReadColor(_T("BorderPressed"), m_clrRibbonEditBorderPressed);
					tmEdit.ReadColor(_T("Selection"), m_clrRibbonEditSelection);

					CString strButton;
					if (tmEdit.ExcludeTag(_T("BUTTON"), strButton))
					{
						CTagManager tmButton (strButton);
						tmButton.ReadControlRenderer(_T("IMAGE"), m_ctrlRibbonComboBoxBtn, MakeResourceID(_T("IDB_COMBOBOX_BTN")));
					}
				}
			}
		}


		tmItem.ReadControlRenderer(_T("MAIN_BUTTON"), m_ctrlRibbonBtnMain, MakeResourceID(_T("IDB_RIBBON_BTN_MAIN")));

		if (tmItem.ExcludeTag(_T("MAIN"), str))
		{
			CTagManager tmMain(str);

			tmMain.ReadControlRenderer(_T("BACK"), m_ctrlRibbonMainPanel, MakeResourceID(_T("IDB_RIBBON_PANEL_MAIN")));
			tmMain.ReadControlRenderer(_T("BUTTON"), m_ctrlRibbonBtnMainPanel, MakeResourceID(_T("IDB_RIBBON_BTN_PANEL_MAIN")));
		}

		if (tmItem.ExcludeTag(_T("CAPTION"), str))
		{
			CTagManager tmCaption(str);
			tmCaption.ReadControlRenderer(_T("QA"), m_ctrlRibbonCaptionQA, MakeResourceID(_T("IDB_RIBBON_CAPTION_QA")));
		}

		if (tmItem.ExcludeTag(_T("STATUS"), str))
		{
			CTagManager tmStatus(str);
			tmStatus.ReadControlRenderer(_T("PANE_BUTTON"), m_ctrlRibbonBtnStatusPane, MakeResourceID(_T("IDB_RIBBON_BTN_STATUS_PANE")));

			CString strSlider;
			if (tmStatus.ExcludeTag(_T("SLIDER"), strSlider))
			{
				CTagManager tmSlider(strSlider);

				tmSlider.ReadControlRenderer(_T("PLUS"), m_ctrlRibbonSliderBtnPlus, MakeResourceID(_T("IDB_RIBBON_SLIDER_BTN_PLUS")));
				tmSlider.ReadControlRenderer(_T("MINUS"), m_ctrlRibbonSliderBtnMinus, MakeResourceID(_T("IDB_RIBBON_SLIDER_BTN_MINUS")));
			}
		}

		if (tmItem.ExcludeTag(_T("BORDERS"), str))
		{
			CTagManager tmBorders(str);

			tmBorders.ReadControlRenderer(_T("QAT"), m_ctrlRibbonBorder_QAT, MakeResourceID(_T("IDB_RIBBON_BORDER_QAT")));
			//tmBorders.ReadControlRenderer (_T("FLOATY"), m_ctrlRibbonBorder_Floaty, MakeResourceID(_T("IDB_OFFICE2007_RIBBON_BORDER_FLOATY")));
		}
	}

	if (hinstResOld != NULL)
	{
		AfxSetResourceHandle(hinstResOld);
	}


	NONCLIENTMETRICS ncm;
	afxGlobalData.GetNonClientMetrics(ncm);
	m_AppCaptionFont.CreateFontIndirect(&ncm.lfCaptionFont);

	m_penSeparatorDark.CreatePen(PS_SOLID, 0, RGB (198, 212, 227));
	m_penSeparatorLight.CreatePen(PS_SOLID, 0, RGB (237, 243, 248));
}

void CMFCVisualManagerWindows7::OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, BOOL bHighlight, BOOL bIsRadio)
{
	ASSERT_VALID(pButton);

    CMFCToolBarImages& img = bIsRadio ? m_MenuItemMarkerR : m_MenuItemMarkerC;

	if (!CanDrawImage() || img.GetCount() == 0)
	{
		CMFCVisualManagerWindows::OnDrawMenuCheck(pDC, pButton, rect, bHighlight, bIsRadio);
		return;
	}

    CSize size(img.GetImageSize());
    CRect rectImage(0, 0, size.cx, size.cy);

    if ((pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED)
    {
        rectImage.OffsetRect(0, size.cy);
    }

	if (afxGlobalData.m_bIsRTL)
	{
		img.Mirror();
	}

    img.DrawEx(pDC, rect, 0, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter, rectImage);

	if (afxGlobalData.m_bIsRTL)
	{
		img.Mirror();
	}
}

void CMFCVisualManagerWindows7::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawMenuBorder(pDC, pMenu, rect);
		return;
	}

	if (pMenu != NULL)
	{
		CMFCRibbonPanelMenuBar* pRibbonMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, pMenu->GetMenuBar());

		if (pRibbonMenuBar != NULL)
		{
			ASSERT_VALID(pRibbonMenuBar);

			if (pRibbonMenuBar->IsMainPanel())
			{
				if (m_ctrlRibbonMainPanel.IsValid())
				{
					m_ctrlRibbonMainPanel.DrawFrame(pDC, rect);
				}

				return;
			}

			if (!pRibbonMenuBar->IsMenuMode())
			{
				if (pRibbonMenuBar->IsQATPopup() && m_ctrlRibbonBorder_QAT.IsValid())
				{
					m_ctrlRibbonBorder_QAT.DrawFrame(pDC, rect);
					return;
				}
				else if (pRibbonMenuBar->IsCategoryPopup())
				{
					return;
				}
				else if (pRibbonMenuBar->IsRibbonMiniToolBar() /*&& m_ctrlRibbonBorder_Floaty.IsValid()*/)
				{
/*
					m_ctrlRibbonBorder_Floaty.DrawFrame (pDC, rect);
					return;
*/
				}
				else
				{
					if (pRibbonMenuBar->GetPanel() != NULL)
					{
						return;
					}
				}
			}
		}
	}
/*
	CBasePane* pTopLevelBar = NULL;

	for (CMFCPopupMenu* pParentMenu = pMenu; pParentMenu != NULL; pParentMenu = pParentMenu->GetParentPopupMenu())
	{
		CMFCToolBarMenuButton* pParentButton = pParentMenu->GetParentButton();
		if (pParentButton == NULL)
		{
			break;
		}

		pTopLevelBar = DYNAMIC_DOWNCAST(CBasePane, pParentButton->GetParentWnd());
	}

	if (pTopLevelBar == NULL || pTopLevelBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		m_ctrlPopupBorder.DrawFrame(pDC, rect);
	}
	else
	{
		CMFCVisualManagerWindows::OnDrawMenuBorder(pDC, pMenu, rect);
	}
*/

	CMFCVisualManagerWindows::OnDrawMenuBorder (pDC, pMenu, rect);
}

void CMFCVisualManagerWindows7::OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnHighlightMenuItem(pDC, pButton, rect, clrText);
		return;
	}

	clrText = afxGlobalData.clrMenuText;
	m_ctrlMenuHighlighted[(pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED ? 1 : 0].Draw(pDC, rect);
}

void CMFCVisualManagerWindows7::OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rectCaption, CRect rectText)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonCaption(pDC, pBar, rectCaption, rectText);
		return;
	}

	CWnd* pWnd = pBar->GetParent ();
	ASSERT_VALID (pWnd);

	const DWORD dwStyleEx = pWnd->GetExStyle();

	const BOOL bIsRTL     = (dwStyleEx & WS_EX_LAYOUTRTL) == WS_EX_LAYOUTRTL;
	const BOOL bActive = IsWindowActive(pWnd);
	const BOOL bGlass  = pBar->IsTransparentCaption();

	{
		CSize szSysBorder(GetSystemBorders(TRUE));

		if (!bGlass)
		{
			CRect rectCaption1(rectCaption);
			rectCaption1.InflateRect(szSysBorder.cx, szSysBorder.cy, szSysBorder.cx, 0);

			if (m_hThemeWindow != NULL)
			{
				(*m_pfDrawThemeBackground)(m_hThemeWindow, pDC->GetSafeHdc(), WP_CAPTION, bActive ? CS_ACTIVE : CS_INACTIVE, &rectCaption1, 0);
			}
			else
			{
				CDrawingManager dm(*pDC);
				dm.FillGradient(rectCaption1, bActive ? afxGlobalData.clrActiveCaption : afxGlobalData.clrInactiveCaption, bActive ? afxGlobalData.clrActiveCaptionGradient : afxGlobalData.clrInactiveCaptionGradient, FALSE);
			}
		}

		CRect rectQAT = pBar->GetQuickAccessToolbarLocation();

		if (rectQAT.left > rectQAT.right)
		{
			rectText.left = rectQAT.left + 1;
		}

		BOOL bHide  = (pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ALL) != 0;
		BOOL bExtra = !bHide && pBar->IsQuickAccessToolbarOnTop() && rectQAT.left < rectQAT.right && !pBar->IsQATEmpty();

		BOOL bDrawIcon = (bHide && !bExtra) || pBar->IsWindows7Look();

		if (bExtra)
		{
			CRect rectQAFrame(rectQAT);
			rectQAFrame.right = rectText.left - 6;
			rectQAFrame.InflateRect(1, 1, 1, 1);

			const CMFCControlRendererInfo& params = m_ctrlRibbonCaptionQA.GetParams();

			if (rectQAFrame.Height() < params.m_rectImage.Height())
			{
				rectQAFrame.top = rectQAFrame.bottom - params.m_rectImage.Height();
			}

			m_ctrlRibbonCaptionQA.Draw(pDC, rectQAFrame, bActive ? 0 : 1);
		}

		if (bDrawIcon)
		{
			HICON hIcon = afxGlobalUtils.GetWndIcon(pWnd);

			if (hIcon != NULL)
			{
				CSize szIcon(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));

				long x = rectCaption.left + 2;
				long y = rectCaption.top  + max(0, (rectCaption.Height() - szIcon.cy) / 2);

				pDC->DrawState(CPoint(x, y), szIcon, hIcon, DSS_NORMAL, (CBrush*)NULL);

				if (rectText.left < (x + szIcon.cx + 4))
				{
					rectText.left = x + szIcon.cx + 4;
				}
			}
		}
	}

	CString strText;
	pWnd->GetWindowText(strText);

	CFont* pOldFont = (CFont*)pDC->SelectObject(&m_AppCaptionFont);
	ASSERT(pOldFont != NULL);

	DrawNcText(pDC, rectText, strText, bActive, bIsRTL, FALSE, bGlass, pWnd->IsZoomed() ? 0 : 10, pWnd->IsZoomed() ? RGB(255, 255, 255) :(COLORREF)-1);

	pDC->SelectObject(pOldFont);
}

void CMFCVisualManagerWindows7::OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	const BOOL bHighlighted = pButton->IsHighlighted() || pButton->IsFocused();
	const BOOL bPressed = pButton->IsPressed();

	AFX_BUTTON_STATE state = ButtonsIsRegular;
	if (bPressed)
	{
		if (bHighlighted)
		{
			state = ButtonsIsPressed;
		}
	}
	else if (bHighlighted)
	{
		state = ButtonsIsHighlighted;
	}

	const BOOL bMDI = pButton->IsMDIChildButton();
	BOOL bActive = TRUE;

	if (!bMDI)
	{
		CMFCRibbonBar* pBar = pButton->GetParentRibbonBar();
		if (pBar->GetSafeHwnd() != NULL)
		{
			CWnd* pWnd = pBar->GetParent();
			ASSERT_VALID(pWnd);

			bActive = IsWindowActive(pWnd);
		}
	}

	CRect rect(pButton->GetRect());
	rect.DeflateRect(m_hThemeWindow == NULL ? 1 : 2, m_hThemeWindow == NULL ? 1 : 2);

	DrawNcBtn(pDC, rect, pButton->GetID(), state, FALSE, bActive, bMDI);
}

COLORREF CMFCVisualManagerWindows7::OnDrawRibbonPanel(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectPanel, CRect rectCaption)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::OnDrawRibbonPanel(pDC, pPanel, rectPanel, rectCaption);
	}

	ASSERT_VALID (pDC);
	ASSERT_VALID (pPanel);

	if (pPanel->IsKindOf(RUNTIME_CLASS(CMFCRibbonMainPanel)))
	{
		const int nBorderSize = GetPopupMenuBorderSize();
		rectPanel.InflateRect(nBorderSize, nBorderSize);
		
		m_ctrlRibbonMainPanel.Draw(pDC, rectPanel);
	}
	else
	{
		if (!pPanel->IsMenuMode () && !pPanel->IsCollapsed())
		{
			int nWidth = m_ctrlRibbonPanelBackSep.GetParams().m_rectImage.Width();
			int nWidth2 = nWidth / 2;

			rectPanel.left = rectPanel.right - nWidth2;
			rectPanel.right += (nWidth - nWidth2);
			rectPanel.DeflateRect(0, 4);

			m_ctrlRibbonPanelBackSep.Draw(pDC, rectPanel);
		}
	}

	return afxGlobalData.clrBarText;
}

void CMFCVisualManagerWindows7::OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonPanelCaption(pDC, pPanel, rectCaption);
		return;
	}

	if (pPanel->IsKindOf(RUNTIME_CLASS(CMFCRibbonMainPanel)))
	{
		return;
	}

	CString str = pPanel->GetName();

	if (!str.IsEmpty())
	{
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
		if (pPanel->GetLaunchButton().GetID() > 0)
		{
			rectCaption.right = pPanel->GetLaunchButton().GetRect().left;

			rectCaption.DeflateRect(1, 1);
			rectCaption.OffsetRect(-1, -1);
		}
		else
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
		{
			rectCaption.DeflateRect(1, 1);

			if ((rectCaption.Width() % 2) == 0)
			{
				rectCaption.right--;
			}

			rectCaption.OffsetRect(0, -1);
		}

		COLORREF clrTextOld = pDC->SetTextColor(pPanel->IsHighlighted() ? m_clrRibbonPanelCaptionTextHighlighted : m_clrRibbonPanelCaptionText);

		pDC->DrawText( str, rectCaption, DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX);
		pDC->SetTextColor(clrTextOld);
	}
}

void CMFCVisualManagerWindows7::OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pCategory);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonCategory(pDC, pCategory, rectCategory);
		return;
	}

	CMFCControlRenderer* pRenderer = &m_ctrlRibbonCategoryBack;
	CMFCVisualManagerBitmapCache* pCache = &m_cacheRibbonCategoryBack;
/*
	CMFCRibbonBaseElement* pParentButton = pCategory->GetParentButton();

	if (pCategory->GetTabColor() != AFX_CategoryColor_None && (pParentButton == NULL || !pParentButton->IsQATMode()))
	{
		CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[pCategory->GetTabColor() - 1];

		pRenderer = &context.m_ctrlBack;
		pCache    = &context.m_cacheBack;
	}
*/
	const CMFCControlRendererInfo& params = pRenderer->GetParams();

	CMFCRibbonPanelMenuBar* pMenuBar = pCategory->GetParentMenuBar();
	if (pMenuBar != NULL)
	{
		if (pMenuBar->GetCategory() != NULL)
		{
			if (rectCategory.left < 0 || rectCategory.top < 0)
			{
				CDrawingManager dm(*pDC);
				dm.FillGradient(rectCategory, m_clrRibbonBarGradientDark, m_clrRibbonBarGradientLight, TRUE);

				return;
			}
		}
	}

	int nCacheIndex = -1;
	if (pCache != NULL)
	{
		CSize size(params.m_rectImage.Width(), rectCategory.Height());
		nCacheIndex = pCache->FindIndex(size);
		if (nCacheIndex == -1)
		{
			nCacheIndex = pCache->CacheY(size.cy, *pRenderer);
		}
	}

	if (nCacheIndex != -1)
	{
		pCache->Get(nCacheIndex)->DrawY(pDC, rectCategory, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right));
	}
	else
	{
		pRenderer->Draw(pDC, rectCategory);
	}
}

COLORREF CMFCVisualManagerWindows7::OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTab);

	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::OnDrawRibbonCategoryTab (pDC, pTab, bIsActive);
	}

	CMFCRibbonCategory* pCategory = pTab->GetParentCategory();
	ASSERT_VALID(pCategory);
	CMFCRibbonBar* pBar = pCategory->GetParentRibbonBar();
	ASSERT_VALID(pBar);

	bIsActive = bIsActive && ((pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS) == 0 || pTab->GetDroppedDown() != NULL);

	const BOOL bPressed       = pTab->IsPressed();
	const BOOL bIsFocused	  = pTab->IsFocused() &&(pBar->GetHideFlags() & AFX_RIBBONBAR_HIDE_ELEMENTS);
	const BOOL bIsHighlighted = (pTab->IsHighlighted() || bIsFocused) && !pTab->IsDroppedDown();

	CRect rectTab(pTab->GetRect());
	rectTab.bottom++;

	int ratio = 0;
	if (m_ctrlRibbonCategoryTabSep.IsValid())
	{
		ratio = pBar->GetTabTruncateRatio();
	}

	if (ratio > 0)
	{
		rectTab.left++;
	}

	int nImage = bIsActive ? 3 : 0;

	if (bPressed)
	{
		if (bIsHighlighted)
		{
			nImage = bIsActive ? 2 : 1;
		}
	}
	
	if(bIsHighlighted)
	{
		nImage += 1;
	}

	CMFCControlRenderer* pRenderer = &m_ctrlRibbonCategoryTab;
/*
	COLORREF clrText = m_clrRibbonCategoryText;
	COLORREF clrTextHighlighted = m_clrRibbonCategoryTextHighlighted;

	if (pCategory->GetTabColor() != AFX_CategoryColor_None || pTab->IsSelected())
	{
		CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[(pTab->IsSelected() || nImage == 4) ? AFX_CategoryColor_Orange - 1 : pCategory->GetTabColor() - 1];
		pRenderer = &context.m_ctrlTab;
		clrText  = context.m_clrText;
		clrTextHighlighted = context.m_clrTextHighlighted;
	}
*/
	pRenderer->Draw(pDC, rectTab, nImage);

	if (ratio > 0)
	{
		CRect rectSep(rectTab);
		rectSep.left = rectSep.right;
		rectSep.right++;
		rectSep.bottom--;

		m_ctrlRibbonCategoryTabSep.Draw(pDC, rectSep, 0, (BYTE)min(ratio * 255 / 100, 255));
	}

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManagerWindows7::OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* pWndRibbonBar, CRect rectTab)
{
	UNREFERENCED_PARAMETER(pDC);
	UNREFERENCED_PARAMETER(pWndRibbonBar);
	UNREFERENCED_PARAMETER(rectTab);

	return(COLORREF)-1;
}

void CMFCVisualManagerWindows7::OnFillMenuImageRect(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnFillMenuImageRect(pDC, pButton, rect, state);
		return;
	}

	OnFillButtonInterior(pDC, pButton, rect, state);
}

void CMFCVisualManagerWindows7::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnFillButtonInterior(pDC, pButton, rect, state);
		return;
	}

	CMFCCustomizeButton* pCustButton = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pButton);

	if (pCustButton == NULL)
	{
		if (CMFCToolBar::IsCustomizeMode() && 
			!CMFCToolBar::IsAltCustomizeMode() && !pButton->IsLocked())
		{
			return;
		}

		CMFCControlRenderer* pRenderer = NULL;
		int index = 0;

		BOOL bDisabled = (pButton->m_nStyle & TBBS_DISABLED) == TBBS_DISABLED;
		//BOOL bPressed  = (pButton->m_nStyle & TBBS_PRESSED ) == TBBS_PRESSED;
		BOOL bChecked  = (pButton->m_nStyle & TBBS_CHECKED ) == TBBS_CHECKED;

		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, pButton->GetParentWnd());

		CMFCToolBarMenuButton* pMenuButton = 
			DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
		if (pMenuButton != NULL && pBar != NULL)
		{
			if (pBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)) == NULL && pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
			{
				if (bChecked)
				{
					pRenderer = &m_ctrlMenuItemBack;

					if (bDisabled)
					{
						index = 1;
					}

					rect.InflateRect(0, 0, 0, 1);
				}
				else if (state == ButtonsIsPressed || state == ButtonsIsHighlighted)
				{
					pRenderer = &m_ctrlMenuHighlighted[bDisabled ? 1 : 0];
				}
				else
				{
					return;
				}
			}
		}

		if (pRenderer != NULL)
		{
			pRenderer->Draw(pDC, rect, index);
			return;
		}
	}

	CMFCVisualManagerWindows::OnFillButtonInterior(pDC, pButton, rect, state);
}

void CMFCVisualManagerWindows7::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	if (CanDrawImage() && pMenuButton != NULL && pMenuButton->GetParentWnd () != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		return;
	}

	CMFCVisualManagerWindows::OnDrawButtonBorder(pDC, pButton, rect, state);
}

void CMFCVisualManagerWindows7::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnFillBarBackground (pDC, pBar, rectClient, rectClip, bNCArea);
		return;
	}

	if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonStatusBar)))
	{
		if (m_hThemeWindow != NULL)
		{
			(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), 0, 0, &rectClient, 0);
			return;
		}
	}
	else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonBar)))
	{
		CDrawingManager dm(*pDC);
		dm.FillGradient(rectClient, m_clrRibbonBarGradientDark, m_clrRibbonBarGradientLight, TRUE);

		return;
	}

	CMFCVisualManagerWindows::OnFillBarBackground(pDC, pBar, rectClient, rectClip, bNCArea);
}

void CMFCVisualManagerWindows7::OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox)
{
	if (!CanDrawImage() || m_hThemeStatusBar == NULL)
	{
		CMFCVisualManagerWindows::OnDrawStatusBarSizeBox(pDC, pStatBar, rectSizeBox);
		return;
	}

	(*m_pfDrawThemeBackground)(m_hThemeStatusBar, pDC->GetSafeHdc(), SP_GRIPPER, 0, &rectSizeBox, 0);
}

void CMFCVisualManagerWindows7::OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonGalleryButton(pDC, pButton);
		return;
	}

	int index = 0;
	if (pButton->IsDisabled())
	{
		index = 3;
	}
	else
	{
		if (pButton->IsPressed())
		{
			if (pButton->IsHighlighted())
			{
				index = 2;
			}
		}
		else if (pButton->IsHighlighted() || pButton->IsFocused())
		{
			index = 1;
		}
	}

	int nBtn = 1;
	if (pButton->IsLast())
	{
		nBtn = 2;
	}
	else if (pButton->IsFirst())
	{
		nBtn = 0;
	}

	m_ctrlRibbonBtnPalette[nBtn].Draw(pDC, pButton->GetRect(), index);
}

COLORREF CMFCVisualManagerWindows7::OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);
	ASSERT_VALID(pPane);

	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::OnDrawRibbonStatusBarPane(pDC, pBar, pPane);
	}

	CRect rectPane = pPane->GetRect();

	const BOOL bHighlighted = pPane->IsHighlighted() || pPane->IsFocused();
	const BOOL bChecked     = pPane->IsChecked();

	if (bHighlighted || bChecked)
	{
		CRect rectButton = rectPane;
		rectButton.DeflateRect(1, 1);

		int index = 0;
		if (pPane->IsPressed())
		{
			if (bHighlighted)
			{
				index = 1;
			}
		}
		else if (bChecked)
		{
			if (bHighlighted)
			{
				index = 0;
			}
			else
			{
				index = 1;
			}
		}

		m_ctrlRibbonBtnStatusPane.Draw(pDC, rectButton, index);
	}

	return(COLORREF)-1;
}

void CMFCVisualManagerWindows7::OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	UNREFERENCED_PARAMETER(pSlider);
	UNREFERENCED_PARAMETER(bIsHighlighted);
	UNREFERENCED_PARAMETER(bIsPressed);

	ASSERT_VALID(pDC);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonSliderZoomButton(pDC, pSlider, rect, bIsZoomOut, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	CMFCControlRenderer* pRenderer = bIsZoomOut ? &m_ctrlRibbonSliderBtnMinus : &m_ctrlRibbonSliderBtnPlus;

	int index = 0;
	if (bIsDisabled)
	{
		index = 3;
	}
	else
	{
		if (bIsPressed)
		{
			if (bIsHighlighted)
			{
				index = 2;
			}
		}
		else if (bIsHighlighted)
		{
			index = 1;
		}
	}

	pRenderer->FillInterior(pDC, rect, afxGlobalData.GetRibbonImageScale() != 1. ? CMFCToolBarImages::ImageAlignHorzStretch : CMFCToolBarImages::ImageAlignHorzCenter, afxGlobalData.GetRibbonImageScale() != 1. ? CMFCToolBarImages::ImageAlignVertStretch : CMFCToolBarImages::ImageAlignVertCenter, index);
}

void CMFCVisualManagerWindows7::OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect)
{
	if (m_hThemeTrack == NULL)
	{
		CMFCVisualManagerWindows::OnDrawRibbonSliderChannel(pDC, pSlider, rect);
		return;
	}

	ASSERT_VALID(pDC);

	BOOL bVert = FALSE;

	if (bVert)
	{
		if (rect.Width() < 3)
		{
			rect.right++;
		}
	}
	else
	{
		if (rect.Height() < 3)
		{
			rect.bottom++;
		}
	}

	(*m_pfDrawThemeBackground)(m_hThemeTrack, pDC->GetSafeHdc(), bVert ? TKP_TRACKVERT : TKP_TRACK, 1, &rect, 0);
}

void CMFCVisualManagerWindows7::OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled)
{
	if (m_hThemeTrack == NULL)
	{
		CMFCVisualManagerWindows::OnDrawRibbonSliderThumb(pDC, pSlider, rect, bIsHighlighted, bIsPressed, bIsDisabled);
		return;
	}

	ASSERT_VALID(pDC);

	int nPart = 0;
	int nState = 0;

	BOOL bVert = FALSE;
	BOOL bLeftTop = FALSE;
	BOOL bRightBottom = TRUE;

	if (bLeftTop && bRightBottom)
	{
		nPart = bVert ? TKP_THUMBVERT : TKP_THUMB;
	}
	else if (bLeftTop)
	{
		nPart = bVert ? TKP_THUMBLEFT : TKP_THUMBTOP;
	}
	else
	{
		nPart = bVert ? TKP_THUMBRIGHT : TKP_THUMBBOTTOM;
	}

	if (bIsDisabled)
	{
		nState = TUS_DISABLED;
	}
	else if (bIsPressed)
	{
		nState = TUS_PRESSED;
	}
	else if (bIsHighlighted)
	{
		nState = TUS_HOT;
	}
	else
	{
		nState = TUS_NORMAL;
	}

	(*m_pfDrawThemeBackground)(m_hThemeTrack, pDC->GetSafeHdc(), nPart, nState, &rect, 0);
}

void CMFCVisualManagerWindows7::OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode)
{
	if (m_hThemeProgress == NULL)
	{
		CMFCVisualManagerWindows::OnDrawRibbonProgressBar(pDC, pProgress, rectProgress, rectChunk, bInfiniteMode);
		return;
	}

	(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_BAR, 0, &rectProgress, 0);

	if (!bInfiniteMode)
	{
		if (!rectChunk.IsRectEmpty() || pProgress->GetPos() != pProgress->GetRangeMin())
		{
			(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_CHUNK, 0, &rectChunk, 0);
		}
	}
	else if (pProgress->GetPos() != pProgress->GetRangeMin())
	{
		CRgn rgn;
		rgn.CreateRectRgnIndirect(rectProgress);
		pDC->SelectClipRgn(&rgn);

		double index = (pProgress->GetPos() - pProgress->GetRangeMin()) * 2.0 / double(pProgress->GetRangeMax() - pProgress->GetRangeMin());

		rectProgress.OffsetRect((int)(rectProgress.Width() *(index - 1.0)), 0);

		(*m_pfDrawThemeBackground)(m_hThemeProgress, pDC->GetSafeHdc(), PP_MOVEOVERLAY, 0, &rectProgress, 0);

		pDC->SelectClipRgn(NULL);
	}
}

void CMFCVisualManagerWindows7::OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled/* = FALSE*/, BOOL bIsPressed/* = FALSE*/, BOOL bIsHighlighted/* = FALSE*/)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawDefaultRibbonImage(pDC, rectImage, bIsDisabled, bIsPressed, bIsHighlighted);
		return;
	}

	m_RibbonBtnDefaultImage.DrawEx(pDC, rectImage, bIsDisabled ? 1 : 0,	CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
}

void CMFCVisualManagerWindows7::OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonApplicationButton(pDC, pButton);
		return;
	}

	BOOL bIsHighlighted = pButton->IsHighlighted() || pButton->IsFocused();
	BOOL bIsPressed = pButton->IsPressed() || pButton->IsDroppedDown();

	if (pButton->IsDroppedDown())
	{
		bIsPressed = TRUE;
		bIsHighlighted = TRUE;
	}

	CRect rect = pButton->GetRect();

	int index = 0;
	if (bIsPressed)
	{
		if (bIsHighlighted)
		{
			index = 2;
		}
	}
	else if (bIsHighlighted)
	{
		index = 1;
	}

	m_ctrlRibbonBtnMain.Draw(pDC, pButton->GetRect(), index);
}

void CMFCVisualManagerWindows7::OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled)
{
	if (m_hThemeButton == NULL)
	{
		CMFCVisualManager::OnDrawCheckBoxEx(pDC, rect, nState, bHighlighted, bPressed, bEnabled);
		return;
	}

	DrawCheckBox(pDC, rect, bHighlighted, nState, bEnabled, bPressed);
}

void CMFCVisualManagerWindows7::OnDrawRadioButton(CDC *pDC, CRect rect, BOOL bOn, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled)
{
	DrawRadioButton(pDC, rect, bHighlighted, bOn, bEnabled, bPressed);
}

void CMFCVisualManagerWindows7::OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonButtonBorder(pDC, pButton);
		return;
	}

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		CRect rect(pButton->GetRect());

		COLORREF colorBorder = m_clrRibbonEditBorder;

		if (pButton->IsDisabled())
		{
			colorBorder = m_clrRibbonEditBorderDisabled;
		}
		else if (pButton->IsHighlighted() || pButton->IsDroppedDown() || pButton->IsFocused())
		{
			colorBorder = pButton->IsDroppedDown() ? m_clrRibbonEditBorderPressed : m_clrRibbonEditBorderHighlighted;
		}

		rect.left = pButton->GetCommandRect().left;

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, (COLORREF)-1, colorBorder);
		}
		else
		{
			pDC->Draw3dRect(rect, colorBorder, colorBorder);
		}
	}
}

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
void CMFCVisualManagerWindows7::OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pPanel);

	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonLaunchButton(pDC, pButton, pPanel);
		return;
	}

	CRect rect(pButton->GetRect());
	rect.right--;
	rect.bottom--;

	BOOL bHighlighted = pButton->IsHighlighted() || pButton->IsFocused();

	int index = 0;

	if (m_RibbonBtnLaunchIcon.GetCount() > 3)
	{
		if (pButton->IsDisabled())
		{
			index = 3;
		}
		else if (pButton->IsPressed())
		{
			if (bHighlighted)
			{
				index = 2;
			}
		}
		else if (bHighlighted)
		{
			index = 1;
		}
	}
	else
	{
		if (!pButton->IsDisabled())
		{
			if (pButton->IsPressed())
			{
				if (bHighlighted)
				{
					index = 2;
				}
			}
			else if (bHighlighted)
			{
				index = 1;
			}
		}
	}

	if (m_ctrlRibbonBtnLaunch.IsValid())
	{
		m_ctrlRibbonBtnLaunch.Draw(pDC, rect, index);
	}

	if (m_RibbonBtnLaunchIcon.IsValid())
	{
		const double dblImageScale = afxGlobalData.GetRibbonImageScale();

		if (dblImageScale == 1.)
		{
			m_RibbonBtnLaunchIcon.DrawEx(pDC, rect, index, CMFCToolBarImages::ImageAlignHorzCenter, CMFCToolBarImages::ImageAlignVertCenter);
		}
		else
		{
			CSize sizeImage = m_RibbonBtnLaunchIcon.GetImageSize();

			sizeImage.cx = (int)(.5 + dblImageScale * sizeImage.cx);
			sizeImage.cy = (int)(.5 + dblImageScale * sizeImage.cy);

			rect.left = rect.CenterPoint().x - sizeImage.cx / 2;
			rect.right = rect.left + sizeImage.cx;

			rect.top = rect.CenterPoint().y - sizeImage.cy / 2;
			rect.bottom = rect.top + sizeImage.cy;

			m_RibbonBtnLaunchIcon.DrawEx(pDC, rect, index, CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertStretch);
		}
	}
}
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

COLORREF CMFCVisualManagerWindows7::OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::OnFillRibbonButton(pDC, pButton);
	}

	const BOOL bIsMenuMode = pButton->IsMenuMode();

	CRect rect(pButton->GetRect());

	CMFCControlRenderer* pRenderer = NULL;
	CMFCVisualManagerBitmapCache* pCache = NULL;
	int index = 0;

	BOOL bDisabled    = pButton->IsDisabled();
	BOOL bWasDisabled = bDisabled;
	BOOL bFocused     = pButton->IsFocused();
	BOOL bDroppedDown = pButton->IsDroppedDown();
	BOOL bPressed     = pButton->IsPressed() && !bIsMenuMode;
	BOOL bChecked     = pButton->IsChecked();
	BOOL bHighlighted = pButton->IsHighlighted() || bFocused;

	BOOL bDefaultPanelButton = pButton->IsDefaultPanelButton() && !pButton->IsQATMode();
	if (bFocused)
	{
		bDisabled = FALSE;
	}

	if (pButton->IsDroppedDown() && !bIsMenuMode)
	{
		bChecked     = TRUE;
		bPressed     = FALSE;
		bHighlighted = FALSE;
	}

	CMFCRibbonBaseElement::RibbonElementLocation location = pButton->GetLocationInGroup();

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		COLORREF color1 = m_clrRibbonEdit;
		if (bDisabled)
		{
			color1 = m_clrRibbonEditDisabled;
		}
		else if (bChecked || bHighlighted)
		{
			color1 = m_clrRibbonEditHighlighted;
		}

		COLORREF color2 = color1;

		rect.left = pButton->GetCommandRect().left;

		{
			CDrawingManager dm(*pDC);
			dm.FillGradient(rect, color1, color2, TRUE);
		}

		return (COLORREF)-1;
	}

	if (bChecked && bIsMenuMode && !pButton->IsGalleryIcon())
	{
		bChecked = FALSE;
	}

	if (location != CMFCRibbonBaseElement::RibbonElementNotInGroup && pButton->IsShowGroupBorder())
	{
		if (!pButton->GetMenuRect().IsRectEmpty())
		{
			CRect rectC = pButton->GetCommandRect();
			CRect rectM = pButton->GetMenuRect();

			CMFCControlRenderer* pRendererC = NULL;
			CMFCControlRenderer* pRendererM = NULL;

			CMFCVisualManagerBitmapCache* pCacheC = NULL;
			CMFCVisualManagerBitmapCache* pCacheM = NULL;

			if (location == CMFCRibbonBaseElement::RibbonElementSingleInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_F[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_L[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_F[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_L[1];
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementFirstInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_F[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_F[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_F[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_F[1];
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementLastInGroup)
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_L[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_L[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_L[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_L[1];
			}
			else
			{
				pRendererC = &m_ctrlRibbonBtnGroupMenu_M[0];
				pRendererM = &m_ctrlRibbonBtnGroupMenu_M[1];

				pCacheC = &m_cacheRibbonBtnGroupMenu_M[0];
				pCacheM = &m_cacheRibbonBtnGroupMenu_M[1];
			}

			int indexC = 0;
			int indexM = 0;

			BOOL bHighlightedC = pButton->IsCommandAreaHighlighted();
			BOOL bHighlightedM = pButton->IsMenuAreaHighlighted();

			if (bChecked)
			{
				indexC = 3;

				if (bHighlighted)
				{
					indexM = 5;
				}
			}

			if (bDisabled)
			{
				if (bChecked)
				{
					indexC = 5;
					indexM = 4;
				}
			}
			else
			{
				if (pButton->IsDroppedDown() && !bIsMenuMode)
				{
					indexC = pButton->IsChecked() ? 3 : 6;
					indexM = 3;
				}
				else
				{
					if (bFocused)
					{
						indexC = 6;
						indexM = 5;
					}

					if (bHighlightedC || bHighlightedM)
					{
						if (bChecked)
						{
							indexC = bHighlightedC ? 4 : 3;
						}
						else
						{
							indexC = bHighlightedC ? 1 : 6;
						}

						indexM = bHighlightedM ? 1 : 5;
					}

					if (bPressed)
					{
						if (bHighlightedC)
						{
							indexC = 2;
						}
					}
				}
			}

			if (indexC != -1 && indexM != -1)
			{
				int nCacheIndex = -1;
				if (pCacheC != NULL)
				{
					CSize size(rectC.Size());
					nCacheIndex = pCacheC->FindIndex(size);
					if (nCacheIndex == -1)
					{
						nCacheIndex = pCacheC->Cache(size, *pRendererC);
					}
				}

				if (nCacheIndex != -1)
				{
					pCacheC->Get(nCacheIndex)->Draw(pDC, rectC, indexC);
				}
				else
				{
					pRendererC->Draw(pDC, rectC, indexC);
				}

				nCacheIndex = -1;
				if (pCacheM != NULL)
				{
					CSize size(rectM.Size());
					nCacheIndex = pCacheM->FindIndex(size);
					if (nCacheIndex == -1)
					{
						nCacheIndex = pCacheM->Cache(size, *pRendererM);
					}
				}

				if (nCacheIndex != -1)
				{
					pCacheM->Get(nCacheIndex)->Draw(pDC, rectM, indexM);
				}
				else
				{
					pRendererM->Draw(pDC, rectM, indexM);
				}
			}

			return(COLORREF)-1;
		}
		else
		{
			if (location == CMFCRibbonBaseElement::RibbonElementSingleInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_S;
				pCache    = &m_cacheRibbonBtnGroup_S;
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementFirstInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_F;
				pCache    = &m_cacheRibbonBtnGroup_F;
			}
			else if (location == CMFCRibbonBaseElement::RibbonElementLastInGroup)
			{
				pRenderer = &m_ctrlRibbonBtnGroup_L;
				pCache    = &m_cacheRibbonBtnGroup_L;
			}
			else
			{
				pRenderer = &m_ctrlRibbonBtnGroup_M;
				pCache    = &m_cacheRibbonBtnGroup_M;
			}

			if (bChecked)
			{
				index = 3;
			}

			if (bDisabled && !bFocused)
			{
				index = 0;
			}
			else
			{
				if (bPressed)
				{
					if (bHighlighted)
					{
						index = 2;
					}
				}
				else if (bHighlighted)
				{
					index++;
				}
			}
		}
	}
	else if (bDefaultPanelButton)
	{
		if (bPressed)
		{
			if (bHighlighted)
			{
				index = 2;
			}
		}
		else if (bHighlighted)
		{
			index = 1;
		}
		else if (bChecked)
		{
			index = 2;
		}

		if (bFocused && !bDroppedDown && m_ctrlRibbonBtnDefault.GetImageCount () > 3)
		{
			index = 3;
		}

		if (index != -1)
		{
			pRenderer = &m_ctrlRibbonBtnDefault;
			CMFCVisualManagerBitmapCache* pCacheDefault = &m_cacheRibbonBtnDefault;
/*
			CMFCRibbonCategory* pCategory = pButton->GetParentCategory();
			ASSERT_VALID(pCategory);

			if (pCategory->GetTabColor() != AFX_CategoryColor_None)
			{
				CMFCRibbonContextCategory& context = m_ctrlRibbonContextCategory[pCategory->GetTabColor() - 1];

				pRenderer = &context.m_ctrlBtnDefault;
				pCacheDefault = &context.m_cacheBtnDefault;
			}
*/
			const CMFCControlRendererInfo& params = pRenderer->GetParams();

			int nCacheIndex = -1;
			if (pCacheDefault != NULL)
			{
				CSize size(params.m_rectImage.Width(), rect.Height());
				nCacheIndex = pCacheDefault->FindIndex(size);
				if (nCacheIndex == -1)
				{
					nCacheIndex = pCacheDefault->CacheY(size.cy, *pRenderer);
				}
			}

			if (nCacheIndex != -1)
			{
				pCacheDefault->Get(nCacheIndex)->DrawY(pDC, rect, CSize(params.m_rectInter.left, params.m_rectImage.right - params.m_rectInter.right), index);

				return afxGlobalData.clrBtnText;
			}
		}
	}
	else if ((!bDisabled &&(bPressed || bChecked || bHighlighted)) || (bDisabled && bFocused))
	{
		if (!pButton->GetMenuRect().IsRectEmpty()/* &&
												 (pButton->IsHighlighted() || bChecked)*/)
		{
			CRect rectC = pButton->GetCommandRect();
			CRect rectM = pButton->GetMenuRect();

			CMFCControlRenderer* pRendererC = pButton->IsMenuOnBottom() ? &m_ctrlRibbonBtnMenuV[0] : &m_ctrlRibbonBtnMenuH[0];
			CMFCControlRenderer* pRendererM = pButton->IsMenuOnBottom() ? &m_ctrlRibbonBtnMenuV[1] : &m_ctrlRibbonBtnMenuH[1];

			int indexC = -1;
			int indexM = -1;

			BOOL bDropped      = pButton->IsDroppedDown();
			BOOL bHighlightedC = pButton->IsCommandAreaHighlighted();
			BOOL bHighlightedM = pButton->IsMenuAreaHighlighted();

			if (bDisabled)
			{
				if (bHighlightedC || bHighlightedM)
				{
					indexC = 4;
					indexM = 4;

					if (bHighlightedM)
					{
						indexM = 0;

						if (bDropped && !bIsMenuMode)
						{
							indexC = 5;
							indexM = 2;
						}
						else if (bPressed)
						{
							indexM = 1;
						}
					}
				}
			}
			else
			{
				if (bDropped && !bIsMenuMode)
				{
					indexC = 5;
					indexM = 2;
				}
				else
				{
					if (bFocused)
					{
						indexC = 5;
						indexM = 4;
					}

					if (bChecked)
					{
						indexC = 2;
						indexM = 2;
					}

					if (bHighlightedC || bHighlightedM)
					{
						indexM = 4;

						if (bPressed)
						{
							if (bHighlightedC)
							{
								indexC = 1;
							}
							else if (bHighlightedM)
							{
								indexC = bChecked ? 3 : 5;
							}
						}
						else
						{
							indexC = bChecked ? 3 : 0;

							if (bHighlightedM)
							{
								indexC = bChecked ? 3 : 5;
								indexM = 0;
							}
						}
					}
				}
			}

			if (indexC != -1)
			{
				pRendererC->Draw(pDC, rectC, indexC);
			}

			if (indexM != -1)
			{
				pRendererM->Draw(pDC, rectM, indexM);
			}

			return(COLORREF)-1;
		}
		else
		{
			index = -1;

			pRenderer = &m_ctrlRibbonBtn[0];
			if (rect.Height() > pRenderer->GetParams().m_rectImage.Height() * 1.5 && m_ctrlRibbonBtn[1].IsValid())
			{
				pRenderer = &m_ctrlRibbonBtn[1];
			}

			if (bDisabled && bFocused)
			{
				if (pRenderer->GetImageCount() > 4)
				{
					index = 4;
				}
				else
				{
					index = 0;
				}
			}

			if (!bDisabled)
			{
				if (bChecked)
				{
					index = 2;
				}

				if (bPressed)
				{
					if (bHighlighted)
					{
						index = 1;
					}
				}
				else if (bHighlighted)
				{
					index++;
				}
			}
		}
	}

	COLORREF clrText = bWasDisabled ? afxGlobalData.clrGrayedText : COLORREF(-1);

	if (pRenderer != NULL)
	{
		if (index != -1)
		{
			int nCacheIndex = -1;
			if (pCache != NULL)
			{
				CSize size(rect.Size());
				nCacheIndex = pCache->FindIndex(size);
				if (nCacheIndex == -1)
				{
					nCacheIndex = pCache->Cache(size, *pRenderer);
				}
			}

			if (nCacheIndex != -1)
			{
				pCache->Get(nCacheIndex)->Draw(pDC, rect, index);
			}
			else
			{
				pRenderer->Draw(pDC, rect, index);
			}

			if (!bWasDisabled)
			{
				clrText = afxGlobalData.clrBtnText;
			}
		}
	}

	return clrText;
}

void CMFCVisualManagerWindows7::OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonMenuCheckFrame(pDC, pButton, rect);
		return;
	}

	ASSERT_VALID(pDC);

	m_ctrlMenuItemBack.Draw(pDC, rect);
}

void CMFCVisualManagerWindows7::OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar, CRect rect)
{
	if (!CanDrawImage() || !m_ctrlRibbonBorder_QAT.IsValid())
	{
		CMFCVisualManagerWindows::OnFillRibbonQuickAccessToolBarPopup(pDC, pMenuBar, rect);
		return;
	}

	ASSERT_VALID (pDC);

	m_ctrlRibbonBorder_QAT.FillInterior(pDC, rect);
}

int CMFCVisualManagerWindows7::GetRibbonPopupBorderSize(const CMFCRibbonPanelMenu* pPopup) const
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::GetRibbonPopupBorderSize(pPopup);
	}

	if (pPopup != NULL)
	{
		ASSERT_VALID(pPopup);

		CMFCRibbonPanelMenuBar* pRibbonMenuBar = DYNAMIC_DOWNCAST(CMFCRibbonPanelMenuBar, (const_cast<CMFCRibbonPanelMenu*>(pPopup))->GetMenuBar());

		if (pRibbonMenuBar != NULL)
		{
			if (pRibbonMenuBar->IsMainPanel())
			{
				return m_ctrlRibbonMainPanel.GetParams().m_rectSides.left;
			}

			if (!pRibbonMenuBar->IsMenuMode())
			{
				if (pRibbonMenuBar->IsQATPopup())
				{
					if (m_ctrlRibbonBorder_QAT.IsValid())
					{
						return m_ctrlRibbonBorder_QAT.GetParams().m_rectSides.left;
					}
				}
				else if (pRibbonMenuBar->IsCategoryPopup())
				{
					return 0;
				}
				else if (pRibbonMenuBar->IsRibbonMiniToolBar())
				{
/*
					if (m_ctrlRibbonBorder_Floaty.IsValid())
					{
						return m_ctrlRibbonBorder_Floaty.GetParams().m_rectSides.left;
					}
*/
				}
				else
				{
					if (pRibbonMenuBar->GetPanel() != NULL)
					{
						return 0;
					}

					// standard size
				}
			}
		}
	}

	return(int)GetPopupMenuBorderSize();
}

void CMFCVisualManagerWindows7::OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonDefaultPaneButton(pDC, pButton);
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	OnFillRibbonButton(pDC, pButton);

	BOOL bIsQATMode = pButton->IsQATMode();

	CRect rectFrame(pButton->GetRect());

	if (!bIsQATMode)
	{
		if (m_ctrlRibbonBtnDefaultIcon.IsValid())
		{
			const CSize sizeImage = pButton->GetImageSize(CMFCRibbonButton::RibbonImageSmall);
			const int nMarginX = 11;
			const int nMarginY = 10;
			
			rectFrame.top += nMarginY / 2;
			rectFrame.bottom = rectFrame.top + sizeImage.cy + 2 * nMarginY;
			rectFrame.top -= 2;
			rectFrame.left = rectFrame.CenterPoint ().x - sizeImage.cx / 2 - nMarginX;
			rectFrame.right = rectFrame.left + sizeImage.cx + 2 * nMarginX;

			m_ctrlRibbonBtnDefaultIcon.Draw(pDC, rectFrame);
		}
	}
	else
	{
		if (m_ctrlRibbonBtnDefaultQAT.IsValid())
		{
			int index = 0;
			if (pButton->IsDroppedDown())
			{
				index = 2;
			}
			else if (pButton->IsPressed())
			{
				if (pButton->IsHighlighted())
				{
					index = 2;
				}
			}
			else if (pButton->IsHighlighted() || pButton->IsFocused())
			{
				index = 1;
			}

			m_ctrlRibbonBtnDefaultQAT.Draw(pDC, rectFrame, index);
		}
	}

	OnDrawRibbonDefaultPaneButtonContext(pDC, pButton);
}

void CMFCVisualManagerWindows7::OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect)
{
	if (!CanDrawImage())
	{
		CMFCVisualManagerWindows::OnDrawRibbonRecentFilesFrame(pDC, pPanel, rect);
		return;
	}

	ASSERT_VALID(pDC);

	rect.right += 2;
	pDC->FillRect(rect, &m_brBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.right = rectSeparator.left + 2;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);
}

void CMFCVisualManagerWindows7::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton)
{
	if (!CanDrawImage () || !pButton->IsRibbonButton())
	{
		CMFCVisualManagerWindows::OnDrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted, pButton);
		return;
	}

	rect.InflateRect(0, 1, 1, 1);

	int nIndex = 0;
	if (bDisabled)
	{
		nIndex = 3;
	}
	else
	{
		if (bIsDropped)
		{
			nIndex = 2;
		}
		else if (bIsHighlighted)
		{
			nIndex = 1;
		}
	}

	m_ctrlRibbonComboBoxBtn.Draw(pDC, rect, nIndex);

	rect.DeflateRect(0, 1, 1, 1);

	rect.bottom -= 2;

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
}

COLORREF CMFCVisualManagerWindows7::OnDrawMenuLabel(CDC* pDC, CRect rect)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::OnDrawMenuLabel (pDC, rect);
	}

	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brRibbonBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.top = rectSeparator.bottom - 2;

	DrawSeparator(pDC, rectSeparator, m_penSeparatorDark, m_penSeparatorLight, TRUE);

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManagerWindows7::GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* pEdit, BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled)
{
	if (!CanDrawImage())
	{
		return CMFCVisualManagerWindows::GetRibbonEditBackgroundColor(pEdit, bIsHighlighted, bIsPaneHighlighted, bIsDisabled);
	}

	COLORREF color = m_clrRibbonEdit;

	if (bIsDisabled)
	{
		color = m_clrRibbonEditDisabled;
	}
	else
	{
		if (bIsHighlighted)
		{
			color = m_clrRibbonEditHighlighted;
		}
	}

	return color;
}

BOOL CMFCVisualManagerWindows7::IsWindowActive(CWnd* pWnd) const
{
	BOOL bActive = FALSE;

	HWND hWnd = pWnd->GetSafeHwnd();

	if (hWnd != NULL)
	{
		if (!m_ActivateFlag.Lookup(pWnd->GetSafeHwnd(), bActive))
		{
			//ASSERT(FALSE);
			bActive = TRUE;
		}
	}

	return bActive;
}

BOOL CMFCVisualManagerWindows7::OnNcActivate(CWnd* pWnd, BOOL bActive)
{
	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		return FALSE;
	}

	// stay active if WF_STAYACTIVE bit is on
	if (pWnd->m_nFlags & WF_STAYACTIVE)
	{
		bActive = TRUE;
	}

	// but do not stay active if the window is disabled
	if (!pWnd->IsWindowEnabled())
	{
		bActive = FALSE;
	}

	BOOL bIsMDIFrame = FALSE;
	BOOL bWasActive = FALSE;

	// If the active state of an owner-draw MDI frame window changes, we need to
	// invalidate the MDI client area so the MDI child window captions are redrawn.
	if (IsOwnerDrawCaption())
	{
		bIsMDIFrame = pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd));
		bWasActive = IsWindowActive(pWnd);
	}

	m_ActivateFlag[pWnd->GetSafeHwnd()] = bActive;
	pWnd->SendMessage(WM_NCPAINT, 0, 0);

	if (IsOwnerDrawCaption())
	{
		if (bIsMDIFrame &&(bWasActive != bActive))
		{
			::RedrawWindow(((CMDIFrameWnd *)pWnd)->m_hWndMDIClient, NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN);
		}
	}

	return TRUE;
}

BOOL CMFCVisualManagerWindows7::OnNcPaint(CWnd* pWnd, const CObList& lstSysButtons, CRect rectRedraw)
{
	UNREFERENCED_PARAMETER(lstSysButtons);


	if (afxGlobalData.DwmIsCompositionEnabled())
	{
		return FALSE;
	}

	if (pWnd->GetSafeHwnd() == NULL || m_hThemeWindow == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pWnd);

	CMFCRibbonBar* pBar = GetRibbonBar(pWnd);
	BOOL bRibbonCaption  = pBar != NULL && pBar->IsWindowVisible() && pBar->IsReplaceFrameCaption();
	if (!bRibbonCaption)
	{
		return FALSE;
	}
	else
	{
		const DWORD dwStyle = pWnd->GetStyle();
		BOOL bMaximized = (dwStyle & WS_MAXIMIZE) == WS_MAXIMIZE;
		if (bMaximized)
		{
			return TRUE;
		}
	}

	CWindowDC dc(pWnd);

	if (dc.GetSafeHdc() != NULL)
	{
		CRgn rgn;
		if (!rectRedraw.IsRectEmpty())
		{
			rgn.CreateRectRgnIndirect(rectRedraw);
			dc.SelectClipRgn(&rgn);
		}

		CRect rtWindow;
		pWnd->GetWindowRect(rtWindow);
		pWnd->ScreenToClient(rtWindow);

		CRect rtClient;
		pWnd->GetClientRect(rtClient);

		rtClient.OffsetRect(-rtWindow.TopLeft());
		dc.ExcludeClipRect(rtClient);

		rtWindow.OffsetRect(-rtWindow.TopLeft());

		BOOL bActive = IsWindowActive(pWnd);

		// Modify bActive(if currently TRUE) for owner-drawn MDI child windows: draw child
		// frame active only if window is active MDI child and the MDI frame window is active.
		if (bActive && IsOwnerDrawCaption() && pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)))
		{
			CMDIFrameWnd *pParent = ((CMDIChildWnd *)pWnd)->GetMDIFrame();
			if (pParent)
			{
				CMDIChildWnd *pActiveChild = pParent->MDIGetActive(NULL);
				if (pActiveChild)
				{
					bActive = ((pActiveChild->GetSafeHwnd() == pWnd->GetSafeHwnd()) && IsWindowActive(pParent));
				}
			}
		}

		CRect rectCaption(rtWindow);
		CSize szSysBorders(GetSystemBorders(bRibbonCaption));

		rectCaption.bottom = rectCaption.top + szSysBorders.cy + pBar->GetCaptionHeight();

		(*m_pfDrawThemeBackground)(m_hThemeWindow, dc.GetSafeHdc(), WP_CAPTION, bActive ? CS_ACTIVE : CS_INACTIVE, &rectCaption, 0);

		rtWindow.top = rectCaption.bottom;
		dc.ExcludeClipRect(rectCaption);

		FRAMESTATES framestate = bActive ? FS_ACTIVE : FS_INACTIVE;

		CRect rectPart(rtWindow);
		rectPart.top = rectPart.bottom - szSysBorders.cy;
		(*m_pfDrawThemeBackground)(m_hThemeWindow, dc.GetSafeHdc(), WP_FRAMEBOTTOM, framestate, &rectPart, 0);

		rectPart.bottom = rectPart.top;
		rectPart.top = rtWindow.top;
		rectPart.right = rectPart.left + szSysBorders.cx;
		(*m_pfDrawThemeBackground)(m_hThemeWindow, dc.GetSafeHdc(), WP_FRAMELEFT, framestate, &rectPart, 0);

		rectPart.right = rtWindow.right;
		rectPart.left = rectPart.right - szSysBorders.cx;
		(*m_pfDrawThemeBackground)(m_hThemeWindow, dc.GetSafeHdc(), WP_FRAMERIGHT, framestate, &rectPart, 0);

		dc.SelectClipRgn(NULL);

		return TRUE;
	}

	return FALSE;
}

CSize CMFCVisualManagerWindows7::GetSystemBorders(BOOL bRibbonPresent) const
{
	CSize size(::GetSystemMetrics(SM_CYSIZEFRAME), ::GetSystemMetrics(SM_CXSIZEFRAME));

	if (bRibbonPresent)
	{
		size.cx--;
		size.cy--;
	}

	return size;
}

CMFCRibbonBar* CMFCVisualManagerWindows7::GetRibbonBar(CWnd* pWnd) const
{
	CMFCRibbonBar* pBar = NULL;

	if (pWnd == NULL)
	{
		pWnd = AfxGetMainWnd();
	}

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	if (pWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		pBar = ((CFrameWndEx*) pWnd)->GetRibbonBar();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		pBar = ((CMDIFrameWndEx*) pWnd)->GetRibbonBar();
	}

	return pBar;
}

BOOL CMFCVisualManagerWindows7::IsRibbonPresent(CWnd* pWnd) const
{
	CMFCRibbonBar* pBar = GetRibbonBar(pWnd);

	return pBar != NULL && pBar->IsWindowVisible();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxwinappex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#include "stdafx.h"
#include "afxglobals.h"
#include "afxcontrolbarutil.h"
#include "afxtoolbar.h"
#include "afxwinappex.h"

#include "afxframeimpl.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxoleipframewndex.h"

#include "afxmousemanager.h"
#include "afxcontextmenumanager.h"
#include "afxkeyboardmanager.h"
#include "afxusertoolsmanager.h"
#include "afxmenutearoffmanager.h"
#include "afxshellmanager.h"
#include "afxtooltipmanager.h"

#include "afxsettingsstore.h"
#include "afxregpath.h"
#include "afxrebarstate.h"

#ifndef _MFC_USER_BUILD
#include "version.h"
#endif

IMPLEMENT_DYNAMIC(CWinAppEx, CWinApp)

static const CString strRegEntryNameControlBars = _T("\\ControlBars");
static const CString strWindowPlacementRegSection = _T("WindowPlacement");
static const CString strRectMainKey = _T("MainWindowRect");
static const CString strFlagsKey = _T("Flags");
static const CString strShowCmdKey = _T("ShowCmd");
static const CString strRegEntryNameSizingBars = _T("\\SizingBars");
static const CString strRegEntryVersion = _T("ControlBarVersion");
static const CString strVersionMajorKey = _T("Major");
static const CString strVersionMinorKey = _T("Minor");

extern CObList afxAllToolBars;

CWinAppEx::CWinAppEx(BOOL bResourceSmartUpdate/* = TRUE*/) :
	m_bResourceSmartUpdate(bResourceSmartUpdate)
{
	m_bKeyboardManagerAutocreated = FALSE;
	m_bContextMenuManagerAutocreated = FALSE;
	m_bMouseManagerAutocreated = FALSE;
	m_bUserToolsManagerAutoCreated = FALSE;
	m_bTearOffManagerAutoCreated = FALSE;
	m_bTooltipManagerAutocreated = FALSE;

	m_bShellManagerAutocreated = FALSE;
	InitShellManager();

	const CString strRegEntryNameWorkspace = _T("Workspace");
	m_strRegSection = strRegEntryNameWorkspace;

	m_iSavedVersionMajor = -1;
	m_iSavedVersionMinor = -1;

	m_bForceDockStateLoad = FALSE;
	m_bLoadSaveFrameBarsOnly = FALSE;

	m_bSaveState = TRUE;
	m_bForceImageReset = FALSE;

	m_bLoadUserToolbars = TRUE;

	m_bLoadWindowPlacement = TRUE;
}

int CWinAppEx::ExitInstance() 
{
	ControlBarCleanUp();
	return CWinApp::ExitInstance();
}

CWinAppEx::~CWinAppEx()
{
	// Delete autocreated managers
	if (m_bKeyboardManagerAutocreated && afxKeyboardManager != NULL)
	{
		delete afxKeyboardManager;
		afxKeyboardManager = NULL;
	}

	if (m_bContextMenuManagerAutocreated && afxContextMenuManager != NULL)
	{
		delete afxContextMenuManager;
		afxContextMenuManager = NULL;
	}

	if (m_bMouseManagerAutocreated && afxMouseManager != NULL)
	{
		delete afxMouseManager;
		afxMouseManager = NULL;
	}

	if (m_bUserToolsManagerAutoCreated && afxUserToolsManager != NULL)
	{
		delete afxUserToolsManager;
		afxUserToolsManager = NULL;
	}

	if (m_bTearOffManagerAutoCreated && g_pTearOffMenuManager != NULL)
	{
		delete g_pTearOffMenuManager;
		g_pTearOffMenuManager = NULL;
	}

	if (m_bShellManagerAutocreated && afxShellManager != NULL)
	{
		delete afxShellManager;
		afxShellManager = NULL;
	}

	if (m_bTooltipManagerAutocreated && afxTooltipManager != NULL)
	{
		delete afxTooltipManager;
		afxTooltipManager = NULL;
	}
}

LPCTSTR CWinAppEx::SetRegistryBase(LPCTSTR lpszSectionName /*= NULL*/)
{
	m_strRegSection = (lpszSectionName != NULL) ? lpszSectionName : _T("");
	return m_strRegSection;
}

BOOL CWinAppEx::InitShellManager()
{
	if (afxShellManager != NULL)
	{
		return TRUE;
	}

	afxShellManager = new CShellManager;
	m_bShellManagerAutocreated = TRUE;

	return TRUE;
}

BOOL CWinAppEx::InitTooltipManager()
{
	if (afxTooltipManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	afxTooltipManager = new CTooltipManager;
	m_bTooltipManagerAutocreated = TRUE;
	return TRUE;
}

BOOL CWinAppEx::InitMouseManager()
{
	if (afxMouseManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	afxMouseManager = new CMouseManager;
	m_bMouseManagerAutocreated = TRUE;
	return TRUE;
}

BOOL CWinAppEx::InitContextMenuManager()
{
	if (afxContextMenuManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	afxContextMenuManager = new CContextMenuManager;
	m_bContextMenuManagerAutocreated = TRUE;

	return TRUE;
}

BOOL CWinAppEx::InitKeyboardManager()
{
	if (afxKeyboardManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	afxKeyboardManager = new CKeyboardManager;
	m_bKeyboardManagerAutocreated = TRUE;

	return TRUE;
}

BOOL CWinAppEx::EnableUserTools(const UINT uiCmdToolsDummy, const UINT uiCmdFirst, const UINT uiCmdLast,
	CRuntimeClass* pToolRTC, UINT uArgMenuID, UINT uInitDirMenuID)

{
	if (afxUserToolsManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	afxUserToolsManager = new
		CUserToolsManager( uiCmdToolsDummy, uiCmdFirst, uiCmdLast, pToolRTC, uArgMenuID, uInitDirMenuID);
	m_bUserToolsManagerAutoCreated = TRUE;

	return TRUE;
}

BOOL CWinAppEx::EnableTearOffMenus(LPCTSTR lpszRegEntry, const UINT uiCmdFirst, const UINT uiCmdLast)
{
	if (g_pTearOffMenuManager != NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	g_pTearOffMenuManager = new CMenuTearOffManager;
	m_bTearOffManagerAutoCreated = TRUE;

	return g_pTearOffMenuManager->Initialize(lpszRegEntry, uiCmdFirst, uiCmdLast);
}

CMouseManager* CWinAppEx::GetMouseManager()
{
	if (afxMouseManager == NULL)
	{
		InitMouseManager();
	}

	ASSERT_VALID(afxMouseManager);
	return afxMouseManager;
}

CShellManager* CWinAppEx::GetShellManager()
{
	if (afxShellManager == NULL)
	{
		InitShellManager();
	}

	ASSERT_VALID(afxShellManager);
	return afxShellManager;
}

CTooltipManager* CWinAppEx::GetTooltipManager()
{
	if (afxTooltipManager == NULL)
	{
		InitTooltipManager();
	}

	ASSERT_VALID(afxTooltipManager);
	return afxTooltipManager;
}

CContextMenuManager* CWinAppEx::GetContextMenuManager()
{
	if (afxContextMenuManager == NULL)
	{
		InitContextMenuManager();
	}

	ASSERT_VALID(afxContextMenuManager);
	return afxContextMenuManager;
}

CKeyboardManager* CWinAppEx::GetKeyboardManager()
{
	if (afxKeyboardManager == NULL)
	{
		InitKeyboardManager();
	}

	ASSERT_VALID(afxKeyboardManager);
	return afxKeyboardManager;
}

CUserToolsManager* CWinAppEx::GetUserToolsManager()
{
	return afxUserToolsManager;
}

CString CWinAppEx::GetRegSectionPath(LPCTSTR szSectionAdd /*=NULL*/)
{
	CString strSectionPath = ::AFXGetRegPath(m_strRegSection);
	if (szSectionAdd != NULL && _tcslen(szSectionAdd) != 0)
	{
		strSectionPath += szSectionAdd;
		strSectionPath += _T("\\");
	}

	return strSectionPath;
}

BOOL CWinAppEx::LoadState(LPCTSTR lpszSectionName /*=NULL*/, CFrameImpl* pFrameImpl /*= NULL*/)
{
	if (lpszSectionName != NULL)
	{
		m_strRegSection = lpszSectionName;
	}

	CString strSection = GetRegSectionPath();

	//-----------------------------
	// Other things to do before ?:
	//-----------------------------
	PreLoadState();

	//------------------------
	// Loaded library version:
	//------------------------
	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (reg.Open(GetRegSectionPath(strRegEntryVersion)))
	{
		reg.Read(strVersionMajorKey, m_iSavedVersionMajor);
		reg.Read(strVersionMinorKey, m_iSavedVersionMinor);
	}

	//--------------------------------------
	// Save general toolbar/menu parameters:
	//--------------------------------------
	CMFCToolBar::LoadParameters(strSection);
	afxCommandManager->LoadState(strSection);

	BOOL bResetImages = FALSE; // Reset images to default

	if (m_bResourceSmartUpdate)
	{
		CMFCToolBarButton::m_bUpdateImages = FALSE;
	}

	if (pFrameImpl != NULL)
	{
		ASSERT_VALID(pFrameImpl->m_pFrame);

		//-------------------
		// Load rebars state:
		//-------------------
		CMFCReBarState::LoadState(strSection, pFrameImpl->m_pFrame);

		BOOL bPrevDisableRecalcLayout = CDockingManager::m_bDisableRecalcLayout;
		CDockingManager::m_bDisableRecalcLayout = TRUE;

		//-----------------------------------------------------
		// Load all toolbars, menubar and docking control bars:
		//-----------------------------------------------------
		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				if (!m_bLoadSaveFrameBarsOnly || pToolBar->GetTopLevelFrame() == pFrameImpl->m_pFrame)
				{
					if (!pToolBar->IsFloating())
					{
						pToolBar->LoadState(strSection);
						if (pToolBar->IsResourceChanged())
						{
							bResetImages = TRUE;
						}
					}
				}
			}
		}

		//----------------------------
		// Load user defined toolbars:
		//----------------------------
		if (m_bLoadUserToolbars)
		{
			pFrameImpl->LoadUserToolbars();
		}

		//------------------------
		// Load tear-off toolbars:
		//------------------------
		pFrameImpl->LoadTearOffMenus();

		CDockingManager::m_bDisableRecalcLayout = bPrevDisableRecalcLayout;

		CDockState dockState;
		dockState.LoadState(m_strRegSection + strRegEntryNameControlBars);

		if (m_bForceDockStateLoad || pFrameImpl->IsDockStateValid(dockState))
		{
			if ((GetDataVersionMajor() != -1) &&(GetDataVersionMinor() != -1))
			{
				pFrameImpl->LoadDockState(strSection);
				pFrameImpl->SetDockState(dockState);
			}
		}

		if (m_bLoadWindowPlacement)
		{
			//--------------------------------------------------------
			// Set frame default(restored) size:
			//--------------------------------------------------------
			ReloadWindowPlacement(pFrameImpl->m_pFrame);
		}
	}

	//--------------------------------------
	// Load mouse/keyboard/menu managers:
	//--------------------------------------
	if (afxMouseManager != NULL)
	{
		afxMouseManager->LoadState(strSection);
	}

	if (afxContextMenuManager != NULL)
	{
		afxContextMenuManager->LoadState(strSection);
	}

	if (afxKeyboardManager != NULL)
	{
		afxKeyboardManager->LoadState(strSection, pFrameImpl == NULL ? NULL : pFrameImpl->m_pFrame);
	}

	if (afxUserToolsManager != NULL)
	{
		afxUserToolsManager->LoadState(strSection);
	}

	if (m_bResourceSmartUpdate)
	{
		CMFCToolBarButton::m_bUpdateImages = TRUE;
	}

	if (m_bForceImageReset ||(m_bResourceSmartUpdate && bResetImages))
	{
		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				pToolBar->ResetImages();
			}
		}

		if (pFrameImpl != NULL)
		{
			ASSERT_VALID(pFrameImpl->m_pFrame);
			pFrameImpl->m_pFrame->RecalcLayout();
		}
	}

	//----------
	// Call Hook
	//----------
	LoadCustomState();

	//----------------------------------------------------------------------
	// To not confuse internal serialization, set version number to current:
	//----------------------------------------------------------------------
#ifndef _MFC_USER_BUILD
	m_iSavedVersionMajor = rmj;
	m_iSavedVersionMinor = rmm;
#else
	m_iSavedVersionMajor = 9;
	m_iSavedVersionMinor = 0;
#endif

	if (pFrameImpl != NULL)
	{
		ASSERT_VALID(pFrameImpl->m_pFrame);

		if (pFrameImpl->m_pFrame->IsZoomed())
		{
			CView* pViewFirst = NULL;
			if (pFrameImpl->m_pFrame->GetActiveView() == NULL)
			{
				// InitialUpdateFrame wasn't called yet
				pViewFirst = DYNAMIC_DOWNCAST(CView, pFrameImpl->m_pFrame->GetDescendantWindow(AFX_IDW_PANE_FIRST, TRUE));
				if (pViewFirst->GetSafeHwnd() != NULL)
				{
					pViewFirst->m_bInitialRedraw = TRUE;
				}
			}
			
			pFrameImpl->m_pFrame->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

			if (pViewFirst->GetSafeHwnd() != NULL)
			{
				pViewFirst->m_bInitialRedraw = FALSE;
			}
		}
	}

	return TRUE;
}

BOOL CWinAppEx::LoadState(CMDIFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return LoadState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::LoadState(CFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return LoadState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::LoadState(COleIPFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return LoadState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::CleanState(LPCTSTR lpszSectionName /*=NULL*/)
{
	if (lpszSectionName != NULL)
	{
		m_strRegSection = lpszSectionName;
	}

	CString strSection = GetRegSectionPath();

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	return reg.DeleteKey(strSection);
}

BOOL CWinAppEx::SaveState(LPCTSTR lpszSectionName  /*=NULL*/, CFrameImpl* pFrameImpl /*= NULL*/)
{
	if (!m_bSaveState)
	{
		return FALSE;
	}

	if (lpszSectionName != NULL)
	{
		m_strRegSection = lpszSectionName;
	}

	CString strSection = GetRegSectionPath();

	//-----------------------------
	// Other things to do before ?:
	//-----------------------------
	PreSaveState();

	//----------------------
	// Save library version:
	//----------------------
	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(GetRegSectionPath(strRegEntryVersion)))
	{
#ifndef _MFC_USER_BUILD
		reg.Write(strVersionMajorKey, rmj);
		reg.Write(strVersionMinorKey, rmm);
#else
		reg.Write(strVersionMajorKey, 9);
		reg.Write(strVersionMinorKey, 0);
#endif
	}

	//--------------------------------------
	// Save general toolbar/menu parameters:
	//--------------------------------------
	CMFCToolBar::SaveParameters(strSection);
	afxCommandManager->SaveState(strSection);

	if (pFrameImpl != NULL)
	{
		CDockState dockState;

		pFrameImpl->m_pFrame->GetDockState(dockState);
		dockState.SaveState(m_strRegSection + strRegEntryNameControlBars);

		pFrameImpl->SaveDockState(strSection);

		//-----------------------------------------------------
		// Save all toolbars, menubar and docking control bars:
		//-----------------------------------------------------
		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				if (!m_bLoadSaveFrameBarsOnly || pToolBar->GetTopLevelFrame() == pFrameImpl->m_pFrame)
				{
					pToolBar->SaveState(strSection);
				}
			}
		}

		//----------------------------
		// Save user defined toolbars:
		//----------------------------
		pFrameImpl->SaveUserToolbars(m_bLoadSaveFrameBarsOnly);

		//------------------------
		// Save tear-off toolbars:
		//------------------------
		pFrameImpl->SaveTearOffMenus(m_bLoadSaveFrameBarsOnly);

		//-------------------
		// Save rebars state:
		//-------------------
		CMFCReBarState::SaveState(strSection, pFrameImpl->m_pFrame);

		//--------------------------
		// Store window placement
		//--------------------------
		pFrameImpl->StoreWindowPlacement();
	}

	//------------------
	// Save user images:
	//------------------
	if (CMFCToolBar::m_pUserImages != NULL)
	{
		ASSERT_VALID(CMFCToolBar::m_pUserImages);
		CMFCToolBar::m_pUserImages->Save();
	}

	//--------------------------------------
	// Save mouse/keyboard/menu managers:
	//--------------------------------------
	if (afxMouseManager != NULL)
	{
		afxMouseManager->SaveState(strSection);
	}

	if (afxContextMenuManager != NULL)
	{
		afxContextMenuManager->SaveState(strSection);
	}

	if (afxKeyboardManager != NULL)
	{
		afxKeyboardManager->SaveState(strSection, pFrameImpl == NULL ? NULL : pFrameImpl->m_pFrame);
	}

	if (afxUserToolsManager != NULL)
	{
		afxUserToolsManager->SaveState(strSection);
	}

	SaveCustomState();
	return TRUE;
}


// Overidables for customization

void CWinAppEx::OnClosingMainFrame(CFrameImpl* pFrame)
{
	// Defaults to automatically saving state.
	SaveState(0, pFrame);
}

//--------------------------------------------------------
// the next one have to be called explicitly in your code:
//--------------------------------------------------------
BOOL CWinAppEx::OnViewDoubleClick(CWnd* pWnd, int iViewId)
{
	if (afxMouseManager == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(afxMouseManager);

	UINT uiCmd = afxMouseManager->GetViewDblClickCommand(iViewId);
	if (uiCmd > 0 && uiCmd != (UINT) -1)
	{
		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}

		CWnd* pTargetWnd = (pWnd == NULL) ? AfxGetMainWnd() : AFXGetTopLevelFrame(pWnd);
		ASSERT_VALID(pTargetWnd);

		pTargetWnd->SendMessage(WM_COMMAND, uiCmd);
		return TRUE;
	}

	MessageBeep((UINT) -1);
	return FALSE;
}

BOOL CWinAppEx::ShowPopupMenu(UINT uiMenuResId, const CPoint& point, CWnd* pWnd)
{
	if (afxContextMenuManager == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(afxContextMenuManager);
	return afxContextMenuManager->ShowPopupMenu(uiMenuResId, point.x, point.y, pWnd);
}

BOOL CWinAppEx::ReloadWindowPlacement(CFrameWnd* pFrameWnd)
{
	ASSERT_VALID(pFrameWnd);

	CCommandLineInfo cmdInfo;
	AfxGetApp()->ParseCommandLine(cmdInfo);
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		//Don't show the main window if Application
		//was run with /Embedding or /Automation.
		return FALSE;
	}

	CRect rectNormal;
	int nFlags = 0;
	int nShowCmd = SW_SHOWNORMAL;
	BOOL bRet = FALSE;

	if (LoadWindowPlacement(rectNormal, nFlags, nShowCmd))
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(WINDOWPLACEMENT);

		if (pFrameWnd->GetWindowPlacement(&wp))
		{
			wp.rcNormalPosition = rectNormal;
			wp.showCmd = nShowCmd;

			RECT rectDesktop;
			SystemParametersInfo(SPI_GETWORKAREA,0, (PVOID)&rectDesktop,0);
			OffsetRect(&wp.rcNormalPosition, -rectDesktop.left, -rectDesktop.top);

			CView* pViewFirst = NULL;
			if (pFrameWnd->GetActiveView() == NULL)
			{
				// InitialUpdateFrame wasn't called yet
				pViewFirst = DYNAMIC_DOWNCAST(CView, pFrameWnd->GetDescendantWindow(AFX_IDW_PANE_FIRST, TRUE));
				if (pViewFirst->GetSafeHwnd() != NULL)
				{
					pViewFirst->m_bInitialRedraw = TRUE;
				}
			}
			
			pFrameWnd->SetWindowPlacement(&wp);

			if (pViewFirst->GetSafeHwnd() != NULL)
			{
				pViewFirst->m_bInitialRedraw = FALSE;
			}

			bRet = TRUE;
		}
	}

	if (pFrameWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		CDockingManager *pDockingManager = ((CMDIFrameWndEx *)pFrameWnd)->GetDockingManager();
		pDockingManager->ShowDelayShowMiniFrames(TRUE);
	}
	else if (pFrameWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		CDockingManager *pDockingManager = ((CFrameWndEx *)pFrameWnd)->GetDockingManager();
		pDockingManager->ShowDelayShowMiniFrames(TRUE);
	}

	return bRet;
}

BOOL CWinAppEx::LoadWindowPlacement(CRect& rectNormalPosition, int& nFlags, int& nShowCmd)
{
	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(GetRegSectionPath(strWindowPlacementRegSection)))
	{
		return FALSE;
	}

	return reg.Read(strRectMainKey, rectNormalPosition) && reg.Read(strFlagsKey, nFlags) && reg.Read(strShowCmdKey, nShowCmd);
}

BOOL CWinAppEx::StoreWindowPlacement(const CRect& rectNormalPosition, int nFlags, int nShowCmd)
{
	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.CreateKey(GetRegSectionPath(strWindowPlacementRegSection)))
	{
		return FALSE;
	}

	return reg.Write(strRectMainKey, rectNormalPosition) && reg.Write(strFlagsKey, nFlags) && reg.Write(strShowCmdKey, nShowCmd);
}

// These functions load and store values from the "Custom" subkey
// To use subkeys of the "Custom" subkey use GetSectionInt() etc.
// instead
int CWinAppEx::GetInt(LPCTSTR lpszEntry, int nDefault /*= 0*/)
{
	return GetSectionInt(_T(""), lpszEntry, nDefault);
}

CString CWinAppEx::GetString(LPCTSTR lpszEntry, LPCTSTR lpszDefault /*= ""*/)
{
	return GetSectionString(_T(""), lpszEntry, lpszDefault);
}

BOOL CWinAppEx::GetBinary(LPCTSTR lpszEntry, LPBYTE* ppData, UINT* pBytes)
{
	return GetSectionBinary(_T(""), lpszEntry, ppData, pBytes);
}

BOOL CWinAppEx::GetObject(LPCTSTR lpszEntry, CObject& obj)
{
	return GetSectionObject(_T(""), lpszEntry, obj);
}

BOOL CWinAppEx::WriteInt(LPCTSTR lpszEntry, int nValue )
{
	return WriteSectionInt(_T(""), lpszEntry, nValue);
}

BOOL CWinAppEx::WriteString(LPCTSTR lpszEntry, LPCTSTR lpszValue )
{
	return WriteSectionString(_T(""), lpszEntry, lpszValue);
}

BOOL CWinAppEx::WriteBinary(LPCTSTR lpszEntry, LPBYTE pData, UINT nBytes)
{
	return WriteSectionBinary(_T(""), lpszEntry, pData, nBytes);
}

BOOL CWinAppEx::WriteObject(LPCTSTR lpszEntry, CObject& obj)
{
	return WriteSectionObject(_T(""), lpszEntry, obj);
}

// These functions load and store values from a given subkey
// of the "Custom" subkey. For simpler access you may use
// GetInt() etc.
int CWinAppEx::GetSectionInt( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, int nDefault /*= 0*/)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);

	int nRet = nDefault;

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (reg.Open(strSection))
	{
		reg.Read(lpszEntry, nRet);
	}
	return nRet;
}

CString CWinAppEx::GetSectionString( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPCTSTR lpszDefault /*= ""*/)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ENSURE(lpszDefault != NULL);

	CString strRet = lpszDefault;

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (reg.Open(strSection))
	{
		reg.Read(lpszEntry, strRet);
	}
	return strRet;
}

BOOL CWinAppEx::GetSectionBinary(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPBYTE* ppData, UINT* pBytes)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ENSURE(ppData != NULL);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (reg.Open(strSection) && reg.Read(lpszEntry, ppData, pBytes) )
	{
		return TRUE;
	}
	return FALSE;
}

BOOL CWinAppEx::GetSectionObject(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, CObject& obj)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ASSERT_VALID(&obj);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (reg.Open(strSection) && reg.Read(lpszEntry, obj))
	{
		return TRUE;
	}
	return FALSE;
}

BOOL CWinAppEx::WriteSectionInt( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, int nValue )
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		return reg.Write(lpszEntry, nValue);
	}
	return FALSE;
}

BOOL CWinAppEx::WriteSectionString( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPCTSTR lpszValue )
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ENSURE(lpszValue != NULL);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		return reg.Write(lpszEntry, lpszValue);
	}
	return FALSE;
}

BOOL CWinAppEx::WriteSectionBinary(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPBYTE pData, UINT nBytes)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ENSURE(pData != NULL);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		return reg.Write(lpszEntry, pData, nBytes);
	}
	return FALSE;
}

BOOL CWinAppEx::WriteSectionObject(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, CObject& obj)
{
	ENSURE(lpszSubSection != NULL);
	ENSURE(lpszEntry != NULL);
	ASSERT_VALID(&obj);

	CString strSection = GetRegSectionPath(lpszSubSection);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		return reg.Write(lpszEntry, obj);
	}

	return FALSE;
}

void CWinAppEx::OnAppContextHelp(CWnd* pWndControl, const DWORD dwHelpIDArray [])
{
	ASSERT_VALID(pWndControl);
	if (pWndControl != NULL)
	{
		pWndControl->WinHelpInternal((DWORD_PTR)(LPVOID)dwHelpIDArray, HELP_CONTEXTMENU);
	}
}

BOOL CWinAppEx::SaveState(CMDIFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return SaveState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::SaveState(CFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return SaveState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::SaveState(COleIPFrameWndEx* pFrame, LPCTSTR lpszSectionName /*=NULL*/)
{
	ASSERT_VALID(pFrame);
	return SaveState(lpszSectionName, &pFrame->m_Impl);
}

BOOL CWinAppEx::IsStateExists(LPCTSTR lpszSectionName /*=NULL*/)
{
	if (lpszSectionName != NULL)
	{
		m_strRegSection = lpszSectionName;
	}

	CString strSection = GetRegSectionPath();

	//------------------------
	// Loaded library version:
	//------------------------
	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	return reg.Open(GetRegSectionPath(strRegEntryVersion));
}

int CWinAppEx::GetDataVersion() const
{
	if (m_iSavedVersionMajor == -1 || m_iSavedVersionMinor == -1)
	{
		return 0xFFFFFFFF;
	}

	int nVersionMinor = m_iSavedVersionMinor / 10;
	int nVersionDigit = m_iSavedVersionMinor % 10;

	nVersionMinor *= 0x100;
	nVersionDigit *= 0x10;

	if (nVersionMinor < 10)
	{
		nVersionDigit *=0x10;
	}

	return m_iSavedVersionMajor * 0x10000 + nVersionMinor + nVersionDigit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvslistbox.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxvslistbox.h"
#include "afxacceleratorkey.h"
#include "afxribbonres.h"
#include "afxglobals.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nListId = 1;
static const int nTextMargin = 5;
static const int nBrowseButtonWidth = 20;

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxEditCtrl

CVSListBoxEditCtrl::CVSListBoxEditCtrl()
{
	m_bLocked = FALSE;
	m_pParentList = NULL;
}

CVSListBoxEditCtrl::~CVSListBoxEditCtrl()
{
}

BEGIN_MESSAGE_MAP(CVSListBoxEditCtrl, CMFCEditBrowseCtrl)
	//{{AFX_MSG_MAP(CVSListBoxEditCtrl)
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_NCCALCSIZE()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_NCPAINT()
	ON_WM_NCHITTEST()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxEditCtrl message handlers

void CVSListBoxEditCtrl::LockSize(CVSListBoxBase* pParent, BOOL bLock)
{
	m_pParentList = pParent;
	m_bLocked = bLock;
}

void CVSListBoxEditCtrl::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	if (m_bLocked)
	{
		lpwndpos->flags |= SWP_NOSIZE;
	}

	CEdit::OnWindowPosChanging(lpwndpos);
}

void CVSListBoxEditCtrl::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	if (!m_bLocked)
	{
		CMFCEditBrowseCtrl::OnNcCalcSize(bCalcValidRects, lpncsp);
	}
}

void CVSListBoxEditCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_TAB && (m_pParentList->GetCount() == 1) && (m_pParentList->IsCreatingNewItem()))
	{
		long lParam = nRepCnt | nFlags << 16;
		CMFCEditBrowseCtrl::DefWindowProc(WM_KEYDOWN, VK_RETURN, lParam);
		return;
	}

	CMFCEditBrowseCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxBase

CVSListBoxBase::CVSListBoxBase()
{
	m_sizeButton = CSize(0, 0);
	m_uiStandardBtns = 0;
	m_bNewItem = FALSE;
	m_bIsActualDelete = TRUE;
	m_bBrowseButton = FALSE;
	m_bGrayDisabledButtons = FALSE;
	m_bDefaultCaption = TRUE;
}

CVSListBoxBase::~CVSListBoxBase()
{
	while (!m_lstButtons.IsEmpty())
	{
		delete m_lstButtons.RemoveHead();
	}
}

//{{AFX_MSG_MAP(CVSListBoxBase)
BEGIN_MESSAGE_MAP(CVSListBoxBase, CStatic)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_SETFOCUS()
	ON_WM_ENABLE()
	ON_WM_GETDLGCODE()
	ON_MESSAGE(WM_SETFONT, &CVSListBoxBase::OnSetFont)
	ON_MESSAGE(WM_GETFONT, &CVSListBoxBase::OnGetFont)
	ON_MESSAGE(WM_SETTEXT, &CVSListBoxBase::OnSetText)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxBase message handlers
void CVSListBoxBase::PreSubclassWindow()
{
	CStatic::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		Init();
	}
}

int CVSListBoxBase::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CStatic::OnCreate(lpCreateStruct) == -1)
		return -1;

	Init();
	return 0;
}

void CVSListBoxBase::Init()
{
	ModifyStyle(0, SS_USERITEM);

	if (OnCreateList() == NULL)
	{
		TRACE0("CVSListBoxBase::Init(): Can not create list control\n");
		return;
	}

	AdjustLayout();
}

BOOL CVSListBoxBase::SetStandardButtons(UINT uiBtns)
{
	if (GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CString strButton;
	if (uiBtns & AFX_VSLISTBOX_BTN_NEW)
	{
		ENSURE(strButton.LoadString(IDS_AFXBARRES_NEW));
		ENSURE(AddButton(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_NEW32 : IDB_AFXBARRES_NEW, strButton, VK_INSERT,0,AFX_VSLISTBOX_BTN_NEW_ID));
	}

	if (uiBtns & AFX_VSLISTBOX_BTN_DELETE)
	{
		ENSURE(strButton.LoadString(IDS_AFXBARRES_DELETE));
		ENSURE(AddButton(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_DELETE32 : IDB_AFXBARRES_DELETE, strButton, VK_DELETE, 0, AFX_VSLISTBOX_BTN_DELETE_ID));
	}

	if (uiBtns & AFX_VSLISTBOX_BTN_UP)
	{
		ENSURE(strButton.LoadString(IDS_AFXBARRES_MOVEUP));
		ENSURE(AddButton(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_UP32 : IDB_AFXBARRES_UP, strButton, VK_UP, FALT, AFX_VSLISTBOX_BTN_UP_ID));
	}

	if (uiBtns & AFX_VSLISTBOX_BTN_DOWN)
	{
		ENSURE(strButton.LoadString(IDS_AFXBARRES_MOVEDN));
		ENSURE(AddButton(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_DOWN32 : IDB_AFXBARRES_DOWN, strButton, VK_DOWN, FALT, AFX_VSLISTBOX_BTN_DOWN_ID));
	}

	m_uiStandardBtns |= uiBtns;
	return TRUE;
}

BOOL CVSListBoxBase::AddButton(UINT uiImageResId, LPCTSTR lpszTooltip/* = NULL*/, WORD wKeyAccelerator/* = 0*/, BYTE fVirt/* = 0*/, UINT uiButtonID/* = 0*/)
{
	if (GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (uiButtonID != 0)
	{
		ASSERT(GetButtonNum(uiButtonID)==-1); // button with this ID still not added
	}

	CRect rectEmpty;
	rectEmpty.SetRectEmpty();

	CMFCButton* pButton = new CMFCButton();
	if (!pButton->Create(_T(""), WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_OWNERDRAW, rectEmpty, this, (int) m_lstButtons.GetCount() + 2))
	{
		return FALSE;
	}

	pButton->m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
	pButton->m_bGrayDisabled = m_bGrayDisabledButtons;
	pButton->m_bDrawFocus = FALSE;

	pButton->SetImage(uiImageResId);
	if (lpszTooltip != NULL)
	{
		CString strTooltip = lpszTooltip;
		if (wKeyAccelerator != 0)
		{
			ACCEL acccel;
			acccel.cmd = 0;
			acccel.fVirt = (BYTE)(fVirt | FVIRTKEY);
			acccel.key = wKeyAccelerator;

			CMFCAcceleratorKey helper(&acccel);
			CString strAccellKey;
			helper.Format(strAccellKey);

			strTooltip += _T("(");
			strTooltip += strAccellKey;
			strTooltip += _T(")");
		}

		pButton->SetTooltip(strTooltip);
	}

	pButton->SizeToContent();
	CRect rectBtn;
	pButton->GetWindowRect(rectBtn);
	CSize sizeButton = rectBtn.Size();

	if (m_lstButtons.IsEmpty())
	{
		m_sizeButton = sizeButton;
	}
	else
	{
		ASSERT(m_sizeButton == sizeButton);
	}

	m_lstButtons.AddTail(pButton);

	if (wKeyAccelerator == 0)
	{
		fVirt = 0;
	}

	DWORD dwKey = (fVirt << 16) | wKeyAccelerator;
	m_lstKeyAccell.AddTail(dwKey);

	if (uiButtonID != 0)
	{
		int iButton = (int) m_lstButtons.GetCount() - 1;
		m_mapButtonIDs.SetAt(iButton, uiButtonID);
	}

	AdjustLayout();
	return TRUE;
}

void CVSListBoxBase::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	dc.FillRect(m_rectCaption, &afxGlobalData.brBtnFace);
	dc.Draw3dRect(m_rectCaption, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnHilite);

	CRect rectText = m_rectCaption;
	rectText.DeflateRect(nTextMargin, 0);

	dc.SetBkMode(TRANSPARENT);
	dc.SetTextColor(IsWindowEnabled() ? afxGlobalData.clrBtnText : afxGlobalData.clrGrayedText);

	CFont* pOldFont = NULL;

	if (m_font.GetSafeHandle() != NULL)
	{
		pOldFont = dc.SelectObject(&m_font);
	}
	else
	{
		CFont* pParentFont = GetParent()->GetFont();

		if (pParentFont != NULL)
		{
			pOldFont = dc.SelectObject(pParentFont);
			ENSURE(pOldFont != NULL);
		}
	}

	CString strCaption;

	if (m_bDefaultCaption)
	{
		GetWindowText(strCaption);
	}
	else
	{
		strCaption = m_strCaption;
	}

	dc.DrawText(strCaption, rectText, DT_LEFT | DT_SINGLELINE | DT_VCENTER);

	if (pOldFont != NULL)
	{
		dc.SelectObject(pOldFont);
	}
}

void CVSListBoxBase::OnSize(UINT nType, int cx, int cy)
{
	CStatic::OnSize(nType, cx, cy);
	AdjustLayout();
}

void CVSListBoxBase::AdjustLayout()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CWnd* pWndList = CWnd::FromHandle(GetListHwnd());
	if (pWndList == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	m_rectCaption = rectClient;

	CClientDC dc(this);

	CFont* pOldFont = NULL;
	if (m_font.GetSafeHandle() != NULL)
	{
		pOldFont = dc.SelectObject(&m_font);
		pWndList->SetFont(&m_font, FALSE);
	}
	else
	{
		CFont* pParentFont = GetParent()->GetFont();

		if (pParentFont != NULL)
		{
			pWndList->SetFont(pParentFont, FALSE);

			pOldFont = dc.SelectObject(pParentFont);
			ENSURE(pOldFont != NULL);
		}
	}

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	if (pOldFont != NULL)
	{
		dc.SelectObject(pOldFont);
	}

	m_rectCaption.bottom = m_rectCaption.top + max(tm.tmHeight * 4 / 3, m_sizeButton.cy);

	int x = rectClient.right - 1 - m_sizeButton.cx;
	for (POSITION pos = m_lstButtons.GetTailPosition(); pos != NULL;)
	{
		CMFCButton* pButton = m_lstButtons.GetPrev(pos);
		ENSURE(pButton != NULL);

		pButton->MoveWindow(x, rectClient.top + 1, m_sizeButton.cx, m_rectCaption.Height() - 2);
		x -= m_sizeButton.cx;
	}

	pWndList->MoveWindow( rectClient.left, rectClient.top + m_rectCaption.Height(), rectClient.Width(), rectClient.Height() - m_rectCaption.Height());
	OnSizeList();
}

BOOL CVSListBoxBase::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CVSListBoxBase::OnCommand(WPARAM wParam, LPARAM lParam)
{
	HWND hwnd = (HWND) lParam;

	int iButton = 0;
	for (POSITION pos = m_lstButtons.GetHeadPosition(); pos != NULL; iButton ++)
	{
		CMFCButton* pButton = m_lstButtons.GetNext(pos);
		ENSURE(pButton);

		if (pButton->GetSafeHwnd() == hwnd)
		{
			CWnd* pWndList = CWnd::FromHandle(GetListHwnd());
			if (pWndList == NULL)
			{
				ASSERT(FALSE);
			}
			else
			{
				pWndList->SetFocus();
			}

			OnClickButton(iButton);
			return TRUE;
		}
	}

	return CStatic::OnCommand(wParam, lParam);
}

void CVSListBoxBase::OnSetFocus(CWnd* /*pOldWnd*/)
{
	CWnd* pWndList = CWnd::FromHandle(GetListHwnd());
	if (pWndList == NULL)
	{
		ASSERT(FALSE);
	}
	else
	{
		pWndList->SetFocus();
	}
}

void CVSListBoxBase::OnClickButton(int iButton)
{
	if (m_uiStandardBtns == 0)
	{
		return;
	}

	int iSelItem = GetSelItem();
	UINT uiBtnID = GetButtonID(iButton);

	switch(uiBtnID)
	{
	case AFX_VSLISTBOX_BTN_NEW_ID:
		CreateNewItem();
		return;

	case AFX_VSLISTBOX_BTN_DELETE_ID:
		if (iSelItem >= 0)
		{
			if (OnBeforeRemoveItem(iSelItem))
			{
				RemoveItem(iSelItem);
			}
		}
		break;

	case AFX_VSLISTBOX_BTN_UP_ID:
	case AFX_VSLISTBOX_BTN_DOWN_ID:
		if (iSelItem >= 0)
		{
			BOOL bIsUp = (uiBtnID == AFX_VSLISTBOX_BTN_UP_ID);
			if (bIsUp)
			{
				if (iSelItem == 0)
				{
					return;
				}
			}
			else
			{
				if (iSelItem == GetCount() - 1)
				{
					return;
				}
			}

			// Adjust list control:
			SetRedraw(FALSE);

			CString strLabel = GetItemText(iSelItem);
			DWORD_PTR dwData = GetItemData(iSelItem);

			m_bIsActualDelete = FALSE;
			RemoveItem(iSelItem);
			m_bIsActualDelete = TRUE;

			if (bIsUp)
			{
				iSelItem --;
			}
			else
			{
				iSelItem ++;
			}

			AddItem(strLabel, dwData, iSelItem);
			SelectItem(iSelItem);

			SetRedraw();

			CWnd* pWndList = CWnd::FromHandle(GetListHwnd());
			if (pWndList == NULL)
			{
				ASSERT(FALSE);
			}
			else
			{
				pWndList->Invalidate();
			}

			if (bIsUp)
			{
				OnAfterMoveItemUp(iSelItem);
			}
			else
			{
				OnAfterMoveItemDown(iSelItem);
			}
		}
	}
}

int CVSListBoxBase::GetStdButtonNum(UINT uiStdBtn) const
{
	if ((m_uiStandardBtns & uiStdBtn) == 0)
	{
		return -1;
	}

	switch(uiStdBtn)
	{
	case AFX_VSLISTBOX_BTN_NEW:
		return GetButtonNum(AFX_VSLISTBOX_BTN_NEW_ID);

	case AFX_VSLISTBOX_BTN_DELETE:
		return GetButtonNum(AFX_VSLISTBOX_BTN_DELETE_ID);

	case AFX_VSLISTBOX_BTN_UP:
		return GetButtonNum(AFX_VSLISTBOX_BTN_UP_ID);

	case AFX_VSLISTBOX_BTN_DOWN:
		return GetButtonNum(AFX_VSLISTBOX_BTN_DOWN_ID);
	}

	ASSERT(FALSE);
	return -1;
}

void CVSListBoxBase::CreateNewItem()
{
	int iLastItem = AddItem(_T(""));
	ASSERT(iLastItem >= 0);

	m_bNewItem = TRUE;
	EditItem(iLastItem);
}

void CVSListBoxBase::OnKey(WORD wKey, BYTE fFlags)
{
	int iSelItem = GetSelItem();
	TCHAR cKey = (TCHAR) LOWORD(::MapVirtualKey(wKey, 2));

	if (fFlags == 0 && iSelItem >= 0 && (cKey == _T(' ') || wKey == VK_F2))
	{
		EditItem(iSelItem);
	}
}

LRESULT CVSListBoxBase::OnGetFont(WPARAM /*wParam*/, LPARAM /*lParam*/)
{
	return(LRESULT) m_font.GetSafeHandle();
}

LRESULT CVSListBoxBase::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = Default();

	CFont* pFont = CFont::FromHandle((HFONT) wParam);
	if (pFont != NULL)
	{
		LOGFONT lf;
		pFont->GetLogFont(&lf);

		m_font.DeleteObject();
		m_font.CreateFontIndirect(&lf);
	}

	if (::IsWindow(GetSafeHwnd()) != NULL)
	{
		AdjustLayout();

		if (lParam != 0)
		{
			Invalidate();
			UpdateWindow();
		}
	}

	return lResult;
}

void CVSListBoxBase::OnEndEditLabel(LPCTSTR lpszLabel)
{
	int iSelItem = GetSelItem();
	if (iSelItem < 0)
	{
		ASSERT(FALSE);
		return;
	}

	CString strLabel = (lpszLabel != NULL) ? lpszLabel : _T("");

	if (!strLabel.IsEmpty())
	{
		SetItemText(iSelItem, strLabel);

		if (m_bNewItem)
		{
			OnAfterAddItem(iSelItem);
		}
		else
		{
			OnAfterRenameItem(iSelItem);
		}
	}
	else
	{
		if (m_bNewItem)
		{
			RemoveItem(iSelItem);
		}
	}

	m_bNewItem = FALSE;
}

BOOL CVSListBoxBase::EnableButton(int iButtonNum, BOOL bEnable/* = TRUE*/)
{
	POSITION pos = m_lstButtons.FindIndex(iButtonNum);
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCButton* pButton = m_lstButtons.GetAt(pos);
	ASSERT_VALID(pButton);

	pButton->EnableWindow(bEnable);
	return TRUE;
}

UINT CVSListBoxBase::GetButtonID(int iButtonNum) const
{
	UINT uiID = 0;
	m_mapButtonIDs.Lookup(iButtonNum, uiID);

	return uiID;
}

int CVSListBoxBase::GetButtonNum(UINT uiID) const
{
	for (POSITION pos = m_mapButtonIDs.GetStartPosition(); pos != NULL;)
	{
		int iNum = -1;
		UINT uiButtonID = 0;

		m_mapButtonIDs.GetNextAssoc(pos, iNum, uiButtonID);

		if (uiButtonID == uiID)
		{
			return iNum;
		}
	}

	return -1;
}


void CVSListBoxBase::EnableBrowseButton(BOOL bEnable/* = TRUE*/)
{
	m_bBrowseButton = bEnable;
}

void CVSListBoxBase::SetGrayDisabledButtons(BOOL bOn)
{
	m_bGrayDisabledButtons = bOn;
}

void CVSListBoxBase::OnEnable(BOOL bEnable)
{
	CStatic::OnEnable(bEnable);

	for (POSITION pos = m_lstButtons.GetTailPosition(); pos != NULL;)
	{
		CMFCButton* pButton = m_lstButtons.GetPrev(pos);
		ASSERT_VALID(pButton);

		pButton->m_bGrayDisabled = !bEnable || m_bGrayDisabledButtons;
		pButton->EnableWindow(bEnable);
	}

	CWnd* pWndList = CWnd::FromHandle(GetListHwnd());
	if (pWndList != NULL)
	{
		pWndList->EnableWindow(bEnable);
	}

	RedrawWindow();
}

UINT CVSListBoxBase::OnGetDlgCode()
{
	return DLGC_WANTALLKEYS;
}

LRESULT CVSListBoxBase::OnSetText(WPARAM, LPARAM lParam)
{
	LPCTSTR lpcszTitle = reinterpret_cast<LPCTSTR>(lParam);
	if (lpcszTitle != NULL)
	{
		m_strCaption = lpcszTitle;
		m_bDefaultCaption = FALSE;
	}
	else
	{
		m_bDefaultCaption = TRUE;
		m_strCaption.Empty();
	}

	RedrawWindow();
	return Default();
}

/////////////////////////////////////////////////////////////////////////////
// CVSListBox

CVSListBox::CVSListBox()
{
	m_pWndList = NULL;
	m_ptClick = CPoint(-1, -1);
}

CVSListBox::~CVSListBox()
{
	if (m_pWndList != NULL)
	{
		ASSERT_VALID(m_pWndList);
		delete m_pWndList;
	}
}

BEGIN_MESSAGE_MAP(CVSListBox, CVSListBoxBase)
	//{{AFX_MSG_MAP(CVSListBox)
	ON_NOTIFY(LVN_KEYDOWN, nListId, &CVSListBox::OnKeyDown)
	ON_NOTIFY(NM_DBLCLK, nListId, &CVSListBox::OnDblclkList)
	ON_NOTIFY(LVN_GETDISPINFO, nListId, &CVSListBox::OnGetdispinfo)
	ON_NOTIFY(LVN_ENDLABELEDIT, nListId, &CVSListBox::OnEndLabelEdit)
	ON_NOTIFY(LVN_ITEMCHANGED, nListId, &CVSListBox::OnItemChanged)
	ON_MESSAGE(WM_MFC_INITCTRL, &CVSListBox::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVSListBox message handlers

CWnd* CVSListBox::OnCreateList()
{
	if (GetSafeHwnd() == NULL ||
		m_pWndList != NULL)
	{
		return FALSE;
	}

	ASSERT(GetStyle() & WS_CHILD);

	CRect rectEmpty;
	rectEmpty.SetRectEmpty();

	m_pWndList = new CListCtrl;
	m_pWndList->CWnd::CreateEx(WS_EX_CLIENTEDGE, _T("SysListView32"), _T(""), WS_VISIBLE | WS_CHILD | LVS_REPORT | LVS_SINGLESEL |
		LVS_NOCOLUMNHEADER | LVS_EDITLABELS | LVS_SHOWSELALWAYS, rectEmpty, this, nListId);

	m_pWndList->SendMessage(LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
	m_pWndList->InsertColumn(0, _T(""));

	return m_pWndList;
}

int CVSListBox::AddItem(const CString& strText, DWORD_PTR dwData, int iIndex)
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		return -1;
	}

	ASSERT_VALID(m_pWndList);

	if (iIndex < 0)
	{
		iIndex = m_pWndList->GetItemCount();
	}

	int iItem = m_pWndList->InsertItem(iIndex, strText, I_IMAGECALLBACK);
	m_pWndList->SetItemData(iItem, dwData);

	if (iItem == 0)
	{
		SelectItem(0);
	}

	return iItem;
}

int CVSListBox::GetCount() const
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		return -1;
	}

	return m_pWndList->GetItemCount();
}

CString CVSListBox::GetItemText(int iIndex) const
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		return _T("");
	}

	ASSERT_VALID(m_pWndList);
	return m_pWndList->GetItemText(iIndex, 0);
}

DWORD_PTR CVSListBox::GetItemData(int iIndex) const
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	ASSERT_VALID(m_pWndList);
	return m_pWndList->GetItemData(iIndex);
}

void CVSListBox::SetItemData(int iIndex, DWORD_PTR dwData)
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pWndList);
	m_pWndList->SetItemData(iIndex, dwData);
}

void CVSListBox::OnKeyDown(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVKEYDOWN* pKeyDown = (NMLVKEYDOWN*) pNMHDR;
	*pResult = 0;

	if (pKeyDown != NULL)
	{
		BYTE fCurrVirt = 0;

		if (::GetAsyncKeyState(VK_CONTROL) & 0x8000)
		{
			fCurrVirt |= FCONTROL;
		}

		if (::GetAsyncKeyState(VK_MENU) & 0x8000)
		{
			fCurrVirt |= FALT;
		}

		if (::GetAsyncKeyState(VK_SHIFT) & 0x8000)
		{
			fCurrVirt |= FSHIFT;
		}

		int iButton = 0;
		for (POSITION pos = m_lstKeyAccell.GetHeadPosition(); pos != NULL; iButton ++)
		{
			DWORD dwKey = m_lstKeyAccell.GetNext(pos);

			if (dwKey != 0 && pKeyDown->wVKey == (dwKey & 0xFFFF))
			{
				//-------------------
				// Check state flags:
				//-------------------
				BYTE fVirt = (BYTE)(dwKey >> 16);
				if (fCurrVirt == fVirt)
				{
					OnClickButton(iButton);
					return;
				}
			}
		}

		OnKey(pKeyDown->wVKey, fCurrVirt);
	}
}

int CVSListBox::GetSelItem() const
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	ASSERT_VALID(m_pWndList);
	return m_pWndList->GetNextItem(-1, LVNI_SELECTED);
}

BOOL CVSListBox::SelectItem(int iItem)
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(m_pWndList);

	if (!m_pWndList->SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED))
	{
		return FALSE;
	}

	return m_pWndList->EnsureVisible(iItem, FALSE);
}

void CVSListBox::OnDblclkList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	*pResult = 0;

	int iSelItem = GetSelItem();

	if ((m_uiStandardBtns & AFX_VSLISTBOX_BTN_NEW) && iSelItem == -1)
	{
		CreateNewItem();
		return;
	}

	if (iSelItem >= 0)
	{
		EditItem(iSelItem);
	}
}

BOOL CVSListBox::RemoveItem(int iIndex)
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(m_pWndList);

	BOOL bIsSelected = (GetSelItem() == iIndex);

	if (!m_pWndList->DeleteItem(iIndex))
	{
		return FALSE;
	}

	if (!bIsSelected || GetCount() == 0)
	{
		return FALSE;
	}

	//-------------------
	// Restore selection:
	//-------------------
	if (iIndex >= GetCount())
	{
		iIndex --;
	}

	SelectItem(iIndex);
	return TRUE;
}

void CVSListBox::OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(pNMHDR != NULL);

	LV_ITEM* pItem = &((LV_DISPINFO*)pNMHDR)->item;
	ENSURE(pItem != NULL);

	if (pItem->mask & LVIF_IMAGE)
	{
		pItem->iImage = OnGetImage(pItem);
	}

	*pResult = 0;
}

void CVSListBox::OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(pNMHDR != NULL);

	LV_ITEM* pItem = &((LV_DISPINFO*)pNMHDR)->item;
	ENSURE(pItem != NULL);

	OnEndEditLabel(pItem->pszText);

	for (POSITION pos = m_lstButtons.GetTailPosition(); pos != NULL;)
	{
		CMFCButton* pButton = m_lstButtons.GetPrev(pos);
		ENSURE(pButton != NULL);

		pButton->EnableWindow();
	}

	*pResult = 0;
}

void CVSListBox::OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(pNMHDR != NULL);

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	ENSURE(pNMListView != NULL);

	if (pNMListView->uChanged == LVIF_STATE && (pNMListView->uOldState & LVIS_SELECTED) != (pNMListView->uNewState & LVIS_SELECTED))
	{
		OnSelectionChanged();
	}

	*pResult = 0;
}

BOOL CVSListBox::EditItem(int iIndex)
{
	m_wndEdit.LockSize(NULL, FALSE);

	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT_VALID(m_pWndList);

	m_pWndList->SetFocus();
	CEdit* pEdit = m_pWndList->EditLabel(iIndex);
	if (pEdit == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pEdit);

	m_wndEdit.SubclassWindow(pEdit->GetSafeHwnd());
	m_wndEdit.EnableBrowseButton(m_bBrowseButton);

	CRect rectItem;
	m_pWndList->GetItemRect(iIndex, rectItem, LVIR_LABEL);

	CRect rectEdit;
	pEdit->GetClientRect(rectEdit);

	pEdit->SetWindowPos(NULL, -1, -1, rectItem.Width(), rectEdit.Height(), SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	m_wndEdit.LockSize(this);

	for (POSITION pos = m_lstButtons.GetTailPosition(); pos != NULL;)
	{
		CMFCButton* pButton = m_lstButtons.GetPrev(pos);
		ENSURE(pButton != NULL);

		pButton->EnableWindow(FALSE);
	}

	return TRUE;
}

void CVSListBox::OnSizeList()
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pWndList);

	CRect rectClient;
	GetClientRect(rectClient);

	m_pWndList->SetColumnWidth(0, rectClient.Width() - 2 * ::GetSystemMetrics(SM_CXEDGE) - ::GetSystemMetrics(SM_CXVSCROLL));
}

void CVSListBox::SetItemText(int iIndex, const CString& strText)
{
	if (GetSafeHwnd() == NULL || m_pWndList == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(m_pWndList);
	m_pWndList->SetItemText(iIndex, 0, strText);
}

BOOL CVSListBox::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_LBUTTONDOWN && m_pWndList != NULL && m_pWndList->GetEditControl() == NULL && m_pWndList->GetSafeHwnd() == CWnd::GetFocus()->GetSafeHwnd())
	{
		ASSERT_VALID(m_pWndList);

		m_ptClick = CPoint(-1, -1);

		CPoint ptClick = pMsg->pt;
		m_pWndList->ScreenToClient(&ptClick);

		UINT uFlags;
		int iItem = m_pWndList->HitTest(ptClick, &uFlags);
		if (iItem >= 0 &&(uFlags & LVHT_ONITEMLABEL))
		{
			UINT uiMask = LVIS_FOCUSED | LVIS_SELECTED;
			if ((m_pWndList->GetItemState(iItem, uiMask) & uiMask) == uiMask)
			{
				// Secondary click on selected item:
				m_ptClick = ptClick;

				SetCapture();
				return TRUE;
			}
		}
	}
	else if (pMsg->message == WM_LBUTTONUP && m_ptClick != CPoint(-1, -1))
	{
		ASSERT_VALID(m_pWndList);

		ReleaseCapture();

		CPoint ptClick = pMsg->pt;
		m_pWndList->ScreenToClient(&ptClick);

		int iItem = m_pWndList->HitTest(ptClick);

		BOOL bEditItem = iItem >= 0 && (abs(ptClick.x - m_ptClick.x) < ::GetSystemMetrics(SM_CXDRAG) && abs(ptClick.y - m_ptClick.y) < ::GetSystemMetrics(SM_CYDRAG));

		m_ptClick = CPoint(-1, -1);

		if (bEditItem)
		{
			EditItem(iItem);
		}

		return TRUE;
	}

	return CVSListBoxBase::PreTranslateMessage(pMsg);
}

LRESULT CVSListBox::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bBrowseButton = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCVSListbox_BrowseButton, bBrowseButton))
	{
		EnableBrowseButton(bBrowseButton);
	}

	UINT uiBtns = 0;

	BOOL bNewButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCVSListbox_NewButton, bNewButton))
	{
		if (bNewButton && GetButtonNum(AFX_VSLISTBOX_BTN_NEW_ID) == -1)
		{
			uiBtns |= AFX_VSLISTBOX_BTN_NEW;
		}
	}

	BOOL bRemoveButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCVSListbox_RemoveButton, bRemoveButton))
	{
		if (bRemoveButton && GetButtonNum(AFX_VSLISTBOX_BTN_DELETE_ID) == -1)
		{
			uiBtns |= AFX_VSLISTBOX_BTN_DELETE;
		}
	}

	BOOL bUpButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCVSListbox_UpButton, bUpButton))
	{
		if (bUpButton && GetButtonNum(AFX_VSLISTBOX_BTN_UP_ID) == -1)
		{
			uiBtns |= AFX_VSLISTBOX_BTN_UP;
		}
	}

	BOOL bDownButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCVSListbox_DownButton, bDownButton))
	{
		if (bDownButton && GetButtonNum(AFX_VSLISTBOX_BTN_DOWN_ID) == -1)
		{
			uiBtns |= AFX_VSLISTBOX_BTN_DOWN;
		}
	}

	if (uiBtns != 0)
	{
		SetStandardButtons(uiBtns);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxvisualmanagerofficexp.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "afxvisualmanagerofficexp.h"
#include "afxdrawmanager.h"
#include "afxmenubar.h"
#include "afxpopupmenu.h"
#include "afxtoolbarmenubutton.h"
#include "afxoutlookbarpane.h"
#include "afxcolorbar.h"
#include "afxbasetabctrl.h"
#include "afxdockablepane.h"
#include "afxautohidedocksite.h"
#include "afxglobals.h"
#include "afxoutlookbarpanebutton.h"
#include "afxpaneframewnd.h"
#include "afxtaskspaneframewnd.h"
#include "afxtoolbareditboxbutton.h"
#include "afxtaskspane.h"
#include "afxdesktopalertwnd.h"
#include "afxpropertygridctrl.h"
#include "afxcustomizebutton.h"
#include "afxribbonbutton.h"
#include "afxribbonpanelmenu.h"
#include "afxribboncombobox.h"
#include "afxribbonpanel.h"
#include "afxribbonlabel.h"
#include "afxribbonstatusbarpane.h"
#include "afxcaptionbar.h"
#include "afxribboncolorbutton.h"
#include "afxribboncategory.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCVisualManagerOfficeXP, CMFCVisualManager)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCVisualManagerOfficeXP::CMFCVisualManagerOfficeXP(BOOL bIsTemporary) : CMFCVisualManager(bIsTemporary)
{
	m_bConnectMenuToParent = TRUE;

	m_nVertMargin = 4;
	m_nHorzMargin = 4;
	m_nGroupVertOffset = 4;
	m_nGroupCaptionHeight = 0;
	m_nGroupCaptionHorzOffset = 0;
	m_nGroupCaptionVertOffset = 0;
	m_nTasksHorzOffset = 12;
	m_nTasksIconHorzOffset = 5;
	m_nTasksIconVertOffset = 4;
	m_bActiveCaptions = FALSE;

	m_bMenuFlatLook = TRUE;
	m_bShadowHighlightedImage = TRUE;
	m_bEmbossDisabledImage = FALSE;
	m_bFadeInactiveImage = TRUE;
	m_nMenuShadowDepth = 4;
	m_nMenuBorderSize = 1;
	m_bShdowDroppedDownMenuButton = TRUE;

	m_bOfficeXPStyleMenus = TRUE;
	m_bDrawLastTabLine = TRUE;

	afxGlobalData.UpdateSysColors();
	OnUpdateSystemColors();
}

CMFCVisualManagerOfficeXP::~CMFCVisualManagerOfficeXP()
{
}

void CMFCVisualManagerOfficeXP::OnUpdateSystemColors()
{
	CMFCVisualManager::OnUpdateSystemColors();

	m_brBarBkgnd.DeleteObject();
	m_brMenuRarelyUsed.DeleteObject();
	m_brMenuLight.DeleteObject();
	m_brHighlight.DeleteObject();
	m_brHighlightDn.DeleteObject();
	m_brHighlightChecked.DeleteObject();

	m_brFloatToolBarBorder.DeleteObject();

	m_penSeparator.DeleteObject();
	m_brTabBack.DeleteObject();

	COLORREF clrTabBack;
	COLORREF clrFloatToolBarBorder;

	if (afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode())
	{
		COLORREF clrWindow = GetWindowColor();
		COLORREF clrFace = afxGlobalData.clrBarFace;

		m_clrMenuLight = RGB( (219 * GetRValue(clrWindow) + 36 * GetRValue(clrFace)) / 255,
			(219 * GetGValue(clrWindow) + 36 * GetGValue(clrFace)) / 255, (219 * GetBValue(clrWindow) + 36 * GetBValue(clrFace)) / 255);

		double H, S, L;
		CDrawingManager::RGBtoHSL(clrFace, &H, &S, &L);

		double S1;
		double L1;

		if (S < 0.1)
		{
			L1 = min(1., L +(1. - L) * .5);
			S1 = S == 0 ? 0 : min(1., S + .1);
		}
		else
		{
			L1 = min(1., 0.5 * L + 0.5);
			S1 = min(1., S * 2);
		}

		clrTabBack = CDrawingManager::HLStoRGB_ONE(H, L1, S1);

		m_clrBarBkgnd = RGB((40 * GetRValue(clrWindow) + 215 * GetRValue(clrFace)) / 255,
			(40 * GetGValue(clrWindow) + 215 * GetGValue(clrFace)) / 255, (40 * GetBValue(clrWindow) + 215 * GetBValue(clrFace)) / 255);

		m_clrMenuRarelyUsed = CDrawingManager::PixelAlpha(
			m_clrBarBkgnd, 94);

		m_clrInactiveTabText = CDrawingManager::PixelAlpha(clrFace, 55);

		COLORREF clrHL = afxGlobalData.clrHilite;
		CDrawingManager::RGBtoHSL(clrHL, &H, &S, &L);

		COLORREF clrMix = RGB((77 * GetRValue(clrHL) + 178 * GetRValue(m_clrMenuLight)) / 255,
			(77 * GetGValue(clrHL) + 178 * GetGValue(m_clrMenuLight)) / 255, (77 * GetBValue(clrHL) + 178 * GetBValue(m_clrMenuLight)) / 255);

		if (L > .8) // The highlight color is very light
		{
			m_clrHighlight = CDrawingManager::PixelAlpha(clrMix, 91);
			m_clrHighlightDn = CDrawingManager::PixelAlpha(clrMix, 98);
			m_clrMenuItemBorder = CDrawingManager::PixelAlpha(afxGlobalData.clrHilite, 84);
		}
		else
		{
			m_clrHighlight = CDrawingManager::PixelAlpha(clrMix, 102);
			m_clrHighlightDn = CDrawingManager::PixelAlpha(m_clrHighlight, 87);
			m_clrMenuItemBorder = afxGlobalData.clrHilite;
		}

		m_clrHighlightChecked = CDrawingManager::PixelAlpha(RGB((GetRValue(clrHL) + 5 * GetRValue(m_clrMenuLight)) / 6,
			(GetGValue(clrHL) + 5 * GetGValue(m_clrMenuLight)) / 6, (GetBValue(clrHL) + 5 * GetBValue(m_clrMenuLight)) / 6), 100);

		m_clrSeparator = CDrawingManager::PixelAlpha(afxGlobalData.clrBarFace, .86, .86, .86);

		m_clrPaneBorder = afxGlobalData.clrBarShadow;

		m_clrMenuBorder = CDrawingManager::PixelAlpha(clrFace, 55);

		clrFloatToolBarBorder = CDrawingManager::PixelAlpha(afxGlobalData.clrBarShadow, .85, .85, .85);

		m_clrGripper = CDrawingManager::PixelAlpha(afxGlobalData.clrBarShadow, 110);
	}
	else
	{
		m_clrMenuLight = afxGlobalData.clrWindow;

		m_clrBarBkgnd = afxGlobalData.clrBtnFace;

		if (afxGlobalData.m_bIsBlackHighContrast)
		{
			m_clrHighlightChecked = m_clrHighlightDn = m_clrHighlight = afxGlobalData.clrHilite;
			m_clrMenuRarelyUsed = afxGlobalData.clrBtnFace;
		}
		else
		{
			m_clrHighlightDn = m_clrHighlight = afxGlobalData.clrBtnFace;
			m_clrHighlightChecked = afxGlobalData.clrWindow;
			m_clrMenuRarelyUsed = afxGlobalData.clrBarLight;
		}

		clrTabBack = afxGlobalData.clrBtnFace;
		m_clrInactiveTabText = afxGlobalData.clrBtnDkShadow;
		m_clrSeparator = afxGlobalData.clrBtnShadow;
		m_clrGripper = afxGlobalData.clrBtnShadow;
		m_clrPaneBorder = afxGlobalData.clrBtnShadow;
		m_clrMenuBorder = afxGlobalData.clrBtnDkShadow;
		clrFloatToolBarBorder = afxGlobalData.clrBtnShadow;

		m_clrMenuItemBorder = afxGlobalData.IsHighContrastMode() ? afxGlobalData.clrBtnDkShadow : afxGlobalData.clrHilite;
	}

	m_brBarBkgnd.CreateSolidBrush(m_clrBarBkgnd);
	m_brMenuRarelyUsed.CreateSolidBrush(m_clrMenuRarelyUsed);
	m_brMenuLight.CreateSolidBrush(m_clrMenuLight);

	m_brHighlight.CreateSolidBrush(m_clrHighlight);
	m_brHighlightDn.CreateSolidBrush(m_clrHighlightDn);
	m_brHighlightChecked.CreateSolidBrush(m_clrHighlightChecked);
	m_brTabBack.CreateSolidBrush(clrTabBack);
	m_penSeparator.CreatePen(PS_SOLID, 1, m_clrSeparator);

	m_brFloatToolBarBorder.CreateSolidBrush(clrFloatToolBarBorder);

	m_clrPressedButtonBorder = (COLORREF)-1; // Used in derived classes

	m_penMenuItemBorder.DeleteObject();
	m_penMenuItemBorder.CreatePen(PS_SOLID, 1, m_clrMenuItemBorder);
}

void CMFCVisualManagerOfficeXP::OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar)
{
	ASSERT_VALID(pDC);

	if (pBar != NULL && pBar->IsDialogControl())
	{
		CMFCVisualManager::OnDrawBarGripper(pDC, rectGripper, bHorz, pBar);
		return;
	}

	if (m_brGripperHorz.GetSafeHandle() == NULL)
	{
		CreateGripperBrush();
	}

	BOOL bSideBar = pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CDockablePane));
	BOOL bMenuBar = pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar));

	CRect rectFill = rectGripper;

	if (!bSideBar)
	{
		if (bHorz)
		{
			int xCenter = rectFill.CenterPoint().x;
			rectFill.left = xCenter - 1;
			rectFill.right = xCenter + 2;
			rectFill.DeflateRect(0, 5);
		}
		else
		{
			int yCenter = rectFill.CenterPoint().y;
			rectFill.top = yCenter - 1;
			rectFill.bottom = yCenter + 2;
			rectFill.DeflateRect(5, 0);
		}
	}
	else
	{
		if (bHorz)
		{
			rectFill.DeflateRect(4, 0);
		}
		else
		{
			rectFill.DeflateRect(4, 0);
		}

		bHorz = !bHorz;
	}

	COLORREF clrTextOld = pDC->SetTextColor(m_clrGripper);
	COLORREF clrBkOld = pDC->SetBkColor(bSideBar || bMenuBar ? afxGlobalData.clrBarFace : m_clrBarBkgnd);

	pDC->FillRect(rectFill, bHorz ? &m_brGripperHorz : &m_brGripperVert);

	if (bSideBar)
	{
		//------------------
		// Draw bar caption:
		//------------------
		int nOldBkMode = pDC->SetBkMode(OPAQUE);
		pDC->SetTextColor(afxGlobalData.clrBarText);

		const CFont& font = CMFCMenuBar::GetMenuFont(bHorz);

		CFont* pOldFont = pDC->SelectObject((CFont*) &font);

		CString strCaption;
		pBar->GetWindowText(strCaption);
		strCaption = _T(" ") + strCaption + _T(" ");

		CRect rectText = rectGripper;
		UINT uiTextFormat = 0;

		TEXTMETRIC tm;
		pDC->GetTextMetrics(&tm);

		CPoint ptTextOffset(0, 0);
		if (bHorz)
		{
			ptTextOffset.y = (rectGripper.Height() - tm.tmHeight - 1) / 2;
		}
		else
		{
			ptTextOffset.x = (rectGripper.Width() - tm.tmHeight + 1) / 2;
		}

		if (bHorz)
		{
			rectText.top += ptTextOffset.y;
			pDC->DrawText(strCaption, &rectText, uiTextFormat);
		}
		else
		{
			rectText.left = rectText.right - ptTextOffset.x;
			rectText.top = rectGripper.top + ptTextOffset.y;
			rectText.bottom = rectGripper.top + 3 * ptTextOffset.y;

			uiTextFormat |= DT_NOCLIP;

			pDC->DrawText(strCaption, &rectText, uiTextFormat);
		}

		pDC->SelectObject(pOldFont);
		pDC->SetBkMode(nOldBkMode);
	}

	pDC->SetTextColor(clrTextOld);
	pDC->SetBkColor(clrBkOld);
}

void CMFCVisualManagerOfficeXP::OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pMenu);

	const BOOL bRTL = pMenu->GetExStyle() & WS_EX_LAYOUTRTL;

	pDC->Draw3dRect(rect, m_clrMenuBorder, m_clrMenuBorder);
	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(rect, m_clrMenuLight, m_clrMenuLight);

	CRect rectLeft(1, 1, 2, rect.bottom - 1);
	pDC->FillRect(rectLeft, &m_brBarBkgnd);

	//------------------------------------------------
	// Quick Customize Office XP like draw popup menu
	//------------------------------------------------
	CMFCPopupMenu* pParentPopup = pMenu->GetParentPopupMenu();
	if (pParentPopup != NULL)
	{
		if (pParentPopup->IsQuickCustomize() && !bRTL)
		{
			CMFCToolBarMenuButton* pParentBtn = pMenu->GetParentButton();
			if ((pParentBtn != NULL) &&(pParentBtn->IsQuickMode()))
			{
				CMFCPopupMenu* pParent = (CMFCPopupMenu*)pMenu->GetParentPopupMenu();

				CRect rcParent;
				pParent->GetWindowRect(rcParent);

				CRect rcCurrent;
				pMenu->GetWindowRect(rcCurrent);

				CMFCToolBarMenuButton* pBtn = pMenu->GetMenuItem(0);
				CRect rcButton = pBtn->Rect();

				CRect rectBorder;
				rectBorder.SetRectEmpty();

				if (rcParent.left > rcCurrent.left)
				{
					if (rcParent.top <= rcCurrent.top)
					{
						rectBorder.SetRect(rect.right - 1, rect.top, rect.right + 1, rcButton.bottom);
					}
					else
					{
						// up
						rectBorder.SetRect(rect.right - 1, rect.bottom - rcButton.Height(), rect.right + 1, rect.bottom);
					}
				}
				else
				{
					if (rcParent.top <= rcCurrent.top)
					{
						rectBorder.SetRect(rect.left - 1, rect.top, rect.left + 1, rcButton.bottom);
					}
					else
					{
						// up
						rectBorder.SetRect(rect.left - 1, rect.bottom - rcButton.Height(), rect.left + 1, rect.bottom);
					}
				}

				if (!rectBorder.IsRectEmpty())
				{
					pDC->FillRect(rectBorder, &m_brBarBkgnd);
				}
			}
		}
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		//-------------------------------------
		// "Connect" menu to the parent button:
		//-------------------------------------
		CMFCToolBarMenuButton* pParentMenuBtn = pMenu->GetParentButton();
		if (m_bConnectMenuToParent && pParentMenuBtn != NULL && pMenu->GetParentPopupMenu() == NULL && pParentMenuBtn->IsBorder())
		{
			CRect rectConnect;
			rectConnect.SetRectEmpty();

			CRect rectParent = pParentMenuBtn->Rect();
			CWnd* pWnd = pParentMenuBtn->GetParentWnd();
			pWnd->ClientToScreen(rectParent);
			pMenu->ScreenToClient(&rectParent);

			switch(pMenu->GetDropDirection())
			{
			case CMFCPopupMenu::DROP_DIRECTION_BOTTOM:
				rectConnect = CRect(rectParent.left + 1, rect.top - 1, rectParent.right - 1, rect.top);

				if (rectConnect.Width() > rect.Width() + 2)
				{
					return;
				}

				break;

			case CMFCPopupMenu::DROP_DIRECTION_TOP:
				rectConnect = CRect(rectParent.left + 1, rect.bottom, rectParent.right - 1, rect.bottom + 1);

				if (rectConnect.Width() > rect.Width() + 2)
				{
					return;
				}

				break;

			case CMFCPopupMenu::DROP_DIRECTION_RIGHT:
				rectConnect = CRect(rect.left - 1, rectParent.top + 1, rect.left, rectParent.bottom - 1);

				if (rectConnect.Height() > rect.Height() + 2)
				{
					return;
				}

				break;

			case CMFCPopupMenu::DROP_DIRECTION_LEFT:
				rectConnect = CRect(rect.right, rectParent.top + 1, rect.right + 1, rectParent.bottom - 1);

				if (rectConnect.Height() > rect.Height() + 2)
				{
					return;
				}

				break;
			}

			CRect rectBorder = rect;
			rectBorder.InflateRect(1, 1);
			rectConnect.IntersectRect(&rectConnect, &rectBorder);
			rectParent.InflateRect(1, 1);
			rectConnect.IntersectRect(&rectConnect, &rectParent);

			pDC->FillRect(rectConnect, &m_brBarBkgnd);
		}
	}
}

void CMFCVisualManagerOfficeXP::OnDrawMenuShadow(CDC* pPaintDC, const CRect& rectClient, const CRect& rectExclude,
	int nDepth, int iMinBrightness, int iMaxBrightness, CBitmap* pBmpSaveBottom,  CBitmap* pBmpSaveRight, BOOL bRTL)
{
	ASSERT_VALID(pPaintDC);
	ASSERT_VALID(pBmpSaveBottom);
	ASSERT_VALID(pBmpSaveRight);

	if (rectExclude.IsRectNull())
	{
		//------------------------
		// Simple draw the shadow:
		//------------------------
		CDrawingManager dm(*pPaintDC);
		dm.DrawShadow(rectClient, nDepth, iMinBrightness, iMaxBrightness, pBmpSaveBottom, pBmpSaveRight, m_clrMenuShadowBase, !bRTL);
	}
	else
	{
		//--------------------------------------------
		// Copy screen content into the memory bitmap:
		//--------------------------------------------
		CDC dcMem;
		if (!dcMem.CreateCompatibleDC(pPaintDC))
		{
			ASSERT(FALSE);
			return;
		}

		//--------------------------------------------
		// Gets the whole menu and changes the shadow.
		//--------------------------------------------
		CRect rectBmp(0, 0, rectClient.Width(), rectClient.Height());
		int cx = rectBmp.Width() + nDepth;
		int cy = rectBmp.Height() + nDepth;
		CBitmap bmpMem;
		if (!bmpMem.CreateCompatibleBitmap(pPaintDC, cx, cy))
		{
			ASSERT(FALSE);
			return;
		}

		CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
		ENSURE(pOldBmp != NULL);

		dcMem.BitBlt(0, 0, cx, cy, pPaintDC, rectClient.left, rectClient.top, SRCCOPY);

		//-----------------
		// Draw the shadow:
		//-----------------
		CDrawingManager dm(dcMem);
		dm.DrawShadow(rectBmp, nDepth, iMinBrightness, iMaxBrightness, pBmpSaveBottom, pBmpSaveRight, m_clrMenuShadowBase, !bRTL);

		//------------------------------------------
		// Do not cover rectExclude with the shadow:
		//------------------------------------------
		dcMem.BitBlt(rectExclude.left - rectClient.left, rectExclude.top - rectClient.top, rectExclude.Width(), rectExclude.Height(),
			pPaintDC, rectExclude.left, rectExclude.top, SRCCOPY);

		//-----------------------------------------
		// Copy shadowed bitmap back to the screen:
		//-----------------------------------------
		pPaintDC->BitBlt(rectClient.left, rectClient.top, cx, cy, &dcMem, 0, 0, SRCCOPY);

		dcMem.SelectObject(pOldBmp);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect)
{
	ASSERT_VALID(pBar);
	ASSERT_VALID(pDC);

	if (pBar->IsDialogControl())
	{
		CMFCVisualManager::OnDrawPaneBorder(pDC, pBar, rect);
		return;
	}

	DWORD dwBarStyle = pBar->GetPaneStyle();
	if (!(dwBarStyle & CBRS_BORDER_ANY))
	{
		return;
	}

	COLORREF clrBckOld = pDC->GetBkColor(); // FillSolidRect changes it

	if (dwBarStyle & CBRS_BORDER_LEFT)
		pDC->FillSolidRect(0, 0, 1, rect.Height() - 1, afxGlobalData.clrBarFace);
	if (dwBarStyle & CBRS_BORDER_TOP)
		pDC->FillSolidRect(0, 0, rect.Width()-1 , 1, afxGlobalData.clrBarFace);
	if (dwBarStyle & CBRS_BORDER_RIGHT)
		pDC->FillSolidRect(rect.right, 0/*RGL~:1*/, -1,
		rect.Height()/*RGL-: - 1*/, afxGlobalData.clrBarFace);
	if (dwBarStyle & CBRS_BORDER_BOTTOM)
		pDC->FillSolidRect(0, rect.bottom, rect.Width()-1, -1, afxGlobalData.clrBarFace);

	if (dwBarStyle & CBRS_BORDER_LEFT)
		++rect.left;
	if (dwBarStyle & CBRS_BORDER_TOP)
		++rect.top;
	if (dwBarStyle & CBRS_BORDER_RIGHT)
		--rect.right;
	if (dwBarStyle & CBRS_BORDER_BOTTOM)
		--rect.bottom;

	// Restore Bk color:
	pDC->SetBkColor(clrBckOld);
}

void CMFCVisualManagerOfficeXP::OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL /*bNCArea*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (DYNAMIC_DOWNCAST(CReBar, pBar) != NULL || DYNAMIC_DOWNCAST(CReBar, pBar->GetParent()))
	{
		FillReBarPane(pDC, pBar, rectClient);
		return;
	}

	if (rectClip.IsRectEmpty())
	{
		rectClip = rectClient;
	}

	CRuntimeClass* pBarClass = pBar->GetRuntimeClass();

	if (pBarClass == NULL || pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCMenuBar)))
	{
		CMFCVisualManager::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
		return;
	}

	if (pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCOutlookBarPane)))
	{
		CMFCOutlookBarPane* pOlBar = DYNAMIC_DOWNCAST(CMFCOutlookBarPane, pBar);
		ASSERT_VALID(pOlBar);

		if (pOlBar->IsBackgroundTexture())
		{
			CMFCVisualManager::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
			return;
		}
	}

	if (pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCColorBar)))
	{
		if (pBar->IsDialogControl())
		{
			CMFCVisualManager::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
		}
		else
		{
			pDC->FillRect(rectClip, ((CMFCColorBar*) pBar)->IsTearOff() ? &m_brBarBkgnd : &m_brMenuLight);
		}

		return;
	}

	if (pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCPopupMenuBar)))
	{
		pDC->FillRect(rectClip, &m_brMenuLight);

		CMFCPopupMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pBar);
		if (!pMenuBar->m_bDisableSideBarInXPMode)
		{
			CRect rectImages = rectClient;
			rectImages.right = rectImages.left + pMenuBar->GetGutterWidth ();
			rectImages.DeflateRect (0, 1);

			pDC->FillRect(rectImages, &m_brBarBkgnd);
		}

		return;
	}

	if (pBarClass->IsDerivedFrom(RUNTIME_CLASS(CMFCToolBar)))
	{
		if (pBar->IsDialogControl())
		{
			CMFCVisualManager::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
		}
		else
		{
			pDC->FillRect(rectClip, &m_brBarBkgnd);
		}

		return;
	}

	if (pBarClass->IsDerivedFrom(RUNTIME_CLASS(CAutoHideDockSite)))
	{
		pDC->FillRect(rectClip, &m_brTabBack);
		return;
	}

	CMFCVisualManager::OnFillBarBackground(pDC, pBar, rectClient, rectClip);
}

void CMFCVisualManagerOfficeXP::OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bHorz)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBar);

	if (pBar->IsDialogControl())
	{
		CMFCVisualManager::OnDrawSeparator(pDC, pBar, rect, bHorz);
		return;
	}

	CRect rectSeparator = rect;

	CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
	ENSURE(pOldPen != NULL);

	int x1, x2;
	int y1, y2;

	if (bHorz)
	{
		x1 = x2 = (rect.left + rect.right) / 2;
		y1 = rect.top;
		y2 = rect.bottom - 1;
	}
	else
	{
		y1 = y2 = (rect.top + rect.bottom) / 2;
		x1 = rect.left;
		x2 = rect.right;

		BOOL bIsRibbon = FALSE;

		bIsRibbon = pBar->IsKindOf(RUNTIME_CLASS(CMFCRibbonPanelMenuBar));

		if (bIsRibbon &&((CMFCRibbonPanelMenuBar*) pBar)->IsDefaultMenuLook())
		{
			bIsRibbon = FALSE;
		}

		if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)) && !bIsRibbon && !pBar->IsKindOf(RUNTIME_CLASS(CMFCColorBar)))
		{

			x1 = rect.left + CMFCToolBar::GetMenuImageSize().cx + GetMenuImageMargin() + 1; 
			CRect rectBar;
			pBar->GetClientRect(rectBar);

			if (rectBar.right - x2 < 50) // Last item in row
			{
				x2 = rectBar.right;
			}

			if (((CMFCPopupMenuBar*) pBar)->m_bDisableSideBarInXPMode)
			{
				x1 = 0;
			}

			//---------------------------------
			// Maybe Quick Customize separator
			//---------------------------------
			if (pBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
			{
				CWnd* pWnd = pBar->GetParent();
				if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CMFCPopupMenu)))
				{
					CMFCPopupMenu* pMenu = (CMFCPopupMenu*)pWnd;
					if (pMenu->IsCustomizePane())
					{
						x1 = rect.left + 2*CMFCToolBar::GetMenuImageSize().cx + 3*GetMenuImageMargin() + 2;
					}
				}
			}
		}
	}

	pDC->MoveTo(x1, y1);
	pDC->LineTo(x2, y2);

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOfficeXP::OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (state != ButtonsIsPressed && state != ButtonsIsHighlighted)
	{
		ASSERT((pButton->m_nStyle & TBBS_CHECKED) == 0);
		return;
	}

	COLORREF clrBorder = m_clrMenuItemBorder;

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	BOOL bIsMenuButton = pMenuButton != NULL;

	BOOL bIsPopupMenu = bIsMenuButton && pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));

	BOOL bIsPressedBorder = !bIsPopupMenu;

	if (bIsMenuButton && !bIsPopupMenu && pMenuButton->IsDroppedDown())
	{
		bIsPressedBorder = FALSE;

		CMFCPopupMenu* pPopupMenu= pMenuButton->GetPopupMenu();
		if (pPopupMenu != NULL && (pPopupMenu->IsWindowVisible() || pPopupMenu->IsShown()))
		{
			clrBorder = m_clrMenuBorder;
			ExtendMenuButton(pMenuButton, rect);

			BOOL bRTL = pPopupMenu->GetExStyle() & WS_EX_LAYOUTRTL;

			if (m_bShdowDroppedDownMenuButton && !bRTL && CMFCMenuBar::IsMenuShadows() && !CMFCToolBar::IsCustomizeMode() &&
				afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode() && !pPopupMenu->IsRightAlign())
			{
				CDrawingManager dm(*pDC);

				dm.DrawShadow(rect, m_nMenuShadowDepth, 100, 75, NULL, NULL, m_clrMenuShadowBase);
			}
		}
	}

	const BOOL bIsChecked = (pButton->m_nStyle & TBBS_CHECKED);

	switch(state)
	{
	case ButtonsIsPressed:
		if (bIsPressedBorder && m_clrPressedButtonBorder != (COLORREF)-1 && !bIsChecked && rect.Width() > 5 && rect.Height() > 5)
		{
			clrBorder = m_clrPressedButtonBorder;
		}

	case ButtonsIsHighlighted:
		if (bIsPopupMenu && bIsChecked)
		{
			if (pButton->m_nStyle & TBBS_MARKED)
			{
				clrBorder = m_clrPressedButtonBorder;
			}

			rect.bottom ++;
		}

		pDC->Draw3dRect(rect, clrBorder, clrBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (state != ButtonsIsPressed && state != ButtonsIsHighlighted)
	{
		return;
	}

	if (CMFCToolBar::IsCustomizeMode() && !CMFCToolBar::IsAltCustomizeMode() && !pButton->IsLocked())
	{
		return;
	}

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButton);
	BOOL bIsMenuButton = pMenuButton != NULL;
	BOOL bIsPopupMenu = bIsMenuButton && pMenuButton->GetParentWnd() != NULL && pMenuButton->GetParentWnd()->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar));
	if (!bIsPopupMenu && !m_bEnableToolbarButtonFill)
	{
		return;
	}

	CBrush* pBrush = ((pButton->m_nStyle & TBBS_PRESSED) && !bIsPopupMenu) ? &m_brHighlightDn : &m_brHighlight;

	if (bIsMenuButton && !bIsPopupMenu && pMenuButton->IsDroppedDown())
	{
		ExtendMenuButton(pMenuButton, rect);
		pBrush = &m_brBarBkgnd;
	}

	if (pButton->m_nStyle & TBBS_CHECKED)
	{
		pBrush = (state == ButtonsIsHighlighted) ? &m_brHighlightDn : &m_brHighlightChecked;
	}

	if (bIsMenuButton &&(pButton->m_nStyle & TBBS_DISABLED))
	{
		pBrush = &m_brMenuLight;
	}

	switch(state)
	{
	case ButtonsIsPressed:
	case ButtonsIsHighlighted:
		if ((pButton->m_nStyle & TBBS_CHECKED) == 0)
		{
			rect.DeflateRect(1, 1);
		}

		OnFillHighlightedArea(pDC, rect, pBrush, pButton);
	}
}

void CMFCVisualManagerOfficeXP::OnHighlightMenuItem(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CBrush* pBrush = (pButton->m_nStyle & TBBS_DISABLED) ? &m_brMenuLight : &m_brHighlight;

	rect.DeflateRect(1, 0);

	OnFillHighlightedArea(pDC, rect, pBrush, pButton);
	pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);

	clrText = GetHighlightedMenuItemTextColor(pButton);
}

COLORREF CMFCVisualManagerOfficeXP::GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton)
{
	ASSERT_VALID(pButton);

	if (pButton->m_nStyle & TBBS_DISABLED)
	{
		return afxGlobalData.clrGrayedText;
	}

	if (GetRValue(m_clrHighlight) > 128 && GetGValue(m_clrHighlight) > 128 && GetBValue(m_clrHighlight) > 128)
	{
		return RGB(0, 0, 0);
	}
	else
	{
		return RGB(255, 255, 255);
	}
}

void CMFCVisualManagerOfficeXP::OnHighlightQuickCustomizeMenuButton(CDC* pDC, CMFCToolBarMenuButton* /*pButton*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brBarBkgnd);
	pDC->Draw3dRect(rect, m_clrMenuBorder, m_clrMenuBorder);
}

void CMFCVisualManagerOfficeXP::OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed)
{
	ASSERT_VALID(pDC);

	rectRarelyUsed.left --;
	rectRarelyUsed.right = rectRarelyUsed.left + CMFCToolBar::GetMenuImageSize().cx + 2 * GetMenuImageMargin() + 2;

	pDC->FillRect(rectRarelyUsed, &m_brMenuRarelyUsed);
}

void CMFCVisualManagerOfficeXP::OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
#define AFX_TEXT_MARGIN 4
#define AFX_IMAGE_MARGIN 4

	ASSERT_VALID(pTabWnd);
	ASSERT_VALID(pDC);

	if (pTabWnd->IsFlatTab() || pTabWnd->IsOneNoteStyle() || pTabWnd->IsColored() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManager::OnDrawTab(pDC, rectTab, iTab, bIsActive, pTabWnd);
		return;
	}

	COLORREF clrDark;
	COLORREF clrBlack;
	COLORREF clrHighlight;
	COLORREF clrFace;
	COLORREF clrDarkShadow;
	COLORREF clrLight;
	CBrush* pbrFace = NULL;
	CBrush* pbrBlack = NULL;

	GetTabFrameColors(pTabWnd, clrDark, clrBlack, clrHighlight, clrFace, clrDarkShadow, clrLight, pbrFace, pbrBlack);

	CPen penGray(PS_SOLID, 1, clrDark);
	CPen penDkGray(PS_SOLID, 1, clrBlack);
	CPen penHiLight(PS_SOLID, 1, clrHighlight);

	CPen* pOldPen = pDC->SelectObject(&penGray);
	ENSURE(pOldPen != NULL);

	if (iTab != pTabWnd->GetActiveTab() - 1)
	{
		if (iTab < pTabWnd->GetVisibleTabsNum() - 1 || m_bDrawLastTabLine)
		{
			pDC->MoveTo(rectTab.right, rectTab.top + 3);
			pDC->LineTo(rectTab.right, rectTab.bottom - 3);
		}
	}

	if (bIsActive)
	{
		if (pTabWnd->GetLocation() == CMFCBaseTabCtrl::LOCATION_BOTTOM)
		{
			CRect rectFace = rectTab;
			rectFace.top--;

			OnFillTab(pDC, rectFace, pbrFace, iTab, bIsActive, pTabWnd);

			pDC->SelectObject(&penDkGray);

			pDC->MoveTo(rectTab.right, rectTab.top);
			pDC->LineTo(rectTab.right, rectTab.bottom);
			pDC->LineTo(rectTab.left, rectTab.bottom);

			pDC->SelectObject(&penHiLight);
			pDC->LineTo(rectTab.left, rectTab.top - 2);
		}
		else
		{
			CPen penLight(PS_SOLID, 1, m_clrMenuLight);

			CRect rectFace = rectTab;
			rectFace.bottom++;
			rectFace.left++;

			OnFillTab(pDC, rectFace, pbrFace, iTab, bIsActive, pTabWnd);

			pDC->SelectObject(&penDkGray);
			pDC->MoveTo(rectTab.right, rectTab.bottom);
			pDC->LineTo(rectTab.right, rectTab.top);

			pDC->SelectObject(&penHiLight);

			pDC->LineTo(rectTab.right, rectTab.top);
			pDC->LineTo(rectTab.left, rectTab.top);
			pDC->LineTo(rectTab.left, rectTab.bottom);
		}
	}

	pDC->SelectObject(pOldPen);

	COLORREF clrText;

	if (pTabWnd->IsDialogControl())
	{
		clrText = afxGlobalData.clrBtnText;
	}
	else
	{
		clrText = bIsActive ? afxGlobalData.clrBarText : m_clrInactiveTabText;
	}

	OnDrawTabContent(pDC, rectTab, iTab, bIsActive, pTabWnd, clrText);
}

void CMFCVisualManagerOfficeXP::OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pbrFill);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->GetTabBkColor(iTab) != (COLORREF)-1 && !bIsActive)
	{
		CBrush br(pTabWnd->GetTabBkColor(iTab));
		pDC->FillRect(rectFill, &br);
		return;
	}

	if (pTabWnd->IsOneNoteStyle() || pTabWnd->IsVS2005Style() || pTabWnd->IsLeftRightRounded())
	{
		CMFCVisualManager::OnFillTab(pDC, rectFill, pbrFill, iTab, bIsActive, pTabWnd);
	}
	else if (bIsActive)
	{
		pDC->FillRect(rectFill, pbrFill);
	}
}

void CMFCVisualManagerOfficeXP::OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pTabWnd);

	if (pTabWnd->IsFlatTab())
	{
		CMFCVisualManager::OnEraseTabsArea(pDC, rect, pTabWnd);
		return;
	}

	if (pTabWnd->IsDialogControl())
	{
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		return;
	}

	pDC->FillRect(rect, &m_brTabBack);
}

COLORREF CMFCVisualManagerOfficeXP::OnDrawPaneCaption(CDC* pDC, CDockablePane* /*pBar*/, BOOL bActive, CRect rectCaption, CRect /*rectButtons*/)
{
	ASSERT_VALID(pDC);

	CPen pen(PS_SOLID, 1, bActive ? afxGlobalData.clrBarLight : afxGlobalData.clrBarShadow);
	CPen* pOldPen = pDC->SelectObject(&pen);

	CBrush* pOldBrush = (CBrush*) pDC->SelectObject(bActive ? &afxGlobalData.brActiveCaption : &afxGlobalData.brBarFace);

	if (bActive)
	{
		rectCaption.InflateRect(1, 1);
	}

	pDC->RoundRect(rectCaption, CPoint(2, 2));

	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);

	// get the text color
	COLORREF clrCptnText = bActive ? afxGlobalData.clrCaptionText : afxGlobalData.clrBarText;

	return clrCptnText;
}

void CMFCVisualManagerOfficeXP::OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID /*= -1*/)
{
	ASSERT_VALID(pDC);
	ENSURE(pButton != NULL);

	CRect rc = pButton->GetRect();

	if (pButton->m_bPushed &&(pButton->m_bFocused || pButton->m_bDroppedDown) && !bDisabled)
	{
		OnFillHighlightedArea(pDC, rc, &m_brHighlightDn, NULL);
		bActive = TRUE;
	}
	else if (pButton->m_bPushed || pButton->m_bFocused || pButton->m_bDroppedDown)
	{
		if (!bDisabled)
		{
			OnFillHighlightedArea(pDC, rc, &m_brHighlight, NULL);
		}

		bActive = FALSE;
	}

	CMenuImages::IMAGES_IDS id = (CMenuImages::IMAGES_IDS)-1;

	if (nImageID != -1)
	{
		id = (CMenuImages::IMAGES_IDS)nImageID;
	}
	else
	{
		id = pButton->GetIconID(bHorz, bMaximized);
	}

	if (id != (CMenuImages::IMAGES_IDS)-1)
	{
		CSize sizeImage = CMenuImages::Size();
		CPoint ptImage(rc.left +(rc.Width() - sizeImage.cx) / 2, rc.top +(rc.Height() - sizeImage.cy) / 2);

		OnDrawCaptionButtonIcon(pDC, pButton, id, bActive, bDisabled, ptImage);
	}

	if ((pButton->m_bPushed || pButton->m_bFocused || pButton->m_bDroppedDown) && !bDisabled)
	{
		COLORREF clrDark = afxGlobalData.clrBarDkShadow;
		pDC->Draw3dRect(rc, clrDark, clrDark);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawCaptionButtonIcon(CDC* pDC, CMFCCaptionButton* pButton, CMenuImages::IMAGES_IDS id, BOOL bActive, BOOL bDisabled, CPoint ptImage)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	CMenuImages::IMAGE_STATE imageState;

	if (bDisabled)
	{
		imageState = CMenuImages::ImageGray;
	}
	else if (pButton->m_bFocused || pButton->m_bPushed)
	{
		COLORREF clrBack = pButton->m_bPushed ? m_clrHighlightDn : m_clrHighlight;

		if (GetRValue(clrBack) <= 192 && GetGValue(clrBack) <= 192 && GetBValue(clrBack) <= 192)
		{
			imageState = CMenuImages::ImageWhite;
		}
		else
		{
			imageState = CMenuImages::ImageBlack;
		}
	}
	else if (pButton->m_clrForeground == (COLORREF)-1)
	{
		imageState = bActive ? CMenuImages::ImageWhite : CMenuImages::ImageBlack;
	}
	else
	{
		if (GetRValue(pButton->m_clrForeground) > 192 && GetGValue(pButton->m_clrForeground) > 192 && GetBValue(pButton->m_clrForeground) > 192)
		{
			imageState = CMenuImages::ImageWhite;
		}
		else
		{
			imageState = CMenuImages::ImageBlack;
		}
	}

	CMenuImages::Draw(pDC, id, ptImage, imageState);
}

COLORREF CMFCVisualManagerOfficeXP::OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	COLORREF clrText = afxGlobalData.clrBarText;

	int nImageWidth = CMFCToolBar::GetMenuImageSize().cx + GetMenuImageMargin();

	if (bIsSelected)
	{
		if (m_bEnableToolbarButtonFill)
		{
			rect.left = 0;
		}

		OnFillHighlightedArea(pDC, rect, &m_brHighlight, NULL);

		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);

		// Now, we should define a menu text color...
		if (GetRValue(m_clrHighlight) > 128 && GetGValue(m_clrHighlight) > 128 && GetBValue(m_clrHighlight) > 128)
		{
			clrText = RGB(0, 0, 0);
		}
		else
		{
			clrText = RGB(255, 255, 255);
		}
	}
	else
	{
		pDC->FillRect(rect, &m_brMenuLight);

		CRect rectImages = rect;
		rectImages.right = rectImages.left + nImageWidth + AFX_MENU_IMAGE_MARGIN;

		pDC->FillRect(rectImages, &m_brBarBkgnd);

		clrText = afxGlobalData.clrBarText;
	}

	return clrText;
}

void CMFCVisualManagerOfficeXP::OnDrawMenuArrowOnCustomizeList(CDC* pDC, CRect rectCommand, BOOL /*bSelected*/)
{
	ASSERT_VALID(pDC);

	CRect rectTriangle = rectCommand;
	rectTriangle.left = rectTriangle.right - CMenuImages::Size().cx;

	CMenuImages::IMAGE_STATE state = CMenuImages::ImageBlack;
	COLORREF clrPen = RGB(0, 0, 0);

	if (GetRValue(m_clrHighlight) < 128 || GetGValue(m_clrHighlight) < 128 || GetBValue(m_clrHighlight) < 128)
	{
		state = CMenuImages::ImageWhite;
		clrPen = RGB(255, 255, 255);
	}

	CMenuImages::Draw(pDC, CMenuImages::IdArrowRightLarge, rectTriangle, state);

	CPen penLine(PS_SOLID, 1, clrPen);
	CPen* pOldPen = pDC->SelectObject(&penLine);
	ENSURE(pOldPen != NULL);

	pDC->MoveTo(rectTriangle.left - 1, rectCommand.top + 2);
	pDC->LineTo(rectTriangle.left - 1, rectCommand.bottom - 2);

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOfficeXP::OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive)
{
	const int nBorderSize = 1;
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brMenuLight);

	rect.DeflateRect(nBorderSize, nBorderSize);
	OnFillHighlightedArea(pDC, rect, bIsActive ? &m_brHighlight : &m_brBarBkgnd, NULL);

	// Draw gripper:
	int nGripperWidth = max(20, CMFCToolBar::GetMenuImageSize().cx * 2);

	CRect rectGripper = rect;
	rectGripper.DeflateRect((rectGripper.Width() - nGripperWidth) / 2, 1);

	if (m_brGripperHorz.GetSafeHandle() == NULL)
	{
		CreateGripperBrush();
	}

	COLORREF clrTextOld = pDC->SetTextColor(bIsActive ? afxGlobalData.clrBarDkShadow : afxGlobalData.clrBarShadow);
	COLORREF clrBkOld = pDC->SetBkColor(bIsActive ? m_clrHighlight : m_clrBarBkgnd);

	if (bIsActive)
	{
		rectGripper.DeflateRect(0, 1);
	}

	pDC->FillRect(rectGripper, &m_brGripperHorz);

	pDC->SetTextColor(clrTextOld);
	pDC->SetBkColor(clrBkOld);

	if (bIsActive)
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawMenuResizeBar(CDC* pDC, CRect rect, int nResizeFlags)
{
	ASSERT_VALID(pDC);

	const int nBorderSize = 1;
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brMenuLight);
	rect.DeflateRect(nBorderSize, nBorderSize);
	OnFillHighlightedArea(pDC, rect, &m_brBarBkgnd, NULL);

	CRect rectGripper = rect;

	if (nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_BOTTOM_RIGHT || nResizeFlags == (int) CMFCPopupMenu::MENU_RESIZE_TOP_RIGHT)
	{
		rectGripper.left = rectGripper.right - rectGripper.Height();
	}
	else
	{
		rectGripper.left = rectGripper.CenterPoint().x - rectGripper.Height() / 2;
		rectGripper.right = rectGripper.left + rectGripper.Height();
	}

	rectGripper.DeflateRect(2, 2);

	if (m_brGripperHorz.GetSafeHandle() == NULL)
	{
		CreateGripperBrush();
	}

	COLORREF clrTextOld = pDC->SetTextColor(afxGlobalData.clrBarShadow);
	COLORREF clrBkOld = pDC->SetBkColor(m_clrBarBkgnd);

	pDC->FillRect(rectGripper, &m_brGripperHorz);

	pDC->SetTextColor(clrTextOld);
	pDC->SetBkColor(clrBkOld);
}

void CMFCVisualManagerOfficeXP::OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL /*bIsPressed*/, BOOL /*bIsDisabled*/)
{
	ASSERT_VALID(pDC);

	rect.top --;
	pDC->FillRect(rect, &afxGlobalData.brBarFace);

	CMenuImages::Draw(pDC, bIsScrollDown ? CMenuImages::IdArrowDown : CMenuImages::IdArrowUp, rect);

	if (bIsHighlited)
	{
		CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);
		CPen* pOldPen = pDC->SelectObject(&pen);

		CBrush* pOldBrush = (CBrush*) pDC->SelectStockObject(NULL_BRUSH);

		rect.DeflateRect(1, 1);
		pDC->RoundRect(rect, CPoint(2, 2));

		pDC->SelectObject(pOldBrush);
		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManagerOfficeXP::CreateGripperBrush()
{
	ASSERT(m_brGripperHorz.GetSafeHandle() == NULL);
	ASSERT(m_brGripperVert.GetSafeHandle() == NULL);

	WORD horzHatchBits [8] = { 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00 };

	CBitmap bmpGripperHorz;
	bmpGripperHorz.CreateBitmap(8, 8, 1, 1, horzHatchBits);

	m_brGripperHorz.CreatePatternBrush(&bmpGripperHorz);

	WORD vertHatchBits[8] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };

	CBitmap bmpGripperVert;
	bmpGripperVert.CreateBitmap(8, 8, 1, 1, vertHatchBits);

	m_brGripperVert.CreatePatternBrush(&bmpGripperVert);
}

void CMFCVisualManagerOfficeXP::ExtendMenuButton(CMFCToolBarMenuButton* pMenuButton, CRect& rect)
{
	ASSERT_VALID(pMenuButton);

	CMFCPopupMenu* pPopupMenu= pMenuButton->GetPopupMenu();
	if (pPopupMenu == NULL || pPopupMenu->GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rectMenu;
	pPopupMenu->GetWindowRect(rectMenu);

	if (DYNAMIC_DOWNCAST(CMFCCustomizeButton, pMenuButton) != NULL)
	{
		CBasePane* pParentBar = DYNAMIC_DOWNCAST(CBasePane, pMenuButton->GetParentWnd());

		if (pParentBar != NULL)
		{
			CRect rectScreen = rect;
			pParentBar->ClientToScreen(&rectScreen);

			if (pParentBar->IsHorizontal())
			{
				rectScreen.top = rectMenu.top;
				rectScreen.bottom = rectMenu.bottom;
			}
			else
			{
				rectScreen.left = rectMenu.left;
				rectScreen.right = rectMenu.right;
				rectScreen.bottom++;
			}

			CRect rectInter;
			if (!rectInter.IntersectRect(rectScreen, rectMenu))
			{
				return;
			}
		}
	}

	int nGrow = 4;

	switch(pPopupMenu->GetDropDirection())
	{
	case CMFCPopupMenu::DROP_DIRECTION_BOTTOM:
		if (rectMenu.Width() < rect.Width())
		{
			nGrow = 1;
		}

		rect.bottom += nGrow;
		break;

	case CMFCPopupMenu::DROP_DIRECTION_TOP:
		if (rectMenu.Width() < rect.Width())
		{
			nGrow = 1;
		}

		rect.top -= nGrow;
		break;

	case CMFCPopupMenu::DROP_DIRECTION_RIGHT:
		if (rectMenu.Height() < rect.Height())
		{
			nGrow = 1;
		}

		rect.right += nGrow;
		break;

	case CMFCPopupMenu::DROP_DIRECTION_LEFT:
		if (rectMenu.Height() < rect.Height())
		{
			nGrow = 1;
		}

		rect.left -= nGrow;
		break;
	}
}

void CMFCVisualManagerOfficeXP::OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight)
{
	ASSERT_VALID(pDC);

	BOOL bIsDisabled = (nStyle & TBBS_DISABLED);
	BOOL bIsPressed = (nStyle & TBBS_PRESSED);

	CMenuImages::IMAGES_IDS imageID;

	switch(uiSystemCommand)
	{
	case SC_CLOSE:
		imageID = CMenuImages::IdClose;
		break;

	case SC_MINIMIZE:
		imageID = CMenuImages::IdMinimize;
		break;

	case SC_RESTORE:
		imageID = CMenuImages::IdRestore;
		break;

	default:
		return;
	}

	if (bHighlight && !bIsDisabled)
	{
		OnFillHighlightedArea(pDC, rect, bIsPressed ? &m_brHighlightDn : &m_brHighlight, NULL);

		COLORREF clrBorder = m_clrMenuItemBorder;
		pDC->Draw3dRect(rect, clrBorder, clrBorder);
	}

	CMenuImages::Draw(pDC, imageID, rect, bIsDisabled ? CMenuImages::ImageGray : bHighlight ? CMenuImages::ImageWhite : CMenuImages::ImageBlack);
}

void CMFCVisualManagerOfficeXP::OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* /*pBar*/, CRect rectPane, UINT /*uiID*/, UINT nStyle)
{
	if (!(nStyle & SBPS_NOBORDERS))
	{
		if (nStyle & SBPS_POPOUT)
		{
			CDrawingManager dm(*pDC);
			dm.HighlightRect(rectPane);
		}

		// Draw pane border:
		pDC->Draw3dRect(rectPane, m_clrPaneBorder, m_clrPaneBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* /*pButton*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	COLORREF clrText = pDC->GetTextColor();

	if (bIsDropped || bIsHighlighted)
	{
		OnFillHighlightedArea(pDC, rect, bIsDropped ? &m_brHighlightDn : &m_brHighlight, NULL);

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawLine(rect.left, rect.top, rect.left, rect.bottom, m_clrMenuItemBorder);
		}
		else
		{
			CPen* pOldPen = pDC->SelectObject(&m_penMenuItemBorder);
			ENSURE(pOldPen != NULL);

			pDC->MoveTo(rect.left, rect.top);
			pDC->LineTo(rect.left, rect.bottom);

			pDC->SelectObject(pOldPen);
		}
	}
	else
	{
		pDC->FillRect(rect, &afxGlobalData.brBarFace);

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, (COLORREF)-1, afxGlobalData.clrWindow);
		}
		else
		{
			pDC->Draw3dRect(rect, afxGlobalData.clrBarWindow, afxGlobalData.clrBarWindow);
		}
	}

	CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rect, bDisabled ? CMenuImages::ImageGray : (bIsDropped && bIsHighlighted) ? CMenuImages::ImageWhite : CMenuImages::ImageBlack);

	pDC->SetTextColor(clrText);
}

void CMFCVisualManagerOfficeXP::OnDrawComboBorder(CDC* pDC, CRect rect, BOOL /*bDisabled*/, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* /*pButton*/)
{
	if (bIsHighlighted || bIsDropped)
	{
		rect.DeflateRect(1, 1);
		pDC->Draw3dRect(&rect,  m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* /*pTabWnd*/, BOOL bIsHighlighted, BOOL bIsPressed, BOOL /*bIsDisabled*/)
{
	if (bIsHighlighted)
	{
		OnFillHighlightedArea(pDC, rect, bIsPressed ? &m_brHighlightDn : &m_brHighlight, NULL);
	}

	CMenuImages::Draw(pDC, CMenuImages::IdClose, rect, CMenuImages::ImageBlack);

	if (bIsHighlighted)
	{
		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pWndTab);

	if (pWndTab->IsFlatTab())
	{
		CBrush* pBrush = pButton->IsPressed() ? &m_brHighlightDn : pButton->IsHighlighted() ? &m_brHighlight : &afxGlobalData.brBarFace;

		pDC->FillRect(rect, pBrush);
		OnFillHighlightedArea(pDC, rect, pBrush, NULL);
	}
	else if (pWndTab->IsDialogControl())
	{
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
	}
	else
	{
		pDC->FillRect(rect, &m_brTabBack);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT /*uiState*/, CMFCBaseTabCtrl* pWndTab)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);
	ASSERT_VALID(pWndTab);

	if (pWndTab->IsFlatTab())
	{
		if (pButton->IsPushed() || pButton->IsHighlighted())
		{
			COLORREF clrDark = afxGlobalData.clrBarDkShadow;
			pDC->Draw3dRect(rect, clrDark, clrDark);
		}
	}
	else
	{
		if (pButton->IsPushed() || pButton->IsHighlighted())
		{
			if (pButton->IsPressed())
			{
				pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, m_clrGripper);
			}
			else
			{
				pDC->Draw3dRect(rect, m_clrGripper, afxGlobalData.clrBarDkShadow);
			}
		}
	}
}

COLORREF CMFCVisualManagerOfficeXP::OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	BOOL bIsToolBar = FALSE;
	BOOL bIsTasksPane = pFrameWnd->IsKindOf( RUNTIME_CLASS( CMFCTasksPaneFrameWnd ) );

	if (DYNAMIC_DOWNCAST(CMFCBaseToolBar, pFrameWnd->GetPane()) != NULL)
	{
		bActive = FALSE;
		bIsToolBar = TRUE;
	}

	if (bIsToolBar)
	{
		pDC->FillRect(rectCaption, &m_brFloatToolBarBorder);
		return afxGlobalData.clrCaptionText;
	}
	else if (bIsTasksPane)
	{
		pDC->FillRect(rectCaption, &afxGlobalData.brBarFace);
		return afxGlobalData.clrBarText;
	}

	pDC->FillRect(rectCaption, bActive ? &afxGlobalData.brActiveCaption : &afxGlobalData.brInactiveCaption);

	// get the text color
	return afxGlobalData.clrCaptionText;
}

void CMFCVisualManagerOfficeXP::OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pFrameWnd);

	BOOL bIsTasksPane = pFrameWnd->IsKindOf( RUNTIME_CLASS( CMFCTasksPaneFrameWnd ) );

	if (bIsTasksPane)
	{
		CBrush* pOldBrush = pDC->SelectObject(&m_brFloatToolBarBorder);
		ENSURE(pOldBrush != NULL);

		pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorderSize.left, rectBorder.Height(), PATCOPY);
		pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorder.Width(), rectBorderSize.top, PATCOPY);
		pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top, rectBorderSize.right, rectBorder.Height(), PATCOPY);
		pDC->PatBlt(rectBorder.left, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width(), rectBorderSize.bottom, PATCOPY);

		rectBorderSize.DeflateRect(2, 2);
		rectBorder.DeflateRect(2, 2);

		pDC->SelectObject(bIsTasksPane ? &afxGlobalData.brLight : &afxGlobalData.brBarFace);

		pDC->PatBlt(rectBorder.left, rectBorder.top + 1, rectBorderSize.left, rectBorder.Height() - 2, PATCOPY);
		pDC->PatBlt(rectBorder.left + 1, rectBorder.top, rectBorder.Width() - 2, rectBorderSize.top, PATCOPY);
		pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top + 1, rectBorderSize.right, rectBorder.Height() - 2, PATCOPY);
		pDC->PatBlt(rectBorder.left + 1, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width() - 2, rectBorderSize.bottom, PATCOPY);

		pDC->SelectObject(pOldBrush);
	}
	else
	{
		CMFCVisualManager::OnDrawMiniFrameBorder(pDC, pFrameWnd, rectBorder, rectBorderSize);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawFloatingToolbarBorder(CDC* pDC, CMFCBaseToolBar* /*pToolBar*/, CRect rectBorder, CRect rectBorderSize)
{
	ASSERT_VALID(pDC);

	CBrush* pOldBrush = pDC->SelectObject(&m_brFloatToolBarBorder);
	ENSURE(pOldBrush != NULL);

	pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorderSize.left, rectBorder.Height(), PATCOPY);
	pDC->PatBlt(rectBorder.left, rectBorder.top, rectBorder.Width(), rectBorderSize.top, PATCOPY);
	pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top, rectBorderSize.right, rectBorder.Height(), PATCOPY);
	pDC->PatBlt(rectBorder.left, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width(), rectBorderSize.bottom, PATCOPY);

	rectBorderSize.DeflateRect(2, 2);
	rectBorder.DeflateRect(2, 2);

	pDC->SelectObject(&afxGlobalData.brBarFace);

	pDC->PatBlt(rectBorder.left, rectBorder.top + 1, rectBorderSize.left, rectBorder.Height() - 2, PATCOPY);
	pDC->PatBlt(rectBorder.left + 1, rectBorder.top, rectBorder.Width() - 2, rectBorderSize.top, PATCOPY);
	pDC->PatBlt(rectBorder.right - rectBorderSize.right, rectBorder.top + 1, rectBorderSize.right, rectBorder.Height() - 2, PATCOPY);
	pDC->PatBlt(rectBorder.left + 1, rectBorder.bottom - rectBorderSize.bottom, rectBorder.Width() - 2, rectBorderSize.bottom, PATCOPY);

	pDC->SelectObject(pOldBrush);
}

COLORREF CMFCVisualManagerOfficeXP::GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state)
{
	ASSERT_VALID(pButton);

	if (!afxGlobalData.IsHighContrastMode())
	{
		BOOL bDisabled = (CMFCToolBar::IsCustomizeMode() && !pButton->IsEditable()) || (!CMFCToolBar::IsCustomizeMode() &&(pButton->m_nStyle & TBBS_DISABLED));

		if (pButton->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneButton)))
		{
			if (bDisabled)
			{
				return afxGlobalData.clrGrayedText;
			}

			return afxGlobalData.IsHighContrastMode() ? afxGlobalData.clrWindowText : afxGlobalData.clrBarText;
		}

		if (state == ButtonsIsHighlighted && (pButton->m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)))
		{
			return afxGlobalData.clrTextHilite;
		}
	}

	return CMFCVisualManager::GetToolbarButtonTextColor(pButton, state);
}

void CMFCVisualManagerOfficeXP::OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton)
{
	if (!CMFCToolBarEditBoxButton::IsFlatMode())
	{
		CMFCVisualManager::OnDrawEditBorder(pDC, rect, bDisabled, bIsHighlighted, pButton);
		return;
	}

	if (bIsHighlighted)
	{
		pDC->Draw3dRect(&rect,  m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted, BOOL bIsSelected, BOOL bCanCollapse)
{
	ENSURE(pGroup != NULL);
	ENSURE(pGroup->m_pPage != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pGroup);
	ASSERT_VALID(pGroup->m_pPage);

	CRect rectGroup = pGroup->m_rect;

	// ------------------------------
	// Draw group caption(Office XP)
	// ------------------------------

	// ---------------------------
	// Draw an icon if it presents
	// ---------------------------
	BOOL bShowIcon = (pGroup->m_hIcon != NULL && pGroup->m_sizeIcon.cx < rectGroup.Width() - rectGroup.Height());
	if (bShowIcon)
	{
		OnDrawTasksGroupIcon(pDC, pGroup, 5, bIsHighlighted, bIsSelected, bCanCollapse);
	}

	// -----------------------
	// Draw group caption text
	// -----------------------
	CFont* pFontOld = pDC->SelectObject(&afxGlobalData.fontBold);
	COLORREF clrTextOld = pDC->GetTextColor();

	if (bCanCollapse && bIsHighlighted)
	{
		clrTextOld = pDC->SetTextColor(pGroup->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrWindowText : pGroup->m_clrTextHot);
	}
	else
	{
		clrTextOld = pDC->SetTextColor(pGroup->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pGroup->m_clrText);
	}

	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	int nTaskPaneHOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionHorzOffset();
	int nTaskPaneVOffset = pGroup->m_pPage->m_pTaskPane->GetGroupCaptionVertOffset();
	int nCaptionHOffset = (nTaskPaneHOffset != -1 ? nTaskPaneHOffset : m_nGroupCaptionHorzOffset);

	CRect rectText = rectGroup;
	rectText.left += (bShowIcon ? pGroup->m_sizeIcon.cx + 5: nCaptionHOffset);
	rectText.top += (nTaskPaneVOffset != -1 ? nTaskPaneVOffset : m_nGroupCaptionVertOffset);
	rectText.right = max(rectText.left, rectText.right -(bCanCollapse ? rectGroup.Height() : nCaptionHOffset));

	pDC->DrawText(pGroup->m_strName, rectText, DT_SINGLELINE | DT_VCENTER);

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);

	// -------------------------
	// Draw group caption button
	// -------------------------
	if (bCanCollapse && !pGroup->m_strName.IsEmpty())
	{
		CSize sizeButton = CMenuImages::Size();
		CRect rectButton = rectGroup;
		rectButton.left = max(rectButton.left, rectButton.right - sizeButton.cx);
		rectButton.top = max(rectButton.top, rectButton.bottom - sizeButton.cy);

		if (rectButton.Width() >= sizeButton.cx && rectButton.Height() >= sizeButton.cy)
		{
			if (bIsHighlighted)
			{
				// Draw button frame
				CPen* pPenOld = (CPen*) pDC->SelectObject(&afxGlobalData.penHilite);
				CBrush* pBrushOld = (CBrush*) pDC->SelectObject(&m_brHighlight);
				COLORREF clrBckOld = pDC->GetBkColor();

				pDC->Rectangle(&rectButton);

				pDC->SetBkColor(clrBckOld);
				pDC->SelectObject(pPenOld);
				pDC->SelectObject(pBrushOld);
			}

			if (!pGroup->m_bIsCollapsed)
			{
				CMenuImages::Draw(pDC, CMenuImages::IdArrowUp, rectButton.TopLeft());
			}
			else
			{
				CMenuImages::Draw(pDC, CMenuImages::IdArrowDown, rectButton.TopLeft());
			}
		}
	}
}

void CMFCVisualManagerOfficeXP::OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL /*bSpecial*/)
{
	ASSERT_VALID(pDC);

	// Draw underline
	CPen* pPenOld = (CPen*) pDC->SelectObject(&afxGlobalData.penBarShadow);
	pDC->MoveTo(rect.left, rect.top);
	pDC->LineTo(rect.right, rect.top);
	pDC->SelectObject(pPenOld);
}

void CMFCVisualManagerOfficeXP::OnDrawTasksGroupAreaBorder(CDC* /*pDC*/, CRect /*rect*/, BOOL /*bSpecial*/, BOOL /*bNoTitle*/)
{
}

void CMFCVisualManagerOfficeXP::OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted, BOOL /*bIsSelected*/)
{
	ENSURE(pTask != NULL);
	ENSURE(pIcons != NULL);

	ASSERT_VALID(pDC);
	ASSERT_VALID(pTask);
	ASSERT_VALID(pIcons);

	CRect rectText = pTask->m_rect;

	if (pTask->m_bIsSeparator)
	{
		CPen* pPenOld = (CPen*) pDC->SelectObject(&afxGlobalData.penBarShadow);

		pDC->MoveTo(rectText.left, rectText.CenterPoint().y);
		pDC->LineTo(rectText.right, rectText.CenterPoint().y);

		pDC->SelectObject(pPenOld);
		return;
	}

	// ---------
	// Draw icon
	// ---------
	CSize sizeIcon(0, 0);
	::ImageList_GetIconSize(pIcons->m_hImageList, (int*) &sizeIcon.cx, (int*) &sizeIcon.cy);
	if (pTask->m_nIcon >= 0 && sizeIcon.cx > 0)
	{
		pIcons->Draw(pDC, pTask->m_nIcon, rectText.TopLeft(), ILD_TRANSPARENT);
	}
	int nTaskPaneOffset = pTask->m_pGroup->m_pPage->m_pTaskPane->GetTasksIconHorzOffset();
	rectText.left += sizeIcon.cx +(nTaskPaneOffset != -1 ? nTaskPaneOffset : m_nTasksIconHorzOffset);

	// ---------
	// Draw text
	// ---------
	BOOL bIsLabel = (pTask->m_uiCommandID == 0);

	CFont* pFontOld = NULL;
	COLORREF clrTextOld = pDC->GetTextColor();
	if (bIsLabel)
	{
		pFontOld = pDC->SelectObject(pTask->m_bIsBold ? &afxGlobalData.fontBold : &afxGlobalData.fontRegular);
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrText);
	}
	else if (!pTask->m_bEnabled)
	{
		pDC->SetTextColor(afxGlobalData.clrGrayedText);
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
	}
	else if (bIsHighlighted)
	{
		pDC->SetTextColor(pTask->m_clrTextHot == (COLORREF)-1 ? afxGlobalData.clrHotLinkNormalText : pTask->m_clrTextHot);
		pFontOld = pDC->SelectObject(&afxGlobalData.fontUnderline);
	}
	else
	{
		pDC->SetTextColor(pTask->m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : pTask->m_clrText);
		pFontOld = pDC->SelectObject(&afxGlobalData.fontRegular);
	}
	int nBkModeOld = pDC->SetBkMode(TRANSPARENT);

	CMFCTasksPane* pTaskPane = pTask->m_pGroup->m_pPage->m_pTaskPane;
	ASSERT_VALID(pTaskPane);

	BOOL bMultiline = bIsLabel ? pTaskPane->IsWrapLabelsEnabled() : pTaskPane->IsWrapTasksEnabled();

	if (bMultiline)
	{
		pDC->DrawText(pTask->m_strName, rectText, DT_WORDBREAK);
	}
	else
	{
		CString strText = pTask->m_strName;
		strText.Remove (_T('\n'));
		strText.Remove (_T('\r'));
		pDC->DrawText(strText, rectText, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	}

	pDC->SetBkMode(nBkModeOld);
	pDC->SelectObject(pFontOld);
	pDC->SetTextColor(clrTextOld);
}

void CMFCVisualManagerOfficeXP::OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited)
{
	ASSERT_VALID(pDC);

	CRect rectFill = rect;
	rectFill.top -= nBorderSize;

	pDC->FillRect(rectFill, &afxGlobalData.brWindow);

	if (bHilited)
	{
		pDC->FillRect(rect, &m_brHighlight);
		pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}

	CMenuImages::Draw(pDC, (CMenuImages::IMAGES_IDS) iImage, rect);
}

void CMFCVisualManagerOfficeXP::OnDrawSpinButtons(CDC* pDC, CRect rectSpin, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* /*pSpinCtrl*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	CRect rect [2];
	rect[0] = rect[1] = rectSpin;

	if (!bOrientation)
	{
		rect[0].DeflateRect(0, 0, 0, rect[0].Height() / 2);
		rect[1].top = rect[0].bottom ;
	}
	else
	{
		rect[0].DeflateRect(0, 0, rect[0].Width() / 2, 0);
		rect[1].left = rect[0].right ;
	}

	CMenuImages::IMAGES_IDS id[2][2] = {{CMenuImages::IdArrowUp, CMenuImages::IdArrowDown}, {CMenuImages::IdArrowLeft, CMenuImages::IdArrowRight}};

	int idxPressed = (nState &(AFX_SPIN_PRESSEDUP | AFX_SPIN_PRESSEDDOWN)) - 1;
	int idxHighlighted = -1;
	if (nState & AFX_SPIN_HIGHLIGHTEDUP)
	{
		idxHighlighted = 0;
	}
	else if (nState & AFX_SPIN_HIGHLIGHTEDDOWN)
	{
		idxHighlighted = 1;
	}

	BOOL bDisabled = nState & AFX_SPIN_DISABLED;

	for (int i = 0; i < 2; i ++)
	{
		if (idxPressed == i || idxHighlighted == i)
		{
			OnFillHighlightedArea(pDC, rect [i], (idxPressed == i) ? &m_brHighlightDn : &m_brHighlight, NULL);
		}
		else
		{
			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);
				dm.DrawRect(rect[i], afxGlobalData.clrBarFace, afxGlobalData.clrBarHilite);
			}
			else
			{
				pDC->FillRect(rect[i], &afxGlobalData.brBarFace);
				pDC->Draw3dRect(rect[i], afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
			}
		}

		CMenuImages::Draw(pDC, id [bOrientation ? 1 : 0][i], rect[i], bDisabled ? CMenuImages::ImageGray : CMenuImages::ImageBlack);
	}

	if (idxHighlighted >= 0)
	{
		CRect rectHot = rect [idxHighlighted];

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rectHot, (COLORREF)-1, m_clrMenuItemBorder);
		}
		else
		{
			pDC->Draw3dRect(rectHot, m_clrMenuItemBorder, m_clrMenuItemBorder);
		}
	}
}

void CMFCVisualManagerOfficeXP::OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* /*pButton*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pBrush);

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		LOGBRUSH br;
		pBrush->GetLogBrush(&br);

		CDrawingManager dm(*pDC);
		dm.DrawRect(rect, br.lbColor, (COLORREF)-1);
	}
	else
	{
		pDC->FillRect(rect, pBrush);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawSplitterBorder(CDC* pDC, CSplitterWndEx* /*pSplitterWnd*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
	rect.InflateRect(-AFX_CX_BORDER, -AFX_CY_BORDER);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

void CMFCVisualManagerOfficeXP::OnDrawSplitterBox(CDC* pDC, CSplitterWndEx* /*pSplitterWnd*/, CRect& rect)
{
	ASSERT_VALID(pDC);
	pDC->Draw3dRect(rect, afxGlobalData.clrBarFace, afxGlobalData.clrBarFace);
}

BOOL CMFCVisualManagerOfficeXP::OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* /*pEdit*/, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& /*clrText*/)
{
	ASSERT_VALID(pDC);

	CRect rectFrame = rect;
	rectFrame.InflateRect(0, 1, 1, 1);

	switch(state)
	{
	case ButtonsIsPressed:
		pDC->FillRect(rect, &m_brHighlightDn);
		pDC->Draw3dRect(&rectFrame, m_clrMenuItemBorder, m_clrMenuItemBorder);
		pDC->SetTextColor(afxGlobalData.clrWindow);
		break;

	case ButtonsIsHighlighted:
		pDC->FillRect(rect, &m_brHighlight);
		pDC->Draw3dRect(&rectFrame, m_clrMenuItemBorder, m_clrMenuItemBorder);
		break;

	default:
		pDC->FillRect(rect, &afxGlobalData.brBtnFace);
		pDC->Draw3dRect(rect, afxGlobalData.clrBarHilite, afxGlobalData.clrBarHilite);
		break;
	}

	return TRUE;
}

COLORREF CMFCVisualManagerOfficeXP::GetWindowColor() const
{
	return afxGlobalData.clrWindow;
}

COLORREF CMFCVisualManagerOfficeXP::GetAutoHideButtonTextColor(CMFCAutoHideButton* /*pButton*/)
{
	return afxGlobalData.clrBtnDkShadow;
}

void CMFCVisualManagerOfficeXP::GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder)
{
	clrBaseGroupBackground = m_clrBarBkgnd;
	clrBaseGroupBorder = m_clrMenuBorder;
}

void CMFCVisualManagerOfficeXP::OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* /*pButton*/, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE /*state*/, BOOL bHorz)
{
	CPen* pOldPen = pDC->SelectObject(&m_penMenuItemBorder);
	ENSURE(pOldPen != NULL);

	if (bHorz)
	{
		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.left, rect.bottom);
	}
	else
	{
		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.right, rect.top);
	}

	pDC->SelectObject(pOldPen);
}

void CMFCVisualManagerOfficeXP::OnDrawPopupWindowBorder(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->Draw3dRect(rect, m_clrMenuBorder, m_clrMenuBorder);
	rect.DeflateRect(1, 1);
	pDC->Draw3dRect(rect, m_clrMenuLight, m_clrMenuLight);
}

COLORREF  CMFCVisualManagerOfficeXP::OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* /*pPopupWnd*/)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rectCaption, &m_brHighlight);

	// get the text color
	return afxGlobalData.clrBarText;
}

void CMFCVisualManagerOfficeXP::OnErasePopupWindowButton(CDC* pDC, CRect rc, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsPressed())
	{
		CBrush br(m_clrHighlightDn);
		pDC->FillRect(&rc, &br);
		return;
	}
	else if (pButton->IsHighlighted() || pButton->IsPushed())
	{
		CBrush br(m_clrHighlight);
		pDC->FillRect(&rc, &br);
		return;
	}

	CRect rectParent;
	pButton->GetParent()->GetClientRect(rectParent);

	pButton->GetParent()->MapWindowPoints(pButton, rectParent);
	OnFillPopupWindowBackground(pDC, rectParent);
}

void CMFCVisualManagerOfficeXP::OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rc, CMFCDesktopAlertWndButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsHighlighted() || pButton->IsPushed() || pButton->IsCaptionButton())
	{
		pDC->Draw3dRect(rc, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}
}

void CMFCVisualManagerOfficeXP::OnFillPopupWindowBackground(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &m_brMenuLight);
}

COLORREF CMFCVisualManagerOfficeXP::GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList)
{
	ASSERT_VALID(pPropList);

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		return CMFCVisualManager::GetPropertyGridGroupColor(pPropList);
	}

	return CDrawingManager::PixelAlpha(pPropList->DrawControlBarColors() ? afxGlobalData.clrBarFace : afxGlobalData.clrBtnFace, 94);
}

COLORREF CMFCVisualManagerOfficeXP::GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList)
{
	ASSERT_VALID(pPropList);

	return pPropList->DrawControlBarColors() ? afxGlobalData.clrBarShadow : afxGlobalData.clrBtnShadow;
}

COLORREF CMFCVisualManagerOfficeXP::OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsDefaultPanelButton() && !pButton->IsQATMode())
	{
		return(COLORREF)-1;
	}

	CRect rect = pButton->GetRect();

	const BOOL bIsMenuMode = pButton->IsMenuMode() && !pButton->IsGalleryIcon();

	const BOOL bIsHighlighted = (pButton->IsHighlighted() || pButton->IsDroppedDown()) && !pButton->IsDisabled();

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		COLORREF clrBorder = afxGlobalData.clrBarShadow;
		CRect rectCommand = pButton->GetCommandRect();

		if (pButton->GetLocationInGroup() != CMFCRibbonBaseElement::RibbonElementNotInGroup)
		{
			rectCommand.right++;
		}

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			if (bIsHighlighted)
			{
				dm.DrawRect(rect, afxGlobalData.clrWindow, clrBorder);
			}
			else
			{
				dm.DrawRect(rect, afxGlobalData.clrBarFace, clrBorder);
			}
		}
		else
		{
			if (bIsHighlighted)
			{
				pDC->FillRect(rectCommand, &afxGlobalData.brWindow);
			}
			else
			{
				pDC->FillRect(rectCommand, &afxGlobalData.brBarFace);

				CDrawingManager dm(*pDC);
				dm.HighlightRect(rectCommand);
			}

			pDC->Draw3dRect(rect, clrBorder, clrBorder);
		}

		return(COLORREF)-1;
	}

	if (!pButton->IsChecked() && !bIsHighlighted)
	{
		return(COLORREF)-1;
	}

	if (pButton->IsChecked() && bIsMenuMode && !bIsHighlighted)
	{
		return(COLORREF)-1;
	}

	CRect rectMenu = pButton->GetMenuRect();

	if (pButton->GetLocationInGroup() != CMFCRibbonBaseElement::RibbonElementNotInGroup)
	{
		rect.DeflateRect(1, 1);
	}

	CRect rectCommand(0, 0, 0, 0);
	if (!rectMenu.IsRectEmpty())
	{
		rectCommand = pButton->GetCommandRect();

		if (pButton->GetLocationInGroup() != CMFCRibbonBaseElement::RibbonElementNotInGroup)
		{
			rectMenu.DeflateRect(0, 1, 1, 1);
			rectCommand.DeflateRect(1, 1, 0, 1);
		}
	}

	if (!rectMenu.IsRectEmpty() && bIsHighlighted)
	{
		if (pButton->IsCommandAreaHighlighted())
		{
			OnFillHighlightedArea(pDC, rectCommand, (pButton->IsPressed() || pButton->IsDroppedDown()) && !bIsMenuMode ? &m_brHighlightDn : &m_brHighlight, NULL);
		}
		else
		{
			OnFillHighlightedArea(pDC, rectCommand, &m_brHighlight, NULL);

			CDrawingManager dm(*pDC);
			dm.HighlightRect(rectCommand);
		}

		if (pButton->IsMenuAreaHighlighted())
		{
			OnFillHighlightedArea(pDC, rectMenu, (pButton->IsPressed() || pButton->IsDroppedDown()) && !bIsMenuMode ? &m_brHighlightDn : &m_brHighlight, NULL);
		}
		else
		{
			OnFillHighlightedArea(pDC, rectMenu, &m_brHighlight, NULL);

			CDrawingManager dm(*pDC);
			dm.HighlightRect(rectMenu);
		}
	}
	else
	{
		CBrush* pBrush = (pButton->IsPressed() || pButton->IsDroppedDown()) && !bIsMenuMode ? &m_brHighlightDn : &m_brHighlight;

		CRect rectFill = rect;

		if (pButton->IsChecked() && !bIsMenuMode)
		{
			pBrush = bIsHighlighted ? &m_brHighlightDn : &m_brHighlightChecked;

			if (!bIsHighlighted && !rectCommand.IsRectEmpty())
			{
				rectFill = rectCommand;
			}
		}

		OnFillHighlightedArea(pDC, rectFill, pBrush, NULL);
	}

	return(COLORREF)-1;
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pButton);

	if (pButton->IsDefaultPanelButton() && !pButton->IsQATMode())
	{
		return;
	}

	if (pButton->IsKindOf(RUNTIME_CLASS(CMFCRibbonEdit)))
	{
		return;
	}

	const BOOL bIsMenuMode = pButton->IsMenuMode();

	const BOOL bIsHighlighted = (pButton->IsHighlighted() || pButton->IsDroppedDown()) && !pButton->IsDisabled();

	if (pButton->IsChecked() && bIsMenuMode && !bIsHighlighted)
	{
		return;
	}

	CRect rect = pButton->GetRect();
	CRect rectMenu = pButton->GetMenuRect();

	if (pButton->GetLocationInGroup() != CMFCRibbonBaseElement::RibbonElementNotInGroup)
	{
		rect.DeflateRect(1, 1);
	}

	if ((bIsHighlighted || pButton->IsChecked()) && (!pButton->IsDisabled() || pButton->IsFocused() || pButton->IsChecked()))
	{
		COLORREF clrLine = ((pButton->IsPressed() || pButton->IsDroppedDown()) && !bIsMenuMode) ? m_clrPressedButtonBorder : m_clrMenuItemBorder;

		if (CMFCToolBarImages::m_bIsDrawOnGlass)
		{
			CDrawingManager dm(*pDC);
			dm.DrawRect(rect, (COLORREF)-1, m_clrMenuItemBorder);
		}
		else
		{
			pDC->Draw3dRect(rect, clrLine, clrLine);
		}

		if (!rectMenu.IsRectEmpty())
		{
			if (pButton->GetLocationInGroup() != CMFCRibbonBaseElement::RibbonElementNotInGroup)
			{
				rectMenu.DeflateRect(0, 1, 1, 1);
			}

			if (CMFCToolBarImages::m_bIsDrawOnGlass)
			{
				CDrawingManager dm(*pDC);

				if (pButton->IsMenuOnBottom())
				{
					dm.DrawLine(rectMenu.left, rectMenu.top, rectMenu.right, rectMenu.top, m_clrMenuItemBorder);
				}
				else
				{
					dm.DrawLine(rectMenu.left, rectMenu.top, rectMenu.left, rectMenu.bottom, m_clrMenuItemBorder);
				}
			}
			else
			{
				CPen* pOldPen = pDC->SelectObject(&m_penMenuItemBorder);
				ENSURE(pOldPen != NULL);

				if (pButton->IsMenuOnBottom())
				{
					pDC->MoveTo(rectMenu.left, rectMenu.top);
					pDC->LineTo(rectMenu.right, rectMenu.top);
				}
				else
				{
					pDC->MoveTo(rectMenu.left, rectMenu.top);
					pDC->LineTo(rectMenu.left, rectMenu.bottom);
				}

				pDC->SelectObject(pOldPen);
			}
		}
	}
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonCategoryScroll (CDC* pDC, CRibbonCategoryScroll* pScroll)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pScroll);

	CRect rect = pScroll->GetRect();
	rect.bottom--;

	OnFillHighlightedArea(pDC, rect, pScroll->IsHighlighted() ? &m_brHighlight : &afxGlobalData.brBarFace, NULL);

	BOOL bIsLeft = pScroll->IsLeftScroll();
	if (afxGlobalData.m_bIsRTL)
	{
		bIsLeft = !bIsLeft;
	}

	CMenuImages::Draw(pDC,
		bIsLeft ? CMenuImages::IdArrowLeftLarge : CMenuImages::IdArrowRightLarge, 
		rect);

	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* /*pButton*/, CRect rect)
{
	ASSERT_VALID(pDC);

	OnFillHighlightedArea(pDC, rect, &m_brHighlight, NULL);
	pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
}

void CMFCVisualManagerOfficeXP::OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* /*pPanel*/, CRect rect)
{
	ASSERT_VALID(pDC);
	pDC->FillRect(rect, &m_brMenuLight);
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* /*pPanel*/, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.right = rectSeparator.left + 2;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
}

COLORREF CMFCVisualManagerOfficeXP::OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* /*pBar*/, CMFCRibbonStatusBarPane* pPane)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pPane);

	CRect rect = pPane->GetRect();

	if (pPane->IsHighlighted())
	{
		CRect rectButton = rect;
		rectButton.DeflateRect(1, 1);

		OnFillHighlightedArea(pDC, rectButton, pPane->IsPressed() ? &m_brHighlightDn : &m_brHighlight, NULL);
		pDC->Draw3dRect(rectButton, m_clrMenuItemBorder, m_clrMenuItemBorder);
	}

	CRect rectSeparator = rect;
	rectSeparator.DeflateRect(0, 2);

	rectSeparator.left = rectSeparator.right - 1;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);

	if (afxGlobalData.IsHighContrastMode())
	{
		return afxGlobalData.clrBarText;
	}

	return(COLORREF)-1;
}

void CMFCVisualManagerOfficeXP::GetRibbonSliderColors(CMFCRibbonSlider* /*pSlider*/, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled, COLORREF& clrLine, COLORREF& clrFill)
{
	clrLine = bIsDisabled ? afxGlobalData.clrBarShadow : (bIsPressed || bIsHighlighted) ? m_clrMenuItemBorder : afxGlobalData.clrBarDkShadow;
	clrFill = bIsPressed && bIsHighlighted ? m_clrHighlightDn : bIsHighlighted ? m_clrHighlight : afxGlobalData.clrBarFace;
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* /*pSeparator*/, CRect rect)
{
	ASSERT_VALID(pDC);

	int x = rect.CenterPoint().x;
	int y1 = rect.top;
	int y2 = rect.bottom - 1;

	if (CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		CDrawingManager dm(*pDC);
		dm.DrawLine(x, y1, x, y2, m_clrSeparator);
	}
	else
	{
		CPen* pOldPen = pDC->SelectObject(&m_penSeparator);
		ENSURE(pOldPen != NULL);

		pDC->MoveTo(x, y1);
		pDC->LineTo(x, y2);

		pDC->SelectObject(pOldPen);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawRibbonColorPaletteBox(CDC* pDC, CMFCRibbonColorButton* /*pColorButton*/, CMFCRibbonGalleryIcon* /*pIcon*/,
	COLORREF color, CRect rect, BOOL bDrawTopEdge, BOOL bDrawBottomEdge, BOOL bIsHighlighted, BOOL bIsChecked, BOOL /*bIsDisabled*/)
{
	ASSERT_VALID(pDC);

	CRect rectFill = rect;
	rectFill.DeflateRect(1, 0);

	if (bIsHighlighted || bIsChecked)
	{
		OnFillHighlightedArea(pDC, rect, &m_brHighlight, NULL);
		rectFill.DeflateRect(1, 2);
	}

	if (color != (COLORREF)-1)
	{
		CBrush br(color);
		pDC->FillRect(rectFill, &br);
	}

	COLORREF clrBorder = RGB(197, 197, 197);

	if (bDrawTopEdge && bDrawBottomEdge)
	{
		pDC->Draw3dRect(rect, clrBorder, clrBorder);
	}
	else
	{
		CPen penBorder(PS_SOLID, 1, clrBorder);

		CPen* pOldPen = pDC->SelectObject(&penBorder);
		ENSURE(pOldPen != NULL);

		pDC->MoveTo(rect.left, rect.top);
		pDC->LineTo(rect.left, rect.bottom);

		pDC->MoveTo(rect.right - 1, rect.top);
		pDC->LineTo(rect.right - 1, rect.bottom);

		if (bDrawTopEdge)
		{
			pDC->MoveTo(rect.left, rect.top);
			pDC->LineTo(rect.right, rect.top);
		}

		if (bDrawBottomEdge)
		{
			pDC->MoveTo(rect.left, rect.bottom - 1);
			pDC->LineTo(rect.right, rect.bottom - 1);
		}

		pDC->SelectObject(pOldPen);
	}

	if (bIsHighlighted || bIsChecked)
	{
		clrBorder = bIsChecked ? m_clrPressedButtonBorder : m_clrMenuItemBorder;
		pDC->Draw3dRect(rect, clrBorder, clrBorder);
	}
}

COLORREF CMFCVisualManagerOfficeXP::OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* /*pParent*/, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected)
{
	ASSERT_VALID(pDC);

	CBrush* pBrush = NULL;

	if (bIsSelected)
	{
		pBrush = !bIsHighlihted ? &m_brHighlightChecked : &m_brHighlightDn;
	}
	else if (bIsHighlihted)
	{
		pBrush = &m_brHighlight;
	}

	OnFillHighlightedArea(pDC, rect, pBrush, NULL);
	pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);

	return afxGlobalData.clrBtnText;
}

COLORREF CMFCVisualManagerOfficeXP::OnDrawMenuLabel(CDC* pDC, CRect rect)
{
	ASSERT_VALID(pDC);

	pDC->FillRect(rect, &m_brBarBkgnd);

	CRect rectSeparator = rect;
	rectSeparator.top = rectSeparator.bottom - 2;

	pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBarShadow,
		afxGlobalData.clrBarHilite);

	return afxGlobalData.clrBarText;
}

COLORREF CMFCVisualManagerOfficeXP::OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
	BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton)
{
	ASSERT_VALID(pBar);

	if (!pBar->IsMessageBarMode())
	{
		return CMFCVisualManager::OnFillCaptionBarButton(pDC, pBar, rect, bIsPressed, bIsHighlighted, bIsDisabled, bHasDropDownArrow, bIsSysButton);
	}

	if (bIsDisabled)
	{
		return(COLORREF)-1;
	}

	COLORREF clrText = afxGlobalData.clrBarText;

	if (bIsHighlighted)
	{
		OnFillHighlightedArea(pDC, rect, &m_brHighlight, NULL);

		if (GetRValue(m_clrHighlight) > 128 && GetGValue(m_clrHighlight) > 128 && GetBValue(m_clrHighlight) > 128)
		{
			clrText = RGB(0, 0, 0);
		}
		else
		{
			clrText = RGB(255, 255, 255);
		}
	}
	else if (!bIsSysButton)
	{
		pDC->FillRect(rect, &m_brMenuLight);
	}

	return clrText;
}

void CMFCVisualManagerOfficeXP::OnDrawCaptionBarButtonBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
	BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton)
{
	ASSERT_VALID(pBar);

	if (!pBar->IsMessageBarMode())
	{
		CMFCVisualManager::OnDrawCaptionBarButtonBorder(pDC, pBar, rect, bIsPressed, bIsHighlighted, bIsDisabled, bHasDropDownArrow, bIsSysButton);
		return;
	}

	ASSERT_VALID(pDC);

	if (bIsHighlighted)
	{
		if (bIsSysButton && bIsPressed && m_clrPressedButtonBorder != (COLORREF)-1)
		{
			pDC->Draw3dRect(rect, m_clrPressedButtonBorder, m_clrPressedButtonBorder);
		}
		else
		{
			pDC->Draw3dRect(rect, m_clrMenuItemBorder, m_clrMenuItemBorder);
		}
	}
	else if (!bIsSysButton)
	{
		pDC->Draw3dRect(rect, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
	}
}

void CMFCVisualManagerOfficeXP::OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* /*pBar*/, CRect rect)
{
	ASSERT_VALID(pDC);

	::FillRect(pDC->GetSafeHdc(), rect, ::GetSysColorBrush(COLOR_INFOBK));
	pDC->Draw3dRect(rect, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\apphelpx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Basic Help support (for backward compatibility to MFC 2.0)

void CWinApp::OnHelp()  // use context to derive help context
{
	if (m_dwPromptContext != 0)
	{
		// do not call WinHelp when the error is failing to lauch help
		if (m_dwPromptContext != HID_BASE_PROMPT+AFX_IDP_FAILED_TO_LAUNCH_HELP)
			WinHelpInternal(m_dwPromptContext);
		return;
	}

	// otherwise, use CWnd::OnHelp implementation
	CWnd* pWnd = AfxGetMainWnd();
	ENSURE_VALID(pWnd);
	if (!pWnd->IsFrameWnd())
		pWnd->OnHelp();
	else
		((CFrameWnd*)pWnd)->OnHelp();
}

void CWinApp::OnHelpIndex()
{
	WinHelpInternal(0L, HELP_INDEX);
}

void CWinApp::OnHelpFinder()
{
	WinHelpInternal(0L, HELP_FINDER);
}

void CWinApp::OnHelpUsing()
{
	WinHelpInternal(0L, HELP_HELPONHELP);
}

/////////////////////////////////////////////////////////////////////////////
// Context Help Mode support (backward compatibility to MFC 2.0)

void CWinApp::OnContextHelp()
{
	// just use CFrameWnd::OnContextHelp implementation
	m_bHelpMode = HELP_ACTIVE;
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	ENSURE_VALID(pMainWnd);
	ENSURE(pMainWnd->IsFrameWnd());
	pMainWnd->OnContextHelp();
	m_bHelpMode = pMainWnd->m_bHelpMode;
	pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\apphelp.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Help and other support

// Strings in format ".....%1 .... %2 ...." etc.

void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
		LPCTSTR const* rglpsz, int nString)
{
	CString strFormat;
	if (!strFormat.LoadString(nIDS) != 0)
	{
		TRACE(traceAppMsg, 0, "Error: failed to load AfxFormatString string 0x%04x.\n", nIDS);
		ASSERT(FALSE);
		return;
	}
	AfxFormatStrings(rString, strFormat, rglpsz, nString);
}

void AFXAPI AfxFormatStrings(CString& rString, LPCTSTR lpszFormat,
		LPCTSTR const* rglpsz, int nString)
{
	ENSURE_ARG(lpszFormat != NULL);
	ENSURE_ARG(rglpsz != NULL);
	// determine length of destination string, not including null terminator
	int nTotalLen = 0;
	LPCTSTR pchSrc = lpszFormat;
	while (*pchSrc != '\0')
	{
		if (pchSrc[0] == '%' &&
			 ( (pchSrc[1] >= '1' && pchSrc[1] <= '9') ||
				(pchSrc[1] >= 'A' && pchSrc[1] <= 'Z')) )
		{
			// %A comes after %9 -- we'll need it someday
			int i;
			if (pchSrc[1] > '9')
				i = 9 + (pchSrc[1] - 'A');
			else
				i = pchSrc[1] - '1';
			pchSrc += 2;
			if (i >= nString)
				++nTotalLen;
			else if (rglpsz[i] != NULL)
				nTotalLen += lstrlen(rglpsz[i]);
		}
		else
		{
			if (_istlead(*pchSrc))
				++nTotalLen, ++pchSrc;
			++pchSrc;
			++nTotalLen;
		}
	}

	pchSrc = lpszFormat;
	LPTSTR pchDest = rString.GetBuffer(nTotalLen);
	while (*pchSrc != '\0')
	{
		if (pchSrc[0] == '%' &&
			 ( (pchSrc[1] >= '1' && pchSrc[1] <= '9') ||
				(pchSrc[1] >= 'A' && pchSrc[1] <= 'Z')) )
		{
			// %A comes after %9 -- we'll need it someday
			int i;
			if (pchSrc[1] > '9')
				i = 9 + (pchSrc[1] - 'A');
			else
				i = pchSrc[1] - '1';
			pchSrc += 2;
			if (i >= nString)
			{
				TRACE(traceAppMsg, 0, "Error: illegal string index requested %d.\n", i);
				*pchDest++ = '?';
				nTotalLen--;
			}
			else if (rglpsz[i] != NULL)
			{
				int nLen = lstrlen(rglpsz[i]);
				Checked::tcscpy_s(pchDest, nTotalLen + 1, rglpsz[i]);
				nTotalLen -= nLen;
				pchDest += nLen;
			}
		}
		else
		{
			if (_istlead(*pchSrc))
				*pchDest++ = *pchSrc++, nTotalLen--; // copy first of 2 bytes
			*pchDest++ = *pchSrc++;
			nTotalLen--;
		}
	}
	rString.ReleaseBuffer((int)((LPCTSTR)pchDest - (LPCTSTR)rString));
		// ReleaseBuffer will assert if we went too far
}

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1)
{
	AfxFormatStrings(rString, nIDS, &lpsz1, 1);
}

void AFXAPI AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1,
		LPCTSTR lpsz2)
{
	LPCTSTR rglpsz[2];
	rglpsz[0] = lpsz1;
	rglpsz[1] = lpsz2;
	AfxFormatStrings(rString, nIDS, rglpsz, 2);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxwindowsmanagerdialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmdiframewndex.h"
#include "afxwindowsmanagerdialog.h"
#include "afxmdichildwndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCWindowsManagerDialog dialog

UINT AFX_WM_WINDOW_HELP = ::RegisterWindowMessage(_T("WINDOW_HELP"));

CMFCWindowsManagerDialog::CMFCWindowsManagerDialog(CMDIFrameWndEx* pMDIFrame, BOOL bHelpButton)
	: CDialog(CMFCWindowsManagerDialog::IDD, pMDIFrame), m_pMDIFrame(pMDIFrame), m_bHelpButton(bHelpButton)
{
	ASSERT_VALID(m_pMDIFrame);

	m_bMDIActions = TRUE;
}

void CMFCWindowsManagerDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCWindowsManagerDialog)
	DDX_Control(pDX, IDC_AFXBARRES_LIST, m_wndList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCWindowsManagerDialog, CDialog)
	//{{AFX_MSG_MAP(CMFCWindowsManagerDialog)
	ON_WM_DRAWITEM()
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_AFXBARRES_ACTIVATE, &CMFCWindowsManagerDialog::OnActivate)
	ON_BN_CLICKED(IDC_AFXBARRES_SAVE, &CMFCWindowsManagerDialog::OnSave)
	ON_BN_CLICKED(IDC_AFXBARRES_CLOSE, &CMFCWindowsManagerDialog::OnClose)
	ON_BN_CLICKED(IDC_AFXBARRES_CASCADE, &CMFCWindowsManagerDialog::OnCascade)
	ON_BN_CLICKED(IDC_AFXBARRES_TILEHORZ, &CMFCWindowsManagerDialog::OnTilehorz)
	ON_BN_CLICKED(IDC_AFXBARRES_TILEVERT, &CMFCWindowsManagerDialog::OnTilevert)
	ON_BN_CLICKED(IDC_AFXBARRES_MINIMIZE, &CMFCWindowsManagerDialog::OnMinimize)
	ON_BN_CLICKED(ID_HELP, &CMFCWindowsManagerDialog::OnWindowHelp)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_LIST, &CMFCWindowsManagerDialog::OnSelchangeList)
	ON_LBN_DBLCLK(IDC_AFXBARRES_LIST, &CMFCWindowsManagerDialog::OnActivate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCWindowsManagerDialog message handlers

void CMFCWindowsManagerDialog::MDIMessage(UINT uMsg, WPARAM flag)
{
	ASSERT_VALID(m_pMDIFrame);

	CWaitCursor wait;

	int nItems = m_wndList.GetCount();
	if (nItems <= 0)
	{
		return;
	}

	HWND hMDIClient = m_pMDIFrame->m_hWndMDIClient;

	::LockWindowUpdate(hMDIClient);

	for (int i = nItems - 1; i >= 0; i--)
	{
		HWND hWnd= (HWND) m_wndList.GetItemData(i);
		::ShowWindow(hWnd, m_wndList.GetSel(i) > 0 ? SW_RESTORE : SW_MINIMIZE);
	}

	::SendMessage(hMDIClient, uMsg, flag, 0);
	::LockWindowUpdate(NULL);
}

void CMFCWindowsManagerDialog::OnActivate()
{
	if (!CMDIFrameWndEx::m_bDisableSetRedraw)
	{
		GetParent()->SetRedraw(FALSE);
	}

	if (m_wndList.GetSelCount() == 1)
	{
		int index;
		if (m_wndList.GetSelItems(1, &index) == 1)
		{
			DWORD_PTR dw = m_wndList.GetItemData(index);
			if (dw != (DWORD_PTR) LB_ERR)
			{
				WINDOWPLACEMENT wndpl;
				wndpl.length = sizeof(WINDOWPLACEMENT);
				::GetWindowPlacement((HWND) dw,&wndpl);

				if (wndpl.showCmd == SW_SHOWMINIMIZED)
				{
					::ShowWindow((HWND) dw,SW_RESTORE);
				}

				::SendMessage(m_pMDIFrame->m_hWndMDIClient,WM_MDIACTIVATE, (WPARAM) dw,0);
				EndDialog(IDOK);
			}
		}
	}

	if (!CMDIFrameWndEx::m_bDisableSetRedraw)
	{
		GetParent()->SetRedraw(TRUE);
		GetParent()->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}
}

void CMFCWindowsManagerDialog::OnSave()
{
	int nItems = m_wndList.GetCount();
	if (nItems > 0)
	{
		for (int i = 0; i < nItems; i++)
		{
			if (m_wndList.GetSel(i) > 0)
			{
				HWND hWnd= (HWND) m_wndList.GetItemData(i);

				if (m_lstSaveDisabled.Find(hWnd) == NULL)
				{
					CWnd* pWnd = CWnd::FromHandle(hWnd);
					CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, pWnd);

					if (pFrame != NULL)
					{
						CDocument *pDoc = pFrame->GetActiveDocument();
						if (pDoc != NULL)
						{
							ASSERT_VALID(pDoc);
							pDoc->DoFileSave();
						}
					}
				}
			}
		}
	}

	FillWindowList();
	SelActive();
	UpdateButtons();
}

void CMFCWindowsManagerDialog::OnClose()
{
	int nItems = m_wndList.GetCount();
	if (nItems > 0)
	{
		HWND hMDIClient = m_pMDIFrame->m_hWndMDIClient;

		m_wndList.SetRedraw(FALSE);

		for (int i = nItems - 1; i>=0; i--)
		{
			if (m_wndList.GetSel(i) > 0)
			{
				HWND hWnd= (HWND) m_wndList.GetItemData(i);

				::SendMessage(hWnd,WM_CLOSE, (WPARAM) 0, (LPARAM) 0);

				if (::GetParent(hWnd) == hMDIClient)
				{
					break;
				}
			}
		}

		m_wndList.SetRedraw(TRUE);
	}

	FillWindowList();
	SelActive();
	UpdateButtons();
}

void CMFCWindowsManagerDialog::OnCascade()
{
	MDIMessage(WM_MDICASCADE,0);
}

void CMFCWindowsManagerDialog::OnTilehorz()
{
	MDIMessage(WM_MDITILE, MDITILE_HORIZONTAL);
}

void CMFCWindowsManagerDialog::OnTilevert()
{
	MDIMessage(WM_MDITILE, MDITILE_VERTICAL);
}

void CMFCWindowsManagerDialog::OnMinimize()
{
	int nItems = m_wndList.GetCount();
	if (nItems > 0)
	{
		m_wndList.SetRedraw(FALSE);

		for (int i = nItems - 1; i >= 0; i--)
		{
			if (m_wndList.GetSel(i) > 0)
			{
				HWND hWnd= (HWND)m_wndList.GetItemData(i);
				::ShowWindow(hWnd,SW_MINIMIZE);
			}
		}

		m_wndList.SetRedraw(TRUE);
	}

	FillWindowList();
	SelActive();
	UpdateButtons();
}

BOOL CMFCWindowsManagerDialog::OnInitDialog()
{
	CDialog::OnInitDialog();

	if (AfxGetMainWnd() != NULL &&
		(AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	FillWindowList();

	// If no MDI actions are available, hide all MDI-related buttons:

	if (!m_bMDIActions)
	{
		GetDlgItem(IDC_AFXBARRES_TILEHORZ)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_AFXBARRES_TILEVERT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_AFXBARRES_CASCADE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_AFXBARRES_MINIMIZE)->ShowWindow(SW_HIDE);
	}

	SelActive();
	UpdateButtons();

	CWnd* pBtnHelp = GetDlgItem(ID_HELP);
	if (pBtnHelp != NULL)
	{
		pBtnHelp->ShowWindow(m_bHelpButton ? SW_SHOW : SW_HIDE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCWindowsManagerDialog::OnSelchangeList()
{
	UpdateButtons();
}

// Enables/Disables states of buttons
void CMFCWindowsManagerDialog::UpdateButtons()
{
	int nSel = m_wndList.GetSelCount();

	BOOL bClose = nSel > 0;
	BOOL bSave = FALSE;

	for (int i = 0; bClose && i < m_wndList.GetCount(); i++)
	{
		if (m_wndList.GetSel(i) > 0)
		{
			HWND hWnd= (HWND) m_wndList.GetItemData(i);

			if (m_lstCloseDisabled.Find(hWnd))
			{
				bClose = FALSE;
			}

			if (m_lstSaveDisabled.Find(hWnd) == NULL)
			{
				bSave = TRUE;
			}
		}
	}

	GetDlgItem(IDC_AFXBARRES_CLOSE)->EnableWindow(bClose);

	GetDlgItem(IDC_AFXBARRES_SAVE)->EnableWindow(bSave);
	GetDlgItem(IDC_AFXBARRES_TILEHORZ)->EnableWindow(m_bMDIActions && nSel>=2);
	GetDlgItem(IDC_AFXBARRES_TILEVERT)->EnableWindow(m_bMDIActions && nSel>=2);
	GetDlgItem(IDC_AFXBARRES_CASCADE)->EnableWindow(m_bMDIActions && nSel>=2);
	GetDlgItem(IDC_AFXBARRES_MINIMIZE)->EnableWindow(m_bMDIActions && nSel>0);

	GetDlgItem(IDC_AFXBARRES_ACTIVATE)->EnableWindow(nSel==1);
}

// Selects currently active window in listbox
void CMFCWindowsManagerDialog::SelActive()
{
	int nItems = m_wndList.GetCount();
	if (nItems > 0)
	{
		m_wndList.SetRedraw(FALSE);
		m_wndList.SelItemRange(FALSE, 0, nItems - 1);

		HWND hwndActive = (HWND) ::SendMessage(m_pMDIFrame->m_hWndMDIClient,WM_MDIGETACTIVE,0,0);

		for (int i = 0; i <nItems; i++)
		{
			if ((HWND) m_wndList.GetItemData(i)==hwndActive)
			{
				m_wndList.SetSel(i);
				break;
			}
		}

		m_wndList.SetRedraw(TRUE);
	}
}

// Refresh windows list
void CMFCWindowsManagerDialog::FillWindowList(void)
{
	m_wndList.SetRedraw(FALSE);
	m_wndList.ResetContent();

	int cxExtent = 0;

	CClientDC dcList(&m_wndList);
	CFont* pOldFont = dcList.SelectObject(GetFont());
	ASSERT_VALID(pOldFont);

	m_bMDIActions = TRUE;
	m_lstCloseDisabled.RemoveAll();
	m_lstSaveDisabled.RemoveAll();

	HWND hwndT = ::GetWindow(m_pMDIFrame->m_hWndMDIClient, GW_CHILD);
	while (hwndT != NULL)
	{
		CMDIChildWndEx* pFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndT));
		if (pFrame == NULL)
		{
			hwndT = ::GetWindow(hwndT,GW_HWNDNEXT);
			continue;
		}

		if (!pFrame->CanShowOnWindowsList())
		{
			hwndT = ::GetWindow(hwndT,GW_HWNDNEXT);
			continue;
		}

		TCHAR szWndTitle[256];
		::GetWindowText(hwndT,szWndTitle,sizeof(szWndTitle)/sizeof(szWndTitle[0]));

		int index = m_wndList.AddString(szWndTitle);

		int cxCurr = dcList.GetTextExtent(szWndTitle).cx;
		cxExtent = max(cxExtent, cxCurr);

		m_wndList.SetItemData(index, (DWORD_PTR) hwndT);

		if (pFrame != NULL && pFrame->IsReadOnly())
		{
			m_lstSaveDisabled.AddTail(hwndT);
		}

		DWORD dwStyle = ::GetWindowLong(hwndT, GWL_STYLE);
		if ((dwStyle & WS_SYSMENU) == 0)
		{
			m_bMDIActions = FALSE;
		}
		else
		{
			HMENU hSysMenu = ::GetSystemMenu(hwndT, FALSE);
			if (hSysMenu == NULL)
			{
				m_bMDIActions = FALSE;
			}
			else
			{
				MENUITEMINFO menuInfo;
				ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
				menuInfo.cbSize = sizeof(MENUITEMINFO);
				menuInfo.fMask = MIIM_STATE;

				if (!::GetMenuItemInfo(hSysMenu, SC_CLOSE, FALSE, &menuInfo) || (menuInfo.fState & MFS_GRAYED) || (menuInfo.fState & MFS_DISABLED))
				{
					m_lstCloseDisabled.AddTail(hwndT);
				}
			}
		}

		hwndT=::GetWindow(hwndT,GW_HWNDNEXT);
	}

	m_wndList.SetHorizontalExtent(cxExtent + ::GetSystemMetrics(SM_CXHSCROLL) + 30);
	dcList.SelectObject(pOldFont);

	m_wndList.SetRedraw(TRUE);
}

void CMFCWindowsManagerDialog::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDIS)
{
	if (nIDCtl != IDC_AFXBARRES_LIST)
	{
		CDialog::OnDrawItem(nIDCtl, lpDIS);
	}

	if (lpDIS->itemID == LB_ERR)
	{
		return;
	}

	CBrush& brFill = (lpDIS->itemState & ODS_SELECTED) ? afxGlobalData.brHilite : afxGlobalData.brWindow;
	COLORREF clText = (lpDIS->itemState & ODS_SELECTED) ? afxGlobalData.clrTextHilite : afxGlobalData.clrWindowText;
	CRect rect = lpDIS->rcItem;
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);

	if (lpDIS->itemAction &(ODA_DRAWENTIRE | ODA_SELECT))
	{
		pDC->FillRect(rect, &brFill);
	}

	pDC->SetBkMode(TRANSPARENT);
	pDC->SetTextColor(clText);

	//-----------
	// Draw text:
	//-----------
	CString str;
	m_wndList.GetText(lpDIS->itemID, str);

	CRect rectText = rect;
	rectText.left += rectText.Height() + 4;

	pDC->DrawText(str, rectText, DT_LEFT | DT_VCENTER | DT_NOPREFIX| DT_SINGLELINE);

	//-----------
	// Draw icon:
	//-----------
	HICON hIcon = (HICON)(LONG_PTR) GetClassLongPtr((HWND) lpDIS->itemData, GCLP_HICONSM);
	if (hIcon != NULL)
	{
		CRect rectIcon = rect;
		rectIcon.right = rectIcon.left + rectIcon.Height();
		rectIcon.DeflateRect(2, 0);

		::DrawIconEx(pDC->GetSafeHdc(), rectIcon.left, rectIcon.top, hIcon, rectIcon.Height(), rectIcon.Height(), 0, NULL, DI_NORMAL);
	}

	if (lpDIS->itemAction & ODA_FOCUS)
	{
		pDC->DrawFocusRect(rect);
	}
}

void CMFCWindowsManagerDialog::OnWindowHelp()
{
	CWnd* pParentFrame = AfxGetMainWnd();
	pParentFrame->SendMessage(AFX_WM_WINDOW_HELP, 0, (LPARAM) this);
}

BOOL CMFCWindowsManagerDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
	pHelpInfo->iCtrlId;
	CWnd* pParentFrame = AfxGetMainWnd();
	pParentFrame->SendMessage(AFX_WM_WINDOW_HELP, 0, (LPARAM) this);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



/////////////////////////////////////////////////////////////////////////////

BOOL AFXAPI AfxWinInit(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,
	_In_z_ LPTSTR lpCmdLine, _In_ int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);


	// handle critical errors and avoid Windows message boxes
	SetErrorMode(SetErrorMode(0) |
		SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);

	// set resource handles
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	pModuleState->m_hCurrentInstanceHandle = hInstance;
	pModuleState->m_hCurrentResourceHandle = hInstance;
	pModuleState->CreateActivationContext();

	// fill in the initial state for the application
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
	{
		// Windows specific initialization (not done if no CWinApp)
		pApp->m_hInstance = hInstance;
		hPrevInstance; // Obsolete.
		pApp->m_lpCmdLine = lpCmdLine;
		pApp->m_nCmdShow = nCmdShow;
		pApp->SetCurrentHandles();
	}

	// initialize thread specific data (for main thread)
	if (!afxContextIsDLL)
		AfxInitThread();

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CWinApp Initialization

void CWinApp::SetCurrentHandles()
{
	ASSERT(this == afxCurrentWinApp);
	ASSERT(afxCurrentAppName == NULL);

	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
	pModuleState->m_hCurrentInstanceHandle = m_hInstance;
	pModuleState->m_hCurrentResourceHandle = m_hInstance;

	// Note: there are a number of _tcsdup (aka strdup) calls that are
	// made here for the exe path, help file path, etc.  In previous
	// versions of MFC, this memory was never freed.  In this and future
	// versions this memory is automatically freed during CWinApp's
	// destructor.  If you are freeing the memory yourself, you should
	// either remove the code or set the pointers to NULL after freeing
	// the memory.

	// get path of executable
	TCHAR szBuff[_MAX_PATH];
	DWORD dwRet = ::GetModuleFileName(m_hInstance, szBuff, _MAX_PATH);
	ASSERT( dwRet != 0 && dwRet != _MAX_PATH );
	if( dwRet == 0 || dwRet == _MAX_PATH )
		AfxThrowUserException();

	LPTSTR lpszExt = ::PathFindExtension(szBuff);
	ASSERT(lpszExt != NULL);
	if( lpszExt == NULL )
		AfxThrowUserException();

	ASSERT(*lpszExt == '.');
	*lpszExt = 0;       // no suffix

	TCHAR szExeName[_MAX_PATH];
	TCHAR szTitle[256];
	TCHAR szAppID[256];

	// get the exe title from the full path name [no extension]
	dwRet = AfxGetFileName(szBuff, szExeName, _MAX_PATH);
	ASSERT( dwRet == 0 );
	if( dwRet != 0 )
		AfxThrowUserException();

	if (m_pszExeName == NULL)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszExeName = _tcsdup(szExeName); // save non-localized name
		AfxEnableMemoryTracking(bEnable);
		if(!m_pszExeName)
		{
			AfxThrowMemoryException();
		}
	}

	// m_pszAppName is the name used to present to the user
	if (m_pszAppName == NULL)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
		if (AfxLoadString(AFX_IDS_APP_TITLE, szTitle) != 0)
		{
			m_pszAppName = _tcsdup(szTitle);    // human readable title
		}
		else
		{
			m_pszAppName = _tcsdup(m_pszExeName);   // same as EXE
		}
		AfxEnableMemoryTracking(bEnable);
		if(!m_pszAppName)
		{
			AfxThrowMemoryException();
		}
	}

	// application user model ID
	if (m_pszAppID == NULL)
	{
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
		if (AfxLoadString(AFX_IDS_APP_ID, szAppID) != 0)
		{
			m_pszAppID = _tcsdup(szAppID);
		}
		else
		{
			m_pszAppID = _T("");   // empty
		}
		AfxEnableMemoryTracking(bEnable);
		if(!m_pszAppID)
		{
			AfxThrowMemoryException();
		}
	}

	pModuleState->m_lpszCurrentAppName = m_pszAppName;
	ASSERT(afxCurrentAppName != NULL);

	// get path of .HLP file or .CHM (HtmlHelp) file
	if (m_pszHelpFilePath == NULL)
	{
		if (m_eHelpType == afxHTMLHelp)
			Checked::tcscpy_s(lpszExt, _countof(szBuff) - (lpszExt - szBuff), _T(".CHM"));
		else
			Checked::tcscpy_s(lpszExt, _countof(szBuff) - (lpszExt - szBuff), _T(".HLP"));
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszHelpFilePath = _tcsdup(szBuff);
		AfxEnableMemoryTracking(bEnable);
		if(!m_pszHelpFilePath)
		{
			AfxThrowMemoryException();
		}
		*lpszExt = '\0';       // back to no suffix
	}

	if (m_pszProfileName == NULL)
	{
		Checked::tcscat_s(szExeName, _countof(szExeName), _T(".INI")); // will be enough room in buffer
		BOOL bEnable = AfxEnableMemoryTracking(FALSE);
		m_pszProfileName = _tcsdup(szExeName);
		AfxEnableMemoryTracking(bEnable);
		if(!m_pszProfileName)
		{
			AfxThrowMemoryException();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFile implementation helpers

#ifdef AfxGetFileName
#undef AfxGetFileName
#endif

UINT AFXAPI AfxGetFileName(LPCTSTR lpszPathName, _Out_opt_cap_(nMax) LPTSTR lpszTitle, UINT nMax)
{
	ASSERT(lpszTitle == NULL ||
		AfxIsValidAddress(lpszTitle, nMax));
	ASSERT(AfxIsValidString(lpszPathName));

	ENSURE_ARG(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPTSTR lpszTemp = ::PathFindFileName(lpszPathName);

	// lpszTitle can be NULL which just returns the number of bytes
	if (lpszTitle == NULL)
		return lstrlen(lpszTemp)+1;

	// otherwise copy it into the buffer provided
	Checked::tcsncpy_s(lpszTitle, nMax, lpszTemp, _TRUNCATE);
	return 0;
}

/////////////////////////////////////////////////////////////////////////////

#pragma init_seg( lib )

#ifdef _DEBUG
ATL::CTraceCategory traceMultiApp(_T("MultiApp"));
ATL::CTraceCategory traceAppMsg(_T("AppMsg"));
ATL::CTraceCategory traceWinMsg(_T("WinMsg"));
ATL::CTraceCategory traceCmdRouting(_T("CmdRouting"));
ATL::CTraceCategory traceOle(_T("Ole"));
ATL::CTraceCategory traceDatabase(_T("Database"));
ATL::CTraceCategory traceInternet(_T("Internet"));
ATL::CTraceCategory traceDumpContext(_T("CDumpContext"));
ATL::CTraceCategory traceMemory(_T("Memory"));
ATL::CTraceCategory traceGdi(_T("GDI"));
ATL::CTraceCategory traceUser(_T("User"));
ATL::CTraceCategory traceKernel(_T("Kernel"));
ATL::CTraceCategory traceHtml(_T("HTML"));
ATL::CTraceCategory traceSocket(_T("Socket"));
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"

/////////////////////////////////////////////////////////////////////////////
// export WinMain to force linkage to this module
extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	_In_ LPTSTR lpCmdLine, int nCmdShow);

extern "C" int WINAPI
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	_In_ LPTSTR lpCmdLine, int nCmdShow)
#pragma warning(suppress: 4985)
{
	// call shared/exported WinMain
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}

/////////////////////////////////////////////////////////////////////////////
// initialize app state such that it points to this module's core state

BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	pModuleState->m_bDLL = (BYTE)bDLL;
	ASSERT(dwVersion <= _MFC_VER);
	UNUSED(dwVersion);  // not used in release build
#ifdef _AFXDLL
	pModuleState->m_dwVersion = dwVersion;
#endif
#ifdef _MBCS
	// set correct multi-byte code-page for Win32 apps
	if (!bDLL)
		_setmbcp(_MB_CP_ANSI);
#endif //_MBCS
	return TRUE;
}

// force initialization early
#pragma warning(disable: 4074)
#pragma init_seg(lib)

#ifndef _AFXDLL
void AFX_CDECL _AfxTermAppState()
{
	// terminate local data and critical sections
	AfxTermLocalData(NULL, TRUE);
	AfxCriticalTerm();

	// release the reference to thread local storage data
	AfxTlsRelease();
}
#endif

#ifndef _AFXDLL
char _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER), atexit(&_AfxTermAppState));
#else
char _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER));
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appdlg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// WinApp features for new and open

void CWinApp::OnFileNew()
{
	if (m_pDocManager != NULL)
		m_pDocManager->OnFileNew();
}

/////////////////////////////////////////////////////////////////////////////

void CWinApp::OnFileOpen()
{
	ENSURE(m_pDocManager != NULL);
	m_pDocManager->OnFileOpen();
}

// prompt for file name - used for open and save as
BOOL CWinApp::DoPromptFileName(CString& fileName, UINT nIDSTitle, DWORD lFlags,
	BOOL bOpenFileDialog, CDocTemplate* pTemplate)
		// if pTemplate==NULL => all document templates
{
	ENSURE(m_pDocManager != NULL);
	return m_pDocManager->DoPromptFileName(fileName, nIDSTitle, lFlags,
		bOpenFileDialog, pTemplate);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appprnt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <cderr.h>      // Commdlg Error definitions
#include <winspool.h>



/////////////////////////////////////////////////////////////////////////////
// WinApp support for printing

BOOL CWinApp::GetPrinterDeviceDefaults(PRINTDLG* pPrintDlg)
{
	UpdatePrinterSelection(m_hDevNames == NULL); //force default if no current
	if (m_hDevNames == NULL)
		return FALSE;               // no printer defaults

	ENSURE_ARG(pPrintDlg != NULL);
	pPrintDlg->hDevNames = m_hDevNames;
	pPrintDlg->hDevMode = m_hDevMode;

	::GlobalUnlock(m_hDevNames);
	::GlobalUnlock(m_hDevMode);
	return TRUE;
}

void CWinApp::UpdatePrinterSelection(BOOL bForceDefaults)
{
	if (!bForceDefaults && m_hDevNames != NULL)
	{
		LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(m_hDevNames);
		ENSURE(lpDevNames != NULL);
		if (lpDevNames->wDefault & DN_DEFAULTPRN)
		{
			CPrintDialog pd(TRUE);
			if (!pd.GetDefaults())
				return;

			if (pd.m_pd.hDevNames == NULL)
			{
				// Printer was default, but now there are no printers at all!
				if (m_hDevMode != NULL)
					AfxGlobalFree(m_hDevMode);
				AfxGlobalFree(m_hDevNames);
				m_hDevMode = NULL;
				m_hDevNames = NULL;
			}
			else if (
				lstrcmp((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
					pd.GetDriverName()) != 0 ||
				lstrcmp((LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
					pd.GetDeviceName()) != 0 ||
				lstrcmp((LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
					pd.GetPortName()) != 0)
			{
				// Printer was default, and default has changed...assume default
				if (m_hDevMode != NULL)
					AfxGlobalFree(m_hDevMode);
				AfxGlobalFree(m_hDevNames);
				m_hDevMode = pd.m_pd.hDevMode;
				m_hDevNames = pd.m_pd.hDevNames;
			}
			else
			{
				// Printer was default, and still is...keep the same
				if (pd.m_pd.hDevMode != NULL)
					AfxGlobalFree(pd.m_pd.hDevMode);
				if (pd.m_pd.hDevNames != NULL)
					AfxGlobalFree(pd.m_pd.hDevNames);
			}
		}
	}
	else
	{
		// First time or Forced -- Get defaults
		CPrintDialog pd(TRUE);
		pd.GetDefaults();

		if (m_hDevMode != NULL)
			AfxGlobalFree(m_hDevMode);
		if (m_hDevNames != NULL)
			AfxGlobalFree(m_hDevNames);

		m_hDevMode = pd.m_pd.hDevMode;
		m_hDevNames = pd.m_pd.hDevNames;
	}
}

INT_PTR CWinApp::DoPrintDialog(CPrintDialog* pPD)
{
	ENSURE_VALID(pPD);
	UpdatePrinterSelection(FALSE);

	pPD->m_pd.hDevMode = m_hDevMode;
	pPD->m_pd.hDevNames = m_hDevNames;
	INT_PTR nResponse = pPD->DoModal();

	// if OK or Cancel is selected we need to update cached devMode/Names
	while (nResponse != IDOK && nResponse != IDCANCEL)
	{
		switch (::AfxCtxCommDlgExtendedError())
		{
		// CommDlg cannot give these errors after NULLing these handles
		case PDERR_PRINTERNOTFOUND:
		case PDERR_DNDMMISMATCH:
		case PDERR_DEFAULTDIFFERENT:
			if (pPD->m_pd.hDevNames != NULL)
			{
				ASSERT(m_hDevNames == pPD->m_pd.hDevNames);
				AfxGlobalFree(pPD->m_pd.hDevNames);
				pPD->m_pd.hDevNames = NULL;
				m_hDevNames = NULL;
			}

			if (pPD->m_pd.hDevMode)
			{
				ASSERT(m_hDevMode == pPD->m_pd.hDevMode);
				AfxGlobalFree(pPD->m_pd.hDevMode);
				pPD->m_pd.hDevMode = NULL;
				m_hDevMode = NULL;
			}
			break;

		default:
			return nResponse;       // do not update cached devMode/Names
		}

		nResponse = pPD->DoModal();
	}

	// refresh current CWinApp cache of printer device information
	m_hDevMode = pPD->m_pd.hDevMode;
	m_hDevNames = pPD->m_pd.hDevNames;

	return nResponse;
}

void CWinApp::OnFilePrintSetup()
{
	CPrintDialog pd(TRUE);
	DoPrintDialog(&pd);
}

void CWinApp::SelectPrinter(HANDLE hDevNames, HANDLE hDevMode, BOOL bFreeOld)
{
	if (m_hDevNames != hDevNames)
	{
		if (m_hDevNames != NULL && bFreeOld)
			AfxGlobalFree(m_hDevNames);
		m_hDevNames = hDevNames;
	}
	if (m_hDevMode != hDevMode)
	{
		if (m_hDevMode != NULL && bFreeOld)
			AfxGlobalFree(m_hDevMode);
		m_hDevMode = hDevMode;
	}
}

BOOL CWinApp::CreatePrinterDC(CDC& dc)
{
	HDC hDC = AfxCreateDC(m_hDevNames, m_hDevMode);
	if (hDC != NULL)
	{
		dc.DeleteDC();
		BOOL bRet = dc.Attach(hDC);
		ASSERT(bRet);
		return bRet;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <malloc.h>
#include "sal.h"

#include "afxglobals.h"
#include "afxdatarecovery.h"

AFX_STATIC_DATA const TCHAR _afxFileSection[] = _T("Recent File List");
AFX_STATIC_DATA const TCHAR _afxFileEntry[] = _T("File%d");
AFX_STATIC_DATA const TCHAR _afxPreviewSection[] = _T("Settings");
AFX_STATIC_DATA const TCHAR _afxPreviewEntry[] = _T("PreviewPages");

/////////////////////////////////////////////////////////////////////////////
// globals (internal library use)

// CDocManager statics are in this file for granularity reasons
BOOL CDocManager::bStaticInit = TRUE;
CDocManager* CDocManager::pStaticDocManager = NULL;
CPtrList* CDocManager::pStaticList = NULL;

BEGIN_MESSAGE_MAP(CWinApp, CCmdTarget)
	//{{AFX_MSG_MAP(CWinApp)
	// Global File commands
	ON_COMMAND(ID_APP_EXIT, &CWinApp::OnAppExit)
	// MRU - most recently used file menu
	ON_UPDATE_COMMAND_UI(ID_FILE_MRU_FILE1, &CWinApp::OnUpdateRecentFileMenu)
	ON_COMMAND_EX_RANGE(ID_FILE_MRU_FILE1, ID_FILE_MRU_FILE16, &CWinApp::OnOpenRecentFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// _AFX_WIN_STATE implementation


static HINSTANCE _AfxLoadLangDLL(LPCTSTR pszFormat, LPCTSTR pszPath, LCID lcid)
{
	TCHAR szLangDLL[_MAX_PATH+14];
	TCHAR szLangCode[4];
	HINSTANCE hInstance;

	if (lcid == LOCALE_SYSTEM_DEFAULT)
	{
		Checked::tcscpy_s(szLangCode, _countof(szLangCode), _T("LOC"));
	}
	else
	{
		int nResult;

		nResult = ::GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szLangCode, 4);
		if (nResult == 0)
			return NULL;
		ASSERT( nResult == 4 );
	}

	int ret;
	ATL_CRT_ERRORCHECK_SPRINTF(ret = _sntprintf_s(szLangDLL,_countof(szLangDLL),_countof(szLangDLL)-1,pszFormat,pszPath,szLangCode));
	if(ret == -1 || ret >= _countof(szLangDLL))
	{
		ASSERT(FALSE);
		return NULL;
	}

	hInstance = ::LoadLibrary(szLangDLL);

	return hInstance;
}

static BOOL CALLBACK _AfxEnumResLangProc(HMODULE /*hModule*/, LPCTSTR /*pszType*/, 
	LPCTSTR /*pszName*/, WORD langid, LONG_PTR lParam)
{
	if(lParam == NULL)
		return FALSE;
		
	LANGID* plangid = reinterpret_cast< LANGID* >( lParam );
	*plangid = langid;

	return TRUE;
}

class CActivationContext
{
protected :
	HANDLE m_hCtxt;
	ULONG_PTR m_uCookie;

public:
	CActivationContext(HANDLE hCtxt = INVALID_HANDLE_VALUE) : m_hCtxt( hCtxt ), m_uCookie( 0 )
	{
	};
	
	~CActivationContext()
	{
		Release();
	}

	bool Create( PCACTCTX pactctx )
	{
		ASSERT( pactctx != NULL );
		if ( pactctx == NULL )
		{
			return false;
		}

		ASSERT( m_hCtxt == INVALID_HANDLE_VALUE );
		if ( m_hCtxt != INVALID_HANDLE_VALUE )
		{
			return false;
		}

		return ( ( m_hCtxt = CreateActCtx( pactctx ) ) != INVALID_HANDLE_VALUE );
	}

	void Release()
	{
		if ( m_hCtxt != INVALID_HANDLE_VALUE )
		{
			Deactivate();
			ReleaseActCtx( m_hCtxt );
		}
	}

	bool Activate()
	{
		ASSERT( m_hCtxt != INVALID_HANDLE_VALUE );
		if ( m_hCtxt == INVALID_HANDLE_VALUE )
		{
			return false;
		}

		ASSERT( m_uCookie == 0 );
		if ( m_uCookie != 0 )
		{
			return false;
		}
	
		return ( ActivateActCtx( m_hCtxt, &m_uCookie) == TRUE );
	}
	
	bool Deactivate()
	{
		if ( m_uCookie != 0 )
		{
			ULONG_PTR uCookie = m_uCookie;
			m_uCookie = 0;
			return ( DeactivateActCtx(0, uCookie) == TRUE );
		}
		return true;
	}
};


// HINSTANCE of the module
extern "C" IMAGE_DOS_HEADER __ImageBase;

typedef BOOL (WINAPI *PFNGETPREFERREDUILANGS)(DWORD, PULONG, PZZWSTR, PULONG);
const int nMaxExpectedPreferredLangs = 20;

HINSTANCE AFXAPI AfxLoadLangResourceDLL(LPCTSTR pszFormat, LPCTSTR pszPath)
{
	// load language specific DLL
	LANGID langid = 0;
	int nPrimaryLang = 0;
	int nSubLang = 0;
	LCID lcid = 0;
	LCID alcidSearch[nMaxExpectedPreferredLangs + 5];
	int nLocales;

	nLocales = 0;

	// First, get the thread preferred UI languages (if supported)
	HMODULE hKernel = AfxCtxLoadLibrary(_T("KERNEL32.DLL"));
	if (hKernel != NULL)
	{
		PFNGETPREFERREDUILANGS pfnGetThreadPreferredUILanguages = (PFNGETPREFERREDUILANGS)GetProcAddress(hKernel, "GetThreadPreferredUILanguages");
		if (pfnGetThreadPreferredUILanguages != NULL)
		{
			BOOL bGotPreferredLangs = FALSE;
			ULONG nLanguages = 0;
			WCHAR wszLanguages[(5 * nMaxExpectedPreferredLangs) + 1] = {0}; // each lang has four chars plus NULL, plus terminating NULL
			ULONG cchLanguagesBuffer = _countof(wszLanguages);
			bGotPreferredLangs = pfnGetThreadPreferredUILanguages(MUI_LANGUAGE_ID | MUI_UI_FALLBACK, &nLanguages, wszLanguages, &cchLanguagesBuffer);
			if (bGotPreferredLangs)
			{
				WCHAR *pwz = wszLanguages;
				while ((*pwz != 0) && (nLocales < nMaxExpectedPreferredLangs))
				{
					ULONG ulLangID = wcstoul(pwz, NULL, 16);
					if ((ulLangID != 0) && (errno != ERANGE))
					{
						alcidSearch[nLocales] = (LCID)ulLangID;
						nLocales++;
					}
					pwz += wcslen(pwz) + 1;  // move to next ID in list
				}
			}
		}
	}

	// Next, try the user's UI language
	langid = GetUserDefaultUILanguage();
	nPrimaryLang = PRIMARYLANGID(langid);
	nSubLang = SUBLANGID(langid);

	lcid = MAKELCID(MAKELANGID(nPrimaryLang, nSubLang), SORT_DEFAULT);
	alcidSearch[nLocales] = ::ConvertDefaultLocale(lcid);
	nLocales++;

	lcid = MAKELCID(MAKELANGID(nPrimaryLang, SUBLANG_NEUTRAL), SORT_DEFAULT);
	alcidSearch[nLocales] = ::ConvertDefaultLocale(lcid);
	nLocales++;

	// Then, try the system's default UI language
	langid = GetSystemDefaultUILanguage();
	nPrimaryLang = PRIMARYLANGID(langid);
	nSubLang = SUBLANGID(langid);

	lcid = MAKELCID(MAKELANGID(nPrimaryLang, nSubLang), SORT_DEFAULT);
	alcidSearch[nLocales] = ::ConvertDefaultLocale(lcid);
	nLocales++;

	lcid = MAKELCID(MAKELANGID(nPrimaryLang, SUBLANG_NEUTRAL), SORT_DEFAULT);
	alcidSearch[nLocales] = ::ConvertDefaultLocale(lcid);
	nLocales++;

	alcidSearch[nLocales] = LOCALE_SYSTEM_DEFAULT;
	nLocales++;

	// get path for our module
	TCHAR rgchFullModulePath[MAX_PATH + 2];
	rgchFullModulePath[_countof(rgchFullModulePath) - 1] = 0;
	rgchFullModulePath[_countof(rgchFullModulePath) - 2] = 0;
	DWORD dw = GetModuleFileName(reinterpret_cast<HMODULE>(&__ImageBase), rgchFullModulePath, _countof(rgchFullModulePath)-1);
	if (dw == 0)
	{
		return NULL;
	}

	for(int iLocale = 0; iLocale < nLocales; iLocale++)
	{
		HINSTANCE hLangDLL;

		hLangDLL = _AfxLoadLangDLL(pszFormat, pszPath, alcidSearch[iLocale]);
		if(hLangDLL != NULL)
			return hLangDLL;
	}

	return NULL;
}

HINSTANCE AFXAPI AfxLoadLangResourceDLL(LPCTSTR pszFormat)
{
	TCHAR pszNewFormat[MAX_PATH + 2 + 1] = _T("%s"); // have space for %s and string terminator
	ENSURE(_tcslen(pszFormat) <= MAX_PATH);
	_tcscat_s (pszNewFormat, _countof(pszNewFormat), pszFormat);
	return AfxLoadLangResourceDLL(pszNewFormat, _T(""));
}

CWinApp::CWinApp(LPCTSTR lpszAppName)
{
	if (lpszAppName != NULL)
		m_pszAppName = _tcsdup(lpszAppName);
	else
		m_pszAppName = NULL;

	// initialize CWinThread state
	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
	ENSURE(pModuleState);
	AFX_MODULE_THREAD_STATE* pThreadState = pModuleState->m_thread;
	ENSURE(pThreadState);
	ASSERT(AfxGetThread() == NULL);
	pThreadState->m_pCurrentWinThread = this;
	ASSERT(AfxGetThread() == this);
	m_hThread = ::GetCurrentThread();
	m_nThreadID = ::GetCurrentThreadId();

	// initialize CWinApp state
	ASSERT(afxCurrentWinApp == NULL); // only one CWinApp object please
	pModuleState->m_pCurrentWinApp = this;
	ASSERT(AfxGetApp() == this);

	// in non-running state until WinMain
	m_hInstance = NULL;
	m_hLangResourceDLL = NULL;
	m_pszHelpFilePath = NULL;
	m_pszProfileName = NULL;
	m_pszRegistryKey = NULL;
	m_pszExeName = NULL;
	m_pRecentFileList = NULL;
	m_pDocManager = NULL;
	m_atomApp = m_atomSystemTopic = NULL;
	m_lpCmdLine = NULL;
	m_pCmdInfo = NULL;
	m_pDataRecoveryHandler = NULL;

	// initialize wait cursor state
	m_nWaitCursorCount = 0;
	m_hcurWaitCursorRestore = NULL;

	// initialize current printer state
	m_hDevMode = NULL;
	m_hDevNames = NULL;
	m_nNumPreviewPages = 0;     // not specified (defaults to 1)

	// initialize DAO state
	m_lpfnDaoTerm = NULL;   // will be set if AfxDaoInit called

	// other initialization
	m_bHelpMode = FALSE;
	m_eHelpType = afxWinHelp;
	m_nSafetyPoolSize = 512;        // default size

	m_dwRestartManagerSupportFlags = 0;    // don't support Restart Manager by default
	m_nAutosaveInterval = 5 * 60 * 1000;   // default autosave interval is 5 minutes (only has effect if autosave flag is set)

	m_bTaskbarInteractionEnabled = TRUE;
}

BOOL CWinApp::LoadSysPolicies() 
{
	return _LoadSysPolicies();
}

// This function is not exception safe - will leak a registry key if exceptions are thrown from some places
// To reduce risk of leaks, I've declared the whole function throw(). This despite the fact that its callers have
// no dependency on non-throwing.
BOOL CWinApp::_LoadSysPolicies() throw()
{
	HKEY hkPolicy = NULL;
	DWORD dwValue = 0;
	DWORD dwDataLen = sizeof(dwValue);
	DWORD dwType = 0;

	// clear current policy settings.
	m_dwPolicies = _AFX_SYSPOLICY_NOTINITIALIZED;

	static _AfxSysPolicyData rgExplorerData[] = 
	{
		{_T("NoRun"), _AFX_SYSPOLICY_NORUN},
		{_T("NoDrives"), _AFX_SYSPOLICY_NODRIVES},
		{_T("RestrictRun"), _AFX_SYSPOLICY_RESTRICTRUN},
		{_T("NoNetConnectDisconnect"), _AFX_SYSPOLICY_NONETCONNECTDISCONNECTD},
		{_T("NoRecentDocsHistory"), _AFX_SYSPOLICY_NORECENTDOCHISTORY},
		{_T("NoClose"), _AFX_SYSPOLICY_NOCLOSE},
		{NULL, NULL}
	};

	static _AfxSysPolicyData rgNetworkData[] = 
	{
		{_T("NoEntireNetwork"), _AFX_SYSPOLICY_NOENTIRENETWORK},
		{NULL, NULL}
	};

	static _AfxSysPolicyData rgComDlgData[] = 
	{
		{_T("NoPlacesBar"), _AFX_SYSPOLICY_NOPLACESBAR},
		{_T("NoBackButton"), _AFX_SYSPOLICY_NOBACKBUTTON},
		{_T("NoFileMru"), _AFX_SYSPOLICY_NOFILEMRU},
		{NULL, NULL}
	};

	static _AfxSysPolicies rgPolicies[] = 
	{
		{_T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
			rgExplorerData},
		{_T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Network"),
			rgNetworkData},
		{_T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Comdlg32"),
			rgComDlgData},
		{NULL, NULL}
	};

	_AfxSysPolicies *pPolicies = rgPolicies;
	_AfxSysPolicyData *pData = NULL;

	while (pPolicies->szPolicyKey != NULL)
	{

		if (ERROR_SUCCESS == ::RegOpenKeyEx(
					HKEY_CURRENT_USER,
					pPolicies->szPolicyKey,
					NULL,
					KEY_QUERY_VALUE,
					&hkPolicy
					))
		{
			pData = pPolicies->pData;
			while (pData->szPolicyName)
			{
				if (ERROR_SUCCESS == ::RegQueryValueEx(
									 hkPolicy,
									 pData->szPolicyName,
									 NULL,
									 &dwType,
									 (BYTE*)&dwValue,
									 &dwDataLen))
				{
					if (dwType == REG_DWORD)
					{
						if (dwValue != 0)
							m_dwPolicies |= pData->dwID;
						else
							m_dwPolicies &= ~pData->dwID;
					}
				}
				dwValue = 0;
				dwDataLen = sizeof(dwValue);
				dwType = 0;
				pData++;
			}
			::RegCloseKey(hkPolicy);
			hkPolicy = NULL;
		}
		pPolicies++;
	};
	return TRUE;
}

BOOL CWinApp::GetSysPolicyValue(DWORD dwPolicyID, BOOL *pbValue)
{
	if (!pbValue)
		return FALSE; // bad pointer
	*pbValue = (m_dwPolicies & dwPolicyID) != 0;
	return TRUE;
}

BOOL CWinApp::InitApplication()
{
	if (CDocManager::pStaticDocManager != NULL)
	{
		if (m_pDocManager == NULL)
			m_pDocManager = CDocManager::pStaticDocManager;
		CDocManager::pStaticDocManager = NULL;
	}

	if (m_pDocManager != NULL)
		m_pDocManager->AddDocTemplate(NULL);
	else
		CDocManager::bStaticInit = FALSE;

	LoadSysPolicies();

	return TRUE;
}

BOOL CWinApp::InitInstance()
{
	InitLibId();
	m_hLangResourceDLL = LoadAppLangResourceDLL();
	if(m_hLangResourceDLL != NULL)
	{
		AfxSetResourceHandle(m_hLangResourceDLL);
		_AtlBaseModule.SetResourceInstance(m_hLangResourceDLL);
	}

	// Register the application with the Restart Manager, if supported.
	if (SupportsRestartManager())
	{
		RegisterWithRestartManager(SupportsApplicationRecovery(), _T(""));
	}

	return TRUE;
}

HINSTANCE CWinApp::LoadAppLangResourceDLL()
{
	TCHAR szPath[MAX_PATH];
	LPTSTR pszExtension;

	int ret = ::GetModuleFileName(m_hInstance, szPath, MAX_PATH);
	if(ret == 0 || ret == MAX_PATH)
	{
		ASSERT(FALSE);
		return NULL;
	}
	pszExtension = ::PathFindExtension(szPath);
	*pszExtension = '\0';

	TCHAR szFormat[] = _T("%s%s.dll");

	return AfxLoadLangResourceDLL(szFormat, szPath);
}

void CWinApp::LoadStdProfileSettings(UINT nMaxMRU)
{
	ASSERT_VALID(this);
	ASSERT(m_pRecentFileList == NULL);

	BOOL bNoRecentDocs = FALSE;
	GetSysPolicyValue(_AFX_SYSPOLICY_NORECENTDOCHISTORY, &bNoRecentDocs);
	if (nMaxMRU != 0 && !bNoRecentDocs )
	{
		// create file MRU since nMaxMRU not zero
		m_pRecentFileList = new CRecentFileList(0, _afxFileSection, _afxFileEntry,
			nMaxMRU);
		m_pRecentFileList->ReadList();
	}
	// 0 by default means not set
	m_nNumPreviewPages = GetProfileInt(_afxPreviewSection, _afxPreviewEntry, 0);
}

void CWinApp::ParseCommandLine(CCommandLineInfo& rCmdInfo)
{
	for (int i = 1; i < __argc; i++)
	{
		LPCTSTR pszParam = __targv[i];
		BOOL bFlag = FALSE;
		BOOL bLast = ((i + 1) == __argc);
		if (pszParam[0] == '-' || pszParam[0] == '/')
		{
			// remove flag specifier
			bFlag = TRUE;
			++pszParam;
		}
		rCmdInfo.ParseParam(pszParam, bFlag, bLast);
	}
}

BOOL CWinApp::RestartInstance()
{
	BOOL bRet = FALSE;

	CDataRecoveryHandler *pHandler = GetDataRecoveryHandler();
	if (pHandler)
	{
		// First read the set of previously opened documents (and associated autosaves) from the registry.
		// ReadOpenDocumentList will return TRUE only if at least one document name was read.
		if (pHandler->ReadOpenDocumentList())
		{
			// Then reopen the previously opened documents (handler will check whether this is enabled).
			bRet = pHandler->ReopenPreviousDocuments();

			// Finally restore the the associated autosaves (handler will check whether this is enabled and query user).
			pHandler->RestoreAutosavedDocuments();
		}
	}

	// Return TRUE if any documents were opened, else return FALSE to indicate
	// that a new document should be opened as in the normal startup scenario.
	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CCommandLineInfo implementation

#define RESTART_COMMAND_LINE_ARG "RestartByRestartManager"  // command-line argument used when restarting the application
#define RESTART_IDENTIFIER_LEN   36                         // length of restart identifier (GUID) used when restarting

CCommandLineInfo::CCommandLineInfo()
{
	m_bShowSplash = TRUE;
	m_bRunEmbedded = FALSE;
	m_bRunAutomated = FALSE;
	m_bRegisterPerUser = FALSE;
	m_nShellCommand = FileNew;
}

CCommandLineInfo::~CCommandLineInfo()
{
}

void CCommandLineInfo::ParseParam(const TCHAR* pszParam,BOOL bFlag,BOOL bLast)
{
	if (bFlag)
	{
		const CStringA strParam(pszParam);
		ParseParamFlag(strParam.GetString());
	}
	else
		ParseParamNotFlag(pszParam);

	ParseLast(bLast);
}

#ifdef UNICODE
void CCommandLineInfo::ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast)
{
	if (bFlag)
		ParseParamFlag(pszParam);
	else
		ParseParamNotFlag(pszParam);

	ParseLast(bLast);
}
#endif // UNICODE

void CCommandLineInfo::ParseParamFlag(const char* pszParam)
{
	// OLE command switches are case insensitive, while
	// shell command switches are case sensitive

	if (lstrcmpA(pszParam, "pt") == 0)
		m_nShellCommand = FilePrintTo;
	else if (lstrcmpA(pszParam, "p") == 0)
		m_nShellCommand = FilePrint;
	else if (::AfxInvariantStrICmp(pszParam, "Register") == 0 ||
		::AfxInvariantStrICmp(pszParam, "Regserver") == 0)
		m_nShellCommand = AppRegister;
	else if (::AfxInvariantStrICmp(pszParam, "RegisterPerUser") == 0 ||
		::AfxInvariantStrICmp(pszParam, "RegserverPerUser") == 0)
	{
		m_nShellCommand = AppRegister;
		m_bRegisterPerUser = TRUE;
	}
	else if (::AfxInvariantStrICmp(pszParam, "Unregister") == 0 ||
		::AfxInvariantStrICmp(pszParam, "Unregserver") == 0)
		m_nShellCommand = AppUnregister;
	else if (::AfxInvariantStrICmp(pszParam, "UnregisterPerUser") == 0 ||
		::AfxInvariantStrICmp(pszParam, "UnregserverPerUser") == 0)
	{
		m_nShellCommand = AppUnregister;
		m_bRegisterPerUser = TRUE;
	}
	else if (_strnicmp(pszParam, RESTART_COMMAND_LINE_ARG, _countof(RESTART_COMMAND_LINE_ARG) - 1) == 0)
	{
		CString strParam = pszParam;
		if (strParam.GetLength() == _countof(RESTART_COMMAND_LINE_ARG) + RESTART_IDENTIFIER_LEN)
		{
			m_nShellCommand = RestartByRestartManager;
			m_strRestartIdentifier = strParam.Right(RESTART_IDENTIFIER_LEN);
		}
	}
	else if (lstrcmpA(pszParam, "ddenoshow") == 0)
	{
		AfxOleSetUserCtrl(FALSE);
		m_nShellCommand = FileDDENoShow;
	}
	else if (lstrcmpA(pszParam, "dde") == 0)
	{
		AfxOleSetUserCtrl(FALSE);
		m_nShellCommand = FileDDE;
	}
	else if (::AfxInvariantStrICmp(pszParam, "Embedding") == 0)
	{
		AfxOleSetUserCtrl(FALSE);
		m_bRunEmbedded = TRUE;
		m_bShowSplash = FALSE;
	}
	else if (::AfxInvariantStrICmp(pszParam, "Automation") == 0)
	{
		AfxOleSetUserCtrl(FALSE);
		m_bRunAutomated = TRUE;
		m_bShowSplash = FALSE;
	}
}

void CCommandLineInfo::ParseParamNotFlag(const TCHAR* pszParam)
{
	if (m_strFileName.IsEmpty())
		m_strFileName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strPrinterName.IsEmpty())
		m_strPrinterName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strDriverName.IsEmpty())
		m_strDriverName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strPortName.IsEmpty())
		m_strPortName = pszParam;
}

#ifdef UNICODE
void CCommandLineInfo::ParseParamNotFlag(const char* pszParam)
{
	if (m_strFileName.IsEmpty())
		m_strFileName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strPrinterName.IsEmpty())
		m_strPrinterName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strDriverName.IsEmpty())
		m_strDriverName = pszParam;
	else if (m_nShellCommand == FilePrintTo && m_strPortName.IsEmpty())
		m_strPortName = pszParam;
}
#endif

void CCommandLineInfo::ParseLast(BOOL bLast)
{
	if (bLast)
	{
		if (m_nShellCommand == FileNew && !m_strFileName.IsEmpty())
			m_nShellCommand = FileOpen;
		m_bShowSplash = !m_bRunEmbedded && !m_bRunAutomated;
	}
}

/////////////////////////////////////////////////////////////////////////////
// App termination

CWinApp::~CWinApp()
{
	AFX_BEGIN_DESTRUCTOR

	// free doc manager
	if (m_pDocManager != NULL)
		delete m_pDocManager;

	// free recent file list
	if (m_pRecentFileList != NULL)
		delete m_pRecentFileList;

	// free data recovery handler
	if (m_pDataRecoveryHandler != NULL)
		delete m_pDataRecoveryHandler;

	// free static list of document templates
	if (!afxContextIsDLL)
	{
		if (CDocManager::pStaticList != NULL)
		{
			delete CDocManager::pStaticList;
			CDocManager::pStaticList = NULL;
		}
		if (CDocManager::pStaticDocManager != NULL)
		{
			delete CDocManager::pStaticDocManager;
			CDocManager::pStaticDocManager = NULL;
		}
	}

	// free printer info
	if (m_hDevMode != NULL)
		AfxGlobalFree(m_hDevMode);
	if (m_hDevNames != NULL)
		AfxGlobalFree(m_hDevNames);

	// free atoms if used
	if (m_atomApp != NULL)
		::GlobalDeleteAtom(m_atomApp);
	if (m_atomSystemTopic != NULL)
		::GlobalDeleteAtom(m_atomSystemTopic);

	// free cached commandline
	if (m_pCmdInfo != NULL)
		delete m_pCmdInfo;

	// cleanup module state
	AFX_MODULE_STATE* pModuleState = _AFX_CMDTARGET_GETSTATE();
	if (pModuleState->m_lpszCurrentAppName == m_pszAppName)
		pModuleState->m_lpszCurrentAppName = NULL;
	if (pModuleState->m_pCurrentWinApp == this)
		pModuleState->m_pCurrentWinApp = NULL;

	// free various strings allocated with _tcsdup
	free((void*)m_pszAppName);
	free((void*)m_pszRegistryKey);
	free((void*)m_pszExeName);
	free((void*)m_pszHelpFilePath);
	free((void*)m_pszProfileName);

	// avoid calling CloseHandle() on our own thread handle
	// during the CWinThread destructor
	m_hThread = NULL;
	AFX_END_DESTRUCTOR
}

void CWinApp::SaveStdProfileSettings()
{
	ASSERT_VALID(this);

	if (m_pRecentFileList != NULL)
		m_pRecentFileList->WriteList();

	if (m_nNumPreviewPages != 0)
		WriteProfileInt(_afxPreviewSection, _afxPreviewEntry, m_nNumPreviewPages);
}

int CWinApp::ExitInstance()
{
	// if we remember that we're unregistering,
	// don't save our profile settings

	if (m_pCmdInfo == NULL ||
		(m_pCmdInfo->m_nShellCommand != CCommandLineInfo::AppUnregister &&
		 m_pCmdInfo->m_nShellCommand != CCommandLineInfo::AppRegister))
	{
		if (!afxContextIsDLL)
			SaveStdProfileSettings();
	}

	// Cleanup DAO if necessary
	if (m_lpfnDaoTerm != NULL)
	{
		// If a DLL, YOU must call AfxDaoTerm prior to ExitInstance
		ASSERT(!afxContextIsDLL);
		(*m_lpfnDaoTerm)();
	}

	if (m_hLangResourceDLL != NULL)
	{
		::FreeLibrary(m_hLangResourceDLL);
		m_hLangResourceDLL = NULL;
	}

	int nReturnValue=0;
	if(AfxGetCurrentMessage())
	{
		nReturnValue=static_cast<int>(AfxGetCurrentMessage()->wParam);
	}
	
	return nReturnValue; // returns the value from PostQuitMessage
}

/////////////////////////////////////////////////////////////////////////////


// Main running routine until application exits
int CWinApp::Run()
{
	if (m_pMainWnd == NULL && AfxOleGetUserCtrl())
	{
		// Not launched /Embedding or /Automation, but has no main window!
		TRACE(traceAppMsg, 0, "Warning: m_pMainWnd is NULL in CWinApp::Run - quitting application.\n");
		AfxPostQuitMessage(0);
	}
	return CWinThread::Run();
}


void AFXAPI AfxPostQuitMessage(int nExitCode)
{
	// cleanup OLE libraries
	CWinThread* pThread = AfxGetThread();
	if (pThread != NULL && pThread->m_lpfnOleTermOrFreeLib != NULL)
		(*pThread->m_lpfnOleTermOrFreeLib)(TRUE, TRUE);

	::PostQuitMessage(nExitCode);
}

/////////////////////////////////////////////////////////////////////////////
// WinHelp Helper


void CWinApp::WinHelp(DWORD_PTR dwData, UINT nCmd)
{
	CWnd* pMainWnd = AfxGetMainWnd();
	ENSURE_VALID(pMainWnd);

	// return global app help mode state to FALSE (backward compatibility)
	m_bHelpMode = FALSE;
	pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update

	pMainWnd->WinHelp(dwData, nCmd);
}

/////////////////////////////////////////////////////////////////////////////
// HtmlHelp Helper

void CWinApp::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	CWnd* pMainWnd = AfxGetMainWnd();
	ENSURE_VALID(pMainWnd);

	// return global app help mode state to FALSE (backward compatibility)
	m_bHelpMode = FALSE;
	pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update

	pMainWnd->HtmlHelp(dwData, nCmd);
}

void CWinApp::WinHelpInternal(DWORD_PTR dwData, UINT nCmd)
{
	CWnd* pMainWnd = AfxGetMainWnd();
	ENSURE_VALID(pMainWnd);

	// return global app help mode state to FALSE (backward compatibility)
	m_bHelpMode = FALSE;
	pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update
	pMainWnd->WinHelpInternal(dwData, nCmd);
}

/////////////////////////////////////////////////////////////////////////////
// Restart Manager support

// Restart Manager is only supported on Vista+, so we dynamically load the exports we need
typedef HRESULT (WINAPI *PFNREGISTERAPPLICATIONRESTART)(PCWSTR, DWORD);
typedef HRESULT (WINAPI *PFNREGISTERAPPLICATIONRECOVERYCALLBACK)(APPLICATION_RECOVERY_CALLBACK, PVOID, DWORD, DWORD);
typedef HRESULT (WINAPI *PFNAPPLICATIONRECOVERYINPROGRESS)(PBOOL);
typedef VOID    (WINAPI *PFNAPPLICATIONRECOVERYFINISHED)(BOOL);

DWORD WINAPI AfxApplicationRecoveryWrapper(LPVOID lpvParam)
{
	DWORD dwRet = 0;
	CWinApp *pApp = AfxGetApp();
	if (pApp != NULL)
	{
		ASSERT_VALID(pApp);
		dwRet = pApp->ApplicationRecoveryCallback(lpvParam);
	}

	return dwRet;
}

HRESULT CWinApp::RegisterWithRestartManager(BOOL bRegisterRecoveryCallback, const CString &strRestartIdentifierParam)
{
	// This method may be called twice.  It will be called from CWinApp::InitInstance with an empty restart identifier string,
	// and a new restart identifier string will be generated.  It may then be called from CWinApp::ProcessShellCommand with the
	// restart identifier string that was passed in on the command line, if the application was restarted by the Restart Manager.

	// The restart identifier is the key name where the list of documents is stored in the registry.
	// It is unique per application instance.

	HRESULT hr = S_OK;
	CString strCommandLineArgs, strCommandLineArgsAppend, strRestartIdentifier = strRestartIdentifierParam;

	// Generate the unique ID for the restart information for this instance
	if (strRestartIdentifier.IsEmpty())
	{
		GUID guidRestartIdentifier = GUID_NULL;
		CoCreateGuid(&guidRestartIdentifier);

		CString strGuid;
		strRestartIdentifier.Format(_T("%08lX-%04X-%04x-%02X%02X-%02X%02X%02X%02X%02X%02X"),
			guidRestartIdentifier.Data1, guidRestartIdentifier.Data2, guidRestartIdentifier.Data3,
			guidRestartIdentifier.Data4[0], guidRestartIdentifier.Data4[1], guidRestartIdentifier.Data4[2], guidRestartIdentifier.Data4[3],
			guidRestartIdentifier.Data4[4], guidRestartIdentifier.Data4[5], guidRestartIdentifier.Data4[6], guidRestartIdentifier.Data4[7]);
	}

	// Set up the command line to be used if the Restart Manager restarts this instance
	strCommandLineArgs = m_lpCmdLine;

	strCommandLineArgsAppend += _T(RESTART_COMMAND_LINE_ARG);
	strCommandLineArgsAppend += _T(":");
	strCommandLineArgsAppend += strRestartIdentifier;

	// If this instance of the application was restarted, then the command line already
	// contains the restart command line arguments, so they do not need to be appended.
	if (strCommandLineArgs.Find(strCommandLineArgsAppend, 0) == -1)
	{
		strCommandLineArgs += _T(" /");
		strCommandLineArgs += strCommandLineArgsAppend;
	}

	// Create the data recovery handler
	CDataRecoveryHandler *pHandler = GetDataRecoveryHandler();
	if (pHandler != NULL)
	{
		pHandler->SetRestartIdentifier(strRestartIdentifier);
	}

	if (bRegisterRecoveryCallback)
	{
		hr = RegisterWithRestartManager(CComBSTR(strCommandLineArgs), GetApplicationRestartFlags(), AfxApplicationRecoveryWrapper, GetApplicationRecoveryParameter(), GetApplicationRecoveryPingInterval(), 0);
	}
	else
	{
		hr = RegisterWithRestartManager(CComBSTR(strCommandLineArgs), GetApplicationRestartFlags(), NULL, NULL, 0, 0);
	}

	return hr;
}

HRESULT CWinApp::RegisterWithRestartManager(LPCWSTR pwzCommandLineArgs, DWORD dwRestartFlags, APPLICATION_RECOVERY_CALLBACK pRecoveryCallback, LPVOID lpvParam, DWORD dwPingInterval, DWORD dwCallbackFlags)
{
	HRESULT hr = S_OK;

	HMODULE hKernel = GetModuleHandleW(L"KERNEL32.DLL");
	ENSURE(hKernel != NULL);
	PFNREGISTERAPPLICATIONRESTART pfnRegisterApplicationRestart = (PFNREGISTERAPPLICATIONRESTART)GetProcAddress(hKernel, "RegisterApplicationRestart");
	PFNREGISTERAPPLICATIONRECOVERYCALLBACK pfnRegisterApplicationRecoveryCallback = (PFNREGISTERAPPLICATIONRECOVERYCALLBACK)GetProcAddress(hKernel, "RegisterApplicationRecoveryCallback");

	if (pfnRegisterApplicationRestart && pfnRegisterApplicationRecoveryCallback)
	{
		// Register for restart by the Restart Manager (component update scenario)
		// Note that according to MSDN, UnregisterApplicationRestart does not need to be called on normal
		// application shutdown, but only if the application for some reason can no longer be restarted.
		hr = pfnRegisterApplicationRestart(pwzCommandLineArgs, dwRestartFlags);
		if (hr != S_OK)
		{
			return hr;
		}

		if (pRecoveryCallback != NULL)
		{
			// Register for application recovery (application hang or crash scenario)
			// Note that according to MSDN, UnregisterApplicationRecoveryCallback does not need to be called on normal
			// application shutdown, but only if the application for some reason can no longer do recovery.
			hr = pfnRegisterApplicationRecoveryCallback(pRecoveryCallback, lpvParam, dwPingInterval, dwCallbackFlags);
			if (hr != S_OK)
			{
				return hr;
			}
		}
	}

	return S_OK;
}

DWORD CWinApp::ApplicationRecoveryCallback(LPVOID /* lpvParam */)
{
	// To change this behavior, either override CWinApp::ApplicationRecoveryCallback or
	// call CWinApp::RegisterWithRestartManager using your own recovery callback function.

	HMODULE hKernel = GetModuleHandleW(L"KERNEL32.DLL");
	ENSURE(hKernel != NULL);
	PFNAPPLICATIONRECOVERYINPROGRESS pfnApplicationRecoveryInProgress = (PFNAPPLICATIONRECOVERYINPROGRESS)GetProcAddress(hKernel, "ApplicationRecoveryInProgress");
	PFNAPPLICATIONRECOVERYFINISHED pfnApplicationRecoveryFinished = (PFNAPPLICATIONRECOVERYFINISHED)GetProcAddress(hKernel, "ApplicationRecoveryFinished");

	if (pfnApplicationRecoveryInProgress && pfnApplicationRecoveryFinished)
	{
		// ApplicationRecoveryInProgress must be called before the ping interval has elapsed. The ping interval
		// is set via the dwPingInterval parameter in the call to RegisterApplicationRecoveryCallback above.
		BOOL bRecoveryCanceled = FALSE;
		pfnApplicationRecoveryInProgress(&bRecoveryCanceled);
		if (bRecoveryCanceled)
		{
			// Recovery has been canceled, so terminate the application.
			return 0;
		}

		BOOL bRecoverySuccessful = TRUE;
		CDataRecoveryHandler *pHandler = GetDataRecoveryHandler();
		if (pHandler)
		{
			// Save the list of open documents to the registry.  Since an exception has already
			// occurred, we do as little as possible here, so we don't do any document autosaves.
			bRecoverySuccessful = pHandler->SaveOpenDocumentList();
		}

		// Once recovery is complete, call ApplicationRecoveryFinished so the Restart Manager can restart the app.
		pfnApplicationRecoveryFinished(bRecoverySuccessful);
	}

	return 0;
}

CDataRecoveryHandler *CWinApp::GetDataRecoveryHandler()
{
	static BOOL bTriedOnce = FALSE;

	// Since the application restart and application recovery are supported only on Windows
	// Vista and above, we don't need a recovery handler on Windows versions less than Vista.
	if (afxGlobalData.bIsWindowsVista && (SupportsRestartManager() || SupportsApplicationRecovery()))
	{
		if (!bTriedOnce && m_pDataRecoveryHandler == NULL)
		{
			m_pDataRecoveryHandler = new CDataRecoveryHandler(m_dwRestartManagerSupportFlags, m_nAutosaveInterval);
			if (!m_pDataRecoveryHandler->Initialize())
			{
				delete m_pDataRecoveryHandler;
				m_pDataRecoveryHandler = NULL;
			}
		}
	}

	bTriedOnce = TRUE;
	return m_pDataRecoveryHandler;
}

/////////////////////////////////////////////////////////////////////////////
// Special exception handling

LRESULT CWinApp::ProcessWndProcException(CException* e, const MSG* pMsg)
{
	ENSURE_ARG(e != NULL);
	ENSURE_ARG(pMsg != NULL);
	// handle certain messages in CWinThread
	switch (pMsg->message)
	{
	case WM_CREATE:
	case WM_PAINT:
		return CWinThread::ProcessWndProcException(e, pMsg);
	}

	// handle all the rest
	UINT nIDP = AFX_IDP_INTERNAL_FAILURE;   // generic message string
	LRESULT lResult = 0;        // sensible default
	if (pMsg->message == WM_COMMAND)
	{
		if ((HWND)pMsg->lParam == NULL)
			nIDP = AFX_IDP_COMMAND_FAILURE; // command (not from a control)
		lResult = (LRESULT)TRUE;        // pretend the command was handled
	}
	if (e->IsKindOf(RUNTIME_CLASS(CMemoryException)))
	{
		e->ReportError(MB_ICONEXCLAMATION|MB_SYSTEMMODAL, nIDP);
	}
	else if (!e->IsKindOf(RUNTIME_CLASS(CUserException)))
	{
		// user has not been alerted yet of this catastrophic problem
		e->ReportError(MB_ICONSTOP, nIDP);
	}
	return lResult; // sensible default return from most WndProc functions
}

/////////////////////////////////////////////////////////////////////////////
// CWinApp idle processing

BOOL CWinApp::OnIdle(LONG lCount)
{
	if (lCount <= 0)
	{
		CWinThread::OnIdle(lCount);

		// call doc-template idle hook
		POSITION pos = NULL;
		if (m_pDocManager != NULL)
			pos = m_pDocManager->GetFirstDocTemplatePosition();

		while (pos != NULL)
		{
			CDocTemplate* pTemplate = m_pDocManager->GetNextDocTemplate(pos);
			ASSERT_KINDOF(CDocTemplate, pTemplate);
			// if auto-save is enabled, the auto-save will be performed in the
			// document's OnIdle method, called from the template's OnIdle method
			pTemplate->OnIdle();
		}

		CDataRecoveryHandler *pHandler = GetDataRecoveryHandler();
		if (pHandler)
		{
			// clear the auto-save on idle flag--it will be set
			// again the next time the auto-save timer ticks.
			pHandler->SetSaveDocumentInfoOnIdle(FALSE);
		}
	}
	else if (lCount == 1)
	{
		VERIFY(!CWinThread::OnIdle(lCount));
	}
	return lCount < 1;  // more to do if lCount < 1
}

/////////////////////////////////////////////////////////////////////////////
// CWinApp idle processing

void CWinApp::DevModeChange(_In_z_ LPTSTR lpDeviceName)
{
	if (m_hDevNames == NULL)
		return;

	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(m_hDevNames);
	ASSERT(lpDevNames != NULL);
	if (lstrcmp((LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
		lpDeviceName) == 0)
	{
		HANDLE hPrinter;
		if (!OpenPrinter(lpDeviceName, &hPrinter, NULL))
			return;

		// DEVMODE changed for the current printer
		if (m_hDevMode != NULL)
			AfxGlobalFree(m_hDevMode);

		// A zero for last param returns the size of buffer needed.
		int nSize = DocumentProperties(NULL, hPrinter, lpDeviceName,
			NULL, NULL, 0);
		ASSERT(nSize >= 0);
		m_hDevMode = GlobalAlloc(GHND, nSize);
		LPDEVMODE lpDevMode = (LPDEVMODE)GlobalLock(m_hDevMode);

		// Fill in the rest of the structure.
		if (DocumentProperties(NULL, hPrinter, lpDeviceName, lpDevMode,
			NULL, DM_OUT_BUFFER) != IDOK)
		{
			AfxGlobalFree(m_hDevMode);
			m_hDevMode = NULL;
		}
		ClosePrinter(hPrinter);
	}
}

///////////////////////////////////////////////////////////////////////////
// CWinApp diagnostics

#ifdef _DEBUG
void CWinApp::AssertValid() const
{
	CWinThread::AssertValid();

	ASSERT(afxCurrentWinApp == this);
	ASSERT(afxCurrentInstanceHandle == m_hInstance);

	if (AfxGetThread() != (CWinThread*)this)
		return;     // only do subset if called from different thread

	if (m_pDocManager != NULL)
		ASSERT_VALID(m_pDocManager);
}

void CWinApp::Dump(CDumpContext& dc) const
{
	CWinThread::Dump(dc);

	dc << "m_hInstance = " << (void*)m_hInstance;
	dc << "\nm_lpCmdLine = " << m_lpCmdLine;
	dc << "\nm_nCmdShow = " << m_nCmdShow;
	dc << "\nm_pszAppName = " << m_pszAppName;
	dc << "\nm_bHelpMode = " << m_bHelpMode;
	dc << "\nm_pszExeName = " << m_pszExeName;
	dc << "\nm_pszHelpFilePath = " << m_pszHelpFilePath;
	dc << "\nm_pszProfileName = " << m_pszProfileName;
	dc << "\nm_hDevMode = " << (void*)m_hDevMode;
	dc << "\nm_hDevNames = " << (void*)m_hDevNames;
	dc << "\nm_dwPromptContext = " << m_dwPromptContext;
	dc << "\nm_eHelpType = " << m_eHelpType;

	if (m_pRecentFileList != NULL)
	{
		dc << "\nm_strRecentFiles[] = ";
		int nSize = m_pRecentFileList->GetSize();
		for (int i = 0; i < nSize; i++)
		{
			if ((*m_pRecentFileList)[i].GetLength() != 0)
				dc << "\n\tFile: " << (*m_pRecentFileList)[i];
		}
	}

	if (m_pDocManager != NULL)
		m_pDocManager->Dump(dc);

	dc << "\nm_nWaitCursorCount = " << m_nWaitCursorCount;
	dc << "\nm_hcurWaitCursorRestore = " << (void*)m_hcurWaitCursorRestore;
	dc << "\nm_nNumPreviewPages = " << m_nNumPreviewPages;

	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	dc << "\nm_msgCur = {";
	dc << "\n\thwnd = " << (void*)pState->m_msgCur.hwnd;
	dc << "\n\tmessage = " << (UINT)pState->m_msgCur.message;
	dc << "\n\twParam = " << (UINT)pState->m_msgCur.wParam;
	dc << "\n\tlParam = " << (void*)pState->m_msgCur.lParam;
	dc << "\n\ttime = " << pState->m_msgCur.time;
	dc << "\n\tpt = " << CPoint(pState->m_msgCur.pt);
	dc << "\n}";

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CWinApp, CWinThread)

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_WIN_STATE, _afxWinState)

/////////////////////////////////////////////////////////////////////////////
///////
///////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\arcex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

#ifdef _DEBUG
// character strings to use for dumping CArchiveException
static const LPCSTR rgszCArchiveExceptionCause[] =
{
	"none",
	"generic",
	"readOnly",
	"endOfFile",
	"writeOnly",
	"badIndex",
	"badClass",
	"badSchema",
	"bufferFull",
};
static const char szUnknown[] = "unknown";
#endif

BOOL CArchiveException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));
	if (lpszError == NULL)
		return FALSE;

	if (pnHelpContext != NULL)
		*pnHelpContext = m_cause + AFX_IDP_ARCH_NONE;

	// we can use CString here; archive errors aren't caused
	// by being out of memory.

	TRY
	{
		CString strMessage;
		CString strFileName = m_strFileName;
		if (strFileName.IsEmpty())
			strFileName.LoadString(AFX_IDS_UNNAMED_FILE);
		AfxFormatString1(strMessage,
			m_cause + AFX_IDP_ARCH_NONE, strFileName);
		Checked::tcsncpy_s(lpszError, nMaxError, strMessage, _TRUNCATE);
	}
	CATCH_ALL( pEx )
	{
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CArchiveException

#ifdef _DEBUG
void CArchiveException::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << " m_cause = ";
	if (m_cause >= 0 && m_cause < _countof(rgszCArchiveExceptionCause))
		dc << rgszCArchiveExceptionCause[m_cause];
	else
		dc << szUnknown;

	dc << "\n";
}
#endif //_DEBUG

void __declspec(noreturn) AFXAPI AfxThrowArchiveException(int cause,
	LPCTSTR lpszArchiveName /* = NULL */)
{
#ifdef _DEBUG
	LPCSTR lpsz;
	if (cause >= 0 && cause < _countof(rgszCArchiveExceptionCause))
		lpsz = rgszCArchiveExceptionCause[cause];
	else
		lpsz = szUnknown;
	TRACE(traceAppMsg, 0, "CArchive exception: %hs.\n", lpsz);

#endif //_DEBUG

	THROW(new CArchiveException(cause, lpszArchiveName));
}


IMPLEMENT_DYNAMIC(CArchiveException, CException)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appui.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



/////////////////////////////////////////////////////////////////////////////
// CWinApp User Interface Extensions

void CWinApp::OnAppExit()
{
	// same as double-clicking on main window close box
	ASSERT(m_pMainWnd != NULL);
	m_pMainWnd->SendMessage(WM_CLOSE);
}


void CWinApp::HideApplication()
{
	ASSERT_VALID(m_pMainWnd);

	// hide the application's windows before closing all the documents
	m_pMainWnd->ShowWindow(SW_HIDE);
	m_pMainWnd->ShowOwnedPopups(FALSE);

	// put the window at the bottom of zorder, so it isn't activated
	m_pMainWnd->SetWindowPos(&CWnd::wndBottom, 0, 0, 0, 0,
		SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
}

void CWinApp::DoWaitCursor(int nCode)
{
	// 0 => restore, 1=> begin, -1=> end
	ENSURE_ARG(nCode == 0 || nCode == 1 || nCode == -1);
	ENSURE(afxData.hcurWait != NULL);
	AfxLockGlobals(CRIT_WAITCURSOR);
	m_nWaitCursorCount += nCode;
	if (m_nWaitCursorCount > 0)
	{
		HCURSOR hcurPrev = ::SetCursor(afxData.hcurWait);
		if (nCode > 0 && m_nWaitCursorCount == 1)
			m_hcurWaitCursorRestore = hcurPrev;
	}
	else
	{
		// turn everything off
		m_nWaitCursorCount = 0;     // prevent underflow
		::SetCursor(m_hcurWaitCursorRestore);
	}
	AfxUnlockGlobals(CRIT_WAITCURSOR);
}


BOOL CWinApp::SaveAllModified()
{
	if (m_pDocManager != NULL)
		return m_pDocManager->SaveAllModified();
	return TRUE;
}

void CWinApp::AddToRecentFileList(LPCTSTR lpszPathName)
{
	ASSERT_VALID(this);
	ENSURE_ARG(lpszPathName != NULL);
	ASSERT(AfxIsValidString(lpszPathName));
	
	if (m_pRecentFileList != NULL)
	{
#if (WINVER >= 0x0601)
		m_pRecentFileList->Add(lpszPathName, m_pszAppID);
#else
		m_pRecentFileList->Add(lpszPathName);
#endif
	}
}

CDocument* CWinApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
	ENSURE_VALID(m_pDocManager);
	return m_pDocManager->OpenDocumentFile(lpszFileName);
}

CDocument* CWinApp::OpenDocumentFile(LPCTSTR lpszFileName, BOOL bAddToMRU)
{
	ENSURE_VALID(m_pDocManager);
	return m_pDocManager->OpenDocumentFile(lpszFileName, bAddToMRU);
}

void CWinApp::CloseAllDocuments(BOOL bEndSession)
{
	if (m_pDocManager != NULL)
		m_pDocManager->CloseAllDocuments(bEndSession);
}

/////////////////////////////////////////////////////////////////////////////
// MRU file list default implementation

void CWinApp::OnUpdateRecentFileMenu(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	ENSURE_ARG(pCmdUI != NULL);
	if (m_pRecentFileList == NULL) // no MRU files
		pCmdUI->Enable(FALSE);
	else
		m_pRecentFileList->UpdateMenu(pCmdUI);
}

/////////////////////////////////////////////////////////////////////////////
// DDE and ShellExecute support

BOOL CWinApp::OnDDECommand(_In_z_ LPTSTR lpszCommand)
{
	if (m_pDocManager != NULL)
		return m_pDocManager->OnDDECommand(lpszCommand);
	else
		return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// MRU file list default implementation

BOOL g_bRemoveFromMRU;

BOOL CWinApp::OnOpenRecentFile(UINT nID)
{
	ASSERT_VALID(this);
	ENSURE(m_pRecentFileList != NULL);

	ENSURE_ARG(nID >= ID_FILE_MRU_FILE1);
	ENSURE_ARG(nID < ID_FILE_MRU_FILE1 + (UINT)m_pRecentFileList->GetSize());
	int nIndex = nID - ID_FILE_MRU_FILE1;
	ASSERT((*m_pRecentFileList)[nIndex].GetLength() != 0);

	TRACE(traceAppMsg, 0, _T("MRU: open file (%d) '%s'.\n"), (nIndex) + 1,
			(LPCTSTR)(*m_pRecentFileList)[nIndex]);

	g_bRemoveFromMRU = TRUE;
	if (OpenDocumentFile((*m_pRecentFileList)[nIndex]) == NULL)
	{
		if (g_bRemoveFromMRU)
		{
			m_pRecentFileList->Remove(nIndex);
		}
	}
	g_bRemoveFromMRU = TRUE;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\arcobj.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// Archive support for polymorphic reading/writing of CObjects

// Note: Starting with MFC 4.0, the file format written/read has been
//  extended to eliminate the previous 32k limit.  Files previously written
//  can still be read by old versions (even 16-bit versions).  In addition,
//  new files, unless they are large enough to take advantage of 32-bit tags,
//  can be read by old versions.

// Pointer mapping constants
#define wNullTag        ((WORD)0)           // special tag indicating NULL ptrs
#define wNewClassTag    ((WORD)0xFFFF)      // special tag indicating new CRuntimeClass
#define wClassTag       ((WORD)0x8000)      // 0x8000 indicates class tag (OR'd)
#define dwBigClassTag   ((DWORD)0x80000000) // 0x8000000 indicates big class tag (OR'd)
#define wBigObjectTag   ((WORD)0x7FFF)      // 0x7FFF indicates DWORD object tag
#define nMaxMapCount    ((DWORD)0x3FFFFFFE) // 0x3FFFFFFE last valid mapCount

// Note: tag value 0x8000 could be used for something in the future, since
//  it is currently an invalid tag (0x8000 means zero wClassTag, but zero
//  index is always reserved for a NULL pointer, and a NULL runtime class
//  does not make any sense).

// This is how the tags have been allocated currently:
//
//  0x0000              represents NULL pointer
//  0x0001 - 0x7FFE     "small" object tags
//  0x7FFF              header for "big" object/class tag
//  0x8000              reserved for future use
//  0x8001 - 0xFFFE     "small" class tag
//  0xFFFF              header for class definition
//
// The special value of 0x7FFF indicates that a DWORD tag follows.  This
// two part "big" tag is used for 32-bit tag values 0x7FFF and above.
// The tag value of 0x7FFF was unused in MFC versions prior to MFC 4.0.

////////////////////////////////////////////////////////////////////////////

void CArchive::CheckCount()
{
	if (m_nMapCount >= nMaxMapCount)
		AfxThrowArchiveException(CArchiveException::badIndex, m_strFileName);
}

//
// Helper function to make sure m_pSchemaMap is created, and the object
// with the designated ref is pointing to the object type array.
//
void CArchive::EnsureSchemaMapExists(CArray<LoadArrayObjType, const LoadArrayObjType&>** ppObjTypeArray)
{
	CMapPtrToPtr* pSchemaMap = m_pSchemaMap;
	CArray<LoadArrayObjType>* pObjTypeArray = NULL;
	void* pTemp = NULL;

	// Ensure schema map exists
	if (NULL == pSchemaMap)
	{
		pSchemaMap = new CMapPtrToPtr;
	}

	// Ensure schema map is initialized
	if (pSchemaMap->Lookup( 
			reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
			pTemp ))
	{
		pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
	}
	else
	{
		// initialize the object type array
		pObjTypeArray = new CArray<LoadArrayObjType>;

		// When memory is exhausted SetSize will raise exception.
		TRY
		{
			pObjTypeArray->SetSize(1, m_nGrowSize);
			pSchemaMap->SetAt(
				reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
				static_cast<void*>(pObjTypeArray));
		}
		CATCH_ALL(e)
		{
			delete pObjTypeArray;
			pObjTypeArray = NULL;
		}
		END_CATCH_ALL
	}

	// Set the target variables
	m_pSchemaMap = pSchemaMap;
	if( NULL != ppObjTypeArray )
	{
		*ppObjTypeArray = pObjTypeArray;
	}
}


void CArchive::WriteObject(const CObject* pOb)
{
	// object can be NULL

	ASSERT(IsStoring());    // proper direction

	if (!IsStoring()) 
	{
		AfxThrowArchiveException(CArchiveException::readOnly, m_strFileName);
	}

	DWORD nObIndex;
	ASSERT(sizeof(nObIndex) == 4);
	ASSERT(sizeof(wNullTag) == 2);
	ASSERT(sizeof(wBigObjectTag) == 2);
	ASSERT(sizeof(wNewClassTag) == 2);

	// make sure m_pStoreMap is initialized
	MapObject(NULL);

	if (pOb == NULL)
	{
		// save out null tag to represent NULL pointer
		*this << wNullTag;
	}
	else if ((nObIndex = (DWORD)(DWORD_PTR)(*m_pStoreMap)[(void*)pOb]) != 0)
		// assumes initialized to 0 map
	{
		// save out index of already stored object
		if (nObIndex < wBigObjectTag)
			*this << (WORD)nObIndex;
		else
		{
			*this << wBigObjectTag;
			*this << nObIndex;
		}
	}
	else
	{
		// write class of object first
		CRuntimeClass* pClassRef = pOb->GetRuntimeClass();
		WriteClass(pClassRef);

		// enter in stored object table, checking for overflow
		CheckCount();
		(*m_pStoreMap)[(void*)pOb] = (void*)(DWORD_PTR)m_nMapCount++;

		// cause the object to serialize itself
		((CObject*)pOb)->Serialize(*this);
	}
}

CObject* CArchive::ReadObject(const CRuntimeClass* pClassRefRequested)
{
	ASSERT(pClassRefRequested == NULL ||
		AfxIsValidAddress(pClassRefRequested, sizeof(CRuntimeClass), FALSE));
	ASSERT(IsLoading());    // proper direction
	ASSERT(wNullTag == 0);
	ASSERT((wClassTag << 16) == dwBigClassTag);
	ASSERT((wNewClassTag & wClassTag) == wClassTag);

	if (!IsLoading()) 
	{
		AfxThrowArchiveException(CArchiveException::writeOnly, m_strFileName);
	}

	// attempt to load next stream as CRuntimeClass
	UINT nSchema;
	DWORD obTag;
	CRuntimeClass* pClassRef = ReadClass(pClassRefRequested, &nSchema, &obTag);

	// check to see if tag to already loaded object
	CObject* pOb=NULL;
	if (pClassRef == NULL)
	{
		if (obTag > (DWORD)m_pLoadArray->GetUpperBound())
		{
			// tag is too large for the number of objects read so far
			AfxThrowArchiveException(CArchiveException::badIndex,
				m_strFileName);
		}

		LoadArrayObjType eType = typeUndefined;
		void* pTemp = NULL;

		if (m_pSchemaMap->Lookup( 
				reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
				pTemp ))
		{
			CArray<LoadArrayObjType>* pTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
			ENSURE( pTypeArray );
			if (obTag <= (DWORD)pTypeArray->GetUpperBound())
			{
				eType = pTypeArray->GetAt(obTag);
			}
		}

		// typeUndefined is acceptable since the user might have added objects
		// to m_pLoadArray without updating the object type array.
		if (eType == typeCRuntimeClass)
		{
			AfxThrowArchiveException(CArchiveException::badIndex,
				m_strFileName);
		}

		pOb = (CObject*)m_pLoadArray->GetAt(obTag);
		if (pOb != NULL && pClassRefRequested != NULL &&
			 !pOb->IsKindOf(pClassRefRequested))
		{
			// loaded an object but of the wrong class
			AfxThrowArchiveException(CArchiveException::badClass,
				m_strFileName);
		}
	}
	else
	{
		TRY
		{
			// allocate a new object based on the class just acquired
			pOb = pClassRef->CreateObject();
		 	if (pOb == NULL)
				AfxThrowMemoryException();

			// Add to mapping array BEFORE de-serializing
			CheckCount();

			m_pLoadArray->InsertAt(m_nMapCount, pOb);

			void* pTemp = NULL;
			m_pSchemaMap->Lookup( 
				reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
				pTemp );
			CArray<LoadArrayObjType>* pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
			ENSURE( pObjTypeArray );

			pObjTypeArray->InsertAt(m_nMapCount, typeCObject);
			m_nMapCount++;

			// Serialize the object with the schema number set in the archive
			UINT nSchemaSave = m_nObjectSchema;
			m_nObjectSchema = nSchema;
			pOb->Serialize(*this);
			m_nObjectSchema = nSchemaSave;
			ASSERT_VALID(pOb);
		}
		CATCH_ALL(e)
		{
			if(pOb!=NULL)
			{
				delete pOb;
				pOb=NULL;
			}
			THROW_LAST();
		}
		END_CATCH_ALL
	}

	return pOb;
}

/////////////////////////////////////////////////////////////////////////////
// advanced versioning and back-pointer support

UINT CArchive::GetObjectSchema()
{
	UINT nResult = m_nObjectSchema;
	m_nObjectSchema = (UINT)-1; // can only be called once per Serialize
	return nResult;
}

void CArchive::MapObject(const CObject* pOb)
{
	if (IsStoring())
	{
		if (m_pStoreMap == NULL)
		{
			// initialize the storage map
			//  (use CMapPtrToPtr because it is used for HANDLE maps too)
			m_pStoreMap = new CMapPtrToPtr(m_nGrowSize);
			m_pStoreMap->InitHashTable(m_nHashSize);
			m_pStoreMap->SetAt(NULL, (void*)(DWORD_PTR)wNullTag);
			m_nMapCount = 1;
		}
		if (pOb != NULL)
		{
			CheckCount();
			(*m_pStoreMap)[(void*)pOb] = (void*)(DWORD_PTR)m_nMapCount++;
		}
	}
	else
	{
		if (m_pLoadArray == NULL)
		{
			// initialize the loaded object pointer array and set special values
			m_pLoadArray = new CPtrArray;
			m_pLoadArray->SetSize(1, m_nGrowSize);
			ASSERT(wNullTag == 0);
			m_pLoadArray->SetAt(wNullTag, NULL);
			m_nMapCount = 1;

			CArray<LoadArrayObjType>* pObjTypeArray = NULL;
			EnsureSchemaMapExists(&pObjTypeArray);
			pObjTypeArray->InsertAt(wNullTag, typeUndefined);
		}
		if (pOb != NULL)
		{
			CheckCount();
			m_pLoadArray->InsertAt(m_nMapCount, (void*)pOb);

			void* pTemp = NULL;
			m_pSchemaMap->Lookup( 
				reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
				pTemp );
			CArray<LoadArrayObjType>* pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
			ENSURE( pObjTypeArray );
			pObjTypeArray->InsertAt(m_nMapCount, typeCObject);

			m_nMapCount++;
		}
	}
}

void CArchive::WriteClass(const CRuntimeClass* pClassRef)
{
	ASSERT(pClassRef != NULL);
	ASSERT(IsStoring());    // proper direction

	if (pClassRef == NULL) 
	{
		AfxThrowArchiveException(CArchiveException::badClass, m_strFileName);
	}

	if (!IsStoring()) 
	{
		AfxThrowArchiveException(CArchiveException::genericException, m_strFileName);
	}

	if (pClassRef->m_wSchema == 0xFFFF)
	{
		TRACE(traceAppMsg, 0, "Warning: Cannot call WriteClass/WriteObject for %hs.\n",
			pClassRef->m_lpszClassName);
		AfxThrowNotSupportedException();
	}

	// make sure m_pStoreMap is initialized
	MapObject(NULL);

	// write out class id of pOb, with high bit set to indicate
	// new object follows

	// ASSUME: initialized to 0 map
	DWORD nClassIndex;
	if ((nClassIndex = (DWORD)(DWORD_PTR)(*m_pStoreMap)[(void*)pClassRef]) != 0)
	{
		// previously seen class, write out the index tagged by high bit
		if (nClassIndex < wBigObjectTag)
			*this << (WORD)(wClassTag | nClassIndex);
		else
		{
			*this << wBigObjectTag;
			*this << (dwBigClassTag | nClassIndex);
		}
	}
	else
	{
		// store new class
		*this << wNewClassTag;
		pClassRef->Store(*this);

		// store new class reference in map, checking for overflow
		CheckCount();
		(*m_pStoreMap)[(void*)pClassRef] = (void*)(DWORD_PTR)m_nMapCount++;
	}
}

CRuntimeClass* CArchive::ReadClass(const CRuntimeClass* pClassRefRequested,
	UINT* pSchema, DWORD* pObTag)
{
	ASSERT(pClassRefRequested == NULL ||
		AfxIsValidAddress(pClassRefRequested, sizeof(CRuntimeClass), FALSE));
	ASSERT(IsLoading());    // proper direction

	if (!IsLoading()) 
	{
		AfxThrowArchiveException(CArchiveException::genericException, m_strFileName);
	}

	if (pClassRefRequested != NULL && pClassRefRequested->m_wSchema == 0xFFFF)
	{
		TRACE(traceAppMsg, 0, "Warning: Cannot call ReadClass/ReadObject for %hs.\n",
			pClassRefRequested->m_lpszClassName);
		AfxThrowNotSupportedException();
	}

	// make sure m_pLoadArray is initialized
	MapObject(NULL);

	// read object tag - if prefixed by wBigObjectTag then DWORD tag follows
	DWORD obTag;
	WORD wTag;
	*this >> wTag;
	if (wTag == wBigObjectTag)
		*this >> obTag;
	else
		obTag = ((wTag & wClassTag) << 16) | (wTag & ~wClassTag);

	// check for object tag (throw exception if expecting class tag)
	if (!(obTag & dwBigClassTag))
	{
		if (pObTag == NULL)
			AfxThrowArchiveException(CArchiveException::badIndex, m_strFileName);

		*pObTag = obTag;
		return NULL;
	}

	CRuntimeClass* pClassRef;
	UINT nSchema;
	if (wTag == wNewClassTag)
	{
		// new object follows a new class id
		if ((pClassRef = CRuntimeClass::Load(*this, &nSchema)) == NULL)
			AfxThrowArchiveException(CArchiveException::badClass, m_strFileName);

		// check nSchema against the expected schema
		if ((pClassRef->m_wSchema & ~VERSIONABLE_SCHEMA) != nSchema)
		{
			if (!(pClassRef->m_wSchema & VERSIONABLE_SCHEMA))
			{
				// schema doesn't match and not marked as VERSIONABLE_SCHEMA
				AfxThrowArchiveException(CArchiveException::badSchema,
					m_strFileName);
			}
			else
			{
				// they differ -- store the schema for later retrieval
				EnsureSchemaMapExists();
				ASSERT_VALID(m_pSchemaMap);
				m_pSchemaMap->SetAt(pClassRef, (void*)(DWORD_PTR)nSchema);
			}
		}
		CheckCount();
		m_pLoadArray->InsertAt(m_nMapCount, pClassRef);

		void* pTemp = NULL;
		m_pSchemaMap->Lookup( 
			reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
			pTemp );
		CArray<LoadArrayObjType>* pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
		ENSURE( pObjTypeArray );

		pObjTypeArray->InsertAt(m_nMapCount, typeCRuntimeClass);
		m_nMapCount++;
	}
	else
	{
		// existing class index in obTag followed by new object
		DWORD nClassIndex = (obTag & ~dwBigClassTag);
		if (nClassIndex == 0 || nClassIndex > (DWORD)m_pLoadArray->GetUpperBound())
			AfxThrowArchiveException(CArchiveException::badIndex,
				m_strFileName);

		void* pTemp = NULL;
		m_pSchemaMap->Lookup( 
			reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
			pTemp );
		CArray<LoadArrayObjType>* pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
		ENSURE( pObjTypeArray );

		// typeUndefined is acceptable here since the user might have added 
		// objects to m_pLoadArray without updating the object type array.
		if (typeCObject == (LoadArrayObjType)pObjTypeArray->GetAt(nClassIndex))
		{
			AfxThrowArchiveException(CArchiveException::badIndex,
				m_strFileName);
		}

		pClassRef = (CRuntimeClass*)m_pLoadArray->GetAt(nClassIndex);
		ASSERT(pClassRef != NULL);

		// determine schema stored against objects of this type
		BOOL bFound = FALSE;
		nSchema = 0;
		if (m_pSchemaMap != NULL)
		{
			bFound = m_pSchemaMap->Lookup( pClassRef, pTemp );
			if (bFound)
				nSchema = (UINT)(UINT_PTR)pTemp;
		}
		if (!bFound)
			nSchema = pClassRef->m_wSchema & ~VERSIONABLE_SCHEMA;
   }

	// check for correct derivation
	if (pClassRefRequested != NULL &&
		!pClassRef->IsDerivedFrom(pClassRefRequested))
	{
		AfxThrowArchiveException(CArchiveException::badClass, m_strFileName);
	}

	// store nSchema for later examination
	if (pSchema != NULL)
		*pSchema = nSchema;
	else
		m_nObjectSchema = nSchema;

	// store obTag for later examination
	if (pObTag != NULL)
		*pObTag = obTag;

	// return the resulting CRuntimeClass*
	return pClassRef;
}

void CArchive::SerializeClass(const CRuntimeClass* pClassRef)
{
	if (IsStoring())
		WriteClass(pClassRef);
	else
		ReadClass(pClassRef);
}

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appterm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <ddeml.h> // for MSGF_DDEMGR



/////////////////////////////////////////////////////////////////////////////
// other globals (internal library use)

/////////////////////////////////////////////////////////////////////////////
// Standard cleanup called by WinMain and AfxAbort

void AFXAPI AfxUnregisterWndClasses()
{
	// unregister Window classes
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_REGCLASSLIST);
	int start=0;
	CString className = pModuleState->m_strUnregisterList.Tokenize(_T("\n"),start);
	while (!className.IsEmpty())
	{
		UnregisterClass(static_cast<LPCTSTR>(className), AfxGetInstanceHandle());
		className = pModuleState->m_strUnregisterList.Tokenize(_T("\n"),start);
	}
	pModuleState->m_strUnregisterList.Empty();
	AfxUnlockGlobals(CRIT_REGCLASSLIST);

}
void AFXAPI AfxWinTerm(void)
{	
	AfxUnregisterWndClasses();
	// cleanup OLE if required
	CWinThread* pThread = AfxGetApp();
	if (pThread != NULL && pThread->m_lpfnOleTermOrFreeLib != NULL)
		(*pThread->m_lpfnOleTermOrFreeLib)(TRUE, FALSE);

	// cleanup thread local tooltip window
	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	if (pModuleThreadState->m_pToolTip != NULL)
	{
		if (pModuleThreadState->m_pToolTip->DestroyToolTipCtrl())
			pModuleThreadState->m_pToolTip = NULL;
	}

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (!afxContextIsDLL)
	{
		// unhook windows hooks
		if (pThreadState->m_hHookOldMsgFilter != NULL)
		{
			::UnhookWindowsHookEx(pThreadState->m_hHookOldMsgFilter);
			pThreadState->m_hHookOldMsgFilter = NULL;
		}
		if (pThreadState->m_hHookOldCbtFilter != NULL)
		{
			::UnhookWindowsHookEx(pThreadState->m_hHookOldCbtFilter);
			pThreadState->m_hHookOldCbtFilter = NULL;
		}
	}
    // We used to suppress all exceptions here. But that's the wrong thing
    // to do. If this process crashes, we should allow Windows to crash
    // the process and invoke watson.
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appui1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// CWinApp UI related functions

void CWinApp::EnableModeless(BOOL bEnable)
{
    DoEnableModeless(bEnable);
}

void CWinApp::DoEnableModeless(BOOL bEnable)
{
#ifdef _AFX_NO_OLE_SUPPORT
	UNUSED(bEnable);
#endif

	// no-op if main window is NULL or not a CFrameWnd
	CWnd* pMainWnd = AfxGetMainWnd();
	if (pMainWnd == NULL || !pMainWnd->IsFrameWnd())
		return;

#ifndef _AFX_NO_OLE_SUPPORT
	// check if notify hook installed
	ASSERT_KINDOF(CFrameWnd, pMainWnd);
	CFrameWnd* pFrameWnd = (CFrameWnd*)pMainWnd;
	if (pFrameWnd->m_pNotifyHook != NULL)
		pFrameWnd->m_pNotifyHook->OnEnableModeless(bEnable);
#endif
}

int CWinApp::DoMessageBox(LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt)
{
    return ShowAppMessageBox(this, lpszPrompt, nType, nIDPrompt);
}

// Helper for message boxes; can work when no CWinApp can be found
int CWinApp::ShowAppMessageBox(CWinApp *pApp, LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt)
{
	// disable windows for modal dialog
	DoEnableModeless(FALSE);
	HWND hWndTop;
	HWND hWnd = CWnd::GetSafeOwner_(NULL, &hWndTop);

	// re-enable the parent window, so that focus is restored 
	// correctly when the dialog is dismissed.
	if (hWnd != hWndTop)
		EnableWindow(hWnd, TRUE);

	// set help context if possible
	DWORD* pdwContext = NULL;

	DWORD dwWndPid=0;
	GetWindowThreadProcessId(hWnd,&dwWndPid);

	if (hWnd != NULL && dwWndPid==GetCurrentProcessId() )
	{
		// use app-level context or frame level context
		LRESULT lResult = ::SendMessage(hWnd, WM_HELPPROMPTADDR, 0, 0);
		if (lResult != 0)
			pdwContext = (DWORD*)lResult;
	}
	// for backward compatibility use app context if possible
	if (pdwContext == NULL && pApp != NULL)
		pdwContext = &pApp->m_dwPromptContext;

	DWORD dwOldPromptContext = 0;
	if (pdwContext != NULL)
	{
		// save old prompt context for restoration later
		dwOldPromptContext = *pdwContext;
		if (nIDPrompt != 0)
			*pdwContext = HID_BASE_PROMPT+nIDPrompt;
	}

	// determine icon based on type specified
	if ((nType & MB_ICONMASK) == 0)
	{
		switch (nType & MB_TYPEMASK)
		{
		case MB_OK:
		case MB_OKCANCEL:
			nType |= MB_ICONEXCLAMATION;
			break;

		case MB_YESNO:
		case MB_YESNOCANCEL:
			nType |= MB_ICONQUESTION;
			break;

		case MB_ABORTRETRYIGNORE:
		case MB_RETRYCANCEL:
			// No default icon for these types, since they are rarely used.
			// The caller should specify the icon.
			break;
		}
	}

#ifdef _DEBUG
	if ((nType & MB_ICONMASK) == 0)
		TRACE(traceAppMsg, 0, "Warning: no icon specified for message box.\n");
#endif

	TCHAR szAppName[_MAX_PATH];
	szAppName[0] = '\0';
	LPCTSTR pszAppName;
	if (pApp != NULL)
		pszAppName = pApp->m_pszAppName;
	else
	{
		pszAppName = szAppName;
		DWORD dwLen = GetModuleFileName(NULL, szAppName, _MAX_PATH);
		if (dwLen == _MAX_PATH)
			szAppName[_MAX_PATH - 1] = '\0';
	}

	int nResult =
		::AfxCtxMessageBox(hWnd, lpszPrompt, pszAppName, nType);

	// restore prompt context if possible
	if (pdwContext != NULL)
		*pdwContext = dwOldPromptContext;

	// re-enable windows
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);
	DoEnableModeless(TRUE);

	return nResult;
}

int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType, UINT nIDHelp)
{
	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
    {
		return pApp->DoMessageBox(lpszText, nType, nIDHelp);
    }
	else
    {
		return CWinApp::ShowAppMessageBox(NULL, lpszText, nType, nIDHelp);
    }
}

int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType, UINT nIDHelp)
{
	CString string;
	if (!string.LoadString(nIDPrompt))
	{
		TRACE(traceAppMsg, 0, "Error: failed to load message box prompt string 0x%04x.\n",
			nIDPrompt);
		ASSERT(FALSE);
	}
	if (nIDHelp == (UINT)-1)
		nIDHelp = nIDPrompt;
	return AfxMessageBox(string, nType, nIDHelp);
}

////////////////////////////////////////////////////////////////////////////
// UI related CWnd functions

HWND PASCAL CWnd::GetSafeOwner_(HWND hParent, HWND* pWndTop)
{
	// get window to start with
	HWND hWnd = hParent;
	if (hWnd == NULL)
	{
		CFrameWnd* pFrame = CCmdTarget::GetRoutingFrame_();
		if (pFrame != NULL)
			hWnd = pFrame->GetSafeHwnd();
		else
			hWnd = AfxGetMainWnd()->GetSafeHwnd();
	}

	// a popup window cannot be owned by a child window
	while (hWnd != NULL && (::GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD))
		hWnd = ::GetParent(hWnd);

	// determine toplevel window to disable as well
	HWND hWndTop = hWnd, hWndTemp = hWnd;
	for (;;)
	{
		if (hWndTemp == NULL)
			break;
		else
			hWndTop = hWndTemp;
		hWndTemp = ::GetParent(hWndTop);
	}

	// get last active popup of first non-child that was found
	if (hParent == NULL && hWnd != NULL)
		hWnd = ::GetLastActivePopup(hWnd);

	// disable and store top level parent window if specified
	if (pWndTop != NULL)
	{
		if (hWndTop != NULL && ::IsWindowEnabled(hWndTop) && hWndTop != hWnd)
		{
			*pWndTop = hWndTop;
			::EnableWindow(hWndTop, FALSE);
		}
		else
			*pWndTop = NULL;
	}

	return hWnd;    // return the owner as HWND
}

/////////////////////////////////////////////////////////////////////////////
// UI related CCmdTarget functions

CView* PASCAL CCmdTarget::GetRoutingView_()
{
	CView* pView = AfxGetThreadState()->m_pRoutingView;
	return pView;
}

CFrameWnd* PASCAL CCmdTarget::GetRoutingFrame_()
{
	CFrameWnd* pFrame = AfxGetThreadState()->m_pRoutingFrame;
	return pFrame;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appui2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// DDE and ShellExecute support

BOOL CWinApp::ProcessShellCommand(CCommandLineInfo& rCmdInfo)
{
	BOOL bResult = TRUE;
	switch (rCmdInfo.m_nShellCommand)
	{
	case CCommandLineInfo::RestartByRestartManager:
		// Re-register with the restart manager using the restart identifier from the command line
		RegisterWithRestartManager(SupportsApplicationRecovery(), rCmdInfo.m_strRestartIdentifier);

		// Call RestartIntance, which should reopen any previously opened document(s) and
		// optionally load the autosaved versions after querying the user about loading.
		if (RestartInstance())
			break;
		// If RestartInstance returns FALSE, then fall through to FileNew case, so
		// a new document is created--otherwise the main frame will not be created.

	case CCommandLineInfo::FileNew:
		if (!AfxGetApp()->OnCmdMsg(ID_FILE_NEW, 0, NULL, NULL))
			OnFileNew();
		if (m_pMainWnd == NULL)
			bResult = FALSE;
		break;

	// If we've been asked to open a file, call OpenDocumentFile()
	case CCommandLineInfo::FileOpen:
		if (!OpenDocumentFile(rCmdInfo.m_strFileName))
			bResult = FALSE;
		break;

	// If the user wanted to print, hide our main window and
	// fire a message to ourselves to start the printing
	case CCommandLineInfo::FilePrintTo:
	case CCommandLineInfo::FilePrint:
		m_nCmdShow = SW_HIDE;
		ASSERT(m_pCmdInfo == NULL);
		if(OpenDocumentFile(rCmdInfo.m_strFileName))
		{
			m_pCmdInfo = &rCmdInfo;
			ENSURE_VALID(m_pMainWnd);
			m_pMainWnd->SendMessage(WM_COMMAND, ID_FILE_PRINT_DIRECT);
			m_pCmdInfo = NULL;
		}
		bResult = FALSE;
		break;

	// If we're doing DDE print or print to, start up without a new document and hide ourselves
	case CCommandLineInfo::FileDDENoShow:
		m_pCmdInfo = (CCommandLineInfo*)(UINT_PTR)m_nCmdShow;
		m_nCmdShow = SW_HIDE;
		break;

	// If we're doing DDE open, start up without a new document, but don't hide ourselves -- this causes the
	// icon in the Windows 7 taskbar to start in the wrong position and slide into the right position.
	case CCommandLineInfo::FileDDE:
		break;

	// If we've been asked to register, exit without showing UI.
	// Registration was already done in InitInstance().
	case CCommandLineInfo::AppRegister:
		{
			Register();			
			bResult = FALSE;    // that's all we do

			// If nobody is using it already, we can use it.
			// We'll flag that we're unregistering and not save our state
			// on the way out. This new object gets deleted by the
			// app object destructor.

			if (m_pCmdInfo == NULL)
			{
				m_pCmdInfo = new CCommandLineInfo;
				m_pCmdInfo->m_nShellCommand = CCommandLineInfo::AppUnregister;
			}
			break;
		}

	// If we've been asked to unregister, unregister and then terminate
	case CCommandLineInfo::AppUnregister:
		{
			BOOL bUnregistered = Unregister();

			if (!rCmdInfo.m_bRunEmbedded)
			{
				if (bUnregistered)
					AfxMessageBox(AFX_IDP_UNREG_DONE);
				else
					AfxMessageBox(AFX_IDP_UNREG_FAILURE);
			}
			bResult = FALSE;    // that's all we do

			// If nobody is using it already, we can use it.
			// We'll flag that we're unregistering and not save our state
			// on the way out. This new object gets deleted by the
			// app object destructor.

			if (m_pCmdInfo == NULL)
			{
				m_pCmdInfo = new CCommandLineInfo;
				m_pCmdInfo->m_nShellCommand = CCommandLineInfo::AppUnregister;
			}
		}
		break;
	}
	return bResult;
}

void CWinApp::InitLibId()
{
}

BOOL CWinApp::Register()
{
	return TRUE;
}

BOOL CWinApp::Unregister()
{
	HKEY    hKey = 0;
	TCHAR   szBuf[_MAX_PATH+1];
	LONG    cSize = 0;
	BOOL    bRet = TRUE;

	POSITION pos = GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		CDocTemplate* pTempl = GetNextDocTemplate(pos);
		if (pTempl != NULL)
			pTempl->OnCmdMsg(0, CN_OLE_UNREGISTER, NULL, NULL);
	}

	// Remove profile information -- the registry entries exist if
	// SetRegistryKey() was used.

	if (m_pszRegistryKey)
	{
		ENSURE(m_pszProfileName != NULL);

		CString strKey = _T("Software\\");
		strKey += m_pszRegistryKey;
		CString strSubKey = strKey + _T("\\") + m_pszProfileName;

		DelRegTree(HKEY_CURRENT_USER, strSubKey);

		// If registry key is empty then remove it

		DWORD   dwResult;
		if ((dwResult = ::RegOpenKeyEx(HKEY_CURRENT_USER, strKey, 0, KEY_ENUMERATE_SUB_KEYS, &hKey)) ==
			ERROR_SUCCESS)
		{
			if (::RegEnumKey(hKey, 0, szBuf, _MAX_PATH) == ERROR_NO_MORE_ITEMS)
				DelRegTree(HKEY_CURRENT_USER, strKey);
			::RegCloseKey(hKey);
		}
		if (RegQueryValue(HKEY_CURRENT_USER, strSubKey, szBuf, &cSize) == ERROR_SUCCESS)
			bRet = TRUE;
	}
	return bRet;
}

// Under Win32, a reg key may not be deleted unless it is empty.
// Thus, to delete a tree,  one must recursively enumerate and
// delete all of the sub-keys.

LONG CWinApp::DelRegTree(HKEY hParentKey, const CString& strKeyName, CAtlTransactionManager* pTM)
{
	return AfxDelRegTreeHelper(hParentKey, strKeyName, pTM);
}

LONG AFXAPI AfxDelRegTreeHelper(HKEY hParentKey, const CString& strKeyName, CAtlTransactionManager* pTM)
{
	TCHAR   szSubKeyName[MAX_PATH + 1];
	HKEY    hCurrentKey;
	DWORD   dwResult;

	CString strRedirectedKeyName = strKeyName;
	if( ( HKEY_CLASSES_ROOT == hParentKey ) && ( TRUE == AfxGetPerUserRegistration() ) )
	{
		strRedirectedKeyName = _T("Software\\Classes\\") + strRedirectedKeyName;
		hParentKey = HKEY_CURRENT_USER;
	}

	dwResult = pTM != NULL ? 
		pTM->RegOpenKeyEx(hParentKey, strRedirectedKeyName, 0, KEY_WRITE | KEY_READ, &hCurrentKey) : 
		::RegOpenKeyEx(hParentKey, strRedirectedKeyName, 0, KEY_WRITE | KEY_READ, &hCurrentKey);
	if (dwResult == ERROR_SUCCESS)
	{
		// Remove all subkeys of the key to delete
		while ((dwResult = RegEnumKey(hCurrentKey, 0, szSubKeyName, MAX_PATH)) == ERROR_SUCCESS)
		{
			try
			{
				// temp CString constructed from szSubKeyName can throw in Low Memory condition.
				if ((dwResult = AfxDelRegTreeHelper(hCurrentKey, szSubKeyName, pTM)) != ERROR_SUCCESS)
					break;
			}
			catch(CMemoryException* e)
			{
				dwResult = ERROR_NOT_ENOUGH_MEMORY;
				e->Delete();
				break;
			}
		}

		// If all went well, we should now be able to delete the requested key
		if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY))
		{
			dwResult = pTM != NULL ? 
				pTM->RegDeleteKey(hParentKey, strRedirectedKeyName) :
				::RegDeleteKey(hParentKey, strRedirectedKeyName);
		}
		RegCloseKey(hCurrentKey);
	}

	return dwResult;
}

void CWinApp::EnableShellOpen()
{
	ASSERT(m_atomApp == NULL && m_atomSystemTopic == NULL); // do once
	if (m_atomApp != NULL || m_atomSystemTopic != NULL)
	{
		return;
	}

	CString strShortName;
	AfxGetModuleShortFileName(AfxGetInstanceHandle(), strShortName);

	// strip out path
	CString strFileName = ::PathFindFileName(strShortName);
	// strip out extension
	LPTSTR pszFileName = strFileName.GetBuffer();
	::PathRemoveExtension(pszFileName);
	strFileName.ReleaseBuffer();

	m_atomApp = ::GlobalAddAtom(strFileName);
	m_atomSystemTopic = ::GlobalAddAtom(_T("system"));
}

void CWinApp::RegisterShellFileTypes(BOOL bCompat)
{
	ENSURE(m_pDocManager != NULL);
	m_pDocManager->RegisterShellFileTypes(bCompat);
}

void CWinApp::UnregisterShellFileTypes()
{
	ENSURE(m_pDocManager != NULL);
	m_pDocManager->UnregisterShellFileTypes();
}


int CWinApp::GetOpenDocumentCount()
{
	ENSURE(m_pDocManager != NULL);
	return m_pDocManager->GetOpenDocumentCount();
}

/////////////////////////////////////////////////////////////////////////////
// Doc template support


void CWinApp::AddDocTemplate(CDocTemplate* pTemplate)
{
	if (m_pDocManager == NULL)
		m_pDocManager = new CDocManager;
	m_pDocManager->AddDocTemplate(pTemplate);
}

POSITION CWinApp::GetFirstDocTemplatePosition() const
{
	if (m_pDocManager == NULL)
		return NULL;
	return m_pDocManager->GetFirstDocTemplatePosition();
}

CDocTemplate* CWinApp::GetNextDocTemplate(POSITION& rPosition) const
{
	ENSURE(m_pDocManager != NULL);
	return m_pDocManager->GetNextDocTemplate(rPosition);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\appui3.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxglobals.h"


/////////////////////////////////////////////////////////////////////////////
// CWinApp Settings Helpers


void CWinApp::SetRegistryKey(LPCTSTR lpszRegistryKey)
{
	ASSERT(m_pszRegistryKey == NULL);
	ASSERT(lpszRegistryKey != NULL);
	ASSERT(m_pszAppName != NULL);

	BOOL bEnable = AfxEnableMemoryTracking(FALSE);
	free((void*)m_pszRegistryKey);
	m_pszRegistryKey = _tcsdup(lpszRegistryKey);
	free((void*)m_pszProfileName);
	m_pszProfileName = _tcsdup(m_pszAppName);
	AfxEnableMemoryTracking(bEnable);
}

void CWinApp::SetRegistryKey(UINT nIDRegistryKey)
{
	ASSERT(m_pszRegistryKey == NULL);

	TCHAR szRegistryKey[256];
	VERIFY(AfxLoadString(nIDRegistryKey, szRegistryKey));
	SetRegistryKey(szRegistryKey);
}

typedef HRESULT (STDAPICALLTYPE *PFNSETCURRENTPROCESSEXPLICITAPPUSERMODELID)(PCWSTR);
void CWinApp::SetAppID(LPCTSTR lpcszAppID)
{
	HMODULE hShell = GetModuleHandleW(L"Shell32");
	if (hShell == NULL)
	{
		return;
	}

	PFNSETCURRENTPROCESSEXPLICITAPPUSERMODELID pfnSetAppUserModelID = 
		(PFNSETCURRENTPROCESSEXPLICITAPPUSERMODELID)GetProcAddress(hShell, "SetCurrentProcessExplicitAppUserModelID");
	if (pfnSetAppUserModelID == NULL)
	{
		return;
	}

	m_pszAppID = lpcszAppID;

#if(WINVER >= 0x0601)
#ifdef UNICODE
	pfnSetAppUserModelID(lpcszAppID);
#else
	USES_CONVERSION;
	LPCWSTR lpID = A2W(lpcszAppID);
	pfnSetAppUserModelID(lpID);
#endif
#endif
}

// returns key for HKEY_CURRENT_USER\"Software"\RegistryKey\ProfileName
// creating it if it doesn't exist
// responsibility of the caller to call RegCloseKey() on the returned HKEY
HKEY CWinApp::GetAppRegistryKey(CAtlTransactionManager* pTM)
{
	ASSERT(m_pszRegistryKey != NULL);
	ASSERT(m_pszProfileName != NULL);

	HKEY hAppKey = NULL;
	HKEY hSoftKey = NULL;
	HKEY hCompanyKey = NULL;
	
	LSTATUS lStatus = pTM != NULL ? 
		pTM->RegOpenKeyEx(HKEY_CURRENT_USER, _T("software"), 0, KEY_WRITE|KEY_READ, &hSoftKey) :
		::RegOpenKeyEx(HKEY_CURRENT_USER, _T("software"), 0, KEY_WRITE|KEY_READ, &hSoftKey);

	if (lStatus == ERROR_SUCCESS)
	{
		DWORD dw;

		lStatus = pTM != NULL ? 
			pTM->RegCreateKeyEx(hSoftKey, m_pszRegistryKey, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hCompanyKey, &dw) :
			::RegCreateKeyEx(hSoftKey, m_pszRegistryKey, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hCompanyKey, &dw);

		if (lStatus == ERROR_SUCCESS)
		{
			lStatus = pTM != NULL ? 
				pTM->RegCreateKeyEx(hCompanyKey, m_pszProfileName, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hAppKey, &dw) :
				::RegCreateKeyEx(hCompanyKey, m_pszProfileName, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hAppKey, &dw);
		}
	}
	if (hSoftKey != NULL)
		RegCloseKey(hSoftKey);
	if (hCompanyKey != NULL)
		RegCloseKey(hCompanyKey);

	return hAppKey;
}

// returns key for:
//      HKEY_CURRENT_USER\"Software"\RegistryKey\AppName\lpszSection
// creating it if it doesn't exist.
// responsibility of the caller to call RegCloseKey() on the returned HKEY
HKEY CWinApp::GetSectionKey(LPCTSTR lpszSection, CAtlTransactionManager* pTM)
{
	ASSERT(lpszSection != NULL);

	HKEY hSectionKey = NULL;
	HKEY hAppKey = GetAppRegistryKey(pTM);
	if (hAppKey == NULL)
		return NULL;

	DWORD dw;

	if (pTM != NULL)
	{
		pTM->RegCreateKeyEx(hAppKey, lpszSection, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hSectionKey, &dw);
	}
	else
	{
		::RegCreateKeyEx(hAppKey, lpszSection, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_READ, NULL, &hSectionKey, &dw);
	}

	RegCloseKey(hAppKey);
	return hSectionKey;
}

UINT CWinApp::GetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry,
	int nDefault)
{
	ASSERT(lpszSection != NULL);
	ASSERT(lpszEntry != NULL);
	if (m_pszRegistryKey != NULL) // use registry
	{
		HKEY hSecKey = GetSectionKey(lpszSection);
		if (hSecKey == NULL)
			return nDefault;
		DWORD dwValue;
		DWORD dwType;
		DWORD dwCount = sizeof(DWORD);
		LONG lResult = RegQueryValueEx(hSecKey, (LPTSTR)lpszEntry, NULL, &dwType,
			(LPBYTE)&dwValue, &dwCount);
		RegCloseKey(hSecKey);
		if (lResult == ERROR_SUCCESS)
		{
			ASSERT(dwType == REG_DWORD);
			ASSERT(dwCount == sizeof(dwValue));
			return (UINT)dwValue;
		}
		return nDefault;
	}
	else
	{
		ASSERT(m_pszProfileName != NULL);
		return ::GetPrivateProfileInt(lpszSection, lpszEntry, nDefault,
			m_pszProfileName);
	}
}

CString CWinApp::GetProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
	LPCTSTR lpszDefault)
{
	ASSERT(lpszSection != NULL);
	ASSERT(lpszEntry != NULL);
	if (m_pszRegistryKey != NULL)
	{
		HKEY hSecKey = GetSectionKey(lpszSection);
		if (hSecKey == NULL)
			return lpszDefault;
		CString strValue;
		DWORD dwType=REG_NONE;
		DWORD dwCount=0;
		LONG lResult = RegQueryValueEx(hSecKey, (LPTSTR)lpszEntry, NULL, &dwType,
			NULL, &dwCount);
		if (lResult == ERROR_SUCCESS)
		{
			ASSERT(dwType == REG_SZ);
			lResult = RegQueryValueEx(hSecKey, (LPTSTR)lpszEntry, NULL, &dwType,
				(LPBYTE)strValue.GetBuffer(dwCount/sizeof(TCHAR)), &dwCount);
			strValue.ReleaseBuffer();
		}
		RegCloseKey(hSecKey);
		if (lResult == ERROR_SUCCESS)
		{
			ASSERT(dwType == REG_SZ);
			return strValue;
		}
		return lpszDefault;
	}
	else
	{
		ASSERT(m_pszProfileName != NULL);

		if (lpszDefault == NULL)
			lpszDefault = _T("");	// don't pass in NULL
		TCHAR szT[4096];
		DWORD dw = ::GetPrivateProfileString(lpszSection, lpszEntry,
			lpszDefault, szT, _countof(szT), m_pszProfileName);
		ASSERT(dw < 4095);
		return szT;
	}
}

BOOL CWinApp::GetProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
	BYTE** ppData, UINT* pBytes)
{
	ASSERT(lpszSection != NULL);
	ASSERT(lpszEntry != NULL);
	ASSERT(ppData != NULL);
	ASSERT(pBytes != NULL);
	*ppData = NULL;
	*pBytes = 0;
	if (m_pszRegistryKey != NULL)
	{
		HKEY hSecKey = GetSectionKey(lpszSection);
		if (hSecKey == NULL)
		{
			return FALSE;
		}

		// ensure destruction
		::ATL::CRegKey rkSecKey(hSecKey);

		DWORD dwType=0;
		DWORD dwCount=0; 
		LONG lResult = RegQueryValueEx(hSecKey, (LPTSTR)lpszEntry, NULL, &dwType, NULL, &dwCount);
		*pBytes = dwCount;
		if (lResult == ERROR_SUCCESS)
		{
			ASSERT(dwType == REG_BINARY);
			*ppData = new BYTE[*pBytes];
			lResult = RegQueryValueEx(hSecKey, (LPTSTR)lpszEntry, NULL, &dwType,
				*ppData, &dwCount);
		}
		if (lResult == ERROR_SUCCESS)
		{
			ASSERT(dwType == REG_BINARY);
			return TRUE;
		}
		else
		{
			delete [] *ppData;
			*ppData = NULL;
		}
		return FALSE;
	}
	else
	{
		ASSERT(m_pszProfileName != NULL);

		CString str = GetProfileString(lpszSection, lpszEntry, NULL);
		if (str.IsEmpty())
			return FALSE;
		ASSERT(str.GetLength()%2 == 0);
		INT_PTR nLen = str.GetLength();
		*pBytes = UINT(nLen)/2;
		*ppData = new BYTE[*pBytes];
		for (int i=0;i<nLen;i+=2)
		{
			(*ppData)[i/2] = (BYTE)
				(((str[i+1] - 'A') << 4) + (str[i] - 'A'));
		}
		return TRUE;
	}
}


BOOL CWinApp::WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry,
	int nValue)
{
	ASSERT(lpszSection != NULL);
	ASSERT(lpszEntry != NULL);
	if (m_pszRegistryKey != NULL)
	{
		HKEY hSecKey = GetSectionKey(lpszSection);
		if (hSecKey == NULL)
			return FALSE;
		LONG lResult = RegSetValueEx(hSecKey, lpszEntry, NULL, REG_DWORD,
			(LPBYTE)&nValue, sizeof(nValue));
		RegCloseKey(hSecKey);
		return lResult == ERROR_SUCCESS;
	}
	else
	{
		ASSERT(m_pszProfileName != NULL);

		TCHAR szT[16];
		_stprintf_s(szT, _countof(szT), _T("%d"), nValue);
		return ::WritePrivateProfileString(lpszSection, lpszEntry, szT,
			m_pszProfileName);
	}
}

BOOL CWinApp::WriteProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
			LPCTSTR lpszValue)
{
	ASSERT(lpszSection != NULL);
	if (m_pszRegistryKey != NULL)
	{
		LONG lResult;
		if (lpszEntry == NULL) //delete whole section
		{
			HKEY hAppKey = GetAppRegistryKey();
			if (hAppKey == NULL)
				return FALSE;
			lResult = ::RegDeleteKey(hAppKey, lpszSection);
			RegCloseKey(hAppKey);
		}
		else if (lpszValue == NULL)
		{
			HKEY hSecKey = GetSectionKey(lpszSection);
			if (hSecKey == NULL)
				return FALSE;
			// necessary to cast away const below
			lResult = ::RegDeleteValue(hSecKey, (LPTSTR)lpszEntry);
			RegCloseKey(hSecKey);
		}
		else
		{
			HKEY hSecKey = GetSectionKey(lpszSection);
			if (hSecKey == NULL)
				return FALSE;
			lResult = RegSetValueEx(hSecKey, lpszEntry, NULL, REG_SZ,
				(LPBYTE)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
			RegCloseKey(hSecKey);
		}
		return lResult == ERROR_SUCCESS;
	}
	else
	{
		ASSERT(m_pszProfileName != NULL);
		ASSERT(lstrlen(m_pszProfileName) < 4095); // can't read in bigger
		return ::WritePrivateProfileString(lpszSection, lpszEntry, lpszValue,
			m_pszProfileName);
	}
}

BOOL CWinApp::WriteProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
	LPBYTE pData, UINT nBytes)
{
	ASSERT(lpszSection != NULL);
	if (m_pszRegistryKey != NULL)
	{
		LONG lResult;
		HKEY hSecKey = GetSectionKey(lpszSection);
		if (hSecKey == NULL)
			return FALSE;
		lResult = RegSetValueEx(hSecKey, lpszEntry, NULL, REG_BINARY,
			pData, nBytes);
		RegCloseKey(hSecKey);
		return lResult == ERROR_SUCCESS;
	}

	// convert to string and write out
	LPTSTR lpsz = new TCHAR[nBytes*2+1];
	UINT i;
	for (i = 0; i < nBytes; i++)
	{
		lpsz[i*2] = (TCHAR)((pData[i] & 0x0F) + 'A'); //low nibble
		lpsz[i*2+1] = (TCHAR)(((pData[i] >> 4) & 0x0F) + 'A'); //high nibble
	}
	lpsz[i*2] = 0;

	ASSERT(m_pszProfileName != NULL);

	BOOL bResult = WriteProfileString(lpszSection, lpszEntry, lpsz);
	delete[] lpsz;
	return bResult;
}

BOOL CWinApp::EnableTaskbarInteraction(BOOL bEnable) 
{
	if(AfxGetMainWnd() != NULL)
	{
		ASSERT(FALSE);
		TRACE0("Windows 7 taskbar interacrion must be called before creation of main window.\n");
		return FALSE;
	}

	m_bTaskbarInteractionEnabled = bEnable;
	return TRUE;
}

BOOL CWinApp::IsTaskbarInteractionEnabled() 
{ 
	return afxGlobalData.bIsWindows7 && m_bTaskbarInteractionEnabled; 
}
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_b.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CByteArray::CByteArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CByteArray::~CByteArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CByteArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ENSURE_ARG(nNewSize <= SIZE_T_MAX/sizeof(BYTE));    // no overflow
#endif
		m_pData = (BYTE*) new BYTE[nNewSize * sizeof(BYTE)];

		memset(m_pData, 0, nNewSize * sizeof(BYTE));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(BYTE));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(BYTE)); // no overflow
#endif
		BYTE* pNewData = (BYTE*) new BYTE[nNewMax * sizeof(BYTE)];

		// copy new data from old 
		Checked::memcpy_s(pNewData, nNewMax * sizeof(BYTE), 
			m_pData, m_nSize * sizeof(BYTE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(BYTE));


		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CByteArray::Append(const CByteArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(BYTE),
		src.m_pData, src.m_nSize * sizeof(BYTE));

	return nOldSize;
}

void CByteArray::Copy(const CByteArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself
	
	if(this != &src)
	{
		SetSize(src.m_nSize);

		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(BYTE),
			src.m_pData, src.m_nSize * sizeof(BYTE));
	}
}

void CByteArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(BYTE)); // no overflow
#endif
		BYTE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (BYTE*) new BYTE[m_nSize * sizeof(BYTE)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(BYTE), 
				m_pData, m_nSize * sizeof(BYTE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CByteArray::SetAtGrow(INT_PTR nIndex, BYTE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CByteArray::InsertAt(INT_PTR nIndex, BYTE newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();
		
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nCount+nIndex)) * sizeof(BYTE), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(BYTE));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(BYTE));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;

}



void CByteArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();
		
	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], (size_t)nMoveCount * sizeof(BYTE), 
			&m_pData[nUpperBound], (size_t)nMoveCount * sizeof(BYTE));
	}

	m_nSize -= nCount;
}

void CByteArray::InsertAt(INT_PTR nStartIndex, CByteArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CByteArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// Serialization

void CByteArray::Serialize(CArchive& ar)
{
	UINT_PTR nBytesLeft;
	UINT nBytesToWrite;
	UINT nBytesToRead;
	LPBYTE pbData;

	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
		nBytesLeft = m_nSize*sizeof(BYTE);
		pbData = m_pData;
		while(nBytesLeft > 0)
		{
			nBytesToWrite = UINT(min(nBytesLeft, INT_MAX));
			ar.Write(pbData, nBytesToWrite);
			pbData += nBytesToWrite;
			nBytesLeft -= nBytesToWrite;
		}
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize);
		nBytesLeft = m_nSize*sizeof(BYTE);
		pbData = m_pData;
		while(nBytesLeft > 0)
		{
			nBytesToRead = UINT(min(nBytesLeft, INT_MAX));
			ar.EnsureRead(pbData, nBytesToRead);
			pbData += nBytesToRead;
			nBytesLeft -= nBytesToRead;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CByteArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CByteArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(BYTE)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CByteArray, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_d.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CDWordArray::CDWordArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CDWordArray::~CDWordArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CDWordArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(DWORD));    // no overflow
#endif
		m_pData = (DWORD*) new BYTE[nNewSize * sizeof(DWORD)];

		memset(m_pData, 0, nNewSize * sizeof(DWORD));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(DWORD)); // no overflow
#endif
		DWORD* pNewData = (DWORD*) new BYTE[nNewMax * sizeof(DWORD)];

		// copy new data from old
		Checked::memcpy_s(pNewData, nNewMax * sizeof(DWORD), 
			m_pData, m_nSize * sizeof(DWORD));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));


		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CDWordArray::Append(const CDWordArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(DWORD), 
		src.m_pData, src.m_nSize * sizeof(DWORD));

	return nOldSize;
}

void CDWordArray::Copy(const CDWordArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);

		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(DWORD), 
			src.m_pData, src.m_nSize * sizeof(DWORD));
	}	

}

void CDWordArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(DWORD)); // no overflow
#endif
		DWORD* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (DWORD*) new BYTE[m_nSize * sizeof(DWORD)];

			// copy new data from old
			Checked::memcpy_s(pNewData, m_nSize * sizeof(DWORD), 
				m_pData, m_nSize * sizeof(DWORD));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CDWordArray::SetAtGrow(INT_PTR nIndex, DWORD newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CDWordArray::InsertAt(INT_PTR nIndex, DWORD newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();
		
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount],(m_nSize-(nIndex+nCount)) * sizeof(DWORD),
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(DWORD));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(DWORD));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;
}



void CDWordArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();
		
	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], nMoveCount * sizeof(DWORD), 
			&m_pData[nUpperBound], nMoveCount * sizeof(DWORD));
	}

	m_nSize -= nCount;
}

void CDWordArray::InsertAt(INT_PTR nStartIndex, CDWordArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CDWordArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}




/////////////////////////////////////////////////////////////////////////////
// Serialization

void CDWordArray::Serialize(CArchive& ar)
{
	UINT_PTR nDWORDsLeft;
	UINT nDWORDsToWrite;
	UINT nDWORDsToRead;
	DWORD* pdwData;

	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
		nDWORDsLeft = m_nSize;
		pdwData = m_pData;
		while(nDWORDsLeft > 0)
		{
			nDWORDsToWrite = UINT(min(nDWORDsLeft, INT_MAX/sizeof(DWORD)));
			ar.Write(pdwData, nDWORDsToWrite*sizeof(DWORD));
			nDWORDsLeft -= nDWORDsToWrite;
			pdwData += nDWORDsToWrite;
		}
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize);
		nDWORDsLeft = m_nSize;
		pdwData = m_pData;
		while(nDWORDsLeft > 0)
		{
			nDWORDsToRead = UINT(min(nDWORDsLeft, INT_MAX/sizeof(DWORD)));
			ar.EnsureRead(pdwData, nDWORDsToRead*sizeof(DWORD));
			nDWORDsLeft -= nDWORDsToRead;
			pdwData += nDWORDsToRead;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CDWordArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CDWordArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(DWORD)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CDWordArray, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\arccore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxtempl.h>
#include <wchar.h>
#include "sal.h"



#define new DEBUG_NEW

////////////////////////////////////////////////////////////////////////////
// Serialize member functions for low level classes put here
// for code swapping improvements

#ifdef _AFX_BYTESWAP
#error _AFX_BYTESWAP is not supported.
#endif

UINT_PTR AFXAPI AfxReadStringLength(CArchive& ar, int& nCharSize)
{
	ULONGLONG qwLength;
	DWORD dwLength;
	WORD wLength;
	BYTE bLength;

	nCharSize = sizeof(char);

	// First, try to read a one-byte length
	ar>>bLength;
	if (bLength < 0xff)
		return bLength;

	// Try a two-byte length
	ar>>wLength;
	if (wLength == 0xfffe)
	{
		// Unicode string.  Start over at 1-byte length
		nCharSize = sizeof(wchar_t);

		ar>>bLength;
		if (bLength < 0xff)
			return bLength;

		// Two-byte length
		ar>>wLength;
		// Fall through to continue on same branch as ANSI string
	}
	if (wLength < 0xffff)
		return wLength;

	// 4-byte length
	ar>>dwLength;
	if (dwLength < 0xffffffff)
		return dwLength;

	// 8-byte length
	ar>>qwLength;
#ifndef _WIN64  // Big strings aren't supported on Win32 clients
	if (qwLength > INT_MAX)
		AfxThrowArchiveException(CArchiveException::genericException);
#endif  // !_WIN64

	return (UINT_PTR)qwLength;
}

void AFXAPI AfxWriteStringLength(CArchive& ar, UINT_PTR nLength, BOOL bUnicode)
{
	if (bUnicode)
	{
		// Tag Unicode strings
		ar<<(BYTE)0xff;
		ar<<(WORD)0xfffe;
	}

	if (nLength < 255)
	{
		ar<<(BYTE)nLength;
	}
	else if (nLength < 0xfffe)
	{
		ar<<(BYTE)0xff;
		ar<<(WORD)nLength;
	}
	else if (nLength < 0xffffffff)
	{
		ar<<(BYTE)0xff;
		ar<<(WORD)0xffff;
		ar<<(DWORD)nLength;
	}
	else
	{
		ar<<(BYTE)0xff;
		ar<<(WORD)0xffff;
		ar<<(DWORD)0xffffffff;
		ar<<(ULONGLONG)nLength;
	}
}

// Runtime class serialization code
CObject* PASCAL CRuntimeClass::CreateObject(LPCSTR lpszClassName)
{
	ENSURE(lpszClassName);

	// attempt to find matching runtime class structure
	CRuntimeClass* pClass = FromName(lpszClassName);
	if (pClass == NULL)
	{
		// not found, trace a warning for diagnostic purposes
		TRACE(traceAppMsg, 0, "Warning: Cannot find %hs CRuntimeClass.  Class not defined.\n",
			lpszClassName);
		return NULL;
	}

	// attempt to create the object with the found CRuntimeClass
	CObject* pObject = pClass->CreateObject();
	return pObject;
}

CObject* PASCAL CRuntimeClass::CreateObject(LPCWSTR lpszClassName)
{	
	const CStringA strClassName(lpszClassName);
	return CRuntimeClass::CreateObject(lpszClassName ? strClassName.GetString() : NULL);
}

CRuntimeClass* PASCAL CRuntimeClass::FromName(LPCSTR lpszClassName)
{
	CRuntimeClass* pClass=NULL;

	ENSURE(lpszClassName);

	// search app specific classes
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	AfxLockGlobals(CRIT_RUNTIMECLASSLIST);
	for (pClass = pModuleState->m_classList; pClass != NULL;
		pClass = pClass->m_pNextClass)
	{
		if (lstrcmpA(lpszClassName, pClass->m_lpszClassName) == 0)
		{
			AfxUnlockGlobals(CRIT_RUNTIMECLASSLIST);
			return pClass;
		}
	}
	AfxUnlockGlobals(CRIT_RUNTIMECLASSLIST);
#ifdef _AFXDLL
	// search classes in shared DLLs
	AfxLockGlobals(CRIT_DYNLINKLIST);
	for (CDynLinkLibrary* pDLL = pModuleState->m_libraryList; pDLL != NULL;
		pDLL = pDLL->m_pNextDLL)
	{
		for (pClass = pDLL->m_classList; pClass != NULL;
			pClass = pClass->m_pNextClass)
		{
			if (lstrcmpA(lpszClassName, pClass->m_lpszClassName) == 0)
			{
				AfxUnlockGlobals(CRIT_DYNLINKLIST);
				return pClass;
			}
		}
	}
	AfxUnlockGlobals(CRIT_DYNLINKLIST);
#endif

	return NULL; // not found
}

CRuntimeClass* PASCAL CRuntimeClass::FromName(LPCWSTR lpszClassName)
{	
	const CStringA strClassName(lpszClassName);	
	if( lpszClassName == NULL )
		return NULL;
	return CRuntimeClass::FromName( strClassName.GetString() );
}

CRuntimeClass* PASCAL CRuntimeClass::Load(CArchive& ar, UINT* pwSchemaNum)
	// loads a runtime class description
{
	if(pwSchemaNum == NULL)
	{
		return NULL;
	}
	WORD nLen;
	char szClassName[64];

	WORD wTemp;
	ar >> wTemp; *pwSchemaNum = wTemp;
	ar >> nLen;

	// load the class name
	if (nLen >= _countof(szClassName) ||
		ar.Read(szClassName, nLen*sizeof(char)) != nLen*sizeof(char))
	{
		return NULL;
	}
	szClassName[nLen] = '\0';

	// match the string against an actual CRuntimeClass
	CRuntimeClass* pClass = FromName(szClassName);
	if (pClass == NULL)
	{
		// not found, trace a warning for diagnostic purposes
		TRACE(traceAppMsg, 0, "Warning: Cannot load %hs from archive.  Class not defined.\n",
			szClassName);
	}

	return pClass;
}

void CRuntimeClass::Store(CArchive& ar) const
	// stores a runtime class description
{
	WORD nLen = (WORD)lstrlenA(m_lpszClassName);
	ar << (WORD)m_wSchema << nLen;
	ar.Write(m_lpszClassName, nLen*sizeof(char));
}

////////////////////////////////////////////////////////////////////////////
// Archive object input/output

// minimum buffer size
enum { nBufSizeMin = 128 };

// default amount to grow m_pLoadArray upon insert
enum { nGrowSize = 64 };
// default size of hash table in m_pStoreMap when storing
enum { nHashSize = 137 };
// default size to grow collision blocks when storing
enum { nBlockSize = 16 };

////////////////////////////////////////////////////////////////////////////

CArchive::CArchive(CFile* pFile, UINT nMode, int nBufSize, void* lpBuf) 
{
	ASSERT_VALID(pFile);
	if(pFile == NULL)
	{
		AfxThrowInvalidArgException();
	}
	
	m_strFileName = pFile->GetFilePath();

	// initialize members not dependent on allocated buffer
	m_nMode = nMode;
	m_pFile = pFile;
	m_pSchemaMap = NULL;
	m_pLoadArray = NULL;
	m_pDocument = NULL;
	m_bForceFlat = TRUE;
	m_nObjectSchema = (UINT)-1; // start with invalid schema
	if (IsStoring())
		m_nGrowSize = nBlockSize;
	else
		m_nGrowSize = nGrowSize;
	m_nHashSize = nHashSize;

	// initialize the buffer.  minimum size is 128
	m_lpBufStart = (BYTE*)lpBuf;
	m_bUserBuf = TRUE;
	m_bDirectBuffer = FALSE;
	m_bBlocking = m_pFile->GetBufferPtr(CFile::bufferCheck)&CFile::bufferBlocking;

	if (nBufSize < nBufSizeMin)
	{
		// force use of private buffer of minimum size
		m_nBufSize = nBufSizeMin;
		m_lpBufStart = NULL;
	}
	else
		m_nBufSize = nBufSize;

	nBufSize = m_nBufSize;
	if (m_lpBufStart == NULL)
	{
		// check for CFile providing buffering support
		m_bDirectBuffer = m_pFile->GetBufferPtr(CFile::bufferCheck)&CFile::bufferDirect;
		if (!m_bDirectBuffer)
		{
			// no support for direct buffering, allocate new buffer
			m_lpBufStart = new BYTE[m_nBufSize];
			m_bUserBuf = FALSE;
		}
		else
		{
			// CFile* supports direct buffering!
			nBufSize = 0;   // will trigger initial FillBuffer
		}
	}

	if (!m_bDirectBuffer)
	{
		ASSERT(m_lpBufStart != NULL);
		ASSERT(AfxIsValidAddress(m_lpBufStart, nBufSize, IsStoring()));
	}
	m_lpBufMax = m_lpBufStart + nBufSize;
	m_lpBufCur = (IsLoading()) ? m_lpBufMax : m_lpBufStart;

	ASSERT(m_pStoreMap == NULL);        // same as m_pLoadArray
}

CArchive::~CArchive()
{
	// Close makes m_pFile NULL. If it is not NULL, we must Close the CArchive
	if (m_pFile != NULL && !(m_nMode & bNoFlushOnDelete))
		Close();

	Abort();    // abort completely shuts down the archive
}

void CArchive::Abort()
{
	ASSERT(m_bDirectBuffer || m_lpBufStart == NULL ||
		AfxIsValidAddress(m_lpBufStart, UINT(m_lpBufMax - m_lpBufStart), IsStoring()));
	ASSERT(m_bDirectBuffer || m_lpBufCur == NULL ||
		AfxIsValidAddress(m_lpBufCur, UINT(m_lpBufMax - m_lpBufCur), IsStoring()));

	// disconnect from the file
	m_pFile = NULL;

	if (!m_bUserBuf)
	{
		ASSERT(!m_bDirectBuffer);
		delete[] m_lpBufStart;
		m_lpBufStart = NULL;
		m_lpBufCur = NULL;
	}

	void* pTemp;
	if ( (NULL != m_pSchemaMap) && 
		(m_pSchemaMap->Lookup( 
				reinterpret_cast<void*>(static_cast<DWORD_PTR>(objTypeArrayRef)), 
				pTemp )))
	{
		CArray<LoadArrayObjType>* pObjTypeArray = static_cast<CArray<LoadArrayObjType>*>(pTemp);
		delete pObjTypeArray;
		pObjTypeArray = NULL;
	}

	delete m_pSchemaMap;
	m_pSchemaMap = NULL;

	// m_pStoreMap and m_pLoadArray are unioned, so we only need to delete one
	ASSERT((CObject*)m_pStoreMap == (CObject*)m_pLoadArray);
	delete (CObject*)m_pLoadArray;
	m_pLoadArray = NULL;
}

void CArchive::Close()
{
	ASSERT_VALID(m_pFile);

	Flush();
	m_pFile = NULL;
}

UINT CArchive::Read(void* lpBuf, UINT nMax)
{
	ASSERT_VALID(m_pFile);

	if (nMax == 0)
		return 0;

	ASSERT(lpBuf != NULL);

	if(lpBuf == NULL)
		return 0;

	ASSERT(AfxIsValidAddress(lpBuf, nMax));
	ASSERT(m_bDirectBuffer || m_lpBufStart != NULL);
	ASSERT(m_bDirectBuffer || m_lpBufCur != NULL);
	ASSERT(m_lpBufStart == NULL ||
		AfxIsValidAddress(m_lpBufStart, UINT(m_lpBufMax - m_lpBufStart), FALSE));
	ASSERT(m_lpBufCur == NULL ||
		AfxIsValidAddress(m_lpBufCur, UINT(m_lpBufMax - m_lpBufCur), FALSE));
	ASSERT(IsLoading());

	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);

	// try to fill from buffer first
	UINT nMaxTemp = nMax;
	UINT nTemp = min(nMaxTemp, UINT(m_lpBufMax - m_lpBufCur));
	Checked::memcpy_s(lpBuf, nMaxTemp, m_lpBufCur, nTemp);
	m_lpBufCur += nTemp;
	lpBuf = (BYTE*)lpBuf + nTemp;
	nMaxTemp -= nTemp;

	if (nMaxTemp != 0)
	{
		ASSERT(m_lpBufCur == m_lpBufMax);

		// read rest in buffer size chunks
		nTemp = nMaxTemp - (nMaxTemp % m_nBufSize);
		UINT nRead = 0;

		UINT nLeft = nTemp;
		UINT nBytes;
		do
		{
			nBytes = m_pFile->Read(lpBuf, nLeft);
			lpBuf = (BYTE*)lpBuf + nBytes;
			nRead += nBytes;
			nLeft -= nBytes;
		}
		while ((nBytes > 0) && (nLeft > 0));

		nMaxTemp -= nRead;

		if (nMaxTemp > 0)
		{
			// read last chunk into buffer then copy
			if (nRead == nTemp)
			{
				ASSERT(m_lpBufCur == m_lpBufMax);
				ASSERT(nMaxTemp < UINT(m_nBufSize));

				// fill buffer (similar to CArchive::FillBuffer, but no exception)
				if (!m_bDirectBuffer)
				{
					UINT nLastLeft;
					UINT nLastBytes;

					if (!m_bBlocking)
						nLastLeft = max(nMaxTemp, UINT(m_nBufSize));
					else
						nLastLeft = nMaxTemp;
					BYTE* lpTemp = m_lpBufStart;
					nRead = 0;
					do
					{
						nLastBytes = m_pFile->Read(lpTemp, nLastLeft);
						lpTemp = lpTemp + nLastBytes;
						nRead += nLastBytes;
						nLastLeft -= nLastBytes;
					}
					while ((nLastBytes > 0) && (nLastLeft > 0) && nRead < nMaxTemp);

					m_lpBufCur = m_lpBufStart;
					m_lpBufMax = m_lpBufStart + nRead;
				}
				else
				{
					nRead = m_pFile->GetBufferPtr(CFile::bufferRead, m_nBufSize,
						(void**)&m_lpBufStart, (void**)&m_lpBufMax);
					ASSERT(nRead == size_t( m_lpBufMax-m_lpBufStart ));
					m_lpBufCur = m_lpBufStart;
				}

				// use first part for rest of read
				nTemp = min(nMaxTemp, UINT(m_lpBufMax - m_lpBufCur));
				Checked::memcpy_s(lpBuf, nMaxTemp, m_lpBufCur, nTemp);
				m_lpBufCur += nTemp;
				nMaxTemp -= nTemp;
			}
		}
	}
	return nMax - nMaxTemp;
}

void CArchive::Write(const void* lpBuf, UINT nMax)
{
	ASSERT_VALID(m_pFile);

	if (nMax == 0)
		return;

	ASSERT(lpBuf != NULL);

	if(lpBuf == NULL)
		return;

	ASSERT(AfxIsValidAddress(lpBuf, nMax, FALSE));  // read-only access needed
	ASSERT(m_bDirectBuffer || m_lpBufStart != NULL);
	ASSERT(m_bDirectBuffer || m_lpBufCur != NULL);
	ASSERT(m_lpBufStart == NULL ||
		AfxIsValidAddress(m_lpBufStart, UINT(m_lpBufMax - m_lpBufStart)));
	ASSERT(m_lpBufCur == NULL ||
		AfxIsValidAddress(m_lpBufCur, UINT(m_lpBufMax - m_lpBufCur)));
	ASSERT(IsStoring());

	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);

	// copy to buffer if possible
	UINT nTemp = min(nMax, (UINT)(m_lpBufMax - m_lpBufCur));
	Checked::memcpy_s(m_lpBufCur, (size_t)(m_lpBufMax - m_lpBufCur), lpBuf, nTemp);
	m_lpBufCur += nTemp;
	lpBuf = (BYTE*)lpBuf + nTemp;
	nMax -= nTemp;

	if (nMax > 0)
	{
		Flush();    // flush the full buffer

		// write rest of buffer size chunks
		nTemp = nMax - (nMax % m_nBufSize);
		m_pFile->Write(lpBuf, nTemp);
		lpBuf = (BYTE*)lpBuf + nTemp;
		nMax -= nTemp;

		if (m_bDirectBuffer)
		{
			// sync up direct mode buffer to new file position
			VERIFY(m_pFile->GetBufferPtr(CFile::bufferWrite, m_nBufSize,
				(void**)&m_lpBufStart, (void**)&m_lpBufMax) == (UINT)m_nBufSize);
			ASSERT((UINT)m_nBufSize == (UINT)(m_lpBufMax - m_lpBufStart));
			m_lpBufCur = m_lpBufStart;
		}

		// copy remaining to active buffer
		ENSURE(nMax < (UINT)m_nBufSize);
		ENSURE(m_lpBufCur == m_lpBufStart);
		Checked::memcpy_s(m_lpBufCur, nMax, lpBuf, nMax);
		m_lpBufCur += nMax;
	}
}

void CArchive::Flush()
{
	ASSERT_VALID(m_pFile);
	ASSERT(m_bDirectBuffer || m_lpBufStart != NULL);
	ASSERT(m_bDirectBuffer || m_lpBufCur != NULL);
	ASSERT(m_lpBufStart == NULL ||
		AfxIsValidAddress(m_lpBufStart, UINT(m_lpBufMax - m_lpBufStart), IsStoring()));
	ASSERT(m_lpBufCur == NULL ||
		AfxIsValidAddress(m_lpBufCur, UINT(m_lpBufMax - m_lpBufCur), IsStoring()));

	if (IsLoading())
	{
		// unget the characters in the buffer, seek back unused amount
		if (m_lpBufMax != m_lpBufCur)
			m_pFile->Seek(-(int(m_lpBufMax - m_lpBufCur)), CFile::current);
		m_lpBufCur = m_lpBufMax;    // empty
	}
	else
	{
		if (!m_bDirectBuffer)
		{
			// write out the current buffer to file
			if (m_lpBufCur != m_lpBufStart)
				m_pFile->Write(m_lpBufStart, ULONG(m_lpBufCur - m_lpBufStart));
		}
		else
		{
			// commit current buffer
			if (m_lpBufCur != m_lpBufStart)
				m_pFile->GetBufferPtr(CFile::bufferCommit, ULONG(m_lpBufCur - m_lpBufStart));
			// get next buffer
			VERIFY(m_pFile->GetBufferPtr(CFile::bufferWrite, m_nBufSize,
				(void**)&m_lpBufStart, (void**)&m_lpBufMax) == (UINT)m_nBufSize);
			ASSERT((UINT)m_nBufSize == (UINT)(m_lpBufMax - m_lpBufStart));
		}
		m_lpBufCur = m_lpBufStart;
	}
}

void CArchive::FillBuffer(UINT nAdditionalBytesNeeded)
{
	ASSERT_VALID(m_pFile);

	ASSERT(IsLoading());
	if (!IsLoading())
	{
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	}

	ASSERT(m_bDirectBuffer || m_lpBufStart != NULL);
	ASSERT(m_bDirectBuffer || m_lpBufCur != NULL);
	ASSERT(nAdditionalBytesNeeded > 0);

	ASSERT(m_lpBufStart == NULL || AfxIsValidAddress(m_lpBufStart, UINT(m_lpBufMax - m_lpBufStart), FALSE));
	ASSERT(m_lpBufCur == NULL || AfxIsValidAddress(m_lpBufCur, UINT(m_lpBufMax - m_lpBufCur), FALSE));

	UINT nPreviouslyFilled = UINT(m_lpBufMax - m_lpBufCur);
	ULONG nTotalSizeWanted = ((ULONG)nAdditionalBytesNeeded) + nPreviouslyFilled;

	// fill up the current buffer from file
	if (!m_bDirectBuffer)
	{
		ASSERT(m_lpBufCur != NULL);
		ASSERT(m_lpBufStart != NULL);
		ASSERT(m_lpBufMax != NULL);

		if (m_lpBufCur > m_lpBufStart)
		{
			// copy previously filled bytes to the start of the buffer
			if ((int)nPreviouslyFilled > 0)
			{
				Checked::memmove_s(m_lpBufStart, (size_t)(m_lpBufMax - m_lpBufStart), m_lpBufCur, nPreviouslyFilled);
				m_lpBufCur = m_lpBufStart;
				m_lpBufMax = m_lpBufStart + nPreviouslyFilled;
			}

			// read to satisfy nAdditionalBytesNeeded if possible, else fill the buffer and throw bufferFull exception
			UINT nTotalInBuffer = nPreviouslyFilled;
			UINT nLeftToRead;
			UINT nBytesRead = 0;

			// Only read what we have to, to avoid blocking waiting on data we don't immediately need
			if (m_bBlocking)
			{
				nLeftToRead = min(nAdditionalBytesNeeded, (UINT)m_nBufSize - nPreviouslyFilled);
			}
			else
			{
				nLeftToRead = (UINT)m_nBufSize - nPreviouslyFilled;
			}

			BYTE* lpTemp = m_lpBufStart + nPreviouslyFilled;
			do
			{
				nBytesRead = m_pFile->Read(lpTemp, nLeftToRead);
				lpTemp = lpTemp + nBytesRead;
				nTotalInBuffer += nBytesRead;
				nLeftToRead -= nBytesRead;
			}
			while (nBytesRead > 0 && nLeftToRead > 0 && nTotalInBuffer < nTotalSizeWanted);

			m_lpBufCur = m_lpBufStart;
			m_lpBufMax = m_lpBufStart + nTotalInBuffer;
		}
	}
	else
	{
		// seek to end of previously filled portion and get the buffer starting there
		if (nPreviouslyFilled != 0)
		{
			m_pFile->Seek(-(LONG)nPreviouslyFilled, CFile::current);
		}

		UINT nActual = m_pFile->GetBufferPtr(CFile::bufferRead, m_nBufSize, (void**)&m_lpBufStart, (void**)&m_lpBufMax);
		ASSERT(nActual == (UINT)(m_lpBufMax - m_lpBufStart));
		m_lpBufCur = m_lpBufStart;
	}

	// buffer not large enough to hold all requested data?
	if ((ULONG)m_nBufSize < nTotalSizeWanted)
	{
		AfxThrowArchiveException(CArchiveException::bufferFull);
	}

	// not enough data to fill request?
	if ((ULONG)(m_lpBufMax - m_lpBufCur) < nTotalSizeWanted)
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}

void CArchive::WriteCount(DWORD_PTR dwCount)
{
	if (dwCount < 0xFFFF)
		*this << (WORD)dwCount;  // 16-bit count
	else
	{
		*this << (WORD)0xFFFF;
#ifndef _WIN64
		*this << (DWORD)dwCount;  // 32-bit count
#else  // _WIN64
		if (dwCount < 0xFFFFFFFF)
			*this << (DWORD)dwCount;  // 32-bit count
		else
		{
			*this << (DWORD)0xFFFFFFFF;
			*this << dwCount;
		}
#endif  // _WIN64
	}
}

DWORD_PTR CArchive::ReadCount()
{
	WORD wCount;
	*this >> wCount;
	if (wCount != 0xFFFF)
		return wCount;

	DWORD dwCount;
	*this >> dwCount;
#ifndef _WIN64
	return dwCount;
#else  // _WIN64
	if (dwCount != 0xFFFFFFFF)
		return dwCount;

	DWORD_PTR qwCount;
	*this >> qwCount;
	return qwCount;
#endif  // _WIN64
}

// special functions for text file input and output

void CArchive::WriteString(LPCTSTR lpsz)
{
	ASSERT(AfxIsValidString(lpsz));
	Write(lpsz, lstrlen(lpsz) * sizeof(TCHAR));
}

LPTSTR CArchive::ReadString(_Out_z_cap_(nMax+1) LPTSTR lpsz, _In_ UINT nMax)
{
	// if nMax is negative (such a large number doesn't make sense given today's
	// 2gb address space), then assume it to mean "keep the newline".
	int nStop = (int)nMax < 0 ? -(int)nMax : (int)nMax;
	ASSERT(AfxIsValidAddress(lpsz, (nStop+1) * sizeof(TCHAR)));

	if(lpsz == NULL)
		return NULL;

	_TUCHAR ch;
	int nRead = 0;

	TRY
	{
		while (nRead < nStop)
		{
			*this >> ch;

			// stop and end-of-line (trailing '\n' is ignored)
			if (ch == '\n' || ch == '\r')
			{
				if (ch == '\r')
					*this >> ch;
				// store the newline when called with negative nMax
				if ((int)nMax != nStop)
					lpsz[nRead++] = ch;
				break;
			}
			lpsz[nRead++] = ch;
		}
	}
	CATCH(CArchiveException, e)
	{
		if (e && e->m_cause == CArchiveException::endOfFile)
		{
			DELETE_EXCEPTION(e);
			if (nRead == 0)
				return NULL;
		}
		else
		{
			THROW_LAST();
		}
	}
	END_CATCH

	lpsz[nRead] = '\0';
	return lpsz;
}

BOOL CArchive::ReadString(CString& rString)
{
	rString = _T("");    // empty string without deallocating
	const int nMaxSize = 128;
	LPTSTR lpsz = rString.GetBuffer(nMaxSize);
	LPTSTR lpszResult;
	int nLen;
	for (;;)
	{
		lpszResult = ReadString(lpsz, (UINT)-nMaxSize); // store the newline
		rString.ReleaseBuffer();

		// if string is read completely or EOF
		if (lpszResult == NULL ||
			(nLen = (int)lstrlen(lpsz)) < nMaxSize ||
			lpsz[nLen-1] == '\n')
		{
			break;
		}

		nLen = rString.GetLength();
		lpsz = rString.GetBuffer(nMaxSize + nLen) + nLen;
	}

	// remove '\n' from end of string if present
	lpsz = rString.GetBuffer(0);
	nLen = rString.GetLength();
	if (nLen != 0 && lpsz[nLen-1] == '\n')
		rString.GetBufferSetLength(nLen-1);

	return lpszResult != NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CObArray::CObArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CObArray::~CObArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CObArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);
	
	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(CObject*));    // no overflow
#endif
		m_pData = (CObject**) new BYTE[nNewSize * sizeof(CObject*)];

		memset(m_pData, 0, nNewSize * sizeof(CObject*));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowBySize = m_nGrowBy;
		if (nGrowBySize == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBySize = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBySize)
			nNewMax = m_nMaxSize + nGrowBySize;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();
			
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(CObject*)); // no overflow
#endif
		CObject** pNewData = (CObject**) new BYTE[nNewMax * sizeof(CObject*)];

		// copy new data from old
		Checked::memcpy_s(pNewData, nNewMax * sizeof(CObject*), 
			m_pData, m_nSize * sizeof(CObject*));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));


		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CObArray::Append(const CObArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();
		
	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(CObject*), 
		src.m_pData, src.m_nSize * sizeof(CObject*));

	return nOldSize;
}

void CObArray::Copy(const CObArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);
	
		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(CObject*), 
			src.m_pData, src.m_nSize * sizeof(CObject*));
	}

}

void CObArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(CObject*)); // no overflow
#endif
		CObject** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (CObject**) new BYTE[m_nSize * sizeof(CObject*)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(CObject*), 
				m_pData, m_nSize * sizeof(CObject*));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CObArray::SetAtGrow(INT_PTR nIndex, CObject* newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	
	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CObArray::InsertAt(INT_PTR nIndex, CObject* newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();
		
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nIndex+nCount)) * sizeof(CObject*), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(CObject*));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(CObject*));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;

}



void CObArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();
		
	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], nMoveCount * sizeof(CObject*), 
			&m_pData[nUpperBound], nMoveCount * sizeof(CObject*));
	}

	m_nSize -= nCount;
}

void CObArray::InsertAt(INT_PTR nStartIndex, CObArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CObArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();
		
	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CObArray::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
		for (INT_PTR i = 0; i < m_nSize; i++)
			ar << m_pData[i];
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize);
		for (INT_PTR i = 0; i < m_nSize; i++)
			ar >> m_pData[i];
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CObArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CObArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(CObject*)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CObArray, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_p.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CPtrArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(void*));    // no overflow
#endif
		m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];

		memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];

		// copy new data from old
		Checked::memcpy_s(pNewData, nNewMax * sizeof(void*), 
			m_pData, m_nSize * sizeof(void*));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CPtrArray::Append(const CPtrArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(void*), 
		src.m_pData, src.m_nSize * sizeof(void*));

	return nOldSize;
}

void CPtrArray::Copy(const CPtrArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);

		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(void*), 
			src.m_pData, src.m_nSize * sizeof(void*));
	}

}

void CPtrArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(void*)); // no overflow
#endif
		void** pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(void*), 
				m_pData, m_nSize * sizeof(void*));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CPtrArray::SetAtGrow(INT_PTR nIndex, void* newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CPtrArray::InsertAt(INT_PTR nIndex, void* newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();
		
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nIndex+nCount)) * sizeof(void*), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(void*));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(void*));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;

}



void CPtrArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();
		
	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], nMoveCount * sizeof(void*), 
			&m_pData[nUpperBound], nMoveCount * sizeof(void*));
	}

	m_nSize -= nCount;
}

void CPtrArray::InsertAt(INT_PTR nStartIndex, CPtrArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CPtrArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CPtrArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CPtrArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(void*)));
	}
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CPtrArray, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\arcstrm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArchiveStream

#ifndef _AFX_NO_OLE_SUPPORT

CArchiveStream::CArchiveStream(CArchive* pArchive)
{
	m_pArchive = pArchive;
}

STDMETHODIMP_(ULONG)CArchiveStream::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG)CArchiveStream::Release()
{
	return 0;
}

STDMETHODIMP CArchiveStream::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	if (iid == IID_IUnknown || iid == IID_IStream)
	{
		if (ppvObj == NULL) 
		{
			return E_POINTER;
		}
		*ppvObj = this;
		return NOERROR;
	}
	return E_NOINTERFACE;
}

STDMETHODIMP CArchiveStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	ASSERT(m_pArchive != NULL);
	ASSERT(m_pArchive->IsLoading());

	int nRead = 0;
	TRY
	{
		nRead = m_pArchive->Read(pv, cb);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		return E_UNEXPECTED;
	}
	END_CATCH_ALL

	if (pcbRead != NULL)
		*pcbRead = nRead;
	return NOERROR;
}

STDMETHODIMP CArchiveStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	ASSERT(m_pArchive != NULL);
	ASSERT(m_pArchive->IsStoring());

	int nWrite = 0;
	TRY
	{
		m_pArchive->Write(pv, cb);
		nWrite = cb;
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		return E_UNEXPECTED;
	}
	END_CATCH_ALL

	if (pcbWritten != NULL)
		*pcbWritten = nWrite;
	return NOERROR;
}

STDMETHODIMP CArchiveStream::Seek(LARGE_INTEGER uliOffset, DWORD dwOrigin,
	ULARGE_INTEGER* puliNew)
{
	CFile* pFile = m_pArchive->GetFile();
	if (pFile == NULL)
		return E_NOTIMPL;
	m_pArchive->Flush();

	ASSERT(STREAM_SEEK_SET == CFile::begin);
	ASSERT(STREAM_SEEK_CUR == CFile::current);
	ASSERT(STREAM_SEEK_END == CFile::end);
	ULONGLONG lNew;
	TRY
	{
		lNew = pFile->Seek(uliOffset.QuadPart, (UINT)dwOrigin);
	}
	CATCH_ALL(e)
	{
		DELETE_EXCEPTION(e);
		return E_UNEXPECTED;
	}
	END_CATCH_ALL

	if (puliNew != NULL)
	  puliNew->QuadPart = lNew;

	return NOERROR;
}

STDMETHODIMP CArchiveStream::SetSize(ULARGE_INTEGER)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*,
	ULARGE_INTEGER*)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::Commit(DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::Revert()
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER,
	DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::Stat(STATSTG*, DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP CArchiveStream::Clone(LPSTREAM*)
{
	return E_NOTIMPL;
}

#endif // _AFX_NO_OLE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_u.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CUIntArray::CUIntArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CUIntArray::~CUIntArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CUIntArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(UINT));    // no overflow
#endif
		m_pData = (UINT*) new BYTE[nNewSize * sizeof(UINT)];

		memset(m_pData, 0, nNewSize * sizeof(UINT));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(UINT));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(UINT)); // no overflow
#endif
		UINT* pNewData = (UINT*) new BYTE[nNewMax * sizeof(UINT)];

		// copy new data from old
		Checked::memcpy_s(pNewData, nNewMax * sizeof(UINT), 
			m_pData, m_nSize * sizeof(UINT));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(UINT));

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CUIntArray::Append(const CUIntArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(UINT), 
		src.m_pData, src.m_nSize * sizeof(UINT));

	return nOldSize;
}

void CUIntArray::Copy(const CUIntArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);

		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(UINT), 
			src.m_pData, src.m_nSize * sizeof(UINT));
	}

}

void CUIntArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(UINT)); // no overflow
#endif
		UINT* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (UINT*) new BYTE[m_nSize * sizeof(UINT)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(UINT),
				m_pData, m_nSize * sizeof(UINT));							
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CUIntArray::SetAtGrow(INT_PTR nIndex, UINT newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CUIntArray::InsertAt(INT_PTR nIndex, UINT newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nIndex+nCount)) * sizeof(UINT), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(UINT));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(UINT));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;

}



void CUIntArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();

	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], (size_t)nMoveCount * sizeof(UINT), 
			&m_pData[nUpperBound], (size_t)nMoveCount * sizeof(UINT));
	}

	m_nSize -= nCount;
}

void CUIntArray::InsertAt(INT_PTR nStartIndex, CUIntArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CUIntArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CUIntArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CUIntArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(UINT)));
	}
}
#endif //_DEBUG



IMPLEMENT_DYNAMIC(CUIntArray, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_s.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#include "elements.h"  // used for special creation

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

static void _ConstructElements(CString* pNewData, INT_PTR nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		ConstructElement(pNewData);
		pNewData++;
	}
}

static void _DestructElements(CString* pOldData, INT_PTR nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		DestructElement(pOldData);
		pOldData++;
	}
}

static void _CopyElements(CString* pDest, CString* pSrc, INT_PTR nCount)
{
	ASSERT(nCount >= 0);

	while (nCount--)
	{
		*pDest = *pSrc;
		++pDest;
		++pSrc;
	}
}

/////////////////////////////////////////////////////////////////////////////

CStringArray::CStringArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CStringArray::~CStringArray()
{
	AFX_BEGIN_DESTRUCTOR

		ASSERT_VALID(this);

		_DestructElements(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;

	AFX_END_DESTRUCTOR
}

void CStringArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing

		_DestructElements(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(CString));    // no overflow
#endif
		m_pData = (CString*) new BYTE[nNewSize * sizeof(CString)];

		_ConstructElements(m_pData, nNewSize);

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			_ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

		}

		else if (m_nSize > nNewSize)  // destroy the old elements
			_DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(CString)); // no overflow
#endif
		CString* pNewData = (CString*) new BYTE[(size_t)nNewMax * sizeof(CString)];

		// copy new data from old 
		Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(CString), 
			m_pData, (size_t)m_nSize * sizeof(CString));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		_ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CStringArray::Append(const CStringArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	_CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);

	return nOldSize;
}

void CStringArray::Copy(const CStringArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);
		_CopyElements(m_pData, src.m_pData, src.m_nSize);
	}
}

void CStringArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(CString)); // no overflow
#endif
		CString* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (CString*) new BYTE[m_nSize * sizeof(CString)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(CString), 
				m_pData, m_nSize * sizeof(CString));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CStringArray::SetAtGrow(INT_PTR nIndex, LPCTSTR newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}


void CStringArray::SetAtGrow(INT_PTR nIndex, const CString& newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
	{
		// Make sure newElement is not a reference to an element in the array.
		// Or else, it will be invalidated by the reallocation.
		ENSURE(	(nIndex < m_nMaxSize) ||
				(&newElement < m_pData) ||
				(&newElement >= (m_pData + m_nMaxSize) ) );
		SetSize(nIndex+1);
	}
	m_pData[nIndex] = newElement;
}



void CStringArray::InsertEmpty(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		INT_PTR nOverlapSize = min(nCount, nOldSize - nIndex);

		SetSize(m_nSize + nCount);  // grow it to new size

		// destroy slots we are about to overwrite
		_DestructElements(&m_pData[m_nSize - nOverlapSize], nOverlapSize);

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nIndex+nCount)) * sizeof(CString), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(CString));

		// re-init the now-vacant slots we moved data from
		_ConstructElements(&m_pData[nIndex], nOverlapSize);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
}


void CStringArray::InsertAt(INT_PTR nIndex, LPCTSTR newElement, INT_PTR nCount)
{

	// make room for new elements
	InsertEmpty(nIndex, nCount);



	// copy elements into the empty space
	CString temp = newElement;
	while (nCount--)
		m_pData[nIndex++] = temp;

}


void CStringArray::InsertAt(INT_PTR nIndex, const CString& newElement, INT_PTR nCount)
{
	// make room for new elements
	InsertEmpty(nIndex, nCount);

	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;
}


void CStringArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();
		
	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	_DestructElements(&m_pData[nIndex], nCount);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], nMoveCount * sizeof(CString), 
			&m_pData[nUpperBound], nMoveCount * sizeof(CString));
	}

	m_nSize -= nCount;
}

void CStringArray::InsertAt(INT_PTR nStartIndex, const CStringArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CStringArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}


/////////////////////////////////////////////////////////////////////////////
// Serialization

void CStringArray::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
		for (INT_PTR i = 0; i < m_nSize; i++)
			ar << m_pData[i];
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize);
		for (INT_PTR i = 0; i < m_nSize; i++)
			ar >> m_pData[i];
	}
}



/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CStringArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CStringArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(CString)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CStringArray, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\bardlg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

CDialogBar::CDialogBar()
{
#ifndef _AFX_NO_OCC_SUPPORT
	m_lpszTemplateName = NULL;
	m_pOccDialogInfo = NULL;
#endif
}

CDialogBar::~CDialogBar()
{
	DestroyWindow();    // avoid PostNcDestroy problems
}

BOOL CDialogBar::Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName,
	UINT nStyle, UINT nID)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(lpszTemplateName != NULL);

#ifdef _DEBUG
	// dialog template must exist and be invisible with WS_CHILD set
	if (!_AfxCheckDialogTemplate(lpszTemplateName, TRUE))
	{
		ASSERT(FALSE);          // invalid dialog template name
		PostNcDestroy();        // cleanup if Create fails too soon
		return FALSE;
	}
#endif //_DEBUG

	// allow chance to modify styles
	m_dwStyle = (nStyle & CBRS_ALL);
	CREATESTRUCT cs;
	memset(&cs, 0, sizeof(cs));
	cs.lpszClass = _afxWndControlBar;
	cs.style = (DWORD)nStyle | WS_CHILD;
	cs.hMenu = (HMENU)(UINT_PTR)nID;
	cs.hInstance = AfxGetInstanceHandle();
	cs.hwndParent = pParentWnd->GetSafeHwnd();
	if (!PreCreateWindow(cs))
		return FALSE;

	// create a modeless dialog

#ifndef _AFX_NO_OCC_SUPPORT
	m_lpszTemplateName = lpszTemplateName;
#endif

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));
	AfxDeferRegisterClass(AFX_WNDCOMMCTLSNEW_REG);

	BOOL bSuccess = CreateDlg(lpszTemplateName, pParentWnd);

#ifndef _AFX_NO_OCC_SUPPORT
	m_lpszTemplateName = NULL;
#endif

	if (!bSuccess)
		return FALSE;

	// dialog template MUST specify that the dialog
	//  is an invisible child window
	SetDlgCtrlID(nID);
	CRect rect;
	GetWindowRect(&rect);
	m_sizeDefault = rect.Size();    // set fixed size

	// force WS_CLIPSIBLINGS
	ModifyStyle(0, WS_CLIPSIBLINGS);

	if (!ExecuteDlgInit(lpszTemplateName))
		return FALSE;

	// force the size to zero - resizing bar will occur later
	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER|SWP_NOACTIVATE|SWP_SHOWWINDOW);

	return TRUE;
}

CSize CDialogBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	if (bStretch) // if not docked stretch to fit
		return CSize(bHorz ? 32767 : m_sizeDefault.cx,
			bHorz ? m_sizeDefault.cy : 32767);
	else
		return m_sizeDefault;
}

void CDialogBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

#ifndef _AFX_NO_OCC_SUPPORT

//{{AFX_MSG_MAP(CDialogBar)
BEGIN_MESSAGE_MAP(CDialogBar, CControlBar)
	ON_MESSAGE(WM_INITDIALOG,&CDialogBar::HandleInitDialog)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

LRESULT CDialogBar::HandleInitDialog(WPARAM, LPARAM)
{
	Default();  // allow default to initialize first (common dialogs/etc)

	// create OLE controls
	COccManager* pOccManager = afxOccManager;
	if ((pOccManager != NULL) && (m_pOccDialogInfo != NULL))
	{
		if (!pOccManager->CreateDlgControls(this, m_lpszTemplateName,
			m_pOccDialogInfo))
		{
			TRACE(traceAppMsg, 0, "Warning: CreateDlgControls failed during dialog bar init.\n");
			return FALSE;
		}
	}

	return FALSE;
}

BOOL CDialogBar::SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo)
{
	m_pOccDialogInfo = pOccDialogInfo;
	return TRUE;
}

#endif //!_AFX_NO_OCC_SUPPORT


IMPLEMENT_DYNAMIC(CDialogBar, CControlBar)

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\barcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <malloc.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CControlBar

// IMPLEMENT_DYNAMIC for CControlBar is in wincore.cpp for .OBJ granularity reasons

BEGIN_MESSAGE_MAP(CControlBar, CWnd)
	//{{AFX_MSG_MAP(CControlBar)
	ON_WM_TIMER()
	ON_WM_PAINT()
	ON_WM_CTLCOLOR()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CControlBar::OnIdleUpdateCmdUI)
	ON_MESSAGE(WM_SIZEPARENT, &CControlBar::OnSizeParent)
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_SHOWWINDOW()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEACTIVATE()
	ON_WM_CANCELMODE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_THEMECHANGED()
	ON_MESSAGE_VOID(WM_INITIALUPDATE, CControlBar::OnInitialUpdate)
	ON_MESSAGE(WM_HELPHITTEST, &CControlBar::OnHelpHitTest)
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CControlBar::CControlBar()
{
	// no elements contained in the control bar yet
	m_nCount = 0;
	m_pData = NULL;

	// set up some default border spacings
	m_cxLeftBorder = m_cxRightBorder = 6;
	m_cxDefaultGap = 2;
	m_cyTopBorder = m_cyBottomBorder = 1;
	m_bAutoDelete = FALSE;
	m_hWndOwner = NULL;
	m_hReBarTheme = NULL;
	m_nStateFlags = 0;
	m_pDockSite = NULL;
	m_pDockBar = NULL;
	m_pDockContext = NULL;
	m_dwStyle = 0;
	m_dwDockStyle = 0;
	m_nMRUWidth = 32767;
	m_pInPlaceOwner = NULL;
}


void CControlBar::SetInPlaceOwner(CWnd *pWnd)
{
	m_pInPlaceOwner = pWnd;
}

void CControlBar::SetBorders(int cxLeft, int cyTop, int cxRight, int cyBottom)
{
	ASSERT(cxLeft >= 0);
	ASSERT(cyTop >= 0);
	ASSERT(cxRight >= 0);
	ASSERT(cyBottom >= 0);

	m_cxLeftBorder = cxLeft;
	m_cyTopBorder = cyTop;
	m_cxRightBorder = cxRight;
	m_cyBottomBorder = cyBottom;
}

BOOL CControlBar::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	// force clipsliblings (otherwise will cause repaint problems)
	cs.style |= WS_CLIPSIBLINGS;

	// default border style translation for Win4
	//  (you can turn off this translation by setting CBRS_BORDER_3D)
	if ((m_dwStyle & CBRS_BORDER_3D) == 0)
	{
		DWORD dwNewStyle = 0;
		switch (m_dwStyle & (CBRS_BORDER_ANY|CBRS_ALIGN_ANY))
		{
		case CBRS_LEFT:
			dwNewStyle = CBRS_BORDER_TOP|CBRS_BORDER_BOTTOM;
			break;
		case CBRS_TOP:
			dwNewStyle = CBRS_BORDER_TOP;
			break;
		case CBRS_RIGHT:
			dwNewStyle = CBRS_BORDER_TOP|CBRS_BORDER_BOTTOM;
			break;
		case CBRS_BOTTOM:
			dwNewStyle = CBRS_BORDER_BOTTOM;
			break;
		}

		// set new style if it matched one of the predefined border types
		if (dwNewStyle != 0)
		{
			m_dwStyle &= ~(CBRS_BORDER_ANY);
			m_dwStyle |= (dwNewStyle | CBRS_BORDER_3D);
		}
	}

	return TRUE;
}

void CControlBar::SetBarStyle(DWORD dwStyle)
{
	ASSERT((dwStyle & CBRS_ALL) == dwStyle);

	EnableToolTips(dwStyle & CBRS_TOOLTIPS);

	if (m_dwStyle != dwStyle)
	{
		DWORD dwOldStyle = m_dwStyle;
		m_dwStyle = dwStyle;
		OnBarStyleChange(dwOldStyle, dwStyle);
	}
}

void CControlBar::OnBarStyleChange(DWORD, DWORD)
{
	// can be overridden in derived classes
}

BOOL CControlBar::AllocElements(int nElements, int cbElement)
{
	ASSERT_VALID(this);
	ENSURE_ARG(nElements >= 0 && cbElement >= 0);	
	ENSURE(m_pData != NULL || m_nCount == 0);

	// allocate new data if necessary
	void* pData = NULL;
	if (nElements > 0)
	{
		ENSURE_ARG(cbElement > 0);		
		if ((pData = calloc(nElements, cbElement)) == NULL)
			return FALSE;
	}
	free(m_pData);      // free old data

	// set new data and elements
	m_pData = pData;
	m_nCount = nElements;

	return TRUE;
}


CControlBar::~CControlBar()
{
	ASSERT_VALID(this);

	m_pInPlaceOwner = NULL;

	DestroyWindow();    // avoid PostNcDestroy problems

	// also done in OnDestroy, but done here just in case
	if (m_pDockSite != NULL)
		m_pDockSite->RemoveControlBar(this);

	// free docking context
	CDockContext* pDockContext = m_pDockContext;
	m_pDockContext = NULL;
	delete pDockContext;

	// free array
	if (m_pData != NULL)
	{
		ASSERT(m_nCount != 0);
		free(m_pData);
	}

	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	if (pModuleThreadState->m_pLastStatus == this)
	{
		pModuleThreadState->m_pLastStatus = NULL;
		pModuleThreadState->m_nLastStatus = static_cast<INT_PTR>(-1);
	}
}

void CControlBar::PostNcDestroy()
{
	if (m_bAutoDelete)      // Automatic cleanup?
		delete this;
}

/////////////////////////////////////////////////////////////////////////////
// Attributes

CSize CControlBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	CSize size;
	size.cx = (bStretch && bHorz ? 32767 : 0);
	size.cy = (bStretch && !bHorz ? 32767 : 0);
	return size;
}

CSize CControlBar::CalcDynamicLayout(int, DWORD nMode)
{
	return CalcFixedLayout(nMode & LM_STRETCH, nMode & LM_HORZ);
}

BOOL CControlBar::IsDockBar() const
{
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Fly-by status bar help

#define ID_TIMER_WAIT   0xE000  // timer while waiting to show status
#define ID_TIMER_CHECK  0xE001  // timer to check for removal of status

void CControlBar::ResetTimer(UINT_PTR nEvent, UINT nTime)
{
	KillTimer(ID_TIMER_WAIT);
	KillTimer(ID_TIMER_CHECK);
	VERIFY(SetTimer(nEvent, nTime, NULL));
}

void CControlBar::OnTimer(UINT_PTR nIDEvent)
{
	if (GetKeyState(VK_LBUTTON) < 0)
		return;

	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();

	// get current mouse position for hit test
	CPoint point; GetCursorPos(&point);
	ScreenToClient(&point);
	INT_PTR nHit = OnToolHitTest(point, NULL);
	if (nHit >= 0)
	{
		CWnd *pParent=GetTopLevelParent();
		// determine if status bar help should go away
        if(!IsTopParentActive())
        {
            nHit=-1;
        }
        else
        {
			ENSURE(pParent);
		    if(!pParent->IsWindowEnabled())
            {
			    nHit = -1;
            }
        }

		// remove status help if capture is set
		HWND hWndTip = pModuleThreadState->m_pToolTip->GetSafeHwnd();
		CWnd* pCapture = GetCapture();
		if (pCapture != this && pCapture->GetSafeHwnd() != hWndTip &&
			pCapture->GetTopLevelParent() == pParent)
		{
			nHit = -1;
		}
	}
	else
	{
		pModuleThreadState->m_nLastStatus = static_cast<INT_PTR>(-1);
	}

	// make sure it isn't over some other app's window
	if (nHit >= 0)
	{
		ClientToScreen(&point);
		HWND hWnd = ::WindowFromPoint(point);
		if (hWnd == NULL || (hWnd != m_hWnd && !::IsChild(m_hWnd, hWnd) &&
			pModuleThreadState->m_pToolTip->GetSafeHwnd() != hWnd))
		{
			nHit = -1;
			pModuleThreadState->m_nLastStatus = static_cast<INT_PTR>(-1);
		}
	}

	// handle the result
	if (nHit < 0)
	{
		if (pModuleThreadState->m_nLastStatus == static_cast<INT_PTR>(-1))
			KillTimer(ID_TIMER_CHECK);
		SetStatusText(static_cast<INT_PTR>(-1));
	}

	// set status text after initial timeout
	if (nIDEvent == ID_TIMER_WAIT)
	{
		KillTimer(ID_TIMER_WAIT);
		if (nHit >= 0)
			SetStatusText(nHit);
	}
}

#ifdef _WIN64
BOOL CControlBar::SetStatusText(int /* nHit */)
{
        return FALSE;
}
#endif

BOOL CControlBar::SetStatusText(INT_PTR nHit)
{
#ifdef _WIN64
        // Start by allowing historical MFC 7.0 64 bit overload a chance
        int niHit=nHit>0 ? 1 : -1;
        if(SetStatusText(niHit))
        {
            return TRUE;
        }
#endif

	CWnd* pOwner = GetOwner();

	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	if (nHit == -1)
	{
		// handle reset case
		pModuleThreadState->m_pLastStatus = NULL;
		if (m_nStateFlags & statusSet)
		{
			pOwner->SendMessage(WM_POPMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
			m_nStateFlags &= ~statusSet;
			return TRUE;
		}
		KillTimer(ID_TIMER_WAIT);
	}
	else
	{
		// handle setnew case
		if (!(m_nStateFlags & statusSet) || pModuleThreadState->m_nLastStatus != nHit)
		{
			pModuleThreadState->m_pLastStatus = this;
			pOwner->SendMessage(WM_SETMESSAGESTRING, nHit);
			m_nStateFlags |= statusSet;
			ResetTimer(ID_TIMER_CHECK, 200);
			return TRUE;
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Default control bar processing

BOOL CControlBar::PreTranslateMessage(MSG* pMsg)
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd != NULL);

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

	UINT message = pMsg->message;
	CWnd* pOwner = GetOwner();

	// handle CBRS_FLYBY style (status bar flyby help)
	if (((m_dwStyle & CBRS_FLYBY) ||
		message == WM_LBUTTONDOWN || message == WM_LBUTTONUP) &&
		((message >= WM_MOUSEFIRST && message <= AFX_WM_MOUSELAST) ||
		 (message >= WM_NCMOUSEFIRST && message <= WM_NCMOUSELAST)))
	{
	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();

		// gather information about current mouse position
		CPoint point = pMsg->pt;
		ScreenToClient(&point);
		TOOLINFO ti; memset(&ti, 0, sizeof(AFX_OLDTOOLINFO));
		ti.cbSize = sizeof(TOOLINFO);
		INT_PTR nHit = OnToolHitTest(point, &ti);
		if (ti.lpszText != LPSTR_TEXTCALLBACK)
			free(ti.lpszText);
		BOOL bNotButton =
			message == WM_LBUTTONDOWN && (ti.uFlags & TTF_NOTBUTTON);
		if (message != WM_LBUTTONDOWN && GetKeyState(VK_LBUTTON) < 0)
			nHit = pModuleThreadState->m_nLastStatus;

		// update state of status bar
		if (nHit < 0 || bNotButton)
		{
			if (GetKeyState(VK_LBUTTON) >= 0 || bNotButton)
			{
				SetStatusText(static_cast<INT_PTR>(-1));
				KillTimer(ID_TIMER_CHECK);
			}
		}
		else
		{
			if (message == WM_LBUTTONUP)
			{
				SetStatusText(static_cast<INT_PTR>(-1));
				ResetTimer(ID_TIMER_CHECK, 200);
			}
			else
			{
				if ((m_nStateFlags & statusSet) || GetKeyState(VK_LBUTTON) < 0)
					SetStatusText(nHit);
				else if (nHit != pModuleThreadState->m_nLastStatus)
					ResetTimer(ID_TIMER_WAIT, 300);
			}
		}
		pModuleThreadState->m_nLastStatus = nHit;
	}

	// don't translate dialog messages when in Shift+F1 help mode
	CFrameWnd* pFrameWnd = GetTopLevelFrame();
	if (pFrameWnd != NULL && pFrameWnd->m_bHelpMode)
		return FALSE;

	// since 'IsDialogMessage' will eat frame window accelerators,
	//   we call all frame windows' PreTranslateMessage first
	while (pOwner != NULL)
	{
		// allow owner & frames to translate before IsDialogMessage does
		if (pOwner->PreTranslateMessage(pMsg))
			return TRUE;

		// try parent frames until there are no parent frames
		pOwner = pOwner->GetParentFrame();
	}

	// filter both messages to dialog and from children
	if (::IsWindow(m_hWnd))
		return PreTranslateInput(pMsg);
	return FALSE;
}

LRESULT CControlBar::WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);

	LRESULT lResult;
	switch (nMsg)
	{
	case WM_NOTIFY:
	case WM_COMMAND:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_DELETEITEM:
	case WM_COMPAREITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
		// send these messages to the owner if not handled
		if (OnWndMsg(nMsg, wParam, lParam, &lResult))
			return lResult;
		else
		{

			if (m_pInPlaceOwner && nMsg == WM_COMMAND)
				lResult = m_pInPlaceOwner->SendMessage(nMsg, wParam, lParam);
			else
				lResult = GetOwner()->SendMessage(nMsg, wParam, lParam);

			// special case for TTN_NEEDTEXTA and TTN_NEEDTEXTW
			if(nMsg == WM_NOTIFY)
			{
				NMHDR* pNMHDR = (NMHDR*)lParam;
				if (pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW)
				{
					TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
					TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;

					if (pNMHDR->code == TTN_NEEDTEXTA)
					{
						if (pTTTA->hinst == 0 && (!pTTTA->lpszText || !*pTTTA->lpszText))
						{
							// not handled by owner, so let bar itself handle it
							lResult = CWnd::WindowProc(nMsg, wParam, lParam);
						}
					} else if (pNMHDR->code == TTN_NEEDTEXTW)
					{
						if (pTTTW->hinst == 0 && (!pTTTW->lpszText || !*pTTTW->lpszText))
						{
							// not handled by owner, so let bar itself handle it
							lResult = CWnd::WindowProc(nMsg, wParam, lParam);
						}
					}
				}
			}
			return lResult;
		}
	}

	// otherwise, just handle in default way
	lResult = CWnd::WindowProc(nMsg, wParam, lParam);
	return lResult;
}

LRESULT CControlBar::OnHelpHitTest(WPARAM, LPARAM lParam)
{
	ASSERT_VALID(this);

	INT_PTR nID = OnToolHitTest((DWORD)lParam, NULL);
	if (nID != -1)
		return HID_BASE_COMMAND+nID;

	nID = _AfxGetDlgCtrlID(m_hWnd);
	return nID != 0 ? HID_BASE_CONTROL+nID : 0;
}

void CControlBar::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	//  We call DefWindowProc here instead of CWnd::OnWindowPosChanging
	//  (which calls CWnd::Default, which calls through the super wndproc)
	//  because certain control bars that are system implemented (such as
	//  CToolBar with TBSTYLE_FLAT) do not implement WM_WINDOWPOSCHANGING
	//  correctly, causing repaint problems.  This code bypasses that whole
	//  mess.
	::DefWindowProc(m_hWnd, WM_WINDOWPOSCHANGING, 0, (LPARAM)lpWndPos);

	if (lpWndPos->flags & SWP_NOSIZE)
		return;

	// invalidate borders on the right
	CRect rect;
	GetWindowRect(&rect);
	CSize sizePrev = rect.Size();
	int cx = lpWndPos->cx;
	int cy = lpWndPos->cy;
	if (cx != sizePrev.cx && (m_dwStyle & CBRS_BORDER_RIGHT))
	{
		rect.SetRect(cx-afxData.cxBorder2, 0, cx, cy);
		InvalidateRect(&rect);
		rect.SetRect(sizePrev.cx-afxData.cxBorder2, 0, sizePrev.cx, cy);
		InvalidateRect(&rect);
	}

	// invalidate borders on the bottom
	if (cy != sizePrev.cy && (m_dwStyle & CBRS_BORDER_BOTTOM))
	{
		rect.SetRect(0, cy-afxData.cyBorder2, cx, cy);
		InvalidateRect(&rect);
		rect.SetRect(0, sizePrev.cy-afxData.cyBorder2, cx, sizePrev.cy);
		InvalidateRect(&rect);
	}
}

int CControlBar::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CWnd::OnCreate(lpcs) == -1)
		return -1;

	if (m_dwStyle & CBRS_TOOLTIPS)
		EnableToolTips();

	CFrameWnd *pFrameWnd = (CFrameWnd*)GetParent();
	if (pFrameWnd->IsFrameWnd())
	{
		m_pDockSite = pFrameWnd;
		m_pDockSite->AddControlBar(this);
	}

	if (IsKindOf(RUNTIME_CLASS(CToolBar)) || IsKindOf(RUNTIME_CLASS(CDockBar)))
	{
		if (CThemeHelper::IsAppThemed())
		{
			m_hReBarTheme = CThemeHelper::OpenThemeData(m_hWnd, VSCLASS_REBAR);
		}
	}
	return 0;
}

LRESULT CControlBar::OnThemeChanged()
{
	if (IsKindOf(RUNTIME_CLASS(CToolBar)) || IsKindOf(RUNTIME_CLASS(CDockBar)))
	{
		if (NULL != m_hReBarTheme)
		{
			CThemeHelper::CloseThemeData(m_hReBarTheme);
		}
		m_hReBarTheme = CThemeHelper::OpenThemeData(m_hWnd, VSCLASS_REBAR);
	}
	return 1;
}

void CControlBar::OnDestroy()
{
	if (IsKindOf(RUNTIME_CLASS(CToolBar)) || IsKindOf(RUNTIME_CLASS(CDockBar)))
	{
		if (CThemeHelper::IsAppThemed())
		{
			CThemeHelper::CloseThemeData(m_hReBarTheme);
		}
	}

	AFX_MODULE_THREAD_STATE* pModuleThreadState = AfxGetModuleThreadState();
	if (pModuleThreadState->m_pLastStatus == this)
	{
		SetStatusText(static_cast<INT_PTR>(-1));
		ASSERT(pModuleThreadState->m_pLastStatus == NULL);
	}

	if (m_pDockSite != NULL)
	{
		m_pDockSite->RemoveControlBar(this);
		m_pDockSite = NULL;
	}

	CWnd::OnDestroy();
}

BOOL CControlBar::DestroyWindow()
{
	if (m_hWnd != NULL && IsFloating())
		return GetDockingFrame()->DestroyWindow();
	else
		return CWnd::DestroyWindow();
}

int CControlBar::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT nMsg)
{
	// call default when toolbar is not floating
	if (!IsFloating())
		return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, nMsg);

	// special behavior when floating
	ActivateTopParent();

	return MA_NOACTIVATE;   // activation already done
}

void CControlBar::OnPaint()
{
	// background is already filled in gray
	CPaintDC dc(this);

	// erase background now
	if (IsVisible())
		DoPaint(&dc);       // delegate to paint helper
}

void CControlBar::EraseNonClient()
{
	// get window DC that is clipped to the non-client area
	CWindowDC dc(this);
	CRect rectClient;
	GetClientRect(rectClient);
	CRect rectWindow;
	GetWindowRect(rectWindow);
	ScreenToClient(rectWindow);
	rectClient.OffsetRect(-rectWindow.left, -rectWindow.top);
	dc.ExcludeClipRect(rectClient);


	// draw borders in non-client area
	rectWindow.OffsetRect(-rectWindow.left, -rectWindow.top);
	DrawBorders(&dc, rectWindow);

	// erase parts not drawn
	dc.IntersectClipRect(rectWindow);
	SendMessage(WM_ERASEBKGND, (WPARAM)dc.m_hDC);

	// draw gripper in non-client area
	DrawNCGripper(&dc, rectWindow);
}

HBRUSH CControlBar::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	LRESULT lResult;
	if (pWnd->SendChildNotifyLastMsg(&lResult))
		return (HBRUSH)lResult;     // eat it

	// force black text on gray background all the time
	if (!GrayCtlColor(pDC->m_hDC, pWnd->GetSafeHwnd(), nCtlColor,
	   afxData.hbrBtnFace, afxData.clrBtnText))
		return (HBRUSH)Default();
	return afxData.hbrBtnFace;
}

void CControlBar::OnLButtonDown(UINT nFlags, CPoint pt)
{
	// only start dragging if clicked in "void" space
	if (m_pDockBar != NULL && OnToolHitTest(pt, NULL) == -1)
	{
		// start the drag
		ASSERT(m_pDockContext != NULL);
		ClientToScreen(&pt);
		m_pDockContext->StartDrag(pt);
	}
	else
	{
		CWnd::OnLButtonDown(nFlags, pt);
	}
}

void CControlBar::OnLButtonDblClk(UINT nFlags, CPoint pt)
{
	// only toggle docking if clicked in "void" space
	if (m_pDockBar != NULL && OnToolHitTest(pt, NULL) == -1)
	{
		// start the drag
		ASSERT(m_pDockContext != NULL);
		m_pDockContext->ToggleDocking();
	}
	else
	{
		CWnd::OnLButtonDblClk(nFlags, pt);
	}
}

LRESULT CControlBar::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
	// handle delay hide/show
	BOOL bVis = GetStyle() & WS_VISIBLE;
	UINT swpFlags = 0;
	if ((m_nStateFlags & delayHide) && bVis)
		swpFlags = SWP_HIDEWINDOW;
	else if ((m_nStateFlags & delayShow) && !bVis)
		swpFlags = SWP_SHOWWINDOW;
	m_nStateFlags &= ~(delayShow|delayHide);
	if (swpFlags != 0)
	{
		SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
			SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
	}

	// the style must be visible and if it is docked
	// the dockbar style must also be visible
	if ((GetStyle() & WS_VISIBLE) &&
		(m_pDockBar == NULL || (m_pDockBar->GetStyle() & WS_VISIBLE)))
	{
		CFrameWnd* pTarget = (CFrameWnd*)GetOwner();
		if (pTarget == NULL || !pTarget->IsFrameWnd())
			pTarget = GetParentFrame();
		if (pTarget != NULL)
			OnUpdateCmdUI(pTarget, (BOOL)wParam);
	}
	return 0L;
}

void CControlBar::OnInitialUpdate()
{
	// update the indicators before becoming visible
	OnIdleUpdateCmdUI(TRUE, 0L);
}

DWORD CControlBar::RecalcDelayShow(AFX_SIZEPARENTPARAMS* lpLayout)
{
	ENSURE_ARG(lpLayout != NULL);
	// resize and reposition this control bar based on styles
	DWORD dwStyle = (m_dwStyle & (CBRS_ALIGN_ANY|CBRS_BORDER_ANY)) |
		(GetStyle() & WS_VISIBLE);

	// handle delay hide/show
	if (m_nStateFlags & (delayHide|delayShow))
	{
		UINT swpFlags = 0;
		if (m_nStateFlags & delayHide)
		{
			ASSERT((m_nStateFlags & delayShow) == 0);
			if (dwStyle & WS_VISIBLE)
				swpFlags = SWP_HIDEWINDOW;
		}
		else
		{
			ASSERT(m_nStateFlags & delayShow);
			if ((dwStyle & WS_VISIBLE) == 0)
				swpFlags = SWP_SHOWWINDOW;
		}
		if (swpFlags != 0)
		{
			// make the window seem visible/hidden
			dwStyle ^= WS_VISIBLE;
			if (lpLayout->hDWP != NULL)
			{
				// clear delay flags
				m_nStateFlags &= ~(delayShow|delayHide);
				// hide/show the window if actually doing layout
				lpLayout->hDWP = ::DeferWindowPos(lpLayout->hDWP, m_hWnd, NULL,
					0, 0, 0, 0, swpFlags|
					SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
			}
		}
		else
		{
			// clear delay flags -- window is already in correct state
			m_nStateFlags &= ~(delayShow|delayHide);
		}
	}
	return dwStyle; // return new style
}

LRESULT CControlBar::OnSizeParent(WPARAM, LPARAM lParam)
{
	AFX_SIZEPARENTPARAMS* lpLayout = (AFX_SIZEPARENTPARAMS*)lParam;
	DWORD dwStyle = RecalcDelayShow(lpLayout);

	if ((dwStyle & WS_VISIBLE) && (dwStyle & CBRS_ALIGN_ANY) != 0)
	{
		// align the control bar
		CRect rect;
		rect.CopyRect(&lpLayout->rect);

		CSize sizeAvail = rect.Size();  // maximum size available

		// get maximum requested size
		DWORD dwMode = lpLayout->bStretch ? LM_STRETCH : 0;
		if ((m_dwStyle & CBRS_SIZE_DYNAMIC) && m_dwStyle & CBRS_FLOATING)
			dwMode |= LM_HORZ | LM_MRUWIDTH;
		else if (dwStyle & CBRS_ORIENT_HORZ)
			dwMode |= LM_HORZ | LM_HORZDOCK;
		else
			dwMode |=  LM_VERTDOCK;

		CSize size = CalcDynamicLayout(-1, dwMode);

		size.cx = min(size.cx, sizeAvail.cx);
		size.cy = min(size.cy, sizeAvail.cy);

		if (dwStyle & CBRS_ORIENT_HORZ)
		{
			lpLayout->sizeTotal.cy += size.cy;
			lpLayout->sizeTotal.cx = max(lpLayout->sizeTotal.cx, size.cx);
			if (dwStyle & CBRS_ALIGN_TOP)
				lpLayout->rect.top += size.cy;
			else if (dwStyle & CBRS_ALIGN_BOTTOM)
			{
				rect.top = rect.bottom - size.cy;
				lpLayout->rect.bottom -= size.cy;
			}
		}
		else if (dwStyle & CBRS_ORIENT_VERT)
		{
			lpLayout->sizeTotal.cx += size.cx;
			lpLayout->sizeTotal.cy = max(lpLayout->sizeTotal.cy, size.cy);
			if (dwStyle & CBRS_ALIGN_LEFT)
				lpLayout->rect.left += size.cx;
			else if (dwStyle & CBRS_ALIGN_RIGHT)
			{
				rect.left = rect.right - size.cx;
				lpLayout->rect.right -= size.cx;
			}
		}
		else
		{
			ASSERT(FALSE);      // can never happen
		}

		rect.right = rect.left + size.cx;
		rect.bottom = rect.top + size.cy;

		// only resize the window if doing layout and not just rect query
		if (lpLayout->hDWP != NULL)
			AfxRepositionWindow(lpLayout, m_hWnd, &rect);
	}
	return 0;
}

void CControlBar::DelayShow(BOOL bShow)
{
	m_nStateFlags &= ~(delayHide|delayShow);
	if (bShow && (GetStyle() & WS_VISIBLE) == 0)
		m_nStateFlags |= delayShow;
	else if (!bShow && (GetStyle() & WS_VISIBLE) != 0)
		m_nStateFlags |= delayHide;
}

BOOL CControlBar::IsVisible() const
{
	if (m_nStateFlags & delayHide)
		return FALSE;

	if ((m_nStateFlags & delayShow) || ((GetStyle() & WS_VISIBLE) != 0))
		return TRUE;

	return FALSE;
}

void CControlBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	// paint inside client area
	CRect rect;
	GetClientRect(rect);
	DrawBorders(pDC, rect);
	DrawGripper(pDC, rect);
}

void CControlBar::DrawBorders(CDC* pDC, CRect& rect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	DWORD dwStyle = m_dwStyle;
	if (!(dwStyle & CBRS_BORDER_ANY))
		return;

	// prepare for dark lines
	ASSERT(rect.top == 0 && rect.left == 0);
	CRect rect1, rect2;
	rect1 = rect;
	rect2 = rect;
	COLORREF clr = afxData.clrBtnShadow;


	// draw dark line one pixel back/up
	if (dwStyle & CBRS_BORDER_3D)
	{
		rect1.right -= AFX_CX_BORDER;
		rect1.bottom -= AFX_CY_BORDER;
	}
	if (dwStyle & CBRS_BORDER_TOP)
		rect2.top += afxData.cyBorder2;
	if (dwStyle & CBRS_BORDER_BOTTOM)
		rect2.bottom -= afxData.cyBorder2;

	if (IsKindOf(RUNTIME_CLASS(CToolBar)) && (dwStyle & TBSTYLE_FLAT) && (dwStyle & CBRS_BORDER_ANY))
	{
		CRect rctBk;
		rctBk.left = 0;
		rctBk.right = rect.right;
		rctBk.top = rect.top;
		rctBk.bottom = rect.bottom;

		HRESULT hr = E_FAIL;

		if (m_hReBarTheme)
		{
			if (CThemeHelper::IsThemeBackgroundPartiallyTransparent(m_hReBarTheme, RP_BACKGROUND, 0 /* No states defined */))
			{
				CThemeHelper::DrawThemeParentBackground(m_hWnd, pDC->m_hDC, &rctBk);
			}

			hr = CThemeHelper::DrawThemeBackground(m_hReBarTheme, pDC->m_hDC, RP_BACKGROUND,
									 0 /* No states defined */,&rctBk, NULL);
		}

		if (FAILED(hr))
		{
			pDC->FillSolidRect((LPRECT)rctBk, pDC->GetBkColor());
		}
	}

	// draw left and top
	if (dwStyle & CBRS_BORDER_LEFT)
		pDC->FillSolidRect(0, rect2.top, AFX_CX_BORDER, rect2.Height(), clr);
	if (dwStyle & CBRS_BORDER_TOP)
		pDC->FillSolidRect(0, 0, rect.right, AFX_CY_BORDER, clr);

	// draw right and bottom
	if (dwStyle & CBRS_BORDER_RIGHT)
		pDC->FillSolidRect(rect1.right, rect2.top, -AFX_CX_BORDER, rect2.Height(), clr);
	if (dwStyle & CBRS_BORDER_BOTTOM)
		pDC->FillSolidRect(0, rect1.bottom, rect.right, -AFX_CY_BORDER, clr);


	if (dwStyle & CBRS_BORDER_3D)
	{
		// prepare for hilite lines
		clr = afxData.clrBtnHilite;

		// draw left and top
		if (dwStyle & CBRS_BORDER_LEFT)
			pDC->FillSolidRect(1, rect2.top, AFX_CX_BORDER, rect2.Height(), clr);
		if (dwStyle & CBRS_BORDER_TOP)
			pDC->FillSolidRect(0, 1, rect.right, AFX_CY_BORDER, clr);

		// draw right and bottom
		if (dwStyle & CBRS_BORDER_RIGHT)
			pDC->FillSolidRect(rect.right, rect2.top, -AFX_CX_BORDER, rect2.Height(), clr);
		if (dwStyle & CBRS_BORDER_BOTTOM)
			pDC->FillSolidRect(0, rect.bottom, rect.right, -AFX_CY_BORDER, clr);
	}

	if (dwStyle & CBRS_BORDER_LEFT)
		rect.left += afxData.cxBorder2;
	if (dwStyle & CBRS_BORDER_TOP)
		rect.top += afxData.cyBorder2;
	if (dwStyle & CBRS_BORDER_RIGHT)
		rect.right -= afxData.cxBorder2;
	if (dwStyle & CBRS_BORDER_BOTTOM)
		rect.bottom -= afxData.cyBorder2;

}

#define AFX_CX_GRIPPER  3
#define AFX_CY_GRIPPER  3
#define AFX_CX_BORDER_GRIPPER 2
#define AFX_CY_BORDER_GRIPPER 2

BOOL CControlBar::DrawNonThemedGripper(CDC* pDC, const CRect& rect)
{
	ENSURE_ARG( pDC );

	// draw the gripper in the border
	if (m_dwStyle & CBRS_ORIENT_HORZ)
	{
		pDC->Draw3dRect(rect.left+AFX_CX_BORDER_GRIPPER,
			rect.top+m_cyTopBorder,
			AFX_CX_GRIPPER, rect.Height()-m_cyTopBorder-m_cyBottomBorder,
			afxData.clrBtnHilite, afxData.clrBtnShadow);
	}
	else
	{
		pDC->Draw3dRect(rect.left+m_cyTopBorder,
			rect.top+AFX_CY_BORDER_GRIPPER,
			rect.Width()-m_cyTopBorder-m_cyBottomBorder, AFX_CY_GRIPPER,
			afxData.clrBtnHilite, afxData.clrBtnShadow);
	}
	return TRUE;
}

BOOL CControlBar::DrawThemedGripper(CDC* pDC, const CRect& rect, BOOL fCentered)
{
	ENSURE_ARG( pDC );

	int nPartId;
	RECT rectGripper;
	HRESULT hr = E_FAIL;

	if (NULL == m_hReBarTheme)
	{
		return FALSE;
	}

	CRect rectClient;
	CRect clipRect;
	if( fCentered )
	{
		GetClientRect(rectClient);
		CRect rectWindow;
		GetWindowRect(rectWindow);
		ScreenToClient(rectWindow);
		rectClient.OffsetRect(-rectWindow.left, -rectWindow.top);
	}


	if (m_dwStyle & CBRS_ORIENT_HORZ)
	{
		SIZE size;

		nPartId = RP_GRIPPERVERT;
		hr = CThemeHelper::GetThemePartSize(m_hReBarTheme, pDC->m_hDC, nPartId,
								 0, NULL, TS_TRUE, &size);
		if (FAILED(hr))
		{
			return FALSE;
		}

		if( fCentered )
		{
			int nAvailable = rectClient.left - rect.left;
			if( nAvailable < size.cx )
			{
				// Needed for linear distribution around the 0.
				--nAvailable;
			}
			rectGripper.left = rect.left + (( nAvailable - size.cx ) / 2 );
		}
		else
		{
			rectGripper.left = rect.left;
		}
		rectGripper.top = rect.top + m_cyTopBorder;
		rectGripper.right = rectGripper.left + size.cx;
		rectGripper.bottom = rectGripper.top + ( rect.Height() - m_cyTopBorder-m_cyBottomBorder );

		clipRect.left = rect.left;
		clipRect.right =  rectClient.left;
		clipRect.top = rectGripper.top;
		clipRect.bottom = rectGripper.bottom;
	}
	else
	{
		SIZE size;

		nPartId = RP_GRIPPER;
		hr = CThemeHelper::GetThemePartSize(m_hReBarTheme, pDC->m_hDC, nPartId,
								 0, NULL, TS_TRUE, &size);
		if (FAILED(hr))
		{
			return FALSE;
		}

		if( fCentered )
		{
			int nAvailable = rectClient.top - rect.top;
			if( nAvailable < size.cy )
			{
				// Needed for linear distribution around the 0.
				--nAvailable;
			}
			rectGripper.top = rect.top + (( nAvailable - size.cy ) / 2);
		}
		else
		{
			rectGripper.top = rect.top;
		}
		rectGripper.left = rect.left + m_cyTopBorder;
		rectGripper.right = rectGripper.left + ( rect.Width() - m_cyTopBorder - m_cyBottomBorder );
		rectGripper.bottom = rectGripper.top + size.cy;

		clipRect.left = rectGripper.left;
		clipRect.right = rectGripper.right;
		clipRect.top = rect.top;
		clipRect.bottom = rectClient.top;
	}

	hr = CThemeHelper::DrawThemeBackground(m_hReBarTheme, pDC->m_hDC, nPartId,
				0, &rectGripper, &clipRect);

	if (FAILED(hr))
	{
		return FALSE;
	}
	return TRUE;
}

void CControlBar::DrawGripper(CDC* pDC, const CRect& rect)
{
	ENSURE_ARG( pDC );

	if ((m_dwStyle & (CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
	{
		if (!DrawThemedGripper( pDC, rect , FALSE))
		{
			DrawNonThemedGripper( pDC, rect );
		}
	}
}

void CControlBar::DrawNCGripper(CDC* pDC, const CRect& rect)
{
	ENSURE_ARG( pDC );

	if ((m_dwStyle & (CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
	{
		if (!DrawThemedGripper( pDC, rect , TRUE))
		{
			DrawNonThemedGripper( pDC, rect );
		}
	}
}


// input CRect should be client rectangle size
void CControlBar::CalcInsideRect(CRect& rect, BOOL bHorz) const
{
	ASSERT_VALID(this);
	DWORD dwStyle = m_dwStyle;

	if (dwStyle & CBRS_BORDER_LEFT)
		rect.left += afxData.cxBorder2;
	if (dwStyle & CBRS_BORDER_TOP)
		rect.top += afxData.cyBorder2;
	if (dwStyle & CBRS_BORDER_RIGHT)
		rect.right -= afxData.cxBorder2;
	if (dwStyle & CBRS_BORDER_BOTTOM)
		rect.bottom -= afxData.cyBorder2;

	// inset the top and bottom.
	if (bHorz)
	{
		rect.left += m_cxLeftBorder;
		rect.top += m_cyTopBorder;
		rect.right -= m_cxRightBorder;
		rect.bottom -= m_cyBottomBorder;
		if ((m_dwStyle & (CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
			rect.left += AFX_CX_BORDER_GRIPPER+AFX_CX_GRIPPER+AFX_CX_BORDER_GRIPPER;
	}
	else
	{
		rect.left += m_cyTopBorder;
		rect.top += m_cxLeftBorder;
		rect.right -= m_cyBottomBorder;
		rect.bottom -= m_cxRightBorder;
		if ((m_dwStyle & (CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER)
			rect.top += AFX_CY_BORDER_GRIPPER+AFX_CY_GRIPPER+AFX_CY_BORDER_GRIPPER;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CControlBar diagnostics

#ifdef _DEBUG
void CControlBar::AssertValid() const
{
	CWnd::AssertValid();

	ASSERT(m_nCount == 0 || m_pData != NULL);
	ASSERT((m_dwStyle & CBRS_ALL) == m_dwStyle);
}

void CControlBar::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	dc << "\nm_cxLeftBorder = " << m_cxLeftBorder;
	dc << "\nm_cxRightBorder = " << m_cxRightBorder;
	dc << "\nm_cyTopBorder = " << m_cyTopBorder;
	dc << "\nm_cyBottomBorder = " << m_cyBottomBorder;
	dc << "\nm_cxDefaultGap = " << m_cxDefaultGap;
	dc << "\nm_nCount = " << m_nCount;
	dc << "\nm_bAutoDelete = " << m_bAutoDelete;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\bardock.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CDockBar

BEGIN_MESSAGE_MAP(CDockBar, CControlBar)
	//{{AFX_MSG_MAP(CDockBar)
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_MESSAGE(WM_SIZEPARENT, &CDockBar::OnSizeParent)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDockBar construction

CDockBar::CDockBar(BOOL bFloating)
{
	m_bFloating = bFloating;
	m_bAutoDelete = TRUE;
	m_arrBars.Add(NULL);
	m_bLayoutQuery = FALSE;
	m_rectLayout.SetRectEmpty();

	// assume no margins
	m_cxLeftBorder = m_cxRightBorder = m_cyBottomBorder = m_cyTopBorder = 0;
}

CDockBar::~CDockBar()
{
	for (int i = 0; i < m_arrBars.GetSize(); i++)
	{
		CControlBar* pBar = GetDockedControlBar(i);
		if (pBar != NULL && pBar->m_pDockBar == this)
			pBar->m_pDockBar = NULL;
	}
}

BOOL CDockBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	ENSURE_VALID(pParentWnd);
	ASSERT_KINDOF(CFrameWnd, pParentWnd);

	// save the style
	m_dwStyle = (dwStyle & CBRS_ALL);

	VERIFY(AfxDeferRegisterClass(AFX_WNDCONTROLBAR_REG));

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();

	// Note: Parent must resize itself for control bar to be resized
	return CWnd::Create(_afxWndControlBar, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CDockBar::IsDockBar() const
{
	return TRUE;
}

int CDockBar::GetDockedCount() const
{
	int nCount = 0;
	for (int i = 0; i < m_arrBars.GetSize(); i++)
	{
		if (GetDockedControlBar(i) != NULL)
			nCount++;
	}
	return nCount;
}

int CDockBar::GetDockedVisibleCount() const
{
	int nCount = 0;
	for (int i = 0; i < m_arrBars.GetSize(); i++)
	{
		CControlBar* pBar = STATIC_DOWNCAST(CControlBar, (CObject*)GetDockedControlBar(i));
		if (pBar != NULL && pBar->IsVisible())
			nCount++;
	}
	return nCount;
}

/////////////////////////////////////////////////////////////////////////////
// CDockBar operations

void CDockBar::DockControlBar(CControlBar* pBar, LPCRECT lpRect)
{
	ENSURE_VALID(this);
	ENSURE_VALID(pBar);
	ASSERT_KINDOF(CControlBar, pBar);

	CRect rectBar;
	pBar->GetWindowRect(&rectBar);
	if (pBar->m_pDockBar == this && (lpRect == NULL || rectBar == *lpRect))
	{
		// already docked and no change in position
		return;
	}

	// set CBRS_FLOAT_MULTI style if docking bar has it
	if (m_bFloating && (pBar->m_dwDockStyle & CBRS_FLOAT_MULTI))
		m_dwStyle |= CBRS_FLOAT_MULTI;

	m_dwStyle &= ~(CBRS_SIZE_FIXED | CBRS_SIZE_DYNAMIC);
	m_dwStyle |= pBar->m_dwStyle & (CBRS_SIZE_FIXED | CBRS_SIZE_DYNAMIC);

	if (!(m_dwStyle & CBRS_FLOAT_MULTI))
	{
		TCHAR szTitle[_MAX_PATH];
		pBar->GetWindowText(szTitle, _countof(szTitle));
		AfxSetWindowText(m_hWnd, szTitle);
	}

	// align correctly and turn on all borders
	DWORD dwStyle = pBar->GetBarStyle();
	dwStyle &= ~(CBRS_ALIGN_ANY);
	dwStyle |=  (m_dwStyle & CBRS_ALIGN_ANY) | CBRS_BORDER_ANY;

	if (m_bFloating)
		dwStyle |= CBRS_FLOATING;
	else
		dwStyle &= ~CBRS_FLOATING;

	pBar->SetBarStyle(dwStyle);

	// hide first if changing to a new docking site to avoid flashing
	BOOL bShow = FALSE;
	if (pBar->m_pDockBar != this && pBar->IsWindowVisible())
	{
		pBar->SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_HIDEWINDOW);
		bShow = TRUE;
	}

	int nPos = -1;
	if (lpRect != NULL)
	{
		// insert into appropriate row
		CRect rect(lpRect);
		ScreenToClient(&rect);
		CPoint ptMid(rect.left + rect.Width()/2, rect.top + rect.Height()/2);
		nPos = Insert(pBar, rect, ptMid);

		// position at requested position
		pBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(),
			rect.Height(), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS);
	}
	else
	{
		// always add on current row, then create new one
		m_arrBars.Add(pBar);
		m_arrBars.Add(NULL);

		// align off the edge initially
		pBar->SetWindowPos(NULL, -afxData.cxBorder2, -afxData.cyBorder2, 0, 0,
			SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS);
	}

	// attach it to the docking site
	if (pBar->GetParent() != this)
		pBar->SetParent(this);
	if (pBar->m_pDockBar == this)
		pBar->m_pDockBar->RemoveControlBar(pBar, nPos);
	else if (pBar->m_pDockBar != NULL)
		pBar->m_pDockBar->RemoveControlBar(pBar, -1, m_bFloating && !pBar->m_pDockBar->m_bFloating);
	pBar->m_pDockBar = this;

	if (bShow)
	{
		ASSERT(!pBar->IsWindowVisible());
		pBar->SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_SHOWWINDOW);
	}

	// remove any place holder for pBar in this dockbar
	RemovePlaceHolder(pBar);

	// get parent frame for recalc layout
	CFrameWnd* pFrameWnd = GetDockingFrame();
	pFrameWnd->DelayRecalcLayout();
}

void CDockBar::ReDockControlBar(CControlBar* pBar, LPCRECT lpRect)
{
	ENSURE_VALID(this);
	ENSURE_VALID(pBar);
	ASSERT_KINDOF(CControlBar, pBar);
	ASSERT(pBar->m_pDockBar != this); // can't redock here if already docked here

	CRect rectBar;
	pBar->GetWindowRect(&rectBar);
	if (pBar->m_pDockBar == this && (lpRect == NULL || rectBar == *lpRect))
	{
		// already docked and no change in position
		return;
	}

	// set CBRS_FLOAT_MULTI style if docking bar has it
	if (m_bFloating && (pBar->m_dwDockStyle & CBRS_FLOAT_MULTI))
		m_dwStyle |= CBRS_FLOAT_MULTI;

	m_dwStyle &= ~(CBRS_SIZE_FIXED | CBRS_SIZE_DYNAMIC);
	m_dwStyle |= pBar->m_dwStyle & (CBRS_SIZE_FIXED | CBRS_SIZE_DYNAMIC);

	if (!(m_dwStyle & CBRS_FLOAT_MULTI))
	{
		TCHAR szTitle[_MAX_PATH];
		pBar->GetWindowText(szTitle, _countof(szTitle));
		AfxSetWindowText(m_hWnd, szTitle);
	}

	// align correctly and turn on all borders
	DWORD dwStyle = pBar->GetBarStyle();
	dwStyle &= ~(CBRS_ALIGN_ANY);
	dwStyle |=  (m_dwStyle & CBRS_ALIGN_ANY) | CBRS_BORDER_ANY;

	if (m_bFloating)
		dwStyle |= CBRS_FLOATING;
	else
		dwStyle &= ~CBRS_FLOATING;

	pBar->SetBarStyle(dwStyle);

	int nPos = FindBar((CControlBar*)(DWORD_PTR)_AfxGetDlgCtrlID(pBar->m_hWnd));
	if (nPos > 0)
		m_arrBars[nPos] = pBar;

	if (lpRect != NULL)
	{
		CRect rect(lpRect);
		ScreenToClient(&rect);

		if (nPos < 1)
		{
			CPoint ptMid(rect.left + rect.Width()/2, rect.top + rect.Height()/2);
			nPos = Insert(pBar, rect, ptMid);
		}

		// position at requested position
		pBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(),
			rect.Height(), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS);
	}
	else
	{
		if (nPos < 1)
		{
			// always add on current row, then create new one
			m_arrBars.Add(pBar);
			m_arrBars.Add(NULL);
		}

		// align off the edge initially
		pBar->SetWindowPos(NULL, -afxData.cxBorder2, -afxData.cyBorder2, 0, 0,
			SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS);
	}

	// attach it to the docking site
	if (pBar->GetParent() != this)
		pBar->SetParent(this);
	if (pBar->m_pDockBar != NULL)
		pBar->m_pDockBar->RemoveControlBar(pBar);
	pBar->m_pDockBar = this;

	// get parent frame for recalc layout
	CFrameWnd* pFrameWnd = GetDockingFrame();
	pFrameWnd->DelayRecalcLayout();
}

void CDockBar::RemovePlaceHolder(CControlBar* pBar)
{
	// remove remembered docking position
	if (DWORD_PTR(pBar) > 0xffff)
		pBar = (CControlBar*)(DWORD_PTR)_AfxGetDlgCtrlID(pBar->m_hWnd);
	int nOldPos = FindBar(pBar);
	if (nOldPos > 0)
	{
		m_arrBars.RemoveAt(nOldPos);

		// remove section indicator (NULL) if nothing else in section
		if (m_arrBars[nOldPos-1] == NULL && m_arrBars[nOldPos] == NULL)
			m_arrBars.RemoveAt(nOldPos);
	}
}

BOOL CDockBar::RemoveControlBar(CControlBar* pBar, int nPosExclude, int nAddPlaceHolder)
{
	ASSERT(nAddPlaceHolder == 1 || nAddPlaceHolder == 0 || nAddPlaceHolder == -1);
	ENSURE_VALID(this);
	ENSURE_VALID(pBar);
	int nPos = FindBar(pBar, nPosExclude);
	ENSURE(nPos > 0);

	if (nAddPlaceHolder == 1)
	{
		m_arrBars[nPos] = (void*)(DWORD_PTR)_AfxGetDlgCtrlID(pBar->m_hWnd);

		// check for already existing place holder
		int nPosOld = FindBar((CControlBar*)m_arrBars[nPos], nPos);
		if (nPosOld > 0)
		{
			m_arrBars.RemoveAt(nPos);

			// remove section indicator (NULL) if nothing else in section
			if (m_arrBars[nPos-1] == NULL && m_arrBars[nPos] == NULL)
				m_arrBars.RemoveAt(nPos);
		}
	}
	else
	{
		m_arrBars.RemoveAt(nPos);
		if (m_arrBars[nPos-1] == NULL && m_arrBars[nPos] == NULL)
			m_arrBars.RemoveAt(nPos);

		// Remove any pre-existing place holders.
		if (nAddPlaceHolder != -1)
			RemovePlaceHolder(pBar);
	}

	// don't do anything more in the shutdown case!
	if (pBar->m_pDockContext == NULL)
		return FALSE;

	// get parent frame for recalc layout/frame destroy
	CFrameWnd* pFrameWnd = GetDockingFrame();
	if (m_bFloating && GetDockedVisibleCount() == 0)
	{
		if (GetDockedCount() == 0)
		{
			pFrameWnd->DestroyWindow();
			return TRUE; // Self-Destruct
		}
		else
			pFrameWnd->ShowWindow(SW_HIDE);
	}
	else
		pFrameWnd->DelayRecalcLayout();

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CDockBar layout

CSize CDockBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	ENSURE_VALID(this);

	CSize sizeFixed = CControlBar::CalcFixedLayout(bStretch, bHorz);

	// get max size
	CSize sizeMax;
	if (!m_rectLayout.IsRectEmpty())
	{
		CRect rect = m_rectLayout;
		CalcInsideRect(rect, bHorz);
		sizeMax = rect.Size();
	}
	else
	{
		CRect rectFrame;
		CFrameWnd* pFrame = EnsureParentFrame();
		pFrame->GetClientRect(&rectFrame);
		sizeMax = rectFrame.Size();
	}

	// prepare for layout
	AFX_SIZEPARENTPARAMS layout;
	layout.hDWP = m_bLayoutQuery ?
		NULL : ::BeginDeferWindowPos((int)m_arrBars.GetSize());
	CPoint pt(-afxData.cxBorder2, -afxData.cyBorder2);
	int nWidth = 0;

	BOOL bWrapped = FALSE;

	// layout all the control bars
	for (int nPos = 0; nPos < m_arrBars.GetSize(); nPos++)
	{
		CControlBar* pBar = GetDockedControlBar(nPos);
		void* pVoid = m_arrBars[nPos];

		if (pBar != NULL)
		{
			if (pBar->IsVisible())
			{
				// get ideal rect for bar
				DWORD dwMode = 0;
				if ((pBar->m_dwStyle & CBRS_SIZE_DYNAMIC) &&
					(pBar->m_dwStyle & CBRS_FLOATING))
					dwMode |= LM_HORZ | LM_MRUWIDTH;
				else if (pBar->m_dwStyle & CBRS_ORIENT_HORZ)
					dwMode |= LM_HORZ | LM_HORZDOCK;
				else
					dwMode |=  LM_VERTDOCK;

				CSize sizeBar = pBar->CalcDynamicLayout(-1, dwMode);

				CRect rect(pt, sizeBar);

				// get current rect for bar
				CRect rectBar;
				pBar->GetWindowRect(&rectBar);
				ScreenToClient(&rectBar);

				if (bHorz)
				{
					// Offset Calculated Rect out to Actual
					if (rectBar.left > rect.left && !m_bFloating)
						rect.OffsetRect(rectBar.left - rect.left, 0);

					// If ControlBar goes off the right, then right justify
					if (rect.right > sizeMax.cx && !m_bFloating)
					{
						int x = rect.Width() - afxData.cxBorder2;
						x = max(sizeMax.cx - x, pt.x);
						rect.OffsetRect(x - rect.left, 0);
					}

					// If ControlBar has been wrapped, then left justify
					if (bWrapped)
					{
						bWrapped = FALSE;
						rect.OffsetRect(-(rect.left + afxData.cxBorder2), 0);
					}
					// If ControlBar is completely invisible, then wrap it
					else if ((rect.left >= (sizeMax.cx - afxData.cxBorder2)) &&
						(nPos > 0) && (m_arrBars[nPos - 1] != NULL))
					{
						m_arrBars.InsertAt(nPos, (CObject*)NULL);
						pBar = NULL; pVoid = NULL;
						bWrapped = TRUE;
					}
					if (!bWrapped)
					{
						if (rect != rectBar)
						{
							if (!m_bLayoutQuery &&
								!(pBar->m_dwStyle & CBRS_FLOATING))
							{
								pBar->m_pDockContext->m_rectMRUDockPos = rect;
							}
							AfxRepositionWindow(&layout, pBar->m_hWnd, &rect);
						}
						pt.x = rect.left + sizeBar.cx - afxData.cxBorder2;
						nWidth = max(nWidth, sizeBar.cy);
					}
				}
				else
				{
					// Offset Calculated Rect out to Actual
					if (rectBar.top > rect.top && !m_bFloating)
						rect.OffsetRect(0, rectBar.top - rect.top);

					// If ControlBar goes off the bottom, then bottom justify
					if (rect.bottom > sizeMax.cy && !m_bFloating)
					{
						int y = rect.Height() - afxData.cyBorder2;
						y = max(sizeMax.cy - y, pt.y);
						rect.OffsetRect(0, y - rect.top);
					}

					// If ControlBar has been wrapped, then top justify
					if (bWrapped)
					{
						bWrapped = FALSE;
						rect.OffsetRect(0, -(rect.top + afxData.cyBorder2));
					}
					// If ControlBar is completely invisible, then wrap it
					else if ((rect.top >= (sizeMax.cy - afxData.cyBorder2)) &&
						(nPos > 0) && (m_arrBars[nPos - 1] != NULL))
					{
						m_arrBars.InsertAt(nPos, (CObject*)NULL);
						pBar = NULL; pVoid = NULL;
						bWrapped = TRUE;
					}
					if (!bWrapped)
					{
						if (rect != rectBar)
						{
							if (!m_bLayoutQuery &&
								!(pBar->m_dwStyle & CBRS_FLOATING))
							{
								pBar->m_pDockContext->m_rectMRUDockPos = rect;
							}
							AfxRepositionWindow(&layout, pBar->m_hWnd, &rect);
						}
						pt.y = rect.top + sizeBar.cy - afxData.cyBorder2;
						nWidth = max(nWidth, sizeBar.cx);
					}
				}
			}
			if (!bWrapped)
			{
				// handle any delay/show hide for the bar
				pBar->RecalcDelayShow(&layout);
			}
		}
		if (pBar == NULL && pVoid == NULL && nWidth != 0)
		{
			// end of row because pBar == NULL
			if (bHorz)
			{
				pt.y += nWidth - afxData.cyBorder2;
				sizeFixed.cx = max(sizeFixed.cx, pt.x);
				sizeFixed.cy = max(sizeFixed.cy, pt.y);
				pt.x = -afxData.cxBorder2;
			}
			else
			{
				pt.x += nWidth - afxData.cxBorder2;
				sizeFixed.cx = max(sizeFixed.cx, pt.x);
				sizeFixed.cy = max(sizeFixed.cy, pt.y);
				pt.y = -afxData.cyBorder2;
			}
			nWidth = 0;
		}
	}
	if (!m_bLayoutQuery)
	{
		// move and resize all the windows at once!
		if (layout.hDWP == NULL || !::EndDeferWindowPos(layout.hDWP))
			TRACE(traceAppMsg, 0, "Warning: DeferWindowPos failed - low system resources.\n");
	}

	// adjust size for borders on the dock bar itself
	CRect rect;
	rect.SetRectEmpty();
	CalcInsideRect(rect, bHorz);

	if ((!bStretch || !bHorz) && sizeFixed.cx != 0)
		sizeFixed.cx += -rect.right + rect.left;
	if ((!bStretch || bHorz) && sizeFixed.cy != 0)
		sizeFixed.cy += -rect.bottom + rect.top;

	return sizeFixed;
}

LRESULT CDockBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
	AFX_SIZEPARENTPARAMS* lpLayout = (AFX_SIZEPARENTPARAMS*)lParam;

	// set m_bLayoutQuery to TRUE if lpLayout->hDWP == NULL
	BOOL bLayoutQuery = m_bLayoutQuery;
	CRect rectLayout = m_rectLayout;
	m_bLayoutQuery = (lpLayout->hDWP == NULL);
	m_rectLayout = lpLayout->rect;
	LRESULT lResult = CControlBar::OnSizeParent(wParam, lParam);
	// restore m_bLayoutQuery
	m_bLayoutQuery = bLayoutQuery;
	m_rectLayout = rectLayout;

	return lResult;
}

/////////////////////////////////////////////////////////////////////////////
// CDockBar message handlers

void CDockBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS* lpncsp)
{
	// calculate border space (will add to top/bottom, subtract from right/bottom)
	CRect rect;
	rect.SetRectEmpty();
	CalcInsideRect(rect, m_dwStyle & CBRS_ORIENT_HORZ);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

BOOL CDockBar::OnEraseBkgnd(CDC* pDC)
{
	ENSURE_ARG( NULL != pDC );

	CRect rect;
	GetClientRect(rect);

	if (m_hReBarTheme)
	{
		HRESULT hr;

		if (CThemeHelper::IsThemeBackgroundPartiallyTransparent(m_hReBarTheme, RP_BACKGROUND, 0 /* No states defined */))
		{
			CThemeHelper::DrawThemeParentBackground(m_hWnd, pDC->m_hDC, &rect);
		}

		hr = CThemeHelper::DrawThemeBackground(m_hReBarTheme, pDC->m_hDC, RP_BACKGROUND, 0 /* No states defined */, &rect, NULL);
		if (SUCCEEDED( hr ))
		{
			return TRUE;
		}
	}

	return (BOOL)Default();
}

void CDockBar::OnNcPaint()
{
	EraseNonClient();
}

void CDockBar::DoPaint(CDC*)
{
	// border painting is done in non-client area
}

void CDockBar::OnPaint()
{
	// background is already filled in gray
	CPaintDC dc(this);
	if (IsVisible() && GetDockedVisibleCount() != 0)
		DoPaint(&dc);       // delegate to paint helper
}

void CDockBar::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	// not necessary to invalidate the borders
	DWORD dwStyle = m_dwStyle;
	m_dwStyle &= ~(CBRS_BORDER_ANY);
	CControlBar::OnWindowPosChanging(lpWndPos);
	m_dwStyle = dwStyle;
}

/////////////////////////////////////////////////////////////////////////////
// CDockBar utility/implementation

int CDockBar::FindBar(CControlBar* pBar, int nPosExclude)
{
	for (int nPos = 0; nPos< m_arrBars.GetSize(); nPos++)
	{
		if (nPos != nPosExclude && m_arrBars[nPos] == pBar)
			return nPos;
	}
	return -1;
}

void CDockBar::ShowAll(BOOL bShow)
{
	for (int nPos = 0; nPos < m_arrBars.GetSize(); nPos++)
	{
		CControlBar* pBar = GetDockedControlBar(nPos);
		if (pBar != NULL)
		{
			CFrameWnd* pFrameWnd = pBar->GetDockingFrame();
			pFrameWnd->ShowControlBar(pBar, bShow, TRUE);
		}
	}
}

CControlBar* CDockBar::GetDockedControlBar(int nPos) const
{
	CControlBar* pResult = (CControlBar*)m_arrBars[nPos];
	if (DWORD_PTR(pResult) <= 0xffff)
		return NULL;
	return pResult;
}

int CDockBar::Insert(CControlBar* pBarIns, CRect rect, CPoint ptMid)
{
	ENSURE_VALID(this);
	ENSURE_VALID(pBarIns);

	int nPos = 0;
	int nPosInsAfter = 0;
	int nWidth = 0;
	int nTotalWidth = 0;
	BOOL bHorz = m_dwStyle & CBRS_ORIENT_HORZ;

	for (nPos = 0; nPos < m_arrBars.GetSize(); nPos++)
	{
		CControlBar* pBar = GetDockedControlBar(nPos);
		if (pBar != NULL && pBar->IsVisible())
		{
			CRect rectBar;
			pBar->GetWindowRect(&rectBar);
			ScreenToClient(&rectBar);
			nWidth = max(nWidth,
				bHorz ? rectBar.Size().cy : rectBar.Size().cx - 1);
			if (bHorz ? rect.left > rectBar.left : rect.top > rectBar.top)
				nPosInsAfter = nPos;
		}
		else
		{
			if (pBar == NULL && m_arrBars[nPos] == NULL) // end of row
			{
				if (0 != nWidth) // if some visible elements in the row
				{
					nTotalWidth += nWidth - afxData.cyBorder2;
				}

				nWidth = 0;
				if ((bHorz ? ptMid.y : ptMid.x) < nTotalWidth)
				{
					if (nPos == 0) // first section
						m_arrBars.InsertAt(nPosInsAfter+1, (CObject*)NULL);
					m_arrBars.InsertAt(nPosInsAfter+1, pBarIns);
					return nPosInsAfter+1;
				}
				nPosInsAfter = nPos;
			}
			// invisible toolbars are ignored
		}
	}

	// create a new row
	m_arrBars.InsertAt(nPosInsAfter+1, (CObject*)NULL);
	m_arrBars.InsertAt(nPosInsAfter+1, pBarIns);

	return nPosInsAfter+1;
}

void CDockBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
}

#ifdef _DEBUG
void CDockBar::AssertValid() const
{
	CControlBar::AssertValid();
	ASSERT(m_arrBars.GetSize() != 0);
	ASSERT(m_arrBars[0] == NULL);
	ASSERT(m_arrBars[m_arrBars.GetUpperBound()] == NULL);
}

void CDockBar::Dump(CDumpContext& dc) const
{
	CControlBar::Dump(dc);

	dc << "m_arrBars " << m_arrBars;
	dc << "\nm_bFloating " << m_bFloating;

	dc << "\n";
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CControlBar docking helpers

void CControlBar::EnableDocking(DWORD dwDockStyle)
{
	// must be CBRS_ALIGN_XXX or CBRS_FLOAT_MULTI only
	ASSERT((dwDockStyle & ~(CBRS_ALIGN_ANY|CBRS_FLOAT_MULTI)) == 0);
	// CBRS_SIZE_DYNAMIC toolbar cannot have the CBRS_FLOAT_MULTI style
	ASSERT(((dwDockStyle & CBRS_FLOAT_MULTI) == 0) || ((m_dwStyle & CBRS_SIZE_DYNAMIC) == 0));

	m_dwDockStyle = dwDockStyle;
	if (m_pDockContext == NULL)
		m_pDockContext = new CDockContext(this);

	// permanently wire the bar's owner to its current parent
	if (m_hWndOwner == NULL)
		m_hWndOwner = ::GetParent(m_hWnd);
}

/////////////////////////////////////////////////////////////////////////////
// CMiniDockFrameWnd

BEGIN_MESSAGE_MAP(CMiniDockFrameWnd, CMiniFrameWnd)
	//{{AFX_MSG_MAP(CMiniDockFrameWnd)
	ON_WM_CLOSE()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_NCLBUTTONDBLCLK()
	//}}AFX_MSG_MAP
	ON_WM_MOUSEACTIVATE()
END_MESSAGE_MAP()

int CMiniDockFrameWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	if (nHitTest >= HTSIZEFIRST && nHitTest <= HTSIZELAST) // resizing
		return MA_NOACTIVATE;
	return CMiniFrameWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

CMiniDockFrameWnd::CMiniDockFrameWnd() : m_wndDockBar(TRUE)
{
	m_wndDockBar.m_bAutoDelete = FALSE;
}

BOOL CMiniDockFrameWnd::Create(CWnd* pParent, DWORD dwBarStyle)
{
	// set m_bInRecalcLayout to avoid flashing during creation
	// RecalcLayout will be called once something is docked
	m_bInRecalcLayout = TRUE;

	DWORD dwStyle = WS_POPUP|WS_CAPTION|WS_SYSMENU|MFS_MOVEFRAME|
		MFS_4THICKFRAME|MFS_SYNCACTIVE|MFS_BLOCKSYSMENU|
		FWS_SNAPTOBARS;

	if (dwBarStyle & CBRS_SIZE_DYNAMIC)
		dwStyle &= ~MFS_MOVEFRAME;

	DWORD dwExStyle = 0;
	if (!CMiniFrameWnd::CreateEx(dwExStyle,
		NULL, _T(""), dwStyle, rectDefault, pParent))
	{
		m_bInRecalcLayout = FALSE;
		return FALSE;
	}
	dwStyle = dwBarStyle & (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT) ?
		CBRS_ALIGN_LEFT : CBRS_ALIGN_TOP;
	dwStyle |= dwBarStyle & CBRS_FLOAT_MULTI;

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if ( pSysMenu )
	{
		pSysMenu->DeleteMenu(SC_SIZE, MF_BYCOMMAND);
		pSysMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
		pSysMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
		pSysMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);

		CString strHide;
		if (strHide.LoadString(AFX_IDS_HIDE))
		{
			pSysMenu->DeleteMenu(SC_CLOSE, MF_BYCOMMAND);
			pSysMenu->AppendMenu(MF_STRING|MF_ENABLED, SC_CLOSE, strHide);
		}
	}

	// must initially create with parent frame as parent
	if (!m_wndDockBar.Create(pParent, WS_CHILD | WS_VISIBLE | dwStyle,
		AFX_IDW_DOCKBAR_FLOAT))
	{
		m_bInRecalcLayout = FALSE;
		return FALSE;
	}

	// set parent to CMiniDockFrameWnd
	m_wndDockBar.SetParent(this);
	m_bInRecalcLayout = FALSE;

	return TRUE;
}

void CMiniDockFrameWnd::RecalcLayout(BOOL bNotify)
{
	if (!m_bInRecalcLayout)
	{
		CMiniFrameWnd::RecalcLayout(bNotify);

		// syncronize window text of frame window with dockbar itself
		TCHAR szTitle[_MAX_PATH];
		m_wndDockBar.GetWindowText(szTitle, _countof(szTitle));
		AfxSetWindowText(m_hWnd, szTitle);
	}
}

void CMiniDockFrameWnd::OnClose()
{
	m_wndDockBar.ShowAll(FALSE);
}

void CMiniDockFrameWnd::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	if (nHitTest == HTCAPTION)
	{
		// special activation for floating toolbars
		ActivateTopParent();

		// initiate toolbar drag for non-CBRS_FLOAT_MULTI toolbars
		if ((m_wndDockBar.m_dwStyle & CBRS_FLOAT_MULTI) == 0)
		{
			int nPos = 1;
			CControlBar* pBar = NULL;
			while(pBar == NULL && nPos < m_wndDockBar.m_arrBars.GetSize())
				pBar = m_wndDockBar.GetDockedControlBar(nPos++);

			ENSURE_VALID(pBar);
			ASSERT_KINDOF(CControlBar, pBar);
			ENSURE(pBar->m_pDockContext != NULL);
			pBar->m_pDockContext->StartDrag(point);
			return;
		}
	}
	else if (nHitTest >= HTSIZEFIRST && nHitTest <= HTSIZELAST)
	{
		// special activation for floating toolbars
		ActivateTopParent();

		int nPos = 1;
		CControlBar* pBar = NULL;
		while(pBar == NULL && nPos < m_wndDockBar.m_arrBars.GetSize())
			pBar = m_wndDockBar.GetDockedControlBar(nPos++);

		ENSURE_VALID(pBar);
		ASSERT_KINDOF(CControlBar, pBar);
		ENSURE(pBar->m_pDockContext != NULL);

		// CBRS_SIZE_DYNAMIC toolbars cannot have the CBRS_FLOAT_MULTI style
		ASSERT((m_wndDockBar.m_dwStyle & CBRS_FLOAT_MULTI) == 0);
		pBar->m_pDockContext->StartResize(nHitTest, point);
		return;
	}
	CMiniFrameWnd::OnNcLButtonDown(nHitTest, point);
}

void CMiniDockFrameWnd::OnNcLButtonDblClk(UINT nHitTest, CPoint point)
{
	if (nHitTest == HTCAPTION)
	{
		// special activation for floating toolbars
		ActivateTopParent();

		// initiate toolbar toggle for non-CBRS_FLOAT_MULTI toolbars
		if ((m_wndDockBar.m_dwStyle & CBRS_FLOAT_MULTI) == 0)
		{
			int nPos = 1;
			CControlBar* pBar = NULL;
			while(pBar == NULL && nPos < m_wndDockBar.m_arrBars.GetSize())
				pBar = m_wndDockBar.GetDockedControlBar(nPos++);

			ENSURE_VALID(pBar);
			ASSERT_KINDOF(CControlBar, pBar);
			ENSURE(pBar->m_pDockContext != NULL);
			pBar->m_pDockContext->ToggleDocking();
			return;
		}
	}
	CMiniFrameWnd::OnNcLButtonDblClk(nHitTest, point);
}


IMPLEMENT_DYNAMIC(CDockBar, CControlBar)
IMPLEMENT_DYNCREATE(CMiniDockFrameWnd, CMiniFrameWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\auxdata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <malloc.h>



/////////////////////////////////////////////////////////////////////////////
// Cached system metrics, etc

AFX_DATADEF AUX_DATA afxData;

// Initialization code
AUX_DATA::AUX_DATA()
{
	// Cached system metrics (updated in CWnd::OnWinIniChange)
	UpdateSysMetrics();

	// Cached system values (updated in CWnd::OnSysColorChange)
	hbrBtnFace = NULL;
	UpdateSysColors();

	// Standard cursors
	hcurWait = ::LoadCursor(NULL, IDC_WAIT);
	hcurArrow = ::LoadCursor(NULL, IDC_ARROW);
	ASSERT(hcurWait != NULL);
	ASSERT(hcurArrow != NULL);
	hcurHelp = NULL;    // loaded on demand

	// cxBorder2 and cyBorder are 2x borders for Win4
	cxBorder2 = AFX_CX_BORDER*2;
	cyBorder2 = AFX_CY_BORDER*2;

	// allocated on demand
	hbmMenuDot = NULL;
	hcurHelp = NULL;
}


// Termination code
AUX_DATA::~AUX_DATA()
{
	AFX_BEGIN_DESTRUCTOR

		// clean up object we don't actually create
		AfxDeleteObject((HGDIOBJ*)&hbmMenuDot);

	AFX_END_DESTRUCTOR
}


void AUX_DATA::UpdateSysColors()
{
	clrBtnFace = ::GetSysColor(COLOR_BTNFACE);
	clrBtnShadow = ::GetSysColor(COLOR_BTNSHADOW);
	clrBtnHilite = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	clrBtnText = ::GetSysColor(COLOR_BTNTEXT);
	clrWindowFrame = ::GetSysColor(COLOR_WINDOWFRAME);

	hbrBtnFace = ::GetSysColorBrush(COLOR_BTNFACE);
	ASSERT(hbrBtnFace != NULL);
	hbrWindowFrame = ::GetSysColorBrush(COLOR_WINDOWFRAME);
	ASSERT(hbrWindowFrame != NULL);
}

void AUX_DATA::UpdateSysMetrics()
{
	// System metrics
	cxIcon = GetSystemMetrics(SM_CXICON);
	cyIcon = GetSystemMetrics(SM_CYICON);

	// System metrics which depend on subsystem version
	afxData.cxVScroll = GetSystemMetrics(SM_CXVSCROLL) + AFX_CX_BORDER;
	afxData.cyHScroll = GetSystemMetrics(SM_CYHSCROLL) + AFX_CY_BORDER;

	// Device metrics for screen
	HDC hDCScreen = GetDC(NULL);
	ASSERT(hDCScreen != NULL);
	cxPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	cyPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\bartool.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW
#define STRING_REFRESH_OFFSET 1000000
/////////////////////////////////////////////////////////////////////////////
// CToolBar creation etc


/*
	DIBs use RGBQUAD format:
		0xbb 0xgg 0xrr 0x00

	Reasonably efficient code to convert a COLORREF into an
	RGBQUAD is byte-order-dependent, so we need different
	code depending on the byte order we're targeting.
*/
#define AFX_RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r))
#define AFX_CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))

struct AFX_COLORMAP
{
	// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
	DWORD rgbqFrom;
	int iSysColorTo;
};

AFX_STATIC_DATA const AFX_COLORMAP _afxSysColorMap[] =
{
	// mapping from color in DIB to system color
	{ AFX_RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
	{ AFX_RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark gray
	{ AFX_RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright gray
	{ AFX_RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
};

HBITMAP AFXAPI
AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono)
{
	HGLOBAL hglb;
	if ((hglb = LoadResource(hInst, hRsrc)) == NULL)
		return NULL;

	LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
	if (lpBitmap == NULL)
		return NULL;

	// make copy of BITMAPINFOHEADER so we can modify the color table
	const int nColorTableSize = 16;
	UINT nSize = lpBitmap->biSize + nColorTableSize * sizeof(RGBQUAD);
	LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)::malloc(nSize);
	if (lpBitmapInfo == NULL)
		return NULL;
	
	Checked::memcpy_s(lpBitmapInfo, nSize, lpBitmap, nSize);

	// color table is in RGBQUAD DIB format
	DWORD* pColorTable =
		(DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo->biSize);

	for (int iColor = 0; iColor < nColorTableSize; iColor++)
	{
		// look for matching RGBQUAD color in original
		for (int i = 0; i < _countof(_afxSysColorMap); i++)
		{
			if (pColorTable[iColor] == _afxSysColorMap[i].rgbqFrom)
			{
				if (bMono)
				{
					// all colors except text become white
					if (_afxSysColorMap[i].iSysColorTo != COLOR_BTNTEXT)
						pColorTable[iColor] = AFX_RGB_TO_RGBQUAD(255, 255, 255);
				}
				else
					pColorTable[iColor] =
						AFX_CLR_TO_RGBQUAD(::GetSysColor(_afxSysColorMap[i].iSysColorTo));
				break;
			}
		}
	}

	int nWidth = (int)lpBitmapInfo->biWidth;
	int nHeight = (int)lpBitmapInfo->biHeight;
	HDC hDCScreen = ::GetDC(NULL);
	HBITMAP hbm = ::CreateCompatibleBitmap(hDCScreen, nWidth, nHeight);

	if (hbm != NULL)
	{
		HDC hDCGlyphs = ::CreateCompatibleDC(hDCScreen);
		HBITMAP hbmOld = (HBITMAP)::SelectObject(hDCGlyphs, hbm);

		LPBYTE lpBits;
		lpBits = (LPBYTE)(lpBitmap + 1);
		lpBits += ((size_t)1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

		StretchDIBits(hDCGlyphs, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight,
			lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
		SelectObject(hDCGlyphs, hbmOld);
		::DeleteDC(hDCGlyphs);
	}
	::ReleaseDC(NULL, hDCScreen);

	// free copy of bitmap info struct and resource itself
	::free(lpBitmapInfo);
	::FreeResource(hglb);

	return hbm;
}


struct AFX_DLLVERSIONINFO
{
		DWORD cbSize;
		DWORD dwMajorVersion;                   // Major version
		DWORD dwMinorVersion;                   // Minor version
		DWORD dwBuildNumber;                    // Build number
		DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
};

typedef HRESULT (CALLBACK* AFX_DLLGETVERSIONPROC)(AFX_DLLVERSIONINFO *);

int _afxComCtlVersion = -1;

DWORD AFXAPI _AfxGetComCtlVersion()
{
	// return cached version if already determined...
	if (_afxComCtlVersion != -1)
		return _afxComCtlVersion;

	// otherwise determine comctl32.dll version via DllGetVersion
	HINSTANCE hInst = afxComCtlWrapper->GetModuleHandle();
	ASSERT(hInst != NULL);
	AFX_DLLGETVERSIONPROC pfn;
	pfn = (AFX_DLLGETVERSIONPROC)GetProcAddress(hInst, "DllGetVersion");
	DWORD dwVersion = VERSION_WIN4;
	if (pfn != NULL)
	{
		AFX_DLLVERSIONINFO dvi;
		memset(&dvi, 0, sizeof(dvi));
		dvi.cbSize = sizeof(dvi);
		HRESULT hr = (*pfn)(&dvi);
		if (SUCCEEDED(hr))
		{
			ASSERT(dvi.dwMajorVersion <= 0xFFFF);
			ASSERT(dvi.dwMinorVersion <= 0xFFFF);
			dwVersion = MAKELONG(dvi.dwMinorVersion, dvi.dwMajorVersion);
		}
	}
	_afxComCtlVersion = dwVersion;
	return dwVersion;
}

int _afxDropDownWidth = -1;

int AFXAPI _AfxGetDropDownWidth()
{
	// return cached version if already determined...
	if (_afxDropDownWidth != -1)
		return _afxDropDownWidth;

	// otherwise calculate it...
	HDC hDC = GetDC(NULL);
	ASSERT(hDC != NULL);
	HFONT hFont = NULL, hFontOld = NULL;
	if ((hFont = CreateFont(GetSystemMetrics(SM_CYMENUCHECK), 0, 0, 0, 
		FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, _T("Marlett"))) != NULL)
		hFontOld = (HFONT)SelectObject(hDC, hFont);
	VERIFY(GetCharWidth(hDC, '6', '6', &_afxDropDownWidth));
	if (hFont != NULL)
	{
		SelectObject(hDC, hFontOld);
		DeleteObject(hFont);
	}
	ReleaseDC(NULL, hDC);
	ASSERT(_afxDropDownWidth != -1);
	return _afxDropDownWidth;
}

CToolBar::CToolBar()
{
	// initialize state
	m_pStringMap = NULL;
	m_hRsrcImageWell = NULL;
	m_hInstImageWell = NULL;
	m_hbmImageWell = NULL;
	m_bDelayedButtonLayout = TRUE;

	// default image sizes
	m_sizeImage.cx = 16;
	m_sizeImage.cy = 15;

	// default button sizes
	m_sizeButton.cx = 23;
	m_sizeButton.cy = 22;

	// top and bottom borders are 1 larger than default for ease of grabbing
	m_cyTopBorder = 3;
	m_cyBottomBorder = 3;
	EnableActiveAccessibility();
}

CToolBar::~CToolBar()
{
	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);
	delete m_pStringMap;

	m_nCount = 0;
}

BOOL CToolBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CreateEx(pParentWnd, 0, dwStyle, 
		CRect(m_cxLeftBorder, m_cyTopBorder, m_cxRightBorder, m_cyBottomBorder), nID);
}

BOOL CToolBar::CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, CRect rcBorders, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent
	ASSERT (!((dwStyle & CBRS_SIZE_FIXED) && (dwStyle & CBRS_SIZE_DYNAMIC)));

	SetBorders(rcBorders);

	// save the style
	m_dwStyle = (dwStyle & CBRS_ALL);
	if (nID == AFX_IDW_TOOLBAR)
		m_dwStyle |= CBRS_HIDE_INPLACE;

	dwStyle &= ~CBRS_ALL;
	dwStyle |= CCS_NOPARENTALIGN|CCS_NOMOVEY|CCS_NODIVIDER|CCS_NORESIZE;
	dwStyle |= dwCtrlStyle;

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));
	_AfxGetComCtlVersion();
	ASSERT(_afxComCtlVersion != -1);
	_AfxGetDropDownWidth();
	ASSERT(_afxDropDownWidth != -1);

	// create the HWND
	CRect rect; rect.SetRectEmpty();
	if (!CWnd::Create(TOOLBARCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// sync up the sizes
	SetSizes(m_sizeButton, m_sizeImage);

	// Note: Parent must resize itself for control bar to be resized

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar

BOOL CToolBar::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!CControlBar::OnNcCreate(lpCreateStruct))
		return FALSE;

	// if the owner was set before the toolbar was created, set it now
	if (m_hWndOwner != NULL)
		DefWindowProc(TB_SETPARENT, (WPARAM)m_hWndOwner, 0);

	DefWindowProc(TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
	return TRUE;
}

void CToolBar::SetOwner(CWnd* pOwnerWnd)
{
	ASSERT_VALID(this);
	if (m_hWnd != NULL)
	{
		ASSERT(::IsWindow(m_hWnd));
		DefWindowProc(TB_SETPARENT, (WPARAM)pOwnerWnd->GetSafeHwnd(), 0);
	}
	CControlBar::SetOwner(pOwnerWnd);
}

void CToolBar::SetSizes(SIZE sizeButton, SIZE sizeImage)
{
	ASSERT_VALID(this);

	// sizes must be non-zero and positive
	ASSERT(sizeButton.cx > 0 && sizeButton.cy > 0);
	ASSERT(sizeImage.cx > 0 && sizeImage.cy > 0);

	// button must be big enough to hold image
	//   + 7 pixels on x
	//   + 6 pixels on y
	ASSERT(sizeButton.cx >= sizeImage.cx + 7);
	ASSERT(sizeButton.cy >= sizeImage.cy + 6);

	if (::IsWindow(m_hWnd))
	{
		// set the sizes via TB_SETBITMAPSIZE and TB_SETBUTTONSIZE
		VERIFY(SendMessage(TB_SETBITMAPSIZE, 0, MAKELONG(sizeImage.cx, sizeImage.cy)));
		VERIFY(SendMessage(TB_SETBUTTONSIZE, 0, MAKELONG(sizeButton.cx, sizeButton.cy)));
		if (_afxComCtlVersion >= VERSION_6)
		{
			DWORD dwSize = (DWORD)SendMessage(TB_GETBUTTONSIZE, 0, 0);
			m_sizeButton.cx = LOWORD(dwSize);
			m_sizeButton.cy = HIWORD(dwSize);
		}
		Invalidate();   // just to be nice if called when toolbar is visible
	}
	else
	{
		// just set our internal values for later
		m_sizeButton = sizeButton;
		m_sizeImage = sizeImage;
	}
}

void CToolBar::SetHeight(int cyHeight)
{
	ASSERT_VALID(this);

	int nHeight = cyHeight;
	if (m_dwStyle & CBRS_BORDER_TOP)
		cyHeight -= afxData.cyBorder2;
	if (m_dwStyle & CBRS_BORDER_BOTTOM)
		cyHeight -= afxData.cyBorder2;
	m_cyBottomBorder = (cyHeight - m_sizeButton.cy) / 2;
	// if there is an extra pixel, m_cyTopBorder will get it
	m_cyTopBorder = cyHeight - m_sizeButton.cy - m_cyBottomBorder;
	if (m_cyTopBorder < 0)
	{
		TRACE(traceAppMsg, 0, "Warning: CToolBar::SetHeight(%d) is smaller than button.\n",
			nHeight);
		m_cyBottomBorder += m_cyTopBorder;
		m_cyTopBorder = 0;  // will clip at bottom
	}

	// recalculate the non-client region
	SetWindowPos(NULL, 0, 0, 0, 0,
		SWP_DRAWFRAME|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER);
	Invalidate();   // just to be nice if called when toolbar is visible
}

struct CToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

BOOL CToolBar::LoadToolBar(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != NULL);

	// determine location of the bitmap in resource fork
	HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_TOOLBAR);
	HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_TOOLBAR);
	if (hRsrc == NULL)
		return FALSE;

	HGLOBAL hGlobal = LoadResource(hInst, hRsrc);
	if (hGlobal == NULL)
		return FALSE;

	CToolBarData* pData = (CToolBarData*)LockResource(hGlobal);
	if (pData == NULL)
		return FALSE;
	ASSERT(pData->wVersion == 1);

	UINT* pItems = new UINT[pData->wItemCount];
	for (int i = 0; i < pData->wItemCount; i++)
		pItems[i] = pData->items()[i];
	BOOL bResult = SetButtons(pItems, pData->wItemCount);
	delete[] pItems;

	if (bResult)
	{
		// set new sizes of the buttons
		CSize sizeImage(pData->wWidth, pData->wHeight);
		CSize sizeButton(pData->wWidth + 7, pData->wHeight + 7);
		SetSizes(sizeButton, sizeImage);

		// load bitmap now that sizes are known by the toolbar control
		bResult = LoadBitmap(lpszResourceName);
	}

	UnlockResource(hGlobal);
	FreeResource(hGlobal);

	return bResult;
}

BOOL CToolBar::LoadBitmap(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != NULL);

	// determine location of the bitmap in resource fork
	HINSTANCE hInstImageWell = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
	HRSRC hRsrcImageWell = ::FindResource(hInstImageWell, lpszResourceName, RT_BITMAP);
	if (hRsrcImageWell == NULL)
		return FALSE;

	// load the bitmap
	HBITMAP hbmImageWell;
	hbmImageWell = AfxLoadSysColorBitmap(hInstImageWell, hRsrcImageWell);

	// tell common control toolbar about the new bitmap
	if (!AddReplaceBitmap(hbmImageWell))
		return FALSE;

	// remember the resource handles so the bitmap can be recolored if necessary
	m_hInstImageWell = hInstImageWell;
	m_hRsrcImageWell = hRsrcImageWell;
	return TRUE;
}

BOOL CToolBar::SetBitmap(HBITMAP hbmImageWell)
{
	ASSERT_VALID(this);
	ASSERT(hbmImageWell != NULL);

	// the caller must manage changing system colors
	m_hInstImageWell = NULL;
	m_hRsrcImageWell = NULL;

	// tell common control toolbar about the new bitmap
	return AddReplaceBitmap(hbmImageWell);
}

BOOL CToolBar::AddReplaceBitmap(HBITMAP hbmImageWell)
{
	// need complete bitmap size to determine number of images
	BITMAP bitmap;
	VERIFY(::GetObject(hbmImageWell, sizeof(BITMAP), &bitmap));

	// add the bitmap to the common control toolbar
	BOOL bResult;
	if (m_hbmImageWell == NULL)
	{
		TBADDBITMAP addBitmap;
		addBitmap.hInst = NULL; // makes TBADDBITMAP::nID behave a HBITMAP
		addBitmap.nID = (UINT_PTR)hbmImageWell;
		bResult =  DefWindowProc(TB_ADDBITMAP,
			bitmap.bmWidth / m_sizeImage.cx, (LPARAM)&addBitmap) == 0;
	}
	else
	{
		TBREPLACEBITMAP replaceBitmap;
		replaceBitmap.hInstOld = NULL;
		replaceBitmap.nIDOld = (UINT_PTR)m_hbmImageWell;
		replaceBitmap.hInstNew = NULL;
		replaceBitmap.nIDNew = (UINT_PTR)hbmImageWell;
		replaceBitmap.nButtons = bitmap.bmWidth / m_sizeImage.cx;
		bResult = (BOOL)DefWindowProc(TB_REPLACEBITMAP, 0,
			(LPARAM)&replaceBitmap);
	}
	// remove old bitmap, if present
	if (bResult)
	{
		AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);
		m_hbmImageWell = hbmImageWell;
	}

	return bResult;
}

BOOL CToolBar::SetButtons(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// delete all existing buttons
	int nCount = (int)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
	while (nCount--)
		VERIFY(DefWindowProc(TB_DELETEBUTTON, 0, 0));

	TBBUTTON button; memset(&button, 0, sizeof(TBBUTTON));
	button.iString = -1;
	if (lpIDArray != NULL)
	{
		// add new buttons to the common control
		int iImage = 0;
		for (int i = 0; i < nIDCount; i++)
		{
			button.fsState = TBSTATE_ENABLED;
			if ((button.idCommand = *lpIDArray++) == 0)
			{
				// separator
				button.fsStyle = TBSTYLE_SEP;
				// width of separator includes 8 pixel overlap
				ASSERT(_afxComCtlVersion != -1);
				if ((GetStyle() & TBSTYLE_FLAT) || _afxComCtlVersion == VERSION_IE4)
					button.iBitmap = 6;
				else
					button.iBitmap = 8;
			}
			else
			{
				// a command button with image
				button.fsStyle = TBSTYLE_BUTTON;
				button.iBitmap = iImage++;
			}
			if (!DefWindowProc(TB_ADDBUTTONS, 1, (LPARAM)&button))
				return FALSE;
		}
	}
	else
	{
		// add 'blank' buttons
		button.fsState = TBSTATE_ENABLED;
		for (int i = 0; i < nIDCount; i++)
		{
			ASSERT(button.fsStyle == TBSTYLE_BUTTON);
			if (!DefWindowProc(TB_ADDBUTTONS, 1, (LPARAM)&button))
				return FALSE;
		}
	}
	m_nCount = (int)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
	m_bDelayedButtonLayout = TRUE;

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CToolBar attribute access

void CToolBar::_GetButton(int nIndex, TBBUTTON* pButton) const
{
	CToolBar* pBar = (CToolBar*)this;
	VERIFY(pBar->DefWindowProc(TB_GETBUTTON, nIndex, (LPARAM)pButton));
	// TBSTATE_ENABLED == TBBS_DISABLED so invert it
	pButton->fsState ^= TBSTATE_ENABLED;
}

void CToolBar::_SetButton(int nIndex, TBBUTTON* pButton)
{
	// get original button state
	TBBUTTON button;
	VERIFY(DefWindowProc(TB_GETBUTTON, nIndex, (LPARAM)&button));

	// prepare for old/new button comparsion
	button.bReserved[0] = 0;
	button.bReserved[1] = 0;
	// TBSTATE_ENABLED == TBBS_DISABLED so invert it
	pButton->fsState ^= TBSTATE_ENABLED;
	pButton->bReserved[0] = 0;
	pButton->bReserved[1] = 0;

	// nothing to do if they are the same
	if (memcmp(pButton, &button, sizeof(TBBUTTON)) != 0)
	{
		// don't redraw everything while setting the button
		DWORD dwStyle = GetStyle();
		ModifyStyle(WS_VISIBLE, 0);
		VERIFY(DefWindowProc(TB_DELETEBUTTON, nIndex, 0));

		// Force a recalc of the toolbar's layout to work around a comctl bug
		if (pButton->iString<-1){	
			int iTextRows;
			iTextRows = (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0);
			::SendMessage(m_hWnd, WM_SETREDRAW, FALSE, 0);
			::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iTextRows+1, 0);
			::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iTextRows, 0);
			::SendMessage(m_hWnd, WM_SETREDRAW, TRUE, 0);
			pButton->iString+=STRING_REFRESH_OFFSET;
 		}
		VERIFY(DefWindowProc(TB_INSERTBUTTON, nIndex, (LPARAM)pButton));
		ModifyStyle(0, dwStyle & WS_VISIBLE);

		// invalidate appropriate parts
		if (((pButton->fsStyle ^ button.fsStyle) & TBSTYLE_SEP) ||
			((pButton->fsStyle & TBSTYLE_SEP) && pButton->iBitmap != button.iBitmap))
		{
			// changing a separator
			Invalidate();
		}
		else
		{
			// invalidate just the button
			CRect rect;
			if (DefWindowProc(TB_GETITEMRECT, nIndex, (LPARAM)&rect))
				InvalidateRect(rect);
		}
	}
}

int CToolBar::CommandToIndex(UINT nIDFind) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	CToolBar* pBar = (CToolBar*)this;
	return (int)pBar->DefWindowProc(TB_COMMANDTOINDEX, nIDFind, 0);
}

UINT CToolBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	TBBUTTON button;
	_GetButton(nIndex, &button);
	return button.idCommand;
}

void CToolBar::GetItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	// handle any delayed layout
	if (m_bDelayedButtonLayout)
		((CToolBar*)this)->Layout();

	// now it is safe to get the item rectangle
	CToolBar* pBar = (CToolBar*)this;
	if (!pBar->DefWindowProc(TB_GETITEMRECT, nIndex, (LPARAM)lpRect))
		SetRectEmpty(lpRect);
}

void CToolBar::Layout()
{
	ASSERT(m_bDelayedButtonLayout);

	m_bDelayedButtonLayout = FALSE;

	BOOL bHorz = (m_dwStyle & CBRS_ORIENT_HORZ) != 0;
	if ((m_dwStyle & CBRS_FLOATING) && (m_dwStyle & CBRS_SIZE_DYNAMIC))
		((CToolBar*)this)->CalcDynamicLayout(0, LM_HORZ | LM_MRUWIDTH | LM_COMMIT);
	else if (bHorz)
		((CToolBar*)this)->CalcDynamicLayout(0, LM_HORZ | LM_HORZDOCK | LM_COMMIT);
	else
		((CToolBar*)this)->CalcDynamicLayout(0, LM_VERTDOCK | LM_COMMIT);
}

UINT CToolBar::GetButtonStyle(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	TBBUTTON button;
	_GetButton(nIndex, &button);
	return MAKELONG(button.fsStyle, button.fsState);
}

void CToolBar::SetButtonStyle(int nIndex, UINT nStyle)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	TBBUTTON button;
	_GetButton(nIndex, &button);
	if (button.fsStyle != (BYTE)LOWORD(nStyle) || button.fsState != (BYTE)HIWORD(nStyle))
	{
		button.fsStyle = (BYTE)LOWORD(nStyle);
		button.fsState = (BYTE)HIWORD(nStyle);
		_SetButton(nIndex, &button);
		m_bDelayedButtonLayout = TRUE;
	}
}

#define CX_OVERLAP  0

CSize CToolBar::CalcSize(TBBUTTON* pData, int nCount)
{
	ASSERT(pData != NULL && nCount > 0);

	CPoint cur(0,0);
	CSize sizeResult(0,0);

	DWORD dwExtendedStyle = DWORD(DefWindowProc(TB_GETEXTENDEDSTYLE, 0, 0));

	for (int i = 0; i < nCount; i++)
	{
		//  The IE4 version of COMCTL32.DLL calculates the separation
		//	on a TBSTYLE_WRAP button as 100% of the value in iBitmap compared
		//	to the other versions which calculate it at 2/3 of that value.
		//	This is actually a bug which should be fixed in IE 4.01, so we
		//	only do the 100% calculation specifically for IE4.
		int cySep = pData[i].iBitmap;
		ASSERT(_afxComCtlVersion != -1);
		if (!(GetStyle() & TBSTYLE_FLAT) && _afxComCtlVersion != VERSION_IE4)
			cySep = cySep * 2 / 3;

		if (pData[i].fsState & TBSTATE_HIDDEN)
			continue;

		int cx = m_sizeButton.cx;
		if (pData[i].fsStyle & TBSTYLE_SEP)
		{
			// a separator represents either a height or width
			if (pData[i].fsState & TBSTATE_WRAP)
				sizeResult.cy = max(cur.y + m_sizeButton.cy + cySep, sizeResult.cy);
			else
				sizeResult.cx = max(cur.x + pData[i].iBitmap, sizeResult.cx);
		}
		else 
		{
			// check for dropdown style, but only if the buttons are being drawn
			if ((pData[i].fsStyle & TBSTYLE_DROPDOWN) && 
				(dwExtendedStyle & TBSTYLE_EX_DRAWDDARROWS))
			{
				// add size of drop down
				ASSERT(_afxDropDownWidth != -1);
				cx += _afxDropDownWidth;
			}
			sizeResult.cx = max(cur.x + cx, sizeResult.cx);
			sizeResult.cy = max(cur.y + m_sizeButton.cy, sizeResult.cy);
		}

		if (pData[i].fsStyle & TBSTYLE_SEP)
			cur.x += pData[i].iBitmap;
		else
			cur.x += cx - CX_OVERLAP;

		if (pData[i].fsState & TBSTATE_WRAP)
		{
			cur.x = 0;
			cur.y += m_sizeButton.cy;
			if (pData[i].fsStyle & TBSTYLE_SEP)
				cur.y += cySep;
		}
	}
	return sizeResult;
}

int CToolBar::WrapToolBar(TBBUTTON* pData, int nCount, int nWidth)
{
	ASSERT(pData != NULL && nCount > 0);

	int nResult = 0;
	int x = 0;
	for (int i = 0; i < nCount; i++)
	{
		pData[i].fsState &= ~TBSTATE_WRAP;

		if (pData[i].fsState & TBSTATE_HIDDEN)
			continue;

		int dx, dxNext;
		if (pData[i].fsStyle & TBSTYLE_SEP)
		{
			dx = pData[i].iBitmap;
			dxNext = dx;
		}
		else
		{
			dx = m_sizeButton.cx;
			dxNext = dx - CX_OVERLAP;
		}

		if (x + dx > nWidth)
		{
			BOOL bFound = FALSE;
			for (int j = i; j >= 0  &&  !(pData[j].fsState & TBSTATE_WRAP); j--)
			{
				// Find last separator that isn't hidden
				// a separator that has a command ID is not
				// a separator, but a custom control.
				if ((pData[j].fsStyle & TBSTYLE_SEP) &&
					(pData[j].idCommand == 0) &&
					!(pData[j].fsState & TBSTATE_HIDDEN))
				{
					bFound = TRUE; i = j; x = 0;
					pData[j].fsState |= TBSTATE_WRAP;
					nResult++;
					break;
				}
			}
			if (!bFound)
			{
				for (int j = i - 1; j >= 0 && !(pData[j].fsState & TBSTATE_WRAP); j--)
				{
					// Never wrap anything that is hidden,
					// or any custom controls
					if ((pData[j].fsState & TBSTATE_HIDDEN) ||
						((pData[j].fsStyle & TBSTYLE_SEP) &&
						(pData[j].idCommand != 0)))
						continue;

					bFound = TRUE; i = j; x = 0;
					pData[j].fsState |= TBSTATE_WRAP;
					nResult++;
					break;
				}
				if (!bFound)
					x += dxNext;
			}
		}
		else
			x += dxNext;
	}
	return nResult + 1;
}

void  CToolBar::SizeToolBar(TBBUTTON* pData, int nCount, int nLength, BOOL bVert)
{
	ASSERT(pData != NULL && nCount > 0);

	if (!bVert)
	{
		int nMin, nMax, nTarget, nCurrent, nMid;

		// Wrap ToolBar as specified
		nMax = nLength;
		nTarget = WrapToolBar(pData, nCount, nMax);

		// Wrap ToolBar vertically
		nMin = 0;
		nCurrent = WrapToolBar(pData, nCount, nMin);

		if (nCurrent != nTarget)
		{
			while (nMin < nMax)
			{
				nMid = (nMin + nMax) / 2;
				nCurrent = WrapToolBar(pData, nCount, nMid);

				if (nCurrent == nTarget)
					nMax = nMid;
				else
				{
					if (nMin == nMid)
					{
						WrapToolBar(pData, nCount, nMax);
						break;
					}
					nMin = nMid;
				}
			}
		}
		CSize size = CalcSize(pData, nCount);
		WrapToolBar(pData, nCount, size.cx);
	}
	else
	{
		CSize sizeMax, sizeMin, sizeMid;

		// Wrap ToolBar vertically
		WrapToolBar(pData, nCount, 0);
		sizeMin = CalcSize(pData, nCount);

		// Wrap ToolBar horizontally
		WrapToolBar(pData, nCount, 32767);
		sizeMax = CalcSize(pData, nCount);

		while (sizeMin.cx < sizeMax.cx)
		{
			sizeMid.cx = (sizeMin.cx + sizeMax.cx) / 2;
			WrapToolBar(pData, nCount, sizeMid.cx);
			sizeMid = CalcSize(pData, nCount);

			if (nLength < sizeMid.cy)
			{
				if (sizeMin == sizeMid)
				{
					WrapToolBar(pData, nCount, sizeMax.cx);
					return;
				}
				sizeMin = sizeMid;
			}
			else if (nLength > sizeMid.cy)
			{
				if (sizeMax == sizeMid)
				{
					WrapToolBar(pData, nCount, sizeMin.cx);
					return;
				}
				sizeMax = sizeMid;
			}
			else
				return;
		}
	}
}

struct _AFX_CONTROLPOS
{
	int nIndex, nID;
	CRect rectOldPos;
};

CSize CToolBar::CalcLayout(DWORD dwMode, int nLength)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));
	if (dwMode & LM_HORZDOCK)
		ASSERT(dwMode & LM_HORZ);

	int nCount;
	TBBUTTON* pData = NULL;
	CSize sizeResult(0,0);

	//BLOCK: Load Buttons
	{
		nCount = int(DefWindowProc(TB_BUTTONCOUNT, 0, 0));
		if (nCount != 0)
		{
			int i;
			pData = new TBBUTTON[nCount];
			for (i = 0; i < nCount; i++)
				_GetButton(i, &pData[i]);
		}
	}

	if (nCount > 0)
	{
		if (!(m_dwStyle & CBRS_SIZE_FIXED))
		{
			BOOL bDynamic = m_dwStyle & CBRS_SIZE_DYNAMIC;

			if (bDynamic && (dwMode & LM_MRUWIDTH))
				SizeToolBar(pData, nCount, m_nMRUWidth);
			else if (bDynamic && (dwMode & LM_HORZDOCK))
				SizeToolBar(pData, nCount, 32767);
			else if (bDynamic && (dwMode & LM_VERTDOCK))
				SizeToolBar(pData, nCount, 0);
			else if (bDynamic && (nLength != -1))
			{
				CRect rect; rect.SetRectEmpty();
				CalcInsideRect(rect, (dwMode & LM_HORZ));
				BOOL bVert = (dwMode & LM_LENGTHY);
				int nLen = nLength + (bVert ? rect.Height() : rect.Width());

				SizeToolBar(pData, nCount, nLen, bVert);
			}
			else if (bDynamic && (m_dwStyle & CBRS_FLOATING))
				SizeToolBar(pData, nCount, m_nMRUWidth);
			else
				SizeToolBar(pData, nCount, (dwMode & LM_HORZ) ? 32767 : 0);
		}

		sizeResult = CalcSize(pData, nCount);

		if (dwMode & LM_COMMIT)
		{
			_AFX_CONTROLPOS* pControl = NULL;
			int nControlCount = 0;
			BOOL bIsDelayed = m_bDelayedButtonLayout;
			m_bDelayedButtonLayout = FALSE;
			int i;

			for (i = 0; i < nCount; i++)
				if ((pData[i].fsStyle & TBSTYLE_SEP) && (pData[i].idCommand != 0))
					nControlCount++;

			if (nControlCount > 0)
			{
				pControl = new _AFX_CONTROLPOS[nControlCount];
				int nControlAlloc=nControlCount;
				nControlCount = 0;

				for(i = 0; i < nCount && nControlCount < nControlAlloc; i++)
				{
					if ((pData[i].fsStyle & TBSTYLE_SEP) && (pData[i].idCommand != 0))
					{
						pControl[nControlCount].nIndex = i;
						pControl[nControlCount].nID = pData[i].idCommand;

						CRect rect;
						GetItemRect(i, &rect);
						ClientToScreen(&rect);
						pControl[nControlCount].rectOldPos = rect;

						nControlCount++;
					}
				}
			}

			if ((m_dwStyle & CBRS_FLOATING) && (m_dwStyle & CBRS_SIZE_DYNAMIC))
				m_nMRUWidth = sizeResult.cx;
			for (i = 0; i < nCount; i++)
				_SetButton(i, &pData[i]);

			if (nControlCount > 0)
			{
				for (i = 0; i < nControlCount; i++)
				{
					CWnd* pWnd = GetDlgItem(pControl[i].nID);
					if (pWnd != NULL)
					{
						CRect rect;
						pWnd->GetWindowRect(&rect);
						CPoint pt = rect.TopLeft() - pControl[i].rectOldPos.TopLeft();
						GetItemRect(pControl[i].nIndex, &rect);
						pt = rect.TopLeft() + pt;
						pWnd->SetWindowPos(NULL, pt.x, pt.y, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
					}
				}
				delete[] pControl;
			}
			m_bDelayedButtonLayout = bIsDelayed;
		}
		delete[] pData;
	}

	//BLOCK: Adjust Margins
	{
		CRect rect; rect.SetRectEmpty();
		CalcInsideRect(rect, (dwMode & LM_HORZ));
		sizeResult.cy -= rect.Height();
		sizeResult.cx -= rect.Width();

		CSize size = CControlBar::CalcFixedLayout((dwMode & LM_STRETCH), (dwMode & LM_HORZ));
		sizeResult.cx = max(sizeResult.cx, size.cx);
		sizeResult.cy = max(sizeResult.cy, size.cy);
	}
	return sizeResult;
}

CSize CToolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	DWORD dwMode = bStretch ? LM_STRETCH : 0;
	dwMode |= bHorz ? LM_HORZ : 0;

	return CalcLayout(dwMode);
}

CSize CToolBar::CalcDynamicLayout(int nLength, DWORD dwMode)
{
	if ((nLength == -1) && !(dwMode & LM_MRUWIDTH) && !(dwMode & LM_COMMIT) &&
		((dwMode & LM_HORZDOCK) || (dwMode & LM_VERTDOCK)))
	{
		return CalcFixedLayout(dwMode & LM_STRETCH, dwMode & LM_HORZDOCK);
	}
	return CalcLayout(dwMode, nLength);
}

void CToolBar::GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	TBBUTTON button;
	_GetButton(nIndex, &button);
	nID = button.idCommand;
	nStyle = MAKELONG(button.fsStyle, button.fsState);
	iImage = button.iBitmap;
}

void CToolBar::SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage)
{
	ASSERT_VALID(this);

	TBBUTTON button;
	_GetButton(nIndex, &button);
	TBBUTTON save;

	Checked::memcpy_s(&save, sizeof(TBBUTTON), &button, sizeof(TBBUTTON));
	button.idCommand = nID;
	button.iBitmap = iImage;
	button.fsStyle = (BYTE)LOWORD(nStyle);
	button.fsState = (BYTE)HIWORD(nStyle);
	if (memcmp(&save, &button, sizeof(save)) != 0)
	{
		_SetButton(nIndex, &button);
		m_bDelayedButtonLayout = TRUE;
	}
}

INT_PTR CToolBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	// check child windows first by calling CControlBar
	INT_PTR nHit = CControlBar::OnToolHitTest(point, pTI);
	if (nHit != -1)
		return nHit;

	// now hit test against CToolBar buttons
	CToolBar* pBar = (CToolBar*)this;
	int nButtons = (int)pBar->DefWindowProc(TB_BUTTONCOUNT, 0, 0);
	for (int i = 0; i < nButtons; i++)
	{
		CRect rect;
		TBBUTTON button;
		if (pBar->DefWindowProc(TB_GETITEMRECT, i, (LPARAM)&rect))
		{
			++rect.bottom;
			++rect.right;
			if (rect.PtInRect(point) &&
				pBar->DefWindowProc(TB_GETBUTTON, i, (LPARAM)&button) &&
				!(button.fsStyle & TBSTYLE_SEP))
			{
				UINT_PTR uHit = GetItemID(i);
				if (pTI != NULL && pTI->cbSize >= sizeof(AFX_OLDTOOLINFO))
				{
					pTI->hwnd = m_hWnd;
					pTI->rect = rect;
					pTI->uId = uHit;
					pTI->lpszText = LPSTR_TEXTCALLBACK;
				}
				// found matching rect, return the ID of the button
				return uHit != 0 ? static_cast<INT_PTR>(uHit) : static_cast<INT_PTR>(-1);
			}
		}
	}
	return -1;
}

BOOL CToolBar::SetButtonText(int nIndex, LPCTSTR lpszText)
{
	// attempt to lookup string index in map
	INT_PTR nString = -1;
	void* p;
	if (m_pStringMap != NULL && m_pStringMap->Lookup(lpszText, p))
		nString = (INT_PTR)p;

	// add new string if not already in map
	if (nString == -1)
	{
		// initialize map if necessary
		if (m_pStringMap == NULL)
			m_pStringMap = new CMapStringToPtr;

		// add new string to toolbar list
		CString strTemp(lpszText, lstrlen(lpszText)+1);
		nString = (INT_PTR)DefWindowProc(TB_ADDSTRING, 0, (LPARAM)(LPCTSTR)strTemp);
		if (nString == -1)
			return FALSE;

		// cache string away in string map
		m_pStringMap->SetAt(lpszText, (void*)nString);
		ASSERT(m_pStringMap->Lookup(lpszText, p));
	}

	// change the toolbar button description
	TBBUTTON button;
	_GetButton(nIndex, &button);
	button.iString = nString-STRING_REFRESH_OFFSET;
	_SetButton(nIndex, &button);

	return TRUE;
}

CString CToolBar::GetButtonText(int nIndex) const
{
	CString strResult;
	GetButtonText(nIndex, strResult);
	return strResult;
}

void CToolBar::GetButtonText(int nIndex, CString& rString) const
{
	if (m_pStringMap != NULL)
	{
		// get button information (need button.iString)
		TBBUTTON button;
		_GetButton(nIndex, &button);

		// look in map for matching iString
		POSITION pos = m_pStringMap->GetStartPosition();
		CString str; void* p;
		while (pos)
		{
			m_pStringMap->GetNextAssoc(pos, str, p);
			if ((INT_PTR)p == button.iString)
			{
				rString = str;
				return;
			}
		}
	}
	rString.Empty();
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar message handlers

BEGIN_MESSAGE_MAP(CToolBar, CControlBar)
	//{{AFX_MSG_MAP(CToolBar)
	ON_WM_NCHITTEST()
	ON_WM_NCPAINT()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_NCCALCSIZE()
	ON_WM_WINDOWPOSCHANGING()
	ON_WM_NCCREATE()
	ON_MESSAGE(TB_SETBITMAPSIZE, &CToolBar::OnSetBitmapSize)
	ON_MESSAGE(TB_SETBUTTONSIZE, &CToolBar::OnSetButtonSize)
	ON_MESSAGE(WM_SETTINGCHANGE, &CToolBar::OnPreserveZeroBorderHelper)
	ON_MESSAGE(WM_SETFONT, &CToolBar::OnPreserveZeroBorderHelper)
	ON_MESSAGE(TB_SETDISABLEDIMAGELIST, &CToolBar::OnPreserveSizingPolicyHelper)
	ON_MESSAGE(TB_SETHOTIMAGELIST, &CToolBar::OnPreserveSizingPolicyHelper)
	ON_MESSAGE(TB_SETIMAGELIST, &CToolBar::OnPreserveSizingPolicyHelper)
	ON_WM_SYSCOLORCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CToolBar::OnEraseBkgnd(CDC*)
{
	return (BOOL)Default();
}

LRESULT CToolBar::OnNcHitTest(CPoint)
{
	return HTCLIENT;
}

void CToolBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS* lpncsp)
{
	// calculate border space (will add to top/bottom, subtract from right/bottom)
	CRect rect; rect.SetRectEmpty();
	BOOL bHorz = (m_dwStyle & CBRS_ORIENT_HORZ) != 0;
	CControlBar::CalcInsideRect(rect, bHorz);
	ASSERT(_afxComCtlVersion != -1);
	ASSERT(_afxComCtlVersion >= VERSION_IE4 || rect.top >= 2);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;
	// previous versions of COMCTL32.DLL had a built-in 2 pixel border
	if (_afxComCtlVersion < VERSION_IE4)
		lpncsp->rgrc[0].top -= 2;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

void CToolBar::OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle)
{
	// a dynamically resizeable toolbar can not have the CBRS_FLOAT_MULTI
	ASSERT(!((dwNewStyle & CBRS_SIZE_DYNAMIC) &&
			(m_dwDockStyle & CBRS_FLOAT_MULTI)));

	// a toolbar can not be both dynamic and fixed in size
	ASSERT (!((dwNewStyle & CBRS_SIZE_FIXED) &&
		(dwNewStyle & CBRS_SIZE_DYNAMIC)));

	// CBRS_SIZE_DYNAMIC can not be disabled once it has been enabled
	ASSERT (((dwOldStyle & CBRS_SIZE_DYNAMIC) == 0) ||
		((dwNewStyle & CBRS_SIZE_DYNAMIC) != 0));

	if (m_hWnd != NULL &&
		((dwOldStyle & CBRS_BORDER_ANY) != (dwNewStyle & CBRS_BORDER_ANY)))
	{
		// recalc non-client area when border styles change
		SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_DRAWFRAME);
	}
	m_bDelayedButtonLayout = TRUE;
}

void CToolBar::OnNcPaint()
{
	EraseNonClient();
}

void CToolBar::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	// not necessary to invalidate the borders
	DWORD dwStyle = m_dwStyle;
	m_dwStyle &= ~(CBRS_BORDER_ANY);
	CControlBar::OnWindowPosChanging(lpWndPos);
	m_dwStyle = dwStyle;

	// If we can resize while floating
	if (dwStyle & CBRS_SIZE_DYNAMIC)
	{
		// And we are resizing
		if (lpWndPos->flags & SWP_NOSIZE)
			return;

		// Then redraw the buttons
		Invalidate();
	}
}

void CToolBar::OnPaint()
{
	if (m_bDelayedButtonLayout)
		Layout();

	Default();
}

LRESULT CToolBar::OnSetButtonSize(WPARAM, LPARAM lParam)
{
	return OnSetSizeHelper(m_sizeButton, lParam);
}

LRESULT CToolBar::OnSetBitmapSize(WPARAM, LPARAM lParam)
{
	return OnSetSizeHelper(m_sizeImage, lParam);
}

LRESULT CToolBar::OnSetSizeHelper(CSize& size, LPARAM lParam)
{
	//  The IE4 version of COMCTL32.DLL supports a zero border, but 
	//	only if TBSTYLE_TRANSPARENT is on during the the TB_SETBITMAPSIZE
	//	and/or TB_SETBUTTONSIZE messages.  In order to enable this feature
	//	all the time (so we get consistent border behavior, dependent only
	//	on the version of COMCTL32.DLL) we turn on TBSTYLE_TRANSPARENT 
	//	whenever these messages go through.  It would be nice that in a
	//	future version, the system toolbar would just allow you to set
	//	the top and left borders to anything you please.

	//  In comctl32 version 6.00 when using XP Look combined with TBSTYLE_EX_DRAWDDARROWS 
	//	style minimal sizing policy was changed to be
	//			button.height >= image.height + 13
	//			button.width >= image.width + 16
	//	this force buttons to be bigger then usual
	//	To override this behavior we should remove TBSTYLE_EX_DRAWDDARROWS prior to sizing operations

	BOOL bModify = FALSE;
	ASSERT(_afxComCtlVersion != -1);
	DWORD dwStyle = 0;
	DWORD dwStyleEx = 0;
	if (_afxComCtlVersion >= VERSION_IE4)
	{
		dwStyle = GetStyle();
		bModify = ModifyStyle(0, TBSTYLE_TRANSPARENT|TBSTYLE_FLAT);
		if ((_afxComCtlVersion >= VERSION_6) && ::IsWindow(GetToolBarCtrl()))
		{
			dwStyleEx = GetToolBarCtrl().SetExtendedStyle(GetToolBarCtrl().GetExtendedStyle() &~ TBSTYLE_EX_DRAWDDARROWS);
		}
	}

	LRESULT lResult = Default();
	if (lResult)
	{
		size = DWORD(lParam);
	}

	if (bModify)
	{
		SetWindowLong(m_hWnd, GWL_STYLE, dwStyle);
	}
	if (dwStyleEx)
	{
		GetToolBarCtrl().SetExtendedStyle(dwStyleEx);
	}

	return lResult;
}

LRESULT CToolBar::OnPreserveZeroBorderHelper(WPARAM, LPARAM)
{
	BOOL bModify = FALSE;
	ASSERT(_afxComCtlVersion != -1);
	DWORD dwStyle = 0;
	DWORD dwStyleEx = 0;
	if (_afxComCtlVersion >= VERSION_IE4)
	{
		dwStyle = GetStyle();
		bModify = ModifyStyle(0, TBSTYLE_TRANSPARENT|TBSTYLE_FLAT);
		if ((_afxComCtlVersion >= VERSION_6) && ::IsWindow(GetToolBarCtrl()))
		{
			dwStyleEx = GetToolBarCtrl().SetExtendedStyle(GetToolBarCtrl().GetExtendedStyle() &~ TBSTYLE_EX_DRAWDDARROWS);
		}
	}

	LRESULT lResult = Default();

	if (bModify)
	{
		SetWindowLong(m_hWnd, GWL_STYLE, dwStyle);
	}
	if (dwStyleEx & TBSTYLE_EX_DRAWDDARROWS)
	{
		GetToolBarCtrl().SetExtendedStyle(dwStyleEx);
	}

	return lResult;
}

LRESULT CToolBar::OnPreserveSizingPolicyHelper(WPARAM, LPARAM)
{
	//	NOTE: in comctl32 version 6.00 when using XP Look combined with TBSTYLE_EX_DRAWDDARROWS 
	//	style minimal sizing policy was changed to be
	//			button.height >= image.height + 13
	//			button.width >= image.width + 16
	//	this force buttons to be bigger then usual
	//	To override this behavior we should remove TBSTYLE_DROPDOWN from all buttons prior to setimagelist 
	//  operations

	UINT uiButtonNum = 0;
	DWORD* pdwStyles = NULL;
	ASSERT(_afxComCtlVersion != -1);
	if (_afxComCtlVersion >= VERSION_6)
	{
		uiButtonNum = GetToolBarCtrl().GetButtonCount();
		pdwStyles = new DWORD[uiButtonNum];
		ASSERT(pdwStyles);
		for(UINT i =0; i < uiButtonNum; i++)
		{
			pdwStyles[i] = GetButtonStyle(i);
			SetButtonStyle(i, pdwStyles[i] & ~TBSTYLE_DROPDOWN ); 
		}
	}
	
	LRESULT lResult = Default();

	if (pdwStyles)
	{
		for (UINT i =0; i< uiButtonNum; i++)
		{			
			SetButtonStyle(i, pdwStyles[i]); 
		}
		delete [] pdwStyles;		
	}

	return lResult;
}

void CToolBar::OnSysColorChange()
{
	// re-color bitmap for toolbar
	if (m_hInstImageWell != NULL && m_hbmImageWell != NULL)
	{
		HBITMAP hbmNew;
		hbmNew = AfxLoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell);
		if (hbmNew != NULL)
			AddReplaceBitmap(hbmNew);
	}
}

// Active Accessibility support
HRESULT CToolBar::get_accName(VARIANT varChild, BSTR *pszName)
{
	if (varChild.lVal == CHILDID_SELF)
	{
		CString strText;
		GetWindowText(strText);

		*pszName = strText.AllocSysString();
		return S_OK;
	}
	else if (varChild.lVal != 0)
	{
		CString szFullText;
		CString strTipText;

		UINT nID;
		UINT nStyle;
		int nImage;
		GetButtonInfo(varChild.lVal - 1, nID, nStyle, nImage);
		// don't handle the message if no string resource found
		if (szFullText.LoadString((UINT)nID) != 0)
		{
			// this is the command id, not the button index
			AfxExtractSubString(strTipText, szFullText, 1, '\n');
			*pszName = strTipText.AllocSysString();
			return S_OK;
		}	
	}
	return CControlBar::get_accName(varChild, pszName);
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUI class

class CToolCmdUI : public CCmdUI        // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CToolCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) & ~TBBS_DISABLED;
	if (!bOn)
	{
		nNewStyle |= TBBS_DISABLED;
		// If a button is currently pressed and then is disabled
		// COMCTL32.DLL does not unpress the button, even after the mouse
		// button goes up!  We work around this bug by forcing TBBS_PRESSED
		// off when a button is disabled.
		nNewStyle &= ~TBBS_PRESSED;
	}
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle);
}

void CToolCmdUI::SetCheck(int nCheck)
{
	ASSERT(nCheck >= 0 && nCheck <= 2); // 0=>off, 1=>on, 2=>indeterminate
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) &
				~(TBBS_CHECKED | TBBS_INDETERMINATE);
	if (nCheck == 1)
		nNewStyle |= TBBS_CHECKED;
	else if (nCheck == 2)
		nNewStyle |= TBBS_INDETERMINATE;
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle | TBBS_CHECKBOX);
}

void CToolCmdUI::SetText(LPCTSTR)
{
	// ignore it
}

void CToolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CToolCmdUI state;
	state.m_pOther = this;

	state.m_nIndexMax = (UINT)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax; state.m_nIndex++)
	{
		// get buttons state
		TBBUTTON button;
		_GetButton(state.m_nIndex, &button);
		state.m_nID = button.idCommand;

		// ignore separators
		if (!(button.fsStyle & TBSTYLE_SEP))
		{
			// allow reflections
			if (CWnd::OnCmdMsg(0, 
				MAKELONG(CN_UPDATE_COMMAND_UI&0xffff, WM_COMMAND+WM_REFLECT_BASE), 
				&state, NULL))
				continue;

			// allow the toolbar itself to have update handlers
			if (CWnd::OnCmdMsg(state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
				continue;

			// allow the owner to process the update
			state.DoUpdate(pTarget, bDisableIfNoHndler);
		}
	}

	// update the dialog controls added to the toolbar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar diagnostics

#ifdef _DEBUG
void CToolBar::AssertValid() const
{
	// Note: CControlBar::AssertValid is not called because it checks for
	//  m_nCount and m_pData to be in sync, which they are not in CToolBar.

	ASSERT(m_hbmImageWell == NULL || ::GetObjectType(m_hbmImageWell) == OBJ_BITMAP);

	if (m_hInstImageWell != NULL && m_hbmImageWell != NULL)
		ASSERT(m_hRsrcImageWell != NULL);
}

void CToolBar::Dump(CDumpContext& dc) const
{
	CControlBar::Dump(dc);

	dc << "m_hbmImageWell = " << (void*)m_hbmImageWell;
	dc << "\nm_hInstImageWell = " << (void*)m_hInstImageWell;
	dc << "\nm_hRsrcImageWell = " << (void*)m_hRsrcImageWell;
	dc << "\nm_sizeButton = " << m_sizeButton;
	dc << "\nm_sizeImage = " << m_sizeImage;

	if (dc.GetDepth() > 0)
	{
		CToolBar* pBar = (CToolBar*)this;
		int nCount = int(pBar->DefWindowProc(TB_BUTTONCOUNT, 0, 0));
		for (int i = 0; i < nCount; i++)
		{
			TBBUTTON button;
			_GetButton(i, &button);
			dc << "\ntoolbar button[" << i << "] = {";
			dc << "\n\tnID = " << button.idCommand;
			dc << "\n\tnStyle = " << MAKELONG(button.fsStyle, button.fsState);
			if (button.fsStyle & TBSTYLE_SEP)
				dc << "\n\tiImage (separator width) = " << button.iBitmap;
			else
				dc <<"\n\tiImage (bitmap image index) = " << button.iBitmap;
			dc << "\n}";
		}
	}

	dc << "\n";
}
#endif


IMPLEMENT_DYNAMIC(CToolBar, CControlBar)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\barstat.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CStatusBar creation, etc

#define SBPF_UPDATE 0x0001  // pending update of text

struct AFX_STATUSPANE
{
	UINT    nID;        // IDC of indicator: 0 => normal text area
	int     cxText;     // width of string area in pixels
						//   on both sides there is a 3 pixel gap and
						//   a one pixel border, making a pane 6 pixels wider
	UINT    nStyle;     // style flags (SBPS_*)
	UINT    nFlags;     // state flags (SBPF_*)
	CString strText;    // text in the pane
};

inline AFX_STATUSPANE* CStatusBar::_GetPanePtr(int nIndex) const
{
	ASSERT((nIndex >= 0 && nIndex < m_nCount) || m_nCount == 0);
	return ((AFX_STATUSPANE*)m_pData) + nIndex;
}


#define CX_PANE_BORDER 6    // 3 pixels on each side of each pane

CStatusBar::CStatusBar()
{
	// setup default border/margin depending on type of system
	m_cyTopBorder = 2;
	m_cxLeftBorder = 0;
	m_cxRightBorder = 0;
	m_cyBottomBorder = 0;

	// minimum height set with SB_SETMINHEIGHT is cached
	m_nMinHeight = 0;
}

CStatusBar::~CStatusBar()
{
	AllocElements(0, 0);    // destroys existing elements
}

BOOL CStatusBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	return CreateEx(pParentWnd, 0, dwStyle, nID);
}

BOOL CStatusBar::CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent

	// save the style (some of these style bits are MFC specific)
	m_dwStyle = (dwStyle & CBRS_ALL);

	// translate MFC style bits to windows style bits
	dwStyle &= ~CBRS_ALL;
	dwStyle |= CCS_NOPARENTALIGN|CCS_NOMOVEY|CCS_NODIVIDER|CCS_NORESIZE;
	if (pParentWnd->GetStyle() & WS_THICKFRAME)
		dwStyle |= SBARS_SIZEGRIP;
	dwStyle |= dwCtrlStyle;

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_BAR_REG));

	// create the HWND
	CRect rect; rect.SetRectEmpty();
	return CWnd::Create(STATUSCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID);
}

BOOL CStatusBar::PreCreateWindow(CREATESTRUCT& cs)
{
	// in Win4, status bars do not have a border at all, since it is
	//  provided by the client area.
	if ((m_dwStyle & (CBRS_ALIGN_ANY|CBRS_BORDER_ANY)) == CBRS_BOTTOM)
		m_dwStyle &= ~(CBRS_BORDER_ANY|CBRS_BORDER_3D);

	return CControlBar::PreCreateWindow(cs);
}

BOOL CStatusBar::SetIndicators(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));
	ASSERT(::IsWindow(m_hWnd));

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(AFX_STATUSPANE)))
		return FALSE;
	ASSERT(nIDCount == m_nCount);

	// copy initial data from indicator array
	BOOL bResult = TRUE;
	if (lpIDArray != NULL)
	{
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = NULL;
		if (hFont != NULL)
			hOldFont = dcScreen.SelectObject(hFont);

		AFX_STATUSPANE* pSBP = _GetPanePtr(0);
		for (int i = 0; i < nIDCount; i++)
		{
			pSBP->nID = *lpIDArray++;
			pSBP->nFlags |= SBPF_UPDATE;
			if (pSBP->nID != 0)
			{
				if (!pSBP->strText.LoadString(pSBP->nID))
				{
					TRACE(traceAppMsg, 0, "Warning: failed to load indicator string 0x%04X.\n",
						pSBP->nID);
					bResult = FALSE;
					break;
				}
				pSBP->cxText = dcScreen.GetTextExtent(pSBP->strText).cx;
				ASSERT(pSBP->cxText >= 0);
				if (!SetPaneText(i, pSBP->strText, FALSE))
				{
					bResult = FALSE;
					break;
				}
			}
			else
			{
				// no indicator (must access via index)
				// default to 1/4 the screen width (first pane is stretchy)
				pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN)/4;
				if (i == 0)
					pSBP->nStyle |= (SBPS_STRETCH | SBPS_NOBORDERS);
			}
			++pSBP;
		}
		if (hOldFont != NULL)
			dcScreen.SelectObject(hOldFont);
	}
	UpdateAllPanes(TRUE, TRUE);

	return bResult;
}

BOOL CStatusBar::AllocElements(int nElements, int cbElement)
{
	int i;

	// destruct old elements
	AFX_STATUSPANE* pSBP = _GetPanePtr(0);
	for (i = 0; i < m_nCount; i++)
	{
		pSBP->strText.~CString();
		++pSBP;
	}

	// allocate new elements
	if (!CControlBar::AllocElements(nElements, cbElement))
		return FALSE;

	// construct new elements
	pSBP = _GetPanePtr(0);
	for (i = 0; i < m_nCount; i++)
	{
#pragma push_macro("new")
#undef new
		new( &pSBP->strText ) CString;
#pragma pop_macro("new")
		++pSBP;
	}
	return TRUE;
}

void CStatusBar::CalcInsideRect(CRect& rect, BOOL bHorz) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(bHorz);  // vertical status bar not supported

	// subtract standard CControlBar borders
	CControlBar::CalcInsideRect(rect, bHorz);

	// subtract size grip if present
	if ((GetStyle() & SBARS_SIZEGRIP) && !::IsZoomed(::GetParent(m_hWnd)))
	{
		// get border metrics from common control
		int rgBorders[3];
		CStatusBar* pBar = (CStatusBar*)this;
		pBar->DefWindowProc(SB_GETBORDERS, 0, (LPARAM)rgBorders);

		// size grip uses a border + size of scrollbar + cx border
		rect.right -= rgBorders[0] + ::GetSystemMetrics(SM_CXVSCROLL) +
			::GetSystemMetrics(SM_CXBORDER) * 2;
	}
}

void CStatusBar::UpdateAllPanes(BOOL bUpdateRects, BOOL bUpdateText)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	int i;

	// update the status pane locations
	if (bUpdateRects)
	{

		// get border information and client work area
		CRect rect; GetWindowRect(rect);
		rect.OffsetRect(-rect.left, -rect.top);
		CalcInsideRect(rect, TRUE);
		int rgBorders[3];
		VERIFY((BOOL)DefWindowProc(SB_GETBORDERS, 0, (LPARAM)rgBorders));

		// determine extra space for stretchy pane
		int cxExtra = rect.Width() + rgBorders[2];
		int nStretchyCount = 0;
		AFX_STATUSPANE* pSBP = _GetPanePtr(0);
		for (i = 0; i < m_nCount; i++)
		{
			if (pSBP->nStyle & SBPS_STRETCH)
				++nStretchyCount;
			cxExtra -= (pSBP->cxText+CX_PANE_BORDER + rgBorders[2]);
			++pSBP;
		}

		// determine right edge of each pane
		CArray<int> rgRights;
		rgRights.SetSize(m_nCount);
		int right = rgBorders[0];
		pSBP = _GetPanePtr(0);
		for (i = 0; i < m_nCount; i++)
		{
			// determine size of the pane
			ASSERT(pSBP->cxText >= 0);
			right += pSBP->cxText+CX_PANE_BORDER;
			if ((pSBP->nStyle & SBPS_STRETCH) && cxExtra > 0)
			{
				ASSERT(nStretchyCount != 0);
				int cxAddExtra = cxExtra / nStretchyCount;
				right += cxAddExtra;
				--nStretchyCount;
				cxExtra -= cxAddExtra;
			}
			rgRights[i] = right;

			// next pane
			++pSBP;
			right += rgBorders[2];
		}

		// set new right edges for all panes
		DefWindowProc(SB_SETPARTS, m_nCount, 
			reinterpret_cast<LPARAM>(rgRights.GetData()));
	}

	// update text in the status panes if specified
	if (bUpdateText)
	{
		AFX_STATUSPANE* pSBP = _GetPanePtr(0);
		for (i = 0; i < m_nCount; i++)
		{
			if (pSBP->nFlags & SBPF_UPDATE)
				SetPaneText(i, pSBP->strText);
			++pSBP;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStatusBar attribute access

int CStatusBar::CommandToIndex(UINT nIDFind) const
{
	ASSERT_VALID(this);

	if (m_nCount <= 0)
		return -1;

	AFX_STATUSPANE* pSBP = _GetPanePtr(0);
	for (int i = 0; i < m_nCount; i++, pSBP++)
		if (pSBP->nID == nIDFind)
			return i;

	return -1;
}

UINT CStatusBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);
	return _GetPanePtr(nIndex)->nID;
}

void CStatusBar::GetItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	CStatusBar* pBar = (CStatusBar*)this;
	if (!pBar->DefWindowProc(SB_GETRECT, nIndex, (LPARAM)lpRect))
		::SetRectEmpty(lpRect);
}

UINT CStatusBar::GetPaneStyle(int nIndex) const
{
	return _GetPanePtr(nIndex)->nStyle;
}

void CStatusBar::SetPaneStyle(int nIndex, UINT nStyle)
{
	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	if (pSBP->nStyle != nStyle)
	{
		// if the pane is changing SBPS_STRETCH, then...
		if ((pSBP->nStyle ^ nStyle) & SBPS_STRETCH)
		{
			// ... we need to re-layout the panes
			pSBP->nStyle = nStyle;
			UpdateAllPanes(TRUE, FALSE);
		}

		// use SetPaneText, since it updates the style and text
		pSBP->nStyle = nStyle;
		pSBP->nFlags |= SBPF_UPDATE;
		SetPaneText(nIndex, pSBP->strText);
	}
}

void CStatusBar::GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle,
	int& cxWidth) const
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	nID = pSBP->nID;
	nStyle = pSBP->nStyle;
	cxWidth = pSBP->cxText;
}

void CStatusBar::SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth)
{
	ASSERT_VALID(this);

	BOOL bChanged = FALSE;
	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	pSBP->nID = nID;
	if (pSBP->nStyle != nStyle)
	{
		if ((pSBP->nStyle ^ nStyle) & SBPS_STRETCH)
			bChanged = TRUE;
		else
		{
			pSBP->nStyle = nStyle;
			pSBP->nFlags |= SBPF_UPDATE;
			SetPaneText(nIndex, pSBP->strText);
		}
		pSBP->nStyle = nStyle;
	}
	if (cxWidth != pSBP->cxText)
	{
		// change width of one pane -> invalidate the entire status bar
		pSBP->cxText = cxWidth;
		bChanged = TRUE;
	}
	if (bChanged)
		UpdateAllPanes(TRUE, FALSE);
}

void CStatusBar::GetPaneText(int nIndex, CString& s) const
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	s = pSBP->strText;
}

CString CStatusBar::GetPaneText(int nIndex) const
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	return pSBP->strText;
}

BOOL CStatusBar::SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);

	if (!(pSBP->nFlags & SBPF_UPDATE) &&
		((lpszNewText == NULL && pSBP->strText.IsEmpty()) ||
		 (lpszNewText != NULL && pSBP->strText.Compare(lpszNewText) == 0)))
	{
		// nothing to change
		return TRUE;
	}

	TRY
	{
		if (lpszNewText != NULL)
			pSBP->strText = lpszNewText;
		else
			pSBP->strText.Empty();
	}
	CATCH_ALL(e)
	{
		// Note: DELETE_EXCEPTION(e) not required
		return FALSE;
	}
	END_CATCH_ALL

	if (!bUpdate)
	{
		// can't update now, wait until later
		pSBP->nFlags |= SBPF_UPDATE;
		return TRUE;
	}

	pSBP->nFlags &= ~SBPF_UPDATE;
	DefWindowProc(SB_SETTEXT, ((WORD)pSBP->nStyle)|nIndex,
		(pSBP->nStyle & SBPS_DISABLED) ? NULL :
		(LPARAM)(LPCTSTR)pSBP->strText);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar implementation

CSize CStatusBar::CalcFixedLayout(BOOL, BOOL bHorz)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	// determinme size of font being used by the status bar
	TEXTMETRIC tm;
	{
		CClientDC dc(NULL);
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT);
		HGDIOBJ hOldFont = NULL;
		if (hFont != NULL)
			hOldFont = dc.SelectObject(hFont);
		VERIFY(dc.GetTextMetrics(&tm));
		if (hOldFont != NULL)
			dc.SelectObject(hOldFont);
	}

	// get border information
	CRect rect; rect.SetRectEmpty();
	CalcInsideRect(rect, bHorz);
	int rgBorders[3];
	DefWindowProc(SB_GETBORDERS, 0, (LPARAM)rgBorders);

	// determine size, including borders
	CSize size;
	size.cx = 32767;
	size.cy = tm.tmHeight - tm.tmInternalLeading - 1
		+ rgBorders[1] * 2 + ::GetSystemMetrics(SM_CYBORDER) * 2
		- rect.Height();
	if (size.cy < m_nMinHeight)
		size.cy = m_nMinHeight;

	return size;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar message handlers

BEGIN_MESSAGE_MAP(CStatusBar, CControlBar)
	//{{AFX_MSG_MAP(CStatusBar)
	ON_WM_NCHITTEST()
	ON_WM_NCPAINT()
	ON_WM_PAINT()
	ON_WM_NCCALCSIZE()
	ON_WM_SIZE()
	ON_WM_WINDOWPOSCHANGING()
	ON_MESSAGE(WM_SETTEXT, &CStatusBar::OnSetText)
	ON_MESSAGE(WM_GETTEXT, &CStatusBar::OnGetText)
	ON_MESSAGE(WM_GETTEXTLENGTH, &CStatusBar::OnGetTextLength)
	ON_MESSAGE(SB_SETMINHEIGHT, &CStatusBar::OnSetMinHeight)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

LRESULT CStatusBar::OnNcHitTest(CPoint)
{
	LRESULT nResult = Default();
	if (nResult == HTBOTTOMRIGHT)
		return HTBOTTOMRIGHT;
	else
		return HTCLIENT;
}

void CStatusBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS* lpncsp)
{
	// calculate border space (will add to top/bottom, subtract from right/bottom)
	CRect rect; rect.SetRectEmpty();
	CControlBar::CalcInsideRect(rect, TRUE);
	ASSERT(rect.top >= 2);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top - 2;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

void CStatusBar::OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle)
{
	if (m_hWnd != NULL &&
		((dwOldStyle & CBRS_BORDER_ANY) != (dwNewStyle & CBRS_BORDER_ANY)))
	{
		// recalc non-client area when border styles change
		SetWindowPos(NULL, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_DRAWFRAME);
	}
}

void CStatusBar::OnNcPaint()
{
	EraseNonClient();
}

// Derived class is responsible for implementing all of these handlers
//  for owner/self draw controls.
void CStatusBar::DrawItem(LPDRAWITEMSTRUCT)
{
	ASSERT(FALSE);
}

BOOL CStatusBar::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	if (message != WM_DRAWITEM)
		return CWnd::OnChildNotify(message, wParam, lParam, pResult);

	ASSERT(pResult == NULL);
	UNUSED(pResult); // unused in release builds
	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
}

void CStatusBar::OnPaint()
{
	UpdateAllPanes(FALSE, TRUE);

	Default();
}

void CStatusBar::OnSize(UINT nType, int cx, int cy)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	CControlBar::OnSize(nType, cx, cy);

	// need to adjust pane right edges (because of stretchy pane)
	UpdateAllPanes(TRUE, FALSE);
}

void CStatusBar::OnWindowPosChanging(LPWINDOWPOS lpWndPos)
{
	// not necessary to invalidate the borders
	DWORD dwStyle = m_dwStyle;
	m_dwStyle &= ~(CBRS_BORDER_ANY);
	CControlBar::OnWindowPosChanging(lpWndPos);
	m_dwStyle = dwStyle;
}

LRESULT CStatusBar::OnSetText(WPARAM, LPARAM lParam)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	int nIndex = CommandToIndex(0);
	if (nIndex < 0)
		return -1;
	return SetPaneText(nIndex, (LPCTSTR)lParam) ? 0 : -1;
}

LRESULT CStatusBar::OnGetText(WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	int nMaxLen = (int)wParam;
	if (nMaxLen == 0)
		return 0;       // nothing copied
	LPTSTR lpszDest = (LPTSTR)lParam;

	INT_PTR nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
		nLen = pSBP->strText.GetLength();
		if (nLen > nMaxLen)
			nLen = nMaxLen - 1; // number of characters to copy (less term.)

		Checked::memcpy_s(lpszDest, nMaxLen*sizeof(TCHAR), 
			(LPCTSTR)pSBP->strText, nLen*sizeof(TCHAR));
	}
	lpszDest[nLen] = '\0';
	return nLen+1;      // number of bytes copied
}

LRESULT CStatusBar::OnGetTextLength(WPARAM, LPARAM)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	INT_PTR nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
		nLen = pSBP->strText.GetLength();
	}
	return nLen;
}

LRESULT CStatusBar::OnSetMinHeight(WPARAM wParam, LPARAM)
{
	LRESULT lResult = Default();
	m_nMinHeight = (int)wParam;
	return lResult;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar idle update through CStatusCmdUI class

class CStatusCmdUI : public CCmdUI      // class private to this file!
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CStatusCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CStatusBar* pStatusBar = (CStatusBar*)m_pOther;
	ASSERT(pStatusBar != NULL);
	ASSERT_KINDOF(CStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_DISABLED;
	if (!bOn)
		nNewStyle |= SBPS_DISABLED;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CStatusCmdUI::SetCheck(int nCheck) // "checking" will pop out the text
{
	CStatusBar* pStatusBar = (CStatusBar*)m_pOther;
	ASSERT(pStatusBar != NULL);
	ASSERT_KINDOF(CStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_POPOUT;
	if (nCheck != 0)
		nNewStyle |= SBPS_POPOUT;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CStatusCmdUI::SetText(LPCTSTR lpszText)
{
	CStatusBar* pStatusBar = (CStatusBar*)m_pOther;
	ASSERT(pStatusBar != NULL);
	ASSERT_KINDOF(CStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	pStatusBar->SetPaneText(m_nIndex, lpszText);
}

void CStatusBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CStatusCmdUI state;
	state.m_pOther = this;
	state.m_nIndexMax = (UINT)m_nCount;
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
		state.m_nIndex++)
	{
		state.m_nID = _GetPanePtr(state.m_nIndex)->nID;

		// allow the statusbar itself to have update handlers
		if (CWnd::OnCmdMsg(state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
			continue;

		// allow target (owner) to handle the remaining updates
		state.DoUpdate(pTarget, FALSE);
	}

	// update the dialog controls added to the status bar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar diagnostics

#ifdef _DEBUG
void CStatusBar::AssertValid() const
{
	CControlBar::AssertValid();
}

void CStatusBar::Dump(CDumpContext& dc) const
{
	CControlBar::Dump(dc);

	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nCount; i++)
		{
			dc << "\nstatus pane[" << i << "] = {";
			dc << "\n\tnID = " << _GetPanePtr(i)->nID;
			dc << "\n\tnStyle = " << _GetPanePtr(i)->nStyle;
			dc << "\n\tcxText = " << _GetPanePtr(i)->cxText;
			dc << "\n\tstrText = " << _GetPanePtr(i)->strText;
			dc << "\n\t}";
		}
	}
	dc << "\n";
}
#endif //_DEBUG


IMPLEMENT_DYNAMIC(CStatusBar, CControlBar)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\barcool.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CReBar

BEGIN_MESSAGE_MAP(CReBar, CControlBar)
	//{{AFX_MSG_MAP(CReBar)
	ON_WM_NCCREATE()
	ON_WM_PAINT()
	ON_WM_NCCALCSIZE()
	ON_WM_ERASEBKGND()
	ON_WM_NCPAINT()
	ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, &CReBar::OnHeightChange)
	ON_NOTIFY_REFLECT(RBN_ENDDRAG, &CReBar::OnHeightChange)
	ON_MESSAGE(RB_SHOWBAND, &CReBar::OnShowBand)
	ON_MESSAGE_VOID(WM_RECALCPARENT, CReBar::OnRecalcParent)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CReBar::CReBar()
{
	if (_AfxGetComCtlVersion() < MAKELONG(1, 6))
	{
		// For 6.0 common controls, the call to RB_INSERTBAND will fail
		// if the 6.1 size is passed in. So, the old size must be used 
		// instead.
		m_nReBarBandInfoSize = sizeof(AFX_OLDREBARBANDINFO);
	}
	else
	{
		m_nReBarBandInfoSize = sizeof(REBARBANDINFO);
	}

	SetBorders();
}

void CReBar::OnRecalcParent()
{
	CFrameWnd* pFrameWnd = EnsureParentFrame();
	pFrameWnd->RecalcLayout();
}

void CReBar::OnHeightChange(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
	// does the CReBar have a frame?
	CFrameWnd* pFrameWnd = GetParentFrame();
	if (pFrameWnd != NULL)
	{
		// it does -- tell it to recalc its layout
		if (!pFrameWnd->m_bInRecalcLayout)
			pFrameWnd->RecalcLayout();
		else
			PostMessage(WM_RECALCPARENT);
	}
	*pResult = 0;
}

LRESULT CReBar::OnShowBand(WPARAM wParam, LPARAM)
{
	LRESULT lResult = Default();
	if (lResult)
	{
		// keep window visible state in sync with band visible state
		REBARBANDINFO rbBand;
		rbBand.cbSize = m_nReBarBandInfoSize;
		rbBand.fMask = RBBIM_CHILD|RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, wParam, (LPARAM)&rbBand));
		CControlBar* pBar = DYNAMIC_DOWNCAST(CControlBar, CWnd::FromHandlePermanent(rbBand.hwndChild));
		BOOL bWindowVisible;
		if (pBar != NULL)
			bWindowVisible = pBar->IsVisible();
		else
			bWindowVisible =  (::GetWindowLong(rbBand.hwndChild, GWL_STYLE) & WS_VISIBLE) != 0;
		BOOL bBandVisible = (rbBand.fStyle & RBBS_HIDDEN) == 0;
		if (bWindowVisible != bBandVisible)
			VERIFY(::ShowWindow(rbBand.hwndChild, bBandVisible ? SW_SHOW : SW_HIDE));
	}
	return lResult;
}

BOOL CReBar::_AddBar(CWnd* pBar, REBARBANDINFO* pRBBI)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));
	ENSURE_ARG(pBar != NULL);	
	ASSERT(::IsWindow(pBar->m_hWnd));

	pRBBI->cbSize = m_nReBarBandInfoSize;
	pRBBI->fMask |= RBBIM_SIZE | RBBIM_CHILD | RBBIM_CHILDSIZE;
	pRBBI->hwndChild = pBar->m_hWnd;

	CSize size;
	CControlBar* pTemp = DYNAMIC_DOWNCAST(CControlBar, pBar);
	if (pTemp != NULL)
	{
		size = pTemp->CalcFixedLayout(FALSE, m_dwStyle & CBRS_ORIENT_HORZ);
	}
	else
	{
		CRect rect;
		pBar->GetWindowRect(&rect);
		size = rect.Size();
	}

	ASSERT(_afxComCtlVersion != -1);
	pRBBI->cyMinChild = size.cy;

	//  COMCTL32.DLL is off by 4 pixels in its sizing logic.  Whatever
	//	is specified as the minimum size, the system rebar will allow that band
	//	to be 4 actual pixels smaller!  That's why we add 4 to the size here.
	pRBBI->cxIdeal = size.cx + (_afxComCtlVersion < VERSION_IE401 ? 4 : 0);

	if(pRBBI->fStyle & RBBS_USECHEVRON)
	{
		pRBBI->fMask |= RBBIM_IDEALSIZE;
		// Make min size square (i.e., pRBBI->cx == pRBBI->cy == size.cy)
		pRBBI->cxMinChild = pRBBI->cyMinChild;
		pRBBI->cx = pRBBI->cxIdeal;
	}
	else
		pRBBI->cx = pRBBI->cxMinChild = pRBBI->cxIdeal;

	if(DefWindowProc(RB_INSERTBAND, (WPARAM)-1, (LPARAM)pRBBI))
	{
		CFrameWnd* pFrameWnd = GetParentFrame();
		if (pFrameWnd != NULL)
			pFrameWnd->RecalcLayout();

		GetReBarCtrl().MaximizeBand(0);

		return TRUE;
	}
	return FALSE;
}

BOOL CReBar::AddBar(CWnd* pBar, LPCTSTR pszText, CBitmap* pbmp, DWORD dwStyle)
{
	ENSURE_ARG(pBar != NULL);	
	REBARBANDINFO rbBand;
	rbBand.fMask = RBBIM_STYLE;
	rbBand.fStyle = dwStyle;
	if (pszText != NULL)
	{
		rbBand.fMask |= RBBIM_TEXT;
		rbBand.lpText = const_cast<LPTSTR>(pszText);
	}
	if (pbmp != NULL)
	{
		rbBand.fMask |= RBBIM_BACKGROUND;
		rbBand.hbmBack = (HBITMAP)*pbmp;
	}
	return _AddBar(pBar, &rbBand);
}

BOOL CReBar::AddBar(CWnd* pBar, COLORREF clrFore, COLORREF clrBack, LPCTSTR pszText, DWORD dwStyle)
{
	REBARBANDINFO rbBand;
	rbBand.fMask = RBBIM_STYLE | RBBIM_COLORS;
	rbBand.fStyle = dwStyle;
	rbBand.clrFore = clrFore;
	rbBand.clrBack = clrBack;
	if (pszText != NULL)
	{
		rbBand.fMask |= RBBIM_TEXT;
		rbBand.lpText = const_cast<LPTSTR>(pszText);
	}
	return _AddBar(pBar, &rbBand);
}

CSize CReBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	// the union of the band rectangles is the total bounding rect
	int nCount = int(DefWindowProc(RB_GETBANDCOUNT, 0, 0));
	REBARBANDINFO rbBand;
	rbBand.cbSize = m_nReBarBandInfoSize;
	int nTemp;

	// sync up hidden state of the bands
	for (nTemp = nCount; nTemp--; )
	{
		rbBand.fMask = RBBIM_CHILD|RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, nTemp, (LPARAM)&rbBand));
		CControlBar* pBar = DYNAMIC_DOWNCAST(CControlBar, CWnd::FromHandlePermanent(rbBand.hwndChild));
		BOOL bWindowVisible;
		if (pBar != NULL)
			bWindowVisible = pBar->IsVisible();
		else
			bWindowVisible =  (::GetWindowLong(rbBand.hwndChild, GWL_STYLE) & WS_VISIBLE) != 0;
		BOOL bBandVisible = (rbBand.fStyle & RBBS_HIDDEN) == 0;
		if (bWindowVisible != bBandVisible)
			VERIFY(DefWindowProc(RB_SHOWBAND, nTemp, bWindowVisible));
	}

	// determine bounding rect of all visible bands
	CRect rectBound; rectBound.SetRectEmpty();
	for (nTemp = nCount; nTemp--; )
	{
		rbBand.fMask = RBBIM_STYLE;
		VERIFY(DefWindowProc(RB_GETBANDINFO, nTemp, (LPARAM)&rbBand));
		if ((rbBand.fStyle & RBBS_HIDDEN) == 0)
		{
			CRect rect;
			VERIFY(DefWindowProc(RB_GETRECT, nTemp, (LPARAM)&rect));
			rectBound |= rect;
		}
	}

	// add borders as part of bounding rect
	if (!rectBound.IsRectEmpty())
	{
		CRect rect; rect.SetRectEmpty();
		CalcInsideRect(rect, bHorz);
		rectBound.right -= rect.Width();
		rectBound.bottom -= rect.Height();
	}

	return CSize((bHorz && bStretch) ? 32767 : rectBound.Width(),
				 (!bHorz && bStretch) ? 32767 : rectBound.Height());
}

CSize CReBar::CalcDynamicLayout(int /*nLength*/, DWORD dwMode)
{
	if (dwMode & LM_HORZDOCK)
		ASSERT(dwMode & LM_HORZ);
	return CalcFixedLayout(dwMode & LM_STRETCH, dwMode & LM_HORZ);
}

BOOL CReBar::Create(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent
	ASSERT(!((dwStyle & CBRS_SIZE_FIXED) && (dwStyle & CBRS_SIZE_DYNAMIC)));

	// save the style
	m_dwStyle = (dwStyle & CBRS_ALL);
	if (nID == AFX_IDW_REBAR)
		m_dwStyle |= CBRS_HIDE_INPLACE;

	dwStyle &= ~CBRS_ALL;
	dwStyle |= CCS_NOPARENTALIGN|CCS_NOMOVEY|CCS_NODIVIDER|CCS_NORESIZE|RBS_VARHEIGHT;
	dwStyle |= dwCtrlStyle;

	// initialize common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTL_COOL_REG));
	_AfxGetComCtlVersion();
	ASSERT(_afxComCtlVersion != -1);

	// create the HWND
	CRect rect; rect.SetRectEmpty();
	if (!CWnd::Create(REBARCLASSNAME, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// Note: Parent must resize itself for control bar to be resized

	return TRUE;
}

void CReBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHandler)
{
	UpdateDialogControls(pTarget, bDisableIfNoHandler);
}

BOOL CReBar::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (!CControlBar::OnNcCreate(lpCreateStruct))
		return FALSE;

	// if the owner was set before the rebar was created, set it now
	if (m_hWndOwner != NULL)
		DefWindowProc(RB_SETPARENT, (WPARAM)m_hWndOwner, 0);

	return TRUE;
}

BOOL CReBar::OnEraseBkgnd(CDC*)
{
	return (BOOL)Default();
}

void CReBar::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS* lpncsp)
{
	// calculate border space (will add to top/bottom, subtract from right/bottom)
	CRect rect; rect.SetRectEmpty();
	BOOL bHorz = (m_dwStyle & CBRS_ORIENT_HORZ) != 0;
	CControlBar::CalcInsideRect(rect, bHorz);

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;
	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

void CReBar::OnNcPaint()
{
	EraseNonClient();
}

void CReBar::OnPaint()
{
	Default();
}

INT_PTR CReBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));

	HWND hWndChild = _AfxChildWindowFromPoint(m_hWnd, point);
	CWnd* pWnd = CWnd::FromHandlePermanent(hWndChild);
	if (pWnd == NULL)
		return CControlBar::OnToolHitTest(point, pTI);

	ASSERT(pWnd->m_hWnd == hWndChild);
	return pWnd->OnToolHitTest(point, pTI);
}

LRESULT CReBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// special handling for certain messages (forwarding to owner/parent)
	switch (message)
	{
	case WM_POPMESSAGESTRING:
	case WM_SETMESSAGESTRING:
		{
			CWnd* pOwner=GetOwner();
			ENSURE(pOwner);
			return pOwner->SendMessage(message, wParam, lParam);
		}
	}
	return CControlBar::WindowProc(message, wParam, lParam);
}


IMPLEMENT_DYNAMIC(CReBar, CControlBar)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\array_w.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "stdafx.h"
#include <wchar.h>



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////

CWordArray::CWordArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CWordArray::~CWordArray()
{
	ASSERT_VALID(this);

	delete[] (BYTE*)m_pData;
}

void CWordArray::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		delete[] (BYTE*)m_pData;
		m_pData = NULL;
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(WORD));    // no overflow
#endif
		m_pData = (WORD*) new BYTE[nNewSize * sizeof(WORD)];

		memset(m_pData, 0, nNewSize * sizeof(WORD));  // zero fill

		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements

			memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));

		}

		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		INT_PTR nGrowArrayBy = m_nGrowBy;
		if (nGrowArrayBy == 0)
		{
			// heuristically determine growth when nGrowArrayBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowArrayBy = min(1024, max(4, m_nSize / 8));
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowArrayBy)
			nNewMax = m_nMaxSize + nGrowArrayBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(WORD)); // no overflow
#endif
		WORD* pNewData = (WORD*) new BYTE[nNewMax * sizeof(WORD)];

		// copy new data from old 
		Checked::memcpy_s(pNewData, nNewMax * sizeof(WORD), 
			m_pData, m_nSize * sizeof(WORD));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);

		memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

INT_PTR CWordArray::Append(const CWordArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);

	Checked::memcpy_s(m_pData + nOldSize, src.m_nSize * sizeof(WORD), 
		src.m_pData, src.m_nSize * sizeof(WORD));

	return nOldSize;
}

void CWordArray::Copy(const CWordArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);

		Checked::memcpy_s(m_pData, src.m_nSize * sizeof(WORD), 
			src.m_pData, src.m_nSize * sizeof(WORD));
	}

}

void CWordArray::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(WORD)); // no overflow
#endif
		WORD* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (WORD*) new BYTE[m_nSize * sizeof(WORD)];

			// copy new data from old 
			Checked::memcpy_s(pNewData, m_nSize * sizeof(WORD), 
				m_pData, m_nSize * sizeof(WORD));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

/////////////////////////////////////////////////////////////////////////////

void CWordArray::SetAtGrow(INT_PTR nIndex, WORD newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);
	m_pData[nIndex] = newElement;
}





void CWordArray::InsertAt(INT_PTR nIndex, WORD newElement, INT_PTR nCount)
{

	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();
		
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount);  // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount);  // grow it to new size

		// shift old data up to fill gap 
		Checked::memmove_s(&m_pData[nIndex+nCount], (m_nSize-(nIndex+nCount)) * sizeof(WORD), 
			&m_pData[nIndex], (nOldSize-nIndex) * sizeof(WORD));

		// re-init slots we copied from
		memset(&m_pData[nIndex], 0, nCount * sizeof(WORD));
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);



	// copy elements into the empty space
	while (nCount--)
		m_pData[nIndex++] = newElement;

}



void CWordArray::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();

	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);

	if (nMoveCount)
	{
		Checked::memmove_s(&m_pData[nIndex], nMoveCount * sizeof(WORD), 
			&m_pData[nUpperBound], nMoveCount * sizeof(WORD));
	}

	m_nSize -= nCount;
}

void CWordArray::InsertAt(INT_PTR nStartIndex, CWordArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_KINDOF(CWordArray, pNewArray);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}




/////////////////////////////////////////////////////////////////////////////
// Serialization

void CWordArray::Serialize(CArchive& ar)
{
	UINT_PTR nWORDsLeft;
	UINT nWORDsToWrite;
	UINT nWORDsToRead;
	LPWORD pwData;

	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
		nWORDsLeft = m_nSize;
		pwData = m_pData;
		while(nWORDsLeft > 0)
		{
			nWORDsToWrite = UINT(min(nWORDsLeft, INT_MAX/sizeof(WORD)));
			ar.Write(pwData, nWORDsToWrite*sizeof(WORD));
			nWORDsLeft -= nWORDsToWrite;
			pwData += nWORDsToWrite;
		}		
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize);
		nWORDsLeft = m_nSize;
		pwData = m_pData;
		while(nWORDsLeft > 0)
		{
			nWORDsToRead = UINT(min( nWORDsLeft, INT_MAX/sizeof(WORD)));
			ar.EnsureRead(pwData, nWORDsToRead*sizeof(WORD));
			nWORDsLeft -= nWORDsToRead;
			pwData += nWORDsToRead;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CWordArray::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		for (INT_PTR i = 0; i < m_nSize; i++)
			dc << "\n\t[" << i << "] = " << m_pData[i];
	}

	dc << "\n";
}

void CWordArray::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(WORD)));
	}
}
#endif //_DEBUG



IMPLEMENT_SERIAL(CWordArray, CObject, 0)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlconn.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Connection map

BEGIN_CONNECTION_MAP(COleControl, CCmdTarget)
	CONNECTION_PART(COleControl, IID_IPropertyNotifySink, PropConnPt)
END_CONNECTION_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleControl::GetConnectionHook - override the connection map

LPCONNECTIONPOINT COleControl::GetConnectionHook(REFIID iid)
{
	if ((m_piidEvents != NULL) && IsEqualIID(iid, *m_piidEvents))
		return (LPCONNECTIONPOINT)((char*)&m_xEventConnPt +
				offsetof(CConnectionPoint, m_xConnPt));
	else
		return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::GetExtraConnectionPoints - override the connection map

BOOL COleControl::GetExtraConnectionPoints(CPtrArray* pConnPoints)
{
	pConnPoints->Add((char*)&m_xEventConnPt +
		offsetof(CConnectionPoint, m_xConnPt));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XProvideClassInfo

STDMETHODIMP_(ULONG) COleControl::XProvideClassInfo::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, ProvideClassInfo)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XProvideClassInfo::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, ProvideClassInfo)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XProvideClassInfo::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, ProvideClassInfo)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XProvideClassInfo::GetClassInfo(
	LPTYPEINFO* ppTypeInfo)
{
	METHOD_PROLOGUE_EX(COleControl, ProvideClassInfo)

	CLSID clsid;
	pThis->GetClassID(&clsid);

	return pThis->GetTypeInfoOfGuid(GetUserDefaultLCID(), clsid, ppTypeInfo);
}

STDMETHODIMP COleControl::XProvideClassInfo::GetGUID(DWORD dwGuidKind,
	GUID* pGUID)
{
	METHOD_PROLOGUE_EX_(COleControl, ProvideClassInfo)

	if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
	{
		*pGUID = *pThis->m_piidEvents;
		return NOERROR;
	}
	else
	{
		*pGUID = GUID_NULL;
		return E_INVALIDARG;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XEventConnPt

void COleControl::XEventConnPt::OnAdvise(BOOL bAdvise)
{
	METHOD_PROLOGUE_EX(COleControl, EventConnPt)
	pThis->OnEventAdvise(bAdvise);
}

REFIID COleControl::XEventConnPt::GetIID()
{
	METHOD_PROLOGUE_EX_(COleControl, EventConnPt)
	if (pThis->m_piidEvents != NULL)
		return *(pThis->m_piidEvents);
	else
		return GUID_NULL;
}

HRESULT COleControl::XEventConnPt::QuerySinkInterface(LPUNKNOWN pUnkSink, 
	void** ppInterface)
{
	METHOD_PROLOGUE_EX_(COleControl, EventConnPt)

	*ppInterface = NULL;
	// First, QI for control-specific IID; failing that, QI for IDispatch
	HRESULT hResult;
	hResult = pUnkSink->QueryInterface(*(pThis->m_piidEvents), ppInterface);
	if (FAILED(hResult))
	{
		hResult = pUnkSink->QueryInterface(IID_IDispatch, ppInterface);
	}

	return hResult;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnEventAdvise - called by XEventConnPt::OnAdvise

void COleControl::OnEventAdvise(BOOL)
{
	// May be overridden by subclass
}

/////////////////////////////////////////////////////////////////////////////
// AfxConnectionAdvise

BOOL AFXAPI AfxConnectionAdvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD* pdwCookie)
{
	ASSERT_POINTER(pUnkSrc, IUnknown);
	ASSERT_POINTER(pUnkSink, IUnknown);
	ASSERT_POINTER(pdwCookie, DWORD);

	BOOL bSuccess = FALSE;

	LPCONNECTIONPOINTCONTAINER pCPC;

	if (SUCCEEDED(pUnkSrc->QueryInterface(
					IID_IConnectionPointContainer,
					(LPVOID*)&pCPC)))
	{
		ASSERT_POINTER(pCPC, IConnectionPointContainer);

		LPCONNECTIONPOINT pCP;

		if (SUCCEEDED(pCPC->FindConnectionPoint(iid, &pCP)))
		{
			ASSERT_POINTER(pCP, IConnectionPoint);

			if (SUCCEEDED(pCP->Advise(pUnkSink, pdwCookie)))
				bSuccess = TRUE;

			pCP->Release();

			// The connection point just AddRef'ed us.  If we don't want to
			// keep this reference count (because it would prevent us from
			// being deleted; our reference count wouldn't go to zero), then
			// we need to cancel the effects of the AddRef by calling
			// Release.

			if (bSuccess && !bRefCount)
				pUnkSink->Release();
		}

		pCPC->Release();
	}

	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// AfxConnectionUnadvise

BOOL AFXAPI AfxConnectionUnadvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD dwCookie)
{
	ASSERT_POINTER(pUnkSrc, IUnknown);
	ASSERT_POINTER(pUnkSink, IUnknown);

	// When we call Unadvise, the connection point will Release us.  If we
	// didn't keep the reference count when we called Advise, we need to
	// AddRef now, to keep our reference count consistent.  Note that if
	// the Unadvise fails, then we need to undo this extra AddRef by
	// calling Release before we return.

	if (!bRefCount)
		pUnkSink->AddRef();

	BOOL bSuccess = FALSE;

	LPCONNECTIONPOINTCONTAINER pCPC;

	if (SUCCEEDED(pUnkSrc->QueryInterface(
					IID_IConnectionPointContainer,
					(LPVOID*)&pCPC)))
	{
		ASSERT_POINTER(pCPC, IConnectionPointContainer);

		LPCONNECTIONPOINT pCP;

		if (SUCCEEDED(pCPC->FindConnectionPoint(iid, &pCP)))
		{
			ASSERT_POINTER(pCP, IConnectionPoint);

			if (SUCCEEDED(pCP->Unadvise(dwCookie)))
				bSuccess = TRUE;

			pCP->Release();
		}

		pCPC->Release();
	}

	// If we failed, undo the earlier AddRef.

	if (!bRefCount && !bSuccess)
		pUnkSink->Release();

	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlcache.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleCache

STDMETHODIMP_(ULONG) COleControl::XOleCache::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XOleCache::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XOleCache::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XOleCache::Cache(LPFORMATETC lpFormatetc, DWORD advf,
	LPDWORD lpdwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)

	if (pThis->m_pDefIOleCache == NULL)
		pThis->m_pDefIOleCache =
			(LPOLECACHE)pThis->QueryDefHandler(IID_IOleCache);

	return pThis->m_pDefIOleCache->Cache(lpFormatetc, advf, lpdwConnection);
}

STDMETHODIMP COleControl::XOleCache::Uncache(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)

	if (pThis->m_pDefIOleCache == NULL)
		pThis->m_pDefIOleCache =
			(LPOLECACHE)pThis->QueryDefHandler(IID_IOleCache);

	if (pThis->m_pDefIOleCache == NULL)
		return E_NOINTERFACE;
	return pThis->m_pDefIOleCache->Uncache(dwConnection);
}

STDMETHODIMP COleControl::XOleCache::EnumCache(
	LPENUMSTATDATA* ppenumStatData)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)

	if (pThis->m_pDefIOleCache == NULL)
		pThis->m_pDefIOleCache =
			(LPOLECACHE)pThis->QueryDefHandler(IID_IOleCache);

	return pThis->m_pDefIOleCache->EnumCache(ppenumStatData);
}

STDMETHODIMP COleControl::XOleCache::InitCache(LPDATAOBJECT pDataObject)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)

	if (pThis->m_pDefIOleCache == NULL)
		pThis->m_pDefIOleCache =
			(LPOLECACHE)pThis->QueryDefHandler(IID_IOleCache);

	return pThis->m_pDefIOleCache->InitCache(pDataObject);
}

STDMETHODIMP COleControl::XOleCache::SetData(LPFORMATETC pformatetc,
	STGMEDIUM* pmedium, BOOL fRelease)
{
	METHOD_PROLOGUE_EX_(COleControl, OleCache)

	if (pThis->m_pDefIOleCache == NULL)
		pThis->m_pDefIOleCache =
			(LPOLECACHE)pThis->QueryDefHandler(IID_IOleCache);

	return pThis->m_pDefIOleCache->SetData(pformatetc, pmedium, fRelease);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ccdata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// AfxGetPropSheetFont

struct _AFX_PROPPAGEFONTINFO : public CNoTrackObject
{
	LPTSTR m_pszFaceName;
	WORD m_wSize;
	_AFX_PROPPAGEFONTINFO() : m_pszFaceName(NULL), m_wSize(0) {}
	~_AFX_PROPPAGEFONTINFO() { GlobalFree(m_pszFaceName); }
};

PROCESS_LOCAL(_AFX_PROPPAGEFONTINFO, _afxPropPageFontInfo)

#define IDD_PROPSHEET   1006
#define IDD_WIZARD      1020

static int CALLBACK FontEnumProc(const LOGFONT*, const TEXTMETRIC*, DWORD, LPARAM lParam)
{
	if (lParam != NULL)
	{
		*(BOOL*)lParam = TRUE;
	}
	return 0;
}

static BOOL IsFontInstalled(LPCTSTR pszFace)
{
	BOOL bInstalled=FALSE;
	HDC hDC=NULL;
	LOGFONT lf;

	memset(&lf, 0, sizeof(lf));

	size_t nLenFace=_tcslen(pszFace);
	ENSURE(nLenFace<LF_FACESIZE);

	Checked::tcscpy_s(lf.lfFaceName, _countof(lf.lfFaceName), pszFace);
	lf.lfCharSet = DEFAULT_CHARSET;

	bInstalled = FALSE;
	hDC = ::GetDC(NULL);
	if (hDC != NULL)
	{
		::EnumFontFamiliesEx(hDC, &lf, FontEnumProc, (LPARAM)&bInstalled, 0);
		::ReleaseDC(NULL, hDC);
	}

	return bInstalled;
}

BOOL AFXAPI AfxGetPropSheetFont(CString& strFace, WORD& wSize, BOOL bWizard)
{
	_AFX_PROPPAGEFONTINFO* pFontInfo = _afxPropPageFontInfo.GetData();

	// determine which font property sheet will use
	if (pFontInfo->m_wSize == 0)
	{
		ASSERT(pFontInfo->m_pszFaceName == NULL);

		HINSTANCE hInst = afxComCtlWrapper->GetModuleHandle();
		if (hInst != NULL)
		{
			HRSRC hResource = NULL;
			WORD wLang = 0;
			LANGID langid;
			langid = GetUserDefaultUILanguage();
			if ((PRIMARYLANGID(langid) == LANG_JAPANESE) && IsFontInstalled(_T("MS UI Gothic")))
				wLang = MAKELANGID(LANG_JAPANESE, 0x3f);

			if (wLang != 0)
			{
				hResource = ::FindResourceExW(hInst, (LPWSTR) RT_DIALOG,
					MAKEINTRESOURCEW(bWizard ? IDD_WIZARD : IDD_PROPSHEET), wLang);
			}
			if (hResource == NULL)
			{
				hResource = ::FindResourceW(hInst,
					MAKEINTRESOURCEW(bWizard ? IDD_WIZARD : IDD_PROPSHEET),
					(LPWSTR) RT_DIALOG);
			}
			if(hResource!=NULL)
			{
				HGLOBAL hTemplate = LoadResource(hInst, hResource);
				if (hTemplate != NULL)
				{
					CDialogTemplate::GetFont((DLGTEMPLATE*)hTemplate, strFace,
						wSize);
				}
			}
		}

		pFontInfo->m_pszFaceName = (LPTSTR)GlobalAlloc(GPTR, static_cast<UINT>(::ATL::AtlMultiplyThrow(static_cast<UINT>((strFace.GetLength() + 1)),static_cast<UINT>(sizeof(TCHAR))) ));
		ENSURE_THROW(pFontInfo->m_pszFaceName!=NULL, ::AfxThrowMemoryException() );
		Checked::tcscpy_s(pFontInfo->m_pszFaceName, strFace.GetLength() + 1, strFace);
		pFontInfo->m_wSize = wSize;
	}

	strFace = pFontInfo->m_pszFaceName;
	wSize = pFontInfo->m_wSize;

	return (wSize != 0xFFFF);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#define _afxTrackingMenu (AfxGetThreadState()->m_hTrackingMenu)

/////////////////////////////////////////////////////////////////////////////
// Special WM_PAINT message handler that includes the HDC

#define ON_WM_PAINT_SPECIAL() \
	{ WM_PAINT, 0, 0, 0, AfxSig_vD, \
	(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CDC*))& ThisClass::OnPaint },

/////////////////////////////////////////////////////////////////////////////
// Window to serve as "parking space" for not-yet-activated subclassed controls

#ifdef _AFXDLL
AFX_MODULE_STATE* AFXAPI _AfxGetOleModuleState();
#endif

AFX_STATIC HWND AFXAPI _AfxGetParkingWindow()
{
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState != NULL);
	if (pThreadState->m_pWndPark == NULL)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(_AfxGetOleModuleState());
#else
		AFX_MANAGE_STATE(AfxGetModuleState());
#endif
		CWnd* pWndTmp = NULL;

		TRY
		{
#ifdef _DEBUG
			HWND hWndActive = ::GetActiveWindow();
#endif
			pWndTmp = new CParkingWnd;
			ASSERT(pWndTmp->m_hWnd != NULL);
#ifdef _DEBUG
			ASSERT(hWndActive == ::GetActiveWindow());
#endif
		}
		CATCH_ALL(e)
		{
			if (pWndTmp)
				delete pWndTmp;
			pWndTmp = NULL;
		}
		END_CATCH_ALL

		pThreadState->m_pWndPark = pWndTmp;
	}
	return pThreadState->m_pWndPark->GetSafeHwnd();
}

AFX_STATIC void AFXAPI _AfxReleaseParkingWindow()
{
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	ASSERT(pThreadState != NULL);
	ASSERT(pThreadState->m_nCtrlRef == 0);
	if (pThreadState->m_pWndPark != NULL)
	{
#ifdef _AFXDLL
		AFX_MANAGE_STATE(_AfxGetOleModuleState());
#else
		AFX_MANAGE_STATE(AfxGetModuleState());
#endif

		ASSERT(pThreadState->m_pWndPark->m_hWnd != NULL);
		ASSERT(::GetWindow(pThreadState->m_pWndPark->m_hWnd, GW_CHILD) == NULL);
		HWND hWnd = pThreadState->m_pWndPark->Detach();
		::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (INT_PTR)DefWindowProc);
		::DestroyWindow(hWnd);
		delete pThreadState->m_pWndPark;
		pThreadState->m_pWndPark = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl interface map

BEGIN_INTERFACE_MAP(COleControl, CCmdTarget)
	INTERFACE_PART(COleControl, IID_IQuickActivate, QuickActivate)
	INTERFACE_PART(COleControl, IID_IOleObject, OleObject)
	INTERFACE_PART(COleControl, IID_IViewObjectEx, ViewObject)
	INTERFACE_PART(COleControl, IID_IPersistMemory, PersistMemory)
	INTERFACE_PART(COleControl, IID_IPersistStreamInit, PersistStreamInit)
	INTERFACE_PART(COleControl, IID_IProvideClassInfo2, ProvideClassInfo)
	INTERFACE_PART(COleControl, IID_IConnectionPointContainer, ConnPtContainer)
	INTERFACE_PART(COleControl, IID_IOleControl, OleControl)
	INTERFACE_PART(COleControl, IID_IOleInPlaceObject, OleInPlaceObject)
	INTERFACE_PART(COleControl, IID_IOleInPlaceObjectWindowless, OleInPlaceObject)
	INTERFACE_PART(COleControl, IID_IOleInPlaceActiveObject, OleInPlaceActiveObject)
	INTERFACE_PART(COleControl, IID_IDispatch, Dispatch)
	INTERFACE_PART(COleControl, IID_IOleCache, OleCache)
	INTERFACE_PART(COleControl, IID_IViewObject, ViewObject)
	INTERFACE_PART(COleControl, IID_IViewObject2, ViewObject)
	INTERFACE_PART(COleControl, IID_IDataObject, DataObject)
	INTERFACE_PART(COleControl, IID_IPersistPropertyBag, PersistPropertyBag)
	INTERFACE_PART(COleControl, IID_ISpecifyPropertyPages, SpecifyPropertyPages)
	INTERFACE_PART(COleControl, IID_IPerPropertyBrowsing, PerPropertyBrowsing)
	INTERFACE_PART(COleControl, IID_IProvideClassInfo, ProvideClassInfo)
	INTERFACE_PART(COleControl, IID_IPersist, PersistStorage)
	INTERFACE_PART(COleControl, IID_IPersistStorage, PersistStorage)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleControl event map

const AFX_EVENTMAP COleControl::eventMap = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// COleControl message map

BEGIN_MESSAGE_MAP(COleControl, CWnd)
	ON_WM_PAINT_SPECIAL()
	//{{AFX_MSG_MAP(COleControl)
	ON_WM_ERASEBKGND()
	ON_WM_NCCREATE()
	ON_WM_NCCALCSIZE()
	ON_WM_SIZE()
	ON_WM_MOVE()
	ON_WM_SHOWWINDOW()
	ON_WM_CREATE()
	ON_MESSAGE(WM_SETTEXT, &COleControl::OnSetText)
	ON_WM_NCPAINT()
	ON_WM_DESTROY()
	ON_WM_ENTERIDLE()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_MESSAGE(OCM_CTLCOLORBTN, &COleControl::OnOcmCtlColorBtn)
	ON_MESSAGE(OCM_CTLCOLORDLG, &COleControl::OnOcmCtlColorDlg)
	ON_MESSAGE(OCM_CTLCOLOREDIT, &COleControl::OnOcmCtlColorEdit)
	ON_MESSAGE(OCM_CTLCOLORLISTBOX, &COleControl::OnOcmCtlColorListBox)
	ON_MESSAGE(OCM_CTLCOLORMSGBOX, &COleControl::OnOcmCtlColorMsgBox)
	ON_MESSAGE(OCM_CTLCOLORSCROLLBAR, &COleControl::OnOcmCtlColorScrollBar)
	ON_MESSAGE(OCM_CTLCOLORSTATIC, &COleControl::OnOcmCtlColorStatic)
	ON_WM_MOUSEMOVE()
	ON_WM_NCHITTEST()
	ON_WM_MOUSEACTIVATE()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MBUTTONDOWN()
	ON_WM_MBUTTONUP()
	ON_WM_MBUTTONDBLCLK()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_RBUTTONDBLCLK()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_CHAR()
	ON_WM_SYSKEYDOWN()
	ON_WM_SYSKEYUP()
	ON_WM_INITMENUPOPUP()
	ON_WM_MENUSELECT()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	ON_WM_GETDLGCODE()
	ON_MESSAGE(WM_SETMESSAGESTRING, &COleControl::OnSetMessageString)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleControl implementation

COleControl::COleControl() :
#ifdef _AFXDLL
	m_font(&m_xFontNotification)
#else
	m_font(NULL)
#endif
{
	// add to parking window reference count
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	++pState->m_nCtrlRef;

	m_bFinalReleaseCalled = FALSE;
	m_bChangingExtent = FALSE;
	m_bUIDead = FALSE;

	m_pReflect = NULL;
	m_pRectTracker = NULL;

	m_pClientSite = NULL;
	m_pOleAdviseHolder = NULL;
	m_pDataAdviseHolder = NULL;
	m_pInPlaceSite = NULL;
	m_pInPlaceFrame = NULL;
	m_pInPlaceDoc = NULL;
	m_pControlSite = NULL;

	m_pDefIUnknown = NULL;
	m_pDefIPersistStorage = NULL;
	m_pDefIViewObject = NULL;
	m_pDefIOleCache = NULL;
	m_pAdviseInfo = NULL;

	m_pUIActiveInfo = NULL;
	m_nIDTracking = 0;
	m_nIDLastMessage = 0;
	m_bAutoMenuEnable = TRUE;       // auto enable on by default

	m_bInPlaceActive = FALSE;
	m_bUIActive = FALSE;
	m_bPendingUIActivation = FALSE;
#ifdef _AFXDLL
	m_bOpen = FALSE;
	m_pWndOpenFrame = NULL;
#endif
	m_bInitialized = FALSE;

	m_dwVersionLoaded = 0;

	m_bModified = TRUE;

	m_iButtonState = 0;
	m_iDblClkState = 0;

	m_sBorderStyle = 0;
	m_sAppearance = 0;
	m_bEnabled = TRUE;
	m_lReadyState = READYSTATE_COMPLETE;

	m_hFontPrev = NULL;

	m_cEventsFrozen = 0;

	m_bConvertVBX = FALSE;

	m_pSimpleFrameSite = NULL;
	m_bSimpleFrame = FALSE;

	m_ptOffset.x = 0;
	m_ptOffset.y = 0;

	m_bNoRedraw = FALSE;

	m_bInPlaceSiteEx = FALSE;
	m_bInPlaceSiteWndless = FALSE;

	m_bOptimizedDraw = FALSE;

	m_bDataPathPropertiesLoaded = TRUE;
	
	m_piidPrimary = NULL;
	m_piidEvents = NULL;

	SetInitialSize(100, 50);

	// Wire up aggregation support
	EnableAggregation();

	// Wire up IDispatch support
	EnableAutomation();

	// Wire up connection map support
	EnableConnections();

	m_pDataSource = NULL;

	AfxOleLockApp();
}


COleControl::~COleControl()
{
	if (m_pDataSource != NULL)
		delete m_pDataSource;

	if (m_pReflect != NULL)
		m_pReflect->DestroyWindow();

#ifdef _AFXDLL
	if (m_pWndOpenFrame != NULL)
		m_pWndOpenFrame->DestroyWindow();
#endif

	ReleaseCaches();

	if (m_hWnd != NULL)
		DestroyWindow();

	// release parking window if reference count is now zero
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	ASSERT(pState != NULL);
	if (pState->m_nCtrlRef == 0 || --pState->m_nCtrlRef == 0)
		_AfxReleaseParkingWindow();

	AfxOleUnlockApp();
}

void COleControl::ReleaseCaches()
{
	RELEASE(m_pClientSite);
	RELEASE(m_pOleAdviseHolder);
	RELEASE(m_pDataAdviseHolder);
	RELEASE(m_pInPlaceSite);
	RELEASE(m_pInPlaceFrame);
	RELEASE(m_pInPlaceDoc);
	RELEASE(m_pControlSite);
	RELEASE(m_pSimpleFrameSite);

	LPUNKNOWN pUnk = GetControllingUnknown();

	InterlockedIncrement(&m_dwRef);  // Keep ref count from going to zero again.

	if (m_pDefIPersistStorage != NULL)
	{
		pUnk->AddRef();
		RELEASE(m_pDefIPersistStorage);
	}

	if (m_pDefIViewObject != NULL)
	{
		pUnk->AddRef();
		RELEASE(m_pDefIViewObject);
	}

	if (m_pDefIOleCache != NULL)
	{
		pUnk->AddRef();
		RELEASE(m_pDefIOleCache);
	}

	if (m_pAdviseInfo != NULL)
	{
		RELEASE(m_pAdviseInfo->m_pAdvSink);
		delete m_pAdviseInfo;
		m_pAdviseInfo = NULL;
	}

	RELEASE(m_pDefIUnknown);
	InterlockedDecrement(&m_dwRef);
}

void COleControl::OnFinalRelease()
{
	if (!m_bFinalReleaseCalled)
	{
		m_bFinalReleaseCalled = TRUE;

		ReleaseCaches();

		if (m_hWnd != NULL)
			DestroyWindow();

		CCmdTarget::OnFinalRelease();
	}
}

LPUNKNOWN COleControl::GetInterfaceHook(const void* piid)
{
	ASSERT_POINTER(piid, IID);

	if (m_piidPrimary != NULL && _AfxIsEqualGUID(*m_piidPrimary, *(IID*)piid))
	{
		return GetInterface((void*)&IID_IDispatch);
	}

	if (_AfxIsEqualGUID(IID_IPointerInactive, *(IID*)piid) &&
		(GetControlFlags() & pointerInactive))
	{
		return &m_xPointerInactive;
	}

	return NULL;
}

void COleControl::SetInitialSize(int cx, int cy)
{
	SIZEL szlPixels;
	SIZEL szlHimetric;
	szlPixels.cx = cx;
	szlPixels.cy = cy;
	_AfxXformSizeInPixelsToHimetric(NULL, &szlPixels, &szlHimetric);
	m_cxExtent = szlHimetric.cx;
	m_cyExtent = szlHimetric.cy;
}

BOOL COleControl::GetDispatchIID(IID* pIID)
{
	if (m_piidPrimary != NULL)
		*pIID = *m_piidPrimary;

	return (m_piidPrimary != NULL);
}

void COleControl::InitializeIIDs(const IID* piidPrimary, const IID* piidEvents)
{
	m_piidPrimary = piidPrimary;
	m_piidEvents = piidEvents;

	EnableTypeLib();

	// Initialize the masks for stock events and properties.
	InitStockEventMask();
	InitStockPropMask();

#ifdef _DEBUG

	// Verify that the type library contains all the correct information.
	// If any of the following assertions fail, carefully check the IDs
	// in the control's .CPP file against those in its .ODL file.

	LPTYPEINFO pTypeInfo;
	HRESULT hr;
	CLSID clsid;

	GetClassID(&clsid);
	if (SUCCEEDED(hr = GetTypeInfoOfGuid(0, clsid, &pTypeInfo)))
		RELEASE(pTypeInfo);

	ASSERT(SUCCEEDED(hr));  // Class ID may be corrupted

	if (SUCCEEDED(hr = GetTypeInfoOfGuid(0, *m_piidPrimary, &pTypeInfo)))
		RELEASE(pTypeInfo);

	ASSERT(SUCCEEDED(hr));  // Primary dispatch interface ID may be corrupted

	if (SUCCEEDED(hr = GetTypeInfoOfGuid(0, *m_piidEvents, &pTypeInfo)))
		RELEASE(pTypeInfo);

	ASSERT(SUCCEEDED(hr));  // Event dispatch interface ID may be corrupted

#endif
}

#ifdef _DEBUG

void COleControl::AssertValid() const
{
	CWnd::AssertValid();
}

void AFXAPI _AfxDumpGuid(CDumpContext& dc, const GUID* pGuid)
{	
	if (pGuid == NULL)
	{
		dc << "(NULL)";
		return;
	}

	OLECHAR szGuid[40];
	::StringFromGUID2(*pGuid, szGuid, 40);
	const CString strGuid(szGuid);
	dc << strGuid;
}

void AFXAPI _AfxDumpHex(CDumpContext& dc, DWORD dw)
{
	TCHAR szHex[16];
	_stprintf_s(szHex, _countof(szHex), _T("0x%08lx"), dw);
	dc << szHex;
}

void COleControl::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);
	dc << "\nm_pModuleState = " << m_pModuleState;
	dc << "\nm_piidPrimary = ";
	_AfxDumpGuid(dc, m_piidPrimary);
	dc << "\nm_piidEvents =  ";
	_AfxDumpGuid(dc, m_piidEvents);
	dc << "\nm_dwVersionLoaded = ";
	_AfxDumpHex(dc, m_dwVersionLoaded);
	dc << "\nm_cEventsFrozen = " << m_cEventsFrozen;
	dc << "\nm_rcPos = " << m_rcPos;
	dc << "\nm_cxExtent = " << m_cxExtent;
	dc << "\nm_cyExtent = " << m_cyExtent;
	dc << "\nm_bFinalReleaseCalled = " << m_bFinalReleaseCalled;
	dc << "\nm_bModified = " << m_bModified;
	dc << "\nm_bCountOnAmbients = " << m_bCountOnAmbients;
	dc << "\nm_iButtonState = " << m_iButtonState;
	dc << "\nm_iDblClkState = " << m_iDblClkState;
	dc << "\nm_bInPlaceActive = " << m_bInPlaceActive;
	dc << "\nm_bUIActive = " << m_bUIActive;
	dc << "\nm_bPendingUIActivation = " << m_bPendingUIActivation;
#ifdef _AFXDLL
	dc << "\nm_bOpen = " << m_bOpen;
#endif
	dc << "\nm_bChangingExtent = " << m_bChangingExtent;
	dc << "\nm_bConvertVBX = " << m_bConvertVBX;
	dc << "\nm_bSimpleFrame = " << m_bSimpleFrame;
	dc << "\nm_bUIDead = " << m_bUIDead;
}

#endif // _DEBUG

void COleControl::DoSuperclassPaint(CDC* pDC, const CRect& rcBounds)
{
	if (m_hWnd == NULL)
		CreateWindowForSubclassedControl();

	if (m_hWnd != NULL)
	{
		CRect rcClient;
		GetClientRect(&rcClient);

		if (rcClient.Size() != rcBounds.Size())
		{
			pDC->SetMapMode(MM_ANISOTROPIC);
			pDC->SetWindowExt(rcClient.right, rcClient.bottom);
			pDC->SetViewportExt(rcBounds.Size());
		}
		pDC->SetWindowOrg(0, 0);
		pDC->SetViewportOrg(rcBounds.left, rcBounds.top);

		::CallWindowProc(*GetSuperWndProcAddr(), m_hWnd, WM_PRINT, 
			(WPARAM)(pDC->m_hDC), (LPARAM)(PRF_CHILDREN | PRF_CLIENT));
	}
}

BOOL COleControl::IsSubclassedControl()
{
	// This default implementation provides some degree of backward
	// compatibility with old controls. New subclassed controls should just
	// override IsSubclassedControl and return TRUE.
	return m_pfnSuper == NULL &&
		GetSuperWndProcAddr() != CWnd::GetSuperWndProcAddr();
}

BOOL COleControl::CreateControlWindow(HWND hWndParent, const CRect& rcPos,
	LPCRECT prcClip)
{
	if (m_hWnd == NULL)
	{
		// If window doesn't exist, create it.

		// Test if:
		// we're not subclassing a Windows control, or
		// container reflects messages for us...

		DWORD dwStyle = WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN;
		if (m_sBorderStyle)
			dwStyle |= WS_BORDER;
		if (!m_bEnabled)
			dwStyle |= WS_DISABLED;
		DWORD dwExStyle = WS_EX_NOPARENTNOTIFY;
		if (m_sAppearance)
			dwExStyle |= WS_EX_CLIENTEDGE;

		// we create normally if:
		//       (we're not subclassing -or- the container reflects)
		// -and- the container autoclips for us
		if ((!IsSubclassedControl() || m_bMsgReflect) && m_bAutoClip)
		{
			// Just create the control's window.
			VERIFY(AfxDeferRegisterClass(AFX_WNDOLECONTROL_REG));
			CreateEx(dwExStyle, AFX_WNDOLECONTROL, m_strText, dwStyle,
				rcPos.left, rcPos.top, rcPos.Width(), rcPos.Height(),
				hWndParent, 0);
		}
		else    // ...we're subclassing a Windows control.
		{
			if (m_pReflect == NULL)
			{
				// Create a window to reflect notification messages.
				m_pReflect = new CReflectorWnd;
				if (prcClip == NULL)
					prcClip = rcPos;
				if (!m_pReflect->Create(prcClip, hWndParent))
				{
					// If m_pReflect->Create failed, then m_pReflect deleted itself.
					m_pReflect = NULL;
				}
			}
			else
			{
				// Reflector window already exists... just reparent it.
				if (m_pReflect->m_hWnd != NULL)
				{
					::SetParent(m_pReflect->m_hWnd, hWndParent);
					::SetWindowPos(m_pReflect->m_hWnd, NULL, 0, 0, 0, 0,
						SWP_NOZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|
						SWP_SHOWWINDOW);
				}
			}

			if (m_pReflect != NULL && m_pReflect->m_hWnd != NULL)
			{
				// Create the control's window.
				CreateEx(dwExStyle, NULL, m_strText, dwStyle,
					m_ptOffset.x, m_ptOffset.y, rcPos.Width(), rcPos.Height(),
					m_pReflect->m_hWnd, 0);
				if (m_hWnd == NULL)
				{
					// Window creation failed: cleanup.
					m_pReflect->DestroyWindow();
					m_pReflect = NULL;
				}
			}
		}

		// Set the new window's font.
		OnFontChanged();
	}
	else
	{
		// If window does exist, reparent it...
		CWnd* pWndOuter = GetOuterWindow();
		ASSERT(pWndOuter != NULL);

		if (::GetParent(pWndOuter->m_hWnd) != hWndParent)
			ReparentControlWindow(pWndOuter->m_hWnd, hWndParent);

		::SetWindowPos(pWndOuter->m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|
			SWP_SHOWWINDOW);

		// And then reposition it...
		OnSetObjectRects(rcPos, prcClip);
	}

	ASSERT(m_hWnd != NULL);
	return (m_hWnd != NULL);
}

void COleControl::ReparentControlWindow(HWND hWndOuter, HWND hWndParent)
{
	// can be overridden by subclass, if necessary
	::SetParent(hWndOuter, hWndParent);
}

void COleControl::GetControlSize(int* pcx, int* pcy)
{
	ASSERT_POINTER(pcx, int);
	ASSERT_POINTER(pcy, int);

	SIZEL szlHimetric;
	SIZEL szlPixels;
	szlHimetric.cx = m_cxExtent;
	szlHimetric.cy = m_cyExtent;
	_AfxXformSizeInHimetricToPixels(NULL, &szlHimetric, &szlPixels);
	*pcx = (int)szlPixels.cx;
	*pcy = (int)szlPixels.cy;
}

BOOL COleControl::SetControlSize(int cx, int cy)
{
	SIZEL szlPixels;
	SIZEL szlHimetric;
	szlPixels.cx = cx;
	szlPixels.cy = cy;
	_AfxXformSizeInPixelsToHimetric(NULL, &szlPixels, &szlHimetric);
	return SUCCEEDED(m_xOleObject.SetExtent(DVASPECT_CONTENT, &szlHimetric));
}

BOOL COleControl::SetRectInContainer(LPCRECT lpRect)
{
	if ((m_pInPlaceSite != NULL) && m_bInPlaceActive)
	{
		m_pInPlaceSite->OnPosRectChange(lpRect);
		return TRUE;
	}
#ifdef _AFXDLL
	else if (m_bOpen)
	{
		ResizeOpenControl(lpRect->right - lpRect->left,
				lpRect->bottom - lpRect->top);
		return TRUE;
	}
#endif

	return FALSE;
}

void COleControl::OnResetState()
{
	CResetPropExchange px;
	DoPropExchange(&px);
	InvalidateControl();
}

#ifndef BDR_INNER
#define BDR_INNER	0x000c
#endif
#ifndef BDR_OUTER
#define BDR_OUTER	0x0003
#endif

void AFXAPI _AfxDrawBorders(CDC* pDC, CRect& rc, BOOL bBorder, BOOL bClientEdge)
{
	if (bBorder)
		::DrawEdge(pDC->m_hDC, &rc, (bClientEdge ? BDR_INNER : BDR_OUTER),
			BF_RECT | BF_ADJUST | (bClientEdge ? BF_FLAT : BF_MONO));

	if (bClientEdge)
		::DrawEdge(pDC->m_hDC, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
}

void COleControl::DrawContent(CDC* pDC, CRect& rc)
{
	// Map into device coordinates.

	pDC->LPtoDP(&rc);
	int iSaveDC = 0;
	if (! m_bOptimizedDraw)
		iSaveDC = pDC->SaveDC();
	pDC->SetViewportOrg(0, 0);
	pDC->SetWindowOrg(0, 0);
	pDC->SetMapMode(MM_TEXT);
	m_rcBounds = rc;
	if (pDC->GetDeviceCaps(TECHNOLOGY) == DT_RASDISPLAY)
		_AfxDrawBorders(pDC, rc, (m_sBorderStyle == 1), (m_sAppearance == 1));
	OnDraw(pDC, rc, rc);
	if (! m_bOptimizedDraw && iSaveDC != 0)
		pDC->RestoreDC(iSaveDC);
}

void COleControl::DrawMetafile(CDC* pDC, CRect& rc)
{
	int iSaveDC = 0;
	if (! m_bOptimizedDraw)
		iSaveDC = pDC->SaveDC();
	m_rcBounds = rc;
	_AfxDrawBorders(pDC, rc, (m_sBorderStyle == 1), (m_sAppearance == 1));
	OnDrawMetafile(pDC, rc);
	if (! m_bOptimizedDraw && iSaveDC != 0)
		pDC->RestoreDC(iSaveDC);
}

void COleControl::OnDraw(CDC*, const CRect&, const CRect&)
{
	// To be overridden by subclass.
}

void COleControl::OnDrawMetafile(CDC* pDC, const CRect& rcBounds)
{
	// By default, we draw into metafile the same way we would draw to the
	// screen.  This may be overridden by the subclass.

	OnDraw(pDC, rcBounds, rcBounds);
}

BOOL COleControl::GetMetafileData(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ASSERT(lpStgMedium->tymed == TYMED_NULL);   // GetDataHere not valid
	ASSERT(lpStgMedium->pUnkForRelease == NULL);

	// medium must be TYMED_MFPICT -- cannot fill in existing HGLOBAL
	if (!(lpFormatEtc->tymed & TYMED_MFPICT) || lpStgMedium->hGlobal != NULL)
		return FALSE;

	// create appropriate memory metafile DC
	CMetaFileDC dc;
	if (!dc.Create())
		return FALSE;

	// create attribute DC according to lpFormatEtc->ptd
	HDC hAttribDC = ::_AfxOleCreateDC(lpFormatEtc->ptd);
	dc.SetAttribDC(hAttribDC);

	// Paint directly into the metafile.
	int cx;
	int cy;
	GetControlSize(&cx, &cy);
	CRect rc(0, 0, cx, cy);
	dc.SetMapMode(MM_ANISOTROPIC);
	dc.SetWindowOrg(0, 0);
	dc.SetWindowExt(cx, cy);
	DrawMetafile(&dc, rc);

	// attribute DC is no longer necessary
	dc.SetAttribDC(NULL);
	::DeleteDC(hAttribDC);

	HMETAFILE hMF;
	hMF = (HMETAFILE)dc.Close();
	if (hMF == NULL)
		return FALSE;

	HGLOBAL hPict;
	if ((hPict = ::GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT))) == NULL)
	{
		DeleteMetaFile(hMF);
		return FALSE;
	}
	LPMETAFILEPICT lpPict;
	if ((lpPict = (LPMETAFILEPICT)::GlobalLock(hPict)) == NULL)
	{
		DeleteMetaFile(hMF);
		::GlobalFree(hPict);
		return FALSE;
	}

	// set the metafile size
	lpPict->mm = MM_ANISOTROPIC;
	lpPict->hMF = hMF;
	lpPict->xExt = (int)m_cxExtent;
	lpPict->yExt = (int)m_cyExtent;

	// return the medium with the hGlobal to the METAFILEPICT
	::GlobalUnlock(hPict);
	lpStgMedium->hGlobal = hPict;
	lpStgMedium->tymed = TYMED_MFPICT;
	return TRUE;
}

BOOL COleControl::OnCreateAggregates()
{
	return TRUE;
}

LPVOID COleControl::QueryDefHandler(REFIID iid)
{
	// If we're being aggregated, we want to pass the outer unknown
	// to the object we're aggregating (the default handler).
	// Otherwise, we pass our own "inner" unknown.
	// That's what GetControllingUnknown() does.

	LPUNKNOWN pUnk = GetControllingUnknown();

	CLSID clsid;
	GetClassID(&clsid);

	if (m_pDefIUnknown == NULL)
	{
		// Note: This call will not increment pUnk's reference count.
		HRESULT hr = CreateDataCache(pUnk, clsid,
			IID_IUnknown, (LPLPVOID)&m_pDefIUnknown);

		if (FAILED(hr))
			return NULL;
	}

	LPVOID pNew;

	// Note: For the following QueryInterface call, we want to prevent
	// pUnk's reference count from being incremented.  So, if the
	// call succeeds, we immediately force a decrement of the reference count.

	if (SUCCEEDED(m_pDefIUnknown->QueryInterface(iid, &pNew)))
	{
		ASSERT(pNew != NULL);
		pUnk->Release();
	}

	return pNew;
}

void COleControl::InvalidateControl(LPCRECT lpRect, BOOL bErase)
{
	if (m_bInPlaceActive && m_bInPlaceSiteWndless)
	{
		CRect rect;
		if (lpRect != NULL)
		{
			CPoint point(0, 0);
			ClientToParent(m_rcPos, &point);
			rect.CopyRect(lpRect);
			rect.OffsetRect(point);
			lpRect = &rect;
		}
		m_pInPlaceSiteWndless->InvalidateRect(lpRect, bErase);
	}
#ifdef _AFXDLL
	else if (m_bInPlaceActive || m_bOpen)
#else
	else if (m_bInPlaceActive)
#endif
	{
		InvalidateRect(lpRect, bErase);
	}
	else
	{
		SendAdvise(OBJECTCODE_VIEWCHANGED);
	}

	if (m_bModified)
		SendAdvise(OBJECTCODE_DATACHANGED);
}

CWnd* COleControl::GetOuterWindow() const
{
	return (m_pReflect != NULL ? (CWnd*)m_pReflect : (CWnd*)this);
}

void COleControl::OnReflectorDestroyed()
{
	m_pReflect = NULL;
}

HRESULT COleControl::SaveState(IStream* pstm)
{
	HRESULT hr = S_OK;

	TRY
	{
		// Delegate to the Serialize method.
		COleStreamFile file(pstm);
		CArchive ar(&file, CArchive::store);
		Serialize(ar);
	}
	CATCH_ALL(e)
	{
		hr = E_FAIL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	return hr;
}

HRESULT COleControl::LoadState(IStream* pstm)
{
	HRESULT hr = S_OK;

	TRY
	{
		// Delegate to the Serialize method.
		COleStreamFile file(pstm);
		CArchive ar(&file, CArchive::load);
		Serialize(ar);
	}
	CATCH_ALL(e)
	{
		// The load failed.  Delete any partially-initialized state.
		OnResetState();
		m_bInitialized = TRUE;
		hr = E_FAIL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// Clear the modified flag.
	m_bModified = FALSE;

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return hr;
}

void COleControl::SendAdvise(UINT uCode)
{
	// Calls the appropriate IOleClientSite or IAdviseSink member function
	// for various events such as closure, renaming, saving, etc.

	switch (uCode)
	{
	case OBJECTCODE_SAVED:
		if (m_pOleAdviseHolder != NULL)
			m_pOleAdviseHolder->SendOnSave();
		break;

	case OBJECTCODE_CLOSED:
		if (m_pOleAdviseHolder != NULL)
			m_pOleAdviseHolder->SendOnClose();
		break;

	case OBJECTCODE_SAVEOBJECT:
		if (m_bModified && m_pClientSite != NULL)
			m_pClientSite->SaveObject();
		break;

	case OBJECTCODE_DATACHANGED:
		//No flags are necessary here.
		if (m_pDataAdviseHolder != NULL)
			m_pDataAdviseHolder->SendOnDataChange(&m_xDataObject, 0, 0);
		break;

	case OBJECTCODE_SHOWWINDOW:
		if (m_pClientSite != NULL)
			m_pClientSite->OnShowWindow(TRUE);
		break;

	case OBJECTCODE_HIDEWINDOW:
		if (m_pClientSite != NULL)
			m_pClientSite->OnShowWindow(FALSE);
		break;

	case OBJECTCODE_SHOWOBJECT:
		if (m_pClientSite != NULL)
			m_pClientSite->ShowObject();
		break;

	case OBJECTCODE_VIEWCHANGED:
		{
			DWORD aspects;
			DWORD advf;
			LPADVISESINK pAdvSink;

			if (SUCCEEDED(m_xViewObject.GetAdvise(&aspects, &advf, &pAdvSink)) &&
				(pAdvSink != NULL))
			{
				pAdvSink->OnViewChange(DVASPECT_CONTENT, -1);
				pAdvSink->Release();
			}
		}
		break;
	}
}

HRESULT COleControl::OnHide()
{
#ifdef _AFXDLL
	CWnd* pWnd = m_bOpen ? m_pWndOpenFrame : GetOuterWindow();
#else
	CWnd* pWnd = GetOuterWindow();
#endif
	if (pWnd != NULL && pWnd->m_hWnd != NULL)
		::ShowWindow(pWnd->m_hWnd, SW_HIDE);

	RELEASE(m_pInPlaceFrame);
	RELEASE(m_pInPlaceDoc);

#ifdef _AFXDLL
	if (m_bOpen)
		SendAdvise(OBJECTCODE_HIDEWINDOW);
#endif

	return S_OK;
}

HRESULT COleControl::OnOpen(BOOL bTryInPlace, LPMSG pMsg)
{
#ifndef _AFXDLL
	ASSERT(bTryInPlace);	// fully-open mode not supported in static builds
	UNUSED_ALWAYS(bTryInPlace);
#endif

#ifndef _AFXDLL
	return OnActivateInPlace(TRUE, pMsg);
#else
	if (!m_bOpen)
	{
		// If not already open, try in-place activating.
		if (bTryInPlace && SUCCEEDED(OnActivateInPlace(bTryInPlace, pMsg)))
			return S_OK;

		// If already in-place active, deactivate first.
		if (m_bInPlaceActive)
			m_xOleInPlaceObject.InPlaceDeactivate();

		m_bOpen = TRUE;

		// Open a separate window.
		if (m_pWndOpenFrame == NULL)
		{
			// Create frame window
			m_pWndOpenFrame = CreateFrameWindow();

			if (m_pWndOpenFrame == NULL)
				return E_FAIL;

			// Size frame window to exactly contain the control.
			int cx;
			int cy;
			GetControlSize(&cx, &cy);
			ResizeFrameWindow(cx, cy);

			// Create and/or reparent the control's window.
			CRect rectClient;
			m_pWndOpenFrame->GetClientRect(&rectClient);
			if (!CreateControlWindow(m_pWndOpenFrame->m_hWnd, rectClient, rectClient))
				return E_FAIL;
		}
	}

	// Make the frame window visible and activate it.
	ASSERT(m_pWndOpenFrame != NULL);
	m_pWndOpenFrame->ShowWindow(SW_SHOW);
	m_pWndOpenFrame->SetActiveWindow();
	SendAdvise(OBJECTCODE_SHOWWINDOW);
	return S_OK;
#endif
}

#ifdef _AFXDLL
CControlFrameWnd* COleControl::CreateFrameWindow()
{
	TCHAR szUserType[256];
	GetUserType(szUserType);

	CControlFrameWnd* pWnd = new CControlFrameWnd(this);
	if (!pWnd->Create(szUserType))
	{
		// If Create failed, then frame window has deleted itself.
		pWnd = NULL;
	}

	return pWnd;
}

void COleControl::OnFrameClose()
{
	// Reparent control to prevent its window from being destroyed.
	CWnd* pWnd = GetOuterWindow();
	if (pWnd != NULL)
	{
		::SetWindowPos(pWnd->m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|
			SWP_HIDEWINDOW);
		pWnd->SetParent(NULL);
	}

	m_pWndOpenFrame = NULL;
	m_bOpen = FALSE;

	m_xOleObject.Close(OLECLOSE_SAVEIFDIRTY);

	SendAdvise(OBJECTCODE_HIDEWINDOW);
	SendAdvise(OBJECTCODE_CLOSED);
}

void COleControl::ResizeOpenControl(int cx, int cy)
{
	CWnd* pWndOuter = GetOuterWindow();
	if ((pWndOuter != NULL) && (pWndOuter->m_hWnd != NULL))
		::SetWindowPos(pWndOuter->m_hWnd, NULL, 0, 0, cx, cy,
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
	ResizeFrameWindow(cx, cy);
}

void COleControl::ResizeFrameWindow(int cxCtrl, int cyCtrl)
{
	ENSURE(m_pWndOpenFrame != NULL);
	m_pWndOpenFrame->SetWindowPos(NULL, 0, 0, 100, 100,
				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
	CRect rectClient;
	m_pWndOpenFrame->GetClientRect(&rectClient);
	CRect rectWindow;
	m_pWndOpenFrame->GetWindowRect(&rectWindow);
	int cx = cxCtrl + rectWindow.Width()  - rectClient.Width();
	int cy = cyCtrl + rectWindow.Height() - rectClient.Height();
	m_pWndOpenFrame->SetWindowPos(NULL, 0, 0, cx, cy,
				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
}

#endif //_AFXDLL

BOOL COleControl::GetRectInContainer(LPRECT lpRect)
{
	if (m_bInPlaceActive)
		CopyRect(lpRect, &m_rcPos);

	return m_bInPlaceActive;
}

LPCLSID COleControl::GetPropPageIDs(ULONG& cPropPages)
{
	cPropPages = 0;
	return NULL;
}

BOOL COleControl::OnEdit(LPMSG lpMsg, HWND, LPCRECT lpRect)
{
	CopyRect(m_rcPos, lpRect);
	return SUCCEEDED(OnActivateInPlace(TRUE, lpMsg));
}

HWND AFXAPI _AfxGetTopLevelWindow(HWND hWnd)
{
	HWND hWndTop;

	do
	{
		hWndTop = hWnd;
		hWnd = ::GetParent(hWnd);
	}
	while (hWnd != NULL);

	return hWndTop;
}

BOOL COleControl::OnProperties(LPMSG, HWND hWndParent, LPCRECT)
{
	HRESULT hr;

	if ((m_pControlSite == NULL) ||
		FAILED(hr = m_pControlSite->ShowPropertyFrame()))
	{
		LPUNKNOWN pUnk = GetIDispatch(FALSE);
		HWND hWndOwner = CWnd::GetSafeOwner_(hWndParent, NULL);

		LCID lcid = AmbientLocaleID();

		ULONG cPropPages;
		LPCLSID pclsidPropPages = GetPropPageIDs(cPropPages);

		RECT rectParent;
		RECT rectTop;
		::GetWindowRect(hWndParent, &rectParent);
		::GetWindowRect(hWndOwner, &rectTop);

		TCHAR szUserType[256];
		GetUserType(szUserType);

		PreModalDialog(hWndOwner);
		const CStringW strUserType(szUserType);
		hr = ::OleCreatePropertyFrame(hWndOwner, rectParent.left - rectTop.left,
				rectParent.top - rectTop.top, strUserType.GetString(), 1, &pUnk,
				cPropPages, pclsidPropPages, lcid, NULL, 0);
		PostModalDialog(hWndOwner);
	}

	return SUCCEEDED(hr);
}

DWORD COleControl::GetControlFlags()
{
	return clipPaintDC;
}

void COleControl::OnPaint(CDC* pDC)
{
	if (m_bNoRedraw)
	{
		// flicker-free activation: no need to repaint
		ValidateRect(NULL);
		m_bNoRedraw = FALSE;    // one time only
		return;
	}

	AfxLockTempMaps();

	GetWindowRect(m_rcBounds);
	m_rcBounds.OffsetRect(-m_rcBounds.left, -m_rcBounds.top);

	// Adjust bounds for size of UI Active tracker, if any.
#ifdef _AFXDLL
	if (!m_bOpen && (m_pRectTracker != NULL))
#else
	if (m_pRectTracker != NULL)
#endif
	{
		int nHandleSize = (int)m_pRectTracker->m_nHandleSize - 1;
		m_rcBounds.InflateRect(-nHandleSize, -nHandleSize);
	}

	CRect rcClient;
	GetClientRect(rcClient);

	if (pDC != NULL)
	{
		// We were passed a device context: use it.
		int iSaveDC = pDC->SaveDC();
		OnDraw(pDC, rcClient, rcClient);
		pDC->RestoreDC(iSaveDC);
	}
	else
	{
#ifdef _DEBUG
		int nFlags = GetControlFlags();
		if (nFlags & fastBeginPaint)
			TRACE(traceAppMsg, 0, "Warning: COleControl::fastBeginPaint is obsolete.\n");
#endif

		CPaintDC dc(this);
		OnDraw(&dc, rcClient, &dc.m_ps.rcPaint);
	}

	AfxUnlockTempMaps();
}

BOOL COleControl::OnEraseBkgnd(CDC* pDC)
{
	// do nothing -- controls erase their background in their OnDraw
	if (IsSubclassedControl())
		return CWnd::OnEraseBkgnd(pDC);
	else
		return TRUE;
}

void  COleControl::Serialize(CArchive& ar)
{
	CArchivePropExchange px(ar);
	DoPropExchange(&px);
	if (ar.IsLoading())
	{
		BoundPropertyChanged(DISPID_UNKNOWN);
		InvalidateControl();
	}
}

void COleControl::DoPropExchange(CPropExchange* pPX)
{
	ASSERT_POINTER(pPX, CPropExchange);

	ExchangeExtent(pPX);
	ExchangeStockProps(pPX);
}

/////////////////////////////////////////////////////////////////////////////
// Wrappers for IOleControlSite

void COleControl::ControlInfoChanged()
{
	if (m_pControlSite != NULL)
		m_pControlSite->OnControlInfoChanged();
}

BOOL COleControl::LockInPlaceActive(BOOL bLock)
{
	if (m_pControlSite != NULL)
		return SUCCEEDED(m_pControlSite->LockInPlaceActive(bLock));

	return FALSE;
}

LPDISPATCH COleControl::GetExtendedControl()
{
	LPDISPATCH pDispatch = NULL;
	if (m_pControlSite != NULL)
		m_pControlSite->GetExtendedControl(&pDispatch);

	return pDispatch;
}

void COleControl::TransformCoords(POINTL* lpptlHimetric,
	POINTF* lpptfContainer, DWORD flags)
{
	if ((m_pControlSite == NULL) ||
		(FAILED(m_pControlSite->TransformCoords(lpptlHimetric,
			lpptfContainer, flags))))
	{
		// Transformation failed, use the identity transformation

		if (flags & XFORMCOORDS_CONTAINERTOHIMETRIC)
		{
			lpptlHimetric->x = (long)lpptfContainer->x;
			lpptlHimetric->y = (long)lpptfContainer->y;
		}
		else
		{
			lpptfContainer->x = (float)lpptlHimetric->x;
			lpptfContainer->y = (float)lpptlHimetric->y;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleControl

STDMETHODIMP_(ULONG) COleControl::XOleControl::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, OleControl)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XOleControl::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, OleControl)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XOleControl::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, OleControl)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XOleControl::GetControlInfo(LPCONTROLINFO pCI)
{
	METHOD_PROLOGUE_EX(COleControl, OleControl)
	pThis->OnGetControlInfo(pCI);
	return S_OK;
}

STDMETHODIMP COleControl::XOleControl::OnMnemonic(LPMSG pMsg)
{
	METHOD_PROLOGUE_EX(COleControl, OleControl)
	pThis->OnMnemonic(pMsg);
	return S_OK;
}

STDMETHODIMP COleControl::XOleControl::OnAmbientPropertyChange(DISPID dispid)
{
	METHOD_PROLOGUE_EX(COleControl, OleControl)

	if (dispid == DISPID_AMBIENT_UIDEAD || dispid == DISPID_UNKNOWN)
		pThis->m_bUIDead = (BYTE)(pThis->AmbientUIDead());

	pThis->OnAmbientPropertyChange(dispid);
	return S_OK;
}

STDMETHODIMP COleControl::XOleControl::FreezeEvents(BOOL bFreeze)
{
	METHOD_PROLOGUE_EX(COleControl, OleControl)

	ULONG& cEventsFrozen = pThis->m_cEventsFrozen;

	if (bFreeze)
		++(cEventsFrozen);
	else
		--(cEventsFrozen);

	//ASSERT(cEventsFrozen >= 0); // Should never go below zero!

	if ((cEventsFrozen == 1 && bFreeze) ||
		(cEventsFrozen == 0 && !bFreeze))
	{
		pThis->OnFreezeEvents(bFreeze);
	}

	return S_OK;
}

void COleControl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
{
	// Subclass may override

	pControlInfo->hAccel = NULL;
	pControlInfo->cAccel = 0;
	pControlInfo->dwFlags = 0;
}

void COleControl::OnMnemonic(LPMSG)
{
	// To be implemented by subclass
}

void COleControl::OnAmbientPropertyChange(DISPID)
{
	// To be implemented by subclass
}

void COleControl::OnFreezeEvents(BOOL)
{
	// To be implemented by subclass
}

void COleControl::OnSetClientSite()
{
	if (!m_bDataPathPropertiesLoaded)
	{
		CAsyncPropExchange PX(m_dwDataPathVersionToReport);
		DoPropExchange(&PX);
		m_bDataPathPropertiesLoaded=TRUE;
	}
}

LPOLECLIENTSITE COleControl::GetClientSite()
{
	return m_pClientSite;
}

COLORREF COleControl::TranslateColor(OLE_COLOR clrColor, HPALETTE hpal)
{
	COLORREF cr = RGB(0x00,0x00,0x00);
	::OleTranslateColor(clrColor, hpal, &cr);

	return cr;
}

void COleControl::Refresh()
{
	InvalidateControl();
	if (m_hWnd != NULL)
		UpdateWindow();
}

void COleControl::DoClick()
{
	OnClick(LEFT_BUTTON);
}

BOOL COleControl::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (m_pReflect != NULL)
		m_pReflect->SetControl(this);

	return CWnd::OnNcCreate(lpCreateStruct);
}

void COleControl::RecreateControlWindow()
{
	if (m_bInPlaceActive)
	{
		BOOL bUIActive = m_bUIActive;
		m_xOleInPlaceObject.InPlaceDeactivate();
		DestroyWindow();
		OnActivateInPlace(bUIActive, NULL);
	}
#ifdef _AFXDLL
	else if (m_bOpen)
	{
		DestroyWindow();
		CRect rectClient;
		m_pWndOpenFrame->GetClientRect(&rectClient);
		CreateControlWindow(m_pWndOpenFrame->m_hWnd, rectClient, rectClient);
	}
#endif //_AFXDLL
	else
	{
		HWND hWndParent = _AfxGetParkingWindow();
		if (hWndParent != NULL)
		{
			DestroyWindow();
			int cx;
			int cy;
			GetControlSize(&cx, &cy);
			CRect rect(0, 0, cx, cy);
			CreateControlWindow(hWndParent, rect);
		}
	}
}

void COleControl::CreateWindowForSubclassedControl()
{
	if (IsSubclassedControl() && (m_hWnd == NULL))
	{
		// If this is a subclassed control, we should create the window
		// for it now, in case the window is needed by the DoSuperclassPaint
		// implementation.

		HWND hWndParent = _AfxGetParkingWindow();
		if (hWndParent != NULL)
		{
			SIZEL szlHimetric;
			SIZEL szlPixels;
			szlHimetric.cx = m_cxExtent;
			szlHimetric.cy = m_cyExtent;
			_AfxXformSizeInHimetricToPixels(NULL, &szlHimetric, &szlPixels);
			CRect rcPos(0, 0, (int)szlPixels.cx, (int)szlPixels.cy);
			CreateControlWindow(hWndParent, rcPos);
		}
	}
}

int COleControl::OnMouseActivate(CWnd *pDesktopWnd, UINT nHitTest, UINT message)
{
	if (m_bInPlaceActive && !m_bUIActive)
		m_bPendingUIActivation = TRUE;

	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

void COleControl::PreModalDialog(HWND hWndParent)
{
	if (m_pInPlaceFrame != NULL)
	{
		m_pInPlaceFrame->EnableModeless(FALSE);
	}
	else
	{
		HWND hWndTop = _AfxGetTopLevelWindow(hWndParent);
		if (hWndTop != NULL)
			::EnableWindow(hWndTop, FALSE);
	}
}

void COleControl::PostModalDialog(HWND hWndParent)
{
	if (m_pInPlaceFrame != NULL)
	{
		m_pInPlaceFrame->EnableModeless(TRUE);
	}
	else
	{
		HWND hWndTop = _AfxGetTopLevelWindow(hWndParent);
		if (hWndTop != NULL)
			::EnableWindow(hWndTop, TRUE);
	}
}

void COleControl::SetModifiedFlag(BOOL bModified)
{
	m_bModified = (BYTE)bModified;
}

BOOL COleControl::IsModified()
{
	return m_bModified;
}

BOOL COleControl::WillAmbientsBeValidDuringLoad()
{
	return m_bCountOnAmbients;
}

void COleControl::EnableSimpleFrame()
{
	m_bSimpleFrame = TRUE;
}

BOOL COleControl::IgnoreWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam,
	LRESULT* plResult)
{
	if (!m_bUIDead)
		return FALSE;

	switch (msg)
	{
	case WM_NCHITTEST:
		*plResult = HTNOWHERE;
		return TRUE;

	case WM_SETCURSOR:
		*plResult = ::SendMessage(::GetParent(m_hWnd), msg, wParam, lParam);
		return TRUE;
	}

	if ((msg >= WM_KEYFIRST) && (msg <= WM_KEYLAST))
	{
		*plResult = 0;
		return TRUE;
	}

	return FALSE;
}

LRESULT COleControl::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
	DWORD dwCookie;
	LRESULT lResult = 0L;
	HRESULT hr;

	ExternalAddRef();   // "Insurance" addref -- keeps control alive

	// allow OCM_ reflections to be handled by ON_XXX_REFLECT macros
	switch (msg)
	{
	case OCM_COMMAND:
	case OCM_CTLCOLORBTN:
	case OCM_CTLCOLOREDIT:
	case OCM_CTLCOLORDLG:
	case OCM_CTLCOLORLISTBOX:
	case OCM_CTLCOLORMSGBOX:
	case OCM_CTLCOLORSCROLLBAR:
	case OCM_CTLCOLORSTATIC:
	case OCM_DRAWITEM:
	case OCM_MEASUREITEM:
	case OCM_DELETEITEM:
	case OCM_VKEYTOITEM:
	case OCM_CHARTOITEM:
	case OCM_COMPAREITEM:
	case OCM_HSCROLL:
	case OCM_VSCROLL:
	case OCM_PARENTNOTIFY:
	case OCM_NOTIFY:
		if (ReflectChildNotify(msg-OCM__BASE, wParam, lParam, &lResult))
		{
			ExternalRelease();
			return lResult;
		}
	}

	// Give the simple frame site the opportunity to filter the message
	if ((m_pSimpleFrameSite != NULL) &&
		SUCCEEDED(hr = m_pSimpleFrameSite->PreMessageFilter(
			m_hWnd, msg, wParam, lParam, &lResult, &dwCookie)))
	{
		if (hr == S_OK)
		{
			if (!IgnoreWindowMessage(msg, wParam, lParam, &lResult))
				lResult = CWnd::WindowProc(msg, wParam, lParam);

			// Simple frame site may have been cleared...
			// check before calling again.

			if (m_pSimpleFrameSite != NULL)
				m_pSimpleFrameSite->PostMessageFilter(
					m_hWnd, msg, wParam, lParam, &lResult, dwCookie);
		}
	}
	else
	{
		if (!IgnoreWindowMessage(msg, wParam, lParam, &lResult))
			lResult = CWnd::WindowProc(msg, wParam, lParam);
	}

	ExternalRelease();

	return lResult;
}

LRESULT COleControl::DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	if (m_hWnd != NULL)
		return CWnd::DefWindowProc(nMsg, wParam, lParam);
	else
		return 0;
}

int COleControl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (IsSubclassedControl())
		return CWnd::OnCreate(lpCreateStruct);
	else
		return 0;
}

void COleControl::OnSize(UINT nType, int cx, int cy)
{
	if (IsSubclassedControl())
		CWnd::OnSize(nType, cx, cy);
}

void COleControl::OnMove(int x, int y)
{
	if (IsSubclassedControl())
		CWnd::OnMove(x, y);
}

void COleControl::OnShowWindow(BOOL bShow, UINT nStatus)
{
	if (IsSubclassedControl())
		CWnd::OnShowWindow(bShow, nStatus);
}

/////////////////////////////////////////////////////////////////////////////
// Command prompts

void COleControl::OnInitMenuPopup(CMenu* pMenu, UINT, BOOL bSysMenu)
{
	AfxCancelModes(m_hWnd);

	if (bSysMenu)
		return;     // don't support system menu

	ENSURE_ARG(pMenu != NULL);
	// check the enabled state of various menu items

	CCmdUI state;
	state.m_pMenu = pMenu;
	ASSERT(state.m_pOther == NULL);
	ASSERT(state.m_pParentMenu == NULL);

	// determine if menu is popup in top-level menu and set m_pOther to
	// it if so (m_pParentMenu == NULL indicates that it is secondary popup)
	HMENU hParentMenu;
	if (_afxTrackingMenu == pMenu->m_hMenu)
		state.m_pParentMenu = pMenu;    // parent == child for tracking popup
	else
	{
		CWnd* pParent = GetTopLevelParent();
			// child windows don't have menus -- need to go to the top!
		if (pParent != NULL &&
			(hParentMenu = pParent->GetMenu()->GetSafeHmenu()) != NULL)
		{
			int nIndexMax = ::GetMenuItemCount(hParentMenu);
			for (int nIndex = 0; nIndex < nIndexMax; nIndex++)
			{
				if (::GetSubMenu(hParentMenu, nIndex) == pMenu->m_hMenu)
				{
					// when popup is found, m_pParentMenu is containing menu
					state.m_pParentMenu = CMenu::FromHandle(hParentMenu);
					break;
				}
			}
		}
	}

	state.m_nIndexMax = pMenu->GetMenuItemCount();
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
	  state.m_nIndex++)
	{
		state.m_nID = pMenu->GetMenuItemID(state.m_nIndex);
		if (state.m_nID == 0)
			continue; // menu separator or invalid cmd - ignore it

		ASSERT(state.m_pOther == NULL);
		ASSERT(state.m_pMenu != NULL);
		if (state.m_nID == (UINT)-1)
		{
			// possibly a popup menu, route to first item of that popup
			state.m_pSubMenu = pMenu->GetSubMenu(state.m_nIndex);
			if (state.m_pSubMenu == NULL ||
				(state.m_nID = state.m_pSubMenu->GetMenuItemID(0)) == 0 ||
				state.m_nID == (UINT)-1)
			{
				continue;       // first item of popup can't be routed to
			}
			state.DoUpdate(this, FALSE);    // popups are never auto disabled
		}
		else
		{
			// normal menu item
			// Auto enable/disable if frame window has 'm_bAutoMenuEnable'
			// set and command is _not_ a system command.
			state.m_pSubMenu = NULL;
			state.DoUpdate(this, m_bAutoMenuEnable && state.m_nID < 0xF000);
		}
	}
}

void COleControl::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU /*hSysMenu*/)
{
	// set the tracking state (update on idle)
	if (nFlags == 0xFFFF)
	{
		m_nIDTracking = AFX_IDS_IDLEMESSAGE;
		SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
		ASSERT(m_nIDTracking == m_nIDLastMessage);
	}
	else if (nItemID == 0 ||
		nFlags & (MF_SEPARATOR|MF_POPUP|MF_MENUBREAK|MF_MENUBARBREAK))
	{
		// nothing should be displayed
		m_nIDTracking = 0;
	}
	else if (nItemID >= 0xF000 && nItemID < 0xF1F0) // max of 31 SC_s
	{
		// special strings table entries for system commands
		m_nIDTracking = ID_COMMAND_FROM_SC(nItemID);
		ASSERT(m_nIDTracking >= AFX_IDS_SCFIRST &&
			m_nIDTracking < AFX_IDS_SCFIRST + 31);
	}
	else if (nItemID >= AFX_IDM_FIRST_MDICHILD)
	{
		// all MDI Child windows map to the same help id
		m_nIDTracking = AFX_IDS_MDICHILD;
	}
	else
	{
		// track on idle
		m_nIDTracking = nItemID;
	}

	// when running in-place, it is necessary to cause a message to
	// be pumped through the queue.
	if (m_nIDTracking != m_nIDLastMessage && GetParent() != NULL)
		PostMessage(WM_NULL);
}

void COleControl::GetMessageString(UINT nID, CString& rMessage) const
{
	// load appropriate string
	LPTSTR lpsz = rMessage.GetBuffer(255);
	if (AfxLoadString(nID, lpsz) != 0)
	{
		// first newline terminates actual string
		lpsz = _tcschr(lpsz, '\n');
		if (lpsz != NULL)
			*lpsz = '\0';
	}
	else
	{
		// not found
		TRACE(traceAppMsg, 0, "Warning: no message line prompt for ID 0x%04X.\n", nID);
	}
	rMessage.ReleaseBuffer();
}

LRESULT COleControl::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{	
	if (m_pInPlaceFrame != NULL)
	{
		LPCTSTR lpsz = NULL;
		CString strMessage;

		// set the message bar text
		if (lParam != 0)
		{
			ASSERT(wParam == 0);    // can't have both an ID and a string
			lpsz = (LPCTSTR)lParam; // set an explicit string
		}
		else if (wParam != 0)
		{
			// use the wParam as a string ID
			GetMessageString((UINT)wParam, strMessage);
			lpsz = strMessage;
		}

		if (lpsz == NULL)
		{
			lpsz = _T("");
		}

		// notify container of new status text
		const CStringW strStatusText(lpsz);
		m_pInPlaceFrame->SetStatusText(lpsz ? strStatusText.GetString() : NULL);
	}

	UINT nIDLast = m_nIDLastMessage;
	m_nIDLastMessage = (UINT)wParam;    // new ID (or 0)
	m_nIDTracking = (UINT)wParam;       // so F1 on toolbar buttons work
	return nIDLast;
}

void COleControl::OnEnterIdle(UINT nWhy, CWnd* /*pWho*/)
{
	if (nWhy != MSGF_MENU || m_nIDTracking == m_nIDLastMessage)
		return;

	SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
	ASSERT(m_nIDTracking == m_nIDLastMessage);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XSpecifyPropertyPages

STDMETHODIMP_(ULONG) COleControl::XSpecifyPropertyPages::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX_(COleControl, SpecifyPropertyPages)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XSpecifyPropertyPages::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX_(COleControl, SpecifyPropertyPages)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XSpecifyPropertyPages::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX_(COleControl, SpecifyPropertyPages)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XSpecifyPropertyPages::GetPages(CAUUID* pPages)
{
	METHOD_PROLOGUE_EX(COleControl, SpecifyPropertyPages)

	ASSERT(pPages != NULL);

	if (pPages == NULL)
		return E_POINTER;

	pPages->cElems = 0;
	pPages->pElems = NULL;

	HRESULT hr = S_OK;
	ULONG cElems;
	LPCLSID pClassID = pThis->GetPropPageIDs(cElems);

	if (cElems > 0)
	{
		if ((pPages->pElems = (LPCLSID)(::ATL::AtlCoTaskMemCAlloc(cElems, sizeof(CLSID)))) != NULL)
		{
			ASSERT(pPages->pElems != NULL);
			pPages->cElems = cElems;
			Checked::memcpy_s(pPages->pElems, cElems * sizeof(CLSID), 
				pClassID, (int)(cElems * sizeof(CLSID)));
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else
	{
		pPages->cElems = 0;
		pPages->pElems = NULL;
	}

	return hr;
}

void COleControl::OnDestroy()
{
	// Release hfont, if any.
	if (m_hFontPrev != NULL)
	{
		SendMessage(WM_SETFONT, (WPARAM)NULL, 0);
		InternalGetFont().m_pFont->ReleaseHfont(m_hFontPrev);
		m_hFontPrev = NULL;
	}

	CWnd::OnDestroy();
}

void COleControl::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	if (m_pControlSite != NULL)
		m_pControlSite->OnFocus(FALSE);
}

void COleControl::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	if (m_pControlSite != NULL)
		m_pControlSite->OnFocus(TRUE);
}

LRESULT COleControl::OnOcmCtlColorBtn(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORBTN, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorDlg(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORDLG, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorEdit(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLOREDIT, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorListBox(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORLISTBOX, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorMsgBox(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORMSGBOX, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorScrollBar(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORSCROLLBAR, wParam, lParam);
}

LRESULT COleControl::OnOcmCtlColorStatic(WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(m_hWnd, WM_CTLCOLORSTATIC, wParam, lParam);
}

void COleControl::ThrowError(SCODE sc, UINT nDescriptionID, UINT nHelpID)
{
	TCHAR szBuffer[256];
	AfxLoadString(nDescriptionID, szBuffer);
	if (nHelpID == -1)
		nHelpID = nDescriptionID;
	ThrowError(sc, szBuffer, nHelpID);
}

void COleControl::ThrowError(SCODE sc, LPCTSTR pszDescription, UINT nHelpID)
{
	COleDispatchException* pExcept = new COleDispatchException(pszDescription,
		nHelpID, 0);
	pExcept->m_scError = sc;
	THROW(pExcept);
}

BOOL COleControl::IsInvokeAllowed(DISPID)
{
	return m_bInitialized;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG


IMPLEMENT_DYNAMIC(COleControl, CWnd)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\cmdtarg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "occimpl.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget construction/destruction

CCmdTarget::CCmdTarget()
{
	// capture module state where object was constructed
	m_pModuleState = AfxGetModuleState();
	ASSERT(m_pModuleState != NULL);

	// initialize state
#ifndef _AFX_NO_OLE_SUPPORT
	m_dwRef = 1;
	m_pOuterUnknown = NULL;
	m_xInnerUnknown = 0;
	m_xDispatch.m_vtbl = 0;
	m_bResultExpected = TRUE;
	m_xConnPtContainer.m_vtbl = 0;
#endif
}

CCmdTarget::~CCmdTarget()
{
#ifndef _AFX_NO_OLE_SUPPORT
	if (m_xDispatch.m_vtbl != 0)
		((COleDispatchImpl*)&m_xDispatch)->Disconnect();
	ASSERT(m_dwRef <= 1);
#endif
	m_pModuleState = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget windows message dispatching

AFX_STATIC BOOL AFXAPI _AfxDispatchCmdMsg(CCmdTarget* pTarget, UINT nID, int nCode,
	AFX_PMSG pfn, void* pExtra, UINT_PTR nSig, AFX_CMDHANDLERINFO* pHandlerInfo)
		// return TRUE to stop routing
{
	ENSURE_VALID(pTarget);
	UNUSED(nCode);   // unused in release builds

	union MessageMapFunctions mmf;
	mmf.pfn = pfn;
	BOOL bResult = TRUE; // default is ok

	if (pHandlerInfo != NULL)
	{
		// just fill in the information, don't do it
		pHandlerInfo->pTarget = pTarget;
		pHandlerInfo->pmf = mmf.pfn;
		return TRUE;
	}

	switch (nSig)
	{
	default:    // illegal
		ASSERT(FALSE);
		return 0;
		break;

	case AfxSigCmd_v:
		// normal command or control notification
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		(pTarget->*mmf.pfnCmd_v_v)();
		break;

	case AfxSigCmd_b:
		// normal command or control notification
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		bResult = (pTarget->*mmf.pfnCmd_b_v)();
		break;

	case AfxSigCmd_RANGE:
		// normal command or control notification in a range
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		(pTarget->*mmf.pfnCmd_v_u)(nID);
		break;

	case AfxSigCmd_EX:
		// extended command (passed ID, returns bContinue)
		ASSERT(pExtra == NULL);
		bResult = (pTarget->*mmf.pfnCmd_b_u)(nID);
		break;

	case AfxSigNotify_v:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			(pTarget->*mmf.pfnNotify_v_NMHDR_pl)(pNotify->pNMHDR, pNotify->pResult);
		}
		break;

	case AfxSigNotify_b:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			bResult = (pTarget->*mmf.pfnNotify_b_NMHDR_pl)(pNotify->pNMHDR, pNotify->pResult);
		}
		break;

	case AfxSigNotify_RANGE:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			(pTarget->*mmf.pfnNotify_v_u_NMHDR_pl)(nID, pNotify->pNMHDR,
				pNotify->pResult);
		}
		break;

	case AfxSigNotify_EX:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			bResult = (pTarget->*mmf.pfnNotify_b_u_NMHDR_pl)(nID, pNotify->pNMHDR,
				pNotify->pResult);
		}
		break;

	case AfxSigCmdUI:
		{
			// ON_UPDATE_COMMAND_UI or ON_UPDATE_COMMAND_UI_REFLECT case
			ASSERT(CN_UPDATE_COMMAND_UI == (UINT)-1);
			ASSERT(nCode == CN_UPDATE_COMMAND_UI || nCode == 0xFFFF);
			ENSURE_ARG(pExtra != NULL);
			CCmdUI* pCmdUI = (CCmdUI*)pExtra;
			ASSERT(!pCmdUI->m_bContinueRouting);    // idle - not set
			(pTarget->*mmf.pfnCmdUI_v_C)(pCmdUI);
			bResult = !pCmdUI->m_bContinueRouting;
			pCmdUI->m_bContinueRouting = FALSE;     // go back to idle
		}
		break;

	case AfxSigCmdUI_RANGE:
		{
			// ON_UPDATE_COMMAND_UI case
			ASSERT(nCode == CN_UPDATE_COMMAND_UI);
			ENSURE_ARG(pExtra != NULL);
			CCmdUI* pCmdUI = (CCmdUI*)pExtra;
			ASSERT(pCmdUI->m_nID == nID);           // sanity assert
			ASSERT(!pCmdUI->m_bContinueRouting);    // idle - not set
			(pTarget->*mmf.pfnCmdUI_v_C_u)(pCmdUI, nID);
			bResult = !pCmdUI->m_bContinueRouting;
			pCmdUI->m_bContinueRouting = FALSE;     // go back to idle
		}
		break;

	// general extensibility hooks
	case AfxSigCmd_v_pv:
		(pTarget->*mmf.pfnCmd_v_pv)(pExtra);
		break;
	case AfxSigCmd_b_pv:
		bResult = (pTarget->*mmf.pfnCmd_b_pv)(pExtra);
		break;
	/*
	case AfxSig_vv:
		// normal command or control notification
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		(pTarget->*mmf.pfn_COMMAND)();
		break;

	case AfxSig_bv:
		// normal command or control notification
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		bResult = (pTarget->*mmf.pfn_bCOMMAND)();
		break;

	case AfxSig_vw:
		// normal command or control notification in a range
		ASSERT(CN_COMMAND == 0);        // CN_COMMAND same as BN_CLICKED
		ASSERT(pExtra == NULL);
		(pTarget->*mmf.pfn_COMMAND_RANGE)(nID);
		break;

	case AfxSig_bw:
		// extended command (passed ID, returns bContinue)
		ASSERT(pExtra == NULL);
		bResult = (pTarget->*mmf.pfn_COMMAND_EX)(nID);
		break;

	case AfxSig_vNMHDRpl:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			(pTarget->*mmf.pfn_NOTIFY)(pNotify->pNMHDR, pNotify->pResult);
		}
		break;
	case AfxSig_bNMHDRpl:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			bResult = (pTarget->*mmf.pfn_bNOTIFY)(pNotify->pNMHDR, pNotify->pResult);
		}
		break;
	case AfxSig_vwNMHDRpl:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			(pTarget->*mmf.pfn_NOTIFY_RANGE)(nID, pNotify->pNMHDR,
				pNotify->pResult);
		}
		break;
	case AfxSig_bwNMHDRpl:
		{
			AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;
			ENSURE(pNotify != NULL);
			ASSERT(pNotify->pResult != NULL);
			ASSERT(pNotify->pNMHDR != NULL);
			bResult = (pTarget->*mmf.pfn_NOTIFY_EX)(nID, pNotify->pNMHDR,
				pNotify->pResult);
		}
		break;
	case AfxSig_cmdui:
		{
			// ON_UPDATE_COMMAND_UI or ON_UPDATE_COMMAND_UI_REFLECT case
			ASSERT(CN_UPDATE_COMMAND_UI == (UINT)-1);
			ASSERT(nCode == CN_UPDATE_COMMAND_UI || nCode == 0xFFFF);
			ENSURE_ARG(pExtra != NULL);
			CCmdUI* pCmdUI = (CCmdUI*)pExtra;
			ASSERT(!pCmdUI->m_bContinueRouting);    // idle - not set
			(pTarget->*mmf.pfn_UPDATE_COMMAND_UI)(pCmdUI);
			bResult = !pCmdUI->m_bContinueRouting;
			pCmdUI->m_bContinueRouting = FALSE;     // go back to idle
		}
		break;

	case AfxSig_cmduiw:
		{
			// ON_UPDATE_COMMAND_UI case
			ASSERT(nCode == CN_UPDATE_COMMAND_UI);
			ENSURE_ARG(pExtra != NULL);
			CCmdUI* pCmdUI = (CCmdUI*)pExtra;
			ASSERT(pCmdUI->m_nID == nID);           // sanity assert
			ASSERT(!pCmdUI->m_bContinueRouting);    // idle - not set
			(pTarget->*mmf.pfn_UPDATE_COMMAND_UI_RANGE)(pCmdUI, nID);
			bResult = !pCmdUI->m_bContinueRouting;
			pCmdUI->m_bContinueRouting = FALSE;     // go back to idle
		}
		break;

	// general extensibility hooks
	case AfxSig_vpv:
		(pTarget->*mmf.pfn_OTHER)(pExtra);
		break;
	case AfxSig_bpv:
		bResult = (pTarget->*mmf.pfn_OTHER_EX)(pExtra);
		break;
	*/

	}
	return bResult;
}

// compare two pointers to GUIDs -- TRUE if both pointers are NULL
// or both pointers point to same GUID; FALSE otherwise

#define IsEqualNULLGuid(pGuid1, pGuid2) \
	(((pGuid1) == NULL && (pGuid2) == NULL) || \
	 ((pGuid1) != NULL && (pGuid2) != NULL && \
		IsEqualGUID(*(pGuid1), *(pGuid2))))


BOOL CCmdTarget::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
#ifndef _AFX_NO_OCC_SUPPORT
	// OLE control events are a special case
	if (nCode == CN_EVENT)
	{
		ENSURE(afxOccManager != NULL);
		return afxOccManager->OnEvent(this, nID, (AFX_EVENT*)pExtra, pHandlerInfo);
	}
#endif // !_AFX_NO_OCC_SUPPORT

	// determine the message number and code (packed into nCode)
	const AFX_MSGMAP* pMessageMap;
	const AFX_MSGMAP_ENTRY* lpEntry;
	UINT nMsg = 0;

#ifndef _AFX_NO_DOCOBJECT_SUPPORT
	if (nCode == CN_OLECOMMAND)
	{
		BOOL bResult = FALSE;

		const AFX_OLECMDMAP* pOleCommandMap;
		const AFX_OLECMDMAP_ENTRY* pEntry;

		ENSURE_ARG(pExtra != NULL);
		COleCmdUI* pUI = (COleCmdUI*) pExtra;
		const GUID* pguidCmdGroup = pUI->m_pguidCmdGroup;

#ifdef _AFXDLL
		for (pOleCommandMap = GetCommandMap(); pOleCommandMap->pfnGetBaseMap != NULL && !bResult;
			pOleCommandMap = pOleCommandMap->pfnGetBaseMap())
#else
		for (pOleCommandMap = GetCommandMap(); pOleCommandMap != NULL && !bResult;
			pOleCommandMap = pOleCommandMap->pBaseMap)
#endif
		{
			for (pEntry = pOleCommandMap->lpEntries;
				pEntry->cmdID != 0 && pEntry->nID != 0 && !bResult;
				pEntry++)
			{
				if (nID == pEntry->cmdID &&
					IsEqualNULLGuid(pguidCmdGroup, pEntry->pguid))
				{
					pUI->m_nID = pEntry->nID;
					bResult = TRUE;
				}
			}
		}

		return bResult;
	}
#endif

	if (nCode != CN_UPDATE_COMMAND_UI)
	{
		nMsg = HIWORD(nCode);
		nCode = LOWORD(nCode);
	}

	// for backward compatibility HIWORD(nCode)==0 is WM_COMMAND
	if (nMsg == 0)
		nMsg = WM_COMMAND;

	// look through message map to see if it applies to us

	for (pMessageMap = GetMessageMap(); pMessageMap->pfnGetBaseMap != NULL;
	  pMessageMap = (*pMessageMap->pfnGetBaseMap)())
	{
		// Note: catches BEGIN_MESSAGE_MAP(CMyClass, CMyClass)!
		ASSERT(pMessageMap != (*pMessageMap->pfnGetBaseMap)());
		lpEntry = AfxFindMessageEntry(pMessageMap->lpEntries, nMsg, nCode, nID);
		if (lpEntry != NULL)
		{
			// found it
#ifdef _DEBUG
			if (nCode == CN_COMMAND)
				TRACE(traceCmdRouting, 1, "SENDING command id 0x%04X to %hs target.\n", nID,
					GetRuntimeClass()->m_lpszClassName);
			else if (nCode > CN_COMMAND)
				TRACE(traceCmdRouting, 1, "SENDING control notification %d from control id 0x%04X to %hs window.\n",
					nCode, nID, GetRuntimeClass()->m_lpszClassName);
#endif //_DEBUG
			return _AfxDispatchCmdMsg(this, nID, nCode,
				lpEntry->pfn, pExtra, lpEntry->nSig, pHandlerInfo);
		}
	}
	return FALSE;   // not handled
}

/////////////////////////////////////////////////////////////////////////////
// Hook to disable automation handlers

#ifndef _AFX_NO_OLE_SUPPORT

BOOL CCmdTarget::IsInvokeAllowed(DISPID)
{
	return TRUE;    // normally, invoke is always allowed
}

#endif // !_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Stubs for OLE type library functions

#ifndef _AFX_NO_OLE_SUPPORT

BOOL CCmdTarget::GetDispatchIID(IID*)
{
	// Subclass must implement (typically via COleControl implementation)
	return FALSE;
}

UINT CCmdTarget::GetTypeInfoCount()
{
	// Subclass must implement (typically via IMPLEMENT_OLETYPELIB macro)
	return 0;
}

CTypeLibCache* CCmdTarget::GetTypeLibCache()
{
	// Subclass must implement (typically via IMPLEMENT_OLETYPELIB macro)
	return NULL;
}

HRESULT CCmdTarget::GetTypeLib(LCID, LPTYPELIB*)
{
	// Subclass must implement (typically via IMPLEMENT_OLETYPELIB macro)
	return TYPE_E_CANTLOADLIBRARY;
}

#endif // !_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget routines that delegate to the WinApp

void CCmdTarget::BeginWaitCursor()
	{ AfxGetApp()->DoWaitCursor(1); }
void CCmdTarget::EndWaitCursor()
	{ AfxGetApp()->DoWaitCursor(-1); }
void CCmdTarget::RestoreWaitCursor()
	{ AfxGetApp()->DoWaitCursor(0); }

/////////////////////////////////////////////////////////////////////////////
// Root of message maps


const AFX_MSGMAP* CCmdTarget::GetMessageMap() const
{
	return GetThisMessageMap();
}

const AFX_MSGMAP* CCmdTarget::GetThisMessageMap()
{
	static const AFX_MSGMAP_ENTRY _messageEntries[] =
	{
		{ 0, 0, AfxSig_end, 0 }     // nothing here
	};
	static const AFX_MSGMAP messageMap =
	{
		NULL,
		&_messageEntries[0]
	};
	return &messageMap;	
}

/////////////////////////////////////////////////////////////////////////////
// Root of dispatch maps

#ifndef _AFX_NO_OLE_SUPPORT

UINT CCmdTarget::_dispatchEntryCount = (UINT)-1;
DWORD CCmdTarget::_dwStockPropMask = (DWORD)-1;

const AFX_DISPMAP CCmdTarget::dispatchMap =
{
	NULL,
	&CCmdTarget::_dispatchEntries[0],
	&CCmdTarget::_dispatchEntryCount,
	&CCmdTarget::_dwStockPropMask
};

const AFX_DISPMAP* CCmdTarget::GetDispatchMap() const
{
	return &CCmdTarget::dispatchMap;
}

#ifdef _AFXDLL
const AFX_DISPMAP* CCmdTarget::GetThisDispatchMap()
{
	return &CCmdTarget::dispatchMap;
}
#endif

const AFX_DISPMAP_ENTRY CCmdTarget::_dispatchEntries[] =
{
	{ NULL, -1, NULL, 0, (AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1,
	  afxDispCustom }
	// nothing here
};

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Root of event sink maps

#ifndef _AFX_NO_OCC_SUPPORT

UINT CCmdTarget::_eventsinkEntryCount = (UINT)-1;

const AFX_EVENTSINKMAP CCmdTarget::eventsinkMap =
{
	NULL,
	&CCmdTarget::_eventsinkEntries[0],
	&CCmdTarget::_eventsinkEntryCount
};

const AFX_EVENTSINKMAP* CCmdTarget::GetEventSinkMap() const
{
	return &CCmdTarget::eventsinkMap;
}

#ifdef _AFXDLL
const AFX_EVENTSINKMAP* CCmdTarget::GetThisEventSinkMap()
{
	return &CCmdTarget::eventsinkMap;
}
#endif

const AFX_EVENTSINKMAP_ENTRY CCmdTarget::_eventsinkEntries[] =
{
	{ NULL, -1, NULL, 0, (AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1,
	  afxDispCustom, (UINT)-1, (UINT)-1 }
	// nothing here
};

#endif //!_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Root of interface maps

#ifndef _AFX_NO_OLE_SUPPORT

const AFX_INTERFACEMAP* CCmdTarget::GetInterfaceMap() const
{
	return &CCmdTarget::interfaceMap;
}

#ifdef _AFXDLL
const AFX_INTERFACEMAP* CCmdTarget::GetThisInterfaceMap()
{
	return &CCmdTarget::interfaceMap;
}
#endif

const AFX_INTERFACEMAP CCmdTarget::interfaceMap =
{
	NULL,
	&CCmdTarget::_interfaceEntries[0]
};

const AFX_INTERFACEMAP_ENTRY CCmdTarget::_interfaceEntries[] =
{
#ifndef _AFX_NO_OLE_SUPPORT
	INTERFACE_PART(CCmdTarget, IID_IDispatch, Dispatch)
#endif
	{ NULL, (size_t)-1 }    // end of entries
};

void CCmdTarget::OnFinalRelease()
{
#ifndef _AFX_NO_OLE_SUPPORT
	AfxLockGlobals(CRIT_TYPELIBCACHE);

	// release the typelib cache, if any
	CTypeLibCache* pTypeLibCache = GetTypeLibCache();
	if (pTypeLibCache != NULL)
		pTypeLibCache->Unlock();

	AfxUnlockGlobals(CRIT_TYPELIBCACHE);
#endif

	delete this;
}

BOOL CCmdTarget::OnCreateAggregates()
{
	return TRUE;
}

LPUNKNOWN CCmdTarget::GetInterfaceHook(const void*)
{
	return NULL;
}

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Root of connection maps

#ifndef _AFX_NO_OLE_SUPPORT

const AFX_CONNECTIONMAP* CCmdTarget::GetConnectionMap() const
{
	return &CCmdTarget::connectionMap;
}

#ifdef _AFXDLL
const AFX_CONNECTIONMAP* CCmdTarget::GetThisConnectionMap()
{
	return &CCmdTarget::connectionMap;
}
#endif

const AFX_CONNECTIONMAP CCmdTarget::connectionMap =
{
	NULL,
	&CCmdTarget::_connectionEntries[0]
};

const AFX_CONNECTIONMAP_ENTRY CCmdTarget::_connectionEntries[] =
{
	{ NULL, (size_t)-1 }    // end of entries
};

LPCONNECTIONPOINT CCmdTarget::GetConnectionHook(const IID&)
{
	return NULL;
}

BOOL CCmdTarget::GetExtraConnectionPoints(CPtrArray*)
{
	return FALSE;
}

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Root of command target maps

#ifndef _AFX_NO_DOCOBJECT_SUPPORT

const AFX_OLECMDMAP CCmdTarget::commandMap =
{
	NULL,
	&CCmdTarget::_commandEntries[0]
};

const AFX_OLECMDMAP_ENTRY CCmdTarget::_commandEntries[] =
{
	{ NULL, 0, 0 }    // end of entries
};

const AFX_OLECMDMAP* CCmdTarget::GetCommandMap() const
{
	return &CCmdTarget::commandMap;
}

#ifdef _AFXDLL
const AFX_OLECMDMAP* CCmdTarget::GetThisCommandMap()
{
	return &CCmdTarget::commandMap;
}
#endif

#endif //!_AFX_NO_DOCOBJECT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Special access to view routing info

CView* CCmdTarget::GetRoutingView()
{
	return GetRoutingView_();
}

CFrameWnd* CCmdTarget::GetRoutingFrame()
{
	return GetRoutingFrame_();
}

/////////////////////////////////////////////////////////////////////////////
// CCmdUI - User Interface for a command

// CCmdUI is a protocol class for all command handler variants
//      CCmdUI is an implementation class for menus and general dialog
//        controls (usually buttons)

CCmdUI::CCmdUI()
{
	// zero out everything
	m_nID = m_nIndex = m_nIndexMax = 0;
	m_pMenu = m_pSubMenu = m_pParentMenu = NULL;
	m_pOther = NULL;
	m_bEnableChanged = m_bContinueRouting = FALSE;
}

// default CCmdUI implementation only works for Menu Items
void CCmdUI::Enable(BOOL bOn)
{
	if (m_pMenu != NULL)
	{
		if (m_pSubMenu != NULL)
			return; // don't change popup menus indirectly

		ENSURE(m_nIndex < m_nIndexMax);
		m_pMenu->EnableMenuItem(m_nIndex, MF_BYPOSITION |
			(bOn ? MF_ENABLED : (MF_DISABLED | MF_GRAYED)));
	}
	else
	{
		// enable/disable a control (i.e. child window)
		ENSURE(m_pOther != NULL);

		// if control has the focus, move the focus before disabling
		if (!bOn && (::GetFocus() == m_pOther->m_hWnd))
			m_pOther->GetParent()->SendMessage(WM_NEXTDLGCTL, 0, FALSE);
		m_pOther->EnableWindow(bOn);
	}
	m_bEnableChanged = TRUE;
}

void CCmdUI::SetCheck(int nCheck)
{
	if (m_pMenu != NULL)
	{
		if (m_pSubMenu != NULL)
			return; // don't change popup menus indirectly

		// place checkmark next to menu item
		ENSURE(m_nIndex < m_nIndexMax);
		m_pMenu->CheckMenuItem(m_nIndex, MF_BYPOSITION |
			(nCheck ? MF_CHECKED : MF_UNCHECKED));
	}
	else
	{
		// we can only check buttons or controls acting like buttons
		ENSURE(m_pOther != NULL);
		if (m_pOther->SendMessage(WM_GETDLGCODE) & DLGC_BUTTON)
			m_pOther->SendMessage(BM_SETCHECK, nCheck);
		// otherwise ignore it
	}
}

AFX_STATIC void AFXAPI _AfxLoadDotBitmap(); // for swap tuning

void CCmdUI::SetRadio(BOOL bOn)
{
	SetCheck(bOn ? 1 : 0); // this default works for most things as well
	if (m_pMenu != NULL)
	{
		if (m_pSubMenu != NULL)
			return; // don't change popup menus indirectly

		// for menu item - use dot instead of checkmark
		ENSURE(m_nIndex < m_nIndexMax);

		if (afxData.hbmMenuDot == NULL)
			_AfxLoadDotBitmap();    // in INIT segment

		if (afxData.hbmMenuDot != NULL)
			SetMenuItemBitmaps(m_pMenu->m_hMenu, m_nIndex, MF_BYPOSITION,
				NULL, afxData.hbmMenuDot);
	}
}

void CCmdUI::SetText(LPCTSTR lpszText)
{
	ENSURE_ARG(lpszText != NULL);
	ASSERT(AfxIsValidString(lpszText));

	if (m_pMenu != NULL)
	{
		if (m_pSubMenu != NULL)
			return; // don't change popup menus indirectly

		// get current menu state so it doesn't change
		UINT nState = m_pMenu->GetMenuState(m_nIndex, MF_BYPOSITION);
		nState &= ~(MF_BITMAP|MF_OWNERDRAW|MF_SEPARATOR);

		// set menu text
		ENSURE(m_nIndex < m_nIndexMax);
		VERIFY(m_pMenu->ModifyMenu(m_nIndex, MF_BYPOSITION |
			MF_STRING | nState, m_nID, lpszText));
	}
	else
	{
		ENSURE(m_pOther != NULL);
		AfxSetWindowText(m_pOther->m_hWnd, lpszText);
	}
}

BOOL CCmdUI::DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler)
{
	if (m_nID == 0 || LOWORD(m_nID) == 0xFFFF)
		return TRUE;     // ignore invalid IDs

	ENSURE_VALID(pTarget);

	m_bEnableChanged = FALSE;
	BOOL bResult = pTarget->OnCmdMsg(m_nID, CN_UPDATE_COMMAND_UI, this, NULL);
	if (!bResult)
		ASSERT(!m_bEnableChanged); // not routed

	if (bDisableIfNoHndler && !m_bEnableChanged)
	{
		AFX_CMDHANDLERINFO info;
		info.pTarget = NULL;
		BOOL bHandler = pTarget->OnCmdMsg(m_nID, CN_COMMAND, this, &info);

#ifdef _DEBUG
		if (!bHandler)
			TRACE(traceCmdRouting, 1, "No handler for command ID 0x%04X, disabling it.\n", m_nID);
#endif
		// Enable or Disable based on whether there is a handler there
		Enable(bHandler);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Special init


AFX_STATIC_DATA const BYTE _afxDot[] =
	{ 0x6, 0xF, 0xF, 0xF, 0x6 }; // simple byte bitmap, 1=> bit on
#define DOT_WIDTH   4
#define DOT_HEIGHT  5

AFX_STATIC void AFXAPI _AfxLoadDotBitmap()
{
	ASSERT(afxData.hbmMenuDot == NULL);
	// attempt to load special bitmap, else default to arrow
	CSize size = ::GetMenuCheckMarkDimensions();
	ENSURE(size.cx > 4 && size.cy > 5); // not too small please
	if (size.cx > 32)
		size.cx = 32;
	int iwRow = (size.cx + 15) >> 4;    // # of WORDs per raster line
	int nShift = (size.cx - DOT_WIDTH) / 2;     // # of bits to shift over
	nShift += ((iwRow * 16) - size.cx); // padding for word alignment
	if (nShift > 16 - DOT_WIDTH)
		nShift = 16 - DOT_WIDTH;    // maximum shift for 1 word

	if (size.cy > 32)
		size.cy = 32;

	// bitmap 2/4/4/4/2 pixels wide - centered (0 => black)
	BYTE rgbBitmap[32 * 2 * sizeof(WORD)];
	memset(rgbBitmap, 0xff, sizeof(rgbBitmap));

	BYTE* pbOut = &rgbBitmap[iwRow * sizeof(WORD) *
							((size.cy - (DOT_HEIGHT+1)) >> 1)];
	const BYTE* pbIn = _afxDot;
	for (int y = 0; y < DOT_HEIGHT; y++)
	{
		WORD w = (WORD)~(((DWORD)*pbIn++) << nShift);
		// bitmaps are always hi-lo
		pbOut[0] = HIBYTE(w);
		pbOut[1] = LOBYTE(w);
		pbOut += iwRow * sizeof(WORD);
	}

	afxData.hbmMenuDot = ::CreateBitmap(size.cx, size.cy, 1, 1,
			(LPVOID)rgbBitmap);
	if (afxData.hbmMenuDot == NULL)
	{
		TRACE(traceAppMsg, 0, "Warning: using system arrow bitmap instead of dot.\n");
		#define OBM_MNARROW         32739
		afxData.hbmMenuDot = ::LoadBitmapW(NULL, MAKEINTRESOURCEW(OBM_MNARROW));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget diagnostics

#ifdef _DEBUG
void CCmdTarget::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

#ifndef _AFX_NO_OLE_SUPPORT
	if (m_xDispatch.m_vtbl != 0)
	{
		dc << "with IDispatch (OLE Automation) capability\n";
		dc << "m_bResultExpected = " << m_bResultExpected << "\n";
	}
	if (m_xConnPtContainer.m_vtbl != 0)
	{
		dc << "with OLE Connection Point capability\n";
	}
	if (GetInterfaceMap() != &CCmdTarget::interfaceMap)
	{
		dc << "with OLE capability";
		dc << "\nm_dwRef = " << m_dwRef;
		dc << "\nm_pOuterUnknown = " << m_pOuterUnknown;
		if (m_xInnerUnknown != 0)
			dc << "\nwith aggregation capability";
		dc << "\n";
	}
#endif //!_AFX_NO_OLE_SUPPORT
}

void CCmdTarget::AssertValid() const
{
	CObject::AssertValid();
}
#endif


IMPLEMENT_DYNAMIC(CCmdTarget, CObject)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlfont.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CFontHolder

CFontHolder::CFontHolder(LPPROPERTYNOTIFYSINK pNotify) :
	m_pFont(NULL),
	m_dwConnectCookie(0),
	m_pNotify(pNotify)
{
	ASSERT_NULL_OR_POINTER(pNotify, IPropertyNotifySink);
}

void CFontHolder::SetFontNotifySink(LPPROPERTYNOTIFYSINK pNotify)
{
	ASSERT_NULL_OR_POINTER(pNotify, IPropertyNotifySink);
	m_pNotify = pNotify;
}

CFontHolder::~CFontHolder()
{
	ReleaseFont();
}

void CFontHolder::ReleaseFont()
{
	if ((m_pFont != NULL) && (m_pNotify != NULL))
	{
		AfxConnectionUnadvise(m_pFont, IID_IPropertyNotifySink, m_pNotify,
			FALSE, m_dwConnectCookie);
	}

	RELEASE(m_pFont);
}

AFX_STATIC_DATA const FONTDESC _afxFontDescDefault =
	{ sizeof(FONTDESC), OLESTR("MS Shell Dlg"), FONTSIZE(12), FW_NORMAL,
	  DEFAULT_CHARSET, FALSE, FALSE, FALSE };

void CFontHolder::InitializeFont(const FONTDESC* pFontDesc,
	LPDISPATCH pFontDispAmbient)
{
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IDispatch);
#ifdef _DEBUG
	if (pFontDesc != NULL)
		ASSERT(pFontDesc->cbSizeofstruct == sizeof(FONTDESC));
#endif

	// Release any previous font, in preparation for creating a new one.
	ReleaseFont();

	LPFONT pFontAmbient;
	LPFONT pFontNew = NULL;

	if ((pFontDispAmbient != NULL) &&
		SUCCEEDED(pFontDispAmbient->QueryInterface(IID_IFont,
				(LPVOID*)&pFontAmbient)))
	{
		ASSERT_POINTER(pFontAmbient, IFont);

		// Make a clone of the ambient font.
		pFontAmbient->Clone(&pFontNew);
		pFontAmbient->Release();
	}
	else
	{
		// Create the font.
		if (pFontDesc == NULL)
			pFontDesc = &_afxFontDescDefault;

		if (FAILED(::OleCreateFontIndirect((LPFONTDESC)pFontDesc, IID_IFont,
				(LPVOID *)&pFontNew)))
			pFontNew = NULL;
	}

	// Setup advisory connection and find dispatch interface.
	if (pFontNew != NULL)
		SetFont(pFontNew);
}

BOOL AFXAPI _AfxIsSameFont(CFontHolder& font, const FONTDESC* pFontDesc,
	LPFONTDISP pFontDispAmbient)
{
	if (font.m_pFont == NULL)
		return FALSE;

	BOOL bSame = FALSE;

	if (pFontDispAmbient != NULL)
	{
		LPFONT pFontAmbient;
		if (SUCCEEDED(pFontDispAmbient->QueryInterface(IID_IFont,
			(LPVOID*)&pFontAmbient)))
		{
			ASSERT_POINTER(pFontAmbient, IFont);
			bSame = pFontAmbient->IsEqual(font.m_pFont) == S_OK;
			pFontAmbient->Release();
		}
	}
	else
	{
		if (pFontDesc == NULL)
			pFontDesc = &_afxFontDescDefault;

		bSame = TRUE;
		BOOL bFlag;

		font.m_pFont->get_Italic(&bFlag);
		bSame = (bFlag == pFontDesc->fItalic);

		if (bSame)
		{
			font.m_pFont->get_Underline(&bFlag);
			bSame = (bFlag == pFontDesc->fUnderline);
		}

		if (bSame)
		{
			font.m_pFont->get_Strikethrough(&bFlag);
			bSame = (bFlag == pFontDesc->fStrikethrough);
		}

		if (bSame)
		{
			short sCharset;
			font.m_pFont->get_Charset(&sCharset);
			bSame = (sCharset == pFontDesc->sCharset);
		}

		if (bSame)
		{
			short sWeight;
			font.m_pFont->get_Weight(&sWeight);
			bSame = (sWeight == pFontDesc->sWeight);
		}

		if (bSame)
		{
			CURRENCY cy;
			font.m_pFont->get_Size(&cy);
			bSame = (memcmp(&cy, &pFontDesc->cySize, sizeof(CURRENCY)) == 0);
		}

		if (bSame)
		{
			BSTR bstrName;
			font.m_pFont->get_Name(&bstrName);
			CString strName1(bstrName);
			CString strName2(pFontDesc->lpstrName);
			bSame = (strName1 == strName2);
			SysFreeString(bstrName);
		}
	}

	return bSame;
}

HFONT CFontHolder::GetFontHandle()
{
	// Assume a screen DC for logical/himetric ratio.
	return GetFontHandle(afxData.cyPixelsPerInch, HIMETRIC_PER_INCH);
}

HFONT CFontHolder::GetFontHandle(long cyLogical, long cyHimetric)
{
	HFONT hFont = NULL;

	if ((m_pFont != NULL) &&
		SUCCEEDED(m_pFont->SetRatio(cyLogical, cyHimetric)) &&
		SUCCEEDED(m_pFont->get_hFont(&hFont)))
	{
		ASSERT(hFont != NULL);
	}

	return hFont;
}

CFont* CFontHolder::Select(CDC* pDC, long cyLogical, long cyHimetric)
{
	ENSURE_ARG(pDC != NULL);
	ASSERT_POINTER(pDC, CDC);

	HFONT hFont = NULL;

	if (m_pFont != NULL)
		hFont = GetFontHandle(cyLogical, cyHimetric);

	if (hFont != NULL)
	{
		if ((pDC->m_hAttribDC != pDC->m_hDC) &&
			(pDC->m_hAttribDC != NULL))
		{
			::SelectObject(pDC->m_hAttribDC, hFont);
		}

		return CFont::FromHandle((HFONT)::SelectObject(pDC->m_hDC, hFont));
	}

	return NULL;
}

void CFontHolder::QueryTextMetrics(LPTEXTMETRIC lptm)
{
	ENSURE_ARG(lptm != NULL);

	if (m_pFont != NULL)
	{
#if defined(_UNICODE)
		// no conversion necessary
		m_pFont->QueryTextMetrics(lptm);
#else
		TEXTMETRICW tmw;
		m_pFont->QueryTextMetrics(&tmw);
		AfxTextMetricW2A(lptm, &tmw);
#endif
	}
	else
	{
		memset(lptm, 0, sizeof(TEXTMETRIC));
	}
}

LPFONTDISP CFontHolder::GetFontDispatch()
{
	LPFONTDISP pFontDisp = NULL;

	if ((m_pFont != NULL) &&
		SUCCEEDED(m_pFont->QueryInterface(IID_IFontDisp, (LPVOID*)&pFontDisp)))
	{
		ASSERT_POINTER(pFontDisp, IFontDisp);
	}

	return pFontDisp;
}

void CFontHolder::SetFont(LPFONT pFontNew)
{
	ASSERT_NULL_OR_POINTER(pFontNew, IFont);

	if (m_pFont != NULL)
		ReleaseFont();

	m_pFont = pFontNew;

	if (m_pNotify != NULL)
	{
		AfxConnectionAdvise(m_pFont, IID_IPropertyNotifySink, m_pNotify,
			FALSE, &m_dwConnectCookie);
	}
}

BOOL CFontHolder::GetDisplayString(CString& strValue)
{
	return strValue.LoadString(AFX_IDS_DISPLAYSTRING_FONT);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctldata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// OCX Support

////////////////////////////////////////////////////////////////////////////
// _AfxRegisterClipFormat - Registers a custom clipboard format, using the
//  string form of a class ID.

CLIPFORMAT AFXAPI _AfxRegisterClipFormat(REFCLSID clsid)
{
	TCHAR pszClsid[40];
	_stprintf_s(pszClsid, _countof(pszClsid),
		_T("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
		clsid.Data1, clsid.Data2, clsid.Data3,
		clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3],
		clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7]);
	return (CLIPFORMAT)RegisterClipboardFormat(pszClsid);
}

CLIPFORMAT AFXAPI _AfxGetClipboardFormatConvertVBX()
{
	static CLIPFORMAT _cfConvertVBX;
	if (_cfConvertVBX == 0)
		_cfConvertVBX = _AfxRegisterClipFormat(CLSID_ConvertVBX);
	ASSERT(_cfConvertVBX != NULL);
	return _cfConvertVBX;
}

CLIPFORMAT AFXAPI _AfxGetClipboardFormatPersistPropset()
{
	static CLIPFORMAT _cfPersistPropset;
	if (_cfPersistPropset == 0)
		_cfPersistPropset = _AfxRegisterClipFormat(CLSID_PersistPropset);
	ASSERT(_cfPersistPropset != NULL);
	return _cfPersistPropset;
}

/////////////////////////////////////////////////////////////////////////////
// AfxOleMatchPropsetClipFormat

BOOL AFXAPI _AfxOleMatchPropsetClipFormat(CLIPFORMAT cfFormat, LPCLSID lpFmtID)
{
	if (cfFormat == _AfxGetClipboardFormatPersistPropset())
	{
		*lpFmtID = CLSID_PersistPropset;
		return TRUE;
	}

	if (cfFormat == _AfxGetClipboardFormatConvertVBX())
	{
		*lpFmtID = CLSID_ConvertVBX;
		return TRUE;
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XDataObject

STDMETHODIMP_(ULONG) COleControl::XDataObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XDataObject::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XDataObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XDataObject::GetData(LPFORMATETC pformatetcIn,
	LPSTGMEDIUM pmedium )
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.GetData(pformatetcIn, pmedium);
}

STDMETHODIMP COleControl::XDataObject::GetDataHere(LPFORMATETC pformatetc,
	LPSTGMEDIUM pmedium )
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.GetDataHere(pformatetc, pmedium);
}

STDMETHODIMP COleControl::XDataObject::QueryGetData(LPFORMATETC pformatetc )
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.QueryGetData(pformatetc);
}

STDMETHODIMP COleControl::XDataObject::GetCanonicalFormatEtc(
	LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.GetCanonicalFormatEtc(pformatetc,
		pformatetcOut);
}

STDMETHODIMP COleControl::XDataObject::SetData(LPFORMATETC pformatetc,
	STGMEDIUM * pmedium, BOOL fRelease)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.SetData(pformatetc, pmedium, fRelease);
}

STDMETHODIMP COleControl::XDataObject::EnumFormatEtc(DWORD dwDirection,
	LPENUMFORMATETC* ppenumFormatEtc)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	CControlDataSource* pDataSource = pThis->GetDataSource();
	if (pDataSource == NULL)
		return E_OUTOFMEMORY;

	return pDataSource->m_xDataObject.EnumFormatEtc(dwDirection,
		ppenumFormatEtc);
}

STDMETHODIMP COleControl::XDataObject::DAdvise(FORMATETC* pFormatetc,
	DWORD advf, LPADVISESINK pAdvSink, DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	*pdwConnection = 0;

	if (pThis->m_pDataAdviseHolder == NULL &&
		CreateDataAdviseHolder(&pThis->m_pDataAdviseHolder) != S_OK)
	{
		return E_OUTOFMEMORY;
	}
	ASSERT(pThis->m_pDataAdviseHolder != NULL);
	return pThis->m_pDataAdviseHolder->Advise(this, pFormatetc, advf, pAdvSink,
		pdwConnection);
}

STDMETHODIMP COleControl::XDataObject::DUnadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	if (pThis->m_pDataAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_pDataAdviseHolder != NULL);
	return pThis->m_pDataAdviseHolder->Unadvise(dwConnection);
}

STDMETHODIMP COleControl::XDataObject::EnumDAdvise(
	LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX_(COleControl, DataObject)

	*ppenumAdvise = NULL;

	if (pThis->m_pDataAdviseHolder == NULL)
		return E_FAIL;

	ASSERT(pThis->m_pDataAdviseHolder != NULL);
	return pThis->m_pDataAdviseHolder->EnumAdvise(ppenumAdvise);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::CControlDataSource

COleControl::CControlDataSource::CControlDataSource(COleControl* pCtrl) :
	m_pCtrl(pCtrl)
{
	m_nGrowBy = 4;  // By default, control puts 4 entries in cache.
}

BOOL COleControl::CControlDataSource::OnRenderGlobalData(
	LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal)
{
	ASSERT_VALID(this);
	ENSURE(m_pCtrl != NULL);
	return m_pCtrl->OnRenderGlobalData(lpFormatEtc, phGlobal);
	// Note: COleDataSource has no implementation
}

BOOL COleControl::CControlDataSource::OnRenderFileData(
	LPFORMATETC lpFormatEtc, CFile* pFile)
{
	ASSERT_VALID(this);
	ENSURE(m_pCtrl != NULL);
	return m_pCtrl->OnRenderFileData(lpFormatEtc, pFile);
	// Note: COleDataSource has no implementation
}

BOOL COleControl::CControlDataSource::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ENSURE(m_pCtrl != NULL);
	if (m_pCtrl->OnRenderData(lpFormatEtc, lpStgMedium))
		return TRUE;

	return COleDataSource::OnRenderData(lpFormatEtc, lpStgMedium);
}

BOOL COleControl::CControlDataSource::OnSetData(LPFORMATETC lpFormatEtc,
	LPSTGMEDIUM lpStgMedium, BOOL bRelease)
{
	ASSERT_VALID(this);
	ENSURE(m_pCtrl != NULL);
	return m_pCtrl->OnSetData(lpFormatEtc, lpStgMedium, bRelease);
	// Note: COleDataSource has no implementation
}

/////////////////////////////////////////////////////////////////////////////
// COleControl overridables for IDataObject implementation

BOOL COleControl::OnRenderGlobalData(LPFORMATETC lpFormatEtc,
	HGLOBAL* phGlobal)
{
#ifndef _DEBUG
	UNUSED(lpFormatEtc); // unused in release builds
	UNUSED(phGlobal);    // unused in release builds
#endif

	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(phGlobal, sizeof(HGLOBAL)));

	return FALSE;   // default does nothing
}

BOOL COleControl::OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile)
{
#ifndef _DEBUG
	UNUSED(lpFormatEtc); // unused in release builds
	UNUSED(pFile);       // unused in release builds
#endif

	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC)));
	ASSERT_VALID(pFile);

	return FALSE;   // default does nothing
}

BOOL COleControl::OnRenderData(
	LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	ASSERT_VALID(this);
	ENSURE_ARG(lpFormatEtc != NULL);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	// default implementation does not support extended layout
	if (lpFormatEtc->lindex != -1)
		return FALSE;

	// default implementation supports CF_METAFILEPICT
	if (lpFormatEtc->cfFormat == CF_METAFILEPICT)
		return GetMetafileData(lpFormatEtc, lpStgMedium);

	// default implementation supports propset format
	CLSID fmtid;
	if (_AfxOleMatchPropsetClipFormat(lpFormatEtc->cfFormat, &fmtid))
	{
		return GetPropsetData(lpFormatEtc, lpStgMedium, fmtid);
	}

	return FALSE;   // cfFormat not supported
}

BOOL COleControl::OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
	BOOL bRelease)
{
	ASSERT_VALID(this);
	ENSURE_ARG(lpFormatEtc != NULL && lpStgMedium != NULL);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));

	// default implementation supports propset format
	BOOL bSuccess = FALSE;
	CLSID fmtid;
	if (_AfxOleMatchPropsetClipFormat(lpFormatEtc->cfFormat, &fmtid))
	{
		bSuccess = SetPropsetData(lpFormatEtc, lpStgMedium, fmtid);

		if (bSuccess && bRelease)
			ReleaseStgMedium(lpStgMedium);
	}

	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::GetDataSource

COleControl::CControlDataSource* COleControl::GetDataSource()
{
	TRY
	{
		if (m_pDataSource == NULL)
		{
			AFX_MANAGE_STATE(m_pModuleState);
			m_pDataSource = new CControlDataSource(this);
			ASSERT(m_pDataSource != NULL);
			SetInitialDataFormats();
		}
	}
	END_TRY

	return m_pDataSource;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::SetInitialDataFormats

void COleControl::SetInitialDataFormats()
{
	// by default a COleControl supports CF_METAFILEPICT
	FORMATETC formatEtc;
	formatEtc.cfFormat = CF_METAFILEPICT;
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_CONTENT;
	formatEtc.lindex = -1;
	formatEtc.tymed = TYMED_MFPICT;
	ENSURE(m_pDataSource != NULL);
	m_pDataSource->DelayRenderData(0, &formatEtc);

	// by default a COleControl supports persistent propset format
	// (GetData or SetData)
	formatEtc.cfFormat = _AfxGetClipboardFormatPersistPropset();
	formatEtc.ptd = NULL;
	formatEtc.dwAspect = DVASPECT_CONTENT;
	formatEtc.lindex = -1;
	formatEtc.tymed = TYMED_ISTREAM | TYMED_ISTORAGE;
	m_pDataSource->DelayRenderData(0, &formatEtc);
	m_pDataSource->DelaySetData(0, &formatEtc);

	// by default a COleControl supports VBX conversion propset format
	// (SetData only)
	formatEtc.cfFormat = _AfxGetClipboardFormatConvertVBX();
	m_pDataSource->DelaySetData(0, &formatEtc);
}


/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlevent.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <stdarg.h>



#define new DEBUG_NEW

#pragma warning(disable: 4706) // assignment within conditional

/////////////////////////////////////////////////////////////////////////////
// Stock event mask

#define STOCKEVENT_CLICK            0x00000001
#define STOCKEVENT_DBLCLICK         0x00000002
#define STOCKEVENT_KEYDOWN          0x00000004
#define STOCKEVENT_KEYPRESS         0x00000008
#define STOCKEVENT_KEYUP            0x00000010
#define STOCKEVENT_MOUSEDOWN        0x00000020
#define STOCKEVENT_MOUSEMOVE        0x00000040
#define STOCKEVENT_MOUSEUP          0x00000080
#define STOCKEVENT_ERROR            0x00000100
#define STOCKEVENT_READYSTATECHANGE 0x00000200

#define STOCKEVENTS_MOUSE       0x000000A3  // Click, DblClick, MouseDown, MouseUp

AFX_STATIC_DATA const DWORD _afxStockEvents[] =
{
	STOCKEVENT_CLICK,               // -600
	STOCKEVENT_DBLCLICK,            // -601
	STOCKEVENT_KEYDOWN,             // -602
	STOCKEVENT_KEYPRESS,            // -603
	STOCKEVENT_KEYUP,               // -604
	STOCKEVENT_MOUSEDOWN,           // -605
	STOCKEVENT_MOUSEMOVE,           // -606
	STOCKEVENT_MOUSEUP,             // -607
	STOCKEVENT_ERROR,               // -608
	STOCKEVENT_READYSTATECHANGE,    // -609
};

void COleControl::InitStockEventMask()
{
	const AFX_EVENTMAP* pEventMap = GetEventMap();
	const AFX_EVENTMAP_ENTRY* pEntry;
	ASSERT(pEventMap != NULL);

	// If stock event mask is already initialized, we're outta here.
	if (*pEventMap->lpStockEventMask != (DWORD)-1)
		return;

	AfxLockGlobals(CRIT_STOCKMASK);

	if (*pEventMap->lpStockEventMask == (DWORD)-1)
	{
		const AFX_EVENTMAP* pEventMapTop = pEventMap;
		DWORD dwStockEventMask = 0;

#ifdef _AFXDLL
		for (;;)
#else
		while (pEventMap != NULL)
#endif
		{
			pEntry = pEventMap->lpEntries;
			while (pEntry != NULL && pEntry->pszName != NULL)
			{
				int nIndex = DISPID_CLICK - pEntry->dispid;
				DWORD dwFlag;
				if ((pEntry->flags & afxEventStock) && (nIndex >= 0) &&
					(nIndex < _countof(_afxStockEvents)) &&
					(dwFlag = _afxStockEvents[nIndex]) != 0)
				{
					dwStockEventMask |= dwFlag;
				}

				++pEntry;
			}
			// check base class
#ifdef _AFXDLL
			if (pEventMap->pfnGetBaseMap == NULL)
				break;
			pEventMap = (*pEventMap->pfnGetBaseMap)();
#else
			pEventMap = pEventMap->lpBaseEventMap;
#endif
		}

		*pEventMapTop->lpStockEventMask = dwStockEventMask;
	}

	AfxUnlockGlobals(CRIT_STOCKMASK);
}

/////////////////////////////////////////////////////////////////////////////
// Event map operations

const AFX_EVENTMAP* COleControl::GetEventMap() const
{
	return &eventMap;
}

#ifdef _AFXDLL
const AFX_EVENTMAP* PASCAL COleControl::GetThisEventMap()
{
	return &eventMap;
}
#endif

const AFX_EVENTMAP_ENTRY* COleControl::GetEventMapEntry(
		LPCTSTR pszName,
		DISPID* pDispid) const
{
	ASSERT(pszName != NULL);
	ASSERT(pDispid != NULL);

	const AFX_EVENTMAP* pEventMap = GetEventMap();
	const AFX_EVENTMAP_ENTRY* pEntry;
	DISPID dispid = MAKELONG(1, 0);

#ifdef _AFXDLL
	for (;;)
#else
	while (pEventMap != NULL)
#endif
	{
		pEntry = pEventMap->lpEntries;

		// Scan entries in this event map

		if (pEntry != NULL)
		{
			while (pEntry->pszName != NULL)
			{
				if (lstrcmp(pEntry->pszName, pszName) == 0)
				{
					if (pEntry->dispid != DISPID_UNKNOWN)
						dispid = pEntry->dispid;

					*pDispid = dispid;
					return pEntry;
				}

				++pEntry;
				++dispid;
			}
		}

		// If we didn't find it, go to the base class's event map
#ifdef _AFXDLL
		if (pEventMap->pfnGetBaseMap == NULL)
			break;
		pEventMap = (*pEventMap->pfnGetBaseMap)();
#else
		pEventMap = pEventMap->lpBaseEventMap;
#endif

		dispid = MAKELONG(1, HIWORD(dispid)+1);
	}

	// If we reach here, the event isn't supported

	return NULL;
}

void COleControl::FireEventV(DISPID dispid, BYTE* pbParams,
	va_list argList)
{
	COleDispatchDriver driver;

	POSITION pos = m_xEventConnPt.GetStartPosition();
	LPDISPATCH pDispatch;
	while (pos != NULL)
	{
		pDispatch = (LPDISPATCH)m_xEventConnPt.GetNextConnection(pos);
		if(pDispatch != NULL)
		{
			driver.AttachDispatch(pDispatch, FALSE);
			TRY
				driver.InvokeHelperV(dispid, DISPATCH_METHOD, VT_EMPTY, NULL,
					pbParams, argList);
			END_TRY
			driver.DetachDispatch();
		}
	}
}

void AFX_CDECL COleControl::FireEvent(DISPID dispid, BYTE* pbParams, ...)
{
	va_list argList;
	va_start(argList, pbParams);
	FireEventV(dispid, pbParams, argList);
	va_end(argList);
}

/////////////////////////////////////////////////////////////////////////////
// Helper function for stock events

short AFXAPI _AfxShiftState()
{
	BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
	BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
	BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

	return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}

/////////////////////////////////////////////////////////////////////////////
// Window message handlers for stock events

void COleControl::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	HWND hWndSave = m_hWnd;
	USHORT nCharShort = (USHORT)nChar;
	KeyDown(&nCharShort);
	if ((m_hWnd == hWndSave) && (nCharShort != 0))
		DefWindowProc(WM_SYSKEYDOWN, nCharShort, MAKELONG(nRepCnt, nFlags));
}

void COleControl::OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	HWND hWndSave = m_hWnd;
	USHORT nCharShort = (USHORT)nChar;
	KeyUp(&nCharShort);
	if ((m_hWnd == hWndSave) && (nCharShort != 0))
		DefWindowProc(WM_SYSKEYUP, nCharShort, MAKELONG(nRepCnt, nFlags));
}

void COleControl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	HWND hWndSave = m_hWnd;
	USHORT nCharShort = (USHORT)nChar;
	KeyDown(&nCharShort);
	if ((m_hWnd == hWndSave) && (nCharShort != 0))
		DefWindowProc(WM_KEYDOWN, nCharShort, MAKELONG(nRepCnt, nFlags));
}

void COleControl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	HWND hWndSave = m_hWnd;
	USHORT nCharShort = (USHORT)nChar;
	KeyUp(&nCharShort);
	if ((m_hWnd == hWndSave) && (nCharShort != 0))
		DefWindowProc(WM_KEYUP, nCharShort, MAKELONG(nRepCnt, nFlags));
}

void COleControl::KeyUp(USHORT* pnChar)
{
	if (GetStockEventMask() & STOCKEVENT_KEYUP)
	{
		USHORT nShiftState = _AfxShiftState();
		FireKeyUp(pnChar, nShiftState);

		// If handler set *pnChar to zero, cancel further processing.
		if (*pnChar != 0)
			OnKeyUpEvent(*pnChar, nShiftState);
	}
}

void COleControl::KeyDown(USHORT* pnChar)
{
	if (GetStockEventMask() & STOCKEVENT_KEYDOWN)
	{
		USHORT nShiftState = _AfxShiftState();
		FireKeyDown(pnChar, nShiftState);

		// If handler set *pnChar to zero, cancel further processing.
		if (*pnChar != 0)
			OnKeyDownEvent(*pnChar, nShiftState);
	}
}

AFX_STATIC void AFXAPI _AfxPostTrailByte(CWnd* pWnd, BYTE bTrailByte)
{
	// Force new trail byte to the front of the queue.
	pWnd->PostMessage(WM_QUEUE_SENTINEL);
	pWnd->PostMessage(WM_CHAR, bTrailByte);
	MSG msg;
	while (::PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_REMOVE) &&
		(msg.message != WM_QUEUE_SENTINEL))
	{
		::PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
	}

	ASSERT(msg.message == WM_QUEUE_SENTINEL);
	ASSERT(msg.hwnd == pWnd->m_hWnd);
}

UINT COleControl::OnGetDlgCode()
{
	// If we're firing KeyPress, prevent the container from stealing WM_CHAR.
	return (IsSubclassedControl() ? CWnd::OnGetDlgCode() : 0) |
		((GetStockEventMask() & STOCKEVENT_KEYPRESS) ? DLGC_WANTCHARS : 0);
}

void COleControl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	USHORT nCharShort = (USHORT)nChar;
	USHORT nCharSave = nCharShort;
	BOOL bLeadByte = IsDBCSLeadByte((BYTE)nCharShort);
	MSG msg;

	if (GetStockEventMask() & STOCKEVENT_KEYPRESS)
	{
		if (bLeadByte)
		{
			// We have the lead-byte of a DBCS character.  Peek for the
			// next WM_CHAR message, which will contain the other byte.

			BOOL bMessage;
			VERIFY(bMessage = ::PeekMessage(&msg, m_hWnd, WM_CHAR, WM_CHAR,
				PM_NOYIELD | PM_NOREMOVE));

			// Combine the bytes to form the DBCS character.

			if (bMessage)
				nCharShort = (USHORT)((nCharShort << 8) | msg.wParam);
		}

		HWND hWndSave = m_hWnd;
		nCharSave = nCharShort;
		FireKeyPress(&nCharShort);

		// If handler set nCharShort to zero, cancel further processing.
		if (nCharShort != 0)
			OnKeyPressEvent(nCharShort);

		if (m_hWnd != hWndSave)
			return;
	}

	if (nCharShort != 0)
	{
		if (nCharSave != nCharShort)
		{
			nChar = nCharShort;

			// Event handler has changed the character.

			BOOL bNewLeadByte = IsDBCSLeadByte(HIBYTE(nCharShort));

			if (bLeadByte)
			{
				if (bNewLeadByte)
				{
					// Event handler changed character from DBCS to DBCS:
					// Remove the old trail byte and post the new one.

					VERIFY(::PeekMessage(&msg, m_hWnd, WM_CHAR, WM_CHAR,
						PM_NOYIELD | PM_REMOVE));
					_AfxPostTrailByte(this, LOBYTE(nCharShort));
					nChar = HIBYTE(nCharShort);
				}
				else
				{
					// Event handler changed character from DBCS to SBCS:
					// Remove the second byte from the queue, and forward
					// along the new single-byte character.

					VERIFY(::PeekMessage(&msg, m_hWnd, WM_CHAR, WM_CHAR,
						PM_NOYIELD | PM_REMOVE));
				}
			}
			else
			{
				if (bNewLeadByte)
				{
					// Event handler changed character from SBCS to DBCS:
					// Post the new trail byte.

					_AfxPostTrailByte(this, LOBYTE(nCharShort));
					nChar = HIBYTE(nCharShort);
				}
			}
		}

		DefWindowProc(WM_CHAR, nChar, MAKELONG(nRepCnt, nFlags));
	}

	if (bLeadByte)
	{
		// Cleanup after processing a DBCS character:
		// Remove the next WM_CHAR message (containing the second byte) from
		// the message queue, UNLESS we're subclassing an Edit, ListBox, or
		// ComboBox control.

		TCHAR szClassName[10];
		if ((!::GetClassName(m_hWnd, szClassName, 10)) ||  // didn't get class
			(::AfxInvariantStrICmp(szClassName, _T("Edit")) &&           // not Edit
			 ::AfxInvariantStrICmp(szClassName, _T("ListBox")) &&        // not ListBox
			 ::AfxInvariantStrICmp(szClassName, _T("ComboBox"))))        // not ComboBox
		{
			VERIFY(::PeekMessage(&msg, m_hWnd, WM_CHAR, WM_CHAR,
				PM_NOYIELD | PM_REMOVE));
		}
	}
}

void COleControl::OnKeyPressEvent(USHORT)
{
	// Can be overridden by subclass
}

void COleControl::OnKeyDownEvent(USHORT, USHORT)
{
	// Can be overridden by subclass
}

void COleControl::OnKeyUpEvent(USHORT, USHORT)
{
	// Can be overridden by subclass
}

void COleControl::ButtonDown(USHORT iButton, UINT, CPoint point)
{
	DWORD dwStockEventMask = GetStockEventMask();
	if ((dwStockEventMask & STOCKEVENTS_MOUSE) || m_bPendingUIActivation)
	{
		if (m_iButtonState == 0)
			SetCapture();

		m_iButtonState |= iButton;

		if (dwStockEventMask & STOCKEVENT_MOUSEDOWN)
			FireMouseDown(iButton, _AfxShiftState(), point.x, point.y);

		m_iDblClkState &= ~iButton;
	}
}

void COleControl::ButtonUp(USHORT iButton, UINT, CPoint point)
{
	if (m_iButtonState != 0)
	{
		m_iButtonState &= ~iButton;

		if (m_iButtonState == 0)
			ReleaseCapture();

		DWORD dwStockEventMask = GetStockEventMask();

		if (dwStockEventMask & STOCKEVENT_MOUSEUP)
			FireMouseUp(iButton, _AfxShiftState(), point.x, point.y);

		if ((dwStockEventMask & STOCKEVENT_CLICK) &&
			!(m_iDblClkState & iButton))
		{
			CRect rect;
			GetClientRect(&rect);
			if (rect.PtInRect(point))
				OnClick(iButton);
		}

		m_iDblClkState &= ~iButton;
	}
}

void COleControl::ButtonDblClk(USHORT iButton, UINT, CPoint)
{
	DWORD dwStockEventMask = GetStockEventMask();
	if (dwStockEventMask & STOCKEVENTS_MOUSE)
	{
		SetCapture();
		m_iButtonState |= iButton;

		if (dwStockEventMask & STOCKEVENT_DBLCLICK)
		{
			FireDblClick();
			m_iDblClkState |= iButton;
		}
	}
}

void COleControl::OnMouseMove(UINT /*nFlags*/, CPoint point)
{
	if (GetStockEventMask() & STOCKEVENT_MOUSEMOVE)
	{
		HWND hWndSave = m_hWnd;
		FireMouseMove((short)m_iButtonState, _AfxShiftState(), point.x, point.y);
		if (m_hWnd != hWndSave)
			return;
	}
	Default();
}

void COleControl::OnLButtonDown(UINT nFlags, CPoint point)
{
	OnButtonDown(LEFT_BUTTON, nFlags, point);
}

void COleControl::OnLButtonUp(UINT nFlags, CPoint point)
{
	OnButtonUp(LEFT_BUTTON, nFlags, point);
}

void COleControl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	OnButtonDblClk(LEFT_BUTTON, nFlags, point);
}

void COleControl::OnMButtonDown(UINT nFlags, CPoint point)
{
	OnButtonDown(MIDDLE_BUTTON, nFlags, point);
}

void COleControl::OnMButtonUp(UINT nFlags, CPoint point)
{
	OnButtonUp(MIDDLE_BUTTON, nFlags, point);
}

void COleControl::OnMButtonDblClk(UINT nFlags, CPoint point)
{
	OnButtonDblClk(MIDDLE_BUTTON, nFlags, point);
}

void COleControl::OnRButtonDown(UINT nFlags, CPoint point)
{
	OnButtonDown(RIGHT_BUTTON, nFlags, point);
}

void COleControl::OnRButtonUp(UINT nFlags, CPoint point)
{
	OnButtonUp(RIGHT_BUTTON, nFlags, point);
}

void COleControl::OnRButtonDblClk(UINT nFlags, CPoint point)
{
	OnButtonDblClk(RIGHT_BUTTON, nFlags, point);
}

void COleControl::OnButtonDown(USHORT nButton, UINT nFlags, CPoint point)
{
	HWND hWndSave = m_hWnd;
	if (nButton == LEFT_BUTTON)
		SetFocus();
	ButtonDown(nButton, nFlags, point);
	if (m_hWnd != hWndSave)
		return;

	Default();
}

void COleControl::OnButtonUp(USHORT nButton, UINT nFlags, CPoint point)
{
	HWND hWndSave = m_hWnd;
	Default();
	ButtonUp(nButton, nFlags, point);
	if (m_hWnd != hWndSave)
		return;

	if (m_bInPlaceActive && !m_bUIActive && m_bPendingUIActivation)
	{
		m_bPendingUIActivation = FALSE;
		HWND hWndFocus = ::GetFocus();
		if (hWndFocus == m_hWnd || ::IsChild(m_hWnd, hWndFocus))
			OnActivateInPlace(TRUE, NULL);
	}
}

void COleControl::OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point)
{
	HWND hWndSave = m_hWnd;
	ButtonDblClk(nButton, nFlags, point);
	if (m_hWnd != hWndSave)
		return;

	Default();
}

void COleControl::OnCancelMode()
{
	CWnd::OnCancelMode();

	if ((m_iButtonState != 0) || (m_iDblClkState != 0))
	{
		ReleaseCapture();
		m_iButtonState = 0;
		m_iDblClkState = 0;
	}
}

void COleControl::OnClick(USHORT /*iButton*/)
{
	// May be overridden by subclass

	if (GetStockEventMask() & STOCKEVENT_CLICK)
		FireClick();
}

/////////////////////////////////////////////////////////////////////////////
// Error event

#define ERROR_PARAMS \
	 EVENT_PARAM(VTS_I2 VTS_PBSTR VTS_SCODE VTS_BSTR VTS_BSTR VTS_I4 VTS_PBOOL)

void COleControl::FireError(SCODE scode, LPCTSTR lpszDescription, UINT nHelpID)
{	
	ExternalAddRef();   // "Insurance" addref -- keeps control alive.

	const CStringW strDescription(lpszDescription);
	BSTR bstrDescription = lpszDescription ? strDescription.AllocSysString() : NULL;
	LPCTSTR lpszSource = AfxGetAppName();
	LPCTSTR lpszHelpFile = _T("");

	if (nHelpID != 0)
		lpszHelpFile = AfxGetApp()->m_pszHelpFilePath;

	if (lpszHelpFile == NULL)
		lpszHelpFile = _T("");

	BOOL bCancelDisplay = FALSE;

	FireEvent(DISPID_ERROREVENT, ERROR_PARAMS, (WORD)SCODE_CODE(scode),
		&bstrDescription, scode, lpszSource, lpszHelpFile, (DWORD)nHelpID,
		&bCancelDisplay);

	if (!bCancelDisplay)
	{
		const CString strDesc(bstrDescription);
		DisplayError(scode, strDesc.GetString(), lpszSource, lpszHelpFile, nHelpID);
	}

	::SysFreeString(bstrDescription);

	ExternalRelease();
}

void COleControl::DisplayError(SCODE /*scode*/, LPCTSTR lpszDescription,
	LPCTSTR lpszSource, LPCTSTR /*lpszHelpFile*/, UINT /*nHelpID*/)
{
	// May be overridden by subclass.
	MessageBox(lpszDescription, lpszSource);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlframe.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _AFXDLL



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CControlFrameWnd, CWnd)
	//{{AFX_MSG_MAP(CControlFrameWnd)
	ON_WM_CLOSE()
	ON_WM_ACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CControlFrameWnd implementation

CControlFrameWnd::CControlFrameWnd(COleControl* pCtrl) :
	m_pCtrl(pCtrl)
{
}

BOOL CControlFrameWnd::PreCreateWindow(CREATESTRUCT& cs)
{
	// make sure the default window class is registered
	VERIFY(AfxDeferRegisterClass(AFX_WND_REG));

	if (cs.lpszClass == NULL)
		cs.lpszClass = AFX_WND;

	return TRUE;
}

BOOL CControlFrameWnd::Create(LPCTSTR pszFrameTitle)
{
	if (!CreateEx(
			0,
			NULL, pszFrameTitle,
			WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
			CW_USEDEFAULT, CW_USEDEFAULT,
			CW_USEDEFAULT, CW_USEDEFAULT,
			NULL, NULL, NULL))
	{
		TRACE(traceAppMsg, 0, "Warning: failed to create CControlFrameWnd\n");
		return FALSE;
	}

	return TRUE;
}

void CControlFrameWnd::OnClose()
{
	m_pCtrl->OnFrameClose();
	DestroyWindow();
}

void CControlFrameWnd::PostNcDestroy()
{
	delete this;
}

void CControlFrameWnd::OnActivate(UINT nState, CWnd* pWndOther,
	BOOL bMinimized)
{
	CWnd::OnActivate(nState, pWndOther, bMinimized);
	m_pCtrl->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG


#endif //_AFXDLL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __CTLIMPL_H__
#define __CTLIMPL_H__

#pragma once

// MFC data definition for data exported from the runtime DLL

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// Codes for COleControl::SendAdvise
//......Code.........................Method called
#define OBJECTCODE_SAVED          0  //IOleAdviseHolder::SendOnSave
#define OBJECTCODE_CLOSED         1  //IOleAdviseHolder::SendOnClose
#define OBJECTCODE_RENAMED        2  //IOleAdviseHolder::SendOnRename
#define OBJECTCODE_SAVEOBJECT     3  //IOleClientSite::SaveObject
#define OBJECTCODE_DATACHANGED    4  //IDataAdviseHolder::SendOnDataChange
#define OBJECTCODE_SHOWWINDOW     5  //IOleClientSite::OnShowWindow(TRUE)
#define OBJECTCODE_HIDEWINDOW     6  //IOleClientSite::OnShowWindow(FALSE)
#define OBJECTCODE_SHOWOBJECT     7  //IOleClientSite::ShowObject
#define OBJECTCODE_VIEWCHANGED    8  //IOleAdviseHolder::SendOnViewChange


/////////////////////////////////////////////////////////////////////////////
// Typedefs

typedef LPVOID* LPLPVOID;

/////////////////////////////////////////////////////////////////////////////
// Functions

LPSTREAM AFXAPI _AfxGetArchiveStream(CArchive& ar, CArchiveStream& stm);
CLIPFORMAT AFXAPI _AfxGetClipboardFormatConvertVBX();
CLIPFORMAT AFXAPI _AfxGetClipboardFormatPersistPropset();
BOOL AFXAPI _AfxOleMatchPropsetClipFormat(CLIPFORMAT cfFormat, LPCLSID lpFmtID);
BOOL AFXAPI _AfxCopyPropValue(VARTYPE vtProp, void* pvDest, const void * pvSrc);
BOOL AFXAPI _AfxPeekAtClassIDInStream(LPSTREAM pstm, LPCLSID lpClassID);
BOOL AFXAPI _AfxIsSamePropValue(VARTYPE vtProp, const void* pv1, const void* pv2);
BOOL AFXAPI _AfxIsSameFont(CFontHolder& font, const FONTDESC* pFontDesc,
	LPFONTDISP pFontDispAmbient);
BOOL AFXAPI _AfxIsSameUnknownObject(REFIID iid, LPUNKNOWN pUnk1, LPUNKNOWN pUnk2);
BOOL AFXAPI _AfxInitBlob(HGLOBAL* phDst, void* pvSrc);
BOOL AFXAPI _AfxCopyBlob(HGLOBAL* phDst, HGLOBAL hSrc);
LPFONT AFXAPI _AfxCreateFontFromStream(LPSTREAM);
BOOL AFXAPI _AfxTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);
void AFXAPI _AfxXformSizeInPixelsToHimetric(HDC, LPSIZEL, LPSIZEL);
void AFXAPI _AfxXformSizeInHimetricToPixels(HDC, LPSIZEL, LPSIZEL);
void AFXAPI _AfxDrawBorders(CDC* pDC, CRect& rc, BOOL bBorder, BOOL bClientEdge);

/////////////////////////////////////////////////////////////////////////////
// _AFXCTL_ADVISE_INFO - Information about an advise sink

struct _AFXCTL_ADVISE_INFO
{
	DWORD m_dwAspects;
	DWORD m_dwAdvf;
	LPADVISESINK m_pAdvSink;

	_AFXCTL_ADVISE_INFO() : m_dwAspects(0), m_dwAdvf(0), m_pAdvSink(NULL) {}
};

/////////////////////////////////////////////////////////////////////////////
// _AFXCTL_AMBIENT_CACHE - cache of common ambient property values

class _AFXCTL_AMBIENT_CACHE : public CNoTrackObject
{
// Constructor
public:
	_AFXCTL_AMBIENT_CACHE();

// Attributes
	BOOL m_bValid;
	DWORD m_dwAmbientFlags;
	OLE_COLOR m_colorFore;
	OLE_COLOR m_colorBack;
	IFont* m_pFont;
	void* m_pReserved;
	DWORD m_dwAppearance;

// Operations
	void Cache(QACONTAINER* pQAContainer);
};

EXTERN_THREAD_LOCAL(_AFXCTL_AMBIENT_CACHE, _afxAmbientCache)

/////////////////////////////////////////////////////////////////////////////
// CControlFrameWnd - used for a control's "open" (non-in-place) state.

class CControlFrameWnd : public CWnd
{
private:
   using CWnd::Create;

public:
	CControlFrameWnd(COleControl* pCtrl);
	virtual BOOL Create(LPCTSTR pszTitle);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

protected:
	virtual void PostNcDestroy();

	COleControl* m_pCtrl;

	//{{AFX_MSG(CControlFrameWnd)
	afx_msg void OnClose();
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CReflectorWnd - reflects window messages to a subclassed control.

class CReflectorWnd : public CWnd
{
private:
   using CWnd::Create;

public:
	CReflectorWnd() : m_pCtrl(NULL) { }

	BOOL Create(const CRect& rect, HWND hWndParent);
	void SetControl(COleControl* pCtrl);

protected:
	virtual LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();

	COleControl* m_pCtrl;
};

/////////////////////////////////////////////////////////////////////////////
// CParkingWnd - "parking space" for not-yet-activated subclassed controls

class CParkingWnd : public CWnd
{
public:
	CParkingWnd()
		{ AfxDeferRegisterClass(AFX_WNDOLECONTROL_REG);
		  CreateEx(WS_EX_NOPARENTNOTIFY|WS_EX_TOOLWINDOW,
			AFX_WNDOLECONTROL, NULL, WS_VISIBLE|WS_CHILD,
			-1000, -1000, 1, 1, ::GetDesktopWindow(), 0); }
	virtual LRESULT WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
	CMapPtrToPtr m_idMap;
};


/////////////////////////////////////////////////////////////////////////////
//  Property sets

typedef struct tagSECTIONHEADER
{
	DWORD       cbSection ;
	DWORD       cProperties ;  // Number of props.
} SECTIONHEADER, *LPSECTIONHEADER ;

typedef struct tagPROPERTYIDOFFSET
{
	DWORD       propertyID;
	DWORD       dwOffset;
} PROPERTYIDOFFSET, *LPPROPERTYIDOFFSET;

typedef struct tagPROPHEADER
{
	WORD        wByteOrder ;    // Always 0xFFFE
	WORD        wFormat ;       // Always 0
	DWORD       dwOSVer ;       // System version
	CLSID       clsID ;         // Application CLSID
	DWORD       cSections ;     // Number of sections (must be at least 1)
} PROPHEADER, *LPPROPHEADER ;

typedef struct tagFORMATIDOFFSET
{
	GUID        formatID;
	DWORD       dwOffset;
} FORMATIDOFFSET, *LPFORMATIDOFFSET;


/////////////////////////////////////////////////////////////////////////////
// CProperty

class CProperty
{
	friend class CPropertySet ;
	friend class CPropertySection ;

public:
// Construction
	CProperty( void ) ;
	CProperty( DWORD dwID, const LPVOID pValue, DWORD dwType ) ;

// Attributes
	BOOL    Set( DWORD dwID, const LPVOID pValue, DWORD dwType ) ;
	BOOL    Set( const LPVOID pValue, DWORD dwType ) ;
	BOOL    Set( const LPVOID pValue ) ;
	LPVOID  Get( DWORD* pcb ) ;     // Returns pointer to actual value
	LPVOID  Get( void ) ;           // Returns pointer to actual value
	DWORD   GetType( void ) ;       // Returns property type
	void    SetType( DWORD dwType ) ;
	DWORD   GetID( void ) ;
	void    SetID( DWORD dwPropID ) ;

	LPVOID  GetRawValue( void ) ;   // Returns pointer internal value (may
									// include size information)
// Operations
	BOOL    WriteToStream( IStream* pIStream ) ;
	BOOL    ReadFromStream( IStream* pIStream ) ;

private:
	DWORD       m_dwPropID ;
	DWORD       m_dwType ;
	LPVOID      m_pValue ;

	LPVOID  AllocValue(ULONG cb);
	void    FreeValue();

public:
	~CProperty() ;
} ;


/////////////////////////////////////////////////////////////////////////////
// CPropertySection

class CPropertySection
{
	friend class CPropertySet ;
	friend class CProperty ;

public:
// Construction
	CPropertySection( void ) ;
	CPropertySection( CLSID FormatID ) ;

// Attributes
	CLSID   GetFormatID( void ) ;
	void    SetFormatID( CLSID FormatID ) ;

	BOOL    Set( DWORD dwPropID, LPVOID pValue, DWORD dwType ) ;
	BOOL    Set( DWORD dwPropID, LPVOID pValue ) ;
	LPVOID  Get( DWORD dwPropID, DWORD* pcb ) ;
	LPVOID  Get( DWORD dwPropID ) ;
	void    Remove( DWORD dwPropID ) ;
	void    RemoveAll() ;

	CProperty* GetProperty( DWORD dwPropID ) ;
	void AddProperty( CProperty* pProp ) ;

	DWORD   GetSize( void ) ;
	DWORD   GetCount( void ) ;
	CPtrList* GetList( void ) ;

	BOOL    GetID( LPCTSTR pszName, DWORD* pdwPropID ) ;
	BOOL    SetName( DWORD dwPropID, LPCTSTR pszName ) ;

	BOOL    SetSectionName( LPCTSTR pszName );
	LPCTSTR GetSectionName( void );

// Operations
	BOOL    WriteToStream( IStream* pIStream ) ;
	BOOL    ReadFromStream( IStream* pIStream, LARGE_INTEGER liPropSet ) ;
	BOOL    WriteNameDictToStream( IStream* pIStream ) ;
	BOOL    ReadNameDictFromStream( IStream* pIStream ) ;

private:
// Implementation
	CLSID           m_FormatID ;
	SECTIONHEADER   m_SH ;
	// List of properties (CProperty)
	CPtrList         m_PropList ;
	// Dictionary of property names
	CMapStringToPtr m_NameDict ;
	CString         m_strSectionName;

public:
	~CPropertySection();
} ;


/////////////////////////////////////////////////////////////////////////////
// CPropertySet

class CPropertySet
{
	friend class CPropertySection ;
	friend class CProperty ;

public:
// Construction
	CPropertySet( void ) ;
	CPropertySet( CLSID clsID )  ;

// Attributes
	BOOL    Set( CLSID FormatID, DWORD dwPropID, LPVOID pValue, DWORD dwType ) ;
	BOOL    Set( CLSID FormatID, DWORD dwPropID, LPVOID pValue ) ;
	LPVOID  Get( CLSID FormatID, DWORD dwPropID, DWORD* pcb ) ;
	LPVOID  Get( CLSID FormatID, DWORD dwPropID ) ;
	void    Remove( CLSID FormatID, DWORD dwPropID ) ;
	void    Remove( CLSID FormatID ) ;
	void    RemoveAll( ) ;

	CProperty* GetProperty( CLSID FormatID, DWORD dwPropID ) ;
	void AddProperty( CLSID FormatID, CProperty* pProp ) ;
	CPropertySection* GetSection( CLSID FormatID ) ;
	CPropertySection* AddSection( CLSID FormatID ) ;
	void AddSection( CPropertySection* psect ) ;

	WORD    GetByteOrder( void ) ;
	WORD    GetFormatVersion( void ) ;
	void    SetFormatVersion( WORD wFmtVersion ) ;
	DWORD   GetOSVersion( void ) ;
	void    SetOSVersion( DWORD dwOSVer ) ;
	CLSID   GetClassID( void ) ;
	void    SetClassID( CLSID clsid ) ;
	DWORD   GetCount( void ) ;
	CPtrList* GetList( void ) ;

// Operations
	BOOL    WriteToStream( IStream* pIStream ) ;
	BOOL    ReadFromStream( IStream* pIStream ) ;

// Implementation
private:
	PROPHEADER      m_PH ;
	CPtrList         m_SectionList ;

public:
	~CPropertySet();
} ;


/////////////////////////////////////////////////////////////////////////////
// CArchivePropExchange - for persistence in an archive.

class CArchivePropExchange : public CPropExchange
{
// Constructors
public:
	CArchivePropExchange(CArchive& ar);

// Operations
	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL);
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL);
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient);
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault);

// Implementation
protected:
	CArchive& m_ar;
};


/////////////////////////////////////////////////////////////////////////////
// CResetPropExchange - for resetting property state to defaults.

class CResetPropExchange : public CPropExchange
{
// Constructors
public:
	CResetPropExchange(void);

// Operations
	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL);
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL);
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient);
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault);
};


/////////////////////////////////////////////////////////////////////////////
// CPropsetPropExchange - for persistence in a property set.

class CPropsetPropExchange : public CPropExchange
{
// Constructors
public:
	CPropsetPropExchange(CPropertySection& psec, LPSTORAGE lpStorage,
		BOOL bLoading);

// Operations
	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL);
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL);
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient);
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault);

// Implementation
	CPropertySection& m_psec;
	LPSTORAGE m_lpStorage;
	DWORD m_dwPropID;
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncPropExchange - for launching asynchronous downloads set.

class CAsyncPropExchange : public CPropExchange
{
// Constructors
public:
	CAsyncPropExchange(DWORD dwVersion);

// Operations
public:
	virtual BOOL ExchangeVersion(DWORD& dwVersionLoaded,
		DWORD dwVersionDefault, BOOL bConvert);

	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL);
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL);
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc,
				LPFONTDISP pFontDispAmbient);
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault);
};


/////////////////////////////////////////////////////////////////////////////
// COleDispatchExceptionEx - dispatch exception that includes an SCODE

class COleDispatchExceptionEx : public COleDispatchException
{
public:
	COleDispatchExceptionEx(LPCTSTR lpszDescription, UINT nHelpID, SCODE sc);
};

/////////////////////////////////////////////////////////////////////////////
// Reset MFC data definitions

#undef AFX_DATA
#define AFX_DATA

#endif  //__CTLIMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlinl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _AFXDLL
#pragma comment(lib, "oleaut32.lib")
#endif

#ifndef _AFX_ENABLE_INLINES


#define _AFXCTL_INLINE
#include "afxctl.inl"

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctllic.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// AfxVerifyLicFile - Checks that a license file exists and contains a
//    specific byte pattern.

BOOL AFXAPI AfxVerifyLicFile(HINSTANCE hInstance, LPCTSTR pszLicFileName,
	LPCOLESTR pszLicFileContents, UINT cch)
{
	// Assume the worst...
	BOOL bVerified = FALSE;

	// Look for license file in same directory as this DLL.
	TCHAR szPathName[_MAX_PATH];
	UINT retVal = ::GetModuleFileName(hInstance, szPathName, _MAX_PATH);
	if (retVal == 0 || retVal == _MAX_PATH)
		return FALSE;

	// Attach the file name in pszLicFileName to the szPathName
	LPTSTR pszFileName = _tcsrchr(szPathName, '\\') + 1;
	if (pszLicFileName != NULL && pszFileName > szPathName &&
		lstrlen(pszLicFileName) < (_MAX_PATH - (pszFileName - szPathName)) ) 
		Checked::tcscpy_s(pszFileName, _countof(szPathName) - (pszFileName - szPathName), pszLicFileName);
	else
		return FALSE;

	LPSTR pszKey = NULL;
	LPBYTE pbContent = NULL;

	TRY
	{
		// Open file, read content and compare.

		CFile file(szPathName, CFile::modeRead);

		if (cch == -1)
			cch = (UINT)wcslen(pszLicFileContents);

		pszKey = (char*)_alloca(cch*2 + 1);
		cch = _wcstombsz(pszKey, pszLicFileContents, cch*2 + 1);

		if (cch != 0)
		{
			--cch;  // license file won't contain the terminating null char
			pbContent = (BYTE*)_alloca(cch);
			file.Read(pbContent, cch);

			if (memcmp(pszKey, pbContent, (size_t)cch) == 0)
				bVerified = TRUE;
		}
	}
	END_TRY

	return bVerified;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlinplc.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

struct _AFXCTL_UIACTIVE_INFO
{
	OLEMENUGROUPWIDTHS m_menuWidths;
	HMENU m_hSharedMenu;
	HOLEMENU m_hOleMenu;

	_AFXCTL_UIACTIVE_INFO(HMENU hInPlaceMenu, LPOLEINPLACEFRAME pInPlaceFrame);
	~_AFXCTL_UIACTIVE_INFO();
};

_AFXCTL_UIACTIVE_INFO::_AFXCTL_UIACTIVE_INFO(HMENU hInPlaceMenu,
	LPOLEINPLACEFRAME pInPlaceFrame)
{
	memset(&m_menuWidths, 0, sizeof m_menuWidths);
	m_hSharedMenu = NULL;
	m_hOleMenu = NULL;

	if (hInPlaceMenu != NULL)
	{
		// Create shared menu
		if ((m_hSharedMenu = ::CreateMenu()) == NULL)
			return;

		// Start out by getting menu from container
		if (pInPlaceFrame->InsertMenus(m_hSharedMenu, &m_menuWidths) != S_OK)
		{
			::DestroyMenu(m_hSharedMenu);
			m_hSharedMenu = NULL;
		}
		else
		{
			// Container shouldn't touch these
			ASSERT(m_menuWidths.width[1] == 0);
			ASSERT(m_menuWidths.width[3] == 0);
			ASSERT(m_menuWidths.width[5] == 0);

			// Only copy the popups if there is a menu loaded
			if (hInPlaceMenu != NULL)
			{
				// Insert our menu popups amongst the container menus
				AfxMergeMenus(m_hSharedMenu, hInPlaceMenu,
					&m_menuWidths.width[0], 1);
			}
		}
	}

	// Finally create the special OLE menu descriptor
	m_hOleMenu = ::OleCreateMenuDescriptor(m_hSharedMenu, &m_menuWidths);
}

_AFXCTL_UIACTIVE_INFO::~_AFXCTL_UIACTIVE_INFO()
{
	if (m_hSharedMenu != NULL)
		::DestroyMenu(m_hSharedMenu);

	if (m_hOleMenu != NULL)
		VERIFY(::OleDestroyMenuDescriptor(m_hOleMenu) == S_OK);
}

short AFXAPI _AfxShiftState();

void AFXAPI _GetClippingCoordinates(LPCRECT pPosRect, LPCRECT pClipRect,
	LPRECT pIntersectRect, LPPOINT pOffsetPoint)
{
	int clipLeft = 0;
	int clipTop = 0;

	if ((pClipRect == NULL) || IsRectEmpty(pClipRect))
	{
		CopyRect(pIntersectRect, pPosRect);
	}
	else
	{
		IntersectRect(pIntersectRect, pPosRect, pClipRect);
		clipLeft = pClipRect->left;
		clipTop = pClipRect->top;
	}

	pOffsetPoint->x = min(0, pPosRect->left - clipLeft);
	pOffsetPoint->y = min(0, pPosRect->top - clipTop);
}

HRESULT COleControl::OnActivateInPlace(BOOL bUIActivate, LPMSG pMsg)
{
#ifdef _AFXDLL
	if (m_bOpen)
	{
		m_pWndOpenFrame->SetActiveWindow();
		SendAdvise(OBJECTCODE_SHOWWINDOW);
		return S_OK;
	}
#endif

	// Initialize pointer to in-place site, if necessary.
	if (m_pInPlaceSite == NULL)
	{
		if (m_pClientSite == NULL)
			return E_UNEXPECTED;

		if ((GetControlFlags() & windowlessActivate) &&
			SUCCEEDED(m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless,
			reinterpret_cast<void**>(&m_pInPlaceSiteWndless))))
		{
			m_bInPlaceSiteWndless = m_bInPlaceSiteEx = TRUE;
		}
		else if ((GetControlFlags() & noFlickerActivate) &&
			SUCCEEDED(m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx,
			reinterpret_cast<void**>(&m_pInPlaceSiteEx))))
		{
			m_bInPlaceSiteEx = TRUE;
		}
		else if (SUCCEEDED(m_pClientSite->QueryInterface(IID_IOleInPlaceSite,
			reinterpret_cast<void**>(&m_pInPlaceSite))))
		{
			m_bInPlaceSiteEx = FALSE;
		}
		else
		{
			m_pInPlaceSite = NULL;
			return E_FAIL;
		}
	}

	ASSERT(m_pInPlaceSite != NULL);

	if ((m_bInPlaceActive && !bUIActivate) || m_bUIActive)
	{
		if (m_bInPlaceSiteWndless)
		{
			OnSetObjectRects(m_rcPos, NULL);
			return S_OK;
		}

		CWnd* pWndOuter = GetOuterWindow();
		HWND hwndParent;
		if ((pWndOuter != NULL) &&
			SUCCEEDED(m_pInPlaceSite->GetWindow(&hwndParent)) &&
			(hwndParent == ::GetParent(pWndOuter->m_hWnd)))
		{
			::SetWindowPos(pWndOuter->m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOZORDER|SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE|
				SWP_SHOWWINDOW);
			OnSetObjectRects(m_rcPos, NULL);
			return S_OK;
		}
	}

	// Check if container allows windowless activation.
	if (m_bInPlaceSiteWndless)
	{
		if (m_pInPlaceSiteWndless->CanWindowlessActivate() != S_OK)
			m_bInPlaceSiteWndless = FALSE;
	}

	HRESULT hr = E_FAIL;
	if (m_pInPlaceSite != NULL)
		hr = m_pInPlaceSite->CanInPlaceActivate();

	if (hr != NOERROR)
	{
		// Site doesn't allow in-place activation.
		return OnOpen(FALSE, pMsg);
	}

	if (!m_bInPlaceActive)
	{
		if (m_bInPlaceSiteEx)
		{
			// flicker-free and/or windowless activation
			BOOL bNoRedraw;
			m_pInPlaceSiteEx->OnInPlaceActivateEx(&bNoRedraw,
				m_bInPlaceSiteWndless ? ACTIVATE_WINDOWLESS : 0);
			if (GetControlFlags() & noFlickerActivate)
				m_bNoRedraw = bNoRedraw;
		}
		else
		{
			// old-style activation
			m_pInPlaceSite->OnInPlaceActivate();
		}
	}

	HWND hwndParent = NULL;

	if (SUCCEEDED(m_pInPlaceSite->GetWindow(&hwndParent)))
	{
		CRect rcClip;
		m_frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

		RELEASE(m_pInPlaceFrame);
		RELEASE(m_pInPlaceDoc);

		if (SUCCEEDED(m_pInPlaceSite->GetWindowContext(
						&m_pInPlaceFrame, &m_pInPlaceDoc,
						&m_rcPos, &rcClip, &m_frameInfo)))
		{
			ASSERT(m_pInPlaceFrame != NULL);

			CRect rectClip;
			if (!m_bInPlaceSiteWndless)
			{
				_GetClippingCoordinates(&m_rcPos, &rcClip, rectClip,
					&m_ptOffset);
				m_bInPlaceActive = CreateControlWindow(hwndParent, m_rcPos,
					rectClip);
			}
			else
			{
				m_bInPlaceActive = TRUE;
			}

			if (m_bInPlaceActive)
			{
				if (bUIActivate)
				{
					if (m_bInPlaceSiteEx)
					{
						if (m_pInPlaceSiteEx->RequestUIActivate() != S_OK)
							m_pInPlaceSite->OnUIDeactivate(FALSE);
					}					
					
					if (SUCCEEDED(m_pInPlaceSite->OnUIActivate()))
					{
						m_bUIActive = TRUE;
						BuildSharedMenu();
						m_pInPlaceFrame->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)
							GetInterface(&IID_IOleInPlaceActiveObject), NULL);
						if (m_pInPlaceDoc != NULL)
							m_pInPlaceDoc->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)
							GetInterface(&IID_IOleInPlaceActiveObject), NULL);

						if (m_hWnd != NULL)
						{
							BOOL bHandles = AmbientShowGrabHandles();
							BOOL bHatching = AmbientShowHatching();

							if (bHandles || bHatching)
								CreateTracker(bHandles, bHatching, rcClip);
						}

						AddFrameLevelUI();

						if (bUIActivate != -1 &&
							(m_bInPlaceSiteWndless || (m_hWnd && !IsChild(GetFocus()))))
						{
							SetFocus();
						}
					} else
					{
						m_bUIActive = FALSE;
					}
				}

				// Pass thru the window message that caused us to be activated
				if ((m_hWnd != NULL || m_bInPlaceSiteWndless) && (pMsg != NULL))
					ForwardActivationMsg(pMsg);

				// Send appropriate notifications...
				SendAdvise(OBJECTCODE_SHOWOBJECT);

				return S_OK;
				
			}
		}
	}

	RELEASE(m_pInPlaceFrame);
	RELEASE(m_pInPlaceDoc);

	return E_FAIL;
}

void COleControl::ForwardActivationMsg(LPMSG pMsg)
{
	UINT uMsg = pMsg->message;
	LPARAM lParam = pMsg->lParam;

	if (m_bInPlaceSiteWndless)
	{
		// For mouse messages, convert to container window's coordinates
		if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= AFX_WM_MOUSELAST))
		{
			POINT ptNew = pMsg->pt;
			HWND hWndContainer = NULL;
			if (SUCCEEDED(m_pInPlaceSite->GetWindow(&hWndContainer)))
			{
				::ScreenToClient(hWndContainer, &ptNew);
				lParam = MAKELONG((short)ptNew.x, (short)ptNew.y);
			}
		}

		// Process message on behalf of windowless control
		OnWindowlessMessage(uMsg, pMsg->wParam, lParam, NULL);
	}
	else
	{
		// For mouse messages, convert to this window's coordinates
		if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= AFX_WM_MOUSELAST))
		{
			POINT ptNew = pMsg->pt;
			ScreenToClient(&ptNew);
			lParam = MAKELONG((short)ptNew.x, (short)ptNew.y);
		}

		// Pass the message along to the control's window
		SendMessage(uMsg, pMsg->wParam, lParam);
	}
}

HMENU COleControl::OnGetInPlaceMenu()
{
	// Default: no in-place menu
	return NULL;
}

BOOL COleControl::BuildSharedMenu()
{
	// This can be called more than once on mouse clicks
	if (m_pUIActiveInfo != NULL)
	{
		ASSERT(m_pUIActiveInfo->m_hSharedMenu != NULL);
		return TRUE;
	}

	HMENU hMenu = m_bUIDead ? NULL : OnGetInPlaceMenu();
	TRY
	{
		m_pUIActiveInfo = new _AFXCTL_UIACTIVE_INFO(hMenu, m_pInPlaceFrame);
	}
	END_TRY

	return (m_pUIActiveInfo != NULL) && (m_pUIActiveInfo->m_hOleMenu != NULL);
}

void COleControl::DestroySharedMenu()
{
	ASSERT(m_pUIActiveInfo != NULL);
	if (m_pUIActiveInfo == NULL)
		return;

	HMENU hInPlaceMenu = NULL;

	if ((m_pUIActiveInfo->m_hSharedMenu != NULL) &&
		((hInPlaceMenu = OnGetInPlaceMenu()) != NULL))
	{
		// remove our menu popups from the shared menu
		AfxUnmergeMenus(m_pUIActiveInfo->m_hSharedMenu, hInPlaceMenu);

		// allow container to remove its items from the menu
		ASSERT(m_pInPlaceFrame != NULL);
		VERIFY(m_pInPlaceFrame->RemoveMenus(m_pUIActiveInfo->m_hSharedMenu) == S_OK);
	}

	delete m_pUIActiveInfo;
	m_pUIActiveInfo = NULL;
}

void COleControl::AddFrameLevelUI()
{
	ASSERT(m_pUIActiveInfo != NULL);
	if (m_pUIActiveInfo == NULL)
		return;

	m_pInPlaceFrame->SetMenu(m_pUIActiveInfo->m_hSharedMenu,
		m_pUIActiveInfo->m_hOleMenu, m_hWnd);
	OnShowToolBars();
}

void COleControl::RemoveFrameLevelUI()
{
	ASSERT(m_pUIActiveInfo != NULL);
	if (m_pUIActiveInfo == NULL)
		return;

	OnHideToolBars();

	// allow container to remove its items from the menu
	ASSERT(m_pInPlaceFrame != NULL);
	if (m_pUIActiveInfo->m_hSharedMenu != NULL)
		VERIFY(m_pInPlaceFrame->RemoveMenus(m_pUIActiveInfo->m_hSharedMenu) == S_OK);
}

void COleControl::OnShowToolBars()
{
	// Default sets border space to empty.
	// When overriding, don't call this implementation.

	m_pInPlaceFrame->SetBorderSpace(NULL);
}

void COleControl::OnHideToolBars()
{
	// Default does nothing
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleInPlaceObject

STDMETHODIMP_(ULONG) COleControl::XOleInPlaceObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XOleInPlaceObject::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XOleInPlaceObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XOleInPlaceObject::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)
	*lphwnd = pThis->m_bInPlaceActive ? pThis->GetOuterWindow()->m_hWnd : NULL;
	return (*lphwnd != NULL) ? S_OK : E_FAIL;
}

STDMETHODIMP COleControl::XOleInPlaceObject::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleInPlaceObject::InPlaceDeactivate()
{
	METHOD_PROLOGUE_EX(COleControl, OleInPlaceObject)

	if (!pThis->m_bInPlaceActive)
		return S_OK;

	pThis->m_bInPlaceActive = FALSE;

	if (pThis->m_bUIActive)
		UIDeactivate();

	// hide the window

	if (pThis->m_bInPlaceSiteEx &&
		(pThis->GetControlFlags() & noFlickerActivate))
	{
		// flicker-free deactivation
		if (! pThis->m_bInPlaceSiteWndless)
		{
			pThis->UpdateWindow();
			pThis->OnHide();
		}
		pThis->m_pInPlaceSiteEx->OnInPlaceDeactivateEx(TRUE);
	}
	else
	{
		// old-style deactivation
		pThis->OnHide();
		pThis->m_pInPlaceSite->OnInPlaceDeactivate();
	}

	return S_OK;
}

STDMETHODIMP COleControl::XOleInPlaceObject::UIDeactivate()
{
	METHOD_PROLOGUE_EX(COleControl, OleInPlaceObject)

	pThis->m_bPendingUIActivation = FALSE;
	if (!pThis->m_bUIActive)
		return S_OK;

	pThis->DestroyTracker();
	pThis->m_bUIActive = FALSE;

	if (pThis->m_pInPlaceDoc != NULL)
		pThis->m_pInPlaceDoc->SetActiveObject(NULL, NULL);
	pThis->m_pInPlaceFrame->SetActiveObject(NULL, NULL);
	pThis->RemoveFrameLevelUI();
	pThis->DestroySharedMenu();

	pThis->m_pInPlaceSite->OnUIDeactivate(FALSE);

	return S_OK;
}

STDMETHODIMP COleControl::XOleInPlaceObject::SetObjectRects(LPCRECT lprcPosRect,
					LPCRECT lprcClipRect)
{
	METHOD_PROLOGUE_EX(COleControl, OleInPlaceObject)

	return pThis->OnSetObjectRects(lprcPosRect, lprcClipRect) ?
			S_OK :
			E_FAIL;
}

BOOL COleControl::OnSetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
	ASSERT(lprcPosRect != NULL);

	// Remember the position rectangle for later
	m_rcPos = *lprcPosRect;

	// Calculate complete rectangle including the tracker (if present)
	CRect rectPos = m_rcPos;
	if (m_bUIActive && m_pRectTracker != NULL)
	{
		// Save new clipping rectangle (for DestroyTracker)
		if (lprcClipRect != NULL)
			m_pRectTracker->m_rectClip = *lprcClipRect;

		// Adjust tracker rectangle to new dimensions
		CRect rectTmp = rectPos;
		rectTmp.OffsetRect(-rectTmp.left, -rectTmp.top);
		m_pRectTracker->m_rect = rectTmp;

		// Adjust the "true" rectangle to include handles/hatching
		UINT nHandleSize = m_pRectTracker->m_nHandleSize - 1;
		rectPos.InflateRect(nHandleSize, nHandleSize);
	}

	// Now clip that rectangle as appropriate
	CRect rectClip;
	_GetClippingCoordinates(rectPos, lprcClipRect, rectClip, &m_ptOffset);

    // Move outer window first. then inner window

    if (!m_bInPlaceSiteWndless)
    {
        CWnd* pWndOuter = GetOuterWindow();
        if (pWndOuter != NULL)
		{
			// Compute the clip rectangle in coordinates relative to the 
			// position rectangle
			CRect rectClipLocal(
				CPoint( rectClip.left-rectPos.left, rectClip.top-rectPos.top ),
				CSize( rectClip.Size() ) );
			// Clip the outer window to the clipping rectangle
			HRGN hRegion = ::CreateRectRgnIndirect(&rectClipLocal);
			pWndOuter->SetWindowRgn(hRegion, TRUE);

			CRect rectOuter;
			pWndOuter->GetWindowRect(&rectOuter);
			pWndOuter->GetParent()->ScreenToClient(&rectOuter);
			if (rectOuter != rectPos)
			{
				// The outer window's position rectangle has changed
				::MoveWindow(pWndOuter->m_hWnd, rectPos.left, rectPos.top, 
					rectPos.Width(), rectPos.Height(), TRUE );
			}
		}
        if (pWndOuter != this)
		{
			CRect rectInner;
			GetWindowRect(&rectInner);
			GetParent()->ScreenToClient(&rectInner);
			if (rectInner != CRect( CPoint( 0, 0 ), rectPos.Size() ))
			{
				// The inner window's position rectangle has changed
				MoveWindow(0, 0, rectPos.Width(), rectPos.Height());
			}
		}
    }

	return TRUE;
}

STDMETHODIMP COleControl::XOleInPlaceObject::ReactivateAndUndo()
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleInPlaceActiveObject

STDMETHODIMP_(ULONG) COleControl::XOleInPlaceActiveObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceActiveObject)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XOleInPlaceActiveObject::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceActiveObject)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceActiveObject)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceActiveObject)
	return pThis->m_xOleInPlaceObject.GetWindow(lphwnd);
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::TranslateAccelerator(
	LPMSG lpmsg)
{
	METHOD_PROLOGUE_EX(COleControl, OleInPlaceActiveObject)

	// Give the control the first chance.
	if (pThis->PreTranslateMessage(lpmsg))
		return S_OK;

	// Give the site a chance.
	HRESULT hr = S_FALSE;
	if (pThis->m_pControlSite != NULL)
		hr = pThis->m_pControlSite->TranslateAccelerator(lpmsg,
			(DWORD)_AfxShiftState());

	return hr;
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::OnFrameWindowActivate(BOOL)
{
	return S_OK;
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::OnDocWindowActivate(
	BOOL fActivate)
{
	METHOD_PROLOGUE_EX(COleControl, OleInPlaceActiveObject)

	if (fActivate && pThis->m_bUIActive)
		pThis->AddFrameLevelUI();
	else
		pThis->OnHideToolBars();

	return S_OK;
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL)
{
	return S_OK;
}

STDMETHODIMP COleControl::XOleInPlaceActiveObject::EnableModeless(BOOL)
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpbag.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CBlobProperty

class CBlobProperty : public IPersistStream
{
public:
	CBlobProperty(HGLOBAL pBlob = NULL);
	HGLOBAL GetBlob();

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(GetClassID)(LPCLSID);
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(LPSTREAM);
	STDMETHOD(Save)(LPSTREAM, BOOL);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER*);

protected:
	long m_dwRef;
	HGLOBAL m_hBlob;
};

CBlobProperty::CBlobProperty(HGLOBAL hBlob) :
	m_hBlob(hBlob),
	m_dwRef(1)
{
}

HGLOBAL CBlobProperty::GetBlob()
{
	return m_hBlob;
}

STDMETHODIMP_(ULONG) CBlobProperty::AddRef()
{
	return InterlockedIncrement(&m_dwRef);
}

STDMETHODIMP_(ULONG) CBlobProperty::Release()
{
	if (InterlockedDecrement(&m_dwRef) > 0)
		return m_dwRef;

	delete this;
	return 0;
}

STDMETHODIMP CBlobProperty::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IPersist) ||
		IsEqualIID(riid, IID_IPersistStream))
	{
		AddRef();
		*ppvObj = this;
		return S_OK;
	}

	*ppvObj = NULL;
	return E_NOINTERFACE;
}

AFX_STATIC_DATA const CLSID _afx_CLSID_BlobProperty =
{ 0xf6f07540, 0x42ec, 0x11ce, { 0x81, 0x35, 0x0, 0xaa, 0x0, 0x4b, 0xb8, 0x51 } };

STDMETHODIMP CBlobProperty::GetClassID(LPCLSID pClsid)
{
	ENSURE_ARG(pClsid != NULL);
	*pClsid = _afx_CLSID_BlobProperty;
	return S_OK;
}

STDMETHODIMP CBlobProperty::IsDirty()
{
	return S_OK;
}

STDMETHODIMP CBlobProperty::Load(LPSTREAM pStream)
{
	ENSURE_ARG(pStream != NULL);
	ULONG cb;
	ULONG cbRead;
	HRESULT hr = pStream->Read(&cb, sizeof(ULONG), &cbRead);

	if (FAILED(hr))
		return hr;

	if (sizeof(ULONG) != cbRead)
		return E_FAIL;

	HGLOBAL hBlobNew = GlobalAlloc(GMEM_MOVEABLE, sizeof(ULONG)+cb);
	if (hBlobNew == NULL)
		return E_OUTOFMEMORY;

	void* pBlobNew = GlobalLock(hBlobNew);
	*(ULONG*)pBlobNew = cb;
	hr = pStream->Read(((ULONG*)pBlobNew)+1, cb, &cbRead);
	GlobalUnlock(hBlobNew);

	if (FAILED(hr))
	{
		GlobalFree(hBlobNew);
		return hr;
	}
	if (cb != cbRead)
	{
		GlobalFree(hBlobNew);
		return E_FAIL;
	}

	GlobalFree(m_hBlob);
	m_hBlob = hBlobNew;
	return S_OK;
}

STDMETHODIMP CBlobProperty::Save(LPSTREAM pStream, BOOL)
{
	ENSURE_ARG(pStream != NULL);

	void* pBlob = GlobalLock(m_hBlob);
	if (pBlob == NULL)
		return E_OUTOFMEMORY;

	ULONG cb = ULONG(sizeof(ULONG)) + *(ULONG*)pBlob;
	ULONG cbWritten;
	HRESULT hr = pStream->Write(pBlob, cb, &cbWritten);

	GlobalUnlock(m_hBlob);

	if (FAILED(hr))
		return hr;

	if (cb != cbWritten)
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP CBlobProperty::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
	ENSURE_ARG(pcbSize != NULL);

	void* pBlob = GlobalLock(m_hBlob);
	if (pBlob == NULL)
		return E_OUTOFMEMORY;

	pcbSize->HighPart = 0;
	pcbSize->LowPart = ULONG(sizeof(ULONG)) + *(ULONG*)pBlob;

	GlobalUnlock(m_hBlob);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPropbagPropExchange

class CPropbagPropExchange : public CPropExchange
{
public:
	CPropbagPropExchange(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog,
		BOOL bLoading, BOOL bSaveAllProperties=FALSE);
	~CPropbagPropExchange();

// Operations
	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL);
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL);
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient);
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault);

// Implementation
	LPPROPERTYBAG m_pPropBag;
	LPERRORLOG m_pErrorLog;
	BOOL m_bSaveAllProperties;
};

CPropbagPropExchange::CPropbagPropExchange(LPPROPERTYBAG pPropBag,
	LPERRORLOG pErrorLog, BOOL bLoading, BOOL bSaveAllProperties) :
	m_pPropBag(pPropBag),
	m_pErrorLog(pErrorLog),
	m_bSaveAllProperties(bSaveAllProperties)
{
	m_bLoading = bLoading;
	if (pPropBag != NULL)
		pPropBag->AddRef();
	if (pErrorLog != NULL)
		pErrorLog->AddRef();
}

CPropbagPropExchange::~CPropbagPropExchange()
{
	RELEASE(m_pPropBag);
	RELEASE(m_pErrorLog);
}

BOOL CPropbagPropExchange::ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
	void* pvProp, const void* pvDefault)
{
	ASSERT_POINTER(m_pPropBag, IPropertyBag);
	ASSERT(AfxIsValidAddress(pvProp, 1, FALSE));
	ASSERT((pvDefault == NULL) || AfxIsValidAddress(pvDefault, 1, FALSE));

	if (m_pPropBag == NULL)
		return FALSE;

	ENSURE_ARG(AfxIsValidString(pszPropName));
	ENSURE_ARG(pvProp != NULL);

	BOOL bSuccess = TRUE;
	VARIANT var;
	AfxVariantInit(&var);
	V_VT(&var) = vtProp;

	if (vtProp == VT_LPSTR)
		V_VT(&var) = VT_BSTR;

	const CStringW strPropName(pszPropName);
	if (m_bLoading)
	{		
		if (FAILED(m_pPropBag->Read(strPropName.GetString(), &var, m_pErrorLog)))
			return _AfxCopyPropValue(vtProp, pvProp, pvDefault);

		switch (vtProp)
		{
		case VT_UI1:
			*(BYTE*)pvProp = V_UI1(&var);
			break;

		case VT_I2:
			*(short*)pvProp = V_I2(&var);
			break;

		case VT_I4:
			*(long*)pvProp = V_I4(&var);
			break;

		case VT_BOOL:
			*(BOOL*)pvProp = (BOOL)V_BOOL(&var);
			break;

		case VT_LPSTR:
		case VT_BSTR:
			*(CString*)pvProp = V_BSTR(&var);
			break;

		case VT_CY:
			*(CY*)pvProp = V_CY(&var);
			break;

		case VT_R4:
			Checked::memcpy_s(pvProp, sizeof(float), &V_R4(&var), sizeof(float));
			break;

		case VT_R8:
			Checked::memcpy_s(pvProp, sizeof(double), &V_R8(&var), sizeof(double));
			break;

		default:
			bSuccess = FALSE;
		}
	}
	else
	{
		if (m_bSaveAllProperties ||
			!_AfxIsSamePropValue(vtProp, pvProp, pvDefault))
		{
			switch (vtProp)
			{
			case VT_UI1:
				V_UI1(&var) = *(BYTE*)pvProp;
				break;

			case VT_I2:
				V_I2(&var) = *(short*)pvProp;
				break;

			case VT_I4:
				V_I4(&var) = *(long*)pvProp;
				break;

			case VT_BOOL:
				V_BOOL(&var) = (VARIANT_BOOL)*(BOOL*)pvProp;
				break;

			case VT_LPSTR:
			case VT_BSTR:
				V_BSTR(&var) = ((CString*)pvProp)->AllocSysString();
				break;

			case VT_CY:
				V_CY(&var) = *(CY*)pvProp;
				break;

			case VT_R4:
				Checked::memcpy_s(&V_R4(&var), sizeof(float), pvProp, sizeof(float));
				break;

			case VT_R8:
				Checked::memcpy_s(&V_R8(&var), sizeof(double), pvProp, sizeof(double));
				break;

			default:
				return FALSE;
			}
			bSuccess = SUCCEEDED(m_pPropBag->Write(strPropName.GetString(), &var));
		}
	}

	VariantClear(&var);
	return bSuccess;
}

BOOL CPropbagPropExchange::ExchangeBlobProp(LPCTSTR pszPropName,
	HGLOBAL* phBlob, HGLOBAL hBlobDefault)
{
	ASSERT_POINTER(m_pPropBag, IPropertyBag);
	ASSERT_POINTER(phBlob, HGLOBAL);

	if (m_pPropBag == NULL)
		return FALSE;

	ENSURE_ARG(AfxIsValidString(pszPropName));
	ENSURE_ARG(phBlob != NULL);

	BOOL bSuccess = FALSE;
	VARIANT var;
	AfxVariantInit(&var);
	V_VT(&var) = VT_UNKNOWN;

	const CStringW strPropName(pszPropName);
	if (m_bLoading)
	{
		if (*phBlob != NULL)
		{
			GlobalFree(*phBlob);
			*phBlob = NULL;
		}

		CBlobProperty* pBlobProp = new CBlobProperty;
		V_UNKNOWN(&var) = pBlobProp;

		if (SUCCEEDED(m_pPropBag->Read(strPropName.GetString(), &var, m_pErrorLog)))
		{
			*phBlob = pBlobProp->GetBlob();
			bSuccess = TRUE;
		}
		else
		{
			if (hBlobDefault != NULL)
				bSuccess = _AfxCopyBlob(phBlob, hBlobDefault);
		}

		pBlobProp->Release();
	}
	else
	{
		CBlobProperty* pBlobProp = new CBlobProperty(*phBlob);
		V_UNKNOWN(&var) = pBlobProp;
		bSuccess = SUCCEEDED(m_pPropBag->Write(strPropName.GetString(), &var));
		pBlobProp->Release();
	}
	return bSuccess;
}

BOOL CPropbagPropExchange::ExchangeFontProp(LPCTSTR pszPropName,
	CFontHolder& font, const FONTDESC* pFontDesc,
	LPFONTDISP pFontDispAmbient)
{
	ASSERT_POINTER(m_pPropBag, IPropertyBag);
	ASSERT_POINTER(&font, CFontHolder);
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IFontDisp);

	if (m_pPropBag == NULL)
		return FALSE;

	ENSURE_ARG(AfxIsValidString(pszPropName));

	BOOL bSuccess = FALSE;
	VARIANT var;
	AfxVariantInit(&var);
	V_VT(&var) = VT_UNKNOWN;

	
	const CStringW strPropName(pszPropName);
	if (m_bLoading)
	{
		LPFONT pFont = NULL;

		bSuccess =
			SUCCEEDED(m_pPropBag->Read(strPropName.GetString(), &var,
				m_pErrorLog)) &&
			SUCCEEDED(V_UNKNOWN(&var)->QueryInterface(IID_IFont,
				(LPVOID*)&pFont));

		if (bSuccess)
		{
			ASSERT_POINTER(pFont, IFont);
			font.SetFont(pFont);
		}
		else
		{
			// Initialize font to its default state
			font.InitializeFont(pFontDesc, pFontDispAmbient);
		}
		VariantClear(&var);
	}
	else
	{
		if ((font.m_pFont == NULL) ||
			(_AfxIsSameFont(font, pFontDesc, pFontDispAmbient) &&
				!m_bSaveAllProperties))
		{
			bSuccess = TRUE;
		}
		else
		{
			V_UNKNOWN(&var) = font.m_pFont;
			bSuccess = SUCCEEDED(m_pPropBag->Write(strPropName.GetString(), &var));
		}
	}

	return bSuccess;
}

BOOL CPropbagPropExchange::ExchangePersistentProp(LPCTSTR pszPropName,
	LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault)
{
	ASSERT_POINTER(m_pPropBag, IPropertyBag);
	ASSERT_POINTER(ppUnk, LPUNKNOWN);
	ASSERT_NULL_OR_POINTER(pUnkDefault, IUnknown);

	if (m_pPropBag == NULL)
		return FALSE;

	ENSURE_ARG(AfxIsValidString(pszPropName));
	ENSURE_ARG(ppUnk != NULL);

	BOOL bSuccess = FALSE;
	VARIANT var;
	AfxVariantInit(&var);
	V_VT(&var) = VT_UNKNOWN;
	
	const CStringW strPropName(pszPropName);
	if (m_bLoading)
	{
		RELEASE(*ppUnk);
		*ppUnk = NULL;

		bSuccess =
			SUCCEEDED(m_pPropBag->Read(strPropName.GetString(), &var,
				m_pErrorLog)) &&
			SUCCEEDED(V_UNKNOWN(&var)->QueryInterface(iid, (LPVOID*)ppUnk));

		if (!bSuccess)
		{
			// Use default value.
			if (pUnkDefault != NULL)
			{
				bSuccess = SUCCEEDED(pUnkDefault->QueryInterface(iid,
					(LPVOID*)ppUnk));
			}
			else
			{
				bSuccess = TRUE;
			}
		}
		VariantClear(&var);
	}
	else
	{
		if ((*ppUnk == NULL) ||
			(_AfxIsSameUnknownObject(iid, *ppUnk, pUnkDefault) &&
				!m_bSaveAllProperties))
		{
			bSuccess = TRUE;
		}
		else
		{
			V_UNKNOWN(&var) = *ppUnk;
			bSuccess = SUCCEEDED(m_pPropBag->Write(strPropName.GetString(), &var));
		}
	}

	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPersistPropertyBag

STDMETHODIMP_(ULONG) COleControl::XPersistPropertyBag::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistPropertyBag)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPersistPropertyBag::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistPropertyBag)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPersistPropertyBag::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistPropertyBag)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPersistPropertyBag::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistPropertyBag)
	return pThis->GetClassID(lpClassID);
}

STDMETHODIMP COleControl::XPersistPropertyBag::InitNew()
{
	METHOD_PROLOGUE_EX(COleControl, PersistPropertyBag)

	// Delegate to OnResetState.
	pThis->OnResetState();

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	if (_afxAmbientCache)
	{
		_afxAmbientCache->Cache(NULL);
	}

	return S_OK;
}

STDMETHODIMP COleControl::XPersistPropertyBag::Load(LPPROPERTYBAG pPropBag,
	LPERRORLOG pErrorLog)
{
	METHOD_PROLOGUE_EX(COleControl, PersistPropertyBag)

	HRESULT hr;

	TRY
	{
		CPropbagPropExchange px(pPropBag, pErrorLog, TRUE);
		pThis->DoPropExchange(&px);
		hr = S_OK;
	}
	CATCH_ALL(e)
	{
		hr = E_FAIL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// Properties have probably changed
	pThis->BoundPropertyChanged(DISPID_UNKNOWN);
	pThis->InvalidateControl();

	// Clear the modified flag.
	pThis->m_bModified = FALSE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return hr;
}

STDMETHODIMP COleControl::XPersistPropertyBag::Save(LPPROPERTYBAG pPropBag,
	BOOL fClearDirty, BOOL fSaveAllProperties)
{
	METHOD_PROLOGUE_EX(COleControl, PersistPropertyBag)

	HRESULT hr;

	TRY
	{
		CPropbagPropExchange px(pPropBag, NULL, FALSE, fSaveAllProperties);
		pThis->DoPropExchange(&px);
		hr = S_OK;
	}
	CATCH_ALL(e)
	{
		hr = E_FAIL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// Bookkeeping:  Clear the dirty flag, if requested.
	if (fClearDirty)
		pThis->m_bModified = FALSE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpict.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

CPictureHolder::CPictureHolder() :
	m_pPict(NULL)
{
}

CPictureHolder::~CPictureHolder()
{
	RELEASE(m_pPict);
}

BOOL CPictureHolder::CreateEmpty()
{
	RELEASE(m_pPict);
	PICTDESC pdesc;
	pdesc.cbSizeofstruct = sizeof(pdesc);
	pdesc.picType = PICTYPE_NONE;
	return SUCCEEDED(::OleCreatePictureIndirect(&pdesc, IID_IPicture, FALSE,
		(LPVOID*)&m_pPict));
}

BOOL CPictureHolder::CreateFromBitmap(UINT idResource)
{
	CBitmap bmp;
	bmp.LoadBitmap(idResource);
	return CreateFromBitmap((HBITMAP)bmp.Detach(), NULL, TRUE);
}

BOOL CPictureHolder::CreateFromBitmap(CBitmap* pBitmap, CPalette* pPal,
	BOOL bTransferOwnership)
{
	HBITMAP hbm = (HBITMAP)(pBitmap->GetSafeHandle());
	HPALETTE hpal = (HPALETTE)(pPal->GetSafeHandle());

	if (bTransferOwnership)
	{
		if (pBitmap != NULL)
			pBitmap->Detach();

		if (pPal != NULL)
			pPal->Detach();
	}

	return CreateFromBitmap(hbm, hpal, bTransferOwnership);
}

BOOL CPictureHolder::CreateFromBitmap(HBITMAP hbm, HPALETTE hpal,
	BOOL bTransferOwnership)
{
	RELEASE(m_pPict);
	PICTDESC pdesc;
	pdesc.cbSizeofstruct = sizeof(pdesc);
	pdesc.picType = PICTYPE_BITMAP;
	pdesc.bmp.hbitmap = hbm;
	pdesc.bmp.hpal = hpal;
	return SUCCEEDED(::OleCreatePictureIndirect(&pdesc, IID_IPicture,
		bTransferOwnership, (LPVOID*)&m_pPict));
}

BOOL CPictureHolder::CreateFromMetafile(HMETAFILE hmf, int xExt,
	int yExt, BOOL bTransferOwnership)
{
	RELEASE(m_pPict);
	PICTDESC pdesc;
	pdesc.cbSizeofstruct = sizeof(pdesc);
	pdesc.picType = PICTYPE_METAFILE;
	pdesc.wmf.hmeta = hmf;
	pdesc.wmf.xExt = xExt;
	pdesc.wmf.yExt = yExt;
	return SUCCEEDED(::OleCreatePictureIndirect(&pdesc, IID_IPicture,
		bTransferOwnership, (LPVOID*)&m_pPict));
}

BOOL CPictureHolder::CreateFromIcon(UINT idResource)
{
	HICON hIcon = AfxGetApp()->LoadIcon(idResource);
	return CreateFromIcon(hIcon, TRUE);
}

BOOL CPictureHolder::CreateFromIcon(HICON hicon, BOOL bTransferOwnership)
{
	RELEASE(m_pPict);
	PICTDESC pdesc;
	pdesc.cbSizeofstruct = sizeof(pdesc);
	pdesc.picType = PICTYPE_ICON;
	pdesc.icon.hicon = hicon;
	return SUCCEEDED(::OleCreatePictureIndirect(&pdesc, IID_IPicture,
		bTransferOwnership, (LPVOID*)&m_pPict));
}

LPPICTUREDISP CPictureHolder::GetPictureDispatch()
{
	LPPICTUREDISP pPictDisp = NULL;

	if ((m_pPict != NULL) &&
		SUCCEEDED(m_pPict->QueryInterface(IID_IPictureDisp, (LPVOID*)&pPictDisp)))
	{
		ASSERT(pPictDisp != NULL);
	}

	return pPictDisp;
}

void CPictureHolder::SetPictureDispatch(LPPICTUREDISP pDisp)
{
	LPPICTURE pPict = NULL;

	if (m_pPict != NULL)
		m_pPict->Release();

	if ((pDisp != NULL) &&
		SUCCEEDED(pDisp->QueryInterface(IID_IPicture, (LPVOID*)&pPict)))
	{
		ASSERT(pPict != NULL);

		m_pPict = pPict;
	}
	else
	{
		m_pPict = NULL;
	}
}

void CPictureHolder::Render(CDC* pDC, const CRect& rcRender,
	const CRect& rcWBounds)
{
	if (m_pPict != NULL)
	{
		long hmWidth;
		long hmHeight;

		m_pPict->get_Width(&hmWidth);
		m_pPict->get_Height(&hmHeight);

		m_pPict->Render(pDC->m_hDC, rcRender.left, rcRender.top,
			rcRender.Width(), rcRender.Height(), 0, hmHeight-1,
			hmWidth, -hmHeight, (LPCRECT)rcWBounds);
	}
}

short CPictureHolder::GetType()
{
	short sPicType = (short)PICTYPE_UNINITIALIZED;

	if (m_pPict != NULL)
	{
		m_pPict->get_Type(&sPicType);
	}

	return sPicType;
}

BOOL CPictureHolder::GetDisplayString(CString& strValue)
{
	short sPicType = GetType();

	UINT idsType = AFX_IDS_PICTYPE_UNKNOWN;

	if ((sPicType >= PICTYPE_NONE) && (sPicType <= PICTYPE_ICON))
		idsType = AFX_IDS_PICTYPE_NONE + sPicType;

	CString strType;
	CString strFormat;
	strType.LoadString(idsType);
	strFormat.LoadString(AFX_IDS_DISPLAYSTRING_PICTURE);

	TCHAR szValue[_MAX_PATH];
	if (-1 == _stprintf_s(szValue, _countof(szValue), (LPCTSTR)strFormat, (LPCTSTR)strType))
		return FALSE;

	strValue = szValue;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlppg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#define AFX_MAX_CLASS_NAME  100

struct NotifyInfo
{
	LPCTSTR     szClassName;        // Name of control's class
	WORD        wNotifyCode;        // Notification code
};

#define MAX_TEXT    1024

BEGIN_INTERFACE_MAP(COlePropertyPage, CDialog)
	INTERFACE_PART(COlePropertyPage, IID_IPropertyPage2, PropertyPage)
	INTERFACE_PART(COlePropertyPage, IID_IPropertyPage, PropertyPage)
END_INTERFACE_MAP()

BEGIN_MESSAGE_MAP(COlePropertyPage, CDialog)
	//{{AFX_MSG_MAP(COlePropertyPage)
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// AFX_DDPDATA

struct AFX_DDPDATA : public CObject
{
	AFX_DDPDATA(LPVOID lpHandler, int nCtrlId, BOOL bEditCtrl, LPVOID lpMember,
		UINT nType, LPCTSTR lpszOleName);

	LPVOID  m_lpHandler;
	int     m_nCtrlId;
	BOOL    m_bEditCtrl;
	LPVOID  m_lpMember;
	UINT    m_nType;
	LPCTSTR m_lpszOleName;
};

AFX_DDPDATA::AFX_DDPDATA(LPVOID lpHandler, int nCtrlId, BOOL bEditCtrl,
	LPVOID lpMember, UINT nType, LPCTSTR lpszOleName) :
	m_lpHandler(lpHandler),
	m_nCtrlId(nCtrlId),
	m_bEditCtrl(bEditCtrl),
	m_lpMember(lpMember),
	m_nType(nType),
	m_lpszOleName(lpszOleName)
{
}

/////////////////////////////////////////////////////////////////////////////
// cleanup helper function

AFX_STATIC void AFXAPI _AfxCleanupDDPs(CPtrArray& arrayDDP)
{
	INT_PTR cDDP = arrayDDP.GetSize();
	for (INT_PTR i = 0; i < cDDP; i++)
	{
		ASSERT(arrayDDP[i] != NULL);
		delete (AFX_DDPDATA*)(arrayDDP[i]);
	}
	arrayDDP.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// page validation helper function (debug only)

#ifdef _DEBUG
static struct
{
    LPCTSTR lpszFontName;
    DWORD   dwFontSize;
} _afxStandardFonts[] =
{
    // 8pt fonts
    { _T("MS Sans Serif"), 8},
    { _T("Helv"), 8},
    { _T("MS Shell Dlg"), 8},
    // 9pt fonts
    { _T("MS Shell Dlg"), 9},       // Simplified, traditional Chinese and Korean
    { _T("MS UI Gothic"), 9},       // Japanese
    { _T("Segoe UI"), 9},
    { _T("Microsoft YaHei"), 9},    // Simplified Chinese
    { _T("Microsoft JhengHei"), 9}, // Traditional Chinese
    { _T("Meiryo"), 9},             // Japanese
    { _T("Malgun Gothic"), 9},      // Korean
    { _T("Majalla UI"), 9},         // Arabic
    { _T("Gisha"), 9},              // Hebrew
    { _T("Leelawadee"), 9}          // Thai
};

void _ValidatePageDialog(CDialogTemplate& dt, CString& strPage,
	COlePropertyPage* pPage)
{
	if (GetSystemMetrics(SM_DBCSENABLED))
		return;

	// Only display the message boxes the first time a page is shown.
#ifdef _DEBUG
	BOOL bEnable = AfxEnableMemoryTracking(FALSE);
#endif
	static CPtrList _classList;
	BOOL bMessageBox = FALSE;
	CRuntimeClass* pClass = pPage->GetRuntimeClass();
	if (_classList.Find(pClass) == NULL)
	{
		bMessageBox = TRUE;
		_classList.AddHead(pClass);
	}
#ifdef _DEBUG
	AfxEnableMemoryTracking(bEnable);
#endif

	SIZE sizeDLU;
	CString strFontName;
	WORD wFontSize;
	LPTSTR pszTmp;

	dt.GetSizeInDialogUnits(&sizeDLU);
	dt.GetFont(strFontName, wFontSize);

	if ((sizeDLU.cx != 250) || ((sizeDLU.cy != 62) && (sizeDLU.cy != 110)))
	{
		int nLen = strPage.GetLength() + 128;
		pszTmp = new TCHAR[nLen];

		_stprintf_s(pszTmp, nLen, _T("Property page '%s' has nonstandard dimensions."),
			(LPCTSTR)strPage);

		TRACE(traceAppMsg, 0, _T("Warning: %s\n"), pszTmp);

		if (bMessageBox)
		{
			Checked::tcscat_s(pszTmp, nLen,
				_T(" Dimensions should be 250x62 or 250x110 dialog units."));
			pPage->MessageBox(pszTmp, _T("Property page warning"),
				MB_ICONEXCLAMATION);
		}

		delete [] pszTmp;
	}

	BOOL bIsStandardFont = FALSE;
	for (int i = 0; i < _countof(_afxStandardFonts); i++)
		if (_afxStandardFonts[i].dwFontSize == wFontSize &&
			_afxStandardFonts[i].lpszFontName == strFontName)
			bIsStandardFont = TRUE;

	if (!bIsStandardFont)
	{
		int nLen = strPage.GetLength() + 128;
		pszTmp = new TCHAR[nLen];

		_stprintf_s(pszTmp, nLen, _T("Property page '%s' uses a nonstandard font."),
			(LPCTSTR)strPage);

		TRACE(traceAppMsg, 0, _T("Warning: %s\n"), pszTmp);

		if (bMessageBox)
		{
			CString strText(_T("Font name and its size should be one of the following combinations:\r\n"));
			for (int i = 0; i < _countof(_afxStandardFonts); i++)
				strText.AppendFormat(_T("%s %dpt\r\n"), _afxStandardFonts[i].lpszFontName, _afxStandardFonts[i].dwFontSize);
			pPage->MessageBox(strText, _T("Property page warning"),
				MB_ICONEXCLAMATION);
		}

		delete [] pszTmp;
	}
}
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// COlePropertyPage::COlePropertyPage

COlePropertyPage::COlePropertyPage(UINT idDlg, UINT idCaption) :
#ifdef _DEBUG
	m_bNonStandardSize(FALSE),
#endif
	m_bDirty(FALSE),
	m_idCaption(idCaption),
	m_idDlg(idDlg),
	m_pPageSite(NULL),
	m_ppDisp(NULL),
	m_pAdvisors(NULL),
	m_bPropsChanged(FALSE),
	m_nObjects(0),
	m_bInitializing(TRUE),
	m_nControls(0),
	m_pStatus(NULL),
	m_hDialog(NULL),
	m_dwHelpContext(0)
{
	// m_lpDialogTemplate is needed later by CWnd::ExecuteDlgInit
	m_lpszTemplateName = MAKEINTRESOURCE(m_idDlg);

	// Keep this DLL loaded at least until this object is deleted.
	AfxOleLockApp();
}

void COlePropertyPage::OnSetPageSite()
{
	// Load the caption from resources
	CString strCaption;
	if (!strCaption.LoadString(m_idCaption))
		strCaption.LoadString(AFX_IDS_PROPPAGE_UNKNOWN);
	SetPageName(strCaption);

	// Try to load the dialog resource template into memory and get its size
	m_sizePage.cx = 0;
	m_sizePage.cy = 0;

	CDialogTemplate dt;
	BOOL bLoaded=dt.Load(MAKEINTRESOURCE(m_idDlg));
	if(!bLoaded)
	{
		AfxThrowMemoryException();
	}

#ifdef _DEBUG
	if (!m_bNonStandardSize)
		_ValidatePageDialog(dt, strCaption, this);
#endif

	// If no font specified, set the system font.
	BOOL bSetSysFont = !dt.HasFont();
	CString strFace;
	WORD wSize;

	// On DBCS systems, also change "MS Sans Serif" or "Helv" to system font.
	if ((!bSetSysFont) && GetSystemMetrics(SM_DBCSENABLED))
	{
		CString strFace;
		dt.GetFont(strFace, wSize);
		bSetSysFont = (strFace == _T("MS Shell Dlg") ||
			strFace == _T("MS Sans Serif") || strFace == _T("Helv"));
	}

	// Here is where we actually set the font.
	if (bSetSysFont && AfxGetPropSheetFont(strFace, wSize, FALSE))
		dt.SetFont(strFace, wSize);

	dt.GetSizeInPixels(&m_sizePage);
	m_hDialog = dt.Detach();
}

BOOL COlePropertyPage::OnInitDialog()
{
	CDialog::OnInitDialog();
	return 0;
}

BOOL COlePropertyPage::PreTranslateMessage(LPMSG lpMsg)
{
	ENSURE_ARG(lpMsg != NULL);
	// Don't let CDialog process the Return key or Escape key.
	if ((lpMsg->message == WM_KEYDOWN) &&
		((lpMsg->wParam == VK_RETURN) || (lpMsg->wParam == VK_ESCAPE)))
	{
		// Special case: if control with focus is an edit control with
		// ES_WANTRETURN style, let it handle the Return key.

		TCHAR szClass[10];
		CWnd* pWndFocus = GetFocus();
		if ((lpMsg->wParam == VK_RETURN) &&
			((pWndFocus = GetFocus()) != NULL) &&
			IsChild(pWndFocus) &&
			(pWndFocus->GetStyle() & ES_WANTRETURN) &&
			GetClassName(pWndFocus->m_hWnd, szClass, 10) &&
			(::AfxInvariantStrICmp(szClass, _T("EDIT")) == 0))
		{
			pWndFocus->SendMessage(WM_CHAR, lpMsg->wParam, lpMsg->lParam);
			return TRUE;
		}

		return FALSE;
	}

	// If it's a WM_SYSKEYDOWN, temporarily replace the hwnd in the
	// message with the hwnd of our first control, and try to handle
	// the message for ourselves.

	BOOL bHandled;

	if ((lpMsg->message == WM_SYSKEYDOWN) && !::IsChild(m_hWnd, lpMsg->hwnd))
	{
		HWND hWndSave = lpMsg->hwnd;
		lpMsg->hwnd = ::GetWindow(m_hWnd, GW_CHILD);
		bHandled = CDialog::PreTranslateMessage(lpMsg);
		lpMsg->hwnd = hWndSave;
	}
	else
	{
		bHandled = CDialog::PreTranslateMessage(lpMsg);
	}

	return bHandled;
}

void COlePropertyPage::CleanupObjectArray()
{
	if (m_pAdvisors)
	{
		for (ULONG nObject = 0; nObject < m_nObjects; nObject++)
			AfxConnectionUnadvise(m_ppDisp[nObject], IID_IPropertyNotifySink,
				&m_xPropNotifySink, FALSE, m_pAdvisors[nObject]);
		delete [] m_pAdvisors;
		m_pAdvisors = NULL;
	}
	if (m_ppDisp)
	{
		for (ULONG nObject = 0; nObject < m_nObjects; nObject++)
			RELEASE(m_ppDisp[nObject]);
		delete [] m_ppDisp;
		m_ppDisp = NULL;
	}
}

COlePropertyPage::~COlePropertyPage()
{
	// Remember to free the resource we loaded!
	if (m_hDialog != NULL)
		GlobalFree(m_hDialog);

	if (m_pStatus != NULL)
	{
		delete [] m_pStatus;
		m_pStatus = NULL;
	}

	// Clean out any leftovers in the DDP map.
	_AfxCleanupDDPs(m_arrayDDP);

	RELEASE(m_pPageSite);
	CleanupObjectArray();
	AfxOleUnlockApp();
}

void COlePropertyPage::OnFinalRelease()
{
	if (m_hWnd != NULL)
		DestroyWindow();

	delete this;
}

LRESULT COlePropertyPage::WindowProc(UINT msg, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(m_pModuleState);

	// Forward WM_SYSCOMMAND messages to the frame for translation
	if (msg == WM_SYSCOMMAND && (wParam & 0xFFF0) != SC_KEYMENU && m_pPageSite != NULL)
	{
		if (m_pPageSite->TranslateAccelerator((LPMSG)GetCurrentMessage())
			== S_OK)
		{
			return 0;
		}
	}

	return CDialog::WindowProc(msg, wParam, lParam);
}

HBRUSH COlePropertyPage::OnCtlColor(CDC*, CWnd* pWnd, UINT)
{
	ENSURE_ARG(pWnd != NULL);

	// allow the control itself first crack at the color
	LRESULT lResult;
	if (pWnd->SendChildNotifyLastMsg(&lResult))
		return (HBRUSH)lResult;

	// allow the parent window to determine the color
	HWND hParent = ::GetParent(m_hWnd);
	const MSG* pMsg = GetCurrentMessage();
	HBRUSH hResult = (HBRUSH)::SendMessage(hParent,
		pMsg->message, pMsg->wParam, pMsg->lParam);

	// use default if parent returns NULL
	if (hResult == NULL)
		hResult = (HBRUSH)Default();
	return hResult;
}

BOOL COlePropertyPage::OnHelp(LPCTSTR)
{
	// May be overridden by subclass.
	return FALSE;
}

BOOL COlePropertyPage::OnEditProperty(DISPID)
{
	// May be overridden by subclass.
	return FALSE;
}

void COlePropertyPage::OnObjectsChanged()
{
	// May be overridden by subclass.
}

LPDISPATCH* COlePropertyPage::GetObjectArray(ULONG* pnObjects)
{
	ASSERT_POINTER(pnObjects, ULONG);

	if (pnObjects != NULL)
		*pnObjects = m_nObjects;

	return m_ppDisp;
}

void COlePropertyPage::SetModifiedFlag(BOOL bModified)
{
	if (!bModified)
		m_bPropsChanged = FALSE;

	if ((m_bDirty && !bModified) || (!m_bDirty && bModified))
	{
		m_bDirty = bModified;

		if (m_pPageSite != NULL)
		{
			DWORD flags = 0;
			if (bModified)
				flags |= PROPPAGESTATUS_DIRTY;

			m_pPageSite->OnStatusChange(flags);
		}
	}
}

BOOL COlePropertyPage::IsModified()
{
	return m_bDirty;
}

void COlePropertyPage::SetPageName(LPCTSTR lpszPageName)
{
	ASSERT(AfxIsValidString(lpszPageName));
	m_strPageName = lpszPageName;
}

void COlePropertyPage::SetDialogResource(HGLOBAL hDialog)
{
	if (m_hDialog != NULL)
	{
		GlobalFree(m_hDialog);
		m_hDialog = NULL;
	}

	CDialogTemplate dt(hDialog);

#ifdef _DEBUG
	_ValidatePageDialog(dt, m_strPageName, this);
#endif

	dt.GetSizeInPixels(&m_sizePage);
	m_hDialog = dt.Detach();
}

void COlePropertyPage::SetHelpInfo(LPCTSTR lpszDocString,
	LPCTSTR lpszHelpFile, DWORD dwHelpContext)
{
	ASSERT((lpszDocString == NULL) || AfxIsValidString(lpszDocString));
	ASSERT((lpszHelpFile == NULL) || AfxIsValidString(lpszHelpFile));

	m_strDocString = lpszDocString;
	m_strHelpFile = lpszHelpFile;
	m_dwHelpContext = dwHelpContext;
}

LPPROPERTYPAGESITE COlePropertyPage::GetPageSite()
{
	return m_pPageSite;
}

int COlePropertyPage::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption,
	UINT nType)
{
	// use caption of page by default
	if (lpszCaption == NULL)
		lpszCaption = m_strPageName;

	// start message box on safe owner of the page
	return ::AfxCtxMessageBox(GetSafeOwner_(m_hWnd, NULL), lpszText, lpszCaption, nType);
}

/////////////////////////////////////////////////////////////////////////////
// COlePropertyPage::XPropertyPage

STDMETHODIMP_(ULONG) COlePropertyPage::XPropertyPage::AddRef()
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COlePropertyPage::XPropertyPage::Release()
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COlePropertyPage::XPropertyPage::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COlePropertyPage::XPropertyPage::SetPageSite(
	LPPROPERTYPAGESITE pPageSite)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);
	ASSERT_NULL_OR_POINTER(pPageSite, IPropertyPageSite);

	RELEASE(pThis->m_pPageSite);            // release the old one

	pThis->m_pPageSite = pPageSite;
	if (pPageSite != NULL)
	{
		pThis->m_pPageSite->AddRef();       // Bump the reference count
		pThis->OnSetPageSite();
	}
	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Activate(HWND hWndParent,
	LPCRECT pRect, BOOL)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);
	ASSERT_NULL_OR_POINTER(pRect, RECT);

	BOOL bSuccess = FALSE;  // Did we successfully create the dialog box

	if (pThis->m_hDialog != NULL)
	{
		// We've already loaded the dialog template into memory so just
		// create it!

		void* lpDialogTemplate = LockResource(pThis->m_hDialog);
		if (lpDialogTemplate != NULL)
		{
			bSuccess = pThis->CreateIndirect(lpDialogTemplate, CWnd::FromHandle(hWndParent));
			UnlockResource(pThis->m_hDialog);
		}
		else
			bSuccess = pThis->Create(pThis->m_idDlg, CWnd::FromHandle(hWndParent));
	}
	else
		bSuccess = pThis->Create(pThis->m_idDlg, CWnd::FromHandle(hWndParent));

	// Were we successful in creating the dialog box!
	if (bSuccess)
	{
		pThis->MoveWindow(pRect);       // Force page to fill area given by frame *
		pThis->m_bInitializing = TRUE;
		pThis->UpdateData(FALSE);
		pThis->SetModifiedFlag(FALSE);
		pThis->m_bInitializing = FALSE;

		if (pThis->m_pStatus != NULL)
		{
			delete [] pThis->m_pStatus;
			pThis->m_pStatus = NULL;
		}

		pThis->m_nControls = 0;
		::EnumChildWindows(pThis->GetSafeHwnd(), (WNDENUMPROC) COlePropertyPage::EnumChildProc, (LPARAM) pThis);

		if (pThis->m_nControls > 0)
			pThis->m_pStatus = new AFX_PPFIELDSTATUS [UINT(pThis->m_nControls)];

		pThis->m_nControls = 0;
		EnumChildWindows(pThis->GetSafeHwnd(), (WNDENUMPROC) COlePropertyPage::EnumControls, (LPARAM) pThis);

		return S_OK;
	}

	return E_FAIL;
}

BOOL CALLBACK COlePropertyPage::EnumChildProc(HWND, LPARAM lParam)
{
	COlePropertyPage* pDlg = (COlePropertyPage*) lParam;
	ENSURE_ARG(pDlg != NULL);
	ASSERT_POINTER(pDlg, COlePropertyPage);

	pDlg->m_nControls++;
	return TRUE;
}

BOOL CALLBACK COlePropertyPage::EnumControls(HWND hWnd, LPARAM lParam)
{
	COlePropertyPage* pDlg = (COlePropertyPage*) lParam;
	ASSERT_POINTER(pDlg, COlePropertyPage);
	ASSERT(pDlg->m_pStatus != NULL);

	pDlg->m_pStatus[pDlg->m_nControls].nID = (UINT)::GetDlgCtrlID(hWnd);
	pDlg->m_pStatus[pDlg->m_nControls].bDirty = FALSE;
	pDlg->m_nControls++;

	return TRUE;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Deactivate()
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	pThis->DestroyWindow();

	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::GetPageInfo(
	LPPROPPAGEINFO pPageInfo)
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)
	ENSURE_ARG(pPageInfo != NULL);
	ASSERT_POINTER(pPageInfo, PROPPAGEINFO);

	pPageInfo->pszTitle = AtlAllocTaskOleString(pThis->m_strPageName);
	pPageInfo->size = pThis->m_sizePage;
	pPageInfo->pszDocString = AtlAllocTaskOleString(pThis->m_strDocString);
	pPageInfo->pszHelpFile = AtlAllocTaskOleString(pThis->m_strHelpFile);
	pPageInfo->dwHelpContext = pThis->m_dwHelpContext;
	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::SetObjects(
		ULONG cObjects, LPUNKNOWN* ppUnk)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);

	pThis->CleanupObjectArray();

	if (cObjects != 0)
	{
		ASSERT(AfxIsValidAddress(ppUnk, sizeof(LPUNKNOWN) * (int)cObjects, FALSE));

		pThis->m_ppDisp = new LPDISPATCH [(UINT)cObjects];
		pThis->m_pAdvisors = new DWORD [(UINT)cObjects];
		for (ULONG nObject = 0; nObject < cObjects; nObject++)
		{
			HRESULT hr = ppUnk[nObject]->QueryInterface(IID_IDispatch,
				(VOID**)&(pThis->m_ppDisp[nObject]));
			if (SUCCEEDED(hr))
			{
				AfxConnectionAdvise(ppUnk[nObject], IID_IPropertyNotifySink,
					&pThis->m_xPropNotifySink, FALSE,
					&pThis->m_pAdvisors[nObject]);
			}
			else
			{
				return hr;
			}
		}
	}

	pThis->m_nObjects = cObjects;

	// No painting during the data update.
	BOOL bLock = (pThis->m_hWnd != NULL) && pThis->IsWindowVisible();
	if (bLock)
		::LockWindowUpdate(pThis->m_hWnd);

	pThis->OnObjectsChanged();

	// If window exists, update the data in its fields.
	if (cObjects != 0 && pThis->m_hWnd != NULL)
	{
		pThis->UpdateData(FALSE);
		pThis->SetModifiedFlag(FALSE);
	}

	if (bLock)
		::LockWindowUpdate(NULL);

	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Show(UINT nCmdShow)
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)

	pThis->ShowWindow(nCmdShow);
	if (nCmdShow == SW_SHOWNORMAL)
		pThis->SetFocus();
	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Move(LPCRECT pRect)
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)
	ASSERT_POINTER(pRect, RECT);

	pThis->MoveWindow(pRect);
	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::IsPageDirty()
{
	METHOD_PROLOGUE_EX_(COlePropertyPage, PropertyPage)

	return pThis->m_bDirty ? S_OK : S_FALSE;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Apply()
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);

	HRESULT hr = S_OK;
	BOOL bClean = FALSE;

	if (pThis->m_bDirty)
	{
		if (pThis->UpdateData(TRUE))
		{
			pThis->m_bDirty = FALSE;
			bClean = TRUE;
		}
		else
			hr = E_FAIL;

		if (pThis->m_bPropsChanged)
		{
			pThis->UpdateData(FALSE);
			pThis->m_bPropsChanged = FALSE;
			bClean = TRUE;
		}

		if (bClean)
		{
			// Set the dirty status of all the controls on this page to FALSE.
			if (pThis->m_pStatus != NULL)
			{
				for (int nControl = 0; nControl < pThis->m_nControls; nControl++)
					pThis->m_pStatus[nControl].bDirty = FALSE;
			}
		}
	}
	else
		ASSERT(!pThis->m_bPropsChanged);

	return hr;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::Help(LPCOLESTR lpszHelpDir)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);
	ASSERT((lpszHelpDir == NULL) || AfxIsValidString(lpszHelpDir));

	const CString strHelpDir(lpszHelpDir);

	if (!pThis->OnHelp(lpszHelpDir ? strHelpDir.GetString(): NULL))
		return S_FALSE;
	else
		return S_OK;
}

BOOL AFXAPI _AfxAtEndOfTabList(CDialog* pDlg, UINT nCmd)
{
	if ((pDlg->SendMessage(WM_GETDLGCODE) &
		(DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
	{
		CWnd* pCtl = CWnd::GetFocus();
		if (pDlg->IsChild(pCtl))
		{
			// Get top level child for controls with children, like combo.
			while (pCtl->GetParent() != pDlg)
			{
				pCtl = pCtl->GetParent();
				ASSERT_VALID(pCtl);
			}

			do
			{
				if ((pCtl = pCtl->GetWindow(nCmd)) == NULL)
					return TRUE;
			}
			while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
		}
	}

	return FALSE;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::TranslateAccelerator(LPMSG lpMsg)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);
	ASSERT_POINTER(lpMsg, MSG);

	BOOL bHandled = FALSE;

	if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB &&
		GetKeyState(VK_CONTROL) >= 0)
	{
		if (pThis->IsChild(CWnd::GetFocus()))
		{
			// We already have the focus.  Let's determine whether we should
			// pass focus up to the frame.

			if (_AfxAtEndOfTabList(pThis, GetKeyState(VK_SHIFT) < 0 ?
				GW_HWNDPREV : GW_HWNDNEXT))
			{
				// fix for default button border
				DWORD dwDefID = pThis->GetDefID();
				if (HIWORD(dwDefID) == DC_HASDEFID)
				{
					CWnd *pDefBtn = pThis->GetDlgItem(LOWORD(dwDefID));
					if (pDefBtn != NULL && pDefBtn->IsWindowEnabled())
						pThis->GotoDlgCtrl(pDefBtn);
				}

				// Pass focus to the frame by letting the page site handle
				// this message.
				if (pThis->m_pPageSite != NULL)
					bHandled =
						pThis->m_pPageSite->TranslateAccelerator(lpMsg) ==
						S_OK;
			}
		}
		else
		{
			// We don't already have the focus.  The frame is passing the
			// focus to us.

			CWnd* pWnd = pThis->GetTopWindow();
			if (pWnd != NULL)
			{
				UINT gwInit;
				UINT gwMove;

				if (GetKeyState(VK_SHIFT) >= 0)
				{
					// Set the focus to the first tabstop in the page.
					gwInit = GW_HWNDFIRST;
					gwMove = GW_HWNDNEXT;
				}
				else
				{
					// Set the focus to the last tabstop in the page.
					gwInit = GW_HWNDLAST;
					gwMove = GW_HWNDPREV;
				}

				pWnd = pWnd->GetWindow(gwInit);
				while (pWnd != NULL)
				{
					if ((pWnd->GetStyle() & (WS_DISABLED | WS_TABSTOP)) ==
						WS_TABSTOP)
					{
						pThis->GotoDlgCtrl(pWnd);
						bHandled = TRUE;
						break;
					}

					pWnd = pWnd->GetWindow(gwMove);
				}
			}
		}
	}

	// If message was not handled here, call PreTranslateMessage
	return (bHandled || pThis->PreTranslateMessage(lpMsg)) ?
		S_OK : S_FALSE;
}

STDMETHODIMP COlePropertyPage::XPropertyPage::EditProperty(DISPID dispid)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropertyPage)
	ASSERT_VALID(pThis);

	return pThis->OnEditProperty(dispid) ? S_OK : E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// COlePropertyPage::XPropNotifySink

STDMETHODIMP_(ULONG) COlePropertyPage::XPropNotifySink::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COlePropertyPage::XPropNotifySink::Release()
{
	return 0;
}

STDMETHODIMP COlePropertyPage::XPropNotifySink::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	if (IsEqualIID(iid, IID_IPropertyNotifySink) ||
		IsEqualIID(iid, IID_IUnknown))
	{
		*ppvObj = this;
		return S_OK;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

STDMETHODIMP COlePropertyPage::XPropNotifySink::OnRequestEdit(DISPID)
{
	return S_OK;
}

STDMETHODIMP COlePropertyPage::XPropNotifySink::OnChanged(DISPID)
{
	METHOD_PROLOGUE_EX(COlePropertyPage, PropNotifySink)

	// If we're not currently in the middle of an UpdateData, call it now.
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThis->m_hWnd != NULL &&
		pThreadState->m_hLockoutNotifyWindow != pThis->m_hWnd)
	{
		pThis->UpdateData(FALSE);
	}
	else
	{
		pThis->m_bPropsChanged = TRUE;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Handle control notifications

AFX_STATIC_DATA const NotifyInfo _afxNotifyList[] = {
	{ _T("edit"),		EN_CHANGE },
	{ _T("button"),		BN_CLICKED },
	{ _T("button"),		BN_DOUBLECLICKED },
	{ _T("combobox"),	CBN_EDITCHANGE },
	{ _T("combobox"),	CBN_SELCHANGE },
	{ _T("listbox"),	LBN_SELCHANGE },
	{ _T("comboboxex32"),	CBN_EDITCHANGE },
	{ _T("comboboxex32"),	CBN_SELCHANGE },
};

AFX_STATIC_DATA const NotifyInfo _afxUpdateList[] = {
	{ _T("edit"),		EN_KILLFOCUS },
	{ _T("button"),		BN_CLICKED },
	{ _T("button"),		BN_DOUBLECLICKED },
	{ _T("combobox"),	CBN_SELCHANGE },
	{ _T("combobox"),	CBN_KILLFOCUS },
	{ _T("listbox"),	LBN_SELCHANGE },
	{ _T("comboboxex32"),	CBN_SELCHANGE },
	{ _T("comboboxex32"),	CBN_KILLFOCUS },
};

BOOL AFXAPI _AfxIsRadioButton(HWND hWnd)
{
	DWORD dwButtonStyle = GetWindowLong(hWnd, GWL_STYLE) & 0x0000000FL;
	return ((dwButtonStyle == BS_RADIOBUTTON) ||
			(dwButtonStyle == BS_AUTORADIOBUTTON));
}

BOOL COlePropertyPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// Let the base class process the message first
	BOOL bSuccess = CDialog::OnCommand(wParam, lParam);

	// Are we just initializing the dialog box, or do we have no objects?
	if (m_bInitializing || m_ppDisp == NULL)
		return bSuccess;

	UINT nID = (UINT)LOWORD(wParam);
	HWND hWndCtl = (HWND)lParam;
	WORD wNotifyCode = HIWORD(wParam);

	DWORD flags = 0;

	if (hWndCtl != NULL)
	{
		BOOL bIgnoreControl = FALSE;
		for (int count = 0; count < m_IDArray.GetSize(); count++)
		{
			UINT nNotID = m_IDArray.GetAt(count);
			if (nID == nNotID)
				bIgnoreControl = TRUE;
		}

		if ( !bIgnoreControl )
		{
			TCHAR szClassName[AFX_MAX_CLASS_NAME];

			// We have a control message - check type of control and message
			::GetClassName(hWndCtl, (LPTSTR)szClassName, AFX_MAX_CLASS_NAME);

			for (int iNotify = 0; iNotify < _countof(_afxNotifyList); iNotify++)
			{
				if (::AfxInvariantStrICmp(_afxNotifyList[iNotify].szClassName, szClassName) == 0
				 && _afxNotifyList[iNotify].wNotifyCode == wNotifyCode )
				{
					if ((::AfxInvariantStrICmp(szClassName, _T("button")) == 0) &&
						_AfxIsRadioButton(hWndCtl))
					{
						// Special case for radio buttons:
						// mark first button in group

						while ((hWndCtl != NULL) &&
								!(GetWindowLong(hWndCtl, GWL_STYLE) & WS_GROUP))
						{
							hWndCtl = ::GetWindow(hWndCtl, GW_HWNDPREV);
						}

						// First button in group must have WS_GROUP style,
						// and must be a radio button.
						ASSERT(hWndCtl != NULL);
						ASSERT(_AfxIsRadioButton(hWndCtl));

						// Mark first radio button as dirty
						if (hWndCtl != NULL)
							nID = ::GetWindowLong(hWndCtl, GWL_ID);
					}

					// Control has been modified
					m_bDirty = TRUE;
					SetControlStatus(nID, TRUE);

					flags = PROPPAGESTATUS_DIRTY;
					break;
				}
			}

			if (m_bDirty)
			{
				for (int iNotify=0; iNotify < _countof(_afxUpdateList); iNotify++)
				{
					if (::AfxInvariantStrICmp(_afxUpdateList[iNotify].szClassName, szClassName)==0 &&
						_afxUpdateList[iNotify].wNotifyCode == wNotifyCode &&
						GetControlStatus(nID))
					{
						flags |= PROPPAGESTATUS_VALIDATE;
					}
				}
			}
		}
	}

	if (flags != 0)
	{
		ASSERT(m_pPageSite != NULL);
		m_pPageSite->OnStatusChange(flags);
	}

	return bSuccess;
}

void COlePropertyPage::IgnoreApply(UINT nID)
{
	m_IDArray.Add(nID);
}

BOOL COlePropertyPage::GetControlStatus(UINT nID)
{
	for (int nControl = 0; nControl < m_nControls; nControl++)
		if (m_pStatus[nControl].nID == nID)
			return m_pStatus[nControl].bDirty;

	// If we couldn't find the control - assume it is dirty
	return TRUE;
}

BOOL COlePropertyPage::SetControlStatus(UINT nID, BOOL bDirty)
{
	for (int nControl = 0; nControl < m_nControls; nControl++)
		if (m_pStatus[nControl].nID == nID)
		{
			m_pStatus[nControl].bDirty = bDirty;
			return TRUE;
		}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Function Templates using the Preprocessor
// [This should be replaced with C++ Templates, eventually]

#define DEFINE_GET_SET_PROP(ctype,initval,casttype,vttype) \
BOOL COlePropertyPage::SetPropText(LPCTSTR pszPropName, ctype& data ) \
{ \
	COleDispatchDriver PropDispDriver; \
	BOOL bResult = FALSE; \
	const CStringW strPropName(pszPropName);\
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString() : NULL;\
	for (ULONG i = 0; i < m_nObjects; i++) \
	{ \
		DISPID dwDispID; \
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID))) \
		{ \
			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE); \
			PropDispDriver.SetProperty(dwDispID, vttype, (casttype)data ); \
			PropDispDriver.DetachDispatch(); \
			bResult = TRUE; \
		} \
	} \
	return bResult; \
} \
BOOL COlePropertyPage::GetPropText(LPCTSTR pszPropName, ctype *data ) \
{ \
	COleDispatchDriver PropDispDriver; \
	BOOL bSuccess = FALSE; \
	const CStringW strPropName(pszPropName);\
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString(): NULL;\
	for (ULONG i = 0; i < m_nObjects; i++) \
	{ \
		DISPID dwDispID; \
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID))) \
		{ \
			ctype dataTemp=static_cast<ctype>(initval); \
			static ctype fill=static_cast<ctype>(initval); \
			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE); \
			PropDispDriver.GetProperty(dwDispID, vttype, &dataTemp); \
			PropDispDriver.DetachDispatch(); \
			if (i == 0) *data = dataTemp; \
			if (*data != dataTemp) *data = fill; \
			bSuccess = TRUE; \
		} \
	} \
	return bSuccess; \
}

/////////////////////////////////////////////////////////////////////////////
// DDP_ property get/set helpers

DEFINE_GET_SET_PROP( BYTE, 0, BYTE, VT_UI1 );
DEFINE_GET_SET_PROP( short, 0, short, VT_I2 );
DEFINE_GET_SET_PROP( int, 0, int, VT_I4 );
DEFINE_GET_SET_PROP( UINT, 0U, UINT, VT_I4 );
DEFINE_GET_SET_PROP( long, 0L, long, VT_I4 );
DEFINE_GET_SET_PROP( DWORD, 0UL, DWORD, VT_I4 );
DEFINE_GET_SET_PROP( float, 0.0, float, VT_R4 );
DEFINE_GET_SET_PROP( double, 0.0, double, VT_R8 );
DEFINE_GET_SET_PROP( CString, "", LPCTSTR, VT_BSTR );

BOOL COlePropertyPage::SetPropCheck(LPCTSTR pszPropName, int Value)
{
	COleDispatchDriver PropDispDriver;
	BOOL bResult = FALSE;
	BOOL bValue;

	if (Value == 1)
		bValue = TRUE;
	else
		bValue = FALSE;         // default to off

	const CStringW strPropName(pszPropName);
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString() : NULL;

	// Set the properties for all the objects
	for (ULONG i = 0; i < m_nObjects; i++)
	{
		DISPID dwDispID;

		// Get the Dispatch ID for the property and if successful set the value of the property
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID)))
		{
			// Set property
			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE);
			PropDispDriver.SetProperty(dwDispID, VT_BOOL, bValue);
			PropDispDriver.DetachDispatch();
			bResult = TRUE;
		}
	}
	return bResult;
}

BOOL COlePropertyPage::GetPropCheck(LPCTSTR pszPropName, int* pValue)
{
	COleDispatchDriver PropDispDriver;
	BOOL bSuccess = FALSE;

	
	const CStringW strPropName(pszPropName);
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString() : NULL;

	// Check the property values for all the objects
	for (ULONG i = 0; i < m_nObjects; i++)
	{
		DISPID dwDispID;

		// Get the Dispatch ID for the property and if successful get the value of the property
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID)))
		{
			// Get property
			BOOL bTemp = FALSE;
			int tempValue;

			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE);
			PropDispDriver.GetProperty(dwDispID, VT_BOOL, &bTemp);
			PropDispDriver.DetachDispatch();

			// Convert boolean value to check box equivalent
			if (bTemp)
				tempValue = 1;
			else
				tempValue = 0;

			// Handle special case for first object
			if (i == 0)
				*pValue = tempValue;

			// If the current check value is not the same as the one just retrieved then
			// set the current check value to the indeterminate state.
			if (tempValue != *pValue)
				*pValue = 2;

			bSuccess = TRUE;
		}
	}
	return bSuccess;
}

BOOL COlePropertyPage::SetPropRadio(LPCTSTR pszPropName, int Value)
{
	COleDispatchDriver PropDispDriver;
	BOOL bSuccess = FALSE;
	
	const CStringW strPropName(pszPropName);
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString() : NULL;

	// Set the properties for all the objects
	for (ULONG i = 0; i < m_nObjects; i++)
	{
		DISPID dwDispID;

		// Get the Dispatch ID for the property and if successful set the value of the property
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID)))
		{
			short nTemp = (short)Value;

			// Set property
			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE);
			PropDispDriver.SetProperty(dwDispID, VT_I2, nTemp);
			PropDispDriver.DetachDispatch();
			bSuccess = TRUE;
		}
	}
	return bSuccess;
}

BOOL COlePropertyPage::GetPropRadio(LPCTSTR pszPropName, int* pValue)
{
	COleDispatchDriver PropDispDriver;
	BOOL bSuccess = FALSE;

	const CStringW strPropName(pszPropName);
	LPCOLESTR lpOleStr = pszPropName ? strPropName.GetString() : NULL;


	// Check the property values for all the objects
	for (ULONG i = 0; i < m_nObjects; i++)
	{
		DISPID dwDispID;

		// Get the Dispatch ID for the property and if successful get the value of the property
		if (SUCCEEDED(m_ppDisp[i]->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpOleStr, 1, 0, &dwDispID)))
		{
			short nTemp=0;

			// Get property
			PropDispDriver.AttachDispatch(m_ppDisp[i], FALSE);
			PropDispDriver.GetProperty(dwDispID, VT_I2, &nTemp);
			PropDispDriver.DetachDispatch();

			// Handle special case for first object
			if (i == 0)
				*pValue = nTemp;

			// Compare the current radio value with the one just retrieved then
			// if they are different then set the radio value to -1, so that no
			// radio buttons will be checked.
			if (nTemp != *pValue)
				*pValue = -1;

			bSuccess = TRUE;
		}
	}
	return bSuccess;
}

BOOL COlePropertyPage::SetPropIndex(LPCTSTR pszPropName, int Value)
{
	return SetPropRadio(pszPropName, Value);
}

BOOL COlePropertyPage::GetPropIndex(LPCTSTR pszPropName, int* pValue)
{
	return GetPropRadio(pszPropName, pValue);
}

/////////////////////////////////////////////////////////////////////////////
// DDP_Begin data exchange routines (Should be C++ templated someday!)

#define DEFINE_DDP_(group,ctype,vtype,bEditCtrl) \
void AFXAPI DDP_End##group(CDataExchange* pDX, int, \
						   ctype *member, LPCTSTR pszPropName ) \
{ \
	ENSURE(pDX->m_pDlgWnd); \
	COlePropertyPage* propDialog = STATIC_DOWNCAST(COlePropertyPage, pDX->m_pDlgWnd); \
	ENSURE(propDialog); \
	if (pDX->m_bSaveAndValidate) \
		propDialog->SetProp##group(pszPropName, *member ); \
} \
void AFXAPI DDP_##group(CDataExchange* pDX, int nCtrlId, \
						ctype &member, LPCTSTR pszPropName ) \
{ \
	ASSERT(AfxIsValidString(pszPropName)); \
	ENSURE(pDX->m_pDlgWnd); \
	COlePropertyPage* propDialog = STATIC_DOWNCAST(COlePropertyPage, pDX->m_pDlgWnd); \
	ENSURE(propDialog); \
	if (pDX->m_bSaveAndValidate) /*Are we Saving?*/ \
	{ \
		if (propDialog->GetControlStatus(nCtrlId)) /*Is Control Dirty?*/ \
		{ \
			void (AFXAPI *pfv)(CDataExchange*,int,ctype*,LPCTSTR) = \
				 DDP_End##group; \
			AFX_DDPDATA *pDDP = new AFX_DDPDATA( (void *)pfv, nCtrlId, bEditCtrl, \
												 (void*)&member, (UINT)vtype, \
												 pszPropName ); \
			propDialog->m_arrayDDP.Add(pDDP); \
		} \
	} \
	else /* Loading data from properties! */ \
	{ \
			propDialog->GetProp##group(pszPropName, &member); \
			propDialog->SetControlStatus(nCtrlId,FALSE); \
	} \
}

/////////////////////////////////////////////////////////////////////////////
// DDP Functions (Pseudo Template Generation)

DEFINE_DDP_(Text,BYTE,VT_UI1,TRUE);
DEFINE_DDP_(Text,short,VT_I2,TRUE);
DEFINE_DDP_(Text,int,VT_I4,TRUE);
DEFINE_DDP_(Text,UINT,VT_UI4,TRUE);
DEFINE_DDP_(Text,long,VT_I4,TRUE);
DEFINE_DDP_(Text,DWORD,VT_UI4,TRUE);
DEFINE_DDP_(Text,float,VT_R4,TRUE);
DEFINE_DDP_(Text,double,VT_R8,TRUE);
DEFINE_DDP_(Text,CString,VT_BSTR,TRUE);
DEFINE_DDP_(Check,BOOL,VT_I4,FALSE);
DEFINE_DDP_(Radio,int,VT_I4,FALSE);

//////////////////////////////////////////////////////////////////////////////
// DDP Deferred Property Write Handler

void AFXAPI DDP_PostProcessing(CDataExchange*pDX)
{
	ENSURE_ARG(pDX != NULL);
	if (pDX->m_bSaveAndValidate)
	{
		CPtrArray &arrayDDP =
			((COlePropertyPage *)pDX->m_pDlgWnd)->m_arrayDDP;
		AFX_DDPDATA *pDDP = NULL;
		INT_PTR cDDP = arrayDDP.GetSize();
		for (INT_PTR i = 0 ; i < cDDP; i++)
		{
			pDDP = (AFX_DDPDATA*)arrayDDP[i];
			TRY
			{
				if (pDDP->m_bEditCtrl)
					pDX->PrepareEditCtrl(pDDP->m_nCtrlId);
				else
					pDX->PrepareCtrl(pDDP->m_nCtrlId);

				switch( pDDP->m_nType )
				{
					case    VT_I1:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   char *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (char *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					case    VT_UI1:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   BYTE *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (BYTE *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );

						break;
					}
					case    VT_I2:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   short *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (short *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					case    VT_UI2:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   WORD *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (WORD *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					case    VT_I4:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   long *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (long *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					case    VT_UI4:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   DWORD *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (DWORD *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName);
						break;
					}
					case    VT_R4:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   float *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (float *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName);
						break;
					}
					case    VT_R8:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   double *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (double *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					case    VT_BSTR:
					{
						typedef void (AFXAPI *PFV)(CDataExchange *, int,
												   CString *, LPCTSTR );
						(*(PFV)pDDP->m_lpHandler)(pDX, pDDP->m_nCtrlId,
												  (CString *)pDDP->m_lpMember,
												  pDDP->m_lpszOleName );
						break;
					}
					default:
						// Unknown Data Type!
						ASSERT(FALSE);
						break;
				}
			}
			CATCH(COleDispatchException, e)
			{
				// Dleanup before pDX->Fail() throws exception.
				_AfxCleanupDDPs(arrayDDP);

				// Display message box for dispatch exceptions.
				COlePropertyPage* pPropPage = (COlePropertyPage*)pDX->m_pDlgWnd;
				pPropPage->MessageBox((LPCTSTR)e->m_strDescription, NULL,
					MB_ICONEXCLAMATION | MB_OK);
				DELETE_EXCEPTION(e);
				pDX->Fail();
			}
			AND_CATCH_ALL(e)
			{
				// Ignore other exceptions.
				DELETE_EXCEPTION(e);
			}
			END_CATCH_ALL
		}

		_AfxCleanupDDPs(arrayDDP);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG


IMPLEMENT_DYNAMIC(COlePropertyPage, CDialog)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlobj.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleObject

STDMETHODIMP_(ULONG) COleControl::XOleObject::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XOleObject::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XOleObject::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XOleObject::SetClientSite(LPOLECLIENTSITE pClientSite)
{
	METHOD_PROLOGUE_EX(COleControl, OleObject)

	ASSERT_NULL_OR_POINTER(pClientSite, IOleClientSite);

	// maintain reference counts
	if (pClientSite != NULL)
		pClientSite->AddRef();
	RELEASE(pThis->m_pClientSite);
	pThis->m_pClientSite = pClientSite;

	// Release existing pointer to ambient property dispinterface.
	pThis->m_ambientDispDriver.ReleaseDispatch();

	if (pClientSite != NULL)
	{
		BOOL bValue;
		pThis->m_bAutoClip =
			pThis->GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, VT_BOOL, &bValue) ? bValue : 0;
		pThis->m_bMsgReflect =
			pThis->GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &bValue) ? bValue : 0;
		pThis->m_bUIDead = (BYTE)(pThis->AmbientUIDead());
	}

	// Release existing pointer to in-place site, if any.
	RELEASE(pThis->m_pInPlaceSite);

	// Initialize pointer to control site
	LPVOID pInterface;
	if (pClientSite == NULL ||
		FAILED(pClientSite->QueryInterface(IID_IOleControlSite, &pInterface)))
	{
		pInterface = NULL;
	}

	RELEASE(pThis->m_pControlSite);
	pThis->m_pControlSite = (LPOLECONTROLSITE) pInterface;

	// Initialize pointer to simple frame site
	if (pClientSite == NULL || !pThis->m_bSimpleFrame ||
		FAILED(pClientSite->QueryInterface(IID_ISimpleFrameSite, &pInterface)))
	{
		pInterface = NULL;
	}

	RELEASE(pThis->m_pSimpleFrameSite);
	pThis->m_pSimpleFrameSite = (LPSIMPLEFRAMESITE) pInterface;

	// Let the control run its own code here.
	pThis->OnSetClientSite();

	// Unless IPersist*::Load or IPersist*::InitNew is called after this,
	// we can't count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = FALSE;

	return S_OK;
}

STDMETHODIMP COleControl::XOleObject::GetClientSite(LPOLECLIENTSITE* ppClientSite)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	ASSERT_POINTER(ppClientSite, LPOLECLIENTSITE);

	LPOLECLIENTSITE pClientSite = pThis->m_pClientSite;
	*ppClientSite = pClientSite;
	if (pClientSite != NULL)
		pClientSite->AddRef();

	return (pClientSite != NULL) ? S_OK : E_FAIL;
}

STDMETHODIMP COleControl::XOleObject::SetHostNames(LPCOLESTR, LPCOLESTR)
{
	return S_OK;
}

STDMETHODIMP COleControl::XOleObject::Close(DWORD dwSaveOption)
{
	METHOD_PROLOGUE_EX(COleControl, OleObject)
	pThis->OnClose(dwSaveOption);
	return S_OK;
}

void COleControl::OnClose(DWORD dwSaveOption)
{
	if (m_bInPlaceActive)
		m_xOleInPlaceObject.InPlaceDeactivate();

	if (((dwSaveOption == OLECLOSE_SAVEIFDIRTY) || (dwSaveOption == OLECLOSE_PROMPTSAVE)) &&
		m_bModified)
	{
		SendAdvise(OBJECTCODE_SAVEOBJECT);
		SendAdvise(OBJECTCODE_SAVED);
	}
}

STDMETHODIMP COleControl::XOleObject::SetMoniker(DWORD, LPMONIKER)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleObject::GetMoniker(DWORD, DWORD, LPMONIKER*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleObject::InitFromData(LPDATAOBJECT, BOOL, DWORD)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleObject::GetClipboardData(DWORD, LPDATAOBJECT*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleObject::DoVerb(LONG iVerb, LPMSG lpmsg,
	LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent,
	LPCRECT lprcPosRect)
{
	METHOD_PROLOGUE_EX(COleControl, OleObject)

	TRY
	{
		if (pThis->OnDoVerb(iVerb, lpmsg, hwndParent, lprcPosRect))
			return S_OK;                 // Custom verb succeeded
	}
	CATCH (COleException, e)
	{
		return E_FAIL;     // Custom verb failed
	}
	END_CATCH

	// Custom verb not found, invoke standard verb instead.

	HRESULT hr;

	switch (iVerb)
	{
	case OLEIVERB_HIDE:
		pThis->m_xOleInPlaceObject.UIDeactivate();
		return pThis->OnHide();


	case OLEIVERB_SHOW:
		return pThis->OnOpen(-1, lpmsg);      // Try in-place first

	case OLEIVERB_UIACTIVATE:
	case OLEIVERB_INPLACEACTIVATE:
#ifdef _AFXDLL
		if (pThis->m_bOpen)
			return OLE_E_NOT_INPLACEACTIVE;    // Already open
#endif

		// FALL THRU

	case OLEIVERB_PRIMARY:
		if (lprcPosRect != NULL)
			CopyRect(&pThis->m_rcPos, lprcPosRect);
		else
			memset(&pThis->m_rcPos, 0, sizeof(pThis->m_rcPos));
		return pThis->OnActivateInPlace((iVerb != OLEIVERB_INPLACEACTIVATE), lpmsg);

#ifdef _AFXDLL
	case OLEIVERB_OPEN:
		return pThis->OnOpen(FALSE, lpmsg);     // Don't try in-place
#endif

	case OLEIVERB_PROPERTIES:
		return pThis->OnProperties(lpmsg, hwndParent, lprcPosRect) ?
				S_OK : E_FAIL;

	default:
		// negative verbs not understood should return E_NOTIMPL
		if (iVerb < 0)
			return E_NOTIMPL;

		// positive verb not processed --
		// according to OLE spec, primary verb should be executed
		// instead.
		if (SUCCEEDED(hr = DoVerb(OLEIVERB_PRIMARY, lpmsg, pActiveSite,
								lindex, hwndParent, lprcPosRect)))
			return OLEOBJ_S_INVALIDVERB;
		else
			return hr;
	}
}

BOOL COleControl::OnDoVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent,
	LPCRECT lpRect)
{
	return DoOleVerb(iVerb, lpMsg, hWndParent, lpRect);
}

STDMETHODIMP COleControl::XOleObject::EnumVerbs(LPENUMOLEVERB* ppenumOleVerb)
{
	METHOD_PROLOGUE_EX(COleControl, OleObject)
	return pThis->OnEnumVerbs(ppenumOleVerb) ?
		S_OK : OLEOBJ_E_NOVERBS;
}

BOOL COleControl::OnEnumVerbs(LPENUMOLEVERB* ppenumOleVerb)
{
	return EnumOleVerbs(ppenumOleVerb);
}

STDMETHODIMP COleControl::XOleObject::Update()
{
	return S_OK;
}

STDMETHODIMP COleControl::XOleObject::IsUpToDate()
{
	return S_OK;
}

STDMETHODIMP COleControl::XOleObject::GetUserClassID(CLSID* pClsid)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)
	return pThis->GetClassID(pClsid);
}

STDMETHODIMP COleControl::XOleObject::GetUserType(DWORD, LPOLESTR* ppszUserType)
{
	METHOD_PROLOGUE_EX(COleControl, OleObject)
	UNUSED(ppszUserType);   // not used in release builds
	ASSERT_POINTER(ppszUserType, LPOLESTR);
	TCHAR szUserType[256];
	pThis->GetUserType(szUserType);
	*ppszUserType = AtlAllocTaskOleString(szUserType);
	return S_OK;
}

void COleControl::GetUserType(_Pre_notnull_ _Post_z_ LPTSTR pszUserType)
{
	ASSERT(pszUserType != NULL);
	pszUserType[0] = '\0';

	TRY
	{
		AfxLoadString(GetUserTypeNameID(), pszUserType);
	}
	END_TRY
}

STDMETHODIMP COleControl::XOleObject::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	if (dwDrawAspect & DVASPECT_CONTENT)
		return pThis->OnSetExtent(lpsizel) ? S_OK : E_FAIL;
	else
		return E_NOTIMPL;
}

BOOL COleControl::OnSetExtent(LPSIZEL lpSizeL)
{
	if (m_bChangingExtent)  // Prevent infinite recursion!
		return FALSE;

	ENSURE_ARG(lpSizeL != NULL);
	m_bChangingExtent = TRUE;

	if (m_cxExtent == lpSizeL->cx && m_cyExtent == lpSizeL->cy)
	{
		InvalidateControl();
		m_bChangingExtent = FALSE;
		return TRUE;
	}

	// Update the control's extent.
	m_cxExtent = lpSizeL->cx;
	m_cyExtent = lpSizeL->cy;

	// Mark the control dirty and force a repaint.
	SetModifiedFlag();
	InvalidateControl();

	SIZEL szlPixels;
	_AfxXformSizeInHimetricToPixels(NULL, lpSizeL, &szlPixels);

	CRect rectNew(m_rcPos);
	rectNew.right = rectNew.left + (int)szlPixels.cx;
	rectNew.bottom = rectNew.top + (int)szlPixels.cy;

	if ((m_pInPlaceSite != NULL) && m_bInPlaceActive)
	{
		// If the control is in-place active, tell the container to resize.
		m_pInPlaceSite->OnPosRectChange(&rectNew);
	}
#ifdef _AFXDLL
	else if (m_bOpen)
	{
		// If the control is open, resize it.
		ResizeOpenControl((int)szlPixels.cx, (int)szlPixels.cy);
	}
#endif
	else
	{
		CopyRect(m_rcPos, rectNew);

		// Resize off-screen window, if any.
		if (m_hWnd != NULL)
			::SetWindowPos(m_hWnd, NULL, 0, 0, (int)szlPixels.cx,
				(int)szlPixels.cy, SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE);
	}

	m_bChangingExtent = FALSE;
	return TRUE;
}

STDMETHODIMP COleControl::XOleObject::GetExtent(DWORD dwDrawAspect,
	LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	if (dwDrawAspect & DVASPECT_CONTENT)
	{
		ENSURE_ARG(lpsizel != NULL);
		lpsizel->cx = pThis->m_cxExtent;
		lpsizel->cy = pThis->m_cyExtent;
		return S_OK;
	}
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XOleObject::Advise(LPADVISESINK pAdvSink,
	DWORD* pdwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	// If no advise holder exists, create one.
	// Then delegate this call to the advise holder.

	if (pThis->m_pOleAdviseHolder == NULL)
	{
		HRESULT hr;
		if (FAILED(hr = CreateOleAdviseHolder(&pThis->m_pOleAdviseHolder)))
			return hr;
	}

	return pThis->m_pOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP COleControl::XOleObject::Unadvise(DWORD dwConnection)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	if (pThis->m_pOleAdviseHolder != NULL)
		return pThis->m_pOleAdviseHolder->Unadvise(dwConnection);

	return E_FAIL;
}

STDMETHODIMP COleControl::XOleObject::EnumAdvise(LPENUMSTATDATA* ppenumAdvise)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)

	if (pThis->m_pOleAdviseHolder != NULL)
		return pThis->m_pOleAdviseHolder->EnumAdvise(ppenumAdvise);

	return E_FAIL;
}

STDMETHODIMP COleControl::XOleObject::GetMiscStatus(DWORD dwAspect,
	DWORD* pdwStatus)
{
	METHOD_PROLOGUE_EX_(COleControl, OleObject)
	ASSERT_POINTER(pdwStatus, DWORD);

	if (dwAspect == DVASPECT_CONTENT)
		*pdwStatus = pThis->GetMiscStatus();
	else
		*pdwStatus = 0;

	return S_OK;
}

STDMETHODIMP COleControl::XOleObject::SetColorScheme(LPLOGPALETTE)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlmodul.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_NO_OCX_SUPPORT


#define new DEBUG_NEW


/////////////////////////////////////////////////////////////////////////////
// COleControlModule::InitInstance

IMPLEMENT_DYNAMIC(COleControlModule, CWinApp)

BOOL COleControlModule::InitInstance()
{
#ifdef _AFXDLL
	// wire up resources from OLE DLL
	AfxOleInitModule();
#endif

	COleObjectFactory::RegisterAll();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlModule::ExitInstance

int COleControlModule::ExitInstance()
{
	COleObjectFactory::RevokeAll();
	return CWinApp::ExitInstance();
}

#endif // !_AFX_NO_OCX_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlnownd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CWindowlessDC - used by COleControl::GetDC and COleControl::ReleaseDC

class CWindowlessDC : public CDC
{
	DECLARE_DYNAMIC(CWindowlessDC)
public:
	CWindowlessDC(HDC hDC, CPoint& pointOrigin);
	HDC Detach();
protected:
	CPoint m_pointOrigin;
};

IMPLEMENT_DYNAMIC(CWindowlessDC, CDC)

CWindowlessDC::CWindowlessDC(HDC hDC, CPoint& pointOrigin)
{
	m_hDC = m_hAttribDC = hDC;
	m_pointOrigin =  GetViewportOrg();
	SetViewportOrg(m_pointOrigin + pointOrigin);
}

HDC CWindowlessDC::Detach()
{
	SetViewportOrg(m_pointOrigin);
	HDC hDC = m_hDC;
	m_hDC = m_hAttribDC = NULL;
	return hDC;
}

/////////////////////////////////////////////////////////////////////////////
// Overridables used with the various windowless interfaces

void COleControl::GetClientOffset(long* pdxOffset, long* pdyOffset) const
{
	int nOffset = (m_sBorderStyle == 1) + (2 * (m_sAppearance == 1));

	if (nOffset > 0)
	{
		*pdxOffset = nOffset * GetSystemMetrics(SM_CXBORDER);
		*pdyOffset = nOffset * GetSystemMetrics(SM_CYBORDER);
	}
	else
	{
		*pdxOffset = *pdyOffset = 0;
	}
}

UINT COleControl::ParentToClient(LPCRECT lprcBounds, LPPOINT pPoint,
	BOOL bHitTest) const
{
	long dxOffset;
	long dyOffset;
	GetClientOffset(&dxOffset, &dyOffset);

	UINT nHitTest = HTNOWHERE;

	if (bHitTest && ::PtInRect(lprcBounds, *pPoint))
	{
		if (dxOffset > 0)
		{
			CRect rectClient(lprcBounds);
			rectClient.InflateRect(-dxOffset, -dyOffset);
			nHitTest = rectClient.PtInRect(*pPoint) ? HTCLIENT : HTBORDER;
		}
		else
		{
			nHitTest = HTCLIENT;
		}
	}

	pPoint->x -= lprcBounds->left + dxOffset;
	pPoint->y -= lprcBounds->top  + dyOffset;

	return nHitTest;
}

void COleControl::ClientToParent(LPCRECT lprcBounds, LPPOINT pPoint) const
{
	long dxOffset;
	long dyOffset;
	GetClientOffset(&dxOffset, &dyOffset);
	pPoint->x += lprcBounds->left + dxOffset;
	pPoint->y += lprcBounds->top  + dyOffset;
}

/////////////////////////////////////////////////////////////////////////////
// Overridables for IPointerInactive methods

DWORD COleControl::GetActivationPolicy()
{
	return 0;
}

BOOL COleControl::OnInactiveSetCursor(LPCRECT lprcBounds, long x, long y,
	DWORD dwMouseMsg, BOOL bSetAlways)
{
	CPoint point(x, y);
	UINT nHitTest = ParentToClient(lprcBounds, &point, TRUE);

	LRESULT lResult = 0;
	OnWndMsg(WM_SETCURSOR, nHitTest, dwMouseMsg, &lResult);

	if (bSetAlways && ! lResult)
		::SetCursor(::LoadCursor(NULL, IDC_ARROW));

	return bSetAlways || lResult;
}

void COleControl::OnInactiveMouseMove(LPCRECT lprcBounds, long x, long y,
	DWORD dwKeyState)
{
	CPoint point(x, y);
	ParentToClient(lprcBounds, &point);
	OnWndMsg(WM_MOUSEMOVE, dwKeyState, MAKELONG(point.x, point.y), NULL);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPointerInactive

STDMETHODIMP_(ULONG) COleControl::XPointerInactive::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPointerInactive::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPointerInactive::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPointerInactive::GetActivationPolicy(
   DWORD* pdwPolicy)
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	*pdwPolicy = pThis->GetActivationPolicy();
	return S_OK;
}

STDMETHODIMP COleControl::XPointerInactive::OnInactiveSetCursor(
	LPCRECT lprcBounds, long x, long y, DWORD dwMouseMsg, BOOL bSetAlways)
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	return pThis->OnInactiveSetCursor(lprcBounds, x, y, dwMouseMsg, bSetAlways) ?
		S_OK : S_FALSE;
}

STDMETHODIMP COleControl::XPointerInactive::OnInactiveMouseMove(
	LPCRECT lprcBounds, long x, long y, DWORD dwKeyState)
{
	METHOD_PROLOGUE_EX_(COleControl, PointerInactive)
	pThis->OnInactiveMouseMove(lprcBounds, x, y, dwKeyState);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Overridables for IOleInPlaceObjectWindowless methods

BOOL COleControl::OnWindowlessMessage(UINT msg, WPARAM wParam, LPARAM lParam,
	LRESULT* plResult)
{
	if ((msg >= WM_MOUSEFIRST && msg <= AFX_WM_MOUSELAST) || (msg == WM_CONTEXTMENU))
	{
		CPoint point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		ParentToClient(m_rcPos, &point, FALSE);
		lParam = MAKELONG(point.x, point.y);
	}

	return OnWndMsg(msg, wParam, lParam, plResult);
}

IDropTarget* COleControl::GetWindowlessDropTarget()
{
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XOleInPlaceObject (IOleInPlaceObjectWindowless methods)

STDMETHODIMP COleControl::XOleInPlaceObject::OnWindowMessage(UINT msg,
	WPARAM wParam, LPARAM lParam, LRESULT* plResult)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)
	return pThis->OnWindowlessMessage(msg, wParam, lParam, plResult) ?
		S_OK : S_FALSE;
}

STDMETHODIMP COleControl::XOleInPlaceObject::GetDropTarget(
	IDropTarget** ppDropTarget)
{
	METHOD_PROLOGUE_EX_(COleControl, OleInPlaceObject)

	*ppDropTarget = pThis->GetWindowlessDropTarget();
	return (*ppDropTarget != NULL) ? S_OK : E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// Cover functions for IOleInPlaceSiteWindowless methods

CWnd* COleControl::SetCapture()
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CWnd* pWndPrev = GetCapture();
		m_pInPlaceSiteWndless->SetCapture(TRUE);
		return pWndPrev;
	}
	else
	{
		return CWnd::SetCapture();
	}
}

BOOL COleControl::ReleaseCapture()
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
		return (m_pInPlaceSiteWndless->SetCapture(FALSE) == S_OK);
	else
		return ::ReleaseCapture();
}

CWnd* COleControl::GetCapture()
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		return (m_pInPlaceSiteWndless->GetCapture() == S_OK) ?
			this : NULL;
	}
	else
	{
		return CWnd::GetCapture();
	}
}

CWnd* COleControl::SetFocus()
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CWnd* pWndPrev = GetFocus();
		m_pInPlaceSiteWndless->SetFocus(TRUE);
		return pWndPrev;
	}
	else
	{
		return CWnd::SetFocus();
	}
}

CWnd* COleControl::GetFocus()
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		return (m_pInPlaceSiteWndless->GetFocus() == S_OK) ?
			this : NULL;
	}
	else
	{
		return CWnd::GetFocus();
	}
}

CDC* COleControl::GetDC(LPCRECT lprcRect, DWORD dwFlags)
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CPoint point(0, 0);
		ClientToParent(m_rcPos, &point);
		CRect rect;
		if (lprcRect != NULL)
		{
			rect.CopyRect(lprcRect);
			rect.OffsetRect(point);
			lprcRect = &rect;
		}

		HDC hDC;
		if (FAILED(m_pInPlaceSiteWndless->GetDC(lprcRect, dwFlags, &hDC)))
			return NULL;

		CDC* pDC = NULL;
		TRY
		{
			pDC = new CWindowlessDC(hDC, point);
		}
		CATCH_ALL(e)
		{
			m_pInPlaceSiteWndless->ReleaseDC(hDC);
		}
		END_CATCH_ALL

		return pDC;
	}
	else
	{
		// NOTE: can only use non-default values for these parameters when
		// activated windowless.
		ASSERT(lprcRect == NULL);
		ASSERT(dwFlags == OLEDC_PAINTBKGND);
		return CWnd::GetDC();
	}
}

BOOL COleControl::ReleaseDC(CDC* pDC)
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CWindowlessDC* pWindowlessDC = DYNAMIC_DOWNCAST(CWindowlessDC, pDC);
		ENSURE(pWindowlessDC != NULL);
		HDC hDC = pWindowlessDC->Detach();
		delete pWindowlessDC;
		return m_pInPlaceSiteWndless->ReleaseDC(hDC);
	}
	else
	{
		return CWnd::ReleaseDC(pDC);
	}
}

void COleControl::InvalidateRgn(CRgn* pRgn, BOOL bErase)
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CRgn rgn;
		if (pRgn != NULL)
		{
			CPoint point(0, 0);
			ClientToParent(m_rcPos, &point);
			rgn.CopyRgn(pRgn);
			rgn.OffsetRgn(point);
		}
		m_pInPlaceSiteWndless->InvalidateRgn(rgn, bErase);
	}
	else
	{
		CWnd::InvalidateRgn(pRgn, bErase);
	}
}

void COleControl::ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect,
	LPCRECT lpClipRect)
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		if (lpRect != NULL || lpClipRect != NULL)
		{
			CPoint point(0, 0);
			ClientToParent(m_rcPos, &point);
			CRect rect;
			CRect rectClip;
			if (lpRect != NULL)
			{
				rect.CopyRect(lpRect);
				rect.OffsetRect(point);
				lpRect = &rect;
			}
			if (lpClipRect != NULL)
			{
				rectClip.CopyRect(lpClipRect);
				rectClip.OffsetRect(point);
				lpClipRect = &rectClip;
			}
		}

		m_pInPlaceSiteWndless->ScrollRect(xAmount, yAmount, lpRect, lpClipRect);
	}
	else
	{
		CWnd::ScrollWindow(xAmount, yAmount, lpRect, lpClipRect);
	}
}

BOOL COleControl::ClipCaretRect(LPRECT lpRect)
{
	BOOL bNotEmpty = FALSE;

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		CPoint point(0, 0);
		ClientToParent(m_rcPos, &point);
		CRect rect(lpRect);
		rect.OffsetRect(point);
		bNotEmpty = (m_pInPlaceSiteWndless->AdjustRect(rect) == S_OK);
		rect.OffsetRect(-point.x, -point.y);
	}

	return bNotEmpty;
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions for windowless controls

void COleControl::GetClientRect(LPRECT lpRect) const
{
	ASSERT((m_hWnd != NULL) || (m_bInPlaceSiteWndless && m_bInPlaceActive));

	if (m_bInPlaceSiteWndless && m_bInPlaceActive)
	{
		long dxOffset;
		long dyOffset;
		GetClientOffset(&dxOffset, &dyOffset);
		::CopyRect(lpRect, m_rcPos);
		::InflateRect(lpRect, -dxOffset, -dyOffset);

#ifdef _DEBUG
		CPoint point(0, 0);
		ClientToParent(m_rcPos, &point);
		ASSERT(point.x == lpRect->left && point.y == lpRect->top);
#endif

		::OffsetRect(lpRect, -lpRect->left, -lpRect->top);
	}
	else if (m_hWnd != NULL)
	{
		CWnd::GetClientRect(lpRect);
	}
	else
	{
		::SetRectEmpty(lpRect);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlprop.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <msstkppg.h>


#ifndef _DEBUG
#pragma intrinsic(memset)
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Stock property mask

#define STOCKPROP_BACKCOLOR     0x00000001
#define STOCKPROP_CAPTION       0x00000002
#define STOCKPROP_FONT          0x00000004
#define STOCKPROP_FORECOLOR     0x00000008
#define STOCKPROP_TEXT          0x00000010
#define STOCKPROP_BORDERSTYLE   0x00000020
#define STOCKPROP_ENABLED       0x00000040
#define STOCKPROP_APPEARANCE    0x00000080

AFX_STATIC_DATA const DWORD _afxStockProps[] =
{
	STOCKPROP_BACKCOLOR,    // -501
	0,                      // -502
	0,                      // -503
	STOCKPROP_BORDERSTYLE,  // -504
	0,                      // -505
	0,                      // -506
	0,                      // -507
	0,                      // -508
	0,                      // -509
	0,                      // -510
	0,                      // -511
	STOCKPROP_FONT,         // -512
	STOCKPROP_FORECOLOR,    // -513
	STOCKPROP_ENABLED,      // -514
	0,                      // -515
	0,                      // -516
	STOCKPROP_TEXT,         // -517
	STOCKPROP_CAPTION,      // -518
	0,                      // -519
	STOCKPROP_APPEARANCE,   // -520
};

void COleControl::InitStockPropMask()
{
	const AFX_DISPMAP* pDispMap = GetDispatchMap();
	const AFX_DISPMAP_ENTRY* pEntry;
	ASSERT(pDispMap != NULL);

	// If stock property mask is already initialized, we're outta here.
	if (*pDispMap->lpStockPropMask != (DWORD)-1)
		return;

	AfxLockGlobals(CRIT_STOCKMASK);

	if (*pDispMap->lpStockPropMask == (DWORD)-1)
	{
		const AFX_DISPMAP* pDispMapTop = pDispMap;
		DWORD dwStockPropMask = 0;

#ifdef _AFXDLL
		for (;;)
#else
		while (pDispMap != NULL)
#endif
		{
			pEntry = pDispMap->lpEntries;
			while (pEntry->nPropOffset != -1)
			{
				int nIndex = DISPID_BACKCOLOR - pEntry->lDispID;
				DWORD dwFlag;
				if (nIndex >= 0 && nIndex < _countof(_afxStockProps) &&
					(dwFlag = _afxStockProps[nIndex]) != 0)
				{
					dwStockPropMask |= dwFlag;
				}

				++pEntry;
			}
			// check base class
#ifdef _AFXDLL
			if (pDispMap->pfnGetBaseMap == NULL)
				break;
			pDispMap = (*pDispMap->pfnGetBaseMap)();
#else
			pDispMap = pDispMap->pBaseMap;
#endif
		}

		*pDispMapTop->lpStockPropMask = dwStockPropMask;
	}

	AfxUnlockGlobals(CRIT_STOCKMASK);
}

AFX_STATIC void AFXAPI _AfxToggleBorderStyle(CWnd* pWnd)
{
	if (pWnd->m_hWnd != NULL)
	{
		// toggle border style and force redraw of border
		::SetWindowLong(pWnd->m_hWnd, GWL_STYLE, pWnd->GetStyle() ^ WS_BORDER);
		::SetWindowPos(pWnd->m_hWnd, NULL, 0, 0, 0, 0,
			SWP_FRAMECHANGED | SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

AFX_STATIC void AFXAPI _AfxToggleAppearance(CWnd* pWnd)
{
	if (pWnd->m_hWnd != NULL)
	{
		// toggle border style and force redraw of border
		::SetWindowLong(pWnd->m_hWnd, GWL_EXSTYLE, pWnd->GetExStyle() ^
			WS_EX_CLIENTEDGE);
		::SetWindowPos(pWnd->m_hWnd, NULL, 0, 0, 0, 0,
			SWP_FRAMECHANGED | SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Property exchange for stock properties

void COleControl::ExchangeStockProps(CPropExchange* pPX)
{
	BOOL bLoading = pPX->IsLoading();
	DWORD dwStockPropMask = GetStockPropMask();
	DWORD dwPersistMask = dwStockPropMask;

	PX_ULong(pPX, _T("_StockProps"), dwPersistMask);

	if (dwStockPropMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
	{
		CString strText;

		if (dwPersistMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
		{
			if (!bLoading)
				strText = InternalGetText();
			if (dwStockPropMask & STOCKPROP_CAPTION)
				PX_String(pPX, _T("Caption"), strText, _T(""));
			if (dwStockPropMask & STOCKPROP_TEXT)
				PX_String(pPX, _T("Text"), strText, _T(""));
		}
		if (bLoading)
		{
			TRY
				SetText(strText);
			END_TRY
		}
	}

	if (dwStockPropMask & STOCKPROP_FORECOLOR)
	{
		if (dwPersistMask & STOCKPROP_FORECOLOR)
			PX_Color(pPX, _T("ForeColor"), m_clrForeColor, AmbientForeColor());
		else if (bLoading)
			m_clrForeColor = AmbientForeColor();
	}

	if (dwStockPropMask & STOCKPROP_BACKCOLOR)
	{
		if (dwPersistMask & STOCKPROP_BACKCOLOR)
			PX_Color(pPX, _T("BackColor"), m_clrBackColor, AmbientBackColor());
		else if (bLoading)
			m_clrBackColor = AmbientBackColor();
	}

	if (dwStockPropMask & STOCKPROP_FONT)
	{
		LPFONTDISP pFontDispAmbient = AmbientFont();
		BOOL bChanged = TRUE;

		if (dwPersistMask & STOCKPROP_FONT)
			bChanged = PX_Font(pPX, _T("Font"), m_font, NULL, pFontDispAmbient);
		else if (bLoading)
			m_font.InitializeFont(NULL, pFontDispAmbient);

		if (bLoading && bChanged)
			OnFontChanged();

		RELEASE(pFontDispAmbient);
	}

	if (dwStockPropMask & STOCKPROP_BORDERSTYLE)
	{
		short sBorderStyle = m_sBorderStyle;

		if (dwPersistMask & STOCKPROP_BORDERSTYLE)
			PX_Short(pPX, _T("BorderStyle"), m_sBorderStyle, 0);
		else if (bLoading)
			m_sBorderStyle = 0;

		if (sBorderStyle != m_sBorderStyle)
			_AfxToggleBorderStyle(this);
	}

	if (dwStockPropMask & STOCKPROP_ENABLED)
	{
		BOOL bEnabled = m_bEnabled;

		if (dwPersistMask & STOCKPROP_ENABLED)
			PX_Bool(pPX, _T("Enabled"), m_bEnabled, TRUE);
		else if (bLoading)
			m_bEnabled = TRUE;

		if ((bEnabled != m_bEnabled) && (m_hWnd != NULL))
			::EnableWindow(m_hWnd, m_bEnabled);
	}

	if (dwStockPropMask & STOCKPROP_APPEARANCE)
	{
		short sAppearance = m_sAppearance;

		if (dwPersistMask & STOCKPROP_APPEARANCE)
			PX_Short(pPX, _T("Appearance"), m_sAppearance, 0);
		else if (bLoading)
			m_sAppearance = AmbientAppearance();

		if (sAppearance != m_sAppearance)
			_AfxToggleAppearance(this);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Serialization for stock properties

void COleControl::SerializeStockProps(CArchive& ar)
{
	BOOL bLoading = ar.IsLoading();
	DWORD dwStockPropMask = GetStockPropMask();
	DWORD dwPersistMask = dwStockPropMask;

	if (bLoading)
	{
		ar >> dwPersistMask;

		if (dwStockPropMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
		{
			if (dwPersistMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
			{
				CString strText;
				ar >> strText;
				TRY
					SetText(strText);
				END_TRY
			}
			else
			{
				TRY
					SetText(_T(""));
				END_TRY
			}
		}

		if (dwStockPropMask & STOCKPROP_FORECOLOR)
		{
			if (dwPersistMask & STOCKPROP_FORECOLOR)
				ar >> m_clrForeColor;
			else
				m_clrForeColor = AmbientForeColor();
		}

		if (dwStockPropMask & STOCKPROP_BACKCOLOR)
		{
			if (dwPersistMask & STOCKPROP_BACKCOLOR)
				ar >> m_clrBackColor;
			else
				m_clrBackColor = AmbientBackColor();
		}

		if (dwStockPropMask & STOCKPROP_FONT)
		{
			BOOL bRead = FALSE;

			if (dwPersistMask & STOCKPROP_FONT)
			{
				BYTE bFlag;
				ar >> bFlag;
				if (bFlag != 0xFF)
				{
					CArchiveStream stm(&ar);
					LPSTREAM pstm = _AfxGetArchiveStream(ar, stm);
					LPFONT pFont = _AfxCreateFontFromStream(pstm);
					if (pFont != NULL)
					{
						m_font.SetFont(pFont);
						bRead = TRUE;
					}
				}
			}

			if (! bRead)
			{
				LPFONTDISP pFontDispAmbient = AmbientFont();
				m_font.InitializeFont(NULL, pFontDispAmbient);
				RELEASE(pFontDispAmbient);
			}

			OnFontChanged();
		}

		if (dwStockPropMask & STOCKPROP_BORDERSTYLE)
		{
			if (dwPersistMask & STOCKPROP_BORDERSTYLE)
			{
				short sBorderStyle = m_sBorderStyle;
				ar >> m_sBorderStyle;
				if (sBorderStyle != m_sBorderStyle)
					_AfxToggleBorderStyle(this);
			}
			else
			{
				m_sBorderStyle = 0;
			}
		}

		if (dwStockPropMask & STOCKPROP_ENABLED)
		{
			if (dwPersistMask & STOCKPROP_ENABLED)
			{
				BOOL bEnabled = m_bEnabled;
				ar >> m_bEnabled;
				if ((bEnabled != m_bEnabled) && (m_hWnd != NULL))
					::EnableWindow(m_hWnd, m_bEnabled);
			}
			else
			{
				m_bEnabled = TRUE;
			}
		}

		if (dwStockPropMask & STOCKPROP_APPEARANCE)
		{
			if (dwPersistMask & STOCKPROP_APPEARANCE)
			{
				short sAppearance = m_sAppearance;
				ar >> m_sAppearance;

				if (sAppearance != m_sAppearance)
					_AfxToggleAppearance(this);
			}
			else
			{
				m_sAppearance = AmbientAppearance();
			}
		}
	}
	else
	{
		ar << dwPersistMask;

		if (dwStockPropMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
			ar << m_strText;

		if (dwStockPropMask & STOCKPROP_FORECOLOR)
			ar << m_clrForeColor;

		if (dwStockPropMask & STOCKPROP_BACKCOLOR)
			ar << m_clrBackColor;

		if (dwStockPropMask & STOCKPROP_FONT)
		{
			BOOL bWrite = FALSE;
			LPFONT pFont = m_font.m_pFont;
			if (pFont != NULL)
			{
				// If same as ambient font (or error), write 0xFF for the flag
				LPFONTDISP pFontDispAmbient = AmbientFont();
				if (!_AfxIsSameFont(m_font, NULL, pFontDispAmbient))
				{
					LPPERSISTSTREAM pps = NULL;
					if (SUCCEEDED(pFont->QueryInterface(IID_IPersistStream,
						(LPVOID*)&pps)))
					{
						ASSERT_POINTER(pps, IPersistStream);
						ar << (BYTE)0x00;
						CArchiveStream stm(&ar);
						LPSTREAM pstm = _AfxGetArchiveStream(ar, stm);
						bWrite = SUCCEEDED(::OleSaveToStream(pps, pstm));
						pps->Release();
						if (!bWrite)
							AfxThrowArchiveException(CArchiveException::genericException);
					}
				}
				RELEASE(pFontDispAmbient);
			}
			if (! bWrite)
			{
				ar << (BYTE)0xFF;
			}
		}

		if (dwStockPropMask & STOCKPROP_BORDERSTYLE)
			ar << m_sBorderStyle;

		if (dwStockPropMask & STOCKPROP_ENABLED)
			ar << m_bEnabled;

		if (dwStockPropMask & STOCKPROP_APPEARANCE)
			ar << m_sAppearance;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Initialization for stock properties

void COleControl::ResetStockProps()
{
	DWORD dwStockPropMask = GetStockPropMask();

	if (dwStockPropMask & (STOCKPROP_CAPTION | STOCKPROP_TEXT))
	{
		TRY
			SetText(_T(""));
		END_TRY
	}

	if (dwStockPropMask & STOCKPROP_FORECOLOR)
		m_clrForeColor = AmbientForeColor();

	if (dwStockPropMask & STOCKPROP_BACKCOLOR)
		m_clrBackColor = AmbientBackColor();

	if (dwStockPropMask & STOCKPROP_FONT)
	{
		LPFONTDISP pFontDispAmbient = AmbientFont();
		m_font.InitializeFont(NULL, pFontDispAmbient);
		RELEASE(pFontDispAmbient);
		OnFontChanged();
	}

	if (dwStockPropMask & STOCKPROP_BORDERSTYLE)
		m_sBorderStyle = 0;

	if (dwStockPropMask & STOCKPROP_ENABLED)
		m_bEnabled = TRUE;

	if (dwStockPropMask & STOCKPROP_APPEARANCE)
		m_sAppearance = AmbientAppearance();
}

/////////////////////////////////////////////////////////////////////////////
// Appearance property

short COleControl::GetAppearance()
{
	return m_sAppearance;
}

void COleControl::SetAppearance(short sAppearance)
{
	if (sAppearance != 0 && sAppearance != 1)
		ThrowError(CTL_E_INVALIDPROPERTYVALUE, AFX_IDP_E_INVALIDPROPERTYVALUE);

	// Is the property changing?
	if (m_sAppearance == sAppearance)
		return;

	if (!BoundPropertyRequestEdit(DISPID_APPEARANCE))
		SetNotPermitted();

	ASSERT((m_hWnd == NULL) ||
		((GetExStyle() & WS_EX_CLIENTEDGE) == (DWORD)(m_sAppearance ?
			WS_EX_CLIENTEDGE : 0)));

	m_sAppearance = sAppearance;
	m_bModified = TRUE;

	_AfxToggleAppearance(this);
	OnAppearanceChanged();

	BoundPropertyChanged(DISPID_APPEARANCE);
}

void COleControl::OnAppearanceChanged()
{
	// Can be overridden by subclass

	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// BackColor property

OLE_COLOR COleControl::GetBackColor()
{
	return m_clrBackColor;
}

void COleControl::SetBackColor(OLE_COLOR clrBackColor)
{
	// Is the property changing?
	if (m_clrBackColor == clrBackColor)
		return;

	if (FAILED(::OleTranslateColor(clrBackColor, NULL, NULL)))
		ThrowError(CTL_E_INVALIDPROPERTYVALUE, AFX_IDP_E_INVALIDPROPERTYVALUE);

	if (!BoundPropertyRequestEdit(DISPID_BACKCOLOR))
		SetNotPermitted();

	m_clrBackColor = clrBackColor;
	m_bModified = TRUE;
	OnBackColorChanged();

	BoundPropertyChanged(DISPID_BACKCOLOR);
}

void COleControl::OnBackColorChanged()
{
	// Can be overridden by subclass
	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// BorderStyle property

short COleControl::GetBorderStyle()
{
	return m_sBorderStyle;
}

void COleControl::SetBorderStyle(short sBorderStyle)
{
	if (sBorderStyle != 0 && sBorderStyle != 1)
		ThrowError(CTL_E_INVALIDPROPERTYVALUE, AFX_IDP_E_INVALIDPROPERTYVALUE);

	// Is the property changing?
	if (m_sBorderStyle == sBorderStyle)
		return;

	if (!BoundPropertyRequestEdit(DISPID_BORDERSTYLE))
		SetNotPermitted();

	ASSERT((m_hWnd == NULL) ||
		((GetStyle() & WS_BORDER) == (DWORD)(m_sBorderStyle ? WS_BORDER : 0)));

	m_sBorderStyle = sBorderStyle;
	m_bModified = TRUE;

	_AfxToggleBorderStyle(this);
	OnBorderStyleChanged();

	BoundPropertyChanged(DISPID_BORDERSTYLE);
}

void COleControl::OnBorderStyleChanged()
{
	// Can be overridden by subclass

	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// Text and Caption properties

const CString& COleControl::InternalGetText()
{
	// Some subclassed controls (such as edit controls and comboboxes) change
	// the window text without sending WM_SETTEXT. Therefore, we need to
	// ensure that m_strText is up-to-date.

	if (m_hWnd != NULL && IsSubclassedControl())
	{
		// Usually, the window text will be shorter than 32 characters.
		// When it is, we can be more efficient.
		const int _cchUsual = 32;

		if (DefWindowProc(WM_GETTEXT, (WPARAM)_cchUsual,
			(LPARAM)m_strText.GetBufferSetLength(_cchUsual)) >= _cchUsual - 1)
		{
			// Text was too long: allocate a bigger buffer.

			int nLen = int(DefWindowProc(WM_GETTEXTLENGTH, (WPARAM)0, (LPARAM)0) + 1);
			DefWindowProc(WM_GETTEXT, (WPARAM)nLen,
				(LPARAM)m_strText.GetBufferSetLength(nLen));
		}
		m_strText.ReleaseBuffer();
	}

	return m_strText;
}

BSTR COleControl::GetText()
{
	return ((CString&)InternalGetText()).AllocSysString();
}

void COleControl::SetText(LPCTSTR pszText)
{
	LRESULT lResult;
	if (m_hWnd != NULL)
		lResult = SendMessage(WM_SETTEXT, 0, (LPARAM)pszText);
	else
		lResult = OnSetText(0, (LPARAM)pszText);

	if (lResult == -1)
		SetNotPermitted();
}

LRESULT COleControl::OnSetText(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam == 0 || AfxIsValidString((LPCTSTR)lParam));

	CString str = InternalGetText();

	// Is the property changing?
	if ((lParam == 0 && str.IsEmpty()) ||
		(lParam != 0 && str == (LPCTSTR)lParam))
		return 0;

	DWORD dwStockPropMask = GetStockPropMask();

	if (dwStockPropMask & STOCKPROP_CAPTION)
		if (!BoundPropertyRequestEdit(DISPID_CAPTION))
			return -1;

	if (dwStockPropMask & STOCKPROP_TEXT)
		if (!BoundPropertyRequestEdit(DISPID_TEXT))
			return -1;

	LRESULT lResult = 0;
	m_strText = (LPCTSTR)lParam;
	m_bModified = TRUE;

	if (m_hWnd != NULL)
		lResult = DefWindowProc(WM_SETTEXT, wParam, lParam);

	OnTextChanged();

	if (dwStockPropMask & STOCKPROP_CAPTION)
		BoundPropertyChanged(DISPID_CAPTION);

	if (dwStockPropMask & STOCKPROP_TEXT)
		BoundPropertyChanged(DISPID_TEXT);

	return lResult;
}

void COleControl::OnTextChanged()
{
	// Can be overridden by subclass
	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// Enabled property

BOOL COleControl::GetEnabled()
{
	return m_bEnabled;
}

void COleControl::SetEnabled(BOOL bEnabled)
{
	// Is the property changing?
	if (m_bEnabled == bEnabled)
		return;

	if (!BoundPropertyRequestEdit(DISPID_ENABLED))
		SetNotPermitted();

	m_bEnabled = bEnabled;
	m_bModified = TRUE;
	if (m_hWnd != NULL)
		::EnableWindow(m_hWnd, m_bEnabled);

	// If the control is UI Active and the Enabled property changed to FALSE,
	// then UI Deactivate the control.

	if (m_bUIActive && !bEnabled)
		m_xOleInPlaceObject.UIDeactivate();

	OnEnabledChanged();

	BoundPropertyChanged(DISPID_ENABLED);
}

void COleControl::OnEnabledChanged()
{
	// Can be overridden by subclass
	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// Font property

CFontHolder& COleControl::InternalGetFont()
{
	return m_font;
}

LPFONTDISP COleControl::GetFont()
{
	return m_font.GetFontDispatch();
}

void COleControl::SetFont(LPFONTDISP pFontDisp)
{
	ASSERT((pFontDisp == NULL) ||
		   AfxIsValidAddress(pFontDisp, sizeof(IDispatch), FALSE));

	m_font.InitializeFont(NULL, pFontDisp);
	m_bModified = TRUE;
	OnFontChanged();

	BoundPropertyChanged(DISPID_FONT);
}

void COleControl::OnFontChanged()
{
	// Can be overridden by subclass

	// Send WM_SETFONT to control's window
	if ((m_hWnd != NULL) &&
		(GetStockPropMask() & STOCKPROP_FONT) &&
		IsSubclassedControl())
	{
		CFontHolder& font = InternalGetFont();

		if (font.m_pFont != NULL)
		{
			HFONT hFont = font.GetFontHandle();
			font.m_pFont->AddRefHfont(hFont);
			SendMessage(WM_SETFONT, (WPARAM)hFont, 0);

			if (m_hFontPrev != NULL)
			{
				font.m_pFont->ReleaseHfont(m_hFontPrev);
			}
			m_hFontPrev = hFont;
		}
		else
		{
			SendMessage(WM_SETFONT, NULL, 0);
			m_hFontPrev = NULL;
		}
	}

	// Invalidate the control
	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// ForeColor property

OLE_COLOR COleControl::GetForeColor()
{
	return m_clrForeColor;
}

void COleControl::SetForeColor(OLE_COLOR clrForeColor)
{
	// Is the property changing?
	if (m_clrForeColor == clrForeColor)
		return;

	if (FAILED(::OleTranslateColor(clrForeColor, NULL, NULL)))
		ThrowError(CTL_E_INVALIDPROPERTYVALUE, AFX_IDP_E_INVALIDPROPERTYVALUE);

	if (!BoundPropertyRequestEdit(DISPID_FORECOLOR))
		SetNotPermitted();

	m_clrForeColor = clrForeColor;
	m_bModified = TRUE;
	OnForeColorChanged();

	BoundPropertyChanged(DISPID_FORECOLOR);
}

void COleControl::OnForeColorChanged()
{
	// Can be overridden by subclass
	InvalidateControl();
}

/////////////////////////////////////////////////////////////////////////////
// hWnd property

OLE_HANDLE COleControl::GetHwnd()
{
#ifdef _AFXDLL
	return (OLE_HANDLE)(DWORD_PTR)((m_bInPlaceActive || m_bOpen) ? m_hWnd : NULL);
#else
	return (OLE_HANDLE)(DWORD_PTR)(m_bInPlaceActive ? m_hWnd : NULL);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// ReadyState property

long COleControl::GetReadyState()
{
	return m_lReadyState;
}

////////////////////////////////////////////////////////////////////////////
// COleControl::XFontNotification

STDMETHODIMP_(ULONG) COleControl::XFontNotification::AddRef()
{
	return 1;
}

STDMETHODIMP_(ULONG) COleControl::XFontNotification::Release()
{
	return 0;
}

STDMETHODIMP COleControl::XFontNotification::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	ASSERT(ppvObj != NULL);

	if (IsEqualIID(iid, IID_IUnknown) ||
		IsEqualIID(iid, IID_IPropertyNotifySink))
	{
		*ppvObj = this;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP COleControl::XFontNotification::OnChanged(DISPID)
{
	METHOD_PROLOGUE_EX(COleControl, FontNotification)
	pThis->OnFontChanged();
	pThis->m_bModified = TRUE;
	pThis->BoundPropertyChanged(DISPID_FONT);
	return S_OK;
}

STDMETHODIMP COleControl::XFontNotification::OnRequestEdit(DISPID)
{
	return S_OK;
}

CFont* COleControl::SelectStockFont(CDC* pDC)
{
	return SelectFontObject(pDC, m_font);
}

CFont* COleControl::SelectFontObject(CDC* pDC, CFontHolder& fontHolder)
{
	return fontHolder.Select(pDC, m_rcBounds.Height(), m_cyExtent);
}

void COleControl::GetStockTextMetrics(LPTEXTMETRIC lptm)
{
	m_font.QueryTextMetrics(lptm);
}

void COleControl::GetFontTextMetrics(LPTEXTMETRIC lptm, CFontHolder& fontHolder)
{
	fontHolder.QueryTextMetrics(lptm);
}

/////////////////////////////////////////////////////////////////////////////
// Ambient property access

BOOL AFXAPI _GetI4Property(LPDISPATCH pDispatch, DISPID dwDispID, DWORD* pdwResult)
{
	if (pDispatch == NULL)
		return FALSE;

	DISPPARAMS dispparams;
	memset(&dispparams, 0, sizeof dispparams);

	VARIANT vaResult;
	AfxVariantInit(&vaResult);

	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr = (UINT)-1;  // initialize to invalid arg

	HRESULT hr = pDispatch->Invoke(dwDispID, IID_NULL, 0, DISPATCH_PROPERTYGET,
		&dispparams, &vaResult, &excepInfo, &nArgErr);

	if (SUCCEEDED(hr))
	{
		if ((V_VT(&vaResult) == VT_I4) ||
			SUCCEEDED(VariantChangeType(&vaResult, &vaResult, 0, VT_I4)))
		{
			*pdwResult = V_I4(&vaResult);
			return TRUE;
		}
	}

	VariantClear(&vaResult);

    ::SysFreeString(excepInfo.bstrSource);
    ::SysFreeString(excepInfo.bstrDescription);
    ::SysFreeString(excepInfo.bstrHelpFile);

	return FALSE;
}

COleDispatchDriver* COleControl::GetAmbientDispatchDriver()
{
	if (m_ambientDispDriver.m_lpDispatch == NULL)
	{
		// Initialize pointer to ambient property dispinterface.
		IDispatch* pDispatch = NULL;

		if (m_pClientSite != NULL &&
			SUCCEEDED(m_pClientSite->QueryInterface(IID_IDispatch,
				reinterpret_cast<void**>(&pDispatch))))
		{
			ASSERT(pDispatch != NULL);
			m_ambientDispDriver.AttachDispatch(pDispatch);
		}
	}

	return &m_ambientDispDriver;
}

AFX_STATIC_DATA const DWORD _afxAmbientFlags[] =
{
	QACONTAINER_MESSAGEREFLECT,     // -706
	0,                              // -707
	0,                              // -708
	QACONTAINER_USERMODE,           // -709
	QACONTAINER_UIDEAD,             // -710
	QACONTAINER_SHOWGRABHANDLES,    // -711
	QACONTAINER_SHOWHATCHING,       // -712
	QACONTAINER_DISPLAYASDEFAULT,   // -713
	QACONTAINER_SUPPORTSMNEMONICS,  // -714
	QACONTAINER_AUTOCLIP,           // -715
};

BOOL COleControl::GetAmbientProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp)
{
	// First, check whether ambient property can be obtained from cache.

	_AFXCTL_AMBIENT_CACHE* pAmbientCache = _afxAmbientCache;
	if (pAmbientCache->m_bValid)
	{
		switch (vtProp)
		{
		// Fetch boolean by selecting appropriate flag in cache.
		case VT_BOOL:
			{
				int nIndex = DISPID_AMBIENT_MESSAGEREFLECT - dwDispID;
				DWORD dwFlag;
				if (nIndex >= 0 && nIndex < _countof(_afxAmbientFlags) &&
					(dwFlag = _afxAmbientFlags[nIndex]) != 0)
				{
					*(BOOL*)pvProp =
						((pAmbientCache->m_dwAmbientFlags & dwFlag) != 0);
					return TRUE;
				}
			}
			break;

		// Fetch color, appearance, or font from corresponding cache entry.
		case VT_I4:
			switch (dwDispID)
			{
			case DISPID_AMBIENT_FORECOLOR:
				*(DWORD*)pvProp = pAmbientCache->m_colorFore;
				return TRUE;

			case DISPID_AMBIENT_BACKCOLOR:
				*(DWORD*)pvProp = pAmbientCache->m_colorBack;
				return TRUE;

			case DISPID_AMBIENT_APPEARANCE:
				*(DWORD*)pvProp = pAmbientCache->m_dwAppearance;
				return TRUE;
			}
			break;

		case VT_I2:
			if (dwDispID == DISPID_AMBIENT_APPEARANCE)
			{
				*(short*)pvProp = (short)pAmbientCache->m_dwAppearance;
				return TRUE;
			}
			break;

		case VT_DISPATCH:
			if ((dwDispID == DISPID_AMBIENT_FONT) &&
				(pAmbientCache->m_pFont != NULL) &&
				SUCCEEDED(pAmbientCache->m_pFont->QueryInterface(IID_IFontDisp,
					reinterpret_cast<void**>(pvProp))))
			{
				return TRUE;
			}
			break;
		}
	}

	// If there's no ambient dispatch interface available, then fail.

	COleDispatchDriver* pDispDriver = GetAmbientDispatchDriver();
	if (pDispDriver->m_lpDispatch == NULL)
		return FALSE;

	// If requested property is of type VT_I4, use optimized function.

	if (vtProp == VT_I4)
		return _GetI4Property(pDispDriver->m_lpDispatch, dwDispID,
			(DWORD*)pvProp);

	// If none of the above apply, just use the dispatch driver.

	BOOL bSuccess = FALSE;
	TRY
	{
		pDispDriver->GetProperty(dwDispID, vtProp, pvProp);
		bSuccess = TRUE;
	}
	END_TRY

	return bSuccess;
}

short COleControl::AmbientAppearance()
{
	DWORD dwAppearance;
	if (!GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, VT_I4, &dwAppearance))
		dwAppearance = 0;
	return (short)dwAppearance;
}

OLE_COLOR COleControl::AmbientBackColor()
{
	OLE_COLOR clrBackColor;
	if (!GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, VT_I4, &clrBackColor))
		clrBackColor = GetSysColor(COLOR_WINDOW);
	return clrBackColor;
}

CString COleControl::AmbientDisplayName()
{
	CString strDisplayName;
	GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, VT_BSTR, &strDisplayName);
	return strDisplayName;
}

LPFONTDISP COleControl::AmbientFont()
{
	// Note: Caller MUST Release the font!
	LPFONTDISP pDisp;
	if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pDisp))
		pDisp = NULL;
	return pDisp;
}

OLE_COLOR COleControl::AmbientForeColor()
{
	OLE_COLOR clrForeColor;
	if (!GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, VT_I4, &clrForeColor))
		clrForeColor = GetSysColor(COLOR_WINDOWTEXT);
	return clrForeColor;
}

LCID COleControl::AmbientLocaleID()
{
	LCID lcid;
	if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &lcid))
		lcid = 0;
	return lcid;
}

CString COleControl::AmbientScaleUnits()
{
	CString strScaleUnits;
	GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, VT_BSTR, &strScaleUnits);
	return strScaleUnits;
}

short COleControl::AmbientTextAlign()
{
	short iTextAlign;
	if (!GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, VT_I2, &iTextAlign))
		iTextAlign = 0;
	return iTextAlign;
}

BOOL COleControl::AmbientUserMode()
{
	BOOL bUserMode;
	if (!GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &bUserMode))
		bUserMode = TRUE;
	return bUserMode;
}

BOOL COleControl::AmbientUIDead()
{
	BOOL bUIDead;
	if (!GetAmbientProperty(DISPID_AMBIENT_UIDEAD, VT_BOOL, &bUIDead))
		bUIDead = FALSE;
	return bUIDead;
}

BOOL COleControl::AmbientShowGrabHandles()
{
	BOOL bShowGrab;
	if (!GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, VT_BOOL, &bShowGrab))
		bShowGrab = TRUE;
	return bShowGrab;
}

BOOL COleControl::AmbientShowHatching()
{
	BOOL bShowHatch;
	if (!GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, VT_BOOL, &bShowHatch))
		bShowHatch = TRUE;
	return bShowHatch;
}

/////////////////////////////////////////////////////////////////////////////
// Calls to IPropertyNotifySink

void COleControl::BoundPropertyChanged(DISPID dispid)
{
	POSITION pos = m_xPropConnPt.GetStartPosition();
	LPPROPERTYNOTIFYSINK pPropNotifySink;

	while (pos != NULL)
	{
		pPropNotifySink =
			(LPPROPERTYNOTIFYSINK)m_xPropConnPt.GetNextConnection(pos);
		if(pPropNotifySink != NULL)
        	pPropNotifySink->OnChanged(dispid);
	}
}

BOOL COleControl::BoundPropertyRequestEdit(DISPID dispid)
{
	POSITION pos = m_xPropConnPt.GetStartPosition();
	LPPROPERTYNOTIFYSINK pPropNotifySink;

	while (pos != NULL)
	{
		pPropNotifySink =
			(LPPROPERTYNOTIFYSINK)m_xPropConnPt.GetNextConnection(pos);
		if (pPropNotifySink != NULL && pPropNotifySink->OnRequestEdit(dispid) != S_OK)
			return FALSE;
	}

	// All of the sinks said yes, so it's ok.
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Function to call when BoundPropertyRequestEdit fails

void COleControl::SetNotPermitted()
{
	ThrowError(CTL_E_SETNOTPERMITTED, AFX_IDP_E_SETNOTPERMITTED);
}

/////////////////////////////////////////////////////////////////////////////
// Placeholder functions for read-only or write-only properties

void COleControl::SetNotSupported()
{
	ThrowError(CTL_E_SETNOTSUPPORTED, AFX_IDP_E_SETNOTSUPPORTED);
}

void COleControl::GetNotSupported()
{
	ThrowError(CTL_E_GETNOTSUPPORTED, AFX_IDP_E_GETNOTSUPPORTED);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPerPropertyBrowsing

STDMETHODIMP_(ULONG) COleControl::XPerPropertyBrowsing::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PerPropertyBrowsing)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPerPropertyBrowsing::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PerPropertyBrowsing)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPerPropertyBrowsing::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PerPropertyBrowsing)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPerPropertyBrowsing::GetDisplayString(
	DISPID dispid, BSTR* lpbstr)
{
	METHOD_PROLOGUE_EX(COleControl, PerPropertyBrowsing)

	ASSERT_NULL_OR_POINTER(lpbstr, BSTR);

	CString strValue;
	BOOL bSuccess = pThis->OnGetDisplayString(dispid, strValue);

	if (lpbstr != NULL)
		*lpbstr = (bSuccess ? strValue.AllocSysString() : NULL);

	return bSuccess ? S_OK : S_FALSE;
}

BOOL COleControl::OnGetDisplayString(DISPID dispid, CString& strValue)
{
	TRY
	{
		switch (dispid)
		{
		case DISPID_FONT:
			return m_font.GetDisplayString(strValue);

		case DISPID_BORDERSTYLE:
			return strValue.LoadString(m_sBorderStyle == 0 ?
				AFX_IDS_BORDERSTYLE_0 : AFX_IDS_BORDERSTYLE_1);
		}
	}
	END_TRY

	return FALSE;
}

STDMETHODIMP COleControl::XPerPropertyBrowsing::MapPropertyToPage(
	DISPID dispid, LPCLSID lpclsid)
{
	METHOD_PROLOGUE_EX(COleControl, PerPropertyBrowsing)

	ASSERT_NULL_OR_POINTER(lpclsid, CLSID);

	CLSID clsid = GUID_NULL;
	BOOL bPageOptional = FALSE;
	BOOL bSuccess = pThis->OnMapPropertyToPage(dispid, &clsid, &bPageOptional);

	if (lpclsid != NULL)
		*lpclsid = (bSuccess ? clsid : GUID_NULL);

	return bSuccess ? (bPageOptional ? S_OK : S_FALSE) :
		PERPROP_E_NOPAGEAVAILABLE;
}

BOOL COleControl::OnMapPropertyToPage(DISPID dispid, LPCLSID lpclsid,
	BOOL* pbPageOptional)
{
	switch (dispid)
	{
	case DISPID_FONT:
		*lpclsid = CLSID_StockFontPage;
		*pbPageOptional = TRUE;
		return TRUE;

	case DISPID_BACKCOLOR:
	case DISPID_FORECOLOR:
		*lpclsid = CLSID_StockColorPage;
		*pbPageOptional = TRUE;
		return TRUE;
	}

	return FALSE;
}

inline LPOLESTR AFXAPI _AfxCopyString(LPCTSTR psz)
{
	if (psz == NULL)
		return NULL;

	int cch = lstrlen(psz) + 1;
	LPOLESTR pszCopy = NULL;
	if (cch > size_t(-1) / sizeof(OLECHAR))
	{
		return NULL;
	}
	if ((pszCopy = (LPOLESTR)::ATL::AtlCoTaskMemCAlloc(cch, sizeof(OLECHAR))) != NULL)
	{
#ifdef _UNICODE
		Checked::wcscpy_s(pszCopy, cch, psz);
#else
		MultiByteToWideChar(CP_ACP, 0, psz, -1, pszCopy, cch);
#endif
	}

	return pszCopy;
}

STDMETHODIMP COleControl::XPerPropertyBrowsing::GetPredefinedStrings(
	DISPID dispid, CALPOLESTR* lpcaStringsOut, CADWORD* lpcaCookiesOut)
{
	METHOD_PROLOGUE_EX(COleControl, PerPropertyBrowsing)

	if ((lpcaStringsOut == NULL) || (lpcaCookiesOut == NULL))
		return E_POINTER;

	ASSERT_POINTER(lpcaStringsOut, CALPOLESTR);
	ASSERT_POINTER(lpcaCookiesOut, CADWORD);

	CStringArray stringArray;
	CDWordArray cookieArray;

	BOOL bSuccess = pThis->OnGetPredefinedStrings(dispid, &stringArray,
		&cookieArray);

	if (bSuccess)
	{
		// Allocate and fill arrays to return.

		ASSERT(stringArray.GetSize() == cookieArray.GetSize());

		int iElem = 0;
		LPOLESTR lpszCopy;
		ULONG cElems = (ULONG)stringArray.GetSize();
		
		if ((cElems <= 0) || (cElems > (ULONG_MAX /sizeof(LPOLESTR))) || (cElems > (ULONG_MAX /sizeof(DWORD*))))
			return E_OUTOFMEMORY;

		lpcaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc(
			sizeof(LPOLESTR) * cElems);

		if (lpcaStringsOut->pElems == NULL)
			return E_OUTOFMEMORY;

		lpcaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc(
			sizeof(DWORD*) * cElems);

		if (lpcaCookiesOut->pElems == NULL)
		{
			CoTaskMemFree(lpcaStringsOut->pElems);
			return E_OUTOFMEMORY;
		}

		lpcaStringsOut->cElems = cElems;
		lpcaCookiesOut->cElems = cElems;

		for (iElem = 0; iElem < (int)cElems; iElem++)
		{
			lpszCopy = _AfxCopyString(stringArray.GetAt(iElem));

			if (lpszCopy == NULL)
			{
				// cleanup everything allocated so far...
				while (--iElem >= 0)
					CoTaskMemFree(lpcaStringsOut->pElems[iElem]);

				CoTaskMemFree(lpcaCookiesOut->pElems);
				CoTaskMemFree(lpcaStringsOut->pElems);

				return E_OUTOFMEMORY;
			}

			lpcaStringsOut->pElems[iElem] = lpszCopy;
			lpcaCookiesOut->pElems[iElem] = cookieArray.GetAt(iElem);
		}
	}

	return bSuccess ? S_OK : S_FALSE;
}

BOOL COleControl::OnGetPredefinedStrings(DISPID dispid,
	CStringArray* pStringArray, CDWordArray* pCookieArray)
{
	BOOL bResult = FALSE;

	switch (dispid)
	{
	case DISPID_BORDERSTYLE:
		TRY
		{
			CString str;
			str.LoadString(AFX_IDS_BORDERSTYLE_0);
			pStringArray->Add(str);
			pCookieArray->Add(0);
			str.LoadString(AFX_IDS_BORDERSTYLE_1);
			pStringArray->Add(str);
			pCookieArray->Add(1);
			bResult = TRUE;
		}
		CATCH (CException, e)
		{
			pStringArray->RemoveAll();
			pCookieArray->RemoveAll();
			bResult = FALSE;
		}
		END_CATCH
		break;
	}

	return bResult;
}

STDMETHODIMP COleControl::XPerPropertyBrowsing::GetPredefinedValue(
	DISPID dispid, DWORD dwCookie, VARIANT* lpvarOut)
{
	METHOD_PROLOGUE_EX(COleControl, PerPropertyBrowsing)

	ASSERT_POINTER(lpvarOut, VARIANT);

	return pThis->OnGetPredefinedValue(dispid, dwCookie, lpvarOut) ?
		S_OK : E_FAIL;
}

BOOL COleControl::OnGetPredefinedValue(DISPID dispid, DWORD dwCookie,
	VARIANT* lpvarOut)
{
	switch (dispid)
	{
	case DISPID_BORDERSTYLE:
		if ((dwCookie == 0) || (dwCookie == 1))
		{
			VariantClear(lpvarOut);
			V_VT(lpvarOut) = VT_I4;
			V_I4(lpvarOut) = dwCookie;
			return TRUE;
		}
		break;
	}

	return FALSE;
}

void COleControl::Load(LPCTSTR strNewPath, CDataPathProperty& prop)
{
	prop.SetControl(this);
	prop.Open(strNewPath);
}

/////////////////////////////////////////////////////////////////////////////
// CDataPathProperty implementation

BOOL CDataPathProperty::Open(CFileException* pError)
{
	return CAsyncMonikerFile::Open(m_strPath, m_pControl ? m_pControl->GetClientSite() : NULL, pError);
}

BOOL CDataPathProperty::Open(LPCTSTR lpszPath, CFileException* pError)
{
	SetPath(lpszPath);
	return Open(pError);
}

BOOL CDataPathProperty::Open(COleControl* pControl, CFileException* pError)
{
	SetControl(pControl);
	return Open(pError);
}

BOOL CDataPathProperty::Open(LPCTSTR lpszPath, COleControl* pControl, CFileException* pError)
{
	SetControl(pControl);
	SetPath(lpszPath);
	return Open(pError);
}

void CDataPathProperty::ResetData()
{
}

#ifdef _DEBUG
void CDataPathProperty::AssertValid() const
{
	CAsyncMonikerFile::AssertValid();
}

void CDataPathProperty::Dump(CDumpContext& dc) const
{
	CAsyncMonikerFile::Dump(dc);

	dc << "\nm_pControl = " << m_pControl;
	dc << "\nm_strPath = \"" << m_strPath;
	dc << "\"\n";
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CCachedDataPathProperty implementation

AFX_STATIC inline DWORD _AfxTransferFileContent(CFile* pFrom, CFile* pTo)
{
	BYTE buff[1024];
	DWORD dwRead = 0;
	DWORD dwActual;
	do
	{
		dwActual = pFrom->Read(buff, 1024);
		pTo->Write(buff, dwActual);

		dwRead += dwActual;
	}
	while (dwActual > 0);
	return dwRead;
}

void CCachedDataPathProperty::OnDataAvailable(DWORD dwSize, DWORD bscfFlag)
{
	UNUSED_ALWAYS(bscfFlag);
	UNUSED_ALWAYS(dwSize);
	ULONGLONG dwPos = m_Cache.GetPosition();
	TRY
	{
		// Cache the data in our mem file.
		m_Cache.SeekToEnd();
		_AfxTransferFileContent(this, &m_Cache);
	}
	CATCH_ALL(e)
	{
		m_Cache.Seek(dwPos, CFile::begin);
		THROW_LAST();
	}
	END_CATCH_ALL
	m_Cache.Seek(dwPos, CFile::begin);
}

void CCachedDataPathProperty::Close()
{
	m_Cache.SetLength(0);
	CDataPathProperty::Close();
}

void CCachedDataPathProperty::ResetData()
{
	m_Cache.SetLength(0);
}
#ifdef _DEBUG
void CCachedDataPathProperty::AssertValid() const
{
	CDataPathProperty::AssertValid();
	m_Cache.AssertValid();
}

void CCachedDataPathProperty::Dump(CDumpContext& dc) const
{
	CDataPathProperty::Dump(dc);

	m_Cache.Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG


IMPLEMENT_DYNAMIC(CDataPathProperty, CAsyncMonikerFile)
IMPLEMENT_DYNAMIC(CCachedDataPathProperty, CDataPathProperty)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpropx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#ifdef _DEBUG
#define ASSERT_BUFFER_VALID(p, cb, bWrite) \
	ASSERT(AfxIsValidAddress(p, cb, bWrite))
#else
#define ASSERT_BUFFER_VALID(p, cb, bWrite)
#endif

// Old class ID for picture type
AFX_STATIC_DATA const CLSID _afx_CLSID_StdPicture2_V1 =
	{ 0xfb8f0824,0x0164,0x101b, { 0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13 } };

/////////////////////////////////////////////////////////////////////////////
// _AfxGetArchiveStream

LPSTREAM AFXAPI _AfxGetArchiveStream(CArchive& ar, CArchiveStream& stm)
{
	// Obtain direct access to the archive's LPSTREAM.
	ar.Flush();
	CFile* pFile = ar.GetFile();
	ASSERT(pFile != NULL);
	LPSTREAM pstm;
	if (pFile->IsKindOf(RUNTIME_CLASS(COleStreamFile)))
	{
		pstm = ((COleStreamFile*)pFile)->m_lpStream;
		ASSERT(pstm != NULL);
	}
	else
	{
		ASSERT(stm.m_pArchive == NULL || stm.m_pArchive == &ar);
		stm.m_pArchive = &ar;
		pstm = &stm;
	}
	return pstm;
}

/////////////////////////////////////////////////////////////////////////////
// _AfxInitBlob

BOOL AFXAPI _AfxInitBlob(HGLOBAL* phDst, void* pvSrc)
{
	BOOL bResult = FALSE;
	ULONG cb;
	if ((cb = *(long*)pvSrc) > 0)
	{
		ASSERT_BUFFER_VALID(pvSrc, sizeof(cb) + cb, TRUE);
		*phDst = GlobalAlloc(GMEM_MOVEABLE, sizeof(cb) + cb);
		if (*phDst != NULL)
		{
			void* pvDst = GlobalLock(*phDst);
			ASSERT(pvDst != NULL);
			Checked::memcpy_s(pvDst, ::GlobalSize(*phDst), pvSrc, sizeof(cb) + cb);
			bResult = TRUE;
			GlobalUnlock(*phDst);
		}
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// _AfxCopyBlob

BOOL AFXAPI _AfxCopyBlob(HGLOBAL* phDst, HGLOBAL hSrc)
{
	BOOL bResult = FALSE;
	void* pvSrc = GlobalLock(hSrc);
	if (pvSrc != NULL)
	{
		bResult = _AfxInitBlob(phDst, pvSrc);
		GlobalUnlock(hSrc);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// _AfxCopyPropValue

BOOL AFXAPI _AfxCopyPropValue(VARTYPE vtProp, void* pvDest, const void * pvSrc)
{
	ASSERT(AfxIsValidAddress(pvDest, 1));

	if (pvSrc != NULL)
	{
		ASSERT(AfxIsValidAddress(pvSrc, 1, FALSE));

		switch (vtProp)
		{
		case VT_UI1:
			*(BYTE*)pvDest = *(BYTE*)pvSrc;
			break;
		case VT_I2:
			*(short*)pvDest = *(short*)pvSrc;
			break;
		case VT_I4:
			*(long*)pvDest = *(long*)pvSrc;
			break;
		case VT_BOOL:
			*(BOOL*)pvDest = *(BOOL*)pvSrc;
			break;
		case VT_BSTR:
			*(CString*)pvDest = *(CString*)pvSrc;
			break;
		case VT_LPSTR:
			*(CString*)pvDest = (LPCTSTR)pvSrc;
			break;
		case VT_CY:
			*(CY*)pvDest = *(CY*)pvSrc;
			break;
		case VT_R4:
			*(float*)pvDest = *(float*)pvSrc;
			break;
		case VT_R8:
			*(double*)pvDest = *(double*)pvSrc;
			break;
		default:
			return FALSE;
		}
	}
	return pvSrc != NULL;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::ExchangeExtent

BOOL COleControl::ExchangeExtent(CPropExchange* pPX)
{
	// Save extent
	SIZEL szl;
	szl.cx = m_cxExtent;
	szl.cy = m_cyExtent;

	if (PX_Long(pPX, _T("_ExtentX"), szl.cx) &&
		PX_Long(pPX, _T("_ExtentY"), szl.cy))
	{
		if ((pPX->IsLoading()) &&
			((m_cxExtent != szl.cx) || (m_cyExtent != szl.cy)))
		{
			m_xOleObject.SetExtent(DVASPECT_CONTENT, &szl);
		}
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization for version number

DWORD COleControl::SerializeVersion(CArchive& ar, DWORD dwVersionDefault,
	BOOL bConvert)
{
	DWORD dwVersion;

	if (ar.IsLoading())
	{
		ar >> m_dwVersionLoaded;
		dwVersion = m_dwVersionLoaded;
	}
	else
	{
		dwVersion = bConvert ? dwVersionDefault : m_dwVersionLoaded;
		ar << dwVersion;
	}

	return dwVersion;
}

/////////////////////////////////////////////////////////////////////////////
// Initialization for version number

void COleControl::ResetVersion(DWORD dwVersionDefault)
{
	m_dwVersionLoaded = dwVersionDefault;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization for extent

void COleControl::SerializeExtent(CArchive& ar)
{
	if (ar.IsLoading())
	{
		SIZEL szl;
		ar >> szl.cx;
		ar >> szl.cy;
		if ((m_cxExtent != szl.cx) || (m_cyExtent != szl.cy))
			m_xOleObject.SetExtent(DVASPECT_CONTENT, &szl);
	}
	else
	{
		ar << m_cxExtent;
		ar << m_cyExtent;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropExchange member functions

BOOL CPropExchange::ExchangeVersion(DWORD& dwVersionLoaded,
	DWORD dwVersionDefault, BOOL bConvert)
{
	BOOL bResult;
	if (m_bLoading)
	{
		bResult = PX_ULong(this, _T("_Version"), m_dwVersion,
			dwVersionDefault);
		dwVersionLoaded = m_dwVersion;
	}
	else
	{
		m_dwVersion = bConvert ? dwVersionDefault : dwVersionLoaded;
		bResult = PX_ULong(this, _T("_Version"), m_dwVersion);
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CArchivePropExchange member functions

CArchivePropExchange::CArchivePropExchange(CArchive& ar) :
	m_ar(ar)
{
	ASSERT_POINTER(&ar, CArchive);
	m_bLoading = m_ar.IsLoading();
}

BOOL CArchivePropExchange::ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
		void* pvProp, const void* pvDefault)
{
	UNUSED(pszPropName);     // unused in release builds
	UNUSED(pvDefault);       // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT(AfxIsValidAddress(pvProp, 1, FALSE));
	ASSERT((pvDefault == NULL) || AfxIsValidAddress(pvDefault, 1, FALSE));

	if (m_bLoading)
	{
		switch (vtProp)
		{
		case VT_UI1:
			m_ar >> *(BYTE*)pvProp;
			break;
		case VT_I2:
			m_ar >> *(WORD*)pvProp;
			break;
		case VT_I4:
			m_ar >> *(long*)pvProp;
			break;
		case VT_BOOL:
			*(BOOL*)pvProp = 0;
			m_ar >> *(BYTE*)pvProp;
			break;
		case VT_LPSTR:
		case VT_BSTR:
			m_ar >> *(CString*)pvProp;
			break;
		case VT_CY:
			m_ar >> ((CY*)pvProp)->Lo;
			m_ar >> ((CY*)pvProp)->Hi;
			break;
		case VT_R4:
			m_ar >> *(float*)pvProp;
			break;
		case VT_R8:
			m_ar >> *(double*)pvProp;
			break;
		}
	}
	else
	{
		switch (vtProp)
		{
		case VT_UI1:
			m_ar << *(BYTE*)pvProp;
			break;
		case VT_I2:
			m_ar << *(WORD*)pvProp;
			break;
		case VT_I4:
			m_ar << *(long*)pvProp;
			break;
		case VT_BOOL:
			m_ar << *(BYTE*)pvProp;
			break;
		case VT_LPSTR:
		case VT_BSTR:
			m_ar << *(CString*)pvProp;
			break;
		case VT_CY:
			m_ar << ((CY*)pvProp)->Lo;
			m_ar << ((CY*)pvProp)->Hi;
			break;
		case VT_R4:
			m_ar << *(float*)pvProp;
			break;
		case VT_R8:
			m_ar << *(double*)pvProp;
			break;
		}
	}

	return TRUE;
}

BOOL CArchivePropExchange::ExchangeBlobProp(LPCTSTR pszPropName,
	HGLOBAL* phBlob, HGLOBAL /*hBlobDefault*/)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(phBlob, HGLOBAL);

	DWORD cb;

	if (m_bLoading)
	{
		// free previous memory block
		if (*phBlob != NULL)
		{
			GlobalFree(*phBlob);
			*phBlob = NULL;
		}

		// read new size
		m_ar >> cb;

		// allocate and fill new memory block
		*phBlob = GlobalAlloc(GMEM_MOVEABLE, sizeof(cb)+cb);
		if (*phBlob != NULL)
		{
			void* pvBlob = GlobalLock(*phBlob);
			ASSERT(pvBlob != NULL);
			*(long*)pvBlob = cb;
			m_ar.EnsureRead((BYTE*)pvBlob+sizeof(cb), cb);
			GlobalUnlock(*phBlob);
		}
	}
	else
	{
		if (*phBlob != NULL)
		{
			void* pvBlob = GlobalLock(*phBlob);
			ASSERT(pvBlob != NULL);
			cb = *(long*)pvBlob;
			ASSERT_BUFFER_VALID(pvBlob, sizeof(cb)+cb, FALSE);
			m_ar.Write(pvBlob, sizeof(cb)+cb);
			GlobalUnlock(*phBlob);
		}
		else
			m_ar << (DWORD)0;
	}
	return TRUE;
}

BOOL AFXAPI _AfxPeekAtClassIDInStream(LPSTREAM pstm, LPCLSID lpClassID)
{
	// Read the class ID, then restore the seek pointer.
	LARGE_INTEGER li;
	li.LowPart = (DWORD)(-(long)sizeof(CLSID));
	li.HighPart = -1;

	return (SUCCEEDED(ReadClassStm(pstm, lpClassID)) &&
		SUCCEEDED(pstm->Seek(li, STREAM_SEEK_CUR, NULL)));
}

BOOL AFXAPI _AfxIsSameUnknownObject(REFIID iid, LPUNKNOWN pUnk1, LPUNKNOWN pUnk2)
{
	if (pUnk1 == pUnk2)
		return TRUE;

	if (pUnk1 == NULL || pUnk2 == NULL)
		return FALSE;

	LPUNKNOWN pI1 = NULL;
	LPUNKNOWN pI2 = NULL;
	BOOL bResult = FALSE;
	if (SUCCEEDED(pUnk1->QueryInterface(iid, (void**)&pI1)))
	{
		ASSERT_POINTER(pI1, IUnknown);
		if (SUCCEEDED(pUnk2->QueryInterface(iid, (void**)&pI2)))
		{
			ASSERT_POINTER(pI2, IUnknown);
			bResult = (pI1 == pI2);
			pI2->Release();
		}
		pI1->Release();
	}
	return bResult;
}

BOOL CArchivePropExchange::ExchangePersistentProp(LPCTSTR pszPropName,
		LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(ppUnk, LPUNKNOWN);
	ASSERT_NULL_OR_POINTER(pUnkDefault, IUnknown);

	BOOL bResult = FALSE;
	CArchiveStream stm(&m_ar);

	if (m_bLoading)
	{
		RELEASE(*ppUnk);
		*ppUnk = NULL;

		BYTE bFlag;
		m_ar >> bFlag;
		if (bFlag != 0xFF)
		{
			// read the CLSID
			CLSID clsid2;
			m_ar >> clsid2.Data1;
			m_ar >> clsid2.Data2;
			m_ar >> clsid2.Data3;
			m_ar.EnsureRead(&clsid2.Data4[0], sizeof clsid2.Data4);

			// check for GUID_NULL first and skip if found
			if (IsEqualCLSID(clsid2, GUID_NULL))
				bResult = TRUE;
			else
			{
				// otherwise will need a stream
				LPSTREAM pstm = _AfxGetArchiveStream(m_ar, stm);
				if (IsEqualCLSID(clsid2, CLSID_StdPicture) ||
					IsEqualCLSID(clsid2, _afx_CLSID_StdPicture2_V1))
				{
					// special case for pictures
					bResult = SUCCEEDED(::OleLoadPicture(pstm, 0, FALSE, iid,
						(void**)ppUnk));
				}
				else
				{
					// otherwise, seek back to the CLSID
					LARGE_INTEGER li;
					li.LowPart = (DWORD)(-(long)sizeof(CLSID));
					li.HighPart = -1;
					VERIFY(SUCCEEDED(pstm->Seek(li, STREAM_SEEK_CUR, NULL)));

					// and load the object normally

					CLSID clsid;
					if (SUCCEEDED(::ReadClassStm(pstm, &clsid)) &&
							(SUCCEEDED(::CoCreateInstance(clsid, NULL,
								CLSCTX_SERVER | CLSCTX_REMOTE_SERVER,
								iid, (void**)ppUnk)) ||
							SUCCEEDED(::CoCreateInstance(clsid, NULL,
								CLSCTX_SERVER & ~CLSCTX_REMOTE_SERVER,
								iid, (void**)ppUnk))))
					{
						LPPERSISTSTREAM pps = NULL;
						if (SUCCEEDED((*ppUnk)->QueryInterface(
								IID_IPersistStream, (void**)&pps)) ||
							SUCCEEDED((*ppUnk)->QueryInterface(
								IID_IPersistStreamInit, (void**)&pps)))
						{
							ASSERT_POINTER(pps, IPersistStream);
							bResult = SUCCEEDED(pps->Load(pstm));
							pps->Release();
						}

						if (!bResult)
						{
							(*ppUnk)->Release();
							*ppUnk = NULL;
						}
					}
				}
			}
		}
		else
		{
			// Use default value.
			bResult = pUnkDefault == NULL ||
				SUCCEEDED(pUnkDefault->QueryInterface(iid, (LPVOID*)ppUnk));
		}
	}
	else
	{
		ASSERT_NULL_OR_POINTER(*ppUnk, IUnknown);

		// Check if *ppUnk and pUnkDefault are the same thing.  If so, don't
		// bother saving the object; just write a special flag instead.

		if (_AfxIsSameUnknownObject(iid, *ppUnk, pUnkDefault))
		{
			m_ar << (BYTE)0xFF;
			bResult = TRUE;
		}
		else
		{
			m_ar << (BYTE)0x00;
			if (*ppUnk != NULL)
			{
				LPPERSISTSTREAM pps = NULL;
				if (SUCCEEDED((*ppUnk)->QueryInterface(
						IID_IPersistStream, (void**)&pps)) ||
					SUCCEEDED((*ppUnk)->QueryInterface(
						IID_IPersistStreamInit, (void**)&pps)))
				{
					ASSERT_POINTER(pps, IPersistStream);
					LPSTREAM pstm = _AfxGetArchiveStream(m_ar, stm);
					bResult = SUCCEEDED(::OleSaveToStream(pps, pstm));
					pps->Release();
				}
			}
			else
			{
				// If no object, write null class ID.
				m_ar.Write(&GUID_NULL, sizeof(GUID));
			}
		}
	}

	// throw exception in case of unthrown errors
	if (!bResult)
		AfxThrowArchiveException(CArchiveException::genericException);

	return TRUE;
}

BOOL CArchivePropExchange::ExchangeFontProp(LPCTSTR pszPropName,
	CFontHolder& font, const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&font, CFontHolder);
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IFontDisp);

	BOOL bResult = FALSE;
	CArchiveStream stm(&m_ar);
	LPFONT pFont;

	if (m_bLoading)
	{
		BYTE bFlag;
		m_ar >> bFlag;
		if (bFlag != 0xFF)
		{
			LPSTREAM pstm = _AfxGetArchiveStream(m_ar, stm);
			pFont = _AfxCreateFontFromStream(pstm);
			if (pFont != NULL)
			{
				font.SetFont(pFont);
				bResult = TRUE;
			}
		}
		if (!bResult)
		{
			font.InitializeFont(pFontDesc, pFontDispAmbient);
			bResult = TRUE;
		}
	}
	else
	{
		pFont = font.m_pFont;
		if (pFont != NULL)
		{
			// If same as ambient font (or error), write 0xFF for the flag
			if (!_AfxIsSameFont(font, pFontDesc, pFontDispAmbient))
			{
				LPPERSISTSTREAM pps = NULL;
				if (SUCCEEDED(pFont->QueryInterface(IID_IPersistStream,
					(LPVOID*)&pps)))
				{
					ASSERT_POINTER(pps, IPersistStream);
					m_ar << (BYTE)0x00;
					LPSTREAM pstm = _AfxGetArchiveStream(m_ar, stm);
					bResult = SUCCEEDED(::OleSaveToStream(pps, pstm));
					pps->Release();
					if (!bResult)
						AfxThrowArchiveException(CArchiveException::genericException);
				}
			}
		}
		if (!bResult)
		{
			m_ar << (BYTE)0xFF;
			bResult = TRUE;
		}
	}
	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CResetPropExchange member functions

CResetPropExchange::CResetPropExchange()
{
	m_bLoading = TRUE;
}

BOOL CResetPropExchange::ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
		void* pvProp, const void* pvDefault)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT(AfxIsValidAddress(pvProp, 1, FALSE));
	ASSERT((pvDefault == NULL) || AfxIsValidAddress(pvDefault, 1, FALSE));

	return _AfxCopyPropValue(vtProp, pvProp, pvDefault);
}

BOOL CResetPropExchange::ExchangeBlobProp(LPCTSTR pszPropName,
	HGLOBAL* phBlob, HGLOBAL hBlobDefault)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(phBlob, HGLOBAL);

	// free the previous memory block
	if (*phBlob != NULL)
	{
		GlobalFree(*phBlob);
		*phBlob = NULL;
	}

	// copy the memory block
	BOOL bResult = TRUE;
	if (hBlobDefault != NULL)
		bResult = _AfxCopyBlob(phBlob, hBlobDefault);
	return bResult;
}

BOOL CResetPropExchange::ExchangePersistentProp(LPCTSTR pszPropName,
		LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(ppUnk, LPUNKNOWN);
	ASSERT_NULL_OR_POINTER(pUnkDefault, IUnknown);

	RELEASE(*ppUnk);

	BOOL bResult = TRUE;
	if (pUnkDefault != NULL)
	{
		bResult = SUCCEEDED(pUnkDefault->QueryInterface(iid,
			(LPVOID*)ppUnk));
	}
	return bResult;
}

BOOL CResetPropExchange::ExchangeFontProp(
	LPCTSTR pszPropName, CFontHolder& font, const FONTDESC* pFontDesc,
	LPFONTDISP pFontDispAmbient)
{
	UNUSED(pszPropName);     // unused in release builds

	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&font, CFontHolder);
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IFontDisp);

	font.InitializeFont(pFontDesc, pFontDispAmbient);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAsyncPropExchange member functions

CAsyncPropExchange::CAsyncPropExchange(DWORD dwVersion)
{
	m_bAsync = TRUE;
	m_bLoading = TRUE;
	m_dwVersion = dwVersion;
}

BOOL CAsyncPropExchange::ExchangeVersion(DWORD& dwVersionLoaded,
	DWORD dwVersionDefault, BOOL bConvert)
{
	if (m_bLoading)
	{
		dwVersionLoaded = m_dwVersion;
		return TRUE;
	}
	else
	{
		return m_dwVersion == (bConvert ? dwVersionDefault : dwVersionLoaded);
	}
}

BOOL CAsyncPropExchange::ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
	void* pvProp, const void* pvDefault)
{
	// Should never be called
	UNUSED_ALWAYS(pszPropName);
	UNUSED_ALWAYS(vtProp);
	UNUSED_ALWAYS(pvProp);
	UNUSED_ALWAYS(pvDefault);
	ASSERT(FALSE);
	return FALSE;
}

BOOL CAsyncPropExchange::ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
	HGLOBAL hBlobDefault)
{
	// Should never be called
	UNUSED_ALWAYS(pszPropName);
	UNUSED_ALWAYS(phBlob);
	UNUSED_ALWAYS(hBlobDefault);
	ASSERT(FALSE);
	return FALSE;
}

BOOL CAsyncPropExchange::ExchangeFontProp(LPCTSTR pszPropName,
	CFontHolder& font, const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient)
{
	// Should never be called
	UNUSED_ALWAYS(pszPropName);
	UNUSED_ALWAYS(font);
	UNUSED_ALWAYS(pFontDesc);
	UNUSED_ALWAYS(pFontDispAmbient);
	ASSERT(FALSE);
	return FALSE;
}

BOOL CAsyncPropExchange::ExchangePersistentProp(LPCTSTR pszPropName,
	LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault)
{
	// Should never be called
	UNUSED_ALWAYS(pszPropName);
	UNUSED_ALWAYS(ppUnk);
	UNUSED_ALWAYS(iid);
	UNUSED_ALWAYS(pUnkDefault);
	ASSERT(FALSE);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// PX_ functions

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&sValue, short);

	if (pPX->IsAsynchronous())
		return TRUE;
	return  pPX->ExchangeProp(pszPropName, VT_I2, &sValue);
}

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue,
	short sDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&sValue, short);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I2, &sValue, &sDefault);
}

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&usValue, USHORT);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I2, &usValue);
}

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue,
	USHORT usDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&usValue, USHORT);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I2, &usValue, &usDefault);
}

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&lValue, long);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &lValue);
}

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue,
	long lDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&lValue, long);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &lValue, &lDefault);
}

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&ulValue, ULONG);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &ulValue);
}

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue,
	ULONG ulDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&ulValue, ULONG);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &ulValue, &ulDefault);
}

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&clrValue, OLE_COLOR);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &clrValue);
}

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue,
	OLE_COLOR clrDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&clrValue, OLE_COLOR);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_I4, &clrValue, &clrDefault);
}

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&bValue, BOOL);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_BOOL, &bValue);
}

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue,
	BOOL bDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&bValue, BOOL);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_BOOL, &bValue, &bDefault);
}

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&strValue, CString);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_BSTR, &strValue);
}

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	const CString& strDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&strValue, CString);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_BSTR, &strValue, &strDefault);
}

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	LPCTSTR lpszDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&strValue, CString);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_LPSTR, &strValue, lpszDefault);
}

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&cyValue, CY);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_CY, &cyValue);
}

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue,
	CY cyDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&cyValue, CY);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_CY, &cyValue, &cyDefault);
}

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&floatValue, float);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_R4, &floatValue);
}

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue,
	float floatDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&floatValue, float);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_R4, &floatValue, &floatDefault);
}

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&doubleValue, double);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_R8, &doubleValue);
}

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue,
	double doubleDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&doubleValue, double);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeProp(pszPropName, VT_R8, &doubleValue, &doubleDefault);
}

BOOL AFX_CDECL PX_Blob(CPropExchange* pPX, LPCTSTR pszPropName, HGLOBAL& hBlob,
	HGLOBAL hBlobDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&hBlob, HGLOBAL);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeBlobProp(pszPropName, &hBlob, hBlobDefault);
}

BOOL AFX_CDECL PX_Font(CPropExchange* pPX, LPCTSTR pszPropName, CFontHolder& font,
		const FONTDESC* pFontDesc, LPFONTDISP pFontDispAmbient)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&font, CFontHolder);
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IFontDisp);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangeFontProp(pszPropName, font, pFontDesc,
		pFontDispAmbient);
}

BOOL AFX_CDECL PX_IUnknown(CPropExchange* pPX, LPCTSTR pszPropName, LPUNKNOWN& pUnk,
	REFIID iid, LPUNKNOWN pUnkDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&pUnk, LPUNKNOWN);
	ASSERT_NULL_OR_POINTER(pUnk, IUnknown);
	ASSERT_NULL_OR_POINTER(pUnkDefault, IUnknown);

	if (pPX->IsAsynchronous())
		return TRUE;
	return pPX->ExchangePersistentProp(pszPropName, &pUnk, iid, pUnkDefault);
}

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName, CPictureHolder& pict)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&pict, CPictureHolder);

	if (pPX->IsAsynchronous())
		return TRUE;
	LPUNKNOWN& pUnk = (LPUNKNOWN&)pict.m_pPict;
	return PX_IUnknown(pPX, pszPropName, pUnk, IID_IPicture);
}

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName, CPictureHolder& pict,
	CPictureHolder& pictDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&pict, CPictureHolder);

	if (pPX->IsAsynchronous())
		return TRUE;
	LPUNKNOWN& pUnk = (LPUNKNOWN&)pict.m_pPict;
	return PX_IUnknown(pPX, pszPropName, pUnk, IID_IPicture,
		pictDefault.m_pPict);
}

BOOL AFX_CDECL PX_VBXFontConvert(CPropExchange* pPX, CFontHolder& font)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT_POINTER(&font, CFontHolder);

	if (pPX->IsAsynchronous())
		return TRUE;
	if (font.m_pFont != NULL)
	{
		CString strName;
		if (PX_String(pPX, _T("FontName"), strName))
		{
			
			BSTR bstrName = strName.AllocSysString();
			font.m_pFont->put_Name(bstrName);
			SysFreeString(bstrName);
		}

		CY cySize;
		if (PX_Currency(pPX, _T("FontSize"), cySize))
			font.m_pFont->put_Size(cySize);

		BOOL bFlag;
		if (PX_Bool(pPX, _T("FontBold"), bFlag))
			font.m_pFont->put_Bold(bFlag);
		if (PX_Bool(pPX, _T("FontItalic"), bFlag))
			font.m_pFont->put_Italic(bFlag);
		if (PX_Bool(pPX, _T("FontUnderline"), bFlag))
			font.m_pFont->put_Underline(bFlag);
		if (PX_Bool(pPX, _T("FontStrikethru"), bFlag))
			font.m_pFont->put_Strikethrough(bFlag);
	}
	return TRUE;
}

AFX_STATIC BOOL AFXAPI _Afx_PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, VARTYPE vtDefault, const void* pvDefault)
{
	ASSERT_POINTER(pPX, CPropExchange);
	ASSERT(AfxIsValidString(pszPropName));

	const BOOL bIsLoading = pPX->IsLoading();

	COleControl* pControl = dataPathProp.GetControl();
	if (!pControl)
		TRACE(traceAppMsg, 0, "No control in PX_DataPath!");

	BOOL bHasClientSite = pControl ? NULL != pControl->GetClientSite() : FALSE;

	if (!pPX->IsAsynchronous())
	{
		CString strPath;
		if (!bIsLoading)
			strPath = dataPathProp.GetPath();
		if (((pvDefault != NULL) && !pPX->ExchangeProp(pszPropName, vtDefault, &strPath, pvDefault)) ||
			((pvDefault == NULL) && !pPX->ExchangeProp(pszPropName, VT_BSTR, &strPath)))
			return FALSE;
		if (bIsLoading)
			dataPathProp.SetPath(strPath);
		if (pControl && !bHasClientSite)
			pControl->RequestAsynchronousExchange(pPX->GetVersion());
	}

	if (pPX->IsAsynchronous() || bHasClientSite)
	{
#ifdef _DEBUG
		{
			if (!bHasClientSite)
				TRACE(traceAppMsg, 0, "No client site in PX_DataPath!");
		}
#endif // _DEBUG

		if (bIsLoading)
			return dataPathProp.Open();
	}

	return TRUE;
}

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, LPCTSTR pszDefault)
{
	return _Afx_PX_DataPath(pPX, pszPropName, dataPathProp, VT_LPSTR, pszDefault);
}

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, const CString& strDefault)
{
	return _Afx_PX_DataPath(pPX, pszPropName, dataPathProp, VT_BSTR, &strDefault);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpset.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

#define OSTYPE 2    // Win32

AFX_STATIC_DATA LARGE_INTEGER _afxLargeZero = { 0,0 };

// Old class IDs for font and picture types
AFX_STATIC_DATA const CLSID _afx_CLSID_StdFont_V1 =
	{ 0xfb8f0823,0x0164,0x101b, { 0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13 } };
AFX_STATIC_DATA const CLSID _afx_CLSID_StdPicture_V1 =
	{ 0xfb8f0824,0x0164,0x101b, { 0x84,0xed,0x08,0x00,0x2b,0x2e,0xc7,0x13 } };

LPSTREAM AFXAPI _AfxCreateMemoryStream()
{
	LPSTREAM lpStream = NULL;

	// Create a stream object on a memory block.
	HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, 0);
	if (hGlobal != NULL)
	{
		if (FAILED(CreateStreamOnHGlobal(hGlobal, TRUE, &lpStream)))
		{
			TRACE(traceAppMsg, 0, "CreateStreamOnHGlobal failed.\n");
			GlobalFree(hGlobal);
			return NULL;
		}

		ASSERT_POINTER(lpStream, IStream);
	}
	else
	{
		TRACE(traceAppMsg, 0, "Failed to allocate memory for stream.\n");
		return NULL;
	}

	return lpStream;
}

BOOL COleControl::GetPropsetData(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium, REFCLSID fmtid)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ENSURE_ARG(lpFormatEtc!=NULL && lpStgMedium!=NULL);

	BOOL bGetDataHere = (lpStgMedium->tymed != TYMED_NULL);

	// Allow IStream or IStorage as the storage medium.

	if (!(lpFormatEtc->tymed & (TYMED_ISTREAM|TYMED_ISTORAGE)))
	{
		TRACE(traceAppMsg, 0, "Propset only supported for stream or storage.\n");
		return FALSE;
	}

	LPSTORAGE lpStorage = NULL;
	LPSTREAM lpStream = NULL;

	if (lpFormatEtc->tymed & TYMED_ISTORAGE)
	{
		// Caller wants propset data in a storage object.

		if (bGetDataHere)
		{
			// Use the caller-supplied storage object.
			lpStorage = lpStgMedium->pstg;
		}
		else
		{
			// Create a storage object on a memory ILockBytes implementation.
			LPLOCKBYTES lpLockBytes = NULL;

			if (FAILED(CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes)))
			{
				TRACE(traceAppMsg, 0, "CreateILockBytesOnHGlobal failed.\n");
				return FALSE;
			}

			ASSERT_POINTER(lpLockBytes, ILockBytes);

			if (FAILED(StgCreateDocfileOnILockBytes(lpLockBytes,
					STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0,
					&lpStorage)))
			{
				TRACE(traceAppMsg, 0, "StgCreateDocfileOnILockBytes failed.\n");
				lpLockBytes->Release();
				return FALSE;
			}

			// Docfile now has reference to ILockBytes, so release ours.
			lpLockBytes->Release();
		}

		ASSERT_POINTER(lpStorage, IStorage);
		ENSURE(lpStorage != NULL);

		// Create a stream within the storage.
		if (FAILED(lpStorage->CreateStream(OLESTR("Contents"),
				STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, 0,
				&lpStream)))
		{
			TRACE(traceAppMsg, 0, "IStorage::CreateStream failed.\n");
			if (!bGetDataHere)
				lpStorage->Release();
			return FALSE;
		}
	}
	else
	{
		// Caller wants propset data in a stream object.

		if (bGetDataHere)
		{
			// Use the caller-supplied stream object
			lpStream = lpStgMedium->pstm;
		}
		else
		{
			lpStream = _AfxCreateMemoryStream();
			if (lpStream == NULL)
				return FALSE;
		}
	}

	ASSERT_POINTER(lpStream, IStream);

	// Create the property set.

	CLSID clsid;
	GetClassID(&clsid);
	CPropertySet pset(clsid);
	pset.SetOSVersion(MAKELONG(LOWORD(GetVersion()), OSTYPE));
	CPropertySection* ppsec = pset.AddSection(fmtid);
	if (ppsec == NULL)
	{
		TRACE(traceAppMsg, 0, "CPropertySet::AddSection failed.\n");
		if (lpStream!=NULL)
		{
			lpStream->Release();
			lpStream=NULL;
		}
		if (lpStorage!=NULL)
		{
			lpStorage->Release();
			lpStorage=NULL;
		}
		return FALSE;
	}

	// Set the name, based on the ambient display name (from the container).
	ppsec->SetSectionName(AmbientDisplayName());

	CPropsetPropExchange propx(*ppsec, lpStorage, FALSE);

	BOOL bPropExchange = FALSE;
	TRY
	{
		DoPropExchange(&propx);
		bPropExchange = TRUE;
	}
	END_TRY

	if (!bPropExchange)
	{
		TRACE(traceAppMsg, 0, "DoPropExchange failed.\n");
		if (lpStream!=NULL)
		{
			lpStream->Release();
			lpStream=NULL;
		}
		if (lpStorage!=NULL)
		{
			lpStorage->Release();
			lpStorage=NULL;
		}
		return FALSE;
	}

	// Store the property set in the stream.

	if (!pset.WriteToStream(lpStream))
	{
		TRACE(traceAppMsg, 0, "CPropertySet::WriteToStream failed.\n");
		if (lpStream!=NULL)
		{
			lpStream->Release();
			lpStream=NULL;
		}
		if (lpStorage!=NULL)
		{
			lpStorage->Release();
			lpStorage=NULL;
		}
		return FALSE;
	}

	// Return the property set in the requested medium.

	if (lpFormatEtc->tymed & TYMED_ISTORAGE)
	{
		// Return as a storage object.

		ASSERT_POINTER(lpStorage, IStorage);
		lpStream->Release();
		lpStgMedium->pstg = lpStorage;
		lpStgMedium->tymed = TYMED_ISTORAGE;
		lpStgMedium->pUnkForRelease = NULL;
	}
	else
	{
		// Return as a stream.

		ASSERT_POINTER(lpStream, IStream);
		lpStgMedium->pstm = lpStream;
		lpStgMedium->tymed = TYMED_ISTREAM;
		lpStgMedium->pUnkForRelease = NULL;
	}

	return TRUE;
}

BOOL COleControl::SetPropsetData(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium, REFCLSID fmtid)
{
	UNUSED(lpFormatEtc); // unused in release builds

	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));
	ASSERT(AfxIsValidAddress(lpStgMedium, sizeof(STGMEDIUM)));
	ENSURE_ARG(lpStgMedium && lpFormatEtc);
	// Get the stream that contains the property set.

	LPSTORAGE lpStorage = NULL;
	LPSTREAM lpStream = NULL;

	switch (lpStgMedium->tymed)
	{
	case TYMED_ISTORAGE:
		{
			lpStorage = lpStgMedium->pstg;
			ASSERT_POINTER(lpStorage, IStorage);
			ENSURE(lpStorage != NULL);
			if (FAILED(lpStorage->OpenStream(OLESTR("Contents"), 0,
					STGM_SHARE_EXCLUSIVE|STGM_READ, 0, &lpStream)))
			{
				TRACE(traceAppMsg, 0, "Failed to open content stream.\n");
				return FALSE;
			}
		}
		break;

	case TYMED_ISTREAM:
		lpStorage = NULL;
		lpStream = lpStgMedium->pstm;
		break;

	default:
		TRACE(traceAppMsg, 0, "Propset only supported for stream or storage.\n");
		return FALSE;
	}

	ASSERT_POINTER(lpStream, IStream);
	ENSURE(lpStream != NULL);

	// Read the property set from the stream.

	CPropertySet pset;
	if (!pset.ReadFromStream(lpStream))
	{
		TRACE(traceAppMsg, 0, "CPropertySet::ReadFromStream failed.\n");
		return FALSE;
	}

	CPropertySection* ppsec = pset.GetSection(fmtid);
	if (ppsec == NULL)
	{
		TRACE(traceAppMsg, 0, "CLSID_PersistPropset section not found in property set.\n");
		return FALSE;
	}

	// Detect whether we're converting a VBX
	m_bConvertVBX = (BYTE)IsEqualGUID(fmtid, CLSID_ConvertVBX);

	// Parse the property set.

	CPropsetPropExchange propx(*ppsec, lpStorage, TRUE);

	BOOL bPropExchange = FALSE;
	TRY
	{
		DoPropExchange(&propx);
		bPropExchange = TRUE;
	}
	END_TRY

	// Properties have probably changed
	BoundPropertyChanged(DISPID_UNKNOWN);
	InvalidateControl();

	m_bConvertVBX = FALSE;

	// Clear the modified flag.
	m_bModified = FALSE;

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	m_bInitialized = TRUE;

	// Cleanup.
	if (lpStorage != NULL)      // If we called OpenStream(), release now.
		lpStream->Release();

	BoundPropertyChanged(DISPID_UNKNOWN);
	return bPropExchange;
}

CPropsetPropExchange::CPropsetPropExchange(CPropertySection& psec,
		LPSTORAGE lpStorage, BOOL bLoading) :
	m_psec(psec),
	m_lpStorage(lpStorage),
	m_dwPropID(255)
{
	ASSERT_POINTER(&psec, CPropertySection);
	ASSERT_NULL_OR_POINTER(lpStorage, IStorage);

	m_bLoading = bLoading;
}

AFX_STATIC size_t AFXAPI _AfxGetSizeOfVarType(VARTYPE vt)
{
	switch (vt)
	{
	case VT_I2:
	case VT_BOOL:
		return 2;

	case VT_I4:
	case VT_R4:
		return 4;

	case VT_R8:
		return 8;

	case VT_CY:
		return sizeof(CURRENCY);

	case VT_BSTR:
		return sizeof(BSTR);
	}

	return 0;
}

BOOL AFXAPI _AfxCoerceNumber(void* pvDst, VARTYPE vtDst, void* pvSrc, VARTYPE vtSrc)
{
	// Check size of source.
	size_t cbSrc = _AfxGetSizeOfVarType(vtSrc);
	if (cbSrc == 0)
		return FALSE;

	// If source and destination are same type, just copy.
	if (vtSrc == vtDst)
	{
		Checked::memcpy_s(pvDst, cbSrc, pvSrc, cbSrc);
		return TRUE;
	}

	// Check size of destination.
	size_t cbDst = _AfxGetSizeOfVarType(vtDst);

	if (cbDst == 0)
		return FALSE;

	// Initialize variant for coercion.
	VARIANTARG var;
	V_VT(&var) = vtSrc;
	Checked::memcpy_s((void*)&V_NONE(&var), sizeof(var), pvSrc, cbSrc);

	// Do the coercion.
	if (FAILED(VariantChangeType(&var, &var, 0, vtDst)))
		return FALSE;

	// Copy result to destination.
	Checked::memcpy_s(pvDst, cbDst, (void*)&V_NONE(&var), cbDst);
	return TRUE;
}

BOOL AFXAPI _AfxIsSamePropValue(VARTYPE vtProp, const void* pv1, const void* pv2)
{
	if (pv1 == pv2)
		return TRUE;

	if ((pv1 == NULL) || (pv2 == NULL))
		return FALSE;

	BOOL bSame = FALSE;

	switch (vtProp)
	{
	case VT_BSTR:
		bSame = ((CString*)pv1)->Compare(*(CString*)pv2) == 0;
		break;
	case VT_LPSTR:
		bSame = ((CString*)pv1)->Compare((LPCTSTR)pv2) == 0;
		break;

	case VT_BOOL:
	case VT_I2:
	case VT_I4:
	case VT_CY:
	case VT_R4:
	case VT_R8:
		bSame = memcmp(pv1, pv2, _AfxGetSizeOfVarType(vtProp)) == 0;
		break;
	}

	return bSame;
}

BOOL CPropsetPropExchange::ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
	void* pvProp, const void* pvDefault)
{
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT(AfxIsValidAddress(pvProp, 1, FALSE));
	ASSERT((pvDefault == NULL) || AfxIsValidAddress(pvDefault, 1, FALSE));

	BOOL bSuccess = FALSE;

	if (m_bLoading)
	{
		DWORD dwPropID;
		LPVOID pvData;
		CProperty* pprop;

		if (m_psec.GetID(pszPropName, &dwPropID) &&
			((pprop = m_psec.GetProperty(dwPropID)) != NULL) &&
			((pvData = pprop->Get()) != NULL))
		{
			VARTYPE vtData = (VARTYPE)pprop->GetType();

			CString strTmp;

#ifdef _UNICODE
			// Unicode is "native" format
			if ((vtData == VT_BSTR) || (vtData == VT_LPWSTR))
#else
			// ANSI is "native" format
			if ((vtData == VT_BSTR) || (vtData == VT_LPSTR))
#endif
			{
				strTmp = (LPCTSTR)pvData;
			}

#ifdef _UNICODE
			else if (vtData == VT_LPSTR)
			{
				// Convert from ANSI to Unicode
				strTmp = (LPCSTR)pvData;
			}
#else
			else if (vtData == VT_LPWSTR)
			{
				// Convert from Unicode to ANSI
				strTmp = (LPCWSTR)pvData;
			}
#endif

			switch (vtProp)
			{
			case VT_LPSTR:
			case VT_BSTR:
				bSuccess = _AfxCopyPropValue(VT_BSTR, pvProp, &strTmp);
				break;

			case VT_BOOL:
				{
					short sProp;
					BSTR bstrTmp = NULL;

					if ((vtData == VT_BSTR) || (vtData == VT_LPSTR) ||
						(vtData == VT_LPWSTR))
					{
						bstrTmp = strTmp.AllocSysString();
						pvData = &bstrTmp;
						vtData = VT_BSTR;
					}

					bSuccess = _AfxCoerceNumber(&sProp, VT_BOOL, pvData,
						vtData);

                    ::SysFreeString(bstrTmp);

					if (bSuccess)
					{
						ASSERT((sProp == -1) || (sProp == 0));
						*(BOOL*)pvProp = !!sProp;
					}
				}
				break;

			case VT_I2:
			case VT_I4:
			case VT_CY:
			case VT_R4:
			case VT_R8:
				bSuccess = _AfxCoerceNumber(pvProp, vtProp, pvData, vtData);
				break;
			}
		}
		else
		{
			bSuccess = _AfxCopyPropValue(vtProp, pvProp, pvDefault);
		}
	}
	else
	{
		if (!_AfxIsSamePropValue(vtProp, pvProp, pvDefault))
		{
			++m_dwPropID;

			LPVOID pvData = NULL;
			BOOL bData;

			switch (vtProp)
			{
			case VT_LPSTR:
			case VT_BSTR:
				pvData = (LPVOID)(LPCTSTR)*(CString*)pvProp;
				break;

			case VT_BOOL:
				// Convert boolean value to -1 or 0.
				bData = (*(BOOL*)pvProp) ? -1 : 0;
				pvData = &bData;
				break;

			case VT_I2:
			case VT_I4:
			case VT_CY:
			case VT_R4:
			case VT_R8:
				pvData = pvProp;
				break;
			}

			bSuccess = m_psec.SetName(m_dwPropID, pszPropName) &&
				m_psec.Set(m_dwPropID, pvData, vtProp);
		}
		else
		{
			bSuccess = TRUE;
		}
	}

	return bSuccess;
}

BOOL CPropsetPropExchange::ExchangeBlobProp(LPCTSTR pszPropName,
	HGLOBAL* phBlob, HGLOBAL hBlobDefault)
{
	ASSERT(AfxIsValidString(pszPropName));
	ENSURE_ARG(phBlob != NULL);
	ENSURE_ARG(pszPropName != NULL);

	BOOL bSuccess = FALSE;
	ULONG cb = 0;
	void* pvBlob = NULL;

	if (m_bLoading)
	{
		if (*phBlob != NULL)
		{
			GlobalFree(*phBlob);
			*phBlob = NULL;
		}

		DWORD dwPropID;
		LPVOID pvData;

		if (m_psec.GetID(pszPropName, &dwPropID) &&
			((pvData = m_psec.Get(dwPropID)) != NULL))
		{
			// Copy count and blob data

			cb = *(ULONG*)pvData;

			if (cb > 0)
			{
				bSuccess = _AfxInitBlob(phBlob, pvData);
			}
			else
			{
				bSuccess = (cb == 0);
			}
		}

		if (!bSuccess)
		{
			// Failed.  Use default values.

			if (hBlobDefault != NULL)
				_AfxCopyBlob(phBlob, hBlobDefault);

			bSuccess = TRUE;
		}
	}
	else
	{
		++m_dwPropID;

		pvBlob = NULL;
		if (*phBlob != NULL)
			pvBlob = GlobalLock(*phBlob);

		ULONG lZero = 0;
		void* pvBlobSave = (pvBlob != NULL) ? pvBlob : &lZero;

		bSuccess = m_psec.SetName(m_dwPropID, pszPropName) &&
			m_psec.Set(m_dwPropID, pvBlobSave, VT_BLOB);

		if ((*phBlob != NULL) && (pvBlob != NULL))
			GlobalUnlock(*phBlob);
	}

	return bSuccess;
}

BOOL AFXAPI _AfxSaveStreamDataAsBlobProp(LPSTREAM pstm, CPropertySection& psec,
		DWORD dwPropID, DWORD dwType)
{
	BOOL bSuccess = FALSE;
	ULARGE_INTEGER uliStart;
	ULARGE_INTEGER uliEnd;

	// Note:  Stream length must fit in a DWORD.

	if (SUCCEEDED(pstm->Seek(_afxLargeZero, STREAM_SEEK_CUR, &uliStart)) &&
		SUCCEEDED(pstm->Seek(_afxLargeZero, STREAM_SEEK_END, &uliEnd)) &&
		SUCCEEDED(pstm->Seek(*(LARGE_INTEGER*)&uliStart, STREAM_SEEK_SET,
			NULL)))
	{
		DWORD cb = uliEnd.LowPart - uliStart.LowPart;
		HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,
			cb + (DWORD)sizeof(cb));

		if (hGlobal != NULL)
		{
			LPBYTE pbData = (LPBYTE)GlobalLock(hGlobal);
			if (pbData != NULL)
			{
				*(DWORD*)pbData = cb;
				if (SUCCEEDED(pstm->Read(pbData + (DWORD)sizeof(DWORD), cb,
					NULL)))
				{
					bSuccess = psec.Set(dwPropID, pbData, dwType);
				}
				GlobalUnlock(hGlobal);
			}
			GlobalFree(hGlobal);
		}
	}

	return bSuccess;
}

BOOL AFXAPI _AfxInitStreamDataFromBlobProp(LPSTREAM pstm, CProperty* pprop)
{
	BOOL bSuccess = FALSE;
	ULONG cb;
	BYTE* pbData = (BYTE*)(pprop->Get(&cb));

	if (pbData != NULL)
	{
		// Put the data into the stream, then seek back to start of data.

		LARGE_INTEGER liOffset;
		liOffset.LowPart = -(LONG)cb;
		liOffset.HighPart = -1;
		if (SUCCEEDED(pstm->Write(pbData + sizeof(ULONG), cb, NULL)) &&
			SUCCEEDED(pstm->Seek(liOffset, STREAM_SEEK_CUR, NULL)))
		{
			bSuccess = TRUE;
		}
	}

	return bSuccess;
}

AFX_STATIC_DATA const FONTDESC _afxFontDescHelv =
	{ sizeof(FONTDESC), OLESTR("Helv"), FONTSIZE(12), FW_NORMAL,
	  DEFAULT_CHARSET, FALSE, FALSE, FALSE };

LPFONT AFXAPI _AfxCreateFontFromStream(LPSTREAM pstm)
{
	BOOL bSuccess = FALSE;
	LPFONT pFont = NULL;
	LPPERSISTSTREAM pPersStm = NULL;
	CLSID clsid;

	if (SUCCEEDED(pstm->Read(&clsid, sizeof(CLSID), NULL)))
	{
		HRESULT hr;

		if (IsEqualCLSID(clsid, CLSID_StdFont) ||
			IsEqualCLSID(clsid, _afx_CLSID_StdFont_V1))
		{
			// We know this kind of font; create it using the API.
			hr = ::OleCreateFontIndirect((LPFONTDESC)&_afxFontDescHelv, IID_IFont,
					(LPVOID*)&pFont);
		}
		else
		{
			// Some other implementation of IFont.
			hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IFont,
					(LPVOID*)&pFont);
		}

		if (SUCCEEDED(hr))
		{
			// Successfully created font, now get its IPersistStream interface.

			ASSERT_POINTER(pFont, IFont);
			ENSURE(pFont != NULL);

			if (SUCCEEDED(pFont->QueryInterface(IID_IPersistStream,
					(LPVOID*)&pPersStm)))
			{
				ASSERT_POINTER(pPersStm, IPersistStream);
			}
		}

		if (pPersStm != NULL)
		{
			// Load the font.

			ASSERT_POINTER(pFont, IFont);
			bSuccess = SUCCEEDED(pPersStm->Load(pstm));
			pPersStm->Release();
		}
	}

	// If we failed for any reason, clean up the font.
	if (!bSuccess && pFont != NULL)
	{
		pFont->Release();
		pFont = NULL;
	}

	return pFont;
}

BOOL AFXAPI _AfxLoadObjectFromStreamedPropset(LPUNKNOWN lpUnknown, LPSTREAM lpStream)
{
	ASSERT_POINTER(lpUnknown, IUnknown);
	ASSERT_POINTER(lpStream, IStream);
	ENSURE_ARG(lpUnknown != NULL);

	BOOL bSuccess = FALSE;
	LPDATAOBJECT pDataObj = NULL;

	if (SUCCEEDED(lpUnknown->QueryInterface(IID_IDataObject,
			(LPVOID*)&pDataObj)))
	{
		ASSERT_POINTER(pDataObj, IDataObject);

		// Set the persistent propset format on the object.

		FORMATETC formatEtc;
		STGMEDIUM stgMedium;
		formatEtc.cfFormat = _AfxGetClipboardFormatPersistPropset();
		formatEtc.ptd = NULL;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = TYMED_ISTREAM;

		stgMedium.tymed = TYMED_ISTREAM;
		stgMedium.pstm = lpStream;
		stgMedium.pUnkForRelease = NULL;

		bSuccess = SUCCEEDED(pDataObj->SetData(&formatEtc, &stgMedium, FALSE));

		pDataObj->Release();
	}

	return bSuccess;
}

BOOL AFXAPI _AfxGetClassIDFromStreamedPropset(LPCLSID lpClsid, LPSTREAM lpStream)
{
	BOOL bSuccess = FALSE;
	ULARGE_INTEGER uliSave;
	LARGE_INTEGER liClsidOffset;
	liClsidOffset.QuadPart = 8;

	if (SUCCEEDED(lpStream->Seek(_afxLargeZero, STREAM_SEEK_CUR, &uliSave)))
	{
		if (SUCCEEDED(lpStream->Seek(liClsidOffset, STREAM_SEEK_CUR, NULL)) &&
			SUCCEEDED(lpStream->Read(lpClsid, sizeof(CLSID), NULL)))
		{
			bSuccess = TRUE;
		}

		lpStream->Seek(*(LARGE_INTEGER*)&uliSave, STREAM_SEEK_SET, NULL);
	}

	return bSuccess;
}

LPUNKNOWN AFXAPI _AfxCreateObjectFromStreamedPropset(LPSTREAM lpStream, REFGUID iid)
{
	LPUNKNOWN pUnk = NULL;
	CLSID clsid;

	if (_AfxGetClassIDFromStreamedPropset(&clsid, lpStream))
	{
		// Special case: we know how to create font objects
		if (IsEqualCLSID(clsid, CLSID_StdFont) ||
			IsEqualCLSID(clsid, _afx_CLSID_StdFont_V1))
		{
			if (FAILED(::OleCreateFontIndirect((LPFONTDESC)&_afxFontDescHelv, iid,
					(LPVOID*)&pUnk)))
			{
				pUnk = NULL;
			}
		}
		// Special case: we know how to create picture objects
		else if (IsEqualCLSID(clsid, CLSID_StdPicture) ||
			IsEqualCLSID(clsid, _afx_CLSID_StdPicture_V1))
		{
			if (FAILED(::OleCreatePictureIndirect(NULL, iid, FALSE,
					(LPVOID*)&pUnk)))
			{
				pUnk = NULL;
			}
		}
		// General case: create the object
		else if (FAILED(CoCreateInstance(clsid, NULL,
					CLSCTX_INPROC_SERVER, iid, (LPVOID*)&pUnk)))
		{
			pUnk = NULL;
		}

		if (pUnk != NULL)
		{
			if (!_AfxLoadObjectFromStreamedPropset(pUnk, lpStream))
			{
				RELEASE(pUnk);
				pUnk = NULL;
			}
		}
	}

	return pUnk;
}

LPSTREAM AFXAPI _AfxLoadStreamFromPropset(CPropertySection& psec, LPCTSTR pszPropName,
	DWORD& vtType)
{
	ASSERT(AfxIsValidString(pszPropName));

	vtType = VT_EMPTY;

	DWORD dwPropID;
	CProperty* pprop = NULL;
	LPSTREAM pstm = NULL;

	if (psec.GetID(pszPropName, &dwPropID) &&
		((pprop = psec.GetProperty(dwPropID)) != NULL))
	{
		vtType = pprop->GetType();

		if ((vtType == VT_BLOB) || (vtType == VT_BLOB_PROPSET))
		{
			pstm = _AfxCreateMemoryStream();

			if (pstm != NULL)
			{
				if (!_AfxInitStreamDataFromBlobProp(pstm, pprop))
				{
					pstm->Release();
					pstm = NULL;
				}
			}
		}
	}

	return pstm;
}

BOOL AFXAPI _AfxSaveObjectInPropset(LPUNKNOWN pUnk, CPropertySection& psec,
	DWORD dwPropID)
{
	if (pUnk == NULL)
		return FALSE;

	ASSERT_POINTER(pUnk, IUnknown);

	BOOL bSuccess = FALSE;
	LPDATAOBJECT pDataObj;

	if (SUCCEEDED(pUnk->QueryInterface(IID_IDataObject,
			(LPVOID*)&pDataObj)))
	{
		// Get the persistent propset format from object.

		FORMATETC formatEtc;
		STGMEDIUM stgMedium;
		formatEtc.cfFormat = _AfxGetClipboardFormatPersistPropset();
		formatEtc.ptd = NULL;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = TYMED_ISTREAM;

		stgMedium.tymed = TYMED_NULL;
		stgMedium.pUnkForRelease = NULL;

		if (SUCCEEDED(pDataObj->GetData(&formatEtc, &stgMedium)))
		{
			if (stgMedium.tymed == TYMED_ISTREAM)
			{
				LPSTREAM pstm = stgMedium.pstm;

				// Seek to start of stream.
				if (SUCCEEDED(pstm->Seek(_afxLargeZero, STREAM_SEEK_SET, NULL)))
				{
					// Create a "blobbed" propset from the stream
					bSuccess = _AfxSaveStreamDataAsBlobProp(stgMedium.pstm,
						psec, dwPropID, VT_BLOB_PROPSET);
				}
			}

			// Cleanup
			ReleaseStgMedium(&stgMedium);
		}

		pDataObj->Release();
	}

	LPPERSISTSTREAM pPersStm = NULL;

	if ((!bSuccess) &&
		SUCCEEDED(pUnk->QueryInterface(IID_IPersistStream,
			(LPVOID*)&pPersStm)))
	{
		// Get the object to save itself into a stream, then store that
		// streamed data as a blob.

		ASSERT_POINTER(pPersStm, IPersistStream);
		LPSTREAM pstm = _AfxCreateMemoryStream();
		if (pstm != NULL)
		{
			if (SUCCEEDED(::OleSaveToStream(pPersStm, pstm)) &&
				SUCCEEDED(pstm->Seek(_afxLargeZero, STREAM_SEEK_SET, NULL)))
			{
				bSuccess = _AfxSaveStreamDataAsBlobProp(pstm, psec,
					dwPropID, VT_BLOB);
			}

			pstm->Release();
		}

		pPersStm->Release();
	}

	return bSuccess;
}

BOOL CPropsetPropExchange::ExchangePersistentProp(LPCTSTR pszPropName,
		LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault)
{
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(ppUnk, LPUNKNOWN);
	ASSERT_NULL_OR_POINTER(pUnkDefault, IUnknown);
	ENSURE_ARG(ppUnk != NULL);

	BOOL bSuccess = FALSE;

	if (m_bLoading)
	{
		RELEASE(*ppUnk);
		*ppUnk = NULL;

		DWORD vtType;
		LPSTREAM pstm = _AfxLoadStreamFromPropset(m_psec, pszPropName, vtType);

		if (pstm != NULL)
		{
			CLSID clsid;

			switch(vtType)
			{
			case VT_BLOB:
				if (_AfxPeekAtClassIDInStream(pstm, &clsid))
				{
					if (IsEqualCLSID(clsid, CLSID_StdPicture) ||
						IsEqualCLSID(clsid, _afx_CLSID_StdPicture_V1))
					{
						// Special case: load the picture directly.
						bSuccess = SUCCEEDED(::ReadClassStm(pstm, &clsid)) &&
							SUCCEEDED(::OleLoadPicture(pstm, 0, FALSE, iid,
							(LPVOID*)ppUnk));
					}
					else
					{
						// Load the object.
						bSuccess = SUCCEEDED(::OleLoadFromStream(pstm, iid,
							(LPVOID*)ppUnk));
					}
				}
				break;

			case VT_BLOB_PROPSET:
				*ppUnk = _AfxCreateObjectFromStreamedPropset(pstm, iid);
				break;

			default:
				break;
			}

			pstm->Release();
		}

		if (!bSuccess && (pUnkDefault != NULL))
		{
			bSuccess = SUCCEEDED(pUnkDefault->QueryInterface(iid,
				(LPVOID*)ppUnk));
		}
	}
	else
	{
		if ((*ppUnk == NULL) ||
			_AfxIsSameUnknownObject(iid, *ppUnk, pUnkDefault))
		{
			bSuccess = TRUE;
		}
		else
		{
			++m_dwPropID;

			bSuccess = m_psec.SetName(m_dwPropID, pszPropName) &&
				_AfxSaveObjectInPropset(*ppUnk, m_psec, m_dwPropID);
		}
	}

	return bSuccess;
}

BOOL CPropsetPropExchange::ExchangeFontProp(LPCTSTR pszPropName,
		CFontHolder& font, const FONTDESC* pFontDesc,
		LPFONTDISP pFontDispAmbient)
{
	ASSERT(AfxIsValidString(pszPropName));
	ASSERT_POINTER(&font, CFontHolder);
	ASSERT_NULL_OR_POINTER(pFontDesc, FONTDESC);
	ASSERT_NULL_OR_POINTER(pFontDispAmbient, IFontDisp);

	BOOL bSuccess = FALSE;

	if (m_bLoading)
	{
		DWORD vtType;
		LPSTREAM pstm = _AfxLoadStreamFromPropset(m_psec, pszPropName, vtType);

		if (pstm != NULL)
		{
			LPFONT pFont;

			switch(vtType)
			{
			case VT_BLOB:
				pFont = _AfxCreateFontFromStream(pstm);
				break;

			case VT_BLOB_PROPSET:
				pFont = (LPFONT)_AfxCreateObjectFromStreamedPropset(pstm,
					IID_IFont);
				break;

			default:
				pFont = NULL;
			}

			if (pFont != NULL)
			{
				font.SetFont(pFont);
				bSuccess = TRUE;
			}

			pstm->Release();
		}

		if (!bSuccess)
		{
			// Initialize font to its default state
			font.InitializeFont(pFontDesc, pFontDispAmbient);
		}
	}
	else
	{
		if ((font.m_pFont == NULL) ||
			_AfxIsSameFont(font, pFontDesc, pFontDispAmbient))
		{
			bSuccess = TRUE;
		}
		else
		{
			++m_dwPropID;

			bSuccess = m_psec.SetName(m_dwPropID, pszPropName) &&
				_AfxSaveObjectInPropset(font.m_pFont, m_psec, m_dwPropID);
		}
	}

	return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpstm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPersistStreamInit

STDMETHODIMP_(ULONG) COleControl::XPersistStreamInit::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStreamInit)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPersistStreamInit::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStreamInit)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPersistStreamInit::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStreamInit)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPersistStreamInit::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStreamInit)
	return pThis->GetClassID(lpClassID);
}

STDMETHODIMP COleControl::XPersistStreamInit::IsDirty()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStreamInit)
	return pThis->m_bModified ? S_OK : S_FALSE;
}

STDMETHODIMP COleControl::XPersistStreamInit::Load(LPSTREAM pStm)
{
	METHOD_PROLOGUE_EX(COleControl, PersistStreamInit)
	return pThis->LoadState(pStm);
}

STDMETHODIMP COleControl::XPersistStreamInit::Save(LPSTREAM pStm,
	BOOL fClearDirty)
{
	METHOD_PROLOGUE_EX(COleControl, PersistStreamInit)

	// Delegate to SaveState.
	HRESULT hr = pThis->SaveState(pStm);

	// Bookkeeping:  Clear the dirty flag, if requested.
	if (fClearDirty)
		pThis->m_bModified = FALSE;

	return hr;
}

STDMETHODIMP COleControl::XPersistStreamInit::GetSizeMax(ULARGE_INTEGER*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XPersistStreamInit::InitNew()
{
	METHOD_PROLOGUE_EX(COleControl, PersistStreamInit)

	// Delegate to OnResetState.
	pThis->OnResetState();

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPersistMemory

STDMETHODIMP_(ULONG) COleControl::XPersistMemory::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistMemory)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPersistMemory::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistMemory)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPersistMemory::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistMemory)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPersistMemory::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistMemory)
	return pThis->GetClassID(lpClassID);
}

STDMETHODIMP COleControl::XPersistMemory::IsDirty()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistMemory)
	return pThis->m_bModified ? S_OK : S_FALSE;
}

STDMETHODIMP COleControl::XPersistMemory::Load(LPVOID lpStream, ULONG cbSize)
{
	METHOD_PROLOGUE_EX(COleControl, PersistMemory)

	HRESULT hr = S_OK;
	TRY
	{
		// Delegate to the Serialize method.
		CMemFile file((LPBYTE)lpStream, cbSize);
		CArchive ar(&file, CArchive::load);
		pThis->Serialize(ar);
	}
	CATCH_ALL(e)
	{
		// The load failed.  Delete any partially-initialized state.
		pThis->OnResetState();
		pThis->m_bInitialized = TRUE;
		hr = E_FAIL;
		DELETE_EXCEPTION(e);
	}
	END_CATCH_ALL

	// Clear the modified flag.
	pThis->m_bModified = FALSE;

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return hr;
}

STDMETHODIMP COleControl::XPersistMemory::Save(LPVOID, BOOL, ULONG)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XPersistMemory::GetSizeMax(ULONG*)
{
	return E_NOTIMPL;
}

STDMETHODIMP COleControl::XPersistMemory::InitNew()
{
	METHOD_PROLOGUE_EX(COleControl, PersistMemory)

	// Delegate to OnResetState.
	pThis->OnResetState();

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlquick.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AFXCTL_AMBIENT_CACHE implementation

THREAD_LOCAL(_AFXCTL_AMBIENT_CACHE, _afxAmbientCache)

_AFXCTL_AMBIENT_CACHE::_AFXCTL_AMBIENT_CACHE()
{
}

void _AFXCTL_AMBIENT_CACHE::Cache(QACONTAINER* pQAContainer)
{
	m_bValid = (pQAContainer != NULL);
	if (m_bValid)
	{
		m_dwAmbientFlags = pQAContainer->dwAmbientFlags;
		m_colorFore = pQAContainer->colorFore;
		m_colorBack = pQAContainer->colorBack;
		m_pFont = pQAContainer->pFont;
		m_pReserved = pQAContainer->pUndoMgr;
		m_dwAppearance = pQAContainer->dwAppearance;
		if (m_pFont != NULL)
			m_pFont->AddRef();
	}
	else
	{
		if (m_pFont != NULL)
			m_pFont->Release();
		m_dwAmbientFlags = 0;
		m_colorFore = 0;
		m_colorBack = 0;
		m_pFont = NULL;
		m_pReserved = NULL;
		m_dwAppearance = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::XQuickActivate

STDMETHODIMP_(ULONG) COleControl::XQuickActivate::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XQuickActivate::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XQuickActivate::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XQuickActivate::QuickActivate(
	QACONTAINER *pQAContainer, QACONTROL *pQAControl)
{
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)

	// Get the IOleObject interface
	HRESULT hr = S_OK;
	IOleObject* pOleObject = NULL;
	if (FAILED(hr = pThis->ExternalQueryInterface(&IID_IOleObject,
		reinterpret_cast<void**>(&pOleObject))))
	{
		return hr;
	}

	// Keep copy of ambient properties
	_afxAmbientCache->Cache(pQAContainer);

	// Set client site
	ASSERT(pOleObject != NULL);
	pOleObject->SetClientSite(pQAContainer->pClientSite);

	// Establish connections
	DWORD dwDummy;
	if (pQAContainer->pAdviseSink != NULL)
		pOleObject->Advise(pQAContainer->pAdviseSink, &dwDummy);

	if (pQAContainer->pPropertyNotifySink != NULL)
		pThis->m_xPropConnPt.m_xConnPt.Advise(pQAContainer->pPropertyNotifySink,
			&pQAControl->dwPropNotifyCookie);
	if (pQAContainer->pUnkEventSink != NULL)
		pThis->m_xEventConnPt.m_xConnPt.Advise(pQAContainer->pUnkEventSink,
			&pQAControl->dwEventCookie);

	// Fill in return values
	IViewObjectEx* pViewObject;
	if (SUCCEEDED(pThis->ExternalQueryInterface(&IID_IViewObjectEx,
		reinterpret_cast<void**>(&pViewObject))))
	{
		pViewObject->GetViewStatus(&pQAControl->dwViewStatus);

		// Set advise sink on IViewObject, while we're here.
		if (pQAContainer->pAdviseSink != NULL)
			pViewObject->SetAdvise(DVASPECT_CONTENT, 0, pQAContainer->pAdviseSink);

		pViewObject->Release();
	}
	else
	{
		pQAControl->dwViewStatus = 0;
	}

	pOleObject->GetMiscStatus(DVASPECT_CONTENT, &pQAControl->dwMiscStatus);

	pOleObject->Release();

	return S_OK;
}

STDMETHODIMP COleControl::XQuickActivate::SetContentExtent(LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)
	return pThis->m_xOleObject.SetExtent(DVASPECT_CONTENT, lpsizel);
}

STDMETHODIMP COleControl::XQuickActivate::GetContentExtent(LPSIZEL lpsizel)
{
	METHOD_PROLOGUE_EX_(COleControl, QuickActivate)
	return pThis->m_xOleObject.GetExtent(DVASPECT_CONTENT, lpsizel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlrefl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CReflectorWnd

BOOL CReflectorWnd::Create(const CRect& rect, HWND hWndParent)
{
	// make sure the default window class is registered
	VERIFY(AfxDeferRegisterClass(AFX_WNDOLECONTROL_REG));
	return CreateEx(0, AFX_WNDOLECONTROL, NULL,
		WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS, rect.left, rect.top,
		rect.right - rect.left, rect.bottom - rect.top, hWndParent, 0);
}

void CReflectorWnd::PostNcDestroy()
{
	if (m_pCtrl != NULL)
		m_pCtrl->OnReflectorDestroyed();
	delete this;
}

LRESULT CReflectorWnd::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_COMMAND:
	case WM_NOTIFY:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_COMPAREITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_PARENTNOTIFY:
		if (m_pCtrl != NULL)
			return m_pCtrl->SendMessage(OCM__BASE + uMsg, wParam, lParam);
		break;

	case WM_SETFOCUS:
		if (m_pCtrl != NULL)
		{
			m_pCtrl->SetFocus();
			return 0;
		}
		break;
	}

	return CWnd::WindowProc(uMsg, wParam, lParam);
}

void CReflectorWnd::SetControl(COleControl* pCtrl)
{
	m_pCtrl = pCtrl;
}

LRESULT CParkingWnd::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND hWndSource = NULL;

	switch (uMsg)
	{
	case WM_COMMAND:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
		hWndSource = (HWND)lParam;
		break;

	case WM_NOTIFY:
		hWndSource = ((NMHDR*)lParam)->hwndFrom;
		break;

	case WM_DRAWITEM:
		hWndSource = ((DRAWITEMSTRUCT*)lParam)->hwndItem;
		break;

	case WM_MEASUREITEM:
		m_idMap.Lookup((void*)(DWORD_PTR)HIWORD(wParam), (void*&)hWndSource);
		break;

	case WM_DELETEITEM:
		hWndSource = ((DELETEITEMSTRUCT*)lParam)->hwndItem;
		break;

	case WM_COMPAREITEM:
		hWndSource = ((COMPAREITEMSTRUCT*)lParam)->hwndItem;
		break;

	case WM_PARENTNOTIFY:
		switch (LOWORD(wParam))
		{
		case WM_CREATE:
			m_idMap.SetAt((void*)(DWORD_PTR)HIWORD(wParam), (HWND)lParam);
			hWndSource = (HWND)lParam;
			break;

		case WM_DESTROY:
			m_idMap.RemoveKey((void*)(DWORD_PTR)HIWORD(wParam));
			hWndSource = (HWND)lParam;
			break;

		default:
			m_idMap.Lookup((void*)(DWORD_PTR)HIWORD(wParam), (void*&)hWndSource);
			break;
		}
	}

	if (hWndSource != NULL)
		return ::SendMessage(hWndSource, OCM__BASE + uMsg, wParam, lParam);
	else
		return CWnd::WindowProc(uMsg, wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlpstg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// COleControl::XPersistStorage

STDMETHODIMP_(ULONG) COleControl::XPersistStorage::AddRef()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleControl::XPersistStorage::Release()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleControl::XPersistStorage::QueryInterface(
	REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP COleControl::XPersistStorage::GetClassID(LPCLSID lpClassID)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)
	return pThis->GetClassID(lpClassID);
}

STDMETHODIMP COleControl::XPersistStorage::IsDirty()
{
	// Return S_OK if modified, and S_FALSE otherwise.
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	BOOL bDefModified = (pThis->m_pDefIPersistStorage->IsDirty() == S_OK);
	return (bDefModified || pThis->m_bModified) ? S_OK : S_FALSE;
}

STDMETHODIMP COleControl::XPersistStorage::InitNew(LPSTORAGE pStg)
{
	METHOD_PROLOGUE_EX(COleControl, PersistStorage)

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	pThis->m_pDefIPersistStorage->InitNew(pStg);

	// Delegate to OnResetState.
	pThis->OnResetState();

	// Unless IOleObject::SetClientSite is called after this, we can
	// count on ambient properties being available while loading.
	pThis->m_bCountOnAmbients = TRUE;

	// Properties have been initialized
	pThis->m_bInitialized = TRUE;

	// Uncache cached ambient properties
	_afxAmbientCache->Cache(NULL);

	return S_OK;
}

STDMETHODIMP COleControl::XPersistStorage::Load(LPSTORAGE pStg)
{
	ASSERT(pStg != NULL);
	METHOD_PROLOGUE_EX(COleControl, PersistStorage)

	CLIPFORMAT cf;
	HRESULT hr;
	CLSID fmtid;

	hr = ::ReadFmtUserTypeStg(pStg, &cf, NULL);

	if (SUCCEEDED(hr) && _AfxOleMatchPropsetClipFormat(cf, &fmtid))
	{
		// Load the property set data
		FORMATETC formatEtc;
		STGMEDIUM stgMedium;
		formatEtc.cfFormat = cf;
		formatEtc.ptd = NULL;
		formatEtc.dwAspect = DVASPECT_CONTENT;
		formatEtc.lindex = -1;
		formatEtc.tymed = TYMED_ISTORAGE;
		stgMedium.tymed = TYMED_ISTORAGE;
		stgMedium.pstg = pStg;
		stgMedium.pUnkForRelease = NULL;
		hr = pThis->SetPropsetData(&formatEtc, &stgMedium, fmtid) ?
			S_OK : E_FAIL;
	}
	else
	{
		// Open the "Contents" stream of the supplied storage object, and
		// then delegate to same implementation as IPersistStreamInit::Load.
		LPSTREAM pStm = NULL;
		hr = pStg->OpenStream(OLESTR("Contents"), NULL,
			STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm);

		ASSERT(FAILED(hr) || pStm != NULL);

		if (pStm != NULL)
		{
			// Delegate to LoadState.
			hr = pThis->LoadState(pStm);
			pStm->Release();
		}
	}

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	// Delegate to default handler (for cache).
	pThis->m_pDefIPersistStorage->Load(pStg);

	return hr;
}

STDMETHODIMP COleControl::XPersistStorage::Save(LPSTORAGE pStg,
	BOOL fSameAsLoad)
{
	METHOD_PROLOGUE_EX(COleControl, PersistStorage)
	ASSERT(pStg != NULL);

	// Create a "Contents" stream on the supplied storage object, and
	// then delegate to the implementation of IPersistStreamInit::Save.

	// Don't bother saving if destination is up-to-date.
	if (fSameAsLoad && (IsDirty() != S_OK))
		return S_OK;

	LPSTREAM pStm = NULL;
	HRESULT hr = pStg->CreateStream(OLESTR("Contents"),
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &pStm);

	ASSERT(FAILED(hr) || pStm != NULL);

	if (pStm != NULL)
	{
		// Delegate to SaveState.
		hr = pThis->SaveState(pStm);

		// Bookkeeping:  Clear the dirty flag, if storage is same.
		if (fSameAsLoad)
			pThis->m_bModified = FALSE;

		pStm->Release();
	}

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	// Delegate to default handler (for cache).
	pThis->m_pDefIPersistStorage->Save(pStg, fSameAsLoad);
	return hr;
}

STDMETHODIMP COleControl::XPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	if (pStgSaved != NULL)
		pThis->m_bModified = FALSE;

	return pThis->m_pDefIPersistStorage->SaveCompleted(pStgSaved);
}

STDMETHODIMP COleControl::XPersistStorage::HandsOffStorage()
{
	METHOD_PROLOGUE_EX_(COleControl, PersistStorage)

	if (pThis->m_pDefIPersistStorage == NULL)
		pThis->m_pDefIPersistStorage =
			(LPPERSISTSTORAGE)pThis->QueryDefHandler(IID_IPersistStorage);

	return pThis->m_pDefIPersistStorage->HandsOffStorage();
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctlreg.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "sal.h"



#define new DEBUG_NEW

#define GUID_CCH    39  // Characters in string form of guid, including '\0'

#define _AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)	\
	if( ( HKEY_CLASSES_ROOT == hKey ) && ( TRUE == AfxGetPerUserRegistration() ) )\
	{\
		strSubKey = _T("Software\\Classes\\") + strSubKey;\
		hKey = HKEY_CURRENT_USER;\
	}

inline BOOL _AfxRegDeleteKeySucceeded(LONG error)
{
	return (error == ERROR_SUCCESS) || (error == ERROR_BADKEY) ||
		(error == ERROR_FILE_NOT_FOUND);
}

// Under Win32, a reg key may not be deleted unless it is empty.
// Thus, to delete a tree,  one must recursively enumerate and
// delete all of the sub-keys.

LONG AFXAPI _AfxRecursiveRegDeleteKey(HKEY hParentKey, _In_ LPTSTR szKeyName)
{
	// one implementation for everybody
	return AfxDelRegTreeHelper(hParentKey, szKeyName);
}

void _AfxUnregisterInterfaces(ITypeLib* pTypeLib)
{
	TCHAR szKey[128];
	Checked::tcscpy_s(szKey, _countof(szKey), _T("Interface\\"));
	LPTSTR pszGuid = szKey + lstrlen(szKey);

	int cTypeInfo = pTypeLib->GetTypeInfoCount();

	for (int i = 0; i < cTypeInfo; i++)
	{
		TYPEKIND tk;
		if (SUCCEEDED(pTypeLib->GetTypeInfoType(i, &tk)) &&
			(tk == TKIND_DISPATCH || tk == TKIND_INTERFACE))
		{
			ITypeInfo* pTypeInfo = NULL;
			if (SUCCEEDED(pTypeLib->GetTypeInfo(i, &pTypeInfo)))
			{
				TYPEATTR* pTypeAttr;
				if (SUCCEEDED(pTypeInfo->GetTypeAttr(&pTypeAttr)))
				{
#if defined(_UNICODE)
					StringFromGUID2(pTypeAttr->guid, pszGuid, GUID_CCH);
#else
					WCHAR wszGuid[39];
					StringFromGUID2(pTypeAttr->guid, wszGuid, GUID_CCH);
					_wcstombsz(pszGuid, wszGuid, GUID_CCH);
#endif
					_AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
					pTypeInfo->ReleaseTypeAttr(pTypeAttr);
				}

				pTypeInfo->Release();
			}
		}
	}
}

BOOL AFXAPI AfxOleRegisterTypeLib(HINSTANCE hInstance, REFGUID tlid,
	LPCTSTR pszFileName, LPCTSTR pszHelpDir)
{	
	BOOL bSuccess = FALSE;
	CStringW strPathNameW;
	wchar_t *szPathNameW = strPathNameW.GetBuffer(_MAX_PATH);
	::GetModuleFileNameW(hInstance, szPathNameW, _MAX_PATH);
	strPathNameW.ReleaseBuffer();
	LPTYPELIB ptlib = NULL;
	// If a filename was specified, replace final component of path with it.
	if (pszFileName != NULL)
	{
		int iBackslash = strPathNameW.ReverseFind('\\');
		if (iBackslash != -1)
			strPathNameW = strPathNameW.Left(iBackslash+1);
		strPathNameW += pszFileName;
	}
	if (SUCCEEDED(LoadTypeLib(strPathNameW.GetString(), &ptlib)))
	{
		ASSERT_POINTER(ptlib, ITypeLib);

		LPTLIBATTR pAttr;
		GUID tlidActual = GUID_NULL;

		if (SUCCEEDED(ptlib->GetLibAttr(&pAttr)))
		{
			ASSERT_POINTER(pAttr, TLIBATTR);
			tlidActual = pAttr->guid;
			ptlib->ReleaseTLibAttr(pAttr);
		}

		// Check that the guid of the loaded type library matches
		// the tlid parameter.
		ASSERT(IsEqualGUID(tlid, tlidActual));

		if (IsEqualGUID(tlid, tlidActual))
		{
			// Register the type library.
			const CStringW strHelpDir(pszHelpDir);

			typedef HRESULT (STDAPICALLTYPE *PFNREGISTERTYPELIB)(ITypeLib *, LPCOLESTR /* const szFullPath */, LPCOLESTR /* const szHelpDir */);
			PFNREGISTERTYPELIB pfnRegisterTypeLib = NULL;

			if( TRUE == AfxGetPerUserRegistration() )
			{
				HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");
				if(hmodOleAut)
				{
					pfnRegisterTypeLib=reinterpret_cast<PFNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "RegisterTypeLibForUser"));
				}
			}

			if( NULL == pfnRegisterTypeLib )
			{
				pfnRegisterTypeLib = (PFNREGISTERTYPELIB)&RegisterTypeLib;
			}

			if (SUCCEEDED(pfnRegisterTypeLib(ptlib,const_cast<LPWSTR>(strPathNameW.GetString()) , 
													const_cast<LPWSTR>(strHelpDir.GetString())  )))
			{
				bSuccess = TRUE;
			}
		}

		RELEASE(ptlib);
	}
	else
	{
		TRACE(traceAppMsg, 0, L"Warning: Could not load type library from %s\n", strPathNameW);
	}

	return bSuccess;
}

#define TYPELIBWIN   _T("win32")
#define TYPELIBWIN_2 _T("win16")

BOOL AFXAPI AfxOleUnregisterTypeLib(REFGUID tlid, WORD wVerMajor,
	WORD wVerMinor, LCID lcid)
{

	// Load type library before unregistering it.
	ITypeLib* pTypeLib = NULL;
	if (wVerMajor != 0)
	{
		if (FAILED(LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, &pTypeLib)))
			pTypeLib = NULL;
	}

	// Format typelib guid as a string
	OLECHAR szTypeLibID[GUID_CCH];
	int cchGuid = ::StringFromGUID2(tlid, szTypeLibID, GUID_CCH);

	ASSERT(cchGuid == GUID_CCH);    // Did StringFromGUID2 work?
	if (cchGuid != GUID_CCH)
		return FALSE;

	TCHAR szKeyTypeLib[_MAX_PATH];
	BOOL bSurgical = FALSE;
	LONG error = ERROR_SUCCESS;

	const CString strTypeLibID(szTypeLibID);
	if (-1 == _stprintf_s(szKeyTypeLib, _countof(szKeyTypeLib), _T("TYPELIB\\%s"), strTypeLibID.GetString()))
		return FALSE;

	HKEY hKeyTypeLib;
	if (AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, szKeyTypeLib, 0, KEY_READ | DELETE, &hKeyTypeLib) ==
		ERROR_SUCCESS)
	{
		int iKeyVersion = 0;
		HKEY hKeyVersion;
		TCHAR szVersion[_MAX_PATH];

		// Iterate through all installed versions of the control

		while (RegEnumKey(hKeyTypeLib, iKeyVersion, szVersion, _MAX_PATH) ==
			ERROR_SUCCESS)
		{
			hKeyVersion = NULL;
			BOOL bSurgicalVersion = FALSE;

			if (RegOpenKeyEx(hKeyTypeLib, szVersion, 0, KEY_READ | DELETE, &hKeyVersion) !=
				ERROR_SUCCESS)
			{
				++iKeyVersion;
				continue;
			}

			int iKeyLocale = 0;
			HKEY hKeyLocale;
			TCHAR szLocale[_MAX_PATH];

			// Iterate through all registered locales for this version

			while (RegEnumKey(hKeyVersion, iKeyLocale, szLocale, _MAX_PATH) ==
				ERROR_SUCCESS)
			{
				// Don't remove HELPDIR or FLAGS keys.
				if ((::AfxInvariantStrICmp(szLocale, _T("HELPDIR")) == 0) ||
					(::AfxInvariantStrICmp(szLocale, _T("FLAGS")) == 0))
				{
					++iKeyLocale;
					continue;
				}

				hKeyLocale = NULL;

				if (RegOpenKeyEx(hKeyVersion, szLocale, 0, KEY_READ | DELETE, &hKeyLocale) !=
					ERROR_SUCCESS)
				{
					++iKeyLocale;
					continue;
				}

				// Check if a 16-bit key is found when unregistering 32-bit
				HKEY hkey;
				if (RegOpenKeyEx(hKeyLocale, TYPELIBWIN_2, 0, STANDARD_RIGHTS_READ, &hkey) ==
					ERROR_SUCCESS)
				{
					RegCloseKey(hkey);

					// Only remove the keys specific to the 32-bit version
					// of control, leaving things intact for 16-bit version.
					error = _AfxRecursiveRegDeleteKey(hKeyLocale, TYPELIBWIN);
					bSurgicalVersion = TRUE;
					RegCloseKey(hKeyLocale);
				}
				else
				{
					// Delete everything for this locale.
					RegCloseKey(hKeyLocale);
					if (_AfxRecursiveRegDeleteKey(hKeyVersion, szLocale) ==
						ERROR_SUCCESS)
					{
						// Start over again, so we don't skip anything.
						iKeyLocale = 0;
						continue;
					}
				}
				++iKeyLocale;
			}
			RegCloseKey(hKeyVersion);

			if (bSurgicalVersion)
			{
				bSurgical = TRUE;
			}
			else
			{
				if (_AfxRecursiveRegDeleteKey(hKeyTypeLib, szVersion) ==
					ERROR_SUCCESS)
				{
					// Start over again, to make sure we don't skip anything.
					iKeyVersion = 0;
					continue;
				}
			}

			++iKeyVersion;
		}
		RegCloseKey(hKeyTypeLib);
	}

	if (!bSurgical)
		error = _AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKeyTypeLib);

	if (_AfxRegDeleteKeySucceeded(error))
	{
		// If type library was unregistered successfully, then also unregister
		// interfaces.
		if (pTypeLib != NULL)
		{
			ITypeLib* pDummy = NULL;
			if (FAILED(LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, &pDummy)))
				_AfxUnregisterInterfaces(pTypeLib);
			else
				pDummy->Release();

			pTypeLib->Release();
		}
	}

	return _AfxRegDeleteKeySucceeded(error);
}

AFX_STATIC_DATA const LPCTSTR _afxCtrlProgID[] =
{
	_T("\0") _T("%1"),
	_T("CLSID\0") _T("%2"),
	NULL
};

#define INPROCSERVER   _T("InprocServer32")
#define INPROCSERVER_2 _T("InprocServer")
#define TOOLBOXBITMAP  _T("ToolboxBitmap32")

AFX_STATIC_DATA const LPCTSTR _afxCtrlClassID[] =
{
	_T("\0") _T("%1"),
	_T("ProgID\0") _T("%2"),
	INPROCSERVER _T("\0%3"),
	TOOLBOXBITMAP _T("\0%3, %4"),
	_T("MiscStatus\0") _T("0"),
	_T("MiscStatus\\1\0") _T("%5"),
	_T("Control\0") _T(""),
	_T("TypeLib\0") _T("%6"),
	_T("Version\0") _T("%7"),
	NULL
};

BOOL AFXAPI AfxOleRegisterControlClass(HINSTANCE hInstance,
	REFCLSID clsid, LPCTSTR pszProgID, UINT idTypeName, UINT idBitmap,
	int nRegFlags, DWORD dwMiscStatus, REFGUID tlid, WORD wVerMajor,
	WORD wVerMinor)
{	
	BOOL bSuccess = FALSE;

	// Format class ID as a string
	OLECHAR szClassID[GUID_CCH];
	int cchGuid = ::StringFromGUID2(clsid, szClassID, GUID_CCH);
	const CString strClassID(szClassID);

	ASSERT(cchGuid == GUID_CCH);    // Did StringFromGUID2 work?
	if (cchGuid != GUID_CCH)
		return FALSE;

	// Format typelib guid as a string
	
	CString strTypeLibID;	
	OLECHAR szTypeLibID[GUID_CCH];
	cchGuid = ::StringFromGUID2(tlid, szTypeLibID, GUID_CCH);

	ASSERT(cchGuid == GUID_CCH);    // Did StringFromGUID2 work?
	if (cchGuid != GUID_CCH)
		return FALSE;

	CString strPathName;
	AfxGetModuleFileName(hInstance, strPathName);

	CString strTypeName;
	if (!strTypeName.LoadString(idTypeName))
	{
		ASSERT(FALSE);  // Name string not present in resources
		strTypeName = strClassID; // Use Class ID instead
	}

	TCHAR szBitmapID[_MAX_PATH];
	Checked::itot_s(idBitmap, szBitmapID, _MAX_PATH, 10);

	TCHAR szMiscStatus[_MAX_PATH];
	Checked::ltot_s(dwMiscStatus, szMiscStatus, _MAX_PATH, 10);

	// Format version string as "major.minor"
	TCHAR szVersion[_MAX_PATH];
	_stprintf_s(szVersion, _countof(szVersion), _T("%d.%d"), wVerMajor, wVerMinor);

	const TCHAR* szPerUserRegistration = {_T("Software\\Classes\\")};

	HKEY hkeyRootKey = HKEY_CLASSES_ROOT;
	const TCHAR* szRedirection = {_T("")};

	if( TRUE == AfxGetPerUserRegistration() )
	{
		szRedirection = szPerUserRegistration;
		hkeyRootKey = HKEY_CURRENT_USER;
	}

	// Attempt to open registry keys.
	::ATL::CRegKey hkeyClassID;
	::ATL::CRegKey hkeyProgID;

	TCHAR szScratch[_MAX_PATH];
	TCHAR szProgID[_MAX_PATH];

	if (-1 == _stprintf_s(szScratch, _countof(szScratch), _T("%sCLSID\\%s"), szRedirection, strClassID.GetString()))
	{
		return FALSE;
	}
	if (-1 == _stprintf_s(szProgID, _countof(szProgID), _T("%s%s"), szRedirection, pszProgID))
	{
		return FALSE;
	}

	if (hkeyClassID.Create(hkeyRootKey, szScratch, NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL) != ERROR_SUCCESS)
	{
		return FALSE;
	}
	if (hkeyProgID.Create(hkeyRootKey, szProgID, NULL, 0, KEY_READ | KEY_WRITE, NULL, NULL) !=ERROR_SUCCESS) 
	{
        	return FALSE;
	}

	ASSERT(hkeyClassID != NULL);
	ASSERT(hkeyProgID != NULL);

	LPCTSTR rglpszSymbols[7];
	rglpszSymbols[0] = strTypeName;
	rglpszSymbols[1] = strClassID;
	bSuccess = AfxOleRegisterHelper(_afxCtrlProgID, rglpszSymbols, 2,
		TRUE, hkeyProgID);
	
	if (!bSuccess)
	{
		return FALSE;
	}

	rglpszSymbols[1] = pszProgID;
	rglpszSymbols[2] = strPathName;
	rglpszSymbols[3] = szBitmapID;
	rglpszSymbols[4] = szMiscStatus;
	strTypeLibID=szTypeLibID;
	rglpszSymbols[5] = strTypeLibID.GetString();
	rglpszSymbols[6] = szVersion;
	bSuccess = AfxOleRegisterHelper(_afxCtrlClassID, rglpszSymbols, 7,
		TRUE, hkeyClassID);

	if (!bSuccess)
	{
		return FALSE;
	}

	bSuccess = AfxOleInprocRegisterHelper(hkeyProgID, hkeyClassID, nRegFlags);

	return bSuccess;
}

BOOL AFXAPI AfxOleUnregisterClass(REFCLSID clsid, LPCTSTR pszProgID)
{	

	// Format class ID as a string
	OLECHAR szClassID[GUID_CCH];
	int cchGuid = ::StringFromGUID2(clsid, szClassID, GUID_CCH);
	const CString strClassID(szClassID);
	

	ASSERT(cchGuid == GUID_CCH);    // Did StringFromGUID2 work?
	if (cchGuid != GUID_CCH)
		return FALSE;

	TCHAR szKey[_MAX_PATH];
	long error;
	BOOL bRetCode = TRUE;

	// check to see if a 16-bit InprocServer key is found when unregistering
	// 32-bit (or vice versa).
	if (-1 == _stprintf_s(szKey, _countof(szKey), _T("CLSID\\%s\\%s"), strClassID.GetString(), INPROCSERVER_2))
		return FALSE;

	HKEY hkey=NULL;
	BOOL bSurgical = (AfxRegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, STANDARD_RIGHTS_READ, &hkey) == ERROR_SUCCESS);
	RegCloseKey(hkey);

	if (bSurgical)
	{
		// Only remove the keys specific to this version of the control,
		// leaving things in tact for the other version.
		if (-1 == _stprintf_s(szKey, _countof(szKey), _T("CLSID\\%s\\%s"), strClassID.GetString(), INPROCSERVER))
			return FALSE;
		error = AfxRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
		bRetCode = bRetCode && _AfxRegDeleteKeySucceeded(error);

		if (-1 == _stprintf_s(szKey, _countof(szKey), _T("CLSID\\%s\\%s"), strClassID.GetString(), TOOLBOXBITMAP))
			return FALSE;
		error = AfxRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
		bRetCode = bRetCode && _AfxRegDeleteKeySucceeded(error);
	}
	else
	{
		// No other versions of this control were detected,
		// so go ahead and remove the control completely.
		if (-1 == _stprintf_s(szKey, _countof(szKey), _T("CLSID\\%s"), strClassID.GetString()))
			return FALSE;
		error = _AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
		bRetCode = bRetCode && _AfxRegDeleteKeySucceeded(error);

		if ((pszProgID != NULL) && (lstrlen(pszProgID) > 0))
		{
			error = _AfxRecursiveRegDeleteKey(HKEY_CLASSES_ROOT,
				(LPTSTR)pszProgID);
			bRetCode = bRetCode && _AfxRegDeleteKeySucceeded(error);
		}
	}

	return bRetCode;
}

AFX_STATIC_DATA const LPCTSTR _afxPropPageClass[] =
{
	_T("\0") _T("%1"),
	INPROCSERVER _T("\0%2"),
	NULL
};

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName)
{
	return AfxOleRegisterPropertyPageClass(hInstance, clsid, idTypeName, 0);
}

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName, int nRegFlags)
{
	ASSERT(!(nRegFlags & afxRegInsertable));    // can't be insertable

	BOOL bSuccess = FALSE;

	// Format class ID as a string
	OLECHAR szClassID[GUID_CCH];
	int cchGuid = ::StringFromGUID2(clsid, szClassID, GUID_CCH);
	const CString strClassID(szClassID);
	
	ASSERT(cchGuid == GUID_CCH);    // Did StringFromGUID2 work?
	if (cchGuid != GUID_CCH)
		return FALSE;

	CString strPathName;
	AfxGetModuleFileName(hInstance, strPathName);

	CString strTypeName;
	if (!strTypeName.LoadString(idTypeName))
	{
		ASSERT(FALSE);  // Name string not present in resources
		strTypeName = strClassID; // Use Class ID instead
	}

	HKEY hkeyClassID = NULL;

	TCHAR szKey[_MAX_PATH];
	if (-1 == _stprintf_s(szKey, _countof(szKey), _T("CLSID\\%s"), strClassID.GetString()))
		return FALSE;
	if (AfxRegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkeyClassID) != ERROR_SUCCESS)
		goto Error;

	LPCTSTR rglpszSymbols[2];
	rglpszSymbols[0] = strTypeName;
	rglpszSymbols[1] = strPathName;
	bSuccess = AfxOleRegisterHelper(_afxPropPageClass, rglpszSymbols, 2, TRUE, hkeyClassID);

	if (!bSuccess)
		goto Error;

	AfxOleInprocRegisterHelper(NULL, hkeyClassID, nRegFlags);

Error:
	if (hkeyClassID != NULL)
		::RegCloseKey(hkeyClassID);

	return bSuccess;
}

LONG AFXAPI AfxRegCreateKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult, CAtlTransactionManager* pTM)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	DWORD dw = 0;

	return pTM != NULL ? 
		pTM->RegCreateKeyEx(hKey, strSubKey, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, phkResult, &dw) : 
		::RegCreateKeyEx(hKey, strSubKey, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, phkResult, &dw);
}

LONG AFXAPI AfxRegOpenKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult, CAtlTransactionManager* pTM)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	return pTM != NULL ? 
		pTM->RegOpenKeyEx(hKey, strSubKey, 0, KEY_WRITE | KEY_READ, phkResult) : 
		::RegOpenKeyEx(hKey, strSubKey, 0, KEY_WRITE | KEY_READ, phkResult);
}

LONG AFXAPI AfxRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey,  DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, CAtlTransactionManager* pTM)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	return pTM != NULL ? 
		pTM->RegOpenKeyEx(hKey, strSubKey, ulOptions, samDesired, phkResult) :
		::RegOpenKeyEx(hKey, strSubKey, ulOptions, samDesired, phkResult);
}

LONG AFXAPI AfxRegQueryValue(HKEY hKey, LPCTSTR lpSubKey,  LPTSTR lpValue,  PLONG lpcbValue)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	return ::RegQueryValue(hKey, strSubKey, lpValue, lpcbValue);
}

LONG AFXAPI AfxRegSetValue(HKEY hKey, LPCTSTR lpSubKey,  DWORD dwType, LPCTSTR lpData,  DWORD cbData)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	return ::RegSetValue(hKey, strSubKey, dwType, lpData, cbData);
}

LONG AFXAPI AfxRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey, CAtlTransactionManager* pTM)
{
	CString strSubKey = lpSubKey;

	_AFX_REDIRECT_REGISTRY_HIVE(hKey, strSubKey)

	return pTM != NULL ? 
		pTM->RegDeleteKey(hKey, strSubKey) : 
		::RegDeleteKey(hKey, strSubKey);
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\ctltrack.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#define new DEBUG_NEW

AFX_STATIC_DATA const int _afxResizeStyle =
	CRectTracker::resizeInside | CRectTracker::resizeOutside;

AFX_STATIC void AFXAPI _AfxOffsetTrackerRect(CRect& rect, CWnd* pWnd)
{
	DWORD dwStyle = pWnd->GetStyle();
	DWORD dwExStyle = pWnd->GetExStyle();

	int nBorders = ((dwStyle & WS_BORDER) != 0) +
		((dwExStyle & WS_EX_CLIENTEDGE) != 0) * 2;

	int dx = -nBorders * GetSystemMetrics(SM_CXBORDER);
	int dy = -nBorders * GetSystemMetrics(SM_CYBORDER);

	if (dwExStyle & WS_EX_LEFTSCROLLBAR)
		dx -= GetSystemMetrics(SM_CXVSCROLL);

	rect.OffsetRect(dx - rect.left, dy - rect.top);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::CreateTracker - Creates tracker for UIActive control

void COleControl::CreateTracker(BOOL bHandles, BOOL bHatching)
{
	CreateTracker(bHandles, bHatching, NULL);
}

void COleControl::CreateTracker(BOOL bHandles, BOOL bHatching, LPCRECT prcClip)
{
	ASSERT(bHandles || bHatching);
#ifdef _AFXDLL
	ASSERT(!m_bOpen);
#endif
	ASSERT(m_bUIActive);
	ASSERT(m_pRectTracker == NULL);

	UINT nStyle = 0;
	if (bHandles)
		nStyle |= CRectTracker::resizeOutside;
	if (bHatching)
		nStyle |= CRectTracker::hatchedBorder;

	ASSERT(nStyle != 0);

	TRY
	{
		// Create the tracker.
		CRect rectTmp = m_rcPos;
		_AfxOffsetTrackerRect(rectTmp, this);
		m_pRectTracker = new CControlRectTracker(rectTmp, nStyle);

		// Reset the window sizes, reflecting the tracker
		if (prcClip != NULL)
			m_pRectTracker->m_rectClip = *prcClip;
		else
			prcClip = m_rcPos;
		OnSetObjectRects(m_rcPos, prcClip);
	}
	CATCH (CException, e)
	{
		// If anything went wrong, just continue without the tracker.
		if (m_pRectTracker != NULL)
		{
			delete m_pRectTracker;
			m_pRectTracker = NULL;
		}
	}
	END_CATCH
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::DestroyTracker - destroys tracker when control UIDeactivates

void COleControl::DestroyTracker()
{
#ifdef _AFXDLL
	ASSERT(!m_bOpen);
#endif
	ASSERT(m_bUIActive);

	if (m_pRectTracker == NULL)
		return;

	// Destroy the tracker.
	CRect rectClip = m_pRectTracker->m_rectClip;
	delete m_pRectTracker;
	m_pRectTracker = NULL;

	// Reset the position based on no tracker present
	OnSetObjectRects(m_rcPos, rectClip);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnNcPaint - handler for WM_NCPAINT message

void COleControl::OnNcPaint()
{
#ifdef _AFXDLL
	if (m_bOpen || m_pRectTracker == NULL)
#else
	if (m_pRectTracker == NULL)
#endif
	{
		Default();
		return;
	}

	DWORD dwStyle = GetStyle();
	DWORD dwExStyle = GetExStyle();
	DWORD dwScrollStyle = dwStyle & (WS_HSCROLL | WS_VSCROLL);

	// Paint scrollbars, if any.
	if (dwScrollStyle != 0)
		Default();

	UINT nHandleSize = m_pRectTracker->m_nHandleSize - 1;
	CWindowDC dc(this);

	// Convert client coords to window coords, draw tracker, and convert back.
	CRect& rectTrack = m_pRectTracker->m_rect;
	int dx = rectTrack.left - nHandleSize;
	int dy = rectTrack.top - nHandleSize;
	rectTrack.OffsetRect(-dx, -dy);
	CRect rc = rectTrack;
	m_pRectTracker->Draw(&dc);
	m_pRectTracker->m_rect.OffsetRect(dx, dy);

	// Draw border, if any.
	_AfxDrawBorders(&dc, rc, (dwStyle & WS_BORDER),
		(dwExStyle & WS_EX_CLIENTEDGE));

	if (dwScrollStyle == (WS_HSCROLL | WS_VSCROLL))
	{
		// Workaround for Windows bug:
		// Draw the corner between the scrollbars

		int cxVScroll = GetSystemMetrics(SM_CXVSCROLL);

		if (dwExStyle & WS_EX_LEFTSCROLLBAR)    // Middle East Windows only
			rc.right = rc.left + cxVScroll;
		else
			rc.left = rc.right - cxVScroll;

		rc.top = rc.bottom - GetSystemMetrics(SM_CYVSCROLL);

		CBrush brushGUI(GetSysColor(COLOR_3DFACE));
		dc.FillRect(rc, &brushGUI);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnNcCalcSize - handler for WM_NCCALCSIZE message

void COleControl::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS* lpParams)
{
	Default();

#ifdef _AFXDLL
	if (m_bOpen || m_pRectTracker == NULL)
#else
	if (m_pRectTracker == NULL)
#endif
		return;

	// Adjust client rect to make room for tracker.
	UINT nHandleSize = m_pRectTracker->m_nHandleSize - 1;
	::InflateRect(lpParams->rgrc, -(int)nHandleSize, -(int)nHandleSize);

	m_pRectTracker->m_rect = m_rcPos;
	_AfxOffsetTrackerRect(m_pRectTracker->m_rect, this);
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnNcHitTest - handler for WM_NCHITTEST message

LRESULT COleControl::OnNcHitTest(CPoint point)
{
#ifdef _AFXDLL
	if (m_bOpen || m_pRectTracker == NULL ||
#else
	if (m_pRectTracker == NULL ||
#endif
		!(m_pRectTracker->m_nStyle & _afxResizeStyle))
	{
		return Default();
	}

	LRESULT nHitCode = Default();

	// Check for scrollbar or sizebox hit.
	if ((nHitCode == HTHSCROLL) || (nHitCode == HTVSCROLL) ||
		(nHitCode == HTSIZE))
	{
		return nHitCode;
	}

	// Check for client area hit.
	CPoint pointClient(point);
	ScreenToClient(&pointClient);
	CRect rect;
	GetClientRect(rect);
	if (rect.PtInRect(pointClient))
		return HTCLIENT;

	// Check for border hit.
	UINT nHandleSize = m_pRectTracker->m_nHandleSize - 1;
	GetWindowRect(rect);
	rect.InflateRect(-(int)nHandleSize, -(int)nHandleSize);
	if (rect.PtInRect(point))
		return HTBORDER;

	// If tracker detects a hit, return HTBORDER; otherwise HTNOWHERE.
	nHitCode = m_pRectTracker->HitTest(pointClient);
	return (nHitCode == CRectTracker::hitNothing) ? HTNOWHERE : HTBORDER;
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnNcLButtonDown - handler for WM_NCLBUTTONDOWN message

void COleControl::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
#ifdef _AFXDLL
	if (m_bOpen || m_pRectTracker == NULL ||
#else
	if (m_pRectTracker == NULL ||
#endif
		!(m_pRectTracker->m_nStyle & _afxResizeStyle) ||
		(nHitTest == HTHSCROLL) || (nHitTest == HTVSCROLL))
	{
		Default();
		return;
	}

	ScreenToClient(&point);

	// Setup a (semi-)permanent CWnd for the control's parent window
	CRect rectBefore = m_pRectTracker->m_rect;
	CWnd* pWndClip = CWnd::FromHandle(::GetParent(GetOuterWindow()->m_hWnd));

	// Move or resize the tracker.
	BOOL bTrack = m_pRectTracker->Track(this, point, FALSE, pWndClip);

	if (bTrack)
	{
		ASSERT(m_pInPlaceSite);

		CRect rectAfter = m_pRectTracker->m_rect;
		if (rectBefore != rectAfter)
		{
			// If rectangle changed, adjust the tracker's rectangle and move
			// the control.
			m_pRectTracker->m_rect.OffsetRect(-m_pRectTracker->m_rect.left,
				-m_pRectTracker->m_rect.top);
			CWnd* pWndOuter = GetOuterWindow();
			CWnd* pWndParent = pWndOuter->GetParent();
			CRect rectWindow;
			CRect rectParent;
			pWndOuter->GetWindowRect(rectWindow);
			pWndParent->GetClientRect(rectParent);
			pWndParent->ClientToScreen(rectParent);
		 int nBorderWidth = GetBorderStyle()*GetSystemMetrics( SM_CXBORDER );
		 int nBorderHeight = GetBorderStyle()*GetSystemMetrics( SM_CYBORDER );
			UINT nHandleSize = m_pRectTracker->m_nHandleSize - 1;
			rectAfter.OffsetRect(rectWindow.left - rectParent.left +
				nHandleSize + nBorderWidth, rectWindow.top - rectParent.top +
			nHandleSize + nBorderHeight);

			// Update the control's extents.
			SIZEL szlPixels;
			SIZEL szlHimetric;
			szlPixels.cx = (long)rectAfter.Width();
			szlPixels.cy = (long)rectAfter.Height();
			_AfxXformSizeInPixelsToHimetric(NULL, &szlPixels, &szlHimetric);
			if ((m_cxExtent != szlHimetric.cx) ||
				(m_cyExtent != szlHimetric.cy))
			{
				m_cxExtent = szlHimetric.cx;
				m_cyExtent = szlHimetric.cy;
				SetModifiedFlag();
			}

			// Move/resize the control's window.
			m_pInPlaceSite->OnPosRectChange(rectAfter);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleControl::OnSetCursor - handler for WM_SETCURSOR message

BOOL COleControl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT)
{
#ifdef _AFXDLL
	if (m_bOpen || m_pRectTracker == NULL ||
#else
	if (m_pRectTracker == NULL ||
#endif
		!(m_pRectTracker->m_nStyle & _afxResizeStyle))
	{
		return (BOOL)Default();
	}

	if ((nHitTest == HTCLIENT) || (nHitTest == HTHSCROLL) ||
		(nHitTest == HTVSCROLL) || (nHitTest == HTSIZE))
	{
		// In client area: use default cursor or arrow.
		if (!Default())
			::SetCursor(::LoadCursor(NULL, IDC_ARROW));
	}
	else
	{
		// In non-client area: use tracker-supplied cursor.
		m_pRectTracker->SetCursor(pWnd, HTCLIENT);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Force any extra compiler-generated code into AFX_INIT_SEG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\daoimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: must include AFXDAO.H first

#pragma once

/////////////////////////////////////////////////////////////////////////////
// _AFX_DAO_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_DAO_STATE : public CNoTrackObject
{
public:
	// Handle initialization and cleanup of OLE and DAO
	_AFX_DAO_STATE();
	virtual ~_AFX_DAO_STATE();

	// MFC/DAO global data
	BOOL m_bOleInitialized;
	DAODBEngine* m_pDAODBEngine;
	CMapPtrToPtr m_mapWorkspaces;
};

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\daodfx.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "math.h"



#define new DEBUG_NEW

#pragma warning(disable: 4311 4312)  // Disable /Wp64 warnings, since DAO isn't supported on Win64

//////////////////////////////////////////////////////////////////////////
// Helpers

// Helpers for floating point operations
AFX_STATIC_DATA const float _afxFloatPseudoNull = AFX_RFX_SINGLE_PSEUDO_NULL;
AFX_STATIC_DATA const double _afxDoublePseudoNull = AFX_RFX_DOUBLE_PSEUDO_NULL;

// Long binary allocation helper
void AFX_CDECL AllocLongBinary(CLongBinary& lb, DWORD dwDataLength);

// Memory allocation callbacks used by ICDAOGetRows
STDAPI DaoStringAllocCallback(DWORD dwLen, DWORD pData, void** ppv);
STDAPI DaoBinaryAllocCallback(DWORD dwLen, DWORD pData, void** ppv);
STDAPI DaoLongBinaryAllocCallback(DWORD dwLen, DWORD pData, void** ppv);

//////////////////////////////////////////////////////////////////////////
// CDaoFieldExchange

CDaoFieldExchange::CDaoFieldExchange(UINT nOperation,
	CDaoRecordset* prs, void* pvField)
{
	ASSERT(nOperation < MaxDFXOperation);

	m_nFieldType = none;
	m_nOperation = nOperation;
	m_prs = prs;
	m_pvField = pvField;
	m_nField = 0;
	m_nParam = 0;
}

BOOL CDaoFieldExchange::IsValidOperation()
{
	if (m_nOperation >= MaxDFXOperation)
	{
		// Invalid operation
		ASSERT(FALSE);
		return FALSE;
	}

	// Operations valid for both field types
#ifdef _DEBUG
	if (m_nOperation == DumpField || m_nOperation == SetFieldNull)
		return TRUE;
#endif

	// Operations only valid for outputColumn OR param types
	if ((m_nOperation == AddToParameterList) ||
		(m_nOperation == BindParam))
		return (m_nFieldType == param);
	else
		return (m_nFieldType == outputColumn);
}

void CDaoFieldExchange::AppendParamType(CString& strParamList,
	DWORD dwParamType)
{
	switch (dwParamType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		strParamList += " Text";
		break;

	case AFX_RFX_BINARY:
		strParamList += " LongBinary";
		break;

	case AFX_RFX_LONGBINARY:
		strParamList += " LongBinary";
		break;

	case AFX_RFX_BOOL:
		strParamList += " Bit";
		break;

	case AFX_RFX_BYTE:
		strParamList += " Byte";
		break;

	case AFX_RFX_SHORT:
		strParamList += " Short";
		break;

	case AFX_RFX_LONG:
		strParamList += " Long";
		break;

	case AFX_RFX_CURRENCY:
		strParamList += " Currency";
		break;

	case AFX_RFX_SINGLE:
		strParamList += " IEEESingle";
		break;

	case AFX_RFX_DOUBLE:
		strParamList += " IEEEDouble";
		break;

	case AFX_RFX_DATE:
		strParamList += " DateTime";
		break;
	}
}

CDaoFieldCache* CDaoFieldExchange::GetCacheValue(CDaoRecordset* prs, void* pv)
{
	// Lookup storage locations
	void* pvCache=NULL;
	if (prs == NULL || !prs->m_pMapFieldCache->Lookup(pv, pvCache))
		AfxThrowDaoException(AFX_DAO_ERROR_DFX_BIND);
	ASSERT(pvCache!=NULL);
	return (CDaoFieldCache*)pvCache;
}

void CDaoFieldExchange::SetNullValue(void* pv, DWORD dwDataType)
{
	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		((CString*)pv)->Empty();
		break;

	case AFX_RFX_BINARY:
		((CByteArray*)pv)->SetSize(0);
		break;

	case AFX_RFX_LONGBINARY:
		((CLongBinary*)pv)->m_dwDataLength = 0;
		break;

	case AFX_RFX_BOOL:
		*(BOOL*)pv = AFX_RFX_BOOL_PSEUDO_NULL;
		break;

	case AFX_RFX_BYTE:
		*(BYTE*)pv = AFX_RFX_BYTE_PSEUDO_NULL;
		break;

	case AFX_RFX_SHORT:
		*(short*)pv = AFX_RFX_SHORT_PSEUDO_NULL;
		break;

	case AFX_RFX_LONG:
		*(long*)pv = AFX_RFX_LONG_PSEUDO_NULL;
		break;

	case AFX_RFX_CURRENCY:
		((COleCurrency*)pv)->SetStatus(COleCurrency::null);
		break;

	case AFX_RFX_SINGLE:
		*(float*)pv = _afxFloatPseudoNull;
		break;

	case AFX_RFX_DOUBLE:
		*(double*)pv = _afxDoublePseudoNull;
		break;

	case AFX_RFX_DATE:
		((COleDateTime*)pv)->SetStatus(COleDateTime::null);
		break;
	}
}

BOOL CDaoFieldExchange::IsNullValue(void* pv, DWORD dwDataType)
{
	BOOL bNull = FALSE;

	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		if (((CString*)pv)->IsEmpty())
			bNull = TRUE;
		break;

	case AFX_RFX_BINARY:
		if (((CByteArray*)pv)->GetSize() == 0)
			bNull = TRUE;
		break;

	case AFX_RFX_LONGBINARY:
		if (((CLongBinary*)pv)->m_dwDataLength == 0)
			bNull = TRUE;
		break;

	case AFX_RFX_BOOL:
		if (*(BOOL*)pv == AFX_RFX_BOOL_PSEUDO_NULL)
			bNull = TRUE;
		break;

	case AFX_RFX_BYTE:
		if (*(BYTE*)pv == AFX_RFX_BYTE_PSEUDO_NULL)
			bNull = TRUE;
		break;

	case AFX_RFX_SHORT:
		if (*(short*)pv == AFX_RFX_SHORT_PSEUDO_NULL)
			bNull = TRUE;
		break;

	case AFX_RFX_LONG:
		if (*(long*)pv == AFX_RFX_LONG_PSEUDO_NULL)
			bNull = TRUE;
		break;

	case AFX_RFX_CURRENCY:
		if (((COleCurrency*)pv)->GetStatus() == COleCurrency::null)
			bNull = TRUE;
		break;

	case AFX_RFX_SINGLE:
		if (*(float*)pv == _afxFloatPseudoNull)
			bNull = TRUE;
		break;

	case AFX_RFX_DOUBLE:
		if (*(double*)pv == _afxDoublePseudoNull)
			bNull = TRUE;
		break;

	case AFX_RFX_DATE:
		if (((COleDateTime*)pv)->GetStatus() == COleDateTime::null)
			bNull = TRUE;
		break;
	}

	return bNull;
}

void CDaoFieldExchange::AllocCacheValue(CDaoFieldCache*& pCache,
	DWORD dwDataType)
{
	// Initialize a new field cache
	pCache = new CDaoFieldCache;
	pCache->m_nStatus = 0;

	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		pCache->m_pvData = new CString();
		pCache->m_nDataType = AFX_RFX_TEXT;
		break;

	case AFX_RFX_BINARY:
		pCache->m_pvData = new CByteArray();
		pCache->m_nDataType = AFX_RFX_BINARY;
		break;

	case AFX_RFX_LONGBINARY:
		pCache->m_pvData = new CLongBinary();
		pCache->m_nDataType = AFX_RFX_LONGBINARY;
		break;

	case AFX_RFX_BOOL:
		pCache->m_nDataType = AFX_RFX_BOOL;
		break;

	case AFX_RFX_BYTE:
		pCache->m_nDataType = AFX_RFX_BYTE;
		break;

	case AFX_RFX_SHORT:
		pCache->m_nDataType = AFX_RFX_SHORT;
		break;

	case AFX_RFX_LONG:
		pCache->m_nDataType = AFX_RFX_LONG;
		break;

	case AFX_RFX_CURRENCY:
		pCache->m_pvData = new COleCurrency();
		pCache->m_nDataType = AFX_RFX_CURRENCY;
		break;

	case AFX_RFX_SINGLE:
		pCache->m_nDataType = AFX_RFX_SINGLE;
		break;

	case AFX_RFX_DOUBLE:
		pCache->m_pvData = new double;
		pCache->m_nDataType = AFX_RFX_DOUBLE;
		break;

	case AFX_RFX_DATE:
		pCache->m_pvData = new COleDateTime();
		pCache->m_nDataType = AFX_RFX_DATE;
		break;
	}
}

void CDaoFieldExchange::DeleteCacheValue(CDaoFieldCache* pCache,
	DWORD dwDataType)
{
	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		delete (CString*)pCache->m_pvData;
		break;

	case AFX_RFX_BINARY:
		delete (CByteArray*)pCache->m_pvData;
		break;

	case AFX_RFX_LONGBINARY:
		delete (CLongBinary*)pCache->m_pvData;
		break;

	case AFX_RFX_BOOL:
	case AFX_RFX_BYTE:
	case AFX_RFX_SHORT:
	case AFX_RFX_LONG:
	case AFX_RFX_SINGLE:
		break;

	case AFX_RFX_CURRENCY:
		delete (COleCurrency*)pCache->m_pvData;
		break;

	case AFX_RFX_DOUBLE:
		delete (double*)pCache->m_pvData;
		break;

	case AFX_RFX_DATE:
		delete (COleDateTime*)pCache->m_pvData;
		break;
	}

	delete pCache;
	pCache = NULL;
}

void CDaoFieldExchange::CopyValue(void* pvSrc, void* pvDest,
	DWORD dwDataType)
{
	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		*(CString*)pvDest = *(CString*)pvSrc;
		break;

	case AFX_RFX_BINARY:
		((CByteArray*)pvDest)->Copy(*(CByteArray*)pvSrc);
		break;

	case AFX_RFX_LONGBINARY:
		{
			CLongBinary* pLongBinarySrc = (CLongBinary*)pvSrc;
			CLongBinary* pLongBinaryDest = (CLongBinary*)pvDest;

			// Reallocate memory in destination if necessary
			AllocLongBinary(*pLongBinaryDest, pLongBinarySrc->m_dwDataLength);
			pLongBinaryDest->m_dwDataLength =
				pLongBinarySrc->m_dwDataLength;

			BYTE* pbSrc = (BYTE*)::GlobalLock(pLongBinarySrc->m_hData);
			BYTE* pbDest = (BYTE*)::GlobalLock(pLongBinaryDest->m_hData);
			Checked::memcpy_s(pbDest, (size_t)pLongBinaryDest->m_dwDataLength, 
				pbSrc, (size_t)pLongBinarySrc->m_dwDataLength);
			::GlobalUnlock(pLongBinarySrc->m_hData);
			::GlobalUnlock(pLongBinaryDest->m_hData);
		}
		break;

	case AFX_RFX_BOOL:
		*(BOOL*)pvDest = *(BOOL*)pvSrc;
		break;

	case AFX_RFX_BYTE:
		*(BYTE*)pvDest = *(BYTE*)pvSrc;
		break;

	case AFX_RFX_SHORT:
		*(short*)pvDest = *(short*)pvSrc;
		break;

	case AFX_RFX_LONG:
		*(long*)pvDest = *(long*)pvSrc;
		break;

	case AFX_RFX_CURRENCY:
		*(COleCurrency*)pvDest = *(COleCurrency*)pvSrc;
		break;

	case AFX_RFX_SINGLE:
		*(float*)pvDest = *(float*)pvSrc;
		break;

	case AFX_RFX_DOUBLE:
		*(double*)pvDest = *(double*)pvSrc;
		break;

	case AFX_RFX_DATE:
		*(COleDateTime*)pvDest = *(COleDateTime*)pvSrc;
		break;
	}
}

BOOL CDaoFieldExchange::CompareValue(void* pvSrc, void* pvDest,
	DWORD dwDataType)
{
	BOOL bDirty = FALSE;

	switch (dwDataType)
	{
	default:
		ASSERT(FALSE);
		break;

	case AFX_RFX_TEXT:
		if (*(CString*)pvDest != *(CString*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_BINARY:
		{
			CByteArray* pByteArraySrc = (CByteArray*)pvSrc;
			CByteArray* pByteArrayDest = (CByteArray*)pvDest;

			INT_PTR nSize = pByteArraySrc->GetSize();
			// If sizes don't compare, must be dirty
			if (nSize != pByteArrayDest->GetSize())
				bDirty = TRUE;
			else
			{
				// If sizes compare, compare the data
				if (memcmp(pByteArrayDest->GetData(), pByteArraySrc->GetData(), (size_t)nSize) != 0)
					bDirty = TRUE;
			}
		}
		break;

	case AFX_RFX_LONGBINARY:
		{
			CLongBinary* pLongBinarySrc = (CLongBinary*)pvSrc;
			CLongBinary* pLongBinaryDest = (CLongBinary*)pvDest;

			BYTE* pbSrc = (BYTE*)::GlobalLock(pLongBinarySrc->m_hData);
			BYTE* pbDest = (BYTE*)::GlobalLock(pLongBinaryDest->m_hData);

			// If sizes don't compare, must be dirty
			if (pLongBinarySrc->m_dwDataLength !=
				pLongBinaryDest->m_dwDataLength)
			{
				bDirty = TRUE;
			}
			else
			{
				// If sizes compare, compare the data
				if (memcmp(pbDest, pbSrc, (size_t)pLongBinarySrc->m_dwDataLength) != 0)
					bDirty = TRUE;
			}

			::GlobalUnlock(pLongBinarySrc->m_hData);
			::GlobalUnlock(pLongBinaryDest->m_hData);
		}
		break;

	case AFX_RFX_BOOL:
		if (*(BOOL*)pvDest != *(BOOL*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_BYTE:
		if (*(BYTE*)pvDest != *(BYTE*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_SHORT:
		if (*(short*)pvDest != *(short*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_LONG:
		if (*(long*)pvDest != *(long*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_CURRENCY:
		if (*(COleCurrency*)pvDest != *(COleCurrency*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_SINGLE:
		if (*(float*)pvDest != *(float*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_DOUBLE:
		if (*(double*)pvDest != *(double*)pvSrc)
			bDirty = TRUE;
		break;

	case AFX_RFX_DATE:
		if (*(COleDateTime*)pvDest != *(COleDateTime*)pvSrc)
			bDirty = TRUE;
		break;
	}

	return bDirty;
}

void CDaoFieldExchange::FillVariant(void* pvValue, DWORD dwDataType,
	COleVariant** ppVar)
{
	COleVariant* pVar;

	if (dwDataType == AFX_RFX_TEXT)
		pVar = new COleVariant(*(CString*)pvValue, VT_BSTRT);
	else if (dwDataType == AFX_RFX_BOOL)
		pVar = new COleVariant(*(long*)pvValue, VT_BOOL);
	else
	{
		pVar = new COleVariant;

		switch (dwDataType)
		{
		default:
			ASSERT(FALSE);
			break;

		case AFX_RFX_BINARY:
			*pVar = *(CByteArray*)pvValue;
			break;

		case AFX_RFX_LONGBINARY:
			*pVar = *(CLongBinary*)pvValue;
			break;

		case AFX_RFX_BYTE:
			*pVar = *(BYTE*)pvValue;
			break;

		case AFX_RFX_SHORT:
			*pVar = *(short*)pvValue;
			break;

		case AFX_RFX_LONG:
			*pVar = *(long*)pvValue;
			break;

		case AFX_RFX_CURRENCY:
			*pVar = *(COleCurrency*)pvValue;
			break;

		case AFX_RFX_SINGLE:
			*pVar = *(float*)pvValue;
			break;

		case AFX_RFX_DOUBLE:
			*pVar = *(double*)pvValue;
			break;

		case AFX_RFX_DATE:
			*pVar = *(COleDateTime*)pvValue;
		}
	}

	*ppVar = pVar;
}

// Default implementation for RFX functions
void CDaoFieldExchange::Default(LPCTSTR lpszName, void* pv,
	DWORD dwColumnType, DWORD dwBindOptions)
{
	switch (m_nOperation)
	{
	case AddToParameterList:
		if (m_nParam != 1)
			m_prs->m_strSQL += ",";
		m_prs->m_strSQL += lpszName;
		AppendParamType(m_prs->m_strSQL, dwColumnType);
		return;

	case AddToSelectList:
		if (m_nField != 1)
			m_prs->m_strSQL += ",";
		m_prs->m_strSQL += lpszName;
		return;

	case BindField:
		{
			// Query parser needs "[" & "]", GetRows can't tolerate them.
			LPTSTR lpszNoBracketName = new TCHAR[lstrlen(lpszName) + 1];
			m_prs->StripBrackets(lpszName, lpszNoBracketName);

			// Finish setting up column binding info struct
			LPDAOCOLUMNBINDING pcb =
				&m_prs->m_prgDaoColBindInfo[m_nField-1];
			pcb->cbInfoOffset =
				(DWORD)&m_prs->m_pulColumnLengths[m_nField-1];
#ifndef _UNICODE
			pcb->columnID.dwKind = DAOCOLKIND_STR;
			pcb->columnID.lpstr = lpszNoBracketName;
#else
			pcb->columnID.dwKind = DAOCOLKIND_WSTR;
			pcb->columnID.lpwstr = lpszNoBracketName;
#endif

			// Setup the field index map (and store value as void ptr)
			m_prs->m_pMapFieldIndex->SetAt(pv, (void*)m_nField);
		}
		return;

	case BindParam:
		{
			COleVariant* pvar = NULL;
			TRY
			{
				// NULL params not supported, use IS NULL in SQL
				// (i.e. - m_strFilter = _T("Foo IS NULL");
				FillVariant(pv, dwColumnType, &pvar);
				m_prs->m_pQueryDef->SetParamValue(lpszName, *pvar);
			}
			CATCH_ALL(e)
			{
				delete pvar;
				THROW_LAST();
			}
			END_CATCH_ALL
			delete pvar;
		}
		return;

	case Fixup:
		if (m_prs->GetFieldLength(m_nField-1) == DAO_NULL)
		{
			// Set the value to PSEUDO NULL and mark the status NULL
			SetNullValue(pv, dwColumnType);
			m_prs->SetNullFieldStatus(m_nField-1);
		}
		return;

	case AllocCache:
		if (dwBindOptions & AFX_DAO_ENABLE_FIELD_CACHE)
		{
			CDaoFieldCache* pCache;

			// Allocate new storage and add to map
			AllocCacheValue(pCache, dwColumnType);
			m_prs->m_pMapFieldCache->SetAt(pv, pCache);
		}
		return;

	case StoreField:
		if (dwBindOptions & AFX_DAO_ENABLE_FIELD_CACHE)
		{
			CDaoFieldCache* pCache = GetCacheValue(m_prs, pv);

			// Copy the data to the cache
			if (dwBindOptions & AFX_DAO_CACHE_BY_VALUE)
				CopyValue(pv, (void*)&pCache->m_pvData, dwColumnType);
			else
				CopyValue(pv, pCache->m_pvData, dwColumnType);

			// Cache the NULL status
			if (m_prs->IsFieldStatusNull(m_nField-1))
				pCache->m_nStatus |= AFX_DAO_FIELD_FLAG_NULL;
			else
				pCache->m_nStatus &= ~AFX_DAO_FIELD_FLAG_NULL;
		}
		return;

	case LoadField:
		if (dwBindOptions & AFX_DAO_ENABLE_FIELD_CACHE)
		{
			CDaoFieldCache* pCache = GetCacheValue(m_prs, pv);

			// Copy the data from the cache
			if (dwBindOptions & AFX_DAO_CACHE_BY_VALUE)
				CopyValue((void*)&pCache->m_pvData, pv, dwColumnType);
			else
				CopyValue(pCache->m_pvData, pv, dwColumnType);

			// Set the NULL status from the cache
			if (pCache->m_nStatus & AFX_DAO_FIELD_FLAG_NULL)
				m_prs->SetNullFieldStatus(m_nField-1);
			else
				m_prs->ClearNullFieldStatus(m_nField-1);
		}
		return;

	case SetFieldNull:
		// Setting field NOT NULL doesn't require field exchange
		if ((m_pvField == NULL && m_nFieldType == outputColumn)
			|| m_pvField == pv)
		{
			SetNullValue(pv, dwColumnType);

			// Also set the status array if not a parameter
			if (m_nFieldType == outputColumn)
				m_prs->SetNullFieldStatus(m_nField-1);

#ifdef _DEBUG
			m_nFieldFound = m_nField;
#endif
		}
		return;

	case MarkForAddNew:
		if (dwBindOptions & AFX_DAO_ENABLE_FIELD_CACHE)
		{
			// Don't need to do anything if field marked dirty
			if (!m_prs->IsFieldStatusDirty(m_nField-1))
			{
				// Mark dirty & not NULL if not set to pseudo NULL value
				if (!IsNullValue(pv, dwColumnType))
				{
					m_prs->SetDirtyFieldStatus(m_nField-1);
					m_prs->ClearNullFieldStatus(m_nField-1);
				}
			}
		}
		return;

	case MarkForEdit:
		if (dwBindOptions & AFX_DAO_ENABLE_FIELD_CACHE)
		{
			// If value not pseudo NULL value, clear NULL status
			if (!IsNullValue(pv, dwColumnType))
				m_prs->ClearNullFieldStatus(m_nField-1);

			// If field already marked dirty, don't need to check cache
			if (!m_prs->IsFieldStatusDirty(m_nField-1))
			{
				CDaoFieldCache* pCache = GetCacheValue(m_prs, pv);

				BOOL bNullField = m_prs->IsFieldStatusNull(m_nField-1);
				BOOL bNullCache = pCache->m_nStatus & AFX_DAO_FIELD_FLAG_NULL;

				void* pvData;
				if (dwBindOptions & AFX_DAO_CACHE_BY_VALUE)
					pvData = &pCache->m_pvData;
				else
					pvData = pCache->m_pvData;

				// Mark dirty if NULL status differs or value differs
				if ( (bNullCache && !bNullField) ||
					(!bNullCache && bNullField) ||
					CompareValue(pv, pvData, dwColumnType))
				{
					m_prs->SetDirtyFieldStatus(m_nField-1);
				}
			}
		}
		return;

	case SetDirtyField:
		if (m_prs->IsFieldStatusDirty(m_nField-1))
		{
			COleVariant* pvar = NULL;
			TRY
			{
				// If field is NULL don't set the value
				if (!m_prs->IsFieldStatusNull(m_nField-1))
					FillVariant(pv, dwColumnType, &pvar);
				else
				{
					pvar = new COleVariant;
					pvar->vt = VT_NULL;
				}

				// SetFieldValue (put_Collect) doesn't like brackets
				// Assumes no brackets if first char not a bracket
				LPTSTR lpszModifiedName = NULL;
				if (*lpszName == '[')
				{
					lpszModifiedName = new TCHAR[lstrlen(lpszName) + 1];

					// Copy the name with no brackets, and reset lpszName
					m_prs->StripBrackets(lpszName, lpszModifiedName);
					lpszName = lpszModifiedName;
				}

				m_prs->SetFieldValue(lpszName, *pvar);
				delete [] lpszModifiedName;
			}
			CATCH_ALL(e)
			{
				delete pvar;
				THROW_LAST();
			}
			END_CATCH_ALL
			delete pvar;
		}
		return;

	default:
		ASSERT(FALSE);
		return;
	}
}

void AFXAPI DFX_Text(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CString& value, int nPreAllocSize, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	DWORD dwDAOType;

#ifdef _UNICODE
	dwDAOType = DAO_WCHAR;
#else
	dwDAOType = DAO_CHAR;
#endif

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			// Pre-allocate buffer to prevent needless re-allocations
			value.GetBuffer(nPreAllocSize);
			value.ReleaseBuffer();

			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = dwDAOType;
			pcb->dwBinding = DAOBINDING_DIRECT | DAOBINDING_CALLBACK;
			pcb->dwUser = (DWORD)&value;
			pcb->cbDataOffset = (DWORD)DaoStringAllocCallback;
			pcb->cbMaxLen = INT_MAX;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_TEXT,
			dwBindOptions);
		return;

	case CDaoFieldExchange::Fixup:
		if (pFX->m_prs->m_pulColumnLengths[pFX->m_nField-1] == 0 ||
			pFX->m_prs->m_pulColumnLengths[pFX->m_nField-1] == DAO_NULL)
		{
			// If null or empty string set length zero
			value.GetBufferSetLength(0);
		}
		else
		{
			// Make sure length correct
			value.GetBufferSetLength(
				((pFX->m_prs->m_pulColumnLengths[pFX->m_nField-1])/sizeof(TCHAR))-1);
		}

		pFX->Default(lpszName, (void*)&value,
			AFX_RFX_TEXT, dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Binary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CByteArray& value, int nPreAllocSize, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			// Pre-allocate buffer to prevent needless re-allocations
			value.SetSize(nPreAllocSize);

			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_BYTES;
			pcb->dwBinding = DAOBINDING_DIRECT | DAOBINDING_CALLBACK;
			pcb->dwUser = (DWORD)&value;
			pcb->cbDataOffset = (ULONG)DaoBinaryAllocCallback;
			pcb->cbMaxLen = INT_MAX;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_BINARY,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_LongBinary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CLongBinary& value, DWORD dwPreAllocSize, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			// Pre-allocate buffer to prevent needless re-allocations
			AllocLongBinary(value, dwPreAllocSize);

			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_BYTES;
			pcb->dwBinding = DAOBINDING_DIRECT | DAOBINDING_CALLBACK;
			pcb->dwUser = (DWORD)&value;
			pcb->cbDataOffset = (DWORD)DaoLongBinaryAllocCallback;
			pcb->cbMaxLen = ULONG_MAX;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value,
			AFX_RFX_LONGBINARY, dwBindOptions);
		return;

	case CDaoFieldExchange::Fixup:
		// Unlock data locked in DaoLongBinaryAllocCallback
		if (value.m_dwDataLength != 0)
			::GlobalUnlock(value.m_hData);

		pFX->Default(lpszName, (void*)&value,
			AFX_RFX_LONGBINARY, dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Bool(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BOOL& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	// Mark as CACHE_BY_VALUE (size <= sizeof(void*))
	dwBindOptions |= AFX_DAO_CACHE_BY_VALUE;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_BOOL;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_BOOL,
			dwBindOptions);
		return;

	case CDaoFieldExchange::Fixup:
		// Convert BOOL value from AFX_DAO_TRUE/FALSE to TRUE/FALSE
		value = (value != AFX_DAO_FALSE);

		pFX->Default(lpszName, (void*)&value,
			AFX_RFX_BOOL, dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Byte(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BYTE& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	// Mark as CACHE_BY_VALUE (size <= sizeof(void*))
	dwBindOptions |= AFX_DAO_CACHE_BY_VALUE;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_BYTE;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_BYTE,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Short(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	short& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	// Mark as CACHE_BY_VALUE (size <= sizeof(void*))
	dwBindOptions |= AFX_DAO_CACHE_BY_VALUE;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_I2;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_SHORT,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Long(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	long& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	// Mark as CACHE_BY_VALUE (size <= sizeof(void*))
	dwBindOptions |= AFX_DAO_CACHE_BY_VALUE;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_I4;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_LONG,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Currency(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleCurrency& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_CURRENCY;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value.m_cur;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(CURRENCY);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;

			// Finish setting up column binding struct
			pFX->Default(lpszName, (void*)&value, AFX_RFX_CURRENCY,
				dwBindOptions);
			return;
		}

	case CDaoFieldExchange::Fixup:
		// Must reset the valid currency flag
		if (pFX->m_prs->GetFieldLength(pFX->m_nField-1) == DAO_NULL)
			value.SetStatus(COleCurrency::null);
		else
			value.SetStatus(COleCurrency::valid);

		// Fall through to reset the NULL status

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_CURRENCY,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << ":" << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Single(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	float& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	// Mark as CACHE_BY_VALUE (size <= sizeof(void*))
	dwBindOptions |= AFX_DAO_CACHE_BY_VALUE;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_R4;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_SINGLE,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_Double(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	double& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_R8;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(value);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;
		}
		// Fall through to finish setting up column binding struct

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_DOUBLE,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << " = " << value;
		return;
#endif //_DEBUG
	}
}

void AFXAPI DFX_DateTime(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleDateTime& value, DWORD dwBindOptions)
{
	(pFX->m_nFieldType == CDaoFieldExchange::outputColumn) ?
		++pFX->m_nField: ++pFX->m_nParam;

	// Do nothing if op not supported for outputColumn or param type
	if (!pFX->IsValidOperation())
		return;

	switch (pFX->m_nOperation)
	{
	case CDaoFieldExchange::BindField:
		{
			LPDAOCOLUMNBINDING pcb =
				&pFX->m_prs->m_prgDaoColBindInfo[pFX->m_nField-1];
			pcb->dwDataType = DAO_DATE;
			pcb->dwBinding = DAOBINDING_DIRECT;
			pcb->cbDataOffset = (DWORD)&value.m_dt;
			pcb->dwUser = 0;
			pcb->cbMaxLen = sizeof(DATE);

			pFX->m_prs->m_cbFixedLengthFields += pcb->cbMaxLen;

			// Finish setting up column binding struct
			pFX->Default(lpszName,(void*)&value, AFX_RFX_DATE,
				dwBindOptions);
			return;
		}

	case CDaoFieldExchange::Fixup:
		// Must reset the valid currency flag
		if (pFX->m_prs->GetFieldLength(pFX->m_nField-1) == DAO_NULL)
			value.SetStatus(COleDateTime::null);
		else
			value.SetStatus(COleDateTime::valid);

		// Fall through to reset the NULL status

	default:
		pFX->Default(lpszName, (void*)&value, AFX_RFX_DATE,
			dwBindOptions);
		return;

#ifdef _DEBUG
	case CDaoFieldExchange::DumpField:
		*pFX->m_pdcDump << "\n" << lpszName << ":" << value;
		return;
#endif //_DEBUG
	}
}

//////////////////////////////////////////////////////////////////////////////
// DAO memory allocation callback helpers

STDAPI DaoStringAllocCallback(DWORD dwLen, DWORD pData, void** ppv)
{
	LPTSTR lpsz;
	CString* pstr = (CString*)pData;

#ifndef _UNICODE
	// If using ANSI DAO interfaces, DAO reports field length
	// rather than data length. In this case there will not be space
	// for NULL terminator if data length equals field length. Make room.
	dwLen++;
	if (dwLen == 2)
	{
		//Workaround DAO bug: FIX: DAO 3.6 Causes Debug Errors in MFC DAO Non-Unicode Builds
		//Problem with a text field that is defined to be only one character in length
		dwLen*=2;
	}
#endif

	TRY
	{
		// Only re-allocate if necessary
		lpsz = pstr->GetBufferSetLength(dwLen/sizeof(TCHAR));
		*ppv = (void*)(dwLen > 0 ? lpsz : NULL);
	}
	CATCH_ALL(e)
	{
		e->Delete();
		return E_OUTOFMEMORY;
	}
	END_CATCH_ALL

	return S_OK;
}


STDAPI DaoBinaryAllocCallback(DWORD dwLen, DWORD pData, void** ppv)
{
	CByteArray* pByteArray = (CByteArray*)pData;

	TRY
	{
		// Only re-allocate if necessary
		pByteArray->SetSize(dwLen);
		*ppv = (void*)(dwLen > 0 ? &((*pByteArray)[0]) : NULL);
	}
	CATCH_ALL(e)
	{
		// Only exceptions thrown should be CMemoryException
		e->Delete();
		return E_OUTOFMEMORY;
	}
	END_CATCH_ALL

	return S_OK;
}


STDAPI DaoLongBinaryAllocCallback(DWORD dwLen, DWORD pData, void** ppv)
{
	CLongBinary* pLongBinary = (CLongBinary*)pData;

	TRY
	{
		AllocLongBinary(*pLongBinary, dwLen);
	}
	CATCH_ALL(e)
	{
		// Only exception is memory exception, just pass back error.
		DELETE_EXCEPTION(e);
		return E_OUTOFMEMORY;
	}
	END_CATCH_ALL

	if (pLongBinary->m_dwDataLength != 0)
	{
		const BYTE* pByte;
		pByte = (const BYTE*)::GlobalLock(pLongBinary->m_hData);

		// If mem can't be locked, free up and return error
		if (pByte == NULL)
		{
			::GlobalFree(pLongBinary->m_hData);
			pLongBinary->m_hData = NULL;
			return E_OUTOFMEMORY;
		}

		*ppv = (void*)pByte;
	}
	else
		*ppv = NULL;

	return S_OK;
}

void AFX_CDECL AllocLongBinary(CLongBinary& lb, DWORD dwDataLength)
{
	if (lb.m_hData == NULL)
	{
		if (dwDataLength > 0)
		{
			// Alloc memory, return error if not possible
			lb.m_hData = ::GlobalAlloc(GMEM_MOVEABLE, dwDataLength);
			if (lb.m_hData == NULL)
				AfxThrowMemoryException();
		}
	}
	else if (::GlobalSize(lb.m_hData) < dwDataLength)
	{
		// Save the old address in case ReAlloc fails
		HGLOBAL hOldData = lb.m_hData;

		// Alloc more mem, free up mem and throw exception if not possible
		lb.m_hData = ::GlobalReAlloc(hOldData, dwDataLength, GMEM_MOVEABLE);
		if (lb.m_hData == NULL)
		{
			lb.m_hData = hOldData;
			AfxThrowMemoryException();
		}
	}
	lb.m_dwDataLength = dwDataLength;
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line

#ifndef _AFX_ENABLE_INLINES

#define _AFXDAODFX_INLINE
#include "afxdao.inl"

#endif


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\daocore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <wchar.h>
#include "sal.h"



#pragma comment(lib, "ole32.lib")


#define new DEBUG_NEW


/////////////////////////////////////////////////////////////////////////////
// Maintain DAODBEngine object

_AFX_DAO_STATE::_AFX_DAO_STATE()
{
	m_pDAODBEngine = NULL;
	m_bOleInitialized = FALSE;
}

_AFX_DAO_STATE::~_AFX_DAO_STATE()
{
	// these ASSERTs can trip when:
	// ... there any outstanding workspsace objects
	ASSERT(m_mapWorkspaces.IsEmpty());

	// ... you've not shut down with a call AfxDaoTerm()
	ASSERT(m_pDAODBEngine == NULL);

	// ... OLE wasn't correctly shut down
	ASSERT(!m_bOleInitialized);
}

//////////////////////////////////////////////////////////////////////////
// Helpers

// Index function return value
#define AFX_DAO_DATA_NOT_FOUND                  (-1L)

#define AFX_DAO_FETCH_PRIMARY_PROPERTIES \
	(AFX_DAO_PRIMARY_INFO | AFX_DAO_SECONDARY_INFO | AFX_DAO_ALL_INFO)
#define AFX_DAO_FETCH_SECONDARY_PROPERTIES \
	(AFX_DAO_SECONDARY_INFO | AFX_DAO_ALL_INFO)
#define AFX_DAO_FETCH_ALL_PROPERTIES \
	AFX_DAO_ALL_INFO

// Info helpers
void AFX_CDECL AfxGetFieldInfo(DAOField* pDAOField, CDaoFieldInfo& fieldinfo,
	DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
void AFX_CDECL AfxSetFieldInfo(DAOField* pDAOField, CDaoFieldInfo& fieldinfo);
void AFX_CDECL AfxGetIndexInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo,
	DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
void AFX_CDECL AfxSetIndexInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo);
void AFX_CDECL AfxGetIndexFields(DAOIndex* pDAOIndex,
	DAOIndexFields** ppDAOIndexFields);
void AFX_CDECL AfxGetIndexFieldInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo);
void AFX_CDECL AfxSetIndexFieldInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo);
void AFX_CDECL AfxGetDefaultValue(DAOField* pDAOField, CString& strDefaultValue);
void AFX_CDECL AfxSetDefaultValue(DAOField* pDAOField, CString& strDefaultValue);

// GetRows helper
void AFX_CDECL ThrowGetRowsDaoException(SCODE scode);

// _AFX_DAO_STATE helper
_AFX_DAO_STATE* AFX_CDECL AfxGetDaoState();

//////////////////////////////////////////////////////////////////////////
// Global data

AFX_STATIC_DATA const TCHAR _afxParameters2[] = _T("PARAMETERS ");
AFX_STATIC_DATA const TCHAR _afxSelect2[] = _T("SELECT ");
AFX_STATIC_DATA const TCHAR _afxFrom2[] = _T(" FROM ");
AFX_STATIC_DATA const TCHAR _afxWhere2[] = _T(" WHERE ");
AFX_STATIC_DATA const TCHAR _afxOrderBy2[] = _T(" ORDER BY ");
AFX_STATIC_DATA const TCHAR _afxTransform2[] = _T("TRANSFORM ");
AFX_STATIC_DATA const TCHAR _afxTable2[] = _T("TABLE ");

// Need a static VARIANT for optional DAO parameters
AFX_STATIC_DATA VARIANT _afxOptionalVariant = { VT_ERROR, 0, 0, 0, (ULONG)DISP_E_PARAMNOTFOUND };

// Need a static VARIANT for NULL DAO parameters
AFX_STATIC_DATA VARIANT _afxNullVariant = { VT_NULL, 0, 0, 0, 0 };

//////////////////////////////////////////////////////////////////////////
// Logging helpers

void AFXAPI AfxDaoCheck(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine, int nError, BOOL bMemOnly)
{
	UNUSED(lpszDaoCall);
	UNUSED(lpszFile);
	UNUSED(nLine);

	if (FAILED(scode))
	{
		TRACE(traceDatabase, 0, _T("\nDAO Call Failed."));
		TRACE(traceDatabase, 0, _T("\n\t%hs"), lpszDaoCall);
		TRACE(traceDatabase, 0, _T("\n\tIn file %hs on line %d"), lpszFile, nLine);
		TRACE(traceDatabase, 0, _T("\n\tscode = %X\n"), scode);

		if (scode == E_OUTOFMEMORY)
			AfxThrowMemoryException();
		else if (!bMemOnly)
			AfxThrowDaoException(nError, scode);
	}
}

#ifdef _DEBUG
void AFXAPI AfxDaoTrace(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine)
{
	if (FAILED(scode))
	{
		TRACE(traceDatabase, 0, _T("\nDAO Call Failed.\n\t"));
		TRACE(traceDatabase, 0, _T("\n%hs"), lpszDaoCall);
		TRACE(traceDatabase, 0, _T("\nIn file %hs on line %d\n"), lpszFile, nLine);
		TRACE(traceDatabase, 0, _T("scode = %X\n"), scode);
	}
}
#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////
// Info structure diagnostics

#ifdef _DEBUG
void CDaoErrorInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoErrorInfo at ") << (void*)this;

	dc << _T("\nm_lErrorCode = ") << m_lErrorCode;
	dc << _T("\nm_strSource = ") << m_strSource;
	dc << _T("\nm_strDescription = ") << m_strDescription;
	dc << _T("\nm_strHelpFile = ") << m_strHelpFile;
	dc << _T("\nm_lHelpContext = ") << m_lHelpContext;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoWorkspaceInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoWorkspaceInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_strUserName = ") << m_strUserName;
	dc << _T("\nb = m_bIsolateODBCTrans") << m_bIsolateODBCTrans;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoDatabaseInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoDatabaseInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_bUpdatable = ") << m_bUpdatable;
	dc << _T("\nm_bTransactions = ") << m_bTransactions;
	dc << _T("\nm_strVersion = ") << m_strVersion;
	dc << _T("\nm_lCollatingOrder = ") << m_lCollatingOrder;
	dc << _T("\nm_nQueryTimeout = ") << m_nQueryTimeout;
	dc << _T("\nm_strConnect = ") << m_strConnect;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoTableDefInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoTableDefInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_bUpdatable = ") << m_bUpdatable;
	dc << _T("\nm_lAttributes = ") << m_lAttributes;
	dc << _T("\nm_dateDateCreated = ") << m_dateCreated;
	dc << _T("\nm_dateLastUpdated = ") << m_dateLastUpdated;
	dc << _T("\nm_strSrcTableName = ") << m_strSrcTableName;
	dc << _T("\nm_strConnect = ") << m_strConnect;
	dc << _T("\nm_strValidationRule = ") << m_strValidationRule;
	dc << _T("\nm_strValidationText = ") << m_strValidationText;
	dc << _T("\nm_lRecordCount = ") << m_lRecordCount;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoFieldInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoFieldInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_nType = ") << m_nType;
	dc << _T("\nm_lSize = ") << m_lSize;
	dc << _T("\nm_lAttributes = ") << m_lAttributes;
	dc << _T("\nm_nOrdinalPosition = ") << m_nOrdinalPosition;
	dc << _T("\nm_bRequired = ") << m_bRequired;
	dc << _T("\nm_bAllowZeroLength = ") << m_bAllowZeroLength;
	dc << _T("\nm_lCollatingOrder = ") << m_lCollatingOrder;
	dc << _T("\nm_strForeignName = ") << m_strForeignName;
	dc << _T("\nm_strSourceField = ") << m_strSourceField;
	dc << _T("\nm_strSourceTable = ") << m_strSourceTable;
	dc << _T("\nm_strValidationRule = ") << m_strValidationRule;
	dc << _T("\nm_strValidationText = ") << m_strValidationText;
	dc << _T("\nm_strDefaultValue = ") << m_strDefaultValue;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoIndexFieldInfo::Dump(CDumpContext& dc) const
{
	dc << _T(" a CDaoIndexFieldInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_bDescending = ") << m_bDescending;
}
#endif

CDaoIndexInfo::CDaoIndexInfo()
{
	m_pFieldInfos = NULL;
	m_nFields = 0;
	m_bCleanupFieldInfo = FALSE;
}

CDaoIndexInfo::~CDaoIndexInfo()
{
	if (m_bCleanupFieldInfo && m_pFieldInfos != NULL)
	{
		delete[] m_pFieldInfos;
		m_pFieldInfos = NULL;
	}
}

#ifdef _DEBUG
void CDaoIndexInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoIndexInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_nFields = ") << m_nFields;

	for (int nIndex = 0; nIndex < m_nFields; nIndex++)
		m_pFieldInfos[nIndex].Dump(dc);

	dc << _T("\nm_bPrimary = ") << m_bPrimary;
	dc << _T("\nm_bUnique = ") << m_bUnique;
	dc << _T("\nm_bClustered = ") << m_bClustered;
	dc << _T("\nm_bIgnoreNulls = ") << m_bIgnoreNulls;
	dc << _T("\nm_bRequired = ") << m_bRequired;
	dc << _T("\nm_bForeign = ") << m_bForeign;
	dc << _T("\nm_lDistinctCount = ") << m_lDistinctCount;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoRelationFieldInfo::Dump(CDumpContext& dc) const
{
	dc << _T(" a CDaoRelationFieldInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_strForeignName = ") << m_strForeignName;
}
#endif

CDaoRelationInfo::CDaoRelationInfo()
{
	m_pFieldInfos = NULL;
	m_nFields = 0;
	m_bCleanupFieldInfo = FALSE;
}

CDaoRelationInfo::~CDaoRelationInfo()
{
	if (m_bCleanupFieldInfo && m_pFieldInfos != NULL)
	{
		delete[] m_pFieldInfos;
		m_pFieldInfos = NULL;
	}
}

#ifdef _DEBUG
void CDaoRelationInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoRelationInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_strTable = ") << m_strTable;
	dc << _T("\nm_strForeignTable = ") << m_strForeignTable;
	dc << _T("\nm_lAttributes = ") << m_lAttributes;
	dc << _T("\nm_nFields = ") << m_nFields;

	for (int nIndex = 0; nIndex < m_nFields; nIndex++)
		m_pFieldInfos[nIndex].Dump(dc);

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoQueryDefInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoQueryDefInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_nType = ") << m_nType;
	dc << _T("\nm_dateCreated = ") << m_dateCreated;
	dc << _T("\nm_dateLastUpdated = ") << m_dateLastUpdated;
	dc << _T("\nm_bUpdatable = ") << m_bUpdatable;
	dc << _T("\nm_bReturnsRecords = ") << m_bReturnsRecords;
	dc << _T("\nm_strSQL = ") << m_strSQL;
	dc << _T("\nm_strConnect = ") << m_strConnect;
	dc << _T("\nm_nODBCTimeout = ") << m_nODBCTimeout;

	dc << _T("\n");
}
#endif // _DEBUG

#ifdef _DEBUG
void CDaoParameterInfo::Dump(CDumpContext& dc) const
{
	dc << _T("a CDaoParameterInfo at ") << (void*)this;

	dc << _T("\nm_strName = ") << m_strName;
	dc << _T("\nm_nType = ") << m_nType;
	dc << _T("\nm_varValue = ") << m_varValue;

	dc << _T("\n");
}
#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////
// CDaoException
IMPLEMENT_DYNAMIC(CDaoException, CException)

CDaoException::CDaoException()
{
	m_pDAOError = NULL;
	m_pDAOErrors = NULL;
	m_pErrorInfo = NULL;
}

CDaoException::~CDaoException()
{
	delete m_pErrorInfo;
	m_pErrorInfo = NULL;

	if (m_pDAOErrors != NULL)
	{
		m_pDAOErrors->Release();
		m_pDAOErrors = NULL;
	}

	if (m_pDAOError != NULL)
	{
		m_pDAOError->Release();
		m_pDAOError = NULL;
	}
}

// Operations
short CDaoException::GetErrorCount()
{
	short nErrors = 1;

	if (m_pDAOErrors == NULL)
		InitErrorsCollection();

	if (m_nAfxDaoError != AFX_DAO_ERROR_ENGINE_INITIALIZATION)
		DAO_CHECK_MEM(m_pDAOErrors->get_Count(&nErrors));

	return nErrors;
}

void CDaoException::GetErrorInfo(int nIndex)
{
	ASSERT(m_pDAOError == NULL);

	if (m_pDAOErrors == NULL)
		InitErrorsCollection();

	if (m_nAfxDaoError != AFX_DAO_ERROR_ENGINE_INITIALIZATION)
	{
		// Get DAOError object and fill in error info struct
		DAO_CHECK_MEM(m_pDAOErrors->get_Item(
			COleVariant((long)nIndex), &m_pDAOError));

		FillErrorInfo();

		// Clean up
		m_pDAOError->Release();
		m_pDAOError = NULL;
	}
}

BOOL CDaoException::GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
	_Out_opt_ PUINT pnHelpContext) const
{
	ASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	BOOL bRetCode = FALSE;

	if (m_pErrorInfo != NULL)
	{
		// DAO help context is not a UINT!
		//  According to DAO it is positive and should be less 10,000,000
		if (pnHelpContext != NULL)
			*pnHelpContext = (UINT) m_pErrorInfo->m_lHelpContext;

		Checked::tcsncpy_s(lpszError, nMaxError, m_pErrorInfo->m_strDescription, _TRUNCATE);
		bRetCode = TRUE;
	}
	else
	{
		// Must be MFC DAO class internal error, get error string
		CString strError;
		if (strError.LoadString(
			AFX_IDP_DAO_FIRST + (m_nAfxDaoError - AFX_DAO_ERROR_MIN)))
		{
			Checked::tcsncpy_s(lpszError, nMaxError, strError, _TRUNCATE);
			bRetCode = TRUE;
		}
		else
			ASSERT(FALSE);  // Couldn't get resource.
	}
	return bRetCode;
}

// Implementation
void CDaoException::InitErrorsCollection()
{
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();

	// Engine not initialized!
	if (pDaoState->m_pDAODBEngine == NULL)
		m_nAfxDaoError = AFX_DAO_ERROR_ENGINE_INITIALIZATION;
	else
		DAO_CHECK_MEM(pDaoState->m_pDAODBEngine->get_Errors(
			&m_pDAOErrors));
}

void CDaoException::FillErrorInfo()
{
	ASSERT(m_pDAOError != NULL);
	// Allocate the error info structure if necessary
	if (m_pErrorInfo == NULL)
		m_pErrorInfo = new CDaoErrorInfo;

	COleVariant var;

	DAO_CHECK_MEM(m_pDAOError->get_Number(
		&m_pErrorInfo->m_lErrorCode));

	DAO_CHECK_MEM(m_pDAOError->get_Source(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	m_pErrorInfo->m_strSource = V_BSTRT(&var);
	var.Clear();

	DAO_CHECK_MEM(m_pDAOError->get_Description(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	m_pErrorInfo->m_strDescription = V_BSTRT(&var);
	var.Clear();

	DAO_CHECK_MEM(m_pDAOError->get_HelpFile(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	m_pErrorInfo->m_strHelpFile = V_BSTRT(&var);

	DAO_CHECK_MEM(m_pDAOError->get_HelpContext(
		&m_pErrorInfo->m_lHelpContext));
}

void AFXAPI AfxThrowDaoException(int nAfxDaoError, SCODE scode)
{
	CDaoException* pException;
	pException = new CDaoException;

	pException->m_scode = scode;

	if (nAfxDaoError == NO_AFX_DAO_ERROR)
	{
		TRY
		{
			int nErrors = pException->GetErrorCount();
			for (int nIndex = 0; nIndex < nErrors; nIndex++)
			{
				pException->GetErrorInfo(nIndex);

				TRACE(traceDatabase, 0, _T("\nError Code = %d\n"),
					pException->m_pErrorInfo->m_lErrorCode);
				TRACE(traceDatabase, 0, _T("Source = %s\n"),
					(LPCTSTR)pException->m_pErrorInfo->m_strSource);
				TRACE(traceDatabase, 0, _T("Description = %s\n"),
					(LPCTSTR)pException->m_pErrorInfo->m_strDescription);
			}
		}
		CATCH_ALL(e)
		{
			// No DAO error info
			e->Delete();
		}
		END_CATCH_ALL
	}
	else
		pException->m_nAfxDaoError = nAfxDaoError;

	THROW(pException);
}


//////////////////////////////////////////////////////////////////////////
// CDaoWorkspace
IMPLEMENT_DYNAMIC(CDaoWorkspace, CObject)

CDaoWorkspace::CDaoWorkspace()
{
	m_pDAOWorkspaces = NULL;
	m_pDAOWorkspace = NULL;
	m_pDAODatabases = NULL;

	m_bOpen = FALSE;
	m_bNew = FALSE;
	m_nStatus = 0;
}

CDaoWorkspace::~CDaoWorkspace()
{
	AFX_BEGIN_DESTRUCTOR

		if (IsOpen())
		{
			m_nStatus |= AFX_DAO_IMPLICIT_CLOSE;
			Close();
		}
		else if (m_bNew)
		{
			// Remove the workspace from the AFX_DAO_STATE's map
			_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
			pDaoState->m_mapWorkspaces.RemoveKey(this);
		}

	AFX_END_DESTRUCTOR
}

void CDaoWorkspace::Create(LPCTSTR lpszName, LPCTSTR lpszUserName,
	LPCTSTR lpszPassword)
{
	ASSERT_VALID(this);
	ASSERT(!IsOpen());
	ASSERT(lpszUserName != NULL);
	ASSERT(lpszPassword != NULL);

	// Get the DAODBEngine interface and initialize if necessary
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	COleVariant varName(lpszName, VT_BSTRT);
	COleVariant varUserName(lpszUserName, VT_BSTRT);
	COleVariant varPassword(lpszPassword, VT_BSTRT);

	DAO_CHECK(pDaoState->m_pDAODBEngine->_30_CreateWorkspace(
		V_BSTR(&varName), V_BSTR(&varUserName),
		V_BSTR(&varPassword), &m_pDAOWorkspace));

	m_bNew = TRUE;

	// Add the workspace to map of Open/New CDaoWorkspaces
	pDaoState->m_mapWorkspaces.SetAt(this, this);
}

void CDaoWorkspace::Append()
{
	ASSERT_VALID(this);
	ASSERT(m_bNew);
	ASSERT(m_pDAOWorkspace != NULL);

	DAOWorkspaces* pDAOWorkspaces;

	// Get the DAODBEngine interface and initialize if necessary
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->get_Workspaces(&pDAOWorkspaces));

	TRY
	{
		DAO_CHECK(pDAOWorkspaces->Append(m_pDAOWorkspace));
	}
	CATCH_ALL(e)
	{
		pDAOWorkspaces->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOWorkspaces->Release();

	m_bNew = FALSE;
	m_bOpen = TRUE;
}

void CDaoWorkspace::Open(LPCTSTR lpszWorkspaceName)
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOWorkspaces == NULL);
	ASSERT(m_pDAOWorkspace == NULL);

	// Re-Opening is invalid.
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	// Set the workspace name (or use 0 if opening default)
	COleVariant var(lpszWorkspaceName, VT_BSTRT);
	if (lpszWorkspaceName == NULL)
	{
		var = 0L;

		// Set status to prevent DAO Workspace Close call
		m_nStatus |= AFX_DAO_DEFAULT_WS;
	}

	// Get the DAODBEngine interface and initialize if necessary
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	// Get the workspace from the workspaces collection
	DAO_CHECK(pDaoState->m_pDAODBEngine->get_Workspaces(
		&m_pDAOWorkspaces));
	DAO_CHECK(m_pDAOWorkspaces->get_Item(var, &m_pDAOWorkspace));

	m_bOpen = TRUE;
	m_pDAOWorkspaces->Release();
	m_pDAOWorkspaces = NULL;

	// Add the workspace to map of Open/New CDaoWorkspaces
	pDaoState->m_mapWorkspaces.SetAt(this, this);
}

void CDaoWorkspace::Close()
{
	ASSERT_VALID(this);

	if (m_pDAODatabases != NULL)
	{
		m_pDAODatabases->Release();
		m_pDAODatabases = NULL;
	}

	// Close any Open CDaoDatabases
	void* pvKey;
	void* pvObject;
	POSITION pos = m_mapDatabases.GetStartPosition();
	while (pos != NULL)
	{
		m_mapDatabases.GetNextAssoc(pos, pvKey, pvObject);
		((CDaoDatabase*)pvObject)->Close();
	}
	m_mapDatabases.RemoveAll();

	if (m_pDAOWorkspace != NULL)
	{
		// If implicit workspace or close, don't call DAO close.
		// It will be automatically closed when ref count 0.
		if (!(m_nStatus & (AFX_DAO_IMPLICIT_WS | AFX_DAO_IMPLICIT_CLOSE |
			AFX_DAO_DEFAULT_WS)))
		{
			DAO_TRACE(m_pDAOWorkspace->Close());
		}

		m_pDAOWorkspace->Release();
		m_pDAOWorkspace = NULL;
	}

	if (m_pDAOWorkspaces != NULL)
	{
		m_pDAOWorkspaces->Release();
		m_pDAOWorkspaces = NULL;
	}

	m_bOpen = FALSE;
	m_bNew = FALSE;
	m_nStatus &= ~AFX_DAO_DEFAULT_WS;

	// Remove the workspace from the AFX_DAO_STATE's map
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	pDaoState->m_mapWorkspaces.RemoveKey(this);
}

CString PASCAL CDaoWorkspace::GetVersion()
{
	COleVariant var;

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->get_Version(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString PASCAL CDaoWorkspace::GetIniPath()
{
	COleVariant var;
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->get_IniPath(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void PASCAL CDaoWorkspace::SetIniPath(LPCTSTR lpszRegistrySubKey)
{
	COleVariant var(lpszRegistrySubKey, VT_BSTRT);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->put_IniPath(V_BSTR(&var)));
}

void PASCAL CDaoWorkspace::SetDefaultUser(LPCTSTR lpszDefaultUser)
{
	COleVariant var(lpszDefaultUser, VT_BSTRT);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->put_DefaultUser(V_BSTR(&var)));
}

void PASCAL CDaoWorkspace::SetDefaultPassword(LPCTSTR lpszPassword)
{
	COleVariant var(lpszPassword, VT_BSTRT);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->put_DefaultPassword(
		V_BSTR(&var)));
}

short PASCAL CDaoWorkspace::GetLoginTimeout()
{
	short nSeconds;

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->get_LoginTimeout(&nSeconds));
	return nSeconds;
}

void PASCAL CDaoWorkspace::SetLoginTimeout(short nSeconds)
{
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->put_LoginTimeout(nSeconds));
}


CString CDaoWorkspace::GetName()
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOWorkspace != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOWorkspace->get_Name(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString CDaoWorkspace::GetUserName()
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOWorkspace != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOWorkspace->get_UserName(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoWorkspace::SetIsolateODBCTrans(BOOL bIsolateODBCTrans)
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOWorkspace != NULL);

	DAO_CHECK(m_pDAOWorkspace->put_IsolateODBCTrans(
		(short)(bIsolateODBCTrans ? AFX_DAO_TRUE : AFX_DAO_FALSE)));
}

BOOL CDaoWorkspace::GetIsolateODBCTrans()
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOWorkspace != NULL);

	short nIsolateODBCTrans;
	DAO_CHECK(m_pDAOWorkspace->get_IsolateODBCTrans(&nIsolateODBCTrans));
	return nIsolateODBCTrans == AFX_DAO_TRUE;
}

void PASCAL CDaoWorkspace::CompactDatabase(LPCTSTR lpszSrcName,
	LPCTSTR lpszDestName, LPCTSTR lpszLocale, int nOptions,
	LPCTSTR lpszPassword)
{
	COleVariant varSrcName(lpszSrcName, VT_BSTRT);
	COleVariant varDestName(lpszDestName, VT_BSTRT);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->CompactDatabase(
		V_BSTR(&varSrcName), V_BSTR(&varDestName),
		COleVariant(lpszLocale, VT_BSTRT), COleVariant((long)nOptions),
		lpszPassword != NULL ? (VARIANT)COleVariant(lpszPassword, VT_BSTRT) :
		_afxOptionalVariant));
}

void PASCAL CDaoWorkspace::CompactDatabase(LPCTSTR lpszSrcName,
	LPCTSTR lpszDestName, LPCTSTR lpszLocale, int nOptions)
{
	CompactDatabase(lpszSrcName, lpszDestName, lpszLocale, nOptions, NULL);
}

void PASCAL CDaoWorkspace::RepairDatabase(LPCTSTR lpszName)
{
	COleVariant varName(lpszName, VT_BSTRT);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->RepairDatabase(
		V_BSTR(&varName)));
}

void PASCAL CDaoWorkspace::Idle(int nAction)
{
	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->Idle(
		COleVariant((long)nAction)));
}

short CDaoWorkspace::GetWorkspaceCount()
{
	ASSERT_VALID(this);

	short nFields;

	if (m_pDAOWorkspaces == NULL)
		InitWorkspacesCollection();

	DAO_CHECK(m_pDAOWorkspaces->get_Count(&nFields));
	return nFields;
}

void CDaoWorkspace::GetWorkspaceInfo(int nIndex,
	CDaoWorkspaceInfo& wsinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOWorkspaces == NULL)
		InitWorkspacesCollection();

	// Get DAOWorkspace object and fill in workspace info struct
	DAOWorkspace* pDAOWorkspace;
	DAO_CHECK(m_pDAOWorkspaces->get_Item(
		COleVariant((long)nIndex), &pDAOWorkspace));
	FillWorkspaceInfo(pDAOWorkspace, wsinfo, dwInfoOptions);

	// Clean up
	pDAOWorkspace->Release();
}

void CDaoWorkspace::GetWorkspaceInfo(
	LPCTSTR lpszName, CDaoWorkspaceInfo& wsinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOWorkspaces == NULL)
		InitWorkspacesCollection();

	// Get DAOWorkspace object and fill in workspace info struct
	DAOWorkspace* pDAOWorkspace;
	DAO_CHECK(m_pDAOWorkspaces->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOWorkspace));
	FillWorkspaceInfo(pDAOWorkspace, wsinfo, dwInfoOptions);

	// Clean up
	pDAOWorkspace->Release();
}

short CDaoWorkspace::GetDatabaseCount()
{
	ASSERT_VALID(this);

	if (m_pDAODatabases == NULL)
		InitDatabasesCollection();

	short nFields;
	DAO_CHECK(m_pDAODatabases->get_Count(&nFields));
	return nFields;
}

void CDaoWorkspace::GetDatabaseInfo(int nIndex, CDaoDatabaseInfo& dbinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAODatabases == NULL)
		InitDatabasesCollection();

	// Get DAODatabase object and fill in database info struct
	DAODatabase* pDAODatabase;
	DAO_CHECK(m_pDAODatabases->get_Item(
		COleVariant((long)nIndex), &pDAODatabase));
	FillDatabaseInfo(pDAODatabase, dbinfo, dwInfoOptions);

	// Clean up
	pDAODatabase->Release();
}

void CDaoWorkspace::GetDatabaseInfo(LPCTSTR lpszName,
	CDaoDatabaseInfo& dbinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAODatabases == NULL)
		InitDatabasesCollection();

	// Get DAODatabase object and fill in database info struct
	DAODatabase* pDAODatabase;
	DAO_CHECK(m_pDAODatabases->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAODatabase));
	FillDatabaseInfo(pDAODatabase, dbinfo, dwInfoOptions);

	// Clean up
	pDAODatabase->Release();
}

void CDaoWorkspace::BeginTrans()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOWorkspace != NULL);

	DAO_CHECK(m_pDAOWorkspace->BeginTrans());
}

// Determine whether to use DAO 3.6, 3.5, or 3.0
// Use DAO 3.0 if DLL build and not built with MFC 4.21 or later
// Use DAO 3.6 if MFC 6.01 or later
// otherwise, DAO 3.5

#ifndef _AFXDLL
#if _MFC_VER >= 0x0601
#define _AfxDetermineDaoVersion()   (36)
#else
#define _AfxDetermineDaoVersion()   (35)
#endif
#else // dynamically because of DLL
static inline BYTE _AfxDetermineDaoVersion()
{
	BYTE bReturn = 35;

#ifdef _AFXDLL
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	if (pModuleState->m_dwVersion < 0x421)
		bReturn = 30;
	else if (pModuleState->m_dwVersion >= 0x0601)
		bReturn = 36;
#endif // _AFXDLL

	return bReturn;
}
#endif

void CDaoWorkspace::CommitTrans()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOWorkspace != NULL);

	// Call DAO 3.5 or 3.6 method with no option set.
	// CommitTrans option parameter not yet supported.
	DAO_CHECK(m_pDAOWorkspace->CommitTrans(0));
}

void CDaoWorkspace::Rollback()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOWorkspace != NULL);

	DAO_CHECK(m_pDAOWorkspace->Rollback());
}

//Implementation
void AFX_CDECL CDaoWorkspace::InitializeEngine()
{
	AfxDaoInit();
}

void CDaoWorkspace::InitWorkspacesCollection()
{
	ASSERT_VALID(this);

	_AFX_DAO_STATE* pDaoState = AfxGetDaoState();
	if (pDaoState->m_pDAODBEngine == NULL)
		InitializeEngine();

	DAO_CHECK(pDaoState->m_pDAODBEngine->get_Workspaces(
		&m_pDAOWorkspaces));
}

void CDaoWorkspace::FillWorkspaceInfo(DAOWorkspace* pDAOWorkspace,
	CDaoWorkspaceInfo& wsinfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAOWorkspace != NULL);
	ASSERT(dwOptions != 0);

	COleVariant var;
	short nBool;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAOWorkspace->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		wsinfo.m_strName = V_BSTRT(&var);
		var.Clear();
	}

	if (dwOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAOWorkspace->get_UserName(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		wsinfo.m_strUserName = V_BSTRT(&var);
	}

	if (dwOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		DAO_CHECK(pDAOWorkspace->get_IsolateODBCTrans(&nBool));
		wsinfo.m_bIsolateODBCTrans = nBool == AFX_DAO_TRUE;
	}
}

void CDaoWorkspace::InitDatabasesCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAOWorkspace->get_Databases(&m_pDAODatabases));
}

void CDaoWorkspace::FillDatabaseInfo(DAODatabase* pDAODatabase,
	CDaoDatabaseInfo& dbinfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAODatabase != NULL);
	ASSERT(dwOptions != 0);

	COleVariant var;
	short nBool;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAODatabase->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		dbinfo.m_strName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAODatabase->get_Updatable(&nBool));
		dbinfo.m_bUpdatable = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAODatabase->get_Transactions(&nBool));
		dbinfo.m_bTransactions = nBool == AFX_DAO_TRUE;
	}

	if (dwOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAODatabase->get_Version(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		dbinfo.m_strVersion = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAODatabase->get_CollatingOrder(
			&dbinfo.m_lCollatingOrder));

		DAO_CHECK(pDAODatabase->get_QueryTimeout(
			&dbinfo.m_nQueryTimeout));
	}

	if (dwOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		DAO_CHECK(pDAODatabase->get_Connect(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		dbinfo.m_strConnect = V_BSTRT(&var);
	}
}

void CDaoWorkspace::ThrowDaoException(int nAfxDaoError)
{
	ASSERT_VALID(this);

	AfxThrowDaoException(nAfxDaoError);
}

#ifdef _DEBUG
void CDaoWorkspace::AssertValid() const
{
	CObject::AssertValid();
}

void CDaoWorkspace::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CObject::Dump(dc);

	dc << _T("m_bOpen = ") << m_bOpen;
	dc << _T("\nm_bNew = ") << m_bNew;
	dc << _T("\nm_nStatus = ") << m_nStatus;

	dc << _T("\n");
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////
// CDaoDatabase
IMPLEMENT_DYNAMIC(CDaoDatabase, CObject)

CDaoDatabase::CDaoDatabase(CDaoWorkspace* pWorkspace)
{
	m_bOpen = FALSE;

	m_pDAODatabase = NULL;

	m_pDAOTableDefs = NULL;
	m_pDAORelations = NULL;
	m_pDAOQueryDefs = NULL;
	m_pDAORecordsets = NULL;

	m_pWorkspace = pWorkspace;
	m_nStatus = 0;
}

CDaoDatabase::~CDaoDatabase()
{
	AFX_BEGIN_DESTRUCTOR

		if (IsOpen())
			Close();

		// Clean up workspace if necessary
		if (m_pWorkspace != NULL && (m_nStatus & AFX_DAO_IMPLICIT_WS))
		{
			m_pWorkspace->Close();
			delete m_pWorkspace;
			m_pWorkspace = NULL;
		}

	AFX_END_DESTRUCTOR
}

void CDaoDatabase::Create(LPCTSTR lpszName, LPCTSTR lpszLocale,
	int nOptions)
{
	ASSERT_VALID(this);
	ASSERT(!IsOpen());

	// Allocate and maintain workspace if necessary
	InitWorkspace();

	COleVariant varName(lpszName, VT_BSTRT);
	COleVariant varLocale(lpszLocale, VT_BSTRT);

	DAO_CHECK(m_pWorkspace->m_pDAOWorkspace->CreateDatabase(V_BSTR(&varName),
		V_BSTR(&varLocale), COleVariant((long)nOptions),
		&m_pDAODatabase));

	m_bOpen = TRUE;

	// Add the database to map of Open CDaoDatabases
	m_pWorkspace->m_mapDatabases.SetAt(this, this);
}

void CDaoDatabase::Open(LPCTSTR lpszName, BOOL bExclusive,
	BOOL bReadOnly, LPCTSTR lpszConnect)
{
	ASSERT_VALID(this);

	// Re-Opening is invalid.
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	// Allocate, maintain and/or open workspace if necessary
	InitWorkspace();

	COleVariant var(lpszName, VT_BSTRT);

	DAO_CHECK(m_pWorkspace->m_pDAOWorkspace->OpenDatabase(
		V_BSTR(&var),
		COleVariant((long)bExclusive, VT_BOOL),
		COleVariant((long)bReadOnly, VT_BOOL),
		COleVariant(lpszConnect, VT_BSTRT),
		&m_pDAODatabase));

	m_bOpen = TRUE;

	// Add the database to map of Open CDaoDatabases
	m_pWorkspace->m_mapDatabases.SetAt(this, this);
}

// Disconnect connection
void CDaoDatabase::Close()
{
	ASSERT_VALID(this);

	if (m_pDAORecordsets != NULL)
	{
		m_pDAORecordsets->Release();
		m_pDAORecordsets = NULL;
	}

	if (m_pDAOQueryDefs != NULL)
	{
		m_pDAOQueryDefs->Release();
		m_pDAOQueryDefs = NULL;
	}

	if (m_pDAORelations != NULL)
	{
		m_pDAORelations->Release();
		m_pDAORelations = NULL;
	}

	if (m_pDAOTableDefs != NULL)
	{
		m_pDAOTableDefs->Release();
		m_pDAOTableDefs = NULL;
	}

	// Close any Open CDaoRecordsets
	void* pvKey;
	void* pvObject;
	POSITION pos = m_mapRecordsets.GetStartPosition();
	while (pos != NULL)
	{
		m_mapRecordsets.GetNextAssoc(pos, pvKey, pvObject);
		((CDaoRecordset*)pvObject)->Close();
	}
	m_mapRecordsets.RemoveAll();

	// Close any Open CDaoQueryDefs
	pos = m_mapQueryDefs.GetStartPosition();
	while (pos != NULL)
	{
		m_mapQueryDefs.GetNextAssoc(pos, pvKey, pvObject);
		((CDaoQueryDef*)pvObject)->Close();
	}
	m_mapQueryDefs.RemoveAll();

	// Close any Open CDaoTableDefs
	pos = m_mapTableDefs.GetStartPosition();
	while (pos != NULL)
	{
		m_mapTableDefs.GetNextAssoc(pos, pvKey, pvObject);
		((CDaoTableDef*)pvObject)->Close();
	}
	m_mapTableDefs.RemoveAll();

	if (m_pDAODatabase != NULL)
	{
		// If implicit database, don't close.
		// It will be automatically closed when ref count 0.
		if (!(m_nStatus & AFX_DAO_IMPLICIT_DB))
			DAO_TRACE(m_pDAODatabase->Close());

		m_pDAODatabase->Release();
		m_pDAODatabase = NULL;
	}

	m_bOpen = FALSE;

	// Remove the CDaoDatabase from the CDaoWorkspace's map
	m_pWorkspace->m_mapDatabases.RemoveKey(this);
}

BOOL CDaoDatabase::CanUpdate()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	short nUpdatable;
	DAO_CHECK(m_pDAODatabase->get_Updatable(&nUpdatable));
	return nUpdatable == AFX_DAO_TRUE;
}

BOOL CDaoDatabase::CanTransact()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	short nTransactable;
	DAO_CHECK(m_pDAODatabase->get_Transactions(&nTransactable));
	return nTransactable == AFX_DAO_TRUE;
}

CString CDaoDatabase::GetName()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAODatabase->get_Name(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString CDaoDatabase::GetConnect()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAODatabase->get_Connect(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString CDaoDatabase::GetVersion()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAODatabase->get_Version(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

short CDaoDatabase::GetQueryTimeout()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	short nQueryTimeout;
	DAO_CHECK(m_pDAODatabase->get_QueryTimeout(&nQueryTimeout));
	return nQueryTimeout;
}

void CDaoDatabase::SetQueryTimeout(short nSeconds)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	DAO_CHECK(m_pDAODatabase->put_QueryTimeout(nSeconds));
}

long CDaoDatabase::GetRecordsAffected()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAODatabase != NULL);

	long lRecordsAffected;
	DAO_CHECK(m_pDAODatabase->get_RecordsAffected(&lRecordsAffected));
	return lRecordsAffected;
}

void CDaoDatabase::DeleteTableDef(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	if (m_pDAOTableDefs == NULL)
		InitTableDefsCollection();

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDefs->Delete(V_BSTR(&var)));
}

void CDaoDatabase::DeleteQueryDef(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	if (m_pDAOQueryDefs == NULL)
		InitQueryDefsCollection();

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOQueryDefs->Delete(V_BSTR(&var)));
}

void CDaoDatabase::CreateRelation(LPCTSTR lpszName, LPCTSTR lpszTable,
	LPCTSTR lpszForeignTable, long lAttributes, LPCTSTR lpszField,
	LPCTSTR lpszForeignField)
{
	ASSERT_VALID(this);

	CDaoRelationInfo relinfo;
	CDaoRelationFieldInfo fieldinfo;

	relinfo.m_strName = lpszName;
	relinfo.m_strTable = lpszTable;
	relinfo.m_strForeignTable = lpszForeignTable;
	relinfo.m_lAttributes = lAttributes;
	relinfo.m_nFields = 1;

	relinfo.m_pFieldInfos = &fieldinfo;
	relinfo.m_pFieldInfos->m_strName = lpszField;
	relinfo.m_pFieldInfos->m_strForeignName = lpszForeignField;

	CreateRelation(relinfo);
}

void CDaoDatabase::CreateRelation(CDaoRelationInfo& relinfo)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(relinfo.m_nFields > 0);

	// Initialize relations collection so that relation can be appended later
	if (m_pDAORelations == NULL)
		InitRelationsCollection();

	DAORelation* pDAORelation = NULL;
	DAOFields* pDAOFields = NULL;
	DAOField* pDAOField = NULL;

	// Create the relation
	DAO_CHECK(m_pDAODatabase->CreateRelation(
		COleVariant(relinfo.m_strName, VT_BSTRT),
		COleVariant(relinfo.m_strTable, VT_BSTRT),
		COleVariant(relinfo.m_strForeignTable, VT_BSTRT),
		COleVariant(relinfo.m_lAttributes), &pDAORelation));

	TRY
	{
		// Get the fields collection for later append of created field
		DAO_CHECK(pDAORelation->get_Fields(&pDAOFields));

		// Create field(s) and set the name and foreign name
		for (int nIndex = 0; nIndex < relinfo.m_nFields; nIndex++)
		{
			DAO_CHECK(pDAORelation->CreateField(
				COleVariant(relinfo.m_pFieldInfos[nIndex].m_strName, VT_BSTRT),
				_afxOptionalVariant, _afxOptionalVariant, &pDAOField));

			COleVariant var(relinfo.m_pFieldInfos[nIndex].m_strForeignName, VT_BSTRT);
			DAO_CHECK(pDAOField->put_ForeignName(V_BSTR(&var)));

			// Append the field to relation fields collection and release
			DAO_CHECK(pDAOFields->Append(pDAOField));
			pDAOField->Release();
			pDAOField = NULL;
		}

		DAO_CHECK(m_pDAORelations->Append(pDAORelation));
	}
	CATCH_ALL(e)
	{
		// Clean up before throw
		if (pDAOField != NULL)
			pDAOField->Release();

		if (pDAOFields != NULL)
			pDAOFields->Release();

		pDAORelation->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	// Clean up
	if (pDAOField != NULL)
		pDAOField->Release();

	pDAOFields->Release();
	pDAORelation->Release();
}

void CDaoDatabase::DeleteRelation(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	if (m_pDAORelations == NULL)
		InitRelationsCollection();

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAORelations->Delete(V_BSTR(&var)));
}

void CDaoDatabase::Execute(LPCTSTR lpszSQL, int nOptions)
{
	ASSERT_VALID(this);
	ASSERT(m_pDAODatabase != NULL);

	COleVariant var(lpszSQL, VT_BSTRT);
	DAO_CHECK(m_pDAODatabase->Execute(
		V_BSTR(&var), COleVariant((long)nOptions)));
}

short CDaoDatabase::GetTableDefCount()
{
	ASSERT_VALID(this);

	short nTables;

	if (m_pDAOTableDefs == NULL)
		InitTableDefsCollection();

	DAO_CHECK(m_pDAOTableDefs->get_Count(&nTables));
	return nTables;
}

void CDaoDatabase::GetTableDefInfo(int nIndex, CDaoTableDefInfo& tabledefinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOTableDefs == NULL)
		InitTableDefsCollection();

	// Get DAOTableDef object and fill in table info struct
	DAOTableDef* pDAOTableDef;
	DAO_CHECK(m_pDAOTableDefs->get_Item(
		COleVariant((long)nIndex), &pDAOTableDef));
	FillTableDefInfo(pDAOTableDef, tabledefinfo, dwInfoOptions);

	// Clean up
	pDAOTableDef->Release();
}

void CDaoDatabase::GetTableDefInfo(LPCTSTR lpszName,
	CDaoTableDefInfo&  tabledefinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOTableDefs == NULL)
		InitTableDefsCollection();

	// Get DAOTableDef object and fill in table info struct
	DAOTableDef* pDAOTableDef;
	DAO_CHECK(m_pDAOTableDefs->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOTableDef));
	FillTableDefInfo(pDAOTableDef, tabledefinfo, dwInfoOptions);

	// Clean up
	pDAOTableDef->Release();
}

short CDaoDatabase::GetRelationCount()
{
	ASSERT_VALID(this);

	short nRelations;

	if (m_pDAORelations == NULL)
		InitRelationsCollection();

	DAO_CHECK(m_pDAORelations->get_Count(&nRelations));
	return nRelations;
}

void CDaoDatabase::GetRelationInfo(int nIndex, CDaoRelationInfo& relinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAORelations == NULL)
		InitRelationsCollection();

	// Get DAORelation object and fill in relation info struct
	DAORelation* pDAORelation;
	DAO_CHECK(m_pDAORelations->get_Item(
		COleVariant((long)nIndex), &pDAORelation));
	FillRelationInfo(pDAORelation, relinfo, dwInfoOptions);

	// Clean up
	pDAORelation->Release();
}

void CDaoDatabase::GetRelationInfo(LPCTSTR lpszName,
	CDaoRelationInfo& relinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAORelations == NULL)
		InitRelationsCollection();

	// Get DAORelation object and fill in relation info struct
	DAORelation* pDAORelation;
	DAO_CHECK(m_pDAORelations->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAORelation));
	FillRelationInfo(pDAORelation, relinfo, dwInfoOptions);

	// Clean up
	pDAORelation->Release();
}

short CDaoDatabase::GetQueryDefCount()
{
	ASSERT_VALID(this);

	short nQueryDefs;

	if (m_pDAOQueryDefs == NULL)
		InitQueryDefsCollection();

	DAO_CHECK(m_pDAOQueryDefs->get_Count(&nQueryDefs));
	return nQueryDefs;
}

void CDaoDatabase::GetQueryDefInfo(int nIndex, CDaoQueryDefInfo& querydefinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOQueryDefs == NULL)
		InitQueryDefsCollection();

	// Get DAOQueryDef object and fill in query info struct
	DAOQueryDef* pDAOQueryDef;
	DAO_CHECK(m_pDAOQueryDefs->get_Item(
		COleVariant((long)nIndex), &pDAOQueryDef));
	FillQueryDefInfo(pDAOQueryDef, querydefinfo, dwInfoOptions);

	// Clean up
	pDAOQueryDef->Release();
}

void CDaoDatabase::GetQueryDefInfo(LPCTSTR lpszName,
	CDaoQueryDefInfo& querydefinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOQueryDefs == NULL)
		InitQueryDefsCollection();

	// Get DAOQueryDef object and fill in query info struct
	DAOQueryDef* pDAOQueryDef;
	DAO_CHECK(m_pDAOQueryDefs->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOQueryDef));
	FillQueryDefInfo(pDAOQueryDef, querydefinfo, dwInfoOptions);

	// Clean up
	pDAOQueryDef->Release();
}

// Implementation
void CDaoDatabase::InitWorkspace()
{
	ASSERT_VALID(this);

	if (m_pWorkspace == NULL)
	{
		// Allocate workspace and mark as implicit
		m_pWorkspace = new CDaoWorkspace;
		m_pWorkspace->m_nStatus |= AFX_DAO_IMPLICIT_WS;
		m_nStatus |= AFX_DAO_IMPLICIT_WS;
	}

	// Open workspace if not open and not new (unappended)
	if (!m_pWorkspace->IsOpen() && !m_pWorkspace->IsNew())
	{
		// Open the default workspace
		m_pWorkspace->Open();
	}
}

void CDaoDatabase::InitTableDefsCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAODatabase->get_TableDefs(&m_pDAOTableDefs));
}

void CDaoDatabase::FillTableDefInfo(DAOTableDef* pDAOTableDef,
	CDaoTableDefInfo& tabledefinfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAOTableDef != NULL);
	ASSERT(dwOptions != 0);

	COleVariant var;
	short nBool;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAOTableDef->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		tabledefinfo.m_strName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOTableDef->get_Updatable(&nBool));
		tabledefinfo.m_bUpdatable = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOTableDef->get_Attributes(
			&tabledefinfo.m_lAttributes));
	}

	if (dwOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAOTableDef->get_DateCreated(&var));
		tabledefinfo.m_dateCreated = var;

		DAO_CHECK(pDAOTableDef->get_LastUpdated(&var));
		tabledefinfo.m_dateLastUpdated = var;

		DAO_CHECK(pDAOTableDef->get_SourceTableName(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		tabledefinfo.m_strSrcTableName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOTableDef->get_Connect(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		tabledefinfo.m_strConnect = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOTableDef->get_ValidationRule(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		tabledefinfo.m_strValidationRule = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOTableDef->get_ValidationText(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		tabledefinfo.m_strValidationText = V_BSTRT(&var);
	}

	// This may be expensive, so only get it if absolutely necessary
	if (dwOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		DAO_CHECK(pDAOTableDef->get_RecordCount(
			&tabledefinfo.m_lRecordCount));
	}
}

void CDaoDatabase::InitRelationsCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAODatabase->get_Relations(&m_pDAORelations));
}

void CDaoDatabase::FillRelationInfo(DAORelation* pDAORelation,
	CDaoRelationInfo& relinfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAORelation != NULL);
	ASSERT(dwOptions != 0);

	COleVariant var;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		// All the relation info is primary
		DAO_CHECK(pDAORelation->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		relinfo.m_strName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAORelation->get_Table(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		relinfo.m_strTable = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAORelation->get_ForeignTable(
			&V_BSTR(&var)));
		var.vt = VT_BSTR;
		relinfo.m_strForeignTable = V_BSTRT(&var);
		var.Clear();
	}

	if (dwOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAOFields* pDAOFields = NULL;
		DAOField* pDAOField = NULL;

		DAO_CHECK(pDAORelation->get_Attributes(
			&relinfo.m_lAttributes));

		// Get the fields collection
		DAO_CHECK(pDAORelation->get_Fields(&pDAOFields));

		TRY
		{
			// Get the number of fields in the relation
			short nCount;
			DAO_CHECK(pDAOFields->get_Count(&nCount));

			// Allocate or reallocate memory for array if necessary
			if (nCount != relinfo.m_nFields)
			{
				if (relinfo.m_nFields != 0)
				{
					// Check that allocation is correct.
					ASSERT(relinfo.m_nFields == 0 ||
						relinfo.m_bCleanupFieldInfo);

					delete[] relinfo.m_pFieldInfos;
					relinfo.m_pFieldInfos = NULL;
				}

				// Now allocate required memory
				relinfo.m_pFieldInfos = new CDaoRelationFieldInfo[nCount];
				relinfo.m_bCleanupFieldInfo = TRUE;
				relinfo.m_nFields = nCount;
			}

			// Now get field info for each field
			for (int nIndex = 0; nIndex < relinfo.m_nFields; nIndex++)
			{
				// Get the field item
				DAO_CHECK(pDAOFields->get_Item(
					COleVariant((long)nIndex), &pDAOField));

				// Get the field name
				DAO_CHECK(pDAOField->get_Name(&V_BSTR(&var)));
				var.vt = VT_BSTR;
				relinfo.m_pFieldInfos[nIndex].m_strName =
					V_BSTRT(&var);
				var.Clear();

				// Get the foreign field name
				DAO_CHECK(pDAOField->get_ForeignName(&V_BSTR(&var)));
				var.vt = VT_BSTR;
				relinfo.m_pFieldInfos[nIndex].m_strForeignName =
					V_BSTRT(&var);
				var.Clear();

				// Release and reset the field object
				pDAOField->Release();
				pDAOField = NULL;
			}
		}
		CATCH_ALL(e)
		{
			if (pDAOField != NULL)
				pDAOField->Release();

			pDAOFields->Release();
			THROW_LAST();
		}
		END_CATCH_ALL

		// Release the objects
		pDAOFields->Release();
	}
}

void CDaoDatabase::InitQueryDefsCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAODatabase->get_QueryDefs(&m_pDAOQueryDefs));
}

void CDaoDatabase::FillQueryDefInfo(DAOQueryDef* pDAOQueryDef,
	CDaoQueryDefInfo& querydefinfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAOQueryDef != NULL);
	ASSERT(dwOptions != 0);

	COleVariant var;
	short nBool;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAOQueryDef->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		querydefinfo.m_strName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOQueryDef->get_Type(&querydefinfo.m_nType));
	}

	if (dwOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAOQueryDef->get_Updatable(&nBool));
		querydefinfo.m_bUpdatable = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOQueryDef->get_DateCreated(&var));
		querydefinfo.m_dateCreated = var;

		DAO_CHECK(pDAOQueryDef->get_LastUpdated(&var));
		querydefinfo.m_dateLastUpdated = var;

		DAO_CHECK(pDAOQueryDef->get_ReturnsRecords(&nBool));
		querydefinfo.m_bReturnsRecords = nBool == AFX_DAO_TRUE;
	}

	if (dwOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		DAO_CHECK(pDAOQueryDef->get_SQL(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		querydefinfo.m_strSQL = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOQueryDef->get_Connect(&V_BSTR(
			(LPVARIANT)var)));
		var.vt = VT_BSTR;
		querydefinfo.m_strConnect = V_BSTRT(&var);

		// DAO will display ODBC connect dialog
		// if data source no longer exists. This must
		// be avoided during bulk info retrieval.
		// Call CDaoQueryDef::GetODBCTimeout directly.
		//  DAO_CHECK(pDAOQueryDef->get_ODBCTimeout(
		//      &querydefinfo.m_nODBCTimeout));

		// Set the m_nODBCTimeout variable to invalid value.
		querydefinfo.m_nODBCTimeout = -1;
	}
}

void CDaoDatabase::ThrowDaoException(int nAfxDaoError)
{
	ASSERT_VALID(this);

	AfxThrowDaoException(nAfxDaoError);
}

#ifdef _DEBUG
void CDaoDatabase::AssertValid() const
{
	CObject::AssertValid();
}

void CDaoDatabase::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CObject::Dump(dc);

	dc << _T("m_bOpen = ") << m_bOpen;
	dc << _T("\nm_nStatus = ") << m_nStatus;

	dc << _T("\n");
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////
// CDaoTableDef
IMPLEMENT_DYNAMIC(CDaoTableDef, CObject)

CDaoTableDef::CDaoTableDef(CDaoDatabase* pDatabase)
{
	m_bOpen = FALSE;
	m_bNew = FALSE;

	m_pDatabase = pDatabase;
	m_pDAOTableDef = NULL;
	m_pDAOFields = NULL;
	m_pDAOIndexes = NULL;
}

CDaoTableDef::~CDaoTableDef()
{
	if (IsOpen())
		Close();
	else if (m_bNew)
	{
		// Remove the tabledef from the CDaoDatabase's map
		m_pDatabase->m_mapTableDefs.RemoveKey(this);
	}
}

void CDaoTableDef::Create(LPCTSTR lpszName, long lAttributes,
	LPCTSTR lpszSrcTable, LPCTSTR lpszConnect)
{
	ASSERT_VALID(this);
	ASSERT(!IsOpen());

	DAO_CHECK(m_pDatabase->m_pDAODatabase->CreateTableDef(
		COleVariant(lpszName, VT_BSTRT), COleVariant(lAttributes),
		COleVariant(lpszSrcTable, VT_BSTRT),
		COleVariant(lpszConnect, VT_BSTRT), &m_pDAOTableDef));

	m_bNew = TRUE;

	// Add the tabledef to map of Open/New CDaoTableDefs
	m_pDatabase->m_mapTableDefs.SetAt(this, this);
}

void CDaoTableDef::Append()
{
	ASSERT_VALID(this);
	ASSERT(m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	DAOTableDefs* pDAOTableDefs;
	DAO_CHECK(m_pDatabase->m_pDAODatabase->get_TableDefs(
		&pDAOTableDefs));

	TRY
	{
		DAO_CHECK(pDAOTableDefs->Append(m_pDAOTableDef));
	}
	CATCH_ALL(e)
	{
		pDAOTableDefs->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOTableDefs->Release();

	m_bNew = FALSE;
	m_bOpen = TRUE;
}

void CDaoTableDef::Open(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(lpszName != NULL);

	// Re-open is invalid
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	DAOTableDefs* pDAOTableDefs = NULL;

	TRY
	{
		DAO_CHECK(m_pDatabase->m_pDAODatabase->get_TableDefs(
			&pDAOTableDefs));
		DAO_CHECK(pDAOTableDefs->get_Item(
			COleVariant(lpszName, VT_BSTRT),&m_pDAOTableDef));
	}
	CATCH_ALL(e)
	{
		if (pDAOTableDefs != NULL)
			pDAOTableDefs->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOTableDefs->Release();

	m_bOpen = TRUE;

	// Add the tabledef to map of Open/New CDaoTableDefs
	m_pDatabase->m_mapTableDefs.SetAt(this, this);
}

void CDaoTableDef::Close()
{
	ASSERT_VALID(this);

	if (m_pDAOIndexes != NULL)
	{
		m_pDAOIndexes->Release();
		m_pDAOIndexes = NULL;
	}

	if (m_pDAOFields != NULL)
	{
		m_pDAOFields->Release();
		m_pDAOFields = NULL;
	}

	if (m_pDAOTableDef != NULL)
	{
		m_pDAOTableDef->Release();
		m_pDAOTableDef = NULL;
	}

	m_bOpen = FALSE;
	m_bNew = FALSE;

	// Remove the tabledef from the CDaoDatabase's map
	m_pDatabase->m_mapTableDefs.RemoveKey(this);
}

BOOL CDaoTableDef::CanUpdate()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	short nUpdatable;
	DAO_CHECK(m_pDAOTableDef->get_Updatable(&nUpdatable));
	return nUpdatable == AFX_DAO_TRUE;
}

void CDaoTableDef::SetName(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDef->put_Name(V_BSTR(&var)));
}

CString CDaoTableDef::GetName()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOTableDef->get_Name(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoTableDef::SetSourceTableName(LPCTSTR lpszSrcTableName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var(lpszSrcTableName, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDef->put_SourceTableName(
		V_BSTR(&var)));
}

CString CDaoTableDef::GetSourceTableName()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOTableDef->get_SourceTableName(
		&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoTableDef::SetConnect(LPCTSTR lpszConnect)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var(lpszConnect, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDef->put_Connect(V_BSTR(&var)));
}

CString CDaoTableDef::GetConnect()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOTableDef->get_Connect(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoTableDef::SetAttributes(long lAttributes)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	DAO_CHECK(m_pDAOTableDef->put_Attributes(lAttributes));
}

long CDaoTableDef::GetAttributes()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	long lAttributes;
	DAO_CHECK(m_pDAOTableDef->get_Attributes(&lAttributes));
	return lAttributes;
}

COleDateTime CDaoTableDef::GetDateCreated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant varDate;
	DAO_CHECK(m_pDAOTableDef->get_DateCreated(&varDate));
	return varDate.date;
}

COleDateTime CDaoTableDef::GetDateLastUpdated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant varDate;
	DAO_CHECK(m_pDAOTableDef->get_LastUpdated(&varDate));
	return varDate.date;
}

void CDaoTableDef::SetValidationRule(
	LPCTSTR lpszValidationRule)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var(lpszValidationRule, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDef->put_ValidationRule(
		V_BSTR(&var)));
}

CString CDaoTableDef::GetValidationRule()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOTableDef->get_ValidationRule(
		&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoTableDef::SetValidationText(
	LPCTSTR lpszValidationText)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var(lpszValidationText, VT_BSTRT);
	DAO_CHECK(m_pDAOTableDef->put_ValidationText(
		V_BSTR(&var)));
}

CString CDaoTableDef::GetValidationText()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAOTableDef->get_ValidationText(
		&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

long CDaoTableDef::GetRecordCount()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	long lRecordCount;
	DAO_CHECK(m_pDAOTableDef->get_RecordCount(&lRecordCount));
	return lRecordCount;
}

void CDaoTableDef::CreateField(LPCTSTR lpszName, short nType, long lSize,
	long lAttributes)
{
	ASSERT_VALID(this);

	CDaoFieldInfo fieldinfo;

	// Initialize everything so only correct properties will be set
	fieldinfo.m_strName = lpszName;
	fieldinfo.m_nType = nType;
	fieldinfo.m_lSize = lSize;
	fieldinfo.m_lAttributes = lAttributes;
	fieldinfo.m_nOrdinalPosition = 0;
	fieldinfo.m_bRequired = FALSE;
	fieldinfo.m_bAllowZeroLength = FALSE;
	fieldinfo.m_lCollatingOrder = 0;

	CreateField(fieldinfo);
}

void CDaoTableDef::CreateField(CDaoFieldInfo& fieldinfo)
{
	ASSERT_VALID(this);

	DAOField* pDAOField;

	// Create the DAO field object (setting basic properties)
	DAO_CHECK(m_pDAOTableDef->CreateField(
		COleVariant(fieldinfo.m_strName, VT_BSTRT),
		COleVariant(fieldinfo.m_nType),
		COleVariant(fieldinfo.m_lSize), &pDAOField));

	TRY
	{
		// Basic properties already set, so set the rest
		AfxSetFieldInfo(pDAOField, fieldinfo);

		// Append the field object to the fields collection
		if (m_pDAOFields == NULL)
			InitFieldsCollection();
		DAO_CHECK(m_pDAOFields->Append(pDAOField));
	}
	CATCH_ALL(e)
	{
		pDAOField->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOField->Release();
}

void CDaoTableDef::DeleteField(LPCTSTR lpszName)
{
	ASSERT_VALID(this);

	ASSERT(lpszName != NULL);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOFields->Delete(V_BSTR(&var)));
}

void CDaoTableDef::DeleteField(int nIndex)
{
	ASSERT_VALID(this);

	CDaoFieldInfo fieldinfo;
	GetFieldInfo(nIndex, fieldinfo, AFX_DAO_PRIMARY_INFO);
	DeleteField((LPCTSTR)fieldinfo.m_strName);
}

void CDaoTableDef::CreateIndex(CDaoIndexInfo& indexinfo)
{
	ASSERT_VALID(this);

	DAOIndex* pDAOIndex;

	DAO_CHECK(m_pDAOTableDef->CreateIndex(
		COleVariant(indexinfo.m_strName, VT_BSTRT), &pDAOIndex));

	TRY
	{
		// Set the index info
		AfxSetIndexInfo(pDAOIndex, indexinfo);

		// Append the field object to the fields collection
		if (m_pDAOIndexes == NULL)
			InitIndexesCollection();
		DAO_CHECK(m_pDAOIndexes->Append(pDAOIndex));
	}
	CATCH_ALL(e)
	{
		pDAOIndex->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOIndex->Release();
}

void CDaoTableDef::DeleteIndex(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(lpszName != NULL);

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOIndexes->Delete(V_BSTR(&var)));
}

void CDaoTableDef::DeleteIndex(int nIndex)
{
	ASSERT_VALID(this);

	CDaoIndexInfo indexinfo;
	GetIndexInfo(nIndex, indexinfo, AFX_DAO_PRIMARY_INFO);
	DeleteIndex((LPCTSTR)indexinfo.m_strName);
}

short CDaoTableDef::GetFieldCount()
{
	ASSERT_VALID(this);

	short nFields;

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	DAO_CHECK(m_pDAOFields->get_Count(&nFields));
	return nFields;
}

void CDaoTableDef::GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant((long)nIndex), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

void CDaoTableDef::GetFieldInfo(LPCTSTR lpszName,
	CDaoFieldInfo& fieldinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

short CDaoTableDef::GetIndexCount()
{
	ASSERT_VALID(this);

	short nIndexes;

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	DAO_CHECK(m_pDAOIndexes->get_Count(&nIndexes));
	return nIndexes;
}

void CDaoTableDef::GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	// Get DAOField object and fill in field info struct
	DAOIndex* pDAOIndex;
	DAO_CHECK(m_pDAOIndexes->get_Item(
		COleVariant((long)nIndex), &pDAOIndex));
	AfxGetIndexInfo(pDAOIndex, indexinfo, dwInfoOptions);

	// Clean up
	pDAOIndex->Release();
}

void CDaoTableDef::GetIndexInfo(LPCTSTR lpszName,
	CDaoIndexInfo& indexinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	// Get DAOField object and fill in field info struct
	DAOIndex* pDAOIndex;
	DAO_CHECK(m_pDAOIndexes->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOIndex));
	AfxGetIndexInfo(pDAOIndex, indexinfo, dwInfoOptions);

	// Clean up
	pDAOIndex->Release();
}

void CDaoTableDef::RefreshLink()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOTableDef != NULL);

	DAO_CHECK(m_pDAOTableDef->RefreshLink());
}

//Implementation functions
void CDaoTableDef::InitFieldsCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAOTableDef->get_Fields(&m_pDAOFields));
}

void CDaoTableDef::InitIndexesCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAOTableDef->get_Indexes(&m_pDAOIndexes));
}

void CDaoTableDef::ThrowDaoException(int nAfxDaoError)
{
	ASSERT_VALID(this);

	AfxThrowDaoException(nAfxDaoError);
}

#ifdef _DEBUG
void CDaoTableDef::AssertValid() const
{
	CObject::AssertValid();
}

void CDaoTableDef::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CObject::Dump(dc);

	dc << _T("m_bOpen = ") << m_bOpen;
	dc << _T("\nm_bNew = ") << m_bNew;

	dc << _T("\n");
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////
// CDaoQueryDef
IMPLEMENT_DYNAMIC(CDaoQueryDef, CObject)

CDaoQueryDef::CDaoQueryDef(CDaoDatabase* pDatabase)
{
	m_bOpen = FALSE;
	m_bNew = FALSE;

	m_pDatabase = pDatabase;
	m_pDAOQueryDef = NULL;
	m_pDAOParameters = NULL;
	m_pDAOFields = NULL;
}

CDaoQueryDef::~CDaoQueryDef()
{
	if (IsOpen())
		Close();
	else if (m_bNew)
	{
		// Remove the querydef from the CDaoDatabase's map
		m_pDatabase->m_mapQueryDefs.RemoveKey(this);
	}
}

void CDaoQueryDef::Create(LPCTSTR lpszName, LPCTSTR lpszSQL)
{
	ASSERT_VALID(this);
	ASSERT(!IsOpen());

	// Create a temp querydef if lpszName is NULL or empty string
	if (lpszName == NULL || *lpszName == '\0')
	{
		DAO_CHECK(m_pDatabase->m_pDAODatabase->CreateQueryDef(
			COleVariant(_T(""), VT_BSTRT),
			COleVariant(lpszSQL, VT_BSTRT),
			&m_pDAOQueryDef));
		m_bOpen = TRUE;
	}
	else
	{
		// Create a template querydef
		// (preventing automatic append to QueryDefs collection)
		DAO_CHECK(m_pDatabase->m_pDAODatabase->CreateQueryDef(
			_afxOptionalVariant, _afxOptionalVariant, &m_pDAOQueryDef));
		m_bNew = TRUE;

		// Now set the name and SQL if necessary
		SetName(lpszName);
		if (lpszSQL != NULL)
			SetSQL(lpszSQL);
	}

	// Add the querydef to map of Open/New CDaoQueryDefs
	m_pDatabase->m_mapQueryDefs.SetAt(this, this);
}

void CDaoQueryDef::Append()
{
	ASSERT_VALID(this);
	ASSERT(m_bNew);
	ASSERT(m_pDAOQueryDef != NULL);

	DAOQueryDefs* pDAOQueryDefs;
	DAO_CHECK(m_pDatabase->m_pDAODatabase->get_QueryDefs(
		&pDAOQueryDefs));

	TRY
	{
		DAO_CHECK(pDAOQueryDefs->Append(m_pDAOQueryDef));
	}
	CATCH_ALL(e)
	{
		pDAOQueryDefs->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOQueryDefs->Release();

	m_bNew = FALSE;
	m_bOpen = TRUE;
}

// Open a pre-defined query or create a temp query
void CDaoQueryDef::Open(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(!m_bNew);

	// Re-open is not allowed
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	// Null lpszName implies create a temp query
	if (lpszName == NULL)
	{
		DAO_CHECK(m_pDatabase->m_pDAODatabase->CreateQueryDef(
			COleVariant(_T(""), VT_BSTRT), _afxOptionalVariant, &m_pDAOQueryDef));
	}
	else
	{
		COleVariant varName(lpszName, VT_BSTRT);
		DAO_CHECK(m_pDatabase->m_pDAODatabase->OpenQueryDef(
			V_BSTR(&varName), &m_pDAOQueryDef));
	}

	m_bOpen = TRUE;

	// Add the querydef to map of Open/New CDaoQueryDefs
	m_pDatabase->m_mapQueryDefs.SetAt(this, this);
}

void CDaoQueryDef::Close()
{
	ASSERT_VALID(this);

	if (m_pDAOParameters != NULL)
	{
		m_pDAOParameters->Release();
		m_pDAOParameters = NULL;
	}

	if (m_pDAOFields != NULL)
	{
		m_pDAOFields->Release();
		m_pDAOFields = NULL;
	}

	if (m_pDAOQueryDef != NULL)
	{
		// DAO Close is a no op, but call it anyway
		DAO_TRACE(m_pDAOQueryDef->Close());
		m_pDAOQueryDef->Release();
		m_pDAOQueryDef = NULL;
	}

	m_bOpen = FALSE;
	m_bNew = FALSE;

	// Remove the querydef from the CDaoDatabase's map
	m_pDatabase->m_mapQueryDefs.RemoveKey(this);
}

BOOL CDaoQueryDef::CanUpdate()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nUpdatable;
	DAO_CHECK(m_pDAOQueryDef->get_Updatable(&nUpdatable));
	return nUpdatable == AFX_DAO_TRUE;
}

CString CDaoQueryDef::GetName()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	COleVariant var;
	DAO_CHECK(m_pDAOQueryDef->get_Name(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoQueryDef::SetName(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAOQueryDef->put_Name(V_BSTR(&var)));
}

CString CDaoQueryDef::GetSQL()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	COleVariant var;
	DAO_CHECK(m_pDAOQueryDef->get_SQL(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoQueryDef::SetSQL(LPCTSTR lpszSQL)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);

	COleVariant var(lpszSQL, VT_BSTRT);
	DAO_CHECK(m_pDAOQueryDef->put_SQL(V_BSTR(&var)));
}

short CDaoQueryDef::GetType()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nType;
	DAO_CHECK(m_pDAOQueryDef->get_Type(&nType));
	return nType;
}

COleDateTime CDaoQueryDef::GetDateCreated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	COleVariant varDate;
	DAO_CHECK(m_pDAOQueryDef->get_DateCreated(&varDate));
	return varDate.date;
}

COleDateTime CDaoQueryDef::GetDateLastUpdated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	COleVariant varDate;
	DAO_CHECK(m_pDAOQueryDef->get_LastUpdated(&varDate));
	return varDate.date;
}

CString CDaoQueryDef::GetConnect()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	COleVariant var;
	DAO_CHECK(m_pDAOQueryDef->get_Connect(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoQueryDef::SetConnect(LPCTSTR lpszConnect)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);

	COleVariant var(lpszConnect, VT_BSTRT);
	DAO_CHECK(m_pDAOQueryDef->put_Connect(V_BSTR(&var)));
}

short CDaoQueryDef::GetODBCTimeout()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nTimeout;
	DAO_CHECK(m_pDAOQueryDef->get_ODBCTimeout(&nTimeout));
	return nTimeout;
}

void CDaoQueryDef::SetODBCTimeout(short nODBCTimeout)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);

	DAO_CHECK(m_pDAOQueryDef->put_ODBCTimeout(nODBCTimeout));
}

BOOL CDaoQueryDef::GetReturnsRecords()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nReturnsRecords;
	DAO_CHECK(m_pDAOQueryDef->get_ReturnsRecords(&nReturnsRecords));
	return nReturnsRecords == AFX_DAO_TRUE;
}

void CDaoQueryDef::SetReturnsRecords(BOOL bReturnsRecords)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);

	DAO_CHECK(m_pDAOQueryDef->put_ReturnsRecords(
		(short)(bReturnsRecords ? AFX_DAO_TRUE : AFX_DAO_FALSE)));
}

long CDaoQueryDef::GetRecordsAffected()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	long lRecordsAffected;
	DAO_CHECK(m_pDAOQueryDef->get_RecordsAffected(&lRecordsAffected));
	return lRecordsAffected;
}

void CDaoQueryDef::Execute(int nOptions)
{
	ASSERT_VALID(this);
	ASSERT(m_pDAOQueryDef != NULL);

	DAO_CHECK(m_pDAOQueryDef->Execute(COleVariant((long)nOptions)));
}

COleVariant CDaoQueryDef::GetParamValue(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOQueryDef != NULL);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	DAOParameter* pDAOParameter = NULL;
	COleVariant var;

	TRY
	{
		DAO_CHECK(m_pDAOParameters->get_Item(
			COleVariant(lpszName, VT_BSTRT), &pDAOParameter));
		DAO_CHECK(pDAOParameter->get_Value(&var));
	}
	CATCH_ALL(e)
	{
		if (pDAOParameter != NULL)
			pDAOParameter->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOParameter->Release();
	return var;
}

COleVariant CDaoQueryDef::GetParamValue(int nIndex)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAOQueryDef != NULL);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	DAOParameter* pDAOParameter = NULL;
	COleVariant var;

	TRY
	{
		DAO_CHECK(m_pDAOParameters->get_Item(
			COleVariant((long)nIndex), &pDAOParameter));
		DAO_CHECK(pDAOParameter->get_Value(&var));
	}
	CATCH_ALL(e)
	{
		if (pDAOParameter != NULL)
			pDAOParameter->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOParameter->Release();
	return var;
}

void CDaoQueryDef::SetParamValue(LPCTSTR lpszName,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOQueryDef != NULL);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	DAOParameter* pDAOParameter = NULL;

	TRY
	{
		DAO_CHECK(m_pDAOParameters->get_Item(
			COleVariant(lpszName, VT_BSTRT), &pDAOParameter));
		DAO_CHECK(pDAOParameter->put_Value(varValue));
	}
	CATCH_ALL(e)
	{
		if (pDAOParameter != NULL)
			pDAOParameter->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOParameter->Release();
}

void CDaoQueryDef::SetParamValue(int nIndex,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen() || m_bNew);
	ASSERT(m_pDAOQueryDef != NULL);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	DAOParameter* pDAOParameter = NULL;

	TRY
	{
		DAO_CHECK(m_pDAOParameters->get_Item(
			COleVariant((long)nIndex), &pDAOParameter));
		DAO_CHECK(pDAOParameter->put_Value(varValue));
	}
	CATCH_ALL(e)
	{
		if (pDAOParameter != NULL)
			pDAOParameter->Release();
		THROW_LAST();
	}
	END_CATCH_ALL

	pDAOParameter->Release();
}

void CDaoQueryDef::SetParamValueNull(LPCTSTR lpszName)
{
	ASSERT_VALID(this);

	SetParamValue(lpszName, _afxNullVariant);
}

void CDaoQueryDef::SetParamValueNull(int nIndex)
{
	ASSERT_VALID(this);

	SetParamValue(nIndex, _afxNullVariant);
}

short CDaoQueryDef::GetFieldCount()
{
	ASSERT_VALID(this);

	short nFields;

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	DAO_CHECK(m_pDAOFields->get_Count(&nFields));
	return nFields;
}

void CDaoQueryDef::GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant((long)nIndex), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

void CDaoQueryDef::GetFieldInfo(LPCTSTR lpszName,
	CDaoFieldInfo& fieldinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

short CDaoQueryDef::GetParameterCount()
{
	ASSERT_VALID(this);

	short nParameters;

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	DAO_CHECK(m_pDAOParameters->get_Count(&nParameters));
	return nParameters;
}

void CDaoQueryDef::GetParameterInfo(int nIndex,
	CDaoParameterInfo& paraminfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	// Get DAOParameter object and fill in parameter info struct
	DAOParameter* pDAOParameter;
	DAO_CHECK(m_pDAOParameters->get_Item(
		COleVariant((long)nIndex), &pDAOParameter));
	FillParameterInfo(pDAOParameter, paraminfo, dwInfoOptions);

	// Clean up
	pDAOParameter->Release();
}

void CDaoQueryDef::GetParameterInfo(LPCTSTR lpszName,
	CDaoParameterInfo& paraminfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOParameters == NULL)
		InitParametersCollection();

	// Get DAOParameter object and fill in parameter info struct
	DAOParameter* pDAOParameter;
	DAO_CHECK(m_pDAOParameters->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOParameter));
	FillParameterInfo(pDAOParameter, paraminfo, dwInfoOptions);

	// Clean up
	pDAOParameter->Release();
}

//Implementation functions
void CDaoQueryDef::InitFieldsCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAOQueryDef->get_Fields(&m_pDAOFields));
}

void CDaoQueryDef::InitParametersCollection()
{
	ASSERT_VALID(this);

	DAO_CHECK(m_pDAOQueryDef->get_Parameters(&m_pDAOParameters));
}

void CDaoQueryDef::FillParameterInfo(DAOParameter* pDAOParameter,
	CDaoParameterInfo& paraminfo, DWORD dwOptions)
{
	ASSERT_VALID(this);
	ASSERT(pDAOParameter != NULL);
	ASSERT(dwOptions != NULL);

	COleVariant var;

	if (dwOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		// All parameter info is basic info
		DAO_CHECK(pDAOParameter->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		paraminfo.m_strName = V_BSTRT(&var);

		TCHAR* pch = paraminfo.m_strName.GetBuffer(0);
		int nLength = lstrlen(pch);
		if (nLength > 0 && *pch == '[' && *(pch + nLength -1) == ']')
		{
			*(pch + nLength - 1) = 0;  // remove last bracket.
			Checked::memmove_s(pch, nLength * sizeof(TCHAR), 
				pch + 1, (nLength - 1) * sizeof(TCHAR));
		}

		paraminfo.m_strName.ReleaseBuffer(-1);

		DAO_CHECK(pDAOParameter->get_Type(
			&paraminfo.m_nType));

		DAO_CHECK(pDAOParameter->get_Value(
			&paraminfo.m_varValue));
	}
}

void CDaoQueryDef::ThrowDaoException(int nAfxDaoError)
{
	ASSERT_VALID(this);

	AfxThrowDaoException(nAfxDaoError);
}

#ifdef _DEBUG
void CDaoQueryDef::AssertValid() const
{
	CObject::AssertValid();
}

void CDaoQueryDef::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CObject::Dump(dc);

	dc << _T("m_bOpen = ") << m_bOpen;
	dc << _T("\nm_bNew = ") << m_bNew;

	dc << _T("\n");
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////
// CDaoRecordset
IMPLEMENT_DYNAMIC(CDaoRecordset, CObject )

CDaoRecordset::CDaoRecordset(CDaoDatabase* pDatabase)
{
	m_bOpen = FALSE;

	m_pMapFieldCache = NULL;
	m_pMapFieldIndex = NULL;
	m_bCheckCacheForDirtyFields = TRUE;

	m_prgDaoColBindInfo = NULL;
	m_pulColumnLengths = NULL;
	m_pbFieldFlags = NULL;
	m_pbParamFlags = NULL;

	m_pDAORecordset = NULL;
	m_pICDAORecordsetGetRows = NULL;
	m_pQueryDef = NULL;
	m_pTableDef = NULL;
	m_pDAOFields = NULL;
	m_pDAOIndexes = NULL;

	m_pDatabase = pDatabase;

	m_nDefaultType = dbOpenDynaset;
	m_nStatus = 0;
	m_nFields = 0;
	m_nParams = 0;
}

CDaoRecordset::~CDaoRecordset()
{
	if (IsOpen())
		Close();

	// Clean up database if necessary
	if (m_pDatabase != NULL && (m_nStatus & AFX_DAO_IMPLICIT_DB))
	{
		m_pDatabase->Close();
		delete m_pDatabase;
		m_pDatabase = NULL;
	}
}

void CDaoRecordset::Open(int nOpenType, LPCTSTR lpszSQL, int nOptions)
{
	ASSERT_VALID(this);
	ASSERT(nOpenType == AFX_DAO_USE_DEFAULT_TYPE ||
		nOpenType == dbOpenDynaset || nOpenType == dbOpenSnapshot ||
		nOpenType == dbOpenTable);

	// Re-Opening is invalid.
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	if (nOpenType == AFX_DAO_USE_DEFAULT_TYPE)
		m_nOpenType = m_nDefaultType;
	else
		m_nOpenType = nOpenType;

	// Snapshots readOnly in DAO model.
	if (m_nOpenType == dbOpenSnapshot)
		nOptions |= dbReadOnly;

	// Cache parameters and initialize
	m_nOptions = nOptions;
	m_cbFixedLengthFields = 0;

	// Cache information for use in Requery
	m_strRequerySQL = lpszSQL;
	m_strRequeryFilter = m_strFilter;
	m_strRequerySort = m_strSort;

	AllocDatabase();

	m_strSQL = lpszSQL;
	if (m_strSQL.IsEmpty())
		m_strSQL = GetDefaultSQL();

	// Open table directly if option specified
	if (m_nOpenType == dbOpenTable)
	{
		m_pTableDef = new CDaoTableDef(m_pDatabase);
		m_nStatus |= AFX_DAO_IMPLICIT_TD;

		TRY
		{
			// Must remove the bracket from the name
			StripBrackets(m_strSQL, m_strSQL.GetBuffer(0));
			m_strSQL.ReleaseBuffer();

			m_pTableDef->Open(m_strSQL);

			// Open the DAO recordset (implicit MoveFirst)
			DAO_CHECK(m_pTableDef->m_pDAOTableDef->OpenRecordset(
				COleVariant((long)m_nOpenType), COleVariant((long)m_nOptions),
				&m_pDAORecordset));
		}
		CATCH_ALL(e)
		{
			// Once recordset marked as open, Close handles this
			if (m_pTableDef->IsOpen())
				m_pTableDef->Close();
			delete m_pTableDef;
			THROW_LAST();
		}
		END_CATCH_ALL
	}
	else
	{
		m_pQueryDef = new CDaoQueryDef(m_pDatabase);
		m_nStatus |= AFX_DAO_IMPLICIT_QD;

		TRY
		{
			// If initial clause includes potential start of row returning
			// query, then SQL passed to Open must be valid
			// (Note: TABLE is valid for UNION-type queries)
			if ((_tcsnicmp(m_strSQL, _afxSelect2, _countof(_afxSelect2)-1) != 0) &&
				(_tcsnicmp(m_strSQL, _afxParameters2, _countof(_afxParameters2)-1) != 0) &&
				(_tcsnicmp(m_strSQL, _afxTransform2, _countof(_afxTransform2)-1) != 0) &&
				(_tcsnicmp(m_strSQL, _afxTable2, _countof(_afxTable2)-1) != 0))
			{
				BuildSQL();
			}
			else
			{
				// Add the filter and sort
				if (!m_strFilter.IsEmpty())
					m_strSQL += _afxWhere2 + m_strFilter;

				if (!m_strSort.IsEmpty())
					m_strSQL += _afxOrderBy2 + m_strSort;
			}

			// Create and define temp query
			m_pQueryDef->Open();
			m_pQueryDef->SetSQL(m_strSQL);

			BindParameters();
			// Open the DAO recordset (implicit MoveFirst)
			DAO_CHECK(m_pQueryDef->m_pDAOQueryDef->_30_OpenRecordset(
				COleVariant((long)m_nOpenType), COleVariant((long)m_nOptions),
				&m_pDAORecordset));
		}
		CATCH_ALL(e)
		{
			// Once recordset marked as open, Close handles this
			if (m_pQueryDef->IsOpen())
				m_pQueryDef->Close();
			delete m_pQueryDef;
			THROW_LAST();
		}
		END_CATCH_ALL
	}

	m_bOpen = TRUE;

	// Add the recordset to map of Open CDaoRecordsets
	m_pDatabase->m_mapRecordsets.SetAt(this, this);

	TRY
	{
		BindFields();
		GetDataAndFixupNulls();
		SetCursorAttributes();
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL
}

void CDaoRecordset::Open(CDaoQueryDef* pQueryDef, int nOpenType,
	int nOptions)
{
	ASSERT_VALID(this);
	// Must pass valid, open QueryDef
	ASSERT(pQueryDef != NULL);
	if (!pQueryDef->IsOpen())
		ThrowDaoException(AFX_DAO_ERROR_OBJECT_NOT_OPEN);

	// Re-Opening is invalid.
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	if (nOpenType == AFX_DAO_USE_DEFAULT_TYPE)
		m_nOpenType = m_nDefaultType;
	else
		m_nOpenType = nOpenType;

	// Can't open table type recordsets with QueryDef
	ASSERT(m_nOpenType == dbOpenDynaset || m_nOpenType == dbOpenSnapshot);

	// Snapshots readOnly in DAO model.
	if (m_nOpenType == dbOpenSnapshot)
		nOptions |= dbReadOnly;

	// Cache parameters and initialize
	m_nOptions = nOptions;
	m_cbFixedLengthFields = 0;

	// Use pre-defined query
	m_pQueryDef = pQueryDef;

	// Share the same database object
	m_pDatabase = m_pQueryDef->m_pDatabase;

	BindParameters();

	// Open the DAO recordset (implicit MoveFirst)
	DAO_CHECK(m_pQueryDef->m_pDAOQueryDef->_30_OpenRecordset(
		COleVariant((long)m_nOpenType), COleVariant((long)m_nOptions),
		&m_pDAORecordset));

	m_bOpen = TRUE;

	// Add the recordset to map of Open CDaoRecordsets
	m_pDatabase->m_mapRecordsets.SetAt(this, this);

	TRY
	{
		BindFields();
		GetDataAndFixupNulls();
		SetCursorAttributes();
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL
}

void CDaoRecordset::Open(CDaoTableDef* pTableDef, int nOpenType,
	int nOptions)
{
	ASSERT_VALID(this);
	// Must pass valid, open TableDef
	ASSERT(pTableDef != NULL);
	if (!pTableDef->IsOpen())
		ThrowDaoException(AFX_DAO_ERROR_OBJECT_NOT_OPEN);
	m_pTableDef = pTableDef;

	// Re-Opening is invalid.
	if (IsOpen())
	{
		ASSERT(FALSE);
		return;
	}

	if (nOpenType == AFX_DAO_USE_DEFAULT_TYPE)
		m_nOpenType = m_nDefaultType;
	else
		m_nOpenType = nOpenType;

	// Cache parameters and initialize
	m_nOptions = nOptions;
	m_cbFixedLengthFields = 0;

	// Share the same database object
	m_pDatabase = m_pTableDef->m_pDatabase;

	// Open the DAO recordset (implicit MoveFirst)
	DAO_CHECK(m_pTableDef->m_pDAOTableDef->OpenRecordset(
		COleVariant((long)m_nOpenType), COleVariant((long)m_nOptions),
		&m_pDAORecordset));

	m_bOpen = TRUE;

	// Add the recordset to map of Open CDaoRecordsets
	m_pDatabase->m_mapRecordsets.SetAt(this, this);

	TRY
	{
		BindFields();
		GetDataAndFixupNulls();
		SetCursorAttributes();
	}
	CATCH_ALL(e)
	{
		Close();
		THROW_LAST();
	}
	END_CATCH_ALL
}

void CDaoRecordset::Close()
{
	ASSERT_VALID(this);

	if (IsOpen())
		FreeCache();

	// Clean up name strings in ColBindInfo struct
	if (m_prgDaoColBindInfo != NULL)
	{
		for (int nIndex = 0; nIndex < m_nFields; nIndex++)
		{
#ifndef _UNICODE
			delete[] (LPTSTR)m_prgDaoColBindInfo[nIndex].columnID.lpstr;
			m_prgDaoColBindInfo[nIndex].columnID.lpstr = NULL;
#else
			delete[] (LPTSTR)m_prgDaoColBindInfo[nIndex].columnID.lpwstr;
			m_prgDaoColBindInfo[nIndex].columnID.lpwstr = NULL;
#endif
		}
	}

	delete[] m_prgDaoColBindInfo;
	m_prgDaoColBindInfo = NULL;

	delete[] m_pulColumnLengths;
	m_pulColumnLengths = NULL;

	delete[] m_pbFieldFlags;
	m_pbFieldFlags = NULL;

	if (m_pMapFieldIndex != NULL)
	{
		delete m_pMapFieldIndex;
		m_pMapFieldIndex = NULL;
	}

	if (m_pDAOIndexes != NULL)
	{
		m_pDAOIndexes->Release();
		m_pDAOIndexes = NULL;
	}

	if (m_pDAOFields != NULL)
	{
		m_pDAOFields->Release();
		m_pDAOFields = NULL;
	}

	if (m_pICDAORecordsetGetRows != NULL)
	{
		m_pICDAORecordsetGetRows->Release();
		m_pICDAORecordsetGetRows = NULL;
	}

	if (m_pDAORecordset != NULL)
	{
		DAO_TRACE(m_pDAORecordset->Close());
		m_pDAORecordset->Release();
		m_pDAORecordset = NULL;
	}

	// Cleanup TableDef if not user supplied
	if (m_pTableDef != NULL && m_nStatus & AFX_DAO_IMPLICIT_TD)
	{
		m_pTableDef->Close();
		delete m_pTableDef;
		m_pTableDef = NULL;
	}

	// Cleanup QueryDef if not user supplied
	if (m_pQueryDef != NULL && m_nStatus & AFX_DAO_IMPLICIT_QD)
	{
		m_pQueryDef->Close();
		delete m_pQueryDef;
		m_pQueryDef = NULL;
	}

	m_nStatus &= ~AFX_DAO_IMPLICIT_QD;
	m_nStatus &= ~AFX_DAO_IMPLICIT_TD;
	m_pQueryDef = NULL;
	m_pTableDef = NULL;

	m_bOpen = FALSE;

	// Remove the recordset from the CDaoDatabase's map
	m_pDatabase->m_mapRecordsets.RemoveKey(this);
}

void CDaoRecordset::Requery()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(CanRestart());

	// If filter or sort strings changed, must Close and Open
	// This is only effective if m_strFilter/m_strSort used
	if ((m_pQueryDef != NULL &&
		(m_nStatus & AFX_DAO_IMPLICIT_QD)) &&
		((m_strRequeryFilter != m_strFilter) ||
		(m_strRequerySort != m_strSort)))
	{
		Close();
		Open(m_nOpenType, m_strRequerySQL, m_nOptions);
	}
	else
	{
		// Rebind parameters in case values have changed
		BindParameters();

		if (m_pQueryDef != NULL)
		{
			COleVariant varDisp;
			varDisp.pdispVal = m_pQueryDef->m_pDAOQueryDef;
			varDisp.vt = VT_DISPATCH;

			TRY
			{
				DAO_CHECK(m_pDAORecordset->Requery(varDisp));
			}
			CATCH_ALL(e)
			{
				// Reset vt to prevent release of DAOQueryDef
				varDisp.vt = VT_EMPTY;
				THROW_LAST();
			}
			END_CATCH_ALL

			// Reset vt to prevent release of DAOQueryDef
			varDisp.vt = VT_EMPTY;
		}
		else
			// Must be a table type recordset (this will fail!)
			DAO_CHECK(m_pDAORecordset->Requery(_afxOptionalVariant));

		GetDataAndFixupNulls();
	}
}

CString CDaoRecordset::GetDefaultDBName()
{
	ASSERT_VALID(this);

	// Override and add UNC path to .MDB file
	return _T("");
}

CString CDaoRecordset::GetDefaultSQL()
{
	ASSERT_VALID(this);

	// Override and add table name or entire SQL SELECT statement
	return _T("");
}

void CDaoRecordset::DoFieldExchange(CDaoFieldExchange* /* pFX */)
{
	ASSERT_VALID(this);

	// Do nothing if dynamic binding, otherwise override and add DFX calls
}

BOOL CDaoRecordset::IsBOF() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nBOF;
	DAO_CHECK(m_pDAORecordset->get_BOF(&nBOF));
	return nBOF == AFX_DAO_TRUE;
}

BOOL CDaoRecordset::IsEOF() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nEOF;
	DAO_CHECK(m_pDAORecordset->get_EOF(&nEOF));
	return nEOF == AFX_DAO_TRUE;
}

BOOL CDaoRecordset::IsDeleted() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	return m_bDeleted;
}

BOOL CDaoRecordset::CanScroll() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	return m_bScrollable;
}

BOOL CDaoRecordset::CanUpdate() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nUpdatable;
	DAO_CHECK(m_pDAORecordset->get_Updatable(&nUpdatable));
	return nUpdatable == AFX_DAO_TRUE;
}

BOOL CDaoRecordset::CanAppend() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	return m_bAppendable;
}

BOOL CDaoRecordset::CanRestart()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	short nRestartable;
	DAO_CHECK(m_pDAORecordset->get_Restartable(&nRestartable));
	return nRestartable == AFX_DAO_TRUE;
}

BOOL CDaoRecordset::CanTransact()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nTransactions;
	DAO_CHECK(m_pDAORecordset->get_Transactions(&nTransactions));
	return nTransactions == AFX_DAO_TRUE;
}

BOOL CDaoRecordset::CanBookmark()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nBookmarkable;
	DAO_CHECK(m_pDAORecordset->get_Bookmarkable(&nBookmarkable));
	return nBookmarkable == AFX_DAO_TRUE;
}

CString CDaoRecordset::GetName()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_Name(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

short CDaoRecordset::GetType()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	short nType;
	DAO_CHECK(m_pDAORecordset->get_Type(&nType));
	return nType;
}

short CDaoRecordset::GetEditMode()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	short nEditMode;
	DAO_CHECK(m_pDAORecordset->get_EditMode(&nEditMode));
	return nEditMode;
}

CString CDaoRecordset::GetSQL() const
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	return m_strSQL;
}

COleDateTime CDaoRecordset::GetDateCreated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant varDate;
	DAO_CHECK(m_pDAORecordset->get_DateCreated(&varDate));
	return varDate.date;
}

COleDateTime CDaoRecordset::GetDateLastUpdated()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant varDate;
	DAO_CHECK(m_pDAORecordset->get_LastUpdated(&varDate));
	return varDate.date;
}

COleVariant CDaoRecordset::GetLastModifiedBookmark()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_LastModified(&var.parray));
	var.vt = VT_ARRAY | VT_UI1;

	return var;
}

CString CDaoRecordset::GetValidationRule()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_ValidationRule(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString CDaoRecordset::GetValidationText()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_ValidationText(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

CString CDaoRecordset::GetCurrentIndex()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_Index(&V_BSTR(&var)));
	var.vt = VT_BSTR;
	return V_BSTRT(&var);
}

void CDaoRecordset::SetCurrentIndex(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var(lpszName, VT_BSTRT);
	DAO_CHECK(m_pDAORecordset->put_Index(V_BSTR(&var)));

	// Refetch the data
	GetDataAndFixupNulls();
}

long CDaoRecordset::GetRecordCount()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	long lRecordCount;
	DAO_CHECK(m_pDAORecordset->get_RecordCount(&lRecordCount));
	return lRecordCount;
}

void CDaoRecordset::SetFieldDirty(void* pv, BOOL bDirty)
{
	ASSERT_VALID(this);

	if (m_nFields <= 0)
	{
		// Can't set fields dirty if no bound fields
		ASSERT(FALSE);
		return;
	}

	int nIndex = 0, nIndexEnd;

	if (pv == NULL)
		nIndexEnd = m_nFields - 1;
	else
	{
		nIndex = nIndexEnd = GetFieldIndex(pv);
		ASSERT(nIndex != AFX_DAO_DATA_NOT_FOUND);
	}

	while (nIndex <= nIndexEnd)
	{
		if (bDirty)
			SetDirtyFieldStatus(nIndex);
		else
			ClearDirtyFieldStatus(nIndex);
		nIndex++;
	}
}

BOOL CDaoRecordset::IsFieldDirty(void* pv)
{
	ASSERT_VALID(this);

	short nEditMode = GetEditMode();

	// Fields can't be dirty if not in edit/addnew mode or no fields bound
	if (nEditMode == dbEditNone || m_nFields <= 0)
		return FALSE;

	// Check if cache field values have changed and mark as dirty
	if (m_bCheckCacheForDirtyFields)
	{
		if (nEditMode == dbEditInProgress)
			MarkForEdit();
		else
			MarkForAddNew();
	}

	int nIndex = 0, nIndexEnd;

	if (pv == NULL)
		nIndexEnd = m_nFields - 1;
	else
	{
		// Get the field index to use status array
		nIndex = nIndexEnd = GetFieldIndex(pv);
		ASSERT(nIndex != AFX_DAO_DATA_NOT_FOUND);
	}

	BOOL bDirty = FALSE;

	while (nIndex <= nIndexEnd && !bDirty)
		bDirty = IsFieldStatusDirty(nIndex++);

	return bDirty;
}

void CDaoRecordset::SetFieldNull(void* pv, BOOL bNull)
{
	ASSERT_VALID(this);

	if (m_nFields <= 0)
	{
		ASSERT(FALSE);
		return;
	}

	if (bNull)
	{
		// Need field exchange to set value to PSEUDO NULL.
		CDaoFieldExchange fx(CDaoFieldExchange::SetFieldNull, this, pv);
		fx.m_nFieldFound = 0;
		DoFieldExchange(&fx);

		// If no field found, index will still be zero
		ASSERT(fx.m_nFieldFound != 0);
	}
	else
	{
		// Set status array not NULL. Don't need field exchange mechanism.
		int nIndex = 0, nIndexEnd;

		if (pv == NULL)
			nIndexEnd = m_nFields - 1;
		else
		{
			nIndex = nIndexEnd = GetFieldIndex(pv);
			ASSERT(nIndex != AFX_DAO_DATA_NOT_FOUND);
		}

		while (nIndex <= nIndexEnd)
		{
			ClearNullFieldStatus(nIndex);
			nIndex++;
		}
	}
}

BOOL CDaoRecordset::IsFieldNull(void* pv)
{
	ASSERT_VALID(this);

	if (m_nFields <= 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	int nIndex = 0, nIndexEnd;

	if (pv == NULL)
		nIndexEnd = m_nFields - 1;
	else
	{
		// Get the field index to use status array
		nIndex = nIndexEnd = GetFieldIndex(pv);
		ASSERT(nIndex != AFX_DAO_DATA_NOT_FOUND);
	}

	BOOL bNull = FALSE;

	while (nIndex <= nIndexEnd && !bNull)
		bNull = IsFieldStatusNull(nIndex++);

	return bNull;
}

BOOL CDaoRecordset::IsFieldNullable(void* pv)
{
	ASSERT_VALID(this);

	if (m_nFields <= 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	int nIndex = 0, nIndexEnd;

	if (pv == NULL)
		nIndexEnd = m_nFields - 1;
	else
	{
		// Get the field index to use status array
		nIndex = nIndexEnd = GetFieldIndex(pv);
		ASSERT(nIndex != AFX_DAO_DATA_NOT_FOUND);
	}

	BOOL bNullable = FALSE;

	while (nIndex <= nIndexEnd && !bNullable)
	{
		if (!IsFieldStatusNullableKnown(nIndex))
		{
			CDaoFieldInfo fieldinfo;
			GetFieldInfo(nIndex, fieldinfo, AFX_DAO_SECONDARY_INFO);
			bNullable = !fieldinfo.m_bRequired;
			if (bNullable)
				SetNullableFieldStatus(nIndex);
			SetNullableKnownFieldStatus(nIndex);
		}
		else
			bNullable = IsFieldStatusNullable(nIndex);

		nIndex++;
	}

	return bNullable;
}

short CDaoRecordset::GetFieldCount()
{
	ASSERT_VALID(this);

	short nFields;

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	DAO_CHECK(m_pDAOFields->get_Count(&nFields));
	return nFields;
}

void CDaoRecordset::GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant((long)nIndex), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

void CDaoRecordset::GetFieldInfo(LPCTSTR lpszName,
	CDaoFieldInfo& fieldinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	// Get DAOField object and fill in field info struct
	DAOField* pDAOField;
	DAO_CHECK(m_pDAOFields->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOField));
	AfxGetFieldInfo(pDAOField, fieldinfo, dwInfoOptions);

	// Clean up
	pDAOField->Release();
}

short CDaoRecordset::GetIndexCount()
{
	ASSERT_VALID(this);

	short nIndexes;

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	DAO_CHECK(m_pDAOIndexes->get_Count(&nIndexes));
	return nIndexes;
}

void CDaoRecordset::GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
	DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	// Get DAOField object and fill in field info struct
	DAOIndex* pDAOIndex;
	DAO_CHECK(m_pDAOIndexes->get_Item(
		COleVariant((long)nIndex), &pDAOIndex));
	AfxGetIndexInfo(pDAOIndex, indexinfo, dwInfoOptions);

	// Clean up
	pDAOIndex->Release();
}

void CDaoRecordset::GetIndexInfo(LPCTSTR lpszName,
	CDaoIndexInfo& indexinfo, DWORD dwInfoOptions)
{
	ASSERT_VALID(this);

	if (m_pDAOIndexes == NULL)
		InitIndexesCollection();

	// Get DAOField object and fill in field info struct
	DAOIndex* pDAOIndex;
	DAO_CHECK(m_pDAOIndexes->get_Item(
		COleVariant(lpszName, VT_BSTRT), &pDAOIndex));
	AfxGetIndexInfo(pDAOIndex, indexinfo, dwInfoOptions);

	// Clean up
	pDAOIndex->Release();
}

COleVariant CDaoRecordset::GetBookmark()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_Bookmark(&var.parray));
	var.vt = VT_ARRAY | VT_UI1;

	return var;
}

void CDaoRecordset::SetBookmark(COleVariant varBookmark)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_Bookmark(&varBookmark.parray));

	GetDataAndFixupNulls();
}

long CDaoRecordset::GetAbsolutePosition()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	long lPosition;
	DAO_CHECK(m_pDAORecordset->get_AbsolutePosition(&lPosition));
	return lPosition;
}

void CDaoRecordset::SetAbsolutePosition(long lPosition)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_AbsolutePosition(lPosition));

	GetDataAndFixupNulls();
}

float CDaoRecordset::GetPercentPosition()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	float fPosition;
	DAO_CHECK(m_pDAORecordset->get_PercentPosition(&fPosition));
	return fPosition;
}

void CDaoRecordset::SetPercentPosition(float fPosition)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_PercentPosition(fPosition));

	GetDataAndFixupNulls();
}

void CDaoRecordset::MoveNext()
{
	ASSERT_VALID(this);

	Move(AFX_DAO_NEXT);
}

void CDaoRecordset::MovePrev()
{
	ASSERT_VALID(this);

	Move(AFX_DAO_PREV);
}

void CDaoRecordset::MoveFirst()
{
	ASSERT_VALID(this);

	Move(AFX_DAO_FIRST);
}

void CDaoRecordset::MoveLast()
{
	ASSERT_VALID(this);

	Move(AFX_DAO_LAST);
}

void CDaoRecordset::Move(long lRows)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	switch(lRows)
	{
	case AFX_DAO_NEXT:
		DAO_CHECK(m_pDAORecordset->MoveNext());
		break;

	case AFX_DAO_PREV:
		DAO_CHECK(m_pDAORecordset->MovePrevious());
		break;

	case AFX_DAO_FIRST:
		DAO_CHECK(m_pDAORecordset->MoveFirst());
		break;

	case AFX_DAO_LAST:
		DAO_CHECK(m_pDAORecordset->_30_MoveLast());
		break;

	// General case
	default:
		// Call Move without getting Bookmark (using unitialized variant).
		DAO_CHECK(m_pDAORecordset->Move(lRows, COleVariant()));

	}

	GetDataAndFixupNulls();
}

BOOL CDaoRecordset::FindNext(LPCTSTR lpszFilter)
{
	ASSERT_VALID(this);

	return Find(AFX_DAO_NEXT, lpszFilter);
}

BOOL CDaoRecordset::FindPrev(LPCTSTR lpszFilter)
{
	ASSERT_VALID(this);

	return Find(AFX_DAO_PREV, lpszFilter);
}

BOOL CDaoRecordset::FindFirst(LPCTSTR lpszFilter)
{
	ASSERT_VALID(this);

	return Find(AFX_DAO_FIRST, lpszFilter);
}

BOOL CDaoRecordset::FindLast(LPCTSTR lpszFilter)
{
	ASSERT_VALID(this);

	return Find(AFX_DAO_LAST, lpszFilter);
}

BOOL CDaoRecordset::Find(long lType, LPCTSTR lpszFilter)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var(lpszFilter, VT_BSTRT);

	switch(lType)
	{
	default:
		// Invalid Find type!
		ASSERT(FALSE);

		// fall through to FindNext case

	case AFX_DAO_NEXT:
		DAO_CHECK(m_pDAORecordset->FindNext(V_BSTR(&var)));
		break;

	case AFX_DAO_PREV:
		DAO_CHECK(m_pDAORecordset->FindPrevious(V_BSTR(&var)));
		break;

	case AFX_DAO_FIRST:
		DAO_CHECK(m_pDAORecordset->FindFirst(V_BSTR(&var)));
		break;

	case AFX_DAO_LAST:
		DAO_CHECK(m_pDAORecordset->FindLast(V_BSTR(&var)));
		break;
	}

	BOOL bMatch = IsMatch();
	if (bMatch)
		GetDataAndFixupNulls();

	return bMatch;
}

BOOL CDaoRecordset::Seek(LPCTSTR lpszComparison, COleVariant* pKey1,
	COleVariant* pKey2, COleVariant* pKey3)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);
	ASSERT(m_nOpenType == dbOpenTable);

	// Must have at least one key
	ASSERT(pKey1 != NULL);

	COleVariant varComparison(lpszComparison, VT_BSTRT);

	DAO_CHECK(m_pDAORecordset->Seek(V_BSTR(&varComparison),
		pKey1 != NULL ? (VARIANT)*pKey1 : _afxOptionalVariant,
		pKey2 != NULL ? (VARIANT)*pKey2 : _afxOptionalVariant,
		pKey3 != NULL ? (VARIANT)*pKey3 : _afxOptionalVariant,
		_afxOptionalVariant, _afxOptionalVariant, _afxOptionalVariant,
		_afxOptionalVariant, _afxOptionalVariant, _afxOptionalVariant,
		_afxOptionalVariant, _afxOptionalVariant, _afxOptionalVariant,
		_afxOptionalVariant));

	BOOL bMatch = IsMatch();
	if (bMatch)
		GetDataAndFixupNulls();

	return bMatch;
}

BOOL CDaoRecordset::Seek(LPCTSTR lpszComparison, COleVariant* pKeyArray,
	WORD nKeys)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);
	ASSERT(m_nOpenType == dbOpenTable);

	// Must have at least one key and no more than 13
	ASSERT(nKeys > 0);
	ASSERT(nKeys < 14);

	COleVariant varComparison(lpszComparison, VT_BSTRT);
	LPVARIANT pVarArray[13];

	WORD nIndex;
	for (nIndex = 0; nIndex < nKeys; nIndex++)
		pVarArray[nIndex] = &pKeyArray[nIndex];

	for (;nIndex < 13; nIndex++)
		pVarArray[nIndex] = &_afxOptionalVariant;

	DAO_CHECK(m_pDAORecordset->Seek(V_BSTR(&varComparison),
		*pVarArray[0], *pVarArray[1], *pVarArray[2], *pVarArray[3],
		*pVarArray[4], *pVarArray[5], *pVarArray[6], *pVarArray[7],
		*pVarArray[8], *pVarArray[9], *pVarArray[10], *pVarArray[11],
		*pVarArray[12]));

	BOOL bMatch = IsMatch();
	if (bMatch)
		GetDataAndFixupNulls();

	return bMatch;
}

void CDaoRecordset::CancelUpdate()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->_30_CancelUpdate());

	// Restore cache if necessary
	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
		LoadFields();
}

void CDaoRecordset::SetLockingMode(BOOL bPessimistic)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_LockEdits(
		(short)(bPessimistic ? AFX_DAO_TRUE : AFX_DAO_FALSE)));
}

BOOL CDaoRecordset::GetLockingMode()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	short nLockEdits;
	DAO_CHECK(m_pDAORecordset->get_LockEdits(&nLockEdits));
	return nLockEdits == AFX_DAO_TRUE;
}

void CDaoRecordset::SetCacheStart(COleVariant varBookmark)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_CacheStart(&varBookmark.parray));
}

COleVariant CDaoRecordset::GetCacheStart()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	COleVariant var;
	DAO_CHECK(m_pDAORecordset->get_CacheStart(&var.parray));
	var.vt = VT_ARRAY | VT_UI1;

	return var;
}

void CDaoRecordset::SetCacheSize(long lSize)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->put_CacheSize(lSize));
}

long CDaoRecordset::GetCacheSize()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	long lSize;
	DAO_CHECK(m_pDAORecordset->get_CacheSize(&lSize));
	return lSize;
}

void CDaoRecordset::FillCache(long* pSize, COleVariant* pBookmark)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->FillCache(
		pSize != NULL ? (VARIANT)COleVariant(*pSize) : _afxOptionalVariant,
		pBookmark != NULL ? (VARIANT)*pBookmark : _afxOptionalVariant));
}

void CDaoRecordset::AddNew()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		short nEditMode = GetEditMode();
		if (nEditMode != dbEditAdd)
		{
			// Store fields if necessary (fields already stored if edit mode)
			if (nEditMode != dbEditInProgress)
			{
				AllocCache();
				StoreFields();
			}

			// Set all fields NULL and not dirty
			SetFieldNull(NULL);
			SetFieldDirty(NULL, FALSE);
		}
	}

	DAO_CHECK(m_pDAORecordset->AddNew());
}

void CDaoRecordset::Edit()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		short nEditMode = GetEditMode();
		if (nEditMode != dbEditInProgress)
		{
			if (nEditMode == dbEditNone)
			{
				// Save fields for restore/dirty checking later
				AllocCache();
				StoreFields();
				SetFieldDirty(NULL, FALSE);
			}
			else
				// Load in fields cached on AddNew call prior to Edit
				LoadFields();
		}
	}

	DAO_CHECK(m_pDAORecordset->Edit());
}

void CDaoRecordset::Update()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	int nMode = 0;

	// If caching, compare cache to current values and save state
	if (m_nFields > 0)
	{
		if (m_bCheckCacheForDirtyFields)
		{
			IsFieldDirty(NULL);
			nMode = GetEditMode();
		}

		// Set all field values of all fields marked dirty
		SetDirtyFields();
	}

	DAO_CHECK(m_pDAORecordset->_30_Update());

	// Restore data if data cached and were in add mode
	if (m_bCheckCacheForDirtyFields && m_nFields > 0 &&
		nMode == dbEditAdd)
	{
		LoadFields();
	}
}

void CDaoRecordset::Delete()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	DAO_CHECK(m_pDAORecordset->Delete());

	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		SetFieldNull(NULL);
		SetFieldDirty(NULL, FALSE);
	}

	m_bDeleted = TRUE;
}

COleVariant CDaoRecordset::GetFieldValue(LPCTSTR lpszName)
{
	COleVariant var;
	GetFieldValue(lpszName, var);
	return var;
}

COleVariant CDaoRecordset::GetFieldValue(int nIndex)
{
	COleVariant var;
	GetFieldValue(nIndex, var);
	return var;
}

void CDaoRecordset::GetFieldValue(LPCTSTR lpszName, COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	// Clear out variant
	varValue.Clear();

	// Use DAO optimization. get_Collect will get the field object from
	// the fields collection and fetch the value
	DAO_CHECK(m_pDAORecordset->get_Collect(
		COleVariant(lpszName, VT_BSTRT), &varValue));
}

void CDaoRecordset::GetFieldValue(int nIndex, COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	// Clear out variant
	varValue.Clear();

	// Use DAO optimization. get_Collect will get the field object from
	// the fields collection and fetch the value
	DAO_CHECK(m_pDAORecordset->get_Collect(
		COleVariant((long)nIndex), &varValue));
}

void CDaoRecordset::SetFieldValue(LPCTSTR lpszName,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	// Use DAO optimization. get_Collect will get the field object from
	// the fields collection and fetch the value
	DAO_CHECK(m_pDAORecordset->put_Collect(
		COleVariant(lpszName, VT_BSTRT), varValue));
}

void CDaoRecordset::SetFieldValue(int nIndex,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pDAORecordset != NULL);

	// Use DAO optimization. put_Collect will get the field object from
	// the fields collection and write the value
	DAO_CHECK(m_pDAORecordset->put_Collect(
		COleVariant((long)nIndex), varValue));
}

void CDaoRecordset::SetFieldValue(int nIndex,
	LPCTSTR lpszValue)
{
	COleVariant varValue(lpszValue, VT_BSTRT);
	SetFieldValue(nIndex, varValue);
}

void CDaoRecordset::SetFieldValue(LPCTSTR lpszName,
	LPCTSTR lpszValue)
{
	COleVariant varValue(lpszValue, VT_BSTRT);
	SetFieldValue(lpszName, varValue);
}

void CDaoRecordset::SetFieldValueNull(LPCTSTR lpszName)
{
	ASSERT_VALID(this);

	SetFieldValue(lpszName, _afxNullVariant);
}

void CDaoRecordset::SetFieldValueNull(int nIndex)
{
	ASSERT_VALID(this);

	SetFieldValue(nIndex, _afxNullVariant);
}

COleVariant CDaoRecordset::GetParamValue(LPCTSTR lpszName)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pQueryDef != NULL);

	return m_pQueryDef->GetParamValue(lpszName);
}

COleVariant CDaoRecordset::GetParamValue(int nIndex)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pQueryDef != NULL);

	return m_pQueryDef->GetParamValue(nIndex);
}

void CDaoRecordset::SetParamValue(LPCTSTR lpszName,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pQueryDef != NULL);

	m_pQueryDef->SetParamValue(lpszName, varValue);
}

void CDaoRecordset::SetParamValue(int nIndex,
	const COleVariant& varValue)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());
	ASSERT(m_pQueryDef != NULL);

	m_pQueryDef->SetParamValue(nIndex, varValue);
}

void CDaoRecordset::SetParamValueNull(LPCTSTR lpszName)
{
	ASSERT_VALID(this);

	SetParamValue(lpszName, _afxNullVariant);
}

void CDaoRecordset::SetParamValueNull(int nIndex)
{
	ASSERT_VALID(this);

	SetParamValue(nIndex, _afxNullVariant);
}

//Implementation functions
DWORD CDaoRecordset::GetFieldLength(int nFieldIndex)
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	return m_pulColumnLengths[nFieldIndex];
}

void CDaoRecordset::InitFieldsCollection()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	DAO_CHECK(m_pDAORecordset->get_Fields(&m_pDAOFields));
}

void CDaoRecordset::InitIndexesCollection()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	DAO_CHECK(m_pTableDef->m_pDAOTableDef->get_Indexes(&m_pDAOIndexes));
}

// "PARAMETERS <parameter list>;"
// "SELECT <select list> FROM <table list>"
// " WHERE <m_strFilter> ORDER BY <m_strSort>"
void CDaoRecordset::BuildSQL()
{
	ASSERT_VALID(this);

	// Assumes m_strSQL represents table list
	CString strTableName = m_strSQL;
	m_strSQL.Empty();

	if (m_nParams > 0)
		BuildParameterList();
	BuildSelectList();
	m_strSQL += _afxFrom2 + strTableName;

	if (!m_strFilter.IsEmpty())
	{
		m_strSQL += _afxWhere2;
		m_strSQL += m_strFilter;
	}

	if (!m_strSort.IsEmpty())
	{
		m_strSQL += _afxOrderBy2;
		m_strSQL += m_strSort;
	}
}

void CDaoRecordset::AllocDatabase()
{
	ASSERT_VALID(this);

	// Allocate and maintain database if necessary
	if (m_pDatabase == NULL)
	{
		m_pDatabase = new CDaoDatabase;
		m_pDatabase->m_nStatus |= AFX_DAO_IMPLICIT_DB;
		m_nStatus |= AFX_DAO_IMPLICIT_DB;
	}

	// Open Database if necessary
	if (!m_pDatabase->IsOpen())
		m_pDatabase->Open((LPCTSTR)GetDefaultDBName(), FALSE, FALSE, NULL);
}

void CDaoRecordset::BuildSelectList()
{
	ASSERT_VALID(this);
	ASSERT(m_nFields > 0);

	m_strSQL += _afxSelect2;

	CDaoFieldExchange fx(CDaoFieldExchange::AddToSelectList, this);
	DoFieldExchange(&fx);
}

void CDaoRecordset::BuildParameterList()
{
	ASSERT_VALID(this);
	ASSERT(m_nParams > 0);

	m_strSQL += _afxParameters2;

	CDaoFieldExchange fx(CDaoFieldExchange::AddToParameterList, this);
	DoFieldExchange(&fx);

	if (fx.m_nParam != 0)
		m_strSQL += _T(";");
	else
		m_strSQL.Empty();
}

void CDaoRecordset::BindFields()
{
	ASSERT_VALID(this);

	if (m_nFields > 0)
	{
		// Setup the DAO binding struct
		ASSERT(m_prgDaoColBindInfo == NULL);
		m_prgDaoColBindInfo = new DAOCOLUMNBINDING[m_nFields];
		memset(m_prgDaoColBindInfo, 0, sizeof(DAOCOLUMNBINDING) * m_nFields);
		m_pulColumnLengths = new DWORD[m_nFields];
		memset(m_pulColumnLengths, 0, sizeof(DWORD) * m_nFields);

		m_pbFieldFlags = new BYTE[m_nFields];
		memset(m_pbFieldFlags, 0, m_nFields);

		m_DaoFetchRows.cRowsRequested = 1;
		m_DaoFetchRows.dwFlags = DAOROWFETCH_BINDABSOLUTE;
		m_DaoFetchRows.pData = NULL;

		// Allocate the index map
		ASSERT(m_pMapFieldIndex == NULL);
		m_pMapFieldIndex = new CMapPtrToPtr;

		CDaoFieldExchange fx(CDaoFieldExchange::BindField, this);
		DoFieldExchange(&fx);
	}
}

void CDaoRecordset::BindParameters()
{
	ASSERT_VALID(this);

	if (m_nParams > 0)
	{
		// Since Jet treats non-bindable names as implicit parameters
		// this should catch some SQL syntax errors that would otherwise
		// appear to be uninitialized parameters.
		ASSERT(m_pQueryDef->GetParameterCount() == m_nParams);

		CDaoFieldExchange fx(CDaoFieldExchange::BindParam, this);
		DoFieldExchange(&fx);
	}
}

void CDaoRecordset::Fixup()
{
	ASSERT_VALID(this);

	CDaoFieldExchange fx(CDaoFieldExchange::Fixup, this);
	DoFieldExchange(&fx);
}

void CDaoRecordset::AllocCache()
{
	ASSERT_VALID(this);

	// Do nothing if caching disabled by master switch
	if (m_bCheckCacheForDirtyFields && m_nFields > 0 &&
		m_pMapFieldCache == NULL)
	{
		m_pMapFieldCache = new CMapPtrToPtr;

		CDaoFieldExchange fx(CDaoFieldExchange::AllocCache, this);
		DoFieldExchange(&fx);
	}
}

void CDaoRecordset::StoreFields()
{
	ASSERT_VALID(this);

	// Do nothing if caching disabled by master switch
	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		ASSERT(m_pMapFieldCache != NULL);
		CDaoFieldExchange fx(CDaoFieldExchange::StoreField, this);
		DoFieldExchange(&fx);
	}
}

void CDaoRecordset::LoadFields()
{
	ASSERT_VALID(this);

	// Do nothing if caching disabled by master switch
	if (m_bCheckCacheForDirtyFields && m_nFields > 0)
	{
		CDaoFieldExchange fx(CDaoFieldExchange::LoadField, this);
		DoFieldExchange(&fx);

		// Clear the dirty status flags
		SetFieldDirty(NULL, FALSE);
	}
}

void CDaoRecordset::FreeCache()
{
	ASSERT_VALID(this);

	// Do nothing if caching disabled by master switch
	if (m_bCheckCacheForDirtyFields && m_nFields > 0 &&
		m_pMapFieldCache != NULL)
	{
		// Free up dynamically allocated mem in cache
		CDaoFieldExchange fx(CDaoFieldExchange::FreeCache, this);

		// Delete any cached data
		void* pvKey;
		void* pvObject;
		POSITION pos = m_pMapFieldCache->GetStartPosition();
		while (pos != NULL)
		{
			m_pMapFieldCache->GetNextAssoc(pos, pvKey, pvObject);
	
			ENSURE(pvObject);
			fx.DeleteCacheValue((CDaoFieldCache*)pvObject, ((CDaoFieldCache*)pvObject)->m_nDataType);
		}
		m_pMapFieldCache->RemoveAll();

		delete m_pMapFieldCache;
		m_pMapFieldCache = NULL;
	}
}

void CDaoRecordset::MarkForAddNew()
{
	ASSERT_VALID(this);

	CDaoFieldExchange fx(CDaoFieldExchange::MarkForAddNew, this);
	DoFieldExchange(&fx);
}

void CDaoRecordset::MarkForEdit()
{
	ASSERT_VALID(this);

	CDaoFieldExchange fx(CDaoFieldExchange::MarkForEdit, this);
	DoFieldExchange(&fx);
}

int CDaoRecordset::GetFieldIndex(void* pv)
{
	ASSERT_VALID(this);
	ASSERT(m_pMapFieldIndex != NULL);

	void* pvIndex;

	if (!m_pMapFieldIndex->Lookup(pv, pvIndex))
		return AFX_DAO_DATA_NOT_FOUND;
	else
		// Index was stored rather than ptr, make it 0-based
		return ((int)(INT_PTR)pvIndex) - 1;
}

void CDaoRecordset::SetDirtyFields()
{
	ASSERT_VALID(this);

	if (m_pDAOFields == NULL)
		InitFieldsCollection();

	CDaoFieldExchange fx(CDaoFieldExchange::SetDirtyField, this);
	DoFieldExchange(&fx);
}

void CDaoRecordset::SetCursorAttributes()
{
	ASSERT_VALID(this);

	m_bScrollable = !(m_nOptions & dbForwardOnly);
	m_bAppendable = CanUpdate() ||
		(!(m_nOptions & dbReadOnly) && (m_nOptions & dbAppendOnly));
}

void CDaoRecordset::GetDataAndFixupNulls()
{
	ASSERT_VALID(this);

	// Don't need to do anything if no fields bound
	if (m_nFields > 0)
	{
		if (IsEOF() || IsBOF())
		{
			// If no current record, simple mark fields NULL
			if (m_nFields > 0)
				SetFieldNull(NULL);
		}
		else
		{
			if (m_pICDAORecordsetGetRows == NULL)
			{
				DAO_CHECK(m_pDAORecordset->QueryInterface(
					IID_ICDAORecordset, (void**)&m_pICDAORecordsetGetRows));
			}

			// Call GetRows to fill in the bound data
			SCODE scode = m_pICDAORecordsetGetRows->GetRows(
				0, m_nFields, m_prgDaoColBindInfo,
				m_cbFixedLengthFields, &m_DaoFetchRows);

			// Check for GetRows specific errors
			//  This is necessary as ICDAORecordset::GetRows
			//  errors are not appended to DAO errors collection
			if (FAILED(scode))
				ThrowGetRowsDaoException(scode);

			// Check to see if row deleted as it is just warning
			m_bDeleted = scode == S_RECORDDELETED;

			// Reset the status array
			ClearFieldStatusFlags();

			// Fixup Null fields
			Fixup();
		}
	}
}

BOOL CDaoRecordset::IsFieldStatusDirty(UINT nField)
{
	ASSERT_VALID(this);

	return ((m_pbFieldFlags[nField] & AFX_DAO_FIELD_FLAG_DIRTY) ==
		AFX_DAO_FIELD_FLAG_DIRTY);
}

void CDaoRecordset::SetDirtyFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] |= AFX_DAO_FIELD_FLAG_DIRTY;
}

void CDaoRecordset::ClearDirtyFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] &= ~AFX_DAO_FIELD_FLAG_DIRTY;
}

BOOL CDaoRecordset::IsFieldStatusNull(UINT nField)
{
	ASSERT_VALID(this);

	return ((m_pbFieldFlags[nField] & AFX_DAO_FIELD_FLAG_NULL) ==
		AFX_DAO_FIELD_FLAG_NULL);
}

void CDaoRecordset::SetNullFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] |= AFX_DAO_FIELD_FLAG_NULL;
}

void CDaoRecordset::ClearNullFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] &= ~AFX_DAO_FIELD_FLAG_NULL;
}

BOOL CDaoRecordset::IsFieldStatusNullable(UINT nField)
{
	ASSERT_VALID(this);

	return ((m_pbFieldFlags[nField] & AFX_DAO_FIELD_FLAG_NULLABLE) ==
		AFX_DAO_FIELD_FLAG_NULLABLE);
}

void CDaoRecordset::SetNullableFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] |= AFX_DAO_FIELD_FLAG_NULLABLE;
}

BOOL CDaoRecordset::IsFieldStatusNullableKnown(UINT nField)
{
	ASSERT_VALID(this);

	return ((m_pbFieldFlags[nField] & AFX_DAO_FIELD_FLAG_NULLABLE_KNOWN)
		== AFX_DAO_FIELD_FLAG_NULLABLE_KNOWN);
}

void CDaoRecordset::SetNullableKnownFieldStatus(UINT nField)
{
	ASSERT_VALID(this);

	m_pbFieldFlags[nField] |= AFX_DAO_FIELD_FLAG_NULLABLE_KNOWN;
}

void CDaoRecordset::ClearFieldStatusFlags()
{
	ASSERT_VALID(this);

	memset(m_pbFieldFlags, 0, m_nFields);
}

BOOL CDaoRecordset::IsMatch()
{
	ASSERT_VALID(this);
	ASSERT(IsOpen());

	short nNoMatch;

	DAO_CHECK(m_pDAORecordset->get_NoMatch(&nNoMatch));

	// Return TRUE if NoMatch is FALSE
	return nNoMatch == AFX_DAO_FALSE;
}

void AFX_CDECL CDaoRecordset::StripBrackets(_In_z_ LPCTSTR lpszSrc, _Pre_notnull_ _Post_z_ LPTSTR lpszDest)
{
	while (*lpszSrc != '\0')
	{
		// Ignore all brackets
		while (*lpszSrc == '[' || *lpszSrc == ']')
			lpszSrc = _tcsinc(lpszSrc);

		// Quit if at the end of the string
		if (*lpszSrc == '\0')
			break;

		// Copy the data and increment the buffers
		if (_istlead(*lpszSrc))
			*lpszDest++ = *lpszSrc++;
		*lpszDest++ = *lpszSrc++;
	}

	// Add the trailing '\0'
	*lpszDest = '\0';
}

void CDaoRecordset::ThrowDaoException(int nAfxDaoError)
{
	ASSERT_VALID(this);

	AfxThrowDaoException(nAfxDaoError);
}

#ifdef _DEBUG
void CDaoRecordset::AssertValid() const
{
	CObject::AssertValid();
}

void CDaoRecordset::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

	CObject::Dump(dc);

	dc << _T("\nm_bOpen = ") << m_bOpen;
	dc << _T("\nm_bAppendable = ") << m_bAppendable;
	dc << _T("\nm_bScrollable = ") << m_bScrollable;
	dc << _T("\nm_bDeleted = ") << m_bDeleted;

	dc << _T("\nm_nOpenType = ") << m_nOpenType;
	dc << _T("\nm_nDefaultType = ") << m_nDefaultType;
	dc << _T("\nm_nOptions = ") << m_nOptions;

	dc << _T("\nm_strSQL = ") << m_strSQL;
	dc << _T("\nm_strFilter = ") << m_strFilter;
	dc << _T("\nm_strSort = ") << m_strSort;
	dc << _T("\nm_strRequerySQL = ") << m_strRequerySQL;
	dc << _T("\nm_strRequeryFilter = ") << m_strRequeryFilter;
	dc << _T("\nm_strRequerySort = ") << m_strRequerySort;

	dc << _T("\nm_nFields = ") << m_nFields;
	dc << _T("\nm_nParams = ") << m_nParams;

	dc << _T("\nm_bCheckCacheForDirtyFields = ") << m_bCheckCacheForDirtyFields;
	dc << _T("\nm_nStatus = ") << m_nStatus;

	dc << _T("\n");
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////
// Helpers - implementation
void AFX_CDECL AfxGetFieldInfo(DAOField* pDAOField, CDaoFieldInfo& fieldinfo,
	DWORD dwInfoOptions)
{
	ASSERT(pDAOField != NULL);
	ASSERT(dwInfoOptions != 0);

	COleVariant var;
	short nBool;

	// Always fetch the Primary properties
	if (dwInfoOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAOField->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		fieldinfo.m_strName = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOField->get_Type(&fieldinfo.m_nType));

		DAO_CHECK(pDAOField->get_Size(&fieldinfo.m_lSize));

		DAO_CHECK(pDAOField->get_Attributes(&fieldinfo.m_lAttributes));
	}

	if (dwInfoOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAOField->get_OrdinalPosition(
			&fieldinfo.m_nOrdinalPosition));

		DAO_CHECK(pDAOField->get_Required(&nBool));
		fieldinfo.m_bRequired = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOField->get_AllowZeroLength(&nBool));
		fieldinfo.m_bAllowZeroLength = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOField->get_CollatingOrder(
			&fieldinfo.m_lCollatingOrder));

		DAO_CHECK(pDAOField->get_SourceField(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		fieldinfo.m_strSourceField = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOField->get_SourceTable(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		fieldinfo.m_strSourceTable = V_BSTRT(&var);
		var.Clear();

		TRY
		{
			DAO_CHECK(pDAOField->get_ForeignName(&V_BSTR(&var)));
			var.vt = VT_BSTR;
			fieldinfo.m_strForeignName = V_BSTRT(&var);
			var.Clear();
		}
		CATCH(CDaoException, e)
		{
			// If this property not appropriate, set foreign name empty
			if (e->m_scode != E_DAO_IllegalOperation)
				THROW_LAST();
			else
			{
				fieldinfo.m_strForeignName.Empty();
				e->Delete();
			}
		}
		END_CATCH
	}

	if (dwInfoOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		AfxGetDefaultValue(pDAOField, fieldinfo.m_strDefaultValue);

		DAO_CHECK(pDAOField->get_ValidationRule(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		fieldinfo.m_strValidationRule = V_BSTRT(&var);
		var.Clear();

		DAO_CHECK(pDAOField->get_ValidationText(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		fieldinfo.m_strValidationText = V_BSTRT(&var);
	}
}

void AFX_CDECL AfxSetFieldInfo(DAOField* pDAOField, CDaoFieldInfo& fieldinfo)
{
	// Assumes name, type and size set on direct DAO CreateField call
	ASSERT(pDAOField != NULL);

	if (fieldinfo.m_lAttributes != 0)
		DAO_CHECK(pDAOField->put_Attributes(fieldinfo.m_lAttributes));

	if (fieldinfo.m_nOrdinalPosition != 0)
	{
		DAO_CHECK(pDAOField->put_OrdinalPosition(
			fieldinfo.m_nOrdinalPosition));
	}

	if (fieldinfo.m_bRequired)
		DAO_CHECK(pDAOField->put_Required(AFX_DAO_TRUE));

	if (fieldinfo.m_bAllowZeroLength)
		DAO_CHECK(pDAOField->put_AllowZeroLength(AFX_DAO_TRUE));

	if (!fieldinfo.m_strForeignName.IsEmpty())
	{
		COleVariant var(fieldinfo.m_strForeignName, VT_BSTRT);
		DAO_CHECK(pDAOField->put_ForeignName(V_BSTR(&var)));
	}

	if (!fieldinfo.m_strValidationRule.IsEmpty())
	{
		COleVariant var(fieldinfo.m_strValidationRule, VT_BSTRT);
		DAO_CHECK(pDAOField->put_ValidationRule(V_BSTR(&var)));
	}

	if (!fieldinfo.m_strValidationText.IsEmpty())
	{
		COleVariant var(fieldinfo.m_strValidationText, VT_BSTRT);
		DAO_CHECK(pDAOField->put_ValidationText(V_BSTR(&var)));
	}

	if (!fieldinfo.m_strDefaultValue.IsEmpty())
	{
		AfxSetDefaultValue(pDAOField, fieldinfo.m_strDefaultValue);
	}
}

void AFX_CDECL AfxGetDefaultValue(DAOField* pDAOField, CString& strDefaultValue)
{
	COleVariant var;
	DAO_CHECK(pDAOField->get_DefaultValue(&var));
	strDefaultValue = V_BSTRT(&var);
}

void AFX_CDECL AfxSetDefaultValue(DAOField* pDAOField, CString& strDefaultValue)
{
	COleVariant var(strDefaultValue, VT_BSTRT);
	DAO_CHECK(pDAOField->put_DefaultValue(var));
}

void AFX_CDECL AfxGetIndexInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo,
	DWORD dwInfoOptions)
{
	ASSERT(pDAOIndex != NULL);
	ASSERT(dwInfoOptions != 0);

	COleVariant var;
	short nBool;

	if (dwInfoOptions & AFX_DAO_FETCH_PRIMARY_PROPERTIES)
	{
		DAO_CHECK(pDAOIndex->get_Name(&V_BSTR(&var)));
		var.vt = VT_BSTR;
		indexinfo.m_strName = V_BSTRT(&var);

		AfxGetIndexFieldInfo(pDAOIndex, indexinfo);
	}

	if (dwInfoOptions & AFX_DAO_FETCH_SECONDARY_PROPERTIES)
	{
		DAO_CHECK(pDAOIndex->get_Primary(&nBool));
		indexinfo.m_bPrimary = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOIndex->get_Unique(&nBool));
		indexinfo.m_bUnique = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOIndex->get_Clustered(&nBool));
		indexinfo.m_bClustered = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOIndex->get_IgnoreNulls(&nBool));
		indexinfo.m_bIgnoreNulls = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOIndex->get_Required(&nBool));
		indexinfo.m_bRequired = nBool == AFX_DAO_TRUE;

		DAO_CHECK(pDAOIndex->get_Foreign(&nBool));
		indexinfo.m_bForeign = nBool == AFX_DAO_TRUE;
	}

	if (dwInfoOptions & AFX_DAO_FETCH_ALL_PROPERTIES)
	{
		DAO_CHECK(pDAOIndex->get_DistinctCount(
			&indexinfo.m_lDistinctCount));
	}
}

void AFX_CDECL AfxSetIndexInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo)
{
	// Assumes name,set on direct DAO CreateIndex call
	ASSERT(pDAOIndex != NULL);

	AfxSetIndexFieldInfo(pDAOIndex, indexinfo);

	if (indexinfo.m_bPrimary)
		DAO_CHECK(pDAOIndex->put_Primary(AFX_DAO_TRUE));

	if (indexinfo.m_bUnique)
		DAO_CHECK(pDAOIndex->put_Unique(AFX_DAO_TRUE));

	if (indexinfo.m_bClustered)
		DAO_CHECK(pDAOIndex->put_Clustered(AFX_DAO_TRUE));

	if (indexinfo.m_bIgnoreNulls)
		DAO_CHECK(pDAOIndex->put_IgnoreNulls(AFX_DAO_TRUE));

	if (indexinfo.m_bRequired)
		DAO_CHECK(pDAOIndex->put_Required(AFX_DAO_TRUE));
}

void AFX_CDECL AfxGetIndexFields(DAOIndex* pDAOIndex,
	DAOIndexFields** ppDAOIndexFields)
{
	COleVariant var;

	// Set the desired interface
#ifdef _UNICODE
	const GUID& guidIndexFields = IID_IDAOIndexFieldsW;
#else
	const GUID& guidIndexFields = IID_IDAOIndexFields;
#endif

	// Get dispatch pointer to fields collection
	DAO_CHECK(pDAOIndex->get_Fields(&var));
	DAO_CHECK(var.pdispVal->QueryInterface(
		guidIndexFields, (void**)ppDAOIndexFields));
}

void AFX_CDECL AfxGetIndexFieldInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo)
{
	COleVariant var;

	DAOIndexFields* pDAOIndexFields = NULL;
	DAOField* pDAOField = NULL;

	// Get the index fields collection
	AfxGetIndexFields(pDAOIndex, &pDAOIndexFields);

	TRY
	{
		// Get the number of fields in the index
		short nCount;
		DAO_CHECK(pDAOIndexFields->get_Count(&nCount));

		// Allocate or reallocate memory for array if necessary
		if (nCount != indexinfo.m_nFields)
		{
			if (indexinfo.m_nFields != 0)
			{
				// Check that allocation is correct.
				ASSERT(indexinfo.m_nFields == 0 ||
					indexinfo.m_bCleanupFieldInfo);

				delete[] indexinfo.m_pFieldInfos;
				indexinfo.m_pFieldInfos = NULL;
			}

			// Now allocate required memory
			indexinfo.m_pFieldInfos = new CDaoIndexFieldInfo[nCount];
			indexinfo.m_bCleanupFieldInfo = TRUE;
			indexinfo.m_nFields = nCount;
		}

		// Now get field info for each field
		long lAttributes;
		for (short nIndex = 0; nIndex < indexinfo.m_nFields; nIndex++)
		{
			// Set the desired interface
#ifdef _UNICODE
		   const GUID& guidField = IID_IDAOFieldW;
#else
		   const GUID& guidField = IID_IDAOField;
#endif

			// Get the field item
			DAO_CHECK(pDAOIndexFields->get_Item(COleVariant(nIndex), &var));
			DAO_CHECK(var.pdispVal->QueryInterface(
				guidField, (void**)&pDAOField));
			var.Clear();

			// Get the field name
			DAO_CHECK(pDAOField->get_Name(&V_BSTR(&var)));
			var.vt = VT_BSTR;
			indexinfo.m_pFieldInfos[nIndex].m_strName = V_BSTRT(&var);

			// Get the field attributes
			DAO_CHECK(pDAOField->get_Attributes(&lAttributes));
			indexinfo.m_pFieldInfos[nIndex].m_bDescending =
				(lAttributes & dbDescending);

			// Release and reset the field object
			pDAOField->Release();
			pDAOField = NULL;
		}

		// Release the index fields object
		pDAOIndexFields->Release();
	}
	CATCH_ALL(e)
	{
		// Release the field object if necessary
		if (pDAOField != NULL)
			pDAOField->Release();

		// Must always release index fields collection
		pDAOIndexFields->Release();
		THROW_LAST();
	}
	END_CATCH_ALL
}

void AFX_CDECL AfxSetIndexFieldInfo(DAOIndex* pDAOIndex, CDaoIndexInfo& indexinfo)
{
	COleVariant var;
	long lAttributes;

	DAOIndexFields* pDAOIndexFields = NULL;
	DAOField* pDAOField = NULL;

	// Get the index fields collection
	AfxGetIndexFields(pDAOIndex, &pDAOIndexFields);

	TRY
	{
		for (int nIndex = 0; nIndex < indexinfo.m_nFields; nIndex++)
		{
			// Create the field and set the name
			DAO_CHECK(pDAOIndex->CreateField(
				COleVariant(indexinfo.m_pFieldInfos[nIndex].m_strName, VT_BSTRT),
				_afxOptionalVariant, _afxOptionalVariant, &pDAOField));

			// Set the descending property
			if (indexinfo.m_pFieldInfos[nIndex].m_bDescending)
				lAttributes = dbDescending;
			else
				lAttributes = 0;
			DAO_CHECK(pDAOField->put_Attributes(lAttributes));

			// Append field to collection, release and reset
			pDAOIndexFields->Append(pDAOField);
			pDAOField->Release();
			pDAOField = NULL;
		}

		// Always release the index fields object
		pDAOIndexFields->Release();
	}
	CATCH_ALL(e)
	{
		if (pDAOField != NULL)
			pDAOField->Release();

		pDAOIndexFields->Release();
		THROW_LAST();
	}
	END_CATCH_ALL
}

//////////////////////////////////////////////////////////////////////////////
// GetRows helper
void AFX_CDECL ThrowGetRowsDaoException(SCODE scode)
{
	switch (scode)
	{
		case E_OUTOFMEMORY:
			AfxThrowMemoryException();

		default:
			AfxThrowDaoException(NO_AFX_DAO_ERROR, scode);

		// These are only (known) DAO 3.0 GetRows errors
		case E_ROWTOOSHORT:
		case E_BADBINDINFO:
		case E_COLUMNUNAVAILABLE:
			break;
	}

	CDaoException* pException;
	pException = new CDaoException;
	pException->m_pErrorInfo = new CDaoErrorInfo;

	// Fill out the DAO error info struct
	pException->m_scode = scode;
	pException->m_pErrorInfo->m_strSource = _T("ICDAORecordset.GetRows");
	pException->m_pErrorInfo->m_lErrorCode = LOWORD(scode);

	// There is no help context or help file
	pException->m_pErrorInfo->m_lHelpContext = 0;

	int nID = 0;

	if (scode == E_ROWTOOSHORT)
		nID = AFX_IDP_DAO_ROWTOOSHORT;
	else if (scode == E_BADBINDINFO)
		nID = AFX_IDP_DAO_BADBINDINFO;
	else
		nID = AFX_IDP_DAO_COLUMNUNAVAILABLE;

	VERIFY(pException->m_pErrorInfo->m_strDescription.LoadString(nID));

	TRACE(traceDatabase, 0, _T("\nError Code = %d\n"),
		pException->m_pErrorInfo->m_lErrorCode);
	TRACE(traceDatabase, 0, _T("Source = %s\n"),
		(LPCTSTR)pException->m_pErrorInfo->m_strSource);
	TRACE(traceDatabase, 0, _T("Description = %s\n"),
		(LPCTSTR)pException->m_pErrorInfo->m_strDescription);

	THROW(pException);
}

//////////////////////////////////////////////////////////////////////////////
// _AFX_DAO_STATE helper
_AFX_DAO_STATE* AFX_CDECL AfxGetDaoState()
{
	/